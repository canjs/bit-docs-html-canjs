{
  "steal-stache": {
    "src": {
      "path": "node_modules/steal-stache/steal-stache.md"
    },
    "body": "\n\n## Use\n\nWith [StealJS](http://stealjs.com) used from `node_modules`, steal-stache will configure Steal so stache modules can be loaded like:\n\n```js\nimport todosStache from \"todos.stache\"\ntodosStache([{name: \"dishes\"}]) //-> <documentFragment>\n```\n\n## Specifying Dependencies\n\nThis plugin allows [can-view-import &lt;can-import&gt;] elements that specify \ntemplate dependencies:\n\n\n```\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\n",
    "description": "\nA [StealJS](http://stealjs.com) extension that allows stache templates as dependencies.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "steal-stache",
    "parent": "can-ecosystem",
    "signatures": [
      {
        "code": "STACHE_MODULE_NAME!steal-stache",
        "description": "\n\nImport a [can-stache stache] module in your code and use it to render.\n\n```js\nvar template = require(\"./main.stache\");\nvar Map = require(\"can-map\");\n\nvar map = new Map();\nvar frag = template(map);\n\n// frag is a live-bound DocumentFragment\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "name": "STACHE_MODULE_NAME",
            "description": "The module name of a stache template. This\nwill typically be something like `templates/main.stache`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A renderer function that will render the template into a document fragment.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "moduleName"
        }
      ],
      "name": "STACHE_MODULE_NAME",
      "description": "The module name of a stache template. This\nwill typically be something like `templates/main.stache`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A renderer function that will render the template into a document fragment.\n"
    },
    "comment": " "
  },
  "Component": {
    "name": "Component",
    "type": "add",
    "description": "undefined\n"
  },
  "Component.static": {
    "src": {
      "line": 40,
      "codeLine": 44,
      "path": "node_modules/can-component/can-component.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "Component.static",
    "parent": "Component",
    "title": "static"
  },
  "Component.prototype": {
    "src": {
      "line": 91,
      "codeLine": 94,
      "path": "node_modules/can-component/can-component.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "Component.prototype",
    "parent": "Component",
    "title": "prototype"
  },
  "can-component": {
    "src": {
      "path": "node_modules/can-component/docs/component.md"
    },
    "body": "\n\n## Use\n\nTo create a Component, you must first [can-component.extend extend] `Component`\nwith the methods and properties of how your component behaves:\n\n    Component.extend({\n      tag: \"hello-world\",\n      template: stache(\"{{#if visible}}{{message}}{{else}}Click me{{/if}}\"),\n      viewModel: {\n        visible: false,\n        message: \"Hello There!\"\n      },\n      events: {\n        click: function(){\n        \tthis.viewModel.attr(\"visible\", !this.viewModel.attr(\"visible\") );\n        }\n      }\n    });\n\nThis element says \"Click me\" until a user clicks it and then \nsays \"Hello There!\".  To create a a instance of this component on the page, \nadd `<hello-world></hello-world>` to a mustache template, render\nthe template and insert the result in the page like:\n\n    var template = stache(\"<hello-world></hello-world>\");\n    $(document.body).append( template() );\n\nCheck this out here:\n\n<div class='demo_wrapper' data-demo-src='can/component/examples/click_me.html'></div>\n\n\nTypically, you do not append a single component at a time.  Instead, \nyou'll render a template with many custom tags like:\n\n    <srchr-app>\n      <srchr-search models=\"models\">\n        <input name=\"search\"/>\n      </srchr-search>\n      <ui-panel>\n        <srchr-history/>\n        <srchr-results models=\"models\"/>\n      </ui-panel>\n    </srchr-app>\n\n### Creating a Component\n\nUse [can-component.extend] to create a `Component` constructor function\nthat will automatically get initialized whenever the component's tag is \nfound. \n\nNote that inheriting from components works differently than other CanJS APIs. You \ncan't call `.extend` on a particular component to create a \"subclass\" of that component. \n\nInstead, components work more like HTML elements. To reuse functionality from a base component, build on top of it with parent \ncomponents that wrap other components in their template and pass any needed viewModel properties via attributes.\n\n### Tag\n\nA component's [can-component::tag tag] is the element node name that\nthe component will be created on.\n\n\nThe following matches `<hello-world>` elements.\n\n    Component.extend({\n      tag: \"hello-world\"\n    });\n\n### Template\n\nA component's [can-component::template template] is rendered as\nthe element's innerHTML.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      template: stache(\"<h1>Hello World</h1>\")\n    });\n\nChanges `<hello-world></hello-world>` elements into:\n\n    <hello-world><h1>Hello World</h1></hello-world>\n\nUse the `<content/>` tag to position the custom element's source HTML.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      template: stache(\"<h1><content/></h1>\")\n    });\n\nChanges `<hello-world>Hi There</hello-world>` into:\n\n    <hello-world><h1>Hi There</h1></hello-world>\n\n### viewModel\n\nA component's [can-component::viewModel viewModel] defines a Map that\nis used to render the component's template. The maps properties \nare typically set by attribute [can-stache-bindings bindings] on the custom element. \nBy default, every attribute's value is looked up in the parent viewModel\nof the custom element and added to the viewModel object.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      template: stache(\"<h1>{{message}}</h1>\")\n    });\n\nChanges the following rendered template:\n\n    var template = stache(\"<hello-world {message}='greeting'/>\");\n    template({\n      greeting: \"Salutations\"\n    })\n\nInto:\n\n    <hello-world><h1>Salutations</h1></hello-world>\n\nDefault values can be provided. The following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      template: stache(\"<h1>{{message}}</h1>\"),\n      viewModel: {\n        message: \"Hi\"\n      }\n    });\n\nChanges the following rendered template:\n\n    var template = stache(\"<hello-world/>\");\n    template({})\n\nInto:\n\n    <hello-world><h1>Hi</h1></hello-world>\n\nIf you want to set the string value of the attribute on viewModel,\nset an attribute without any binding syntax.\n\nThe following template, with the previous `\"hello-world\"` component:\n\n    var template = stache(\"<hello-world message='Howdy'/>\");\n    template({})\n\nRenders to:\n\n    <hello-world><h1>Howdy</h1></hello-world>\n\n### Events\n\nA component's [can-component::events events] object is used to listen to events (that are not\nlistened to with [can-stache-bindings view bindings]). The following component\nadds \"!\" to the message every time `<hello-world>` is clicked:\n\n    Component.extend({\n      tag: \"hello-world\",\n      template: stache(\"<h1>{{message}}</h1>\"),\n      events: {\n        \"click\" : function(){\n          var currentMessage = this.viewModel.attr(\"message\");\n          this.viewModel.attr(\"message\", currentMessage+ \"!\")\n        }\n      }\n    });\n\nComponents have the ability to bind to special inserted and removed events \nthat are called when a component's tag has been inserted into or removed from the page.\n\n### Helpers\n\nA component's [can-component::helpers helpers] object provides [can-stache.helper stache helper] functions\nthat are available within the component's template.  The following component\nonly renders friendly messages:\n\n    Component.extend({\n      tag: \"hello-world\",\n      template: stache(\"{{#isFriendly message}}\"+\n                  \"<h1>{{message}}</h1>\"+\n                \"{{/isFriendly}}\"),\n      helpers: {\n        isFriendly: function(message, options){\n          if( /hi|hello|howdy/.test(message) ) {\n            return options.fn();\n          } else {\n            return options.inverse();\n          }\n        }\n      }\n    });\n\n## Differences between components in can-stache\n\nA [can-mustache] template passes values from the viewModel to a `Component`\nby specifying the key of the value in the attribute directly.  For example:\n\n    Component.extend({\n      tag: \"my-tag\",\n      template: \"<h1>{{greeting}}</h1>\"\n    });\n\n    var template = stache(\"<my-tag greeting='message'></my-tag>\");\n    \n    var frag = template({\n      message: \"Hi\"\n    });\n    \n    frag //-> <my-tag greeting='message'><h1>Hi</h1></my-tag>\n   \nWith [can-stache], you wrap the attribute name with `{}` for parent to child binding. For example:\n\n    Component.extend({\n      tag: \"my-tag\",\n      template: stache(\"<h1>{{greeting}}</h1>\")\n    });\n    var template = stache(\"<my-tag {greeting}='message'></my-tag>\");\n    \n    var frag = template({\n      message: \"Hi\"\n    });\n   \n    frag //-> <my-tag {greeting}='message'><h1>Hi</h1></my-tag>\n\nIf the key was not wrapped, the template would render:\n\n    frag //-> <my-tag greeting='message'><h1>message</h1></my-tag>\n \nBecause the attribute value would be passed as the value of `greeting`.\n\n## Examples\n\nCheck out the following examples built with `Component`.\n\n### Tabs\n\nThe following demos a tabs widget.  Click \"Add Vegetables\"\nto add a new tab.\n\n<div class='demo_wrapper' data-demo-src='can/component/examples/tabs.html'></div>\n\nAn instance of the tabs widget is created by creating `<tabs>` and `<panel>`\nelements like:\n\n    <tabs>\n      {{#each foodTypes}}\n        <panel title='title'>{{content}}</panel>\n      {{/each}}\n    </tabs>\n\nTo add another panel, all we have to do is add data to `foodTypes` like:\n\n    foodTypes.push({\n      title: \"Vegetables\",\n      content: \"Carrots, peas, kale\"\n    })\n\nThe secret is that the `<panel>` element listens to when it is inserted\nand adds its data to the tabs' list of panels with:\n\n    this.element.parent().viewModel().addPanel( this.viewModel );\n\n### TreeCombo\n\nThe following tree combo lets people walk through a hierarchy and select locations.\n\n<div class='demo_wrapper' data-demo-src='can/component/examples/treecombo.html'></div>\n\nThe secret to this widget is the viewModel's `breadcrumb` property, which is an array\nof items the user has navigated through, and `selectableItems`, which represents the children of the\nlast item in the breadcrub.  These are defined on the viewModel like:\n\n\n    breadcrumb: [],\n    selectableItems: function(){\n      var breadcrumb = this.attr(\"breadcrumb\");\n\t      \t\n      // if there's an item in the breadcrumb\n      if(breadcrumb.attr('length')){\n\t\t\t\n        // return the last item's children\n        return breadcrumb.attr(\"\"+(breadcrumb.length-1)+'.children');\n      } else{\n\t\t    \n        // return the top list of items\n        return this.attr('items');\n      }\n    }\n\nWhen the \"+\" icon is clicked next to each item, the viewModel's `showChildren` method is called, which\nadds that item to the breadcrumb like:\n\n    showChildren: function( item, ev ) {\n      ev.stopPropagation();\n      this.attr('breadcrumb').push(item)\n    },\n\n### Paginate\n\nThe following example shows 3 \nwidget-like components: a grid, next / prev buttons, and a page count indicator. And, it shows an application component that puts them all together.\n\n<div class='demo_wrapper' data-demo-src='can/component/examples/paginate.html'></div>\n\nThis demo uses a `Paginate` [can-map] to assist with maintaining a paginated state:\n\n    var Paginate = Map.extend({\n    ...\n    });\n    \nThe `app` component, using the [can-map-define define plugin], creates an instance of the `Paginate` model\nand a `websitesPromise` that represents a request for the Websites\nthat should be displayed.\n\n    viewModel: {\n      define: {\n        paginate: {\n          value: function() {\n            return new Paginate({\n              limit: 5\n            });\n          }\n        },\n        websitesPromise: {\n          get: function() {\n            var params = {\n                  limit: this.attr('paginate.limit'),\n                  offset: this.attr('paginate.offset')\n              },\n              websitesPromise = Website.findAll(params),\n              self = this;\n  \n            websitesPromise.then(function(websites) {\n              self.attr('paginate.count', websites.count);\n            });\n    \n            return websitesPromise;\n          }\n        }\n      }\n    }\n\nThe `app` control passes paginate, paginate's values, and websitesPromise to\nits sub-components:\n\n    <app>\n      <grid {promise-data}='websitesPromise'>\n        {{#each items}}\n          <tr>\n            <td width='40%'>{{name}}</td>\n            <td width='70%'>{{url}}</td>\n          </tr>\n        {{/each}}\n      </grid>\n      <next-prev {paginate}='paginate'></next-prev>\n      <page-count {page}='paginate.page' {count}='paginate.pageCount'/>\n    </app>\n\n## IE 8 Support\n\nWhile CanJS does support Internet Explorer 8 out of the box, if you decide\nto use `Component` then you will need to include [HTML5 Shiv](https://github.com/aFarkas/html5shiv)\nin order for your custom tags to work properly.\n\nFor namespaced tag names (e.g. `<can:example>`) and hyphenated tag names (e.g. `<can-example>`) to work properly, you will \nneed to use version 3.7.2 or later.\n\n## Videos\n\nWatch this video for an overview of [can-component], why you should use it, and a hello world example:\n\n<iframe width=\"662\" height=\"372\" src=\"https://www.youtube.com/embed/BM1Jc3lVUrk\" frameborder=\"0\" allowfullscreen></iframe>\n\nThis video provides a more in depth overview of the API and goes over several examples of Components:\n\n<iframe width=\"662\" height=\"372\" src=\"https://www.youtube.com/embed/ogX765S4iuc\" frameborder=\"0\" allowfullscreen></iframe>\n\nNote: the videos above reference the `scope` property, which was replaced by the [can-component::viewModel viewModel] property in 2.2.\n\n",
    "description": "Create widgets that use a template, a view-model  and custom tags.\n\n",
    "name": "can-component",
    "type": "module",
    "title": "can-component",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "download": "can/component",
    "test": "can/component/test.html",
    "parent": "can-core",
    "release": "2.0",
    "link": "../docco/component/component.html docco",
    "signatures": [
      {
        "code": "< TAG BINDINGS... >",
        "description": "\n\n  Create an instance of a component on a particular tag in a [can-stache] template.\n  In 2.3, use the [can-stache-bindings bindings] syntaxes to setup bindings.\n\n  ",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "TAG",
            "description": "An HTML tag name that matches the [can-component::tag tag]\nproperty of the component.\n"
          },
          {
            "types": [
              {
                "type": "can-stache-bindings"
              }
            ],
            "name": "BINDINGS",
            "description": "Use the following binding syntaxes\nto connect the component's [can-component::viewModel] to the template's [can-view-scope scope]:\n\n - [can-stache-bindings.toChild]=[can-stache.key] - one way binding to child\n - [can-stache-bindings.toParent]=[can-stache.key] - one way binding to parent\n - [can-stache-bindings.twoWay]=[can-stache.key] - two way binding child to parent\n \nExample:\n\n```\n<my-tag {to-child}=\"key\" \n        {^to-parent}=\"key\" \n        {(two-way)}=\"key\"></my-tag>\n```\n"
          }
        ],
        "release": "2.3"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache-bindings"
        }
      ],
      "name": "BINDINGS",
      "description": "Use the following binding syntaxes\nto connect the component's [can-component::viewModel] to the template's [can-view-scope scope]:\n\n - [can-stache-bindings.toChild]=[can-stache.key] - one way binding to child\n - [can-stache-bindings.toParent]=[can-stache.key] - one way binding to parent\n - [can-stache-bindings.twoWay]=[can-stache.key] - two way binding child to parent\n \nExample:\n\n```\n<my-tag {to-child}=\"key\" \n        {^to-parent}=\"key\" \n        {(two-way)}=\"key\"></my-tag>\n```\n"
    },
    "comment": " "
  },
  "can-compute": {
    "src": {
      "path": "node_modules/can-compute/docs/compute.md"
    },
    "body": "\n## Use\n\n`compute` lets you make an observable value. Computes are similar\nto [can-map Observes], but they represent a single value rather than \na collection of values.\n\n`compute` returns a [can-compute.computed compute] function that can \nbe called to read and optionally update the compute's value.\n\nIt's also possible to derive a compute's value from other computes,\n[can-map]s, and [can-list]s. When the derived values\nchange, the compute's value will be automatically updated.\n\nUse [can-compute.computed.bind compute.bind] to listen for changes of the \ncompute's value.\n\n## Observing a value\n\nThe simplest way to use a compute is to have it store a single value, and to set it when\nthat value needs to change:\n\n\n    var tally = canCompute(12);\n    tally(); // 12\n    \n    tally.bind(\"change\",function(ev, newVal, oldVal){\n      console.log(newVal,oldVal)\n    })\n    \n    tally(13);\n    tally(); // 13\n\nAny value can be observed.  The following creates a compute\nthat holds an object and then changes it to an array.\n\n    var data = canCompute({name: \"Justin\"})\n    data([{description: \"Learn Computes\"}])\n\n\n\n## Derived computes\n\nIf you use a compute that derives its\nvalue from properties of a [can-map] or other [compute]s, the compute will listen for changes in those\nproperties and automatically recalculate itself, emitting a _change_ event if its value\nchanges.\n\nThe following example shows creating a `fullName` compute\nthat derives its value from two properties on the `person` observe:\n\n\n    var person = new Map({\n        firstName: 'Alice',\n        lastName: 'Liddell'\n    });\n    \n    var fullName = canCompute(function() {\n        return person.attr('firstName') + ' ' + person.attr('lastName');\n    });\n    fullName.bind('change', function(ev, newVal, oldVal) {\n        console.log(\"This person's full name is now \" + newVal + '.');\n    });\n    \n    person.attr('firstName', 'Allison'); // The log reads:\n    //-> \"This person's full name is now Allison Liddell.\"\n\n\nNotice how the definition of the compute uses `[can-map.prototype.attr attr]`\nto read the values of the properties of `person`. This is how the compute knows to listen\nfor changes.\n\n## Translator computes - computes that update their derived values\n\nSometimes you need a compute to be able to translate one value to another. For example,\nconsider a widget that displays and allows you to update the progress in percent\nof a task. It accepts a compute with values between 0 and 100. But,\nour task observe has progress values between 0 and 1 like:\n\n    var task = new Map({\n      progress: 0.75\n    })\n\nUse `canCompute( getterSetter )` to create a compute that updates itself\nwhen task's `progress` changes, but can also update progress when\nthe compute function is called with a value.  For example:\n\n    var progressPercent = canCompute(function(percent){\n      if(arguments.length){\n        task.attr('progress', percent / 100)\n      } else {\n        return task.attr('progress') * 100\n      }\n    })\n    \n    progressPercent() // -> 75\n    \n    progressPercent(100)\n    \n    task.attr('progress') // -> 1\n\n\nThe following is a similar example that shows converting feet into meters and back:\n\n```\nvar wall = new Map({\n    material: 'brick',\n    length: 10 // in feet\n});\n\nvar wallLengthInMeters = canCompute(function(lengthInM) {\n    if(arguments.length) {\n        wall.attr('length', lengthInM / 3.28084);\n    } else {\n        return wall.attr('length') * 3.28084;\n    }\n});\n\nwallLengthInMeters(); // 3.048\n\n// When you set the compute...\nwallLengthInMeters(5);\nwallLengthInMeters(); // 5\n// ...the original Observe changes too.\nwall.length;          // 16.4042\n```\n\n## Events\n\nWhen a compute's value is changed, it emits a _change_ event. You can listen for this change\nevent by using `[computed.bind bind]` to bind an event handler to the compute:\n\n```\nvar tally = canCompute(0);\ntally.bind('change', function(ev, newVal, oldVal) {\n    console.log('The tally is now at ' + newVal + '.');\n});\n\ntally(tally() + 5); // The log reads:\n                    // 'The tally is now at 5.'\n```\n\n",
    "description": "Create an observable value. \n",
    "name": "can-compute",
    "type": "module",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-core",
    "release": "1.1",
    "link": "../docco/compute/compute.html docco",
    "signatures": [
      {
        "code": "canCompute( getterSetter[, context] )",
        "description": "\n\nCreate a compute that derives its value from [can-map]s and other [can-compute.computed compute]s.\n\n```js\nvar age = canCompute(32);\n\nvar nameAndAge = canCompute(function(){\n\treturn \"Matthew - \" + age();\n});\n\nconsole.log(nameAndAge()); // -> Matthew - 32\n\nage(33);\n\nconsole.log(nameAndAge()); // -> Matthew - 33\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*+"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*+"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "name": "getterSetter",
            "description": "A function that gets and optionally sets the value of the compute.\nWhen called with no parameters, _getterSetter_ should return the current value of the compute. When\ncalled with a single parameter, _getterSetter_ should arrange things so that the next read of the compute\nproduces that value. This compute will automatically update its value when any [can.Map observable]\nvalues are read via [can-map.prototype.attr].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "The `this` to use when calling the `getterSetter` function."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n\n"
        }
      },
      {
        "code": "canCompute( initialValue [, settings] )",
        "description": "\n\nCreates a compute from a value and optionally specifies how to read, update, and \nlisten to changes in dependent values. This form of compute can be used to \ncreate a compute that derives its value from any source.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "initialValue",
            "description": "The initial value of the compute. If `settings` is\nnot provided, the compute simply updates its value to whatever the first argument \nto the compute is.\n\n    var age = canCompute(30);\n    age() //-> 30\n    age(31) //-> fires a \"change\" event\n"
          },
          {
            "types": [
              {
                "type": "computeSettings"
              }
            ],
            "optional": true,
            "name": "settings",
            "description": "\n\nConfigures all behaviors of the [can-compute.computed compute]. The following cross\nbinds an input element to a compute:\n\n    var input = document.getElementById(\"age\")\n    var value = canCompute(\"\",{\n\t\tget: function(){\n\t\t\treturn input.value;\n\t\t},\n\t\tset: function(newVal){\n\t\t\tinput.value = newVal;\n\t\t},\n\t\ton: function(updated){\n\t\t\tinput.addEventListener(\"change\", updated, false);\n\t\t},\n\t\toff: function(updated){\n\t\t\tinput.removeEventListener(\"change\", updated, false);\n\t\t}\n\t})\n\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The new compute.\n\n\n"
        }
      },
      {
        "code": "canCompute( initialValue, setter(newVal,oldVal) )",
        "description": "\n\nCreate a compute that has a setter that can adjust incoming new values.\n\n    var age = canCompute(6,function(newVal, oldVal){\n      if(!isNaN(+newVal)){\n        return +newVal;\n      } else {\n        return oldVal;\n      }\n    })\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "initialValue",
            "description": "\n\nThe initial value of the compute.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "name": "setter",
            "description": "\n\nA function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can-compute.computed compute] and the current value. If\n`set` returns a value, it is used to compare to the current value of the compute. Otherwise,\n`get` is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n"
        }
      },
      {
        "code": "canCompute( object, propertyName [, eventName] )",
        "description": "\n\nCreate a compute from an object's property value. This short-cut\nsignature lets you create a compute on objects that have events\nthat can be listened to with [can.bind].\n\n    var input = document.getElementById('age')\n    var age = canCompute(input,\"value\",\"change\");\n    \n    var me = new Map({name: \"Justin\"});\n    var name = canCompute(me,\"name\")\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "An object that either has a `bind` method or\na has events dispatched on it via [can.trigger].\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The property value to read on `object`.  The\nproperty will be read via `object.attr(propertyName)` or `object[propertyame]`.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "eventName",
            "defaultValue": "propertyName",
            "description": "Specifies the event name to listen\nto on `object` for `propertyName` updates.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A new compute.\n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "eventName",
      "defaultValue": "propertyName",
      "description": "Specifies the event name to listen\nto on `object` for `propertyName` updates.\n"
    },
    "comment": " "
  },
  "can-construct": {
    "name": "can-construct",
    "type": "module",
    "description": " \nProvides a way to easily use the power of prototypal inheritance\nwithout worrying about hooking up all the particulars yourself. Use\n[can-construct.extend can-construct.extend] to create an inheritable\nconstructor function of your own.\n\n",
    "src": {
      "path": "node_modules/can-construct/docs/construct.md"
    },
    "body": "\n## Use\n\nIn the example below, `Animal` is a constructor function returned by [can-construct.extend can-construct.extend]. All instances of `Animal` will have a `speak`\nmethod, and the `Animal` constructor has a `legs` property.\n\n\n    var Construct = require(\"can-construct\");\n\tvar Animal = Construct.extend({\n        legs: 4\n    }, {\n        init: function(sound) {\n            this.sound = sound;\n        },\n        speak: function() {\n            console.log(this.sound);\n        }\n    });\n\n\nYou can make instances of your object by calling your constructor function with the `new` keyword. When an object is created, the [can-construct::init init]\nmethod gets called (if you supplied one):\n\n    var panther = new Animal('growl');\n    panther.speak(); // \"growl\"\n    panther instanceof Animal; // true\n\n## Plugins\n\nThere are two plugins available to help make using `can-construct` even simpler.\n\n-   [can-construct-super] allows you to easily call base methods by making `this._super` available in inherited methods.\n-   [can-construct-proxy] creates a static callback function that sets the value of `this` to an instance of the constructor function.\n\n",
    "title": "can-construct",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-core",
    "comment": " "
  },
  "can-construct.static": {
    "src": {
      "line": 59,
      "codeLine": 62,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "can-construct.static",
    "parent": "can-construct",
    "title": "static"
  },
  "can-construct.constructorExtends": {
    "name": "can-construct.constructorExtends",
    "type": "property",
    "parent": "can-construct.static",
    "src": {
      "line": 63,
      "codeLine": 130,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n If `constructorExtends` is:\n\n  - `true` - the constructor extends\n  - `false` - a new instance of the constructor is created\n\n This property defaults to false.\n\n Example of constructExtends as `true`:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: true // the constructor extends\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var Pony = Animal({\n   gallop: function () {\n      console.log(\"Galloping!!\");\n   }\n }); // Pony is now a constructor function extended from Animal\n\n var frank = new Animal(); // frank is a new instance of Animal\n\n var gertrude = new Pony(); // gertrude is a new instance of Pony\n gertrude.sayHi(); // \"hai!\" - sayHi is \"inherited\" from Animal\n gertrude.gallop(); // \"Galloping!!\" - gallop is unique to instances of Pony\n```\n\n The default behavior is shown in the example below:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: false // the constructor does NOT extend\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var pony = Animal(); // pony is a new instance of Animal\n var frank = new Animal(); // frank is a new instance of Animal\n\n pony.sayHi() // \"hai!\"\n frank.sayHi() // \"hai!\"\n```\n By default to extend a constructor, you must use [can-construct.extend extend].\n\t \n",
    "description": "  Toggles the behavior of a constructor function called\n without the `new` keyword to extend the constructor function or\n create a new instance.\n\n ```js\n var animal = Animal();\n // vs\n var animal = new Animal();\n ```\n\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "constructorExtends",
    "comment": " "
  },
  "can-construct.newInstance": {
    "type": "function",
    "name": "can-construct.newInstance",
    "parent": "can-construct.static",
    "src": {
      "line": 131,
      "codeLine": 196,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "Creates a new instance of the constructor function. This method is useful for creating new instances\nwith arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n__new__ operator.\n\n## Example\n\nThe following creates a `Person` Construct and overrides `newInstance` to cache all\ninstances of Person to prevent duplication. If the properties of a new Person match an existing one it\nwill return a reference to the previously created object, otherwise it returns a new object entirely.\n\n```js\n// define and create the Person constructor\nvar Person = Construct.extend({\n  init : function(first, middle, last) {\n    this.first = first;\n    this.middle = middle;\n    this.last = last;\n  }\n});\n\n// store a reference to the original newInstance function\nvar _newInstance = Person.newInstance;\n\n// override Person's newInstance function\nPerson.newInstance = function() {\n// if cache does not exist make it an new object\nthis.__cache = this.__cache || {};\n// id is a stingified version of the passed arguments\nvar id = JSON.stringify(arguments);\n\n// look in the cache to see if the object already exists\nvar cachedInst = this.__cache[id];\nif(cachedInst) {\n    return cachedInst;\n}\n\n//otherwise call the original newInstance function and return a new instance of Person.\nvar newInst = _newInstance.apply(this, arguments);\nthis.__cache[id] = newInst;\nreturn newInst;\n}\n\n// create two instances with the same arguments\nvar justin = new Person('Justin', 'Barry', 'Meyer'),\n\tbrian = new Person('Justin', 'Barry', 'Meyer');\n\nconsole.log(justin === brian); // true - both are references to the same instance\n```\n\n \n",
    "description": "Returns an instance of `Construct`. This method can be overridden to return a cached instance.\n\n",
    "title": "newInstance",
    "signatures": [
      {
        "code": "Construct.newInstance([...args])",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "args",
            "description": "arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\nthat if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\ninstead."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "class"
            }
          ],
          "description": "instance of the class\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "args",
      "description": "arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\nthat if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\ninstead."
    },
    "_curReturn": {
      "types": [
        {
          "type": "class"
        }
      ],
      "description": "instance of the class\n"
    },
    "comment": " "
  },
  "can-construct.setup": {
    "type": "function",
    "name": "can-construct.setup",
    "parent": "can-construct.static",
    "src": {
      "line": 239,
      "codeLine": 300,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "The static `setup` method is called immediately after a constructor\nfunction is created and\nset to inherit from its base constructor. It is useful for setting up\nadditional inheritance work.\nDo not confuse this with the prototype `[can-construct::setup]` method.\n\n## Example\n\nThis `Parent` class adds a reference to its base class to itself, and\nso do all the classes that inherit from it.\n\n```js\nParent = Construct.extend({\n  setup : function(base, fullName, staticProps, protoProps){\n    this.base = base;\n\n    // call base functionality\n    Construct.setup.apply(this, arguments)\n  }\n},{});\n\nParent.base; // Construct\n\nChild = Parent({});\n\nChild.base; // Parent\n```\n \n",
    "description": "Perform initialization logic for a constructor function. \n",
    "title": "setup",
    "signatures": [
      {
        "code": "Construct.setup(base, fullName, staticProps, protoProps)",
        "description": "\n\nA static `setup` method provides inheritable setup functionality\nfor a Constructor function. The following example\ncreates a Group constructor function.  Any constructor\nfunctions that inherit from Group will be added to\n`Group.childGroups`.\n\n\n    Group = Construct.extend({\n      setup: function(Construct, fullName, staticProps, protoProps){\n        this.childGroups = [];\n        if(Construct !== Construct){\n          this.childGroups.push(Construct)\n        }\n        Construct.setup.apply(this, arguments)\n      }\n    },{})\n    var Flock = Group.extend(...)\n    Group.childGroups[0] //-> Flock\n",
        "params": [
          {
            "types": [
              {
                "type": "constructor"
              }
            ],
            "name": "base",
            "description": "The base constructor that is being inherited from."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "fullName",
            "description": "The name of the new constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "staticProps",
            "description": "The static properties of the new constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "protoProps",
            "description": "The prototype properties of the new constructor.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "protoProps",
      "description": "The prototype properties of the new constructor.\n"
    },
    "comment": " "
  },
  "can-construct.extend": {
    "type": "function",
    "name": "can-construct.extend",
    "parent": "can-construct.static",
    "src": {
      "line": 314,
      "codeLine": 452,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "## Inheritance\nCreating \"subclasses\" with `Construct` is simple. All you need to do is call the base constructor\nwith the new function's static and instance properties. For example, we want our `Snake` to\nbe an `Animal`, but there are some differences:\n\n\n    var Snake = Animal.extend({\n        legs: 0\n    }, {\n        init: function() {\n            Animal.prototype.init.call(this, 'ssssss');\n        },\n        slither: function() {\n            console.log('slithering...');\n        }\n    });\n\n    var baslisk = new Snake();\n    baslisk.speak();   // \"ssssss\"\n    baslisk.slither(); // \"slithering...\"\n    baslisk instanceof Snake;  // true\n    baslisk instanceof Animal; // true\n\n\n## Static properties and inheritance\n\nIf you pass all three arguments to Construct, the second one will be attached directy to the\nconstructor, allowing you to imitate static properties and functions. You can access these\nproperties through the `[can-construct::constructor this.constructor]` property.\n\nStatic properties can get overridden through inheritance just like instance properties. In the example below,\nwe override both the legs static property as well as the the init function for each instance:\n\n```js\nvar Animal = Construct.extend({\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    },\n    speak: function() {\n        console.log(this.sound);\n    }\n});\n\nvar Snake = Animal.extend({\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nAnimal.legs; // 4\nSnake.legs; // 0\nvar dog = new Animal('woof');\nvar blackMamba = new Snake();\ndog.speak(); // 'woof'\nblackMamba.speak(); // 'ssssss'\n```\n \n",
    "description": "\n",
    "title": "extend",
    "signatures": [
      {
        "code": "Construct.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nExtends `Construct`, or constructor functions derived from `Construct`,\nto create a new constructor function. Example:\n\n```js\nvar Animal = Construct.extend({\n  sayHi: function(){\n    console.log(\"hi\")\n  }\n});\n\nvar animal = new Animal()\nanimal.sayHi();\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Adds a name to the constructor function so\nit is nicely labeled in the developer tools. The following:\n\n    Construct.extend(\"ConstructorName\",{})\n\nreturns a constructur function that will show up as `ConstructorName`\nin the developer tools.\nIt also sets \"ConstructorName\" as [can-construct.shortName shortName].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties that are added the constructor\nfunction directly. For example:\n\n```js\nvar Animal = Construct.extend({\n  findAll: function(){\n    return can.ajax({url: \"/animals\"})\n  }\n},{}); // need to pass an empty instanceProperties object\n\nAnimal.findAll().then(function(json){ ... })\n```\n\nThe [can-construct.setup static setup] method can be used to\nspecify inheritable behavior when a Constructor function is created.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [can-construct::init init] and [can-construct::setup setup] properties\nare used for initialization.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceProperties",
      "description": "Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [can-construct::init init] and [can-construct::setup setup] properties\nare used for initialization.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"
    },
    "comment": " "
  },
  "can-construct.shortName": {
    "src": {
      "line": 540,
      "codeLine": 554,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "property",
    "body": "\n```js\nvar MyConstructor = Construct.extend(\"MyConstructor\",{},{});\nMyConstructor.shortName // \"MyConstructor\"\n```\n\t\t \n",
    "description": "\nIf you pass a name when creating a Construct, the `shortName` property will be set to the\nname.\n",
    "types": [
      {
        "type": "String"
      }
    ],
    "title": "shortName",
    "name": "can-construct.shortName",
    "parent": "can-construct.static"
  },
  "can-construct.prototype": {
    "src": {
      "line": 565,
      "codeLine": 568,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "can-construct.prototype",
    "parent": "can-construct",
    "title": "prototype"
  },
  "can-construct.prototype.constructor": {
    "src": {
      "line": 569,
      "codeLine": 598,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "property",
    "body": "\n## Example\n\nThis Construct has a static counter that counts how many instances have been created:\n\n```js\nvar Counter = Construct.extend({\n    count: 0\n}, {\n    init: function() {\n        this.constructor.count++;\n    }\n});\n\nvar childCounter = new Counter();\nconsole.log(childCounter.constructor.count); // 1\nconsole.log(Counter.count); // 1\n```\n\t \n",
    "description": "\nA reference to the constructor function that created the instance. This allows you to access\nthe constructor's static properties from an instance.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "constructor",
    "name": "can-construct.prototype.constructor",
    "parent": "can-construct.prototype",
    "comment": " "
  },
  "can-construct.prototype.setup": {
    "type": "function",
    "name": "can-construct.prototype.setup",
    "parent": "can-construct.prototype",
    "src": {
      "line": 598,
      "codeLine": 664,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n## Deciding between `setup` and `init`\n\n\nUsually, you should use [can-construct::init init] to do your constructor function's initialization.\nYou should, instead, use `setup` when:\n\n  - there is initialization code that you want to run before the inheriting constructor's\n    `init` method is called.\n  - there is initialization code that should run whether or not inheriting constructors\n    call their base's `init` methods.\n  - you want to modify the arguments that will get passed to `init`.\n\n## Example\n\nThis code is a simplified version of the code in [can.Control]'s setup\nmethod. It converts the first argument to a jQuery collection and\nextends the controller's defaults with the options that were passed.\n\n\n    can.Control = Construct.extend({\n        setup: function(domElement, rawOptions) {\n            // set up this.element\n            this.element = $(domElement);\n\n            // set up this.options\n            this.options = can.extend({},\n                                  this.constructor.defaults,\n                                  rawOptions\n                                 );\n\n            // pass this.element and this.options to init.\n            return [this.element, this.options];\n        }\n    });\n\n\n",
    "description": "\n",
    "title": "setup",
    "signatures": [
      {
        "code": "construct.setup(...args)",
        "description": "\n\nA setup function for the instantiation of a constructor function.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "The arguments passed to the constructor.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If an array is returned, the array's items are passed as\narguments to [can-construct::init init]. The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n    WidgetFactory = Construct.extend({\n        setup: function(element){\n            return [$(element)]\n        }\n    })\n\n    MyWidget = WidgetFactory.extend({\n        init: function($el){\n            $el.html(\"My Widget!!\")\n        }\n    })\n\nOtherwise, the arguments to the\nconstructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "The arguments passed to the constructor.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If an array is returned, the array's items are passed as\narguments to [can-construct::init init]. The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n    WidgetFactory = Construct.extend({\n        setup: function(element){\n            return [$(element)]\n        }\n    })\n\n    MyWidget = WidgetFactory.extend({\n        init: function($el){\n            $el.html(\"My Widget!!\")\n        }\n    })\n\nOtherwise, the arguments to the\nconstructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n"
    },
    "comment": " "
  },
  "can-construct.prototype.init": {
    "type": "function",
    "name": "can-construct.prototype.init",
    "parent": "can-construct.prototype",
    "src": {
      "line": 665,
      "codeLine": 724,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "If a prototype `init` method is provided, `init` is called when a new Construct is created---\nafter [can-construct::setup]. The `init` method is where the bulk of your initialization code\nshould go. A common thing to do in `init` is save the arguments passed into the constructor.\n\n## Examples\n\nFirst, we'll make a Person constructor that has a first and last name:\n\n```js\nvar Person = Construct.extend({\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar justin = new Person(\"Justin\", \"Meyer\");\njustin.first; // \"Justin\"\njustin.last; // \"Meyer\"\n```\n\nThen, we'll extend Person into Programmer, and add a favorite language:\n\n```js\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n\nvar brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\nbrian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n```\n\n## Modified Arguments\n\n[can-construct::setup] is able to modify the arguments passed to `init`.\nIf you aren't receiving the arguments you passed to `new Construct(args)`,\ncheck that they aren't being changed by `setup` along\nthe inheritance chain.\n\n",
    "description": "Called when a new instance of a Construct is created. \n",
    "title": "init",
    "signatures": [
      {
        "code": "construct.init(...args)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n"
    },
    "comment": " "
  },
  "can.Control": {
    "name": "can.Control",
    "type": "add",
    "description": "undefined \n"
  },
  "can.Control.static": {
    "src": {
      "line": 67,
      "codeLine": 70,
      "path": "node_modules/can-control/can-control.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "can.Control.static",
    "parent": "can.Control",
    "title": "static"
  },
  "can.Control.prototype": {
    "src": {
      "line": 179,
      "codeLine": 182,
      "path": "node_modules/can-control/can-control.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "can.Control.prototype",
    "parent": "can.Control",
    "title": "prototype"
  },
  "can.Control.processor": {
    "src": {
      "path": "node_modules/can-control/control.processor.md"
    },
    "body": "",
    "description": "A function that handles the binding and unbinding of a [can.Control]'s declarative event method. \n",
    "type": "typedef",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A callback function that unbinds any event handlers bound within this processor.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "the control's element or the object \nspecified by the templated event handler (`\"{object}\"`).\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "The event type.\n"
          },
          {
            "types": [
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "selector",
            "description": "The selector preceding the event in the binding used on the Control.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ],
                    "name": "element",
                    "description": "foo"
                  },
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event",
                    "description": "bar\n"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "can.Control"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The callback function being bound.\n"
          },
          {
            "types": [
              {
                "type": "can.Control"
              }
            ],
            "name": "control",
            "description": "The Control the event is bound on.\n"
          }
        ]
      }
    ],
    "name": "can.Control.processor",
    "_curParam": {
      "types": [
        {
          "type": "can.Control"
        }
      ],
      "name": "control",
      "description": "The Control the event is bound on.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A callback function that unbinds any event handlers bound within this processor.\n"
    }
  },
  "'htmlbool'": {
    "type": "function",
    "name": "'htmlbool'",
    "params": [
      {
        "name": "val",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-map-define/can-map-define.js",
    "src": {
      "line": 224,
      "codeLine": 228,
      "path": "node_modules/can-map-define/can-map-define.js"
    },
    "body": " \n",
    "description": "Implements HTML-style boolean logic for attribute strings, where\nany string, including \"\", is truthy.\n"
  },
  "can-event.static": {
    "name": "can-event.static",
    "title": "static",
    "type": "group",
    "parent": "can-event",
    "description": "",
    "order": 0
  },
  "can-event": {
    "src": {
      "path": "node_modules/can-event/can-event.md"
    },
    "body": "\n## Using as a mixin\n\nThe easiest way to add events to your classes and objects is by mixing [can-event] into your object or prototype.\n\n```\nvar SomeClass = Construct(\"SomeClass\", {\n\tinit: function() {\n\t\tthis.value = 0;\n\t},\n\tincrement: function() {\n\t\tthis.value++;\n\t\tthis.dispatch(\"change\", [this.value]);\n\t}\n});\nObject.assign(SomeClass.prototype, canEvent);\n```\n\nNow that `canEvent` is included in the prototype, we can add/remove/dispatch events on the object instances.\n\n```\nvar instance = new SomeClass();\ninstance.on(\"change\", function(ev, value) {\n\talert(\"The instance changed to \" + value);\n});\n\n// This will dispatch the \"change\" event and show the alert\ninstance.increment();\n```\n\n## Using without mixing in\n\nThe same event functionality from `canEvent` can be used, even if the given object doesn't include `canEvent`. Every method within `canEvent` supports being called with an alternate scope.\n\n```\nvar obj = {};\n\ncanEvent.addEventListener.call(obj, \"change\", function() {\n\talert(\"object change!\");\n});\n\n// This will dispatch the \"change\" event and show the alert\ncanEvent.dispatch.call(obj, \"change\");\n```\n\n",
    "description": " \nAdd event functionality into your objects.\n\nThe `canEvent` object provides a number of methods for handling events in objects. This functionality is best used by mixing the `canEvent` object into an object or prototype. However, event listeners can still be used even on objects that don't include `canEvent`.\n\nAll methods provided by `canEvent` assume that they are mixed into an object -- `this` should be the object dispatching the events.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event",
    "parent": "can-infrastructure",
    "test": "can/event/test.html",
    "link": "../docco/event.html docco",
    "release": "2.1",
    "signatures": [
      {
        "code": "assign(YourClass.prototype, canEvent)",
        "description": "\n\nAdds event functionality to `YourClass` objects. This can also be applied to normal objects: `assign(someObject, canEvent)`.\n\nThe `assign` function can be any function that assigns additional properties on an object such as [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) or lodash's [_.assign](https://lodash.com/docs#assign) or [can-util/js/assign/assign].\n\n```js\nvar assign = require(\"can-util/js/assign/assign\");\nvar canEvent = require(\"can-event\");\n\nfunction Thing(){\n\n}\n\nassign(Thing.prototype, canEvent);\n\n// Can not apply event listeners\n\nvar thing = new Thing();\nthing.addEventListener(\"prop\", function(){ ... });\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-event.addEventListener": {
    "type": "function",
    "name": "can-event.addEventListener",
    "parent": "can-event.static",
    "src": {
      "line": 29,
      "codeLine": 53,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "addEventListener",
    "signatures": [
      {
        "code": "obj.addEventListener(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\n```js\nvar canEvent = require(\"can-event\");\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.addEventListener.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the `canEvent` mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.removeEventListener": {
    "type": "function",
    "name": "can-event.removeEventListener",
    "parent": "can-event.static",
    "src": {
      "line": 70,
      "codeLine": 88,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "removeEventListener",
    "signatures": [
      {
        "code": "obj.removeEventListener(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "__validate",
            "description": "An extra function that can validate an\nevent handler as a match. This is an internal parameter and only used\nfor can-event plugins."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.removeEventListener.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.dispatch": {
    "type": "function",
    "name": "can-event.dispatch",
    "parent": "can-event.static",
    "src": {
      "line": 111,
      "codeLine": 139,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "dispatch",
    "signatures": [
      {
        "code": "obj.dispatch(event, args)",
        "description": "\n\nDispatches/triggers a basic event on an object.\n\n```js\nvar canEvent = require(\"can-event\");\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){\n  console.log(\"FOO BAR!\");\n});\n\nobj.dispatch(\"foo\"); // Causes it to log FOO BAR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "event",
            "description": "The event to dispatch"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Additional arguments to pass to event handlers"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "event The resulting event object\n"
        }
      },
      {
        "code": "canEvent.dispatch.call(obj, event, args)",
        "description": "\n\nThis syntax can be used for objects that don't include the `can.event` mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "event The resulting event object\n"
    }
  },
  "can-event.on": {
    "type": "function",
    "name": "can-event.on",
    "parent": "can-event.static",
    "src": {
      "line": 180,
      "codeLine": 193,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "on",
    "signatures": [
      {
        "code": "obj.on(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\nThis is an alias of [can-event.addEventListener addEventListener].\n",
        "params": []
      },
      {
        "code": "can-event.on.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.off": {
    "type": "function",
    "name": "can-event.off",
    "parent": "can-event.static",
    "src": {
      "line": 202,
      "codeLine": 215,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "off",
    "signatures": [
      {
        "code": "obj.off(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n\nThis is an alias of [can-event.removeEventListener removeEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.off.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.trigger": {
    "type": "function",
    "name": "can-event.trigger",
    "parent": "can-event.static",
    "src": {
      "line": 223,
      "codeLine": 235,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "trigger",
    "signatures": [
      {
        "code": "obj.trigger(event, args)",
        "description": "\n\nDispatches/triggers a basic event on an object.\nThis is an alias of [can-event.dispatch dispatch].\n",
        "params": []
      },
      {
        "code": "canEvent.trigger.call(obj, event, args)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.one": {
    "type": "function",
    "name": "can-event.one",
    "parent": "can-event.static",
    "src": {
      "line": 245,
      "codeLine": 256,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "one",
    "signatures": [
      {
        "code": "obj.one(event, handler)",
        "description": "\n\nAdds a basic event listener that listens to an event once and only once.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n    "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "The handler that will be executed to handle the event."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n    "
    }
  },
  "can-event.listenTo": {
    "type": "function",
    "name": "can-event.listenTo",
    "parent": "can-event.static",
    "src": {
      "line": 276,
      "codeLine": 294,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "listenTo",
    "signatures": [
      {
        "code": "obj.listenTo(other, event, handler)",
        "description": "\n\nListens for an event on another object.\nThis is similar to concepts like event namespacing, except that the namespace\nis the scope of the calling object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "other",
            "description": "The object to listen for events on."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.listenTo.call(obj, other, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.stopListening": {
    "type": "function",
    "name": "can-event.stopListening",
    "parent": "can-event.static",
    "src": {
      "line": 324,
      "codeLine": 340,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "stopListening",
    "signatures": [
      {
        "code": "obj.stopListening(other, event, handler)",
        "description": "\n\nStops listening for an event on another object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "other",
            "description": "The object to listen for events on."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.stopListening.call(obj, other, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.bind": {
    "name": "can-event.bind",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 396,
      "codeLine": 409,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "bind",
    "signatures": [
      {
        "code": "obj.bind(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\nThis is an alias of [can-event.addEventListener addEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.bind.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ]
  },
  "can-event.unbind": {
    "name": "can-event.unbind",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 411,
      "codeLine": 424,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "unbind",
    "signatures": [
      {
        "code": "obj.unbind(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n\nThis is an alias of [can-event.removeEventListener removeEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.unbind.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ]
  },
  "can-event.delegate": {
    "name": "can-event.delegate",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 426,
      "codeLine": 446,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "delegate",
    "signatures": [
      {
        "code": "obj.delegate(selector, event, handler)",
        "description": "\n\nProvides a compatibility layer for adding delegate event listeners.\nThis doesn't actually implement delegates, but rather allows\nlogic that assumes a delegate to still function.\n\nTherefore, this is essentially an alias of [can-event.addEventListener addEventListener] with the selector ignored.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "The **ignored** selector to use for the delegate."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.delegate.call(obj, selector, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can.event] mixin.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.undelegate": {
    "name": "can-event.undelegate",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 448,
      "codeLine": 468,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "undelegate",
    "signatures": [
      {
        "code": "obj.undelegate(selector, event, handler)",
        "description": "\n\nProvides a compatibility layer for removing delegate event listeners.\nThis doesn't actually implement delegates, but rather allows\nlogic that assumes a delegate to still function.\n\nTherefore, this is essentially an alias of [can-event.removeEventListener removeEventListener] with the selector ignored.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "The **ignored** selector to use for the delegate."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.undelegate.call(obj, selector, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-list": {
    "src": {
      "path": "node_modules/can-list/docs/list.md"
    },
    "body": "\n\nUse for observable array-like objects.\n\n\n## Use\n\n`List` is used to observe changes to an Array.  `List` extends `[can-map]`, so all the \nways that you're used to working with Maps also work here.\n\nUse [can-list::attr attr] to read and write properties of a list:\n\n    var hobbies = new List([\"JS\",\"Party Rocking\"])\n    hobbies.attr(0)        //-> \"JS\"\n    hobbies.attr(\"length\") //-> 2\n    \n    hobbies.attr(0,\"JavaScript\")\n    \n    hobbies.attr()         //-> [\"JavaScript\",\"Party Rocking\"]\n\nJust as you shouldn't set properties of an Map directly, you shouldn't change elements\nof a List directly. Always use `attr` to set the elements of a List, or use [can-list::push push],\n[can-list::pop pop], [can-list::shift shift], [can-list::unshift unshift], or [can-list::splice splice].\n\nHere is a tour through the forms of `List`'s `attr` that parallels the one found under [can-map.prototype.attr attr]:\n\n```\nvar people = new List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\npeople[0] = 'Adam'; // don't do this!\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']\n```\n\n## Listening to changes\n\nAs with `Map`s, the real power of observable arrays comes from being able to\nreact to changes in the member elements of the array. Lists emit five types of events:\n\n- the _change_ event fires on every change to a List.\n- the _set_ event is fired when an element is set.\n- the _add_ event is fired when an element is added to the List.\n- the _remove_ event is fired when an element is removed from the List.\n- the _length_ event is fired when the length of the List changes.\n\nThis example presents a brief concrete survey of the times these events are fired:\n\n```\nvar list = new List(['Alice', 'Bob', 'Eve']);\n\nlist.bind('change', function() { console.log('An element changed.'); });\nlist.bind('set', function() { console.log('An element was set.'); });\nlist.bind('add', function() { console.log('An element was added.'); });\nlist.bind('remove', function() { \n  console.log('An element was removed.'); \n});\nlist.bind('length', function() { \n  console.log('The length of the list changed.'); \n});\n\nlist.attr(0, 'Alexis'); // 'An element changed.'\n                        // 'An element was set.'\n\nlist.attr(3, 'Xerxes'); // 'An element changed.'\n                        // 'An element was added.'\n                        // 'The length of the list was changed.'\n\nlist.attr(['Adam', 'Bill']); // 'An element changed.'\n                             // 'An element was set.'\n                             // 'An element was changed.'\n                             // 'An element was set.'\n\nlist.pop(); // 'An element changed.'\n            // 'An element was removed.'\n            // 'The length of the list was changed.'\n```\n\nMore information about binding to these events can be found under [can-list::attr attr].\n\n",
    "description": "\n",
    "name": "can-list",
    "type": "module",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "inherits": "can",
    "download": "can/list",
    "test": "can/list/test.html",
    "parent": "can-legacy",
    "release": "2.0",
    "link": "../docco/list/list.html docco",
    "signatures": [
      {
        "code": "new List([array])",
        "description": "\n\nCreate an observable array-like object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "array",
            "description": "Items to seed the List with.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "An instance of `List` with the elements from _array_.\n"
        }
      },
      {
        "code": "new List(deferred)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can.Deferred"
              }
            ],
            "name": "deferred",
            "description": "A deferred that resolves to an \narray.  When the deferred resolves, its values will be added to the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "An initially empty `List`.  \n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-list"
        }
      ],
      "description": "An initially empty `List`.  \n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can.Deferred"
        }
      ],
      "name": "deferred",
      "description": "A deferred that resolves to an \narray.  When the deferred resolves, its values will be added to the list.\n"
    },
    "comment": " "
  },
  "can.List": {
    "name": "can.List",
    "type": "add",
    "description": "undefined\n"
  },
  "can.List.static": {
    "src": {
      "line": 37,
      "codeLine": 40,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "can.List.static",
    "parent": "can.List",
    "title": "static"
  },
  "can.List.Map": {
    "name": "can.List.Map",
    "type": "property",
    "parent": "can.List.static",
    "src": {
      "line": 41,
      "codeLine": 77,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "",
    "description": "Specify the Map type used to make objects added to this list observable. \n",
    "types": [
      {
        "type": "can.Map",
        "description": "When objects are added to a can.List, those objects are\nconverted into can.Map instances.  For example:\n\n    var list = new can.List();\n    list.push({name: \"Justin\"});\n\n    var map = list.attr(0);\n    map.attr(\"name\") //-> \"Justin\"\n\nBy changing [can.List.Map], you can specify a different type of Map instance to\ncreate. For example:\n\n    var User = can.Map.extend({\n      fullName: function(){\n        return this.attr(\"first\")+\" \"+this.attr(\"last\")\n      }\n    });\n\n    User.List = can.List.extend({\n      Map: User\n    }, {});\n\n    var list = new User.List();\n    list.push({first: \"Justin\", last: \"Meyer\"});\n\n    var user = list.attr(0);\n    user.fullName() //-> \"Justin Meyer\"\n\n\n\n\t "
      }
    ],
    "title": ""
  },
  "can.Map.extend": {
    "src": {
      "line": 78,
      "codeLine": 101,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "function",
    "body": "\n## Use\n\n\n\t \n",
    "description": "\n",
    "title": "",
    "name": "can.Map.extend",
    "signatures": [
      {
        "code": "can.List.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function. Learn more at [can.Construct.extend].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "If provided, adds the extened List constructor function\nto the window at the given name.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties and methods\ndirectly on the constructor function. The most common property to set is [can.List.Map].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "instanceProperties",
            "description": "Properties and methods on instances of this list type.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "instanceProperties",
      "description": "Properties and methods on instances of this list type.\n"
    },
    "comment": " "
  },
  "can.List.prototype": {
    "src": {
      "line": 101,
      "codeLine": 103,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "prototype",
    "body": "",
    "description": " \n",
    "name": "can.List.prototype",
    "parent": "can.List",
    "title": "prototype"
  },
  "can.List.prototype.serialize": {
    "type": "function",
    "name": "can.List.prototype.serialize",
    "params": [],
    "parent": "can.List.prototype",
    "src": {
      "line": 196,
      "codeLine": 200,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "\t \n",
    "description": "Returns the serialized form of this list.\n",
    "hide": true
  },
  "can.List.prototype.each": {
    "src": {
      "line": 203,
      "codeLine": 240,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "function",
    "body": "```\nvar i = 0;\nnew can.Map([1, 10, 100]).each(function(element, index) {\n    i += element;\n});\n\ni; // 111\n\ni = 0;\nnew can.Map([1, 10, 100]).each(function(element, index) {\n    i += element;\n    if(index >= 1) {\n        return false;\n    }\n});\n\ni; // 11\n```\n\t \n",
    "description": "Call a function on each element of a List. ",
    "title": "each",
    "name": "can.List.prototype.each",
    "signatures": [
      {
        "code": "list.each( callback(item, index) )",
        "description": "\n\n`each` iterates through the Map, calling a function\nfor each element.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "this List, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "this List, for chaining\n"
    },
    "comment": " "
  },
  "can.List.prototype.splice": {
    "type": "function",
    "name": "can.List.prototype.splice",
    "parent": "can.List.prototype",
    "src": {
      "line": 240,
      "codeLine": 303,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`splice` lets you remove elements from and insert elements into a List.\n\nThis example demonstrates how to do surgery on a list of numbers:\n\n```\nvar list = new can.List([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.attr(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n## Events\n\n`splice` causes the List it's called on to emit _change_ events,\n_add_ events, _remove_ events, and _length_ events. If there are\nany elements to remove, a _change_ event, a _remove_ event, and a\n_length_ event will be fired. If there are any elements to insert, a\nseparate _change_ event, an _add_ event, and a separate _length_ event\nwill be fired.\n\nThis slightly-modified version of the above example should help\nmake it clear how `splice` causes events to be emitted:\n\n```\nvar list = new can.List(['a', 'b', 'c', 'd']);\nlist.bind('change', function(ev, attr, how, newVals, oldVals) {\n    console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\nlist.bind('add', function(ev, newVals, where) {\n    console.log('add: ' + newVals + ', ' + where);\n});\nlist.bind('remove', function(ev, oldVals, where) {\n    console.log('remove: ' + oldVals + ', ' + where);\n});\nlist.bind('length', function(ev, length) {\n    console.log('length: ' + length + ', ' + this.attr());\n});\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                   // remove: ['c'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                   // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                   // add: ['Alice', 'Bob'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n```\n\nMore information about binding to these events can be found under [can.List.attr attr].\n\t \n",
    "description": "Insert and remove elements from a List. ",
    "title": "splice",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newElements]])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "where to start removing or inserting elements\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "the number of elements to remove\nIf _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the List.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newElements",
            "description": "elements to insert into the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the elements removed by `splice`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newElements",
      "description": "elements to insert into the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the elements removed by `splice`\n"
    },
    "comment": " "
  },
  "can.List.prototype.push": {
    "name": "can.List.prototype.push",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 401,
      "codeLine": 442,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`push` adds elements onto the end of a List here is an example:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\nIf you have an array you want to concatenate to the end\nof the List, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new can.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\n## Events\n\n`push` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`push` has a counterpart in [can.List::pop pop], or you may be\nlooking for [can.List::unshift unshift] and its counterpart [can.List::shift shift].\n\t \n",
    "description": "Add elements to the end of a list. ",
    "title": "push",
    "signatures": [
      {
        "code": "list.push(...elements)",
        "description": "\n\n`push` adds elements onto the end of a List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the List\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the List\n"
    },
    "comment": " "
  },
  "can.List.prototype.unshift": {
    "name": "can.List.prototype.unshift",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 443,
      "codeLine": 484,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`unshift` adds elements to the front of the list in bulk in the order specified:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\nIf you have an array you want to concatenate to the beginning\nof the List, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new can.List(['Alice']);\n\nlist.unshift.apply(list, names);\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\n## Events\n\n`unshift` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`unshift` has a counterpart in [can.List::shift shift], or you may be\nlooking for [can.List::push push] and its counterpart [can.List::pop pop].\n\t \n",
    "description": "Add elements to the beginning of a List. ",
    "title": "unshift",
    "signatures": [
      {
        "code": "list.unshift(...elements)",
        "description": "\n\n`unshift` adds elements onto the beginning of a List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the List\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the List\n"
    },
    "comment": " "
  },
  "can.List.prototype.pop": {
    "name": "can.List.prototype.pop",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 518,
      "codeLine": 550,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`pop` is the opposite action from `[can.List.push push]`:\n\n```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\nwhen it is called.\n\n## See also\n\n`pop` has its counterpart in [can.List::push push], or you may be\nlooking for [can.List::unshift unshift] and its counterpart [can.List::shift shift].\n\t \n",
    "description": "Remove an element from the end of a List. ",
    "title": "pop",
    "signatures": [
      {
        "code": "list.pop()",
        "description": "\n\n`pop` removes an element from the end of a List.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just popped off the List, or `undefined` if the List was empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just popped off the List, or `undefined` if the List was empty\n"
    },
    "comment": " "
  },
  "can.List.prototype.shift": {
    "name": "can.List.prototype.shift",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 551,
      "codeLine": 585,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`shift` is the opposite action from `[can.List::unshift unshift]`:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n\nlist.shift(); // 'Bob'\nlist.shift(); // 'Eve'\nlist.shift(); // 'Alice'\nlist.shift(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\nwhen it is called.\n\n## See also\n\n`shift` has a counterpart in [can.List::unshift unshift], or you may be\nlooking for [can.List::push push] and its counterpart [can.List::pop pop].\n\t \n",
    "description": "Remove en element from the front of a list. ",
    "title": "shift",
    "signatures": [
      {
        "code": "list.shift()",
        "description": "\n\n`shift` removes an element from the beginning of a List.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just shifted off the List, or `undefined` if the List is empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just shifted off the List, or `undefined` if the List is empty\n"
    },
    "comment": " "
  },
  "can.List.prototype.indexOf": {
    "type": "function",
    "name": "can.List.prototype.indexOf",
    "parent": "can.List.prototype",
    "src": {
      "line": 617,
      "codeLine": 643,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1\n```\n\nIt is trivial to make a `contains`-type function using `indexOf`:\n\n```\nfunction(list, item) {\n    return list.indexOf(item) >= 0;\n}\n```\n \n",
    "description": "Look for an item in a List. ",
    "title": "indexOf",
    "signatures": [
      {
        "code": "list.indexOf(item)",
        "description": "\n\n`indexOf` finds the position of a given item in the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "the item to find\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the position of the item in the List, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "the item to find\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the position of the item in the List, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can.List.prototype.join": {
    "type": "function",
    "name": "can.List.prototype.join",
    "parent": "can.List.prototype",
    "src": {
      "line": 653,
      "codeLine": 674,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n\nvar beatles = new can.List(['John', 'Paul', 'Ringo', 'George']);\nbeatles.join('&'); // 'John&Paul&Ringo&George'\n```\n \n",
    "description": "Join a List's elements into a string. ",
    "title": "join",
    "signatures": [
      {
        "code": "list.join(separator)",
        "description": "\n\n`join` turns a List into a string by inserting _separator_ between the string representations\nof all the elements of the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "separator",
            "description": "the string to seperate elements with\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the joined string\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "separator",
      "description": "the string to seperate elements with\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the joined string\n"
    },
    "comment": " "
  },
  "can.List.prototype.reverse": {
    "type": "function",
    "name": "can.List.prototype.reverse",
    "parent": "can.List.prototype",
    "src": {
      "line": 679,
      "codeLine": 697,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n \n",
    "description": "Reverse the order of a List. ",
    "title": "reverse",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\n`reverse` reverses the elements of the List in place.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "the List, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "the List, for chaining\n"
    },
    "comment": " "
  },
  "can.List.prototype.slice": {
    "type": "function",
    "name": "can.List.prototype.slice",
    "parent": "can.List.prototype",
    "src": {
      "line": 702,
      "codeLine": 733,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList.attr(); // ['Bob', 'Charlie', 'Daniel']\n```\n\n`slice` is the simplest way to copy a List:\n\n```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy.attr();   // ['Alice', 'Bob', 'Eve']\nlist === copy; // false\n```\n \n",
    "description": "Make a copy of a part of a List. ",
    "title": "slice",
    "signatures": [
      {
        "code": "list.slice([start[, end]])",
        "description": "\n\n`slice` creates a copy of a portion of the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "start",
            "defaultValue": "0",
            "description": "the index to start copying from\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "end",
            "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "a new `can.List` with the extracted elements\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "end",
      "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "a new `can.List` with the extracted elements\n"
    },
    "comment": " "
  },
  "can.List.prototype.concat": {
    "type": "function",
    "name": "can.List.prototype.concat",
    "parent": "can.List.prototype",
    "src": {
      "line": 740,
      "codeLine": 762,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`concat` makes a new List with the elements of the List followed by the elements of the parameters.\n\n```\nvar list = new can.List();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new can.List(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n```\n \n",
    "description": "Merge many collections together into a List. ",
    "title": "concat",
    "signatures": [
      {
        "code": "list.concat(...args)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can.List"
              },
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can.List"
        },
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.\n"
    },
    "comment": " "
  },
  "can.List.prototype.forEach": {
    "type": "function",
    "name": "can.List.prototype.forEach",
    "parent": "can.List.prototype",
    "src": {
      "line": 770,
      "codeLine": 790,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`forEach` calls a callback for each element in the List.\n\n```\nvar list = new can.List([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.attr(index, element * element);\n});\nlist.attr(); // [1, 4, 9]\n```\n \n",
    "description": "Call a function for each element of a List. ",
    "title": "forEach",
    "signatures": [
      {
        "code": "list.forEach(callback[, thisArg])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "element"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "a function to call with each element of the List\nThe three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the\ncurrent element of the list, and _list_ the List the elements are coming from."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "the object to use as `this` inside the callback\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "the object to use as `this` inside the callback\n"
    },
    "comment": " "
  },
  "can.List.prototype.replace": {
    "type": "function",
    "name": "can.List.prototype.replace",
    "parent": "can.List.prototype",
    "src": {
      "line": 801,
      "codeLine": 863,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`replace` replaces all the elements of this List with new ones.\n\n`replace` is especially useful when `can.List`s are live-bound into `[can.Control]`s,\nand you intend to populate them with the results of a `[can.Model]` call:\n\n```\ncan.Control({\n    init: function() {\n        this.list = new Todo.List();\n        // live-bind the list into the DOM\n        this.element.html(can.view('list.stache', this.list));\n        // when this AJAX call returns, the live-bound DOM will be updated\n        this.list.replace(Todo.findAll());\n    }\n});\n```\n\nLearn more about [can.Model.List making Lists of models].\n\n## Events\n\nA major difference between `replace` and `attr(newElements, true)` is that `replace` always emits\nan _add_ event and a _remove_ event, whereas `attr` will cause _set_ events along with an _add_ or _remove_\nevent if needed. Corresponding _change_ and _length_ events will be fired as well.\n\nThe differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:\n```\nvar attrList = new can.List(['Alexis', 'Bill']);\nattrList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nvar replaceList = new can.List(['Alexis', 'Bill']);\nreplaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nattrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n                                              // 1, set, Ben, Bill\nreplaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n                                              // 0, add, ['Adam', 'Ben'], ['Alexis', 'Bill']\n\nattrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n                                              // 1, remove, undefined, Ben\nreplaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n                                              // 0, add, Amber, ['Adam', 'Ben']\n\nattrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n                                              // 1, add, ['Bob', 'Eve'], undefined\nreplaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n                                              // 0, add, ['Alice', 'Bob', 'Eve'], Amber\n```\n \n",
    "description": "Replace all the elements of a List. ",
    "title": "replace",
    "signatures": [
      {
        "code": "list.replace(collection)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can.List"
              },
              {
                "type": "can.Deferred"
              }
            ],
            "name": "collection",
            "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can.List`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can.List"
        },
        {
          "type": "can.Deferred"
        }
      ],
      "name": "collection",
      "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can.List`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
    },
    "comment": " "
  },
  "static": {
    "src": {
      "line": 277,
      "codeLine": 280,
      "path": "node_modules/can-route/can-route.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "static",
    "parent": null,
    "title": "static"
  },
  "prototype": {
    "src": {
      "line": 141,
      "codeLine": 144,
      "path": "node_modules/can-map/can-map.js"
    },
    "type": "prototype",
    "body": "",
    "description": " \n",
    "name": "prototype",
    "parent": null,
    "title": "prototype"
  },
  "can-map": {
    "src": {
      "path": "node_modules/can-map/docs/map.md"
    },
    "body": "\n## Use\n\nWatch this video to see an example of creating an ATM machine using can.Map:\n\n<iframe width=\"662\" height=\"372\" src=\"https://www.youtube.com/embed/QP9mHyxZNiI\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n`Map` provides a way for you to listen for and keep track of changes\nto objects. When you use the getters and setters provided by `Map`,\nevents are fired that you can react to. `Map` also has support for\nworking with deep properties. Observable arrays are also available with\n`[can-list]`, which is based on `Map`.\n\n## Working with Observes\n\nTo create an Observe, use `new Map([props])`. This will return a\ncopy of `props` that emits events when its properties are changed with\n`[can-map.prototype.attr attr]`.\n\nYou can read the values of properties on Observes directly, but you should\nnever set them directly. You can also read property values using `attr`.\n\n\n    var aName = {a: 'Alexis'},\n        map = new can.Map(aName);\n\n    // Observes are copies of data:\n    aName === map; // false\n\n    // reading from an Observe:\n    map.attr();    // {a: 'Alexis'}\n    map.a;         // 'Alexis'\n    map.attr('a'); // 'Alexis'\n\n    // setting an Observe's property:\n    map.attr('a', 'Alice');\n    map.a; // Alice\n\n    // removing an Observe's property;\n    map.removeAttr('a');\n    map.attr(); // {}\n\n    // Don't do this!\n    map.a = 'Adam'; // wrong!\n\n\nFind out more about manipulating properties of a map under\n[can.Map.prototype.attr attr] and [can.Map.prototype.removeAttr removeAttr].\n\n## Listening to changes\n\nThe real power of maps comes from being able to react to\nproperties being added, set, and removed. Maps emit events when\nproperties are changed that you can bind to.\n\n`Map` has two types of events that fire due to changes on a map:\n- the _change_ event fires on every change to a map.\n- an event named after the property name fires on every change to that property.\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('Something on o changed.');\n    });\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log('a was changed.');\n    });\n\n    o.attr('a', 'Alexis'); // 'Something on o changed.'\n                           // 'a was changed.'\n    o.attr({\n        'a': 'Alice',      // 'Something on o changed.' (for a's change)\n        'b': 'Bob'         // 'Something on o changed.' (for b's change)\n    });                    // 'a was changed.'\n\n    o.removeAttr('a');     // 'Something on o changed.'\n                           // 'a was changed.'\n\n\nFor more detail on how to use these events, see [can.Map.prototype.bind bind] and\n[can.Map.prototype.unbind unbind]. There is also a plugin called [can.Map.delegate]\nthat makes binding to specific types of events easier:\n\n\n    var o = new Map({});\n    o.delegate('a', 'add', function(ev, newVal, oldVal) {\n        console.log('a was added.');\n    });\n    o.delegate('a', 'set', function(ev, newVal, oldVal) {\n        console.log('a was set.');\n    });\n    o.delegate('a', 'remove', function(ev, newVal, oldVal) {\n        console.log('a was removed.');\n    });\n    o.delegate('a', 'change', function(ev, newVal, oldVal) {\n        console.log('a was changed.');\n    });\n\n    o.attr('a', 'Alexis'); // 'a was added.'\n                           // 'a was changed.'\n\n    o.attr('a', 'Alice'); // 'a was set.'\n                          // 'a was changed.'\n\n    o.removeAttr('a'); // 'a was removed.'\n                       // 'a was changed.'\n\n## Object.prototype.watch\n\nDue to a method available on the base Object prototype called \"watch\", refrain from\nusing properties with the same name on Gecko based browsers as there will be a\ncollision. [Source](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/watch)\n\n",
    "description": "Create observable objects. \n",
    "name": "can-map",
    "type": "module",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "inherits": "can",
    "parent": "can-legacy",
    "test": "can/map/test.html",
    "plugin": "can/map",
    "release": "2.0",
    "link": "../docco/map/map.html docco",
    "signatures": [
      {
        "code": "new Map([props])",
        "description": "\n\nCreates a new instance of can.Map.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the Observe with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "An instance of `can.Map` with the properties from _props_.\n"
        }
      },
      {
        "code": "Map.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function.\n\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "An instance of `can.Map` with the properties from _props_.\n"
    },
    "comment": " "
  },
  "can-map-define": {
    "src": {
      "path": "node_modules/can-map-define/can-map-define.md"
    },
    "body": "\nDefine rich attribute behavior\n\n",
    "description": "\n# can-map-define\n",
    "name": "can-map-define",
    "type": "page"
  },
  "can-observation": {
    "type": "module",
    "name": "can-observation",
    "parent": "can-infrastructure",
    "src": {
      "line": 19,
      "codeLine": 26,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "signatures": [
      {
        "code": "new Observation(func, context, compute)",
        "description": "\n",
        "params": []
      }
    ]
  },
  "observed": {
    "name": "observed",
    "type": "typedef",
    "parent": "can-observation",
    "src": {
      "line": 186,
      "codeLine": 203,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": " \nAn object representing an observation.\n\n```js\n{ \"obj\": map, \"event\": \"prop1\" }\n```\n\n",
    "title": "observed",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "obj",
            "description": "The observable object",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "event",
            "description": "The event, or more likely property, that is being observed.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ]
  },
  "Observation.add": {
    "type": "function",
    "name": "Observation.add",
    "parent": "can-observation",
    "src": {
      "line": 255,
      "codeLine": 273,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "\nSignals that an object's property is being observed, so that any functions that are recording observations will see that this object is a dependency.\n\n",
    "description": "",
    "title": "add",
    "signatures": [
      {
        "code": "Observation.add(obj, event)",
        "description": "\n\nSignals that an event should be observed. Adds the observable being read to\nthe top of the stack.\n\n```js\nObservation.add(obj, \"prop1\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An observable object which is being observed."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event (or property) that is being observed."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "event",
      "description": "The name of the event (or property) that is being observed."
    },
    "comment": " "
  },
  "Observation.addAll": {
    "type": "function",
    "name": "Observation.addAll",
    "parent": "can-observation",
    "src": {
      "line": 291,
      "codeLine": 310,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "addAll",
    "signatures": [
      {
        "code": "Observation.addAll(observes)",
        "description": "\n\nThe same as `Observation.add` but takes an array of [observed] objects.\nThis will most often by used in coordination with [Observation.trap]:\n\n```js\nvar untrap = Observation.trap();\n\nObservation.add(obj, \"prop3\");\n\nvar traps = untrap();\nOservation.addAll(traps);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "observed"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "observes",
            "description": "An array of [observed]s.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "observed"
                }
              ]
            }
          ]
        }
      ],
      "name": "observes",
      "description": "An array of [observed]s.\n"
    }
  },
  "Observation.ignore": {
    "type": "function",
    "name": "Observation.ignore",
    "parent": "can-observation",
    "src": {
      "line": 331,
      "codeLine": 354,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "ignore",
    "signatures": [
      {
        "code": "Observation.ignore(fn)",
        "description": "\n\nCreates a function that, when called, will prevent observations from\nbeing applied.\n\n```js\nvar fn = Observation.ignore(function(){\n  // This will be ignored\n  Observation.add(obj, \"prop1\");\n});\n\nfn();\nObservation.trapCount(); // -> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "Any function that contains potential calls to \n[Observation.add].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function that is free of observation side-effects.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "Any function that contains potential calls to \n[Observation.add].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function that is free of observation side-effects.\n"
    }
  },
  "Observation.trap": {
    "type": "function",
    "name": "Observation.trap",
    "parent": "can-observation",
    "src": {
      "line": 369,
      "codeLine": 388,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "trap",
    "signatures": [
      {
        "code": "Observation.trap()",
        "description": "\n\nTrap all observations until the `untrap` function is called. The state of \ntraps prior to `Observation.trap()` will be restored when `untrap()` is called.\n\n```js\nvar untrap = Observation.trap();\n\nObservation.add(obj, \"prop1\");\n\nvar traps = untrap();\nconsole.log(traps[0].obj === obj); // -> true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function to untrap the current observations.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function to untrap the current observations.\n"
    }
  },
  "Observation.isRecording": {
    "type": "function",
    "name": "Observation.isRecording",
    "parent": "can-observation",
    "src": {
      "line": 412,
      "codeLine": 421,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "isRecording",
    "signatures": [
      {
        "code": "Observation.isRecording()",
        "description": "\n\nReturns if some function is in the process of recording observes.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if a function is in the process of recording observes.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if a function is in the process of recording observes.\n"
    }
  },
  "can-observe-info": {
    "src": {
      "path": "node_modules/can-observe-info/can-observe-info.md"
    },
    "body": "\nCore observable indicators\n\n",
    "description": "\n# can-observe-info\n",
    "name": "can-observe-info",
    "type": "page"
  },
  "can-route.param": {
    "type": "function",
    "name": "can-route.param",
    "parent": "canRoute.static",
    "src": {
      "line": 282,
      "codeLine": 306,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Parameterizes the raw JS object representation provided in data.\n\n   canRoute.param( { type: \"video\", id: 5 } )\n         // -> \"type=video&id=5\"\n\nIf a route matching the provided data is found, that URL is built\nfrom the data. Any remaining data is added at the end of the\nURL as &amp; separated key/value parameters.\n\n   canRoute(\":type/:id\")\n\n   canRoute.param( { type: \"video\", id: 5 } ) // -> \"video/5\"\n   canRoute.param( { type: \"video\", id: 5, isNew: false } )\n         // -> \"video/5&isNew=false\"\n \n",
    "description": "Get a route path from given data. ",
    "title": "param",
    "signatures": [
      {
        "code": "route.param(data)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "data"
              }
            ],
            "name": "object",
            "description": "The data to populate the route with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The route, with the data populated in it.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "data"
        }
      ],
      "name": "object",
      "description": "The data to populate the route with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The route, with the data populated in it.\n"
    },
    "comment": " "
  },
  "can-route.deparam": {
    "type": "function",
    "name": "can-route.deparam",
    "parent": "can-route.static",
    "src": {
      "line": 370,
      "codeLine": 420,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Creates a data object based on the query string passed into it. This is\nuseful to create an object based on the `location.hash`.\n\n```js\ncanRoute.deparam(\"id=5&type=videos\")\n  // -> { id: 5, type: \"videos\" }\n```\n\n\nIt's important to make sure the hash or exclamantion point is not passed\nto `canRoute.deparam` otherwise it will be included in the first property's\nname.\n\n```js\ncanRoute.attr(\"id\", 5) // location.hash -> #!id=5\ncanRoute.attr(\"type\", \"videos\")\n  // location.hash -> #!id=5&type=videos\ncanRoute.deparam(location.hash)\n  // -> { #!id: 5, type: \"videos\" }\n```\n\n`canRoute.deparam` will try and find a matching route and, if it does,\nwill deconstruct the URL and parse our the key/value parameters into the data object.\n\n```js\ncanRoute(\":type/:id\")\n\ncanRoute.deparam(\"videos/5\");\n  // -> { id: 5, route: \":type/:id\", type: \"videos\" }\n```\n \n",
    "description": "Extract data from a route path. ",
    "title": "deparam",
    "signatures": [
      {
        "code": "route.deparam(url)",
        "description": "\n\nExtract data from a url, creating an object representing its values.\n\n```js\nroute(\":page\");\n\nvar result = route.deparam(\"page=home\");\nconsole.log(result.page); // -> \"home\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "url",
            "description": "A route fragment to extract data from."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object containing the extracted data.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "url",
      "description": "A route fragment to extract data from."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object containing the extracted data.\n"
    },
    "comment": " "
  },
  "static.routes": {
    "name": "static.routes",
    "type": "property",
    "parent": "static",
    "src": {
      "line": 476,
      "codeLine": 495,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n - test - A regular expression that will match the route when variable values\n   are present; i.e. for :page/:type the `RegExp` is /([\\w\\.]*)/([\\w\\.]*)/ which\n   will match for any value of :page and :type (word chars or period).\n\n - route - The original URL, same as the index for this entry in routes.\n\n - names - An array of all the variable names in this route\n\n - defaults - Default values provided for the variables or an empty object.\n\n - length - The number of parts in the URL separated by '/'.\n \n",
    "description": "\nA list of routes recognized by the router indixed by the url used to add it.\nEach route is an object with these members:\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "",
    "hide": true
  },
  "can-route.ready": {
    "type": "function",
    "name": "can-route.ready",
    "parent": "can-route.static",
    "src": {
      "line": 496,
      "codeLine": 528,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n\n## Use\n\nAfter setting all your routes, callcanRoute.ready().\n\n```js\ncanRoute(\"overview/:dateStart-:dateEnd\");\ncanRoute(\":type/:id\")\ncanRoute.ready()\n```\n \n",
    "description": "\nInitializes can-route.\n",
    "title": "ready",
    "signatures": [
      {
        "code": "route.ready()",
        "description": "\n\nSets up the two-way binding between the hash and the can-route observable\nmap and sets the route map to its initial values.\n\n```js\nroute(\":page\", { page: \"home\" }));\n\nroute.ready();\nroute.attr(\"page\"); // -> \"home\"\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "canRoute"
            }
          ],
          "description": "The can-route object.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "canRoute"
        }
      ],
      "description": "The can-route object.\n"
    },
    "comment": " "
  },
  "can-route.url": {
    "type": "function",
    "name": "can-route.url",
    "parent": "can-route.static",
    "src": {
      "line": 537,
      "codeLine": 574,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Similar to [canRoute.link], but instead of creating an anchor tag, `canRoute.url` creates\nonly the URL based on the route options passed into it.\n\n```js\ncanRoute.url( { type: \"videos\", id: 5 } )\n  // -> \"#!type=videos&id=5\"\n```\n\nIf a route matching the provided data is found the URL is built from the data. Any remaining\ndata is added at the end of the URL as & separated key/value parameters.\n\n```js\ncanRoute(\":type/:id\")\n\ncanRoute.url( { type: \"videos\", id: 5 } ) // -> \"#!videos/5\"\ncanRoute.url( { type: \"video\", id: 5, isNew: false } )\n  // -> \"#!video/5&isNew=false\"\n```\n \n",
    "description": "",
    "title": "url",
    "signatures": [
      {
        "code": "route.url(data [, merge])",
        "description": "\n\nMake a URL fragment that when set to window.location.hash will update can-route's properties\nto match those in `data`.\n\n```js\nroute.url({ page: \"home\" });\n// -> \"#!page=home\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The data to populate the route with."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Whether the given options should be merged into the current state of the route."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The route URL and query string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "merge",
      "description": "Whether the given options should be merged into the current state of the route."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The route URL and query string.\n"
    },
    "comment": " "
  },
  "can-route.link": {
    "type": "function",
    "name": "can-route.link",
    "parent": "canRoute.static",
    "src": {
      "line": 582,
      "codeLine": 626,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Creates and returns an anchor tag with an href of the route\nattributes passed into it, as well as any properties desired\nfor the tag.\n\n   canRoute.link( \"My videos\", { type: \"videos\" }, {}, false )\n         // -> <a href=\"#!type=videos\">My videos</a>\n\nOther attributes besides href can be added to the anchor tag\nby passing in a data object with the attributes desired.\n\n   canRoute.link( \"My videos\", { type: \"videos\" },\n      { className: \"new\" }, false )\n         // -> <a href=\"#!type=videos\" class=\"new\">My Videos</a>\n\nIt is possible to utilize the current route options when making anchor\ntags in order to make your code more reusable. If merge is set to true,\nthe route options passed into `canRoute.link` will be passed into the\ncurrent ones.\n\n    location.hash = \"#!type=videos\"\n   canRoute.link( \"The zoo\", { id: 5 }, true )\n         // -> <a href=\"#!type=videos&id=5\">The zoo</true>\n\n    location.hash = \"#!type=pictures\"\n   canRoute.link( \"The zoo\", { id: 5 }, true )\n         // -> <a href=\"#!type=pictures&id=5\">The zoo</true>\n\n\n \n",
    "description": "",
    "title": "link",
    "signatures": [
      {
        "code": "route.link(innerText, data, props [, merge])",
        "description": "\n\nMake an anchor tag (`<A>`) that when clicked on will updatecanRoute's properties\nto match those in `data`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "innerText",
            "description": "The text inside the link."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The data to populate the route with."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "Properties for the anchor other than `href`."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Whether the given options should be merged into the current state of the route."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A string with an anchor tag that points to the populated route.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "merge",
      "description": "Whether the given options should be merged into the current state of the route."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A string with an anchor tag that points to the populated route.\n"
    },
    "comment": " "
  },
  "can-route.current": {
    "type": "function",
    "name": "can-route.current",
    "parent": "canRoute.static",
    "src": {
      "line": 632,
      "codeLine": 656,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Checks the page's current URL to see if the route represents the options passed\ninto the function.\n\nReturns true if the options respresent the current URL.\n\n   canRoute.attr('id', 5) // location.hash -> \"#!id=5\"\n   canRoute.current({ id: 5 }) // -> true\n   canRoute.current({ id: 5, type: 'videos' }) // -> false\n\n   canRoute.attr('type', 'videos')\n           // location.hash -> #!id=5&type=videos\n   canRoute.current({ id: 5, type: 'videos' }) // -> true\n \n",
    "description": "",
    "title": "current",
    "signatures": [
      {
        "code": "route.current(data)",
        "description": "\n\nCheck if data represents the current route.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "Data to check agains the current route."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Whether the data matches the current URL.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "data",
      "description": "Data to check agains the current route."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Whether the data matches the current URL.\n"
    },
    "comment": " "
  },
  "can-route.map": {
    "src": {
      "path": "node_modules/can-route/route_map.md"
    },
    "body": "\n\n## Background\n\nOne of the biggest challenges in a complex application is getting all the different parts of the app to talk to each other simply, cleanly, and reliably. \n\nAn elegant way to solve this problem is using the [Observer Pattern](http://en.wikipedia.org/wiki/Observer_pattern). A single object, which can be called [Application State](https://www.youtube.com/watch?v=LrzK4exG5Ss), holds the high level state of the application.\n\n## Use\n\n`route.map` provides an easy to way make your Application State object cross-bound to `route`, using an internal can-map instance, which is serialized into the hash (or pushstate URLs).\n\n```js\nvar appState = new Map({\n\tpetType: \"dog\",\n\tstoreId: 2\n});\n\nroute.map(appState);\n```\n\n## When to call it\n\nCall `route.map` at the  start of the application lifecycle, before any calls to `route.bind`. This is because `route.map` creates a new internal `Map`, replacing the default `can.Map` instance, so binding has to occur on this new object.\n\n```js\nvar appState = new Map({\n\tgraphType: \"line\",\n\tcurrencyType: \"USD\"\n});\n\nroute.map(appState);\n```\n\n## Demo\n\nThe following shows creating an appState that loads data at page load, has a virtual property 'locationIds' which serializes an array, and synchronizes the appState to can-route:\n\n<div class='demo_wrapper' data-demo-src='can/route/docs/map.html'></div>\n\n## Using arrays and can.Lists\n\nIf the Application State contains a property which is any non-primitive type, its useful to use the [can-map.prototype.define define] plugin to define how that property will serialize. `route` calls [can.Map.prototype.serialize serialize] internally to turn the Application State object into URL params.\n\nThe following example shows a flags property, which is an array of string-based flags:\n\n```js\nvar AppState = Map.extend({\n\tdefine: {\n\t\tflags: {\n\t\t// return a string friendly format\n\t\tserialize: function(){\n\t\treturn this.attr('flags').join(',');\n\t\t},\n\t\t// convert a stringified object into an array\n\t\tset: function(val){\n\t\tif(val === \"\"){\n\t\t\treturn [];\n\t\t}\n\t\tvar arr = val;\n\t\tif(typeof val === \"string\"){\n\t\t\tarr = val.split(',')\n\t\t}\n\t\treturn arr;\n\t}\n\t}\n});\n\nvar appState = new AppState({\n\tflags: []\n});\n\nroute.map(appState);\n```\n\n## Complete example\n\nThe following example shows loading some metadata on page load, which must be loaded as part of the Application State before the components can be initialized\n\nIt also shows an example of a \"virtual\" property on the AppState, locationIds, which is the serialized version of a non-serializeable can.List, locations.  A setter is defined on locationIds, which will translate changes in locationIds back to the locations can.List.\n\n```js\nvar AppState = Map.extend({\n\tdefine: {\n\t\tlocations: {\n\t\t\t// don't serialize this property at all in the route\n\t\t\tserialize: false\n\t\t},\n\t\t// virtual property that contains a comma separated list of ids\n\t\t// based on locations that are selected\n\t\tlocationIds: {\n\n\t\t\t// comma separated list of ids\n\t\t\tserialize: function(){\n\t\t\t\tvar selected = this.attr('locations').filter(\n\t\t\t\t\tfunction(location){\n\t\t\t\t\t\treturn location.attr('selected');\n\t\t\t\t\t});\n\t\t\t\tvar ids = [];\n\t\t\t\tselected.each(function(item){\n\t\t\t\t\tids.push(item.attr('id'));\n\t\t\t\t})\n\t\t\t\treturn selected.join(',');\n\t\t\t},\n\t\t\t\n\t\t\t// toggle selected from a comma separated list of ids\n\t\t\tset: function(val){\n\t\t\t\tvar arr = val;\n\t\t\t\tif(typeof val === \"string\"){\n\t\t\t\t\tarr = val.split(',')\n\t\t\t\t}\n\t\t\t\t// for each id, toggle any matched location\n\t\t\t\tthis.attr('locations').each(function(location){\n\t\t\t\t\tif(arr.indexOf(location.attr('id')) !== -1){\n\t\t\t\t\t\tlocation.attr('selected', true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocation.attr('selected', false)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n});\n\n// initialize and call map first, so anything binding to can-route\n// will work correctly\nvar appState = new AppState();\nroute.map(appState);\n\n// GET /locations\nvar locations = new Location.List({});\n\n// when the data is ready, set the locations property\nlocations.done(function(){\n\tvar appState.attr('locations', locations)\n\n\t// call ready after the appState is fully initialized\n\troute.ready();\n});\n```\n\n## Why\n\nThe Application State object, which is cross-bound to the can-route via `route.map` and represents the overall state of the application, has several obvious uses:\n\n* It is passed into the various components and used to communicate their own internal state.\n* It provides deep linking and back button support. As the URL changes, Application State changes cause changes in application components.\n* It provides the ability to \"save\" the current state of the page, by serializing the Application State object and saving it on the backend, then restoring with that object to load this saved state.\n\n",
    "description": "\nAssign a can-map instance that acts as can-route's internal can-map.  The purpose for this is to cross-bind a top level state object (Application State) to the can-route.\n",
    "title": "map",
    "name": "can-route.map",
    "type": "function",
    "parent": "can-route.static",
    "signatures": [
      {
        "code": "route.map(MapConstructor)",
        "description": "\n\nBinds can-route to an instance based on a constructor. A new instance will be created and bound to:\n\n```js\nvar ViewModel = Map.attr({\n\tdefine: {\n\t\tpage: {\n\t\t\tset: function(page){\n\t\t\t\tif(page === \"user\") {\n\t\t\t\t\tthis.verifyLoggedIn();\n\t\t\t\t}\n\t\t\t\treturn page;\n\t\t\t}\n\t\t}\n\t}\n});\n\nroute.map(ViewModel);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-map"
              }
            ],
            "name": "MapConstructor",
            "description": "A can-map constructor function.  A new can-map instance will be created and used as the can-map internal to can-route.\n"
          }
        ]
      },
      {
        "code": "route.map(mapInstance)",
        "description": "\n\nBind can-route to an instance of a map.\n\n```js\nvar map = new Map({\n\tpage: \"home\"\n});\n\nroute.map(map);\n\nmap.attr(\"page\", \"user\");\n// location.hash -> \"#user\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-map"
              }
            ],
            "name": "mapInstance",
            "description": "A can-map instance, used as the can-map internal to can-route.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "name": "mapInstance",
      "description": "A can-map instance, used as the can-map internal to can-route.\n"
    },
    "comment": " "
  },
  "can-route.static": {
    "name": "can-route.static",
    "title": "static",
    "type": "group",
    "parent": "can-route",
    "description": "",
    "order": 0
  },
  "can-route": {
    "src": {
      "path": "node_modules/can-route/can-route.md"
    },
    "body": "\n## Use\n\nWatch this video for an overview of can.route's functionality and an example showing how to connect two tab widgets to the browser's history:\n\n<iframe width=\"662\" height=\"372\" src=\"https://www.youtube.com/embed/ef0LKDiaPZ0\" frameborder=\"0\" allowfullscreen></iframe>\n\nIn the following CanJS community we also talk about web application routing:\n\n<iframe width=\"662\" height=\"372\" src=\"https://www.youtube.com/embed/0Hhuv5Qru9k\" frameborder=\"0\" allowfullscreen></iframe>\n\n## Background Information\n\nTo support the browser's back button and bookmarking\nin an Ajax application, most applications use\nthe <code>window.location.hash</code>.  By\nchanging the hash (via a link or JavaScript), \none is able to add to the browser's history \nwithout changing the page.\n\nThis provides the basics needed to\ncreate history enabled Ajax websites.  However,\n`route` addresses several other needs such as:\n\n  - Pretty urls (actually hashes)\n  - Keeping routes independent of application code\n  - Listening to specific parts of the history changing\n  - Setup / Teardown of widgets.\n\n## How it works\n\n<code>route</code> is a [can-map] that represents the\n<code>window.location.hash</code> as an \nobject.  For example, if the hash looks like:\n\n    #!type=videos&id=5\n    \nthe data in <code>route</code> looks like:\n\n    { type: 'videos', id: 5 }\n\n\n`route` keeps the state of the hash in-sync with the `data` contained within \n`route`.\n\n## can-map\n\n`can-route` is a [can-map]. Understanding\n`can-map` is essential for using `can.route` correctly.\n\nYou can listen to changes in an Observe with `bind(eventName, handler(ev, args...))` and\nchange can-route's properties with \n[can.Map.prototype.attr attr].\n\n### Listening to changes in can-route\n\nListen to changes in history \nby [can.Map.prototype.bind bind]ing to\nchanges in <code>can-route</code> like:\n\n    route.bind('change', function(ev, attr, how, newVal, oldVal) {\n    \n    })\n\n - `attr` - the name of the changed attribute\n - `how` - the type of Observe change event (add, set or remove)\n - `newVal`/`oldVal` - the new and old values of the attribute\n\n### Updating can-route\n\nCreate changes in the route data with [can.Map.prototype.attr attr] like:\n\n    route.attr('type','images');\n\nOr change multiple properties at once like:\n\n    route.attr({type: 'pages', id: 5}, true)\n\nWhen you make changes to can-route, they will automatically\nchange the <code>hash</code>.\n\n## Creating a Route\n\nUse <code>route(url, defaults)</code> to create a \nroute. A route is a mapping from a url to \nan object (that is the route's state). \nIn order to map to a specific properties in the url,\nprepend a colon to the name of the property like:\n\n    route(\"#!content/:type\")\n\n\nIf no routes are added, or no route is matched, \ncan-route's data is updated with the [can.deparam deparamed]\nhash.\n\n    location.hash = \"#!type=videos\";\n    // route -> {type : \"videos\"}\n    \nOnce routes are added and the hash changes,\ncan-route looks for matching routes and uses them\nto update can-route's data.\n\n    route(\"#!content/:type\");\n    location.hash = \"#!content/images\";\n    // route -> {type : \"images\"}\n    route.attr(\"type\", \"songs\")\n    // location.hash -> \"#!content/songs\"\n    \nDefault values can be added to a route:\n\n    route(\"content/:type\",{type: \"videos\" });\n    location.hash = \"#!content/\"\n    // route -> {type : \"videos\"}\n    // location.hash -> \"#!content/\"\n\nDefaults can also be set on the root page of your app:\n\n    route(\"\", { page: \"index\" });\n    location.hash = \"#!\";\n    // route.attr() -> { page: \"index\" }\n    // location.hash -> \"#!\"\n\n## Initializing can-route\n\nAfter your application has created all of its routes, call [route.ready]\nto set can-route's data to match the current hash:\n\n     route.ready()\n\n## Changing the route.\n\nTypically, you don't set <code>location.hash</code>\ndirectly.  Instead, you can change properties on <code>route</code>\nlike:\n\n    route.attr('type', 'videos')\n    \nThis will automatically look up the appropriate \nroute and update the hash.\n\nOften, you want to create links.  <code>route</code> provides\nthe [route.link] and [route.url] helpers to make this \neasy:\n\n    route.link(\"Videos\", {type: 'videos'})\n\n## Demo\n\nThe following demo shows the relationship between `window.location.hash`,\nroutes given to `can.data`,\n`route`'s data, and events on `can.data`.  Most properties \nare editable so experiment!\n\n<div class='iframe_wrapper' data-iframe-src='can/route/demo.html' data-iframe-height='980'></div>\n## IE Compatibility\n\nInternet Explorer 6 and 7 does not support `window.onhashchange`. \nEven Internet Explorer 8 running in IE7 compatibility mode reports `true` \nfor `onhashchange` in window, even though the event isn't supported.\n\nIf you are using jQuery, you can include Ben Alman's [HashChange Plugin](http://benalman.com/projects/jquery-hashchange-plugin/)\nto support the event in the unsupported browser(s).\n\n",
    "description": "Manage browser history and client state by synchronizing the window.location.hash with\na [can-map].\n\n",
    "title": "can-route",
    "name": "can-route",
    "parent": "can-core",
    "type": "function",
    "inherits": "can",
    "download": "can/route",
    "test": "can-route/test.html",
    "link": "../docco/route/route.html docco",
    "signatures": [
      {
        "code": "route(template [, defaults])",
        "description": "\n\nCreate a route matching rule. Optionally provide defaults that will be applied to the [can-map] when the route matches.\n\n```js\nroute(\":page\", { page: \"home\" });\n```\n\nWill apply **cart** when the url is `#cart` and **home** when the url is `#`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "the fragment identifier to match.  The fragment identifier\nshould start with either a character (a-Z) or colon (:).  Examples:\n\n```js\nroute(\":foo\")\nroute(\"foo/:bar\")\n```\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "defaults",
            "description": "An object of default values."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.route"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "defaults",
      "description": "An object of default values."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.route"
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "route.pushstate.root": {
    "src": {
      "line": 30,
      "codeLine": 65,
      "path": "node_modules/can-route-pushstate/can-route-pushstate.js"
    },
    "type": "property",
    "body": "\n## Use\n\nBy default, a route like:\n\n    route(\":type/:id\")\n\nMatches urls like:\n\n    http://domain.com/contact/5\n\nBut sometimes, you only want to match pages within a certain directory.  For\nexample, an application that is a filemanager.  You might want to\nspecify root and routes like:\n\n    route.pushstate.root = \"/filemanager/\"\n    route(\"file-:fileId\");\n    route(\"folder-:fileId\")\n\nWhich matches urls like:\n\n    http://domain.com/filemanager/file-34234\n\n\t \n",
    "description": "Configure the base url that will not be modified. \n",
    "types": [
      {
        "type": "String",
        "description": "Represents the base url that pushstate will prepend to all\nroutes.  `root` defaults to: `\"/\"`.\n"
      }
    ],
    "title": "",
    "name": "route.pushstate.root",
    "parent": "route.pushstate",
    "comment": " "
  },
  "can-route-pushstate": {
    "src": {
      "path": "node_modules/can-route-pushstate/can-route-pushstate.md"
    },
    "body": "\n## Use\n\nThe pushstate plugin uses the same API as [can-route]. To start using pushstate plugin all you need is to import `can-route-pushstate`, it will set itself as default binding on [can.route].\n\nYou can check current binding by inspecting `route.currentBinding`, the default value is `\"hashchange\"`.\n\n### Creating and changing routes\n\nTo [create](route.html#section_CreatingaRoute) route use `route(url, defaults)` like:\n\n```js\nroute(\":page\", {page: 'homepage'});\nroute(\"contacts/:username\");\nroute(\"books/:genre/:author\");\nroute.ready(); // do not forget to initialize can-route\n```\n\nDo not forget to [initialize](route.ready.html) can-route after creating all routes, do it by calling `route.ready()`.\n\nList of defined routes is contained in `route.routes`, you can examine current route state by calling:\n\n```js\nroute.attr(); //-> {page: \"homepage\", route: \":page\"}\n```\n\nAfter creating routes and initializing can-route you can update current route by calling `route.attr(attr, newVal)`:\n\n```js\nroute.attr('page', 'about');\nroute.attr(); //-> {page: \"about\", route: \":page\"}\n\n// without cleaning current route state\nroute.attr('username', 'veljko');\nroute.attr(); //-> {page: \"about\", route: \":page\", username: 'veljko'}\n\n// with cleaning current can-route state\nroute.attr({username: 'veljko'}, true);\nroute.attr(); //-> {username: \"veljko\", route: \"contacts/:username\"}\n```\n\nTo update multiple attributes at once pass hash of attributes to `route.attr(hashOfAttrs, true)`. Pass `true` as second argument to clean up current state.\n\n```js\nroute.attr({genre: 'sf', author: 'adams'}, true);\nroute.attr(); //-> {genre: \"sf\", author: \"adams\", route: \"books/:genre/:author\"}\n```\n\n`window.location` acts as expected:\n\n```js\nwindow.location.pathname; //-> \"/books/sf/adams\"\nwindow.location.hash; //-> \"\", hash remains unchanged\n```\n\nTo generate urls use `route.url({attrs})`:\n\n```js\nroute.url({username: 'justinbmeyer'}); //-> '/contacts/justinbmeyer'\n```\n\n### Listening changes on matched route\n\nAs can-route is basically a [can-map] that represents `window.location.pathname`, you can bind on it in the same way you would on any can.Map object.\n\nTo listen on any changes on `route` use `route.bind('change', callback)`, the following params will be passed to callback function:\n\n```js\nroute.bind('change', function(ev, attr, how, newVal, oldVal) {\n\t//-> ev:     {EventObject}\n\t//-> attr:   'username'\n\t//-> how:    'change'\n\t//-> newVal: 'veljko'\n\t//-> oldVal: undefined\n});\n\nroute.attr({username: 'veljko'}, true);\n```\n\nYou can also bind to specific attribute on can-route:\n\n```js\nroute.bind('username', function(ev, newVal, oldVal) {\n\t//-> ev:     {EventObject}\n\t//-> newVal: 'nikica'\n\t//-> oldVal: 'veljko'\n});\n\nroute.attr({username: nikica}, true);\n```\n\n### Using different pathname root\n\nPushstate plugin has one additional property, `route.bindings.pushstate.root`, which specifies the part of that pathname that should not change. For example, if we only want to have pathnames within `http://example.com/contacts/`, we can specify a root like:\n\n```js\nroute.bindings.pushstate.root = \"/contacts/\"\nroute(\":page\");\nroute.url({page: \"list\"}) //-> \"/contacts/list\"\nroute.url({foo: \"bar\"})   //-> \"/contacts/?foo=bar\"\n```\n\nNow, all routes will start with `\"/contacts/\"`, the default `route.bindings.pushstate.root` value is `\"/\"`.\n\n## Planning route structure\n\nComplications can arise if your route structure mimics the folder structure inside your app's public directory.  For example, if you have a folder structure like the one in this url for your admin app...\n\n`/admin/users/list.js`\n\n... using a route of /admin/users on the same page that uses the list.js file will require the use of a trailing slash on all routes and links.  The browser already learned that '/admin/users' is folder.  Because folders were originally denoted by a trailing slash in a url, the browser will correct the url to be '/admin/users/'.  While it is possible to add the trailing slash in routes and listen for them, any link to the page that omits the trailing slash will not trigger the route handler.\n\n",
    "description": "Changes [can-route](https://github.com/canjs/can-route) to use [pushstate](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history)\nto change the window's [pathname](https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.pathname) instead\nof the [hash](https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.hash).\n\n```js\nvar route = require(\"can-route-pushstate\");\n\nroute(\":page\", { page: \"home\" });\nroute.ready();\n\nroute.attr(\"page\", \"user\");\n\nlocation.pathname; // -> \"/user\"\n```\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "The",
            "description": "pushstate object comprises several properties that configure the behavior of [can-route] to work with `history.pushstate`.\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can-route-pushstate",
    "parent": "can-core",
    "download": "can/route/pushstate",
    "link": "../docco/route/pushstate/pushstate.html docco",
    "comment": " "
  },
  "can-simple-map": {
    "src": {
      "path": "node_modules/can-simple-map/can-simple-map.md"
    },
    "body": "\nA performant live-bound map\n\n",
    "description": "\n# can-simple-map\n",
    "name": "can-simple-map",
    "type": "page"
  },
  "can-util": {
    "src": {
      "path": "node_modules/can-util/doc/can-util.md"
    },
    "body": "\n",
    "description": "\nA set of utilities.\n",
    "name": "can-util",
    "type": "page",
    "parent": "can-infrastructure"
  },
  "can-vdom": {
    "src": {
      "path": "node_modules/can-vdom/can-vdom.md"
    },
    "body": "\nA browser-lite environment for nodejs\n\n",
    "description": "\n# can-vdom\n",
    "name": "can-vdom",
    "type": "page"
  },
  "can/view/autorender": {
    "src": {
      "path": "node_modules/can-view-autorender/autorender.md"
    },
    "body": "\n\n## Use\n\nAs long is this module is part of your CanJS build or imported with RequireJS, StealJS, or SystemJS,\n[can/view/autorender.can-autorender] will automatically look for `can-autorender` tags and render them.  Once\nall templates have finished rendering, it will call any callbacks passed to `can.autorender()`.\n\n\nFor example, you might have a page like:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'\n\t\tmessage=\"Hello World\">\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\n\t<script src='jquery.js'></script>\n\t<!-- A CanJS build that includes this plugin -->\n\t<script src='can.custom.js'></script>\n\t<!-- All your app's code and components -->\n\t<script src='app.js'></script>\n\t<script>\n\t\t// Wait until everything has rendered.\n\t\tcan.autorender(function(){\n\n\t\t\t// Update the viewModel the template was rendred with:\n\t\t\t$(\"#main\").viewModel().attr(\"message\",\"Rendered!\");\n\n\t\t})\n\t</script>\n</body>\n```\n\n## Rendered placement\n\nIf the template source is a `<script>` tag within the `<body>`, the rendered template is placed\nimmediately following the template.\n\nFor example:\n\n```\n<body>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n\t<div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n\tHi!\n\t<div>...</div>\n</body>\n```\n\nIf the `<script>` tag is outside the body, for example in the `<head>`\ntag, the rendered result will be placed just before the closing `</body>` tag.\n\nFor example:\n\n```\n<head>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n</head>\n<body>\n\t<div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<head>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n</head>\n<body>\n\t<div>...</div>\n\tHi!\n</body>\n```\n\nIf the template source is any other element, the element's contents will be replaced with the rendered result.  For example:\n\n```\n<body>\n\t<div type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n\t<div type='text/stache' can-autorender message=\"Hi\">\n\t\tHi!\n\t</div>\n</body>\n```\n\n## Scope\n\nThe template is rendered with a [can.Map] made from the attributes of the\ntemplate source element.  That `map` is available on the\ntemplate source element via [can.viewModel].  You can\nchange the map at any time:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'>\n\t\t{{message}}!\n\t</script>\n\t<script>\n\t\tvar viewModel = can.viewModel(document.getElementById(\"main\"));\n\t\tviewModel.attr(\"message\",\"Hello There!\");\n\t</script>\n</body>\n```\n\nYou can change attributes on the element and it will update the\nviewModel too:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'>\n\t\t{{message}}!\n\t</script>\n\t<script>\n\t\tvar main = document.getElementById(\"main\");\n\t\tmain.setAttribute(\"message\",\"Hello There!\");\n\t</script>\n</body>\n```\n\n\n\n## StealJS Use\n\nFor demo pages that require very little setup:\n\n```\n<body>\n\t<script type='text/stache'>\n\t\t<can-import from=\"components/my-component\"/>\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\t<script src='../node_modules/steal/steal.js'\n\t\t\t\t\tmain='can/view/autorender/'>\n\t</script>\n</body>\n```\n\nFor demo pages that require a little custom setup:\n\n```\n<body>\n\t<script type='text/stache' can-autorender>\n\t\t<can-import from=\"components/my-component\"/>\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\t<script src='../node_modules/steal/steal.js'\n\t\t\t\t\tmain='@empty'>\n\t\tvar can = require('can');\n\t\tvar $ = reqire('jquery');\n\t\trequire('can/view/autorender/autorender');\n\n\t\t$(\"my-component\").viewModel().attr(\"message\", \"Hi\");\n\t</script>\n</body>\n```\n\n\n\n\n\n## Errors\n\nError callbacks will be called if a template has a parsing error or\na [can/view/stache/system.import] fails.\n\n",
    "description": "\nA module that automatically renders script and other elements with\nthe [can/view/autorender.can-autorender] attribute. This function is useful to know when\nthe templates have finished rendering.\n",
    "type": "module",
    "title": "can.autorender",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can/view/autorender",
    "parent": "can.view.plugins",
    "signatures": [
      {
        "code": "can.autorender(succcess, error)",
        "description": "\n\n\tRegisters functions to callback when all templates successfully render or an error in rendering happens.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "success",
            "description": "A function to callback when all autorendered templates have been rendered\nsuccessfully.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function to callback if a template was not rendered successfully.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function to callback if a template was not rendered successfully.\n"
    },
    "comment": " "
  },
  "can-view-autorender": {
    "src": {
      "path": "node_modules/can-view-autorender/can-view-autorender.md"
    },
    "body": "\nAutomatically render templates found in the document\n\n",
    "description": "\n# can-view-autorender\n",
    "name": "can-view-autorender",
    "type": "page"
  },
  "can-view-import": {
    "src": {
      "path": "node_modules/can-view-import/can-view-import.md"
    },
    "body": "\nImport dependencies in CanJS views\n\n",
    "description": "\n# can-view-import\n",
    "name": "can-view-import",
    "type": "page"
  },
  "can-view-model": {
    "src": {
      "path": "node_modules/can-view-model/can-view-model.md"
    },
    "body": "\ngets or sets the view model of an element\n\n",
    "description": "\n# can-view-model\n",
    "name": "can-view-model",
    "type": "page"
  },
  "can.view.elements.after": {
    "type": "function",
    "name": "can.view.elements.after",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "HTMLElement"
                  }
                ]
              }
            ]
          }
        ],
        "name": "oldElements",
        "description": ""
      },
      {
        "types": [
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "newFrag",
        "description": "\n "
      }
    ],
    "parent": "can.view.elements",
    "src": {
      "line": 405,
      "codeLine": 414,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "\n",
    "description": "\nInserts newFrag after oldElements.\n",
    "title": "",
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "newFrag",
      "description": "\n "
    }
  },
  "can.view.elements.replace": {
    "type": "function",
    "name": "can.view.elements.replace",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "HTMLElement"
                  }
                ]
              }
            ]
          }
        ],
        "name": "oldElements",
        "description": ""
      },
      {
        "types": [
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "newFrag",
        "description": "\n "
      }
    ],
    "parent": "can.view.elements",
    "src": {
      "line": 423,
      "codeLine": 432,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "\n",
    "description": "\nReplaces `oldElements` with `newFrag`\n",
    "title": "",
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "newFrag",
      "description": "\n "
    }
  },
  "can-view-nodelist": {
    "src": {
      "path": "node_modules/can-view-nodelist/can-view-nodelist.md"
    },
    "body": "\nAdds nesting of text nodes\n\n",
    "description": "\n# can-view-nodelist\n",
    "name": "can-view-nodelist",
    "type": "page"
  },
  "can.view.Scope": {
    "name": "can.view.Scope",
    "type": "add",
    "description": "undefined\n"
  },
  "can.view.Scope.static": {
    "src": {
      "line": 33,
      "codeLine": 36,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "can.view.Scope.static",
    "parent": "can.view.Scope",
    "title": "static"
  },
  "can.view.Scope.prototype": {
    "src": {
      "line": 51,
      "codeLine": 54,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\n",
    "name": "can.view.Scope.prototype",
    "parent": "can.view.Scope",
    "title": "prototype"
  },
  "can.view.Scope.prototype.read": {
    "type": "function",
    "name": "can.view.Scope.prototype.read",
    "params": [
      {
        "types": [
          {
            "type": "can.stache.key"
          }
        ],
        "name": "attr",
        "description": "A dot seperated path.  Use `\".\"` if you have a property name that includes a dot."
      },
      {
        "types": [
          {
            "type": "can.view.Scope.readOptions"
          }
        ],
        "name": "options",
        "description": "that configure how this gets read."
      }
    ],
    "parent": "can.view.Scope.prototype",
    "src": {
      "line": 77,
      "codeLine": 87,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "body": "",
    "description": "",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "can.view.Scope.readOptions"
        }
      ],
      "name": "options",
      "description": "that configure how this gets read."
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "parent",
              "description": "the value's immediate parent",
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            },
            {
              "name": "rootObserve",
              "description": "the first observable to read from.",
              "types": [
                {
                  "type": "can.Map"
                },
                {
                  "type": "can.compute"
                }
              ]
            },
            {
              "name": "reads",
              "description": "An array of properties that can be used to read from the rootObserve to get the value.",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "String"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "value",
              "description": "the found value\n ",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "parent",
              "description": "the value's immediate parent",
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            },
            {
              "name": "rootObserve",
              "description": "the first observable to read from.",
              "types": [
                {
                  "type": "can.Map"
                },
                {
                  "type": "can.compute"
                }
              ]
            },
            {
              "name": "reads",
              "description": "An array of properties that can be used to read from the rootObserve to get the value.",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "String"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "value",
              "description": "the found value\n ",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    }
  },
  "cloneNode": {
    "name": "cloneNode",
    "type": "function",
    "parent": "node_modules/can-view-target/can-view-target.js",
    "src": {
      "line": 51,
      "codeLine": 62,
      "path": "node_modules/can-view-target/can-view-target.js"
    },
    "body": "\n",
    "description": "\nA custom cloneNode function to be used in browsers that properly support cloning\nof custom tags (IE8 for example). Fixes it by doing some manual cloning that\nuses innerHTML instead, which has been shimmed.\n",
    "title": "",
    "hide": true,
    "params": [
      {
        "types": [
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "frag",
        "description": "A document fragment to clone"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "frag",
      "description": "A document fragment to clone"
    },
    "returns": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "a new fragment that is a clone of the provided argument\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "a new fragment that is a clone of the provided argument\n"
    }
  },
  "can-view-target": {
    "src": {
      "path": "node_modules/can-view-target/can-view-target.md"
    },
    "body": "",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-target",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "target(nodes)",
        "description": "\n\nCreate a document fragment that can be cloned but have callbacks be\ncalled quickly on elements within the cloned fragment.\n\n```js\nvar viewTarget = require(\"can-view-target\");\n\nvar target = viewTarget([\n\t{\n\t\ttag: \"h1\",\n\t\tcallbacks: [function(data){\n\t\t\tthis.className = data.className\n\t\t}],\n\t\tchildren: [\n\t\t\t\"Hello \",\n\t\t\tfunction(){\n\t\t\t\tthis.nodeValue = data.message\n\t\t\t}\n\t\t]\n\t},\n]);\n\n// target.clone -> <h1>|Hello||</h1>\n// target.paths -> path: [0], callbacks: [], children: {paths: [1], callbacks:[function(){}]}\n\nvar frag = target.hydrate({className: \"title\", message: \"World\"});\n\nfrag //-> <h1 class='title'>Hello World</h1>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "nodes",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "nodes",
      "description": "\n"
    }
  },
  "can-core": {
    "src": {
      "path": "docs/can-canjs/can-core.md"
    },
    "body": "\n## Use\n\nCanJS's core libraries are the modules most commonly used to build web\napplications.  Each module is part of an independent package, so you\nshould install the ones you use directly:\n\n```\nnpm install can-define can-set can-connect can-component can-stache can-route --save\n```\n\nLets export each one a bit more.\n\n## can-compute\n\n[can-compute]s represent an observable value.  A compute can contain its\nown value and notify listeners of changes like:\n\n```js\nvar compute = require(\"can-compute\");\n\nvar name = compute(\"Justin\");\n\n// read the value\nname() //-> \"Justin\"\n\nname.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Matthew\"\n\toldVal //-> \"Justin\"\n});\n\nname(\"Matthew\");\n```\n\nMore commonly, a compute derives its value from other observables:\n\n```js\nvar DefineMap = require(\"can-define/map/map\"),\n\tDefineList = require(\"can-define/list/list\"),\n\tcompute = require(\"can-compute\");\n\nvar person = new DefineMap({first: \"Justin\", last: \"Meyer\"}),\n\thobbies = new DefineList([\"js\",\"bball\"]),\n\tage = compute(33);\n\nvar info = compute(function(){\n\treturn person.first +\" \"+ person.last+ \" is \"+age()+\n\t\t\"and like \"+hobbies.join(\", \")+\".\";\n});\n\ninfo() //-> \"Justin Meyer is 33 and likes js, bball.\"\n\ninfo.on(\"change\", function(ev, newVal){\n\tnewVal //-> \"Justin Meyer is 33 and likes js.\"\n});\n\nhobbies.pop();\n```\n\n\n## can-define\n\n[can-define/map/map] and [can-define/list/list] allow you to create observable\nmaps and lists with well defined properties.  You can\n[can-define.types.propDefinition define a property's type initial value, enumerability, getter-setters and much more].\nFor example, you can define the behavior of a `Todo` type and a `TodoList` type as follows:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({\n  name: \"string\",\n  complete: {type: \"boolean\", value: false},\n  dueDate: \"date\",\n  isPastDue: {\n    get: function(){\n\t  return new Date() <  this.dueDate;\n\t}\n  },\n  toggleComplete: function(){\n    this.complete = !this.complete;\n  }\n});\n\nvar TodoList = DefineList.extend({\n  \"*\": Todo,\n  completeCount: {\n    get: function(){\n      return this.filter(\"complete\").length;\n    }\n  }\n});\n```\n\nThis allows you to create a Todo, read its properties, and\ncall back its methods like:\n\n```js\nvar dishes = new Todo({\n\tname: \"do dishes\",\n\t// due yesterday\n\tdueDate: new Date() - 1000 * 60 * 60 * 24\n});\ndishes.name      //-> \"do dishes\"\ndishes.isPastDue //-> true\ndishes.complete  //-> false\ndishes.toggleComplete()  \ndishes.complete  //-> true\n```\n\nAnd it allows you to create a `TodoList`, access its items and properties\nlike:\n\n```js\nvar todos = new TodoList( dishes, {name: \"mow lawn\", dueDate: new Date()});\ntodos.length         //-> 2\ntodos[0].complete    //-> true\ntodos.completeCount //-> 1\n```\n\nThese observables provide the foundation\nfor data connection (models), view-models and even routing in your application.\n\n## can-set\n\n[can-set] models a service layer's behavior as a [can-set.Algebra set.Algebra]. Once modeled, other libraries such as [can-connect] or [can-fixture] can\nadd a host of functionality like: real-time behavior, performance optimizations, and\nsimulated service layers.\n\nA `todosAlgebra` set algebra for a `GET /api/todos` service might look like:\n\n```js\nvar set = require(\"can-set\");\nvar todosAlgebra = new set.Algebra(\n    // specify the unique identifier property on data\n    set.prop.id(\"_id\"),  \n    // specify that completed can be true, false or undefined\n    set.prop.boolean(\"complete\"),\n    // specify the property that controls sorting\n    set.prop.sort(\"orderBy\")\n)\n```\n\nThis assumes that the service:\n\n - Returns data where the unique property name is `_id`:\n   ```js\n   GET /api/todos\n   -> [{_id: 1, name: \"mow lawn\", complete: true},\n       {_id: 2, name: \"do dishes\", complete: false}, ...]\n   ```\n - Can filter by a `complete` property:\n   ```js\n   GET /api/todos?complete=false\n   -> [{_id: 2, name: \"do dishes\", complete: false}, ...]\n   ```\n - Sorts by an `orderBy` property:\n   ```js\n   GET /api/todos?orderBy=name\n   -> [{_id: 2, name: \"do dishes\", complete: false},\n       {_id: 1, name: \"mow lawn\", complete: true}]\n   ```\n\n## can-connect\n\n[can-connect] connects a data type, typically a `DefineMap` and its `DefineList`,\nto a service layer. This is often done via the\n[can-connect/can/super-map] module which bundles many common behaviors\nand performance techniques into a single api:\n\n```js\nvar superMap = require(\"can-connect/can/super-map/super-map\"),\n    DefineMap = require(\"can-define/map/map\"),\n    DefineList = require(\"can-define/list/list\"),\n\tset = require(\"can-set\");\n\nvar Todo = DefineMap.extend({\n\t...\n});\nvar TodosList = DefineMap.extend({\n\t\"*\": Todo,\n\t...\n});\nvar todosAlgebra = new set.Algebra({\n\t...\n});\n\nvar connection = superMap({\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList,\n\talgebra: todosAlgebra,\n\tname: \"todo\"\n});\n```\n\n`superMap` extends the `Map` type, in this case, `Todo`, with\nthe ability to make requests to the service layer.\n\n - Get a list of Todos\n   ```js\n   Todo.getList({complete: true}).then(function(todos){})\n   ```\n - Get a single Todo\n   ```js\n   Todo.get({_id: 6}).then(function(todo){})\n   ```\n - Create a Todo\n   ```js\n   var todo = new Todo({name: \"do dishes\", complete: false})\n   todo.save().then(function(todo){})\n   ```\n - Update an already created Todo\n   ```js\n   todo.complete = true;\n   todo.save().then(function(todo){})\n   ```\n - Delete a Todo\n   ```js\n   todo.destroy().then(function(todo){})\n   ```\n\n[can-connect] is also middleware, so custom connections can\nbe assembled too:\n\n```js\nvar base = require(\"can-connect/base/base\");\nvar dataUrl = require(\"can-connect/data-url/data-url\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar map = require(\"can-connect/can/map/map\");\n\nvar options = {\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList,\n\talgebra: todosAlgebra,\n\tname: \"todo\"\n}\nvar connection = map(constructor(dataUrl(base(options))));\n```\n\n## can-stache\n\n[can-stache] provides live binding mustache and handlebars syntax. While\ntemplates should typically be loaded with a module loader like [steal-stache],\nyou can create a template programmatically that lists out todos within a\npromise loaded from `Todo.getList` like:\n\n```js\nvar stache = require(\"can-stache\");\n\n// Creates a template\nvar template = stache(\n\t\"<ul>\"+\n\t\t\"{{#if todos.isPending}}<li>Loading...</li>{{/if}}\"+\n\t\t\"{{#if todos.isResolved}}\"+\n\t\t\t\"{{#each todos.value}}\"+\n\t\t\t\t\"<li class='{{#complete}}complete{{/complete}}'>{{name}}</li>\"+\n\t\t\t\"{{else}}\"+\n\t\t\t\t\"<li>No todos</li>\"+\n\t\t\t\"{{/each}}\"+\n\t\t\"{{/if}}\"+\n\t\"</ul>\");\n\n// Calls the template with some data\nvar frag = template({\n\ttodos: Todo.getList({})\n});\n\n// Inserts the result into the page\ndocument.body.appendChild(frag);\n```\n\n[can-stache] templates use magic tags like `{{}}` to control what\ncontent is rendered. The most common forms of those magic tags are:\n\n - [can-stache.tags.escaped {{key}}] - Insert the value at `key` in the page. If `key` is a function or helper, run it and insert the result.\n - [can-stache.tags.section {{#key}}...{{/key}}] - Render the content between magic tags based on some criteria.  \n\n[can-stache] templates return document fragments that update whenever\ntheir source data changes.\n\n## can-component\n\n[can-component] creates custom elements with unit-testable view models. It\ncombines a view model created by [can-define/map/map] with a template\ncreated by [can-stache].\n\n```js\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\n// Defines the todos-list view model\nvar TodosListVM = DefineMap.extend({\n\t// An initial value that is a promise containing the\n\t// list of all todos.\n\ttodos: {\n\t\tvalue: function(){\n\t\t\treturn Todo.getList({});\n\t\t}\n\t},\n\t// A method that toggles a todo's complete property\n\t// and updates the todo on the server.\n\ttoggleComplete: function(todo){\n\t\ttodo.complete = !todo.complete;\n\t\ttodo.save();\n\t}\n});\n\nComponent.extend({\n\ttag: \"todos-list\",\n\tViewModel: TodosVM,\n\tview: stache(\n\t\t\"<ul>\"+\n\t\t\t\"{{#if todos.isPending}}<li>Loading...</li>{{/if}}\"+\n\t\t\t\"{{#if todos.isResolved}}\"+\n\t\t\t\t\"{{#each todos.value}}\"+\n\t\t\t\t\t\"<li ($click)='toggleComplete(.)'\"+\n\t\t\t\t\t     \"class='{{#complete}}complete{{/complete}}'>{{name}}</li>\"+\n\t\t\t\t\"{{else}}\"+\n\t\t\t\t\t\"<li>No todos</li>\"+\n\t\t\t\t\"{{/each}}\"+\n\t\t\t\"{{/if}}\"+\n\t\t\"</ul>\");\n});\n```\n\n## can-stache-bindings\n\n[can-stache-bindings] provides [can-view-callbacks.attr custom attributes] for\n[can-stache] event and data bindings.\n\nBindings look like:\n\n - `(event)=\"key()\"` for event binding.\n - `{prop}=\"key\"` for one-way binding to a child.\n - `{^prop}=\"key\"` for one-way binding to a parent.\n - `{(prop)}=\"key\"` for two-way binding.\n\nAdding `$` to a binding like `($event)=\"key()\"` changes the binding from the viewModel to the element's attributes or properties.\n\n[can-stache-bindings.event Event] binding examples:\n\n```html\n<!-- calls `toggleComplete` when the li is clicked -->\n<li ($click)=\"toggleComplete(.)\"/>\n\n<!-- calls `resetData` when cancel is dispatched on `my-modal`'s view model -->\n<my-modal (cancel)=\"resetData()\"/>\n```\n\n[can-stache-bindings.toChild One-way to child] examples:\n\n```html\n<!-- updates input's `checked` property with the value of complete -->\n<input type=\"checkbox\" {$checked}=\"complete\"/>\n\n<!-- updates `todo-lists`'s  `todos` property with the result of `getTodos`-->\n<todos-list {todos}=\"getTodos(complete=true)\"/>\n```\n\n[can-stache-bindings.toChild One-way to parent] examples:\n\n```html\n<!-- updates `complete` with input's `checked` property -->\n<input type=\"checkbox\" {^$checked}=\"complete\"/>\n\n<!-- updates `todosList` with `todo-lists`'s `todos` property -->\n<todos-list {^todos}=\"todosList\"/>\n```\n\n[can-stache-bindings.twoWay Two-way] examples:\n\n```html\n<!-- Updates the input's `value` with `name` and vice versa -->\n<input type=\"text\" {($value)}=\"name\"/>\n\n<!-- Updates `date-picker`'s `date` with `dueDate` and vice versa -->\n<date-picker {(date)}=\"dueDate\"/>\n```\n\n## can-route and can-route-pushstate\n\n[can-route] connects a `DefineMap`'s properties to values in the\nurl. Create a map type, connect it to the url, and begin routing like:\n\n```js\nvar route = require(\"can-route\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar AppViewModel = DefineMap.extend({\n\tseal: false\n},{\n\t// Sets the default type to string\n\t\"*\": \"string\",\n\ttodoId: \"string\",\n\ttodo: {\n\t\tget: function(){\n\t\t\tif(this.todoId) {\n\t\t\t\treturn Todo.get({_id: this.todoId})\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar appViewModel = new AppViewModel();\nroute.map(appViewModel);\n\nroute.ready();\n```\n\nWhen the url changes, to something like `#!&todoId=5`, so will the\n`appViewModel`'s `todoId` and `todo` property:\n\n```js\nappViewModel.todoId //-> \"5\"\nappViewModel.todo   //-> Promise<Todo>\n```\n\nSimilarly, if `appViewModel`'s `todoId` is set like:\n\n```js\nappViewModel.todoId = 6;\n```\n\nThe hash will be updated:\n\n```js\nwindow.location.hash //-> \"#!&todoId=6\"\n```\n\nThe `route` function can be used to specify pretty routing rules that\ntranslate property changes to a url and a url to property changes. For example,\n\n```js\n// a route like:\nroute(\"todo/:todoId\");\n\n// and a hash like:\nwindow.location.hash = \"#!todo/7\";\n\n// produces an appViewModel like:\nappViewModel.serialize() //-> {route: \"todo/:todoId\", todoId: \"7\"}\n```\n\n[can-route-pushstate] adds [pushstate](https://developer.mozilla.org/en-US/docs/Web/API/History_API) support. It\nmixes in this behavior so you just need to import the module:\n\n```js\nvar route = require(\"can-route\");\nrequire(\"can-route-pushstate\");\n```\n\n",
    "description": "The best, most hardened and generally useful libraries in CanJS.   \n",
    "name": "can-core",
    "title": "Core",
    "type": "page",
    "parent": "canjs",
    "comment": " "
  },
  "can-ecosystem": {
    "src": {
      "path": "docs/can-canjs/can-ecosystem.md"
    },
    "body": "\n",
    "description": "Useful libraries that extend or add important features to the core collection. \n",
    "name": "can-ecosystem",
    "title": "Ecosystem",
    "type": "page",
    "parent": "canjs",
    "comment": " "
  },
  "canjs": {
    "src": {
      "path": "docs/can-canjs/canjs.md"
    },
    "body": "\n### [can-core Core Collection]\n\n_The best, most hardened and generally useful libraries in CanJS._\n\n- Constructors - [can-construct]\n- Observables - [can-define] and [can-compute]\n- Data connection and service modeling- [can-connect] and [can-set]\n- Routing - [can-route] and [can-route-pushstate]\n- Live binding templates - [can-stache]\n- Custom elements and view bindings - [can-component] and [can-stache-bindings]\n\n### Ecosystem Collection\n\n_Useful libraries that extend or add important features to the core collection._\n\n- Simulate ajax requests - [can-fixture]\n- A virtual DOM that is able to run CanJS's templates - [can-simple-dom] and [can-vdom]\n- Track async activity - [can-zone]\n\n\n### Infrastructure Collection\n\n_Utility libraries that power the core collection._\n\n- DOM and JS utilities - [can-util]\n- Events - [can-event]\n- Observable notification - [can-observe-info]\n- Simple Observable - [can-simple-map]\n- View helpers\n  - Register custom elements or attributes in templates - [can-view-callbacks]\n  - Read a view model from a custom element - [can-view-model]\n  - Lookup scope within a stache template - [can-view-scope]\n  - Parses HTML and magic tags - [can-view-parser]\n  - A fast-path compile target - [can-view-target]\n  - Keeps part of the DOM up to date with a compute - [can-view-live]\n  - Maintains live binding relationships - [can-view-nodelist]\n\n### Legacy Collection\n\n_Former libraries that are not under active development, but we\nstill accept patches._\n\n- [can-control]\n- [can-map] and [can-list]\n- Adds the ability to define getter and setters on `can.Map` and `can.List` - [can-map-define]\n- Adds live-sorting ability to `can-list` - [can-list-sort]\n- [can-map-backup]\n- [can-map-attributes]\n- [can-view-href]\n- [can-map-setter]\n- [can-ejs]\n- [can-mustache]\n\n### Support / Contributing\n\nBefore you make an issue, please read our [Contributing] guide.\n\nYou can find the core team in [gitter chat](https://gitter.im/canjs/canjs).\n\n",
    "description": "A constantly evolving and improving set of client side JavaScript architectural libraries. \n",
    "name": "canjs",
    "title": "CanJS",
    "type": "page",
    "dest": "../index",
    "comment": " "
  },
  "can-legacy": {
    "src": {
      "path": "docs/can-canjs/can-legacy.md"
    },
    "body": "\n",
    "description": "Former libraries that we still accept patches for, but are not under active development.\n\n",
    "name": "can-legacy",
    "title": "Legacy",
    "type": "page",
    "parent": "canjs",
    "comment": " "
  },
  "can-infrastructure": {
    "src": {
      "path": "docs/can-canjs/can-infrastructure.md"
    },
    "body": "\n",
    "description": "Utility libraries that power the core collection. \n",
    "name": "can-infrastructure",
    "title": "Infrastructure",
    "type": "page",
    "parent": "canjs",
    "comment": " "
  },
  "guides": {
    "src": {
      "path": "docs/can-guides/Guides.md"
    },
    "body": "This page contains recipes and tutorials that will get you started with building CanJS projects. Choose a section on the left to learn more about the components that make CanJS work and to see CanJS being used in real projects. If you're new to CanJS, a good starting point is [Why Why CanJS?]\n\n",
    "description": "",
    "name": "guides",
    "title": "Guides",
    "type": "page",
    "parent": "canjs",
    "comment": " "
  },
  "roadmap": {
    "src": {
      "path": "docs/can-guides/Roadmap.md"
    },
    "body": "\nNow that 2.0 is out, we’re setting our sights on the\nfuture.  Help us get there by ranking issues and features\non bithub and fixing them!\n\n## Community\n\nThere’s more than code that goes into a library.  Checkout\nhow we’re working to improve CanJS's community:\n\n### Bithub.com\n\nWe are developing [bithub.com](http://bithub.com/canjs) to track\nall community content. Earn points that you \ncan trade for swag by posting apps, articles, events\nand plugins. __Rank bugs and features to let us and the \nrest of the community know where to focus.__\n\n### Meetups\n\nWe’ve started meetups across the US.  Bitovi provides\nmonthly training and workshop material.  Checkout\nmeetup for meetups and [bithub.com](http://bithub.com/canjs/events)\nfor other events.\n\n## DOM mutation observers\n\nWith CanJS 2.0, you can listen to \"inserted\" and \"removed\" events in\nevery browser.  We want to make it possible to listen to other DOM\nmutation events, making it easier to create custom elements\nthat feel completely native.\n\n## LazyMap and LazyList\n\nWe want our observable layer to handle anything you throw at \nit.  We’ve started work on a LazyMap and LazyList that\nexperiences almost no initialization penalty.  As you\nread nested objects, it converts them into LazyMaps and LazyLists.\n\nFurthermore, we want to setup bubbling only when it’s necessary and not\nby default. This will reduce the number of events, improving performance.\n\n## Component improvements\n\ncan.Component is designed to resemble web components.  As that \nspecification takes shape, we will make sure can.Component\nmakes use of it.  Future improvements:\n\n - A select attribute on `<content>`.\n - In-page custom elements.\n - Iterable `<content>` for lists.\n\n## Super Model\n\nWe want to create list-store that makes complex real-time apps\neasy to build. It will include a fall-through localStorage cache that\ndecreases page load times.\n\n## Dirty checking computes\n\nWant to use plain old objects in can.Component?  We’re looking to\ncreate a compute that checks its value periodically.  Hopefully\nthis becomes unnecessary as object mutation observers and \nproxies arrive in more browsers.\n\n## Deferreds and Computes\n\nEver had a compute that represents a deferred that represents an\nobservable list?  We have.  We want to make it easy to nest\ncomputes and deferreds like you can with Lists and Maps.\n",
    "description": "\n",
    "name": "roadmap",
    "title": "Roadmap",
    "type": "page",
    "parent": "guides",
    "order": 8,
    "comment": " "
  },
  "migrating": {
    "src": {
      "path": "docs/can-guides/migrating_to_3.0.md"
    },
    "body": "\nCanJS 3.0 introduces many new features and deprecates or removes much of the API\n\n## Breaking Changes\n\nThese changes require code modifications to use 2.0.\n\n### can.EJS and can.Mustache are no longer in core\n\ncan.EJS and can.Mustache are no longer packaged in the core download by default. They have\nbeen replaced by can.stache.\n\n",
    "description": "\n",
    "name": "migrating",
    "title": "Migrating to 3.0",
    "type": "page",
    "parent": "guides",
    "order": 7,
    "comment": " "
  },
  "Observables": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/observables.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - `can.Map`, and \n - `can.List`\n- - -\n\nObservables are the subjects in the\n[observer pattern](http://en.wikipedia.org/wiki/Observer_pattern). \nThey let you create relationships between objects\nwhere one object (or objects) listens for and responds to changes in another object. \nMost of the core objects in CanJS are observables. Understanding how to effectively\nwork with observables lies at the heart of understanding how to build successful \nCanJS applications.\n\nIn this section, we’ll review the two observables that make up the core of most CanJS objects:\n\n - [`can.Map`](../docs/can.Map.html) - Used for Objects.\n - [`can.List`](../docs/can.List.html) - Used for Arrays.\n\n`can.Map` and `can.List` are often extended to create observable types. For example,\n[can.Model](../docs/can.Model.html) and [can.route](../docs/can.route.html) are\nbased on `can.Map`, and a `can.Component`’s [`viewModel`](../docs/can.Component.prototype.viewModel.html)\nis a `can.Map`.\n\n## Creating Instances\n\nTo create a Map, call `new can.Map(object)`. This will give you a map\nwith the same properties and values as the _object_ you passed in to the `can.Map` constructor. \n\nTo create a List, call `new can.List(array)`. This will give you a List with the same elements as the\n_array_ you passed into the `can.List` constructor.\n\n```\nvar pagination = new can.Map({page: 1, perPage: 25, count: 1388});\npagination.attr('perPage'); // 25\n\nvar hobbies = new can.List(['programming', 'bball', 'party rocking']);\nhobbies.attr(2); // 'party rocking'\n```\n\n## Manipulating properties\n\nThe [`attr`](../docs/can.Map.prototype.attr.html) method is\nused to read a property from, or write a property to a `can.Map` or `can.List`.\nWhile you can read the properties of a `can.Map` or `can.List` directly off \nof the object, to take advantage of the observable functionality you must\nuse the `.attr` syntax.\n\n```\nvar pagination = new can.Map({page: 1, perPage: 25, count: 1388});\n\npagination.attr('perPage');     // 25\npagination.attr('perPage', 50);\npagination.attr('perPage');     // 50\n\npagination.attr({page: 10, lastVisited: 1});\npagination.attr(); // {page: 10, perPage: 50, count: 1388, lastVisited: 1}\n```\n\nProperties can be removed by using [`removeAttr`](../docs/can.Map.prototype.removeAttr.html),\nwhich is equivalent to the `delete` keyword:\n\n```\npagination.removeAttr('count');\npagination.attr(); // {page: 10, perPage: 50, lastVisited: 1}\n```\n\n## Extending a Map\n\nExtending a `can.Map` (or `can.List`) lets you create custom observable\ntypes. The following extends `can.Map` to create a Paginate type that\nhas a `.next()` method:\n\n```\nPaginate = can.Map.extend({\n  define: {\n    limit: {\n      value: 100\n    },\n    offset: {\n      value: 100\n    },\n    count: {\n      value: Infinity\n    }\n  },\n  next: function() {\n\tthis.attr('offset', this.attr('offset') + this.attr('limit') );\n  }\n});\n\nvar pageInfo = new Paginate();\npageInfo.attr(\"offset\") //-> 100\n\npageInfo.next();\n\npageInfo.attr(\"offset\") //-> 200\n```\n\n## Responding to changes\n\nWhen a property on a Map is changed with `attr`, it will emit an event with the\nname of the changed property.  You can [bind](../docs/can.Map.prototype.bind.html)\nto those events and perform some action:\n\n```\npagination.bind('page', function(event, newVal, oldVal) {\n\tnewVal; // 11\n\toldVal; // 10\n\t\n\t$(\"#page\").text(\"Page: \"+newVal);\n});\n\npagination.attr('page', 11);\n```\n\nAlthough `bind` and its corresponding `unbind` method exist, __there's almost no\nreason to ever use them!__  This is because there are better ways to perform\nthe common actions that would require binding to an observable.\n\nFor example, `stache` templates will automatically update when an observable changes:\n\n```\nvar template = can.stache(\"<span id='page'>{{page}}</span>\");\n$(\"body\").append(template(pagination));\n\ndocument.getElementById(\"page\").innerHTML //-> \"11\"\n\npagination.attr('page', 12);\n\ndocument.getElementById(\"page\").innerHTML //-> \"12\"\n```\n\nThe other common use case is to create some new, derived value.  [can.compute](../docs/can.compute.html)\nor [define getters](../docs/can.Map.prototype.define.get.html) lets you use functional\n(and reactive) programming techniques to derive new values from source \nstate. \n\nFor example, we can create a virtual `page` observable that derives its value from the \n`offset` and `limit`:\n\n```\nvar pagination = new Paginate({\n  limit: 10,\n  offset: 20\n});\n\nvar page = can.compute(function(){\n  return Math.floor(pagination.attr('offset') / \n                    pagination.attr('limit')) + 1;\n});\n\npage() //-> 3\n\npage.bind(\"change\", function(ev, newValue){\n  newValue //-> 4\n});\n\npagination.attr(\"offset\",30);\n```\n\nIn this example `page` will automatically be updated when either `offset` or `limit` change.\n\n\nHowever, `page` is more commonly created as a \"virtual\" property of the `Paginate` Map type\nusing a [define getter](../docs/can.Map.prototype.define.get.html):\n\n```\nPaginate = can.Map.extend({\n  define: {\n    ...\n    page: {\n      get: function() {\n\t    return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n      }\n    }\n  },\n  ...\n});\n\nvar pageInfo = new Paginate({\n  limit: 10,\n  offset: 20,\n  count: 30\n});\npageInfo.attr(\"page\") //-> 3\n\npageInfo.bind(\"page\", function(ev, newVal){\n  newVal //-> 4\n});\n\npageInfo.next();\n```\n\nUsing computes and define getters are very similar to using functional-reactive programming\nevent streams.  Given some source state, they are able to derive and combine it into new values.\n\nComputes and define getters are easier, but less powerful than event streams.  Computes\nand define getters only respond to changes in values where event streams \nare also able to respond to events. However, computes and define getters \nare eaiser to express and automatically manage subscriptions to source values.\n\nFor example, consider deriving a total for one of two menus depending on the time\nof day:\n\n```\nvar lunch = new can.List([\n  {name: \"nachos\", price: 10.25},\n  {name: \"water\", price: 0},\n  {name: \"taco\", price: 3.25}\n]);\n\nvar dinner = new can.List([\n  {name: \"burrito\", price: 12.25},\n  {name: \"agua\", price: 1.20}\n]);\n\nvar timeOfDay = can.compute(\"lunch\");\n\nvar total = can.compute(function(){\n  var list = timeOfDay() === \"lunch\" ? lunch : dinner;\n  var sum = 0;\n  list.forEach(function(item){\n    sum += item.attr(\"price\");\n  });\n  return sum;\n});\n```\n\nIn this example, `total` will listen to not only `timeOfDay`, but\nalso when items are added or removed to `lunch` or `dinner`, and each item's\n`price`.  Furthermore, it only listens to just what needs to be listened to. It will\nlisten to either `lunch` or `dinner`, but not both.\n\nIn the [next chapter](TheDefinePlugin.html) we'll expand on the use of the define plugin\nand show how it can handle asyncronous derived data like AJAX requests.\n\n## Iterating though a Map\n\nIf you want to iterate through the properties on a Map, use `each`:\n\n```\nvar pagination = new can.Map({page: 10, perPage: 25, count: 1388});\n\npagination.each(function(val, key) {\n\tconsole.log(key + ': ' + val);\n});\n\n// The console shows:\n// page: 10\n// perPage: 25\n// count: 1388\n```\n\n\n\n## Observable Arrays\n\nCanJS also provides observable arrays with `can.List`.\n`can.List` inherits from `can.Map`. A `can.List` works much the same way a\n`can.Map` does, with the addition of methods useful for working with\narrays:\n\n- [`indexOf`](../docs/can.List.prototype.indexOf.html), which looks for an item in a\nList.\n- [`pop`](../docs/can.List.prototype.pop.html), which removes the last item from a\nList.\n- [`push`](../docs/can.List.prototype.push.html), which adds an item to the end of a\nList.\n- [`shift`](../docs/can.List.prototype.shift.html), which removes the first item from\na List.\n- [`unshift`](../docs/can.List.prototype.unshift.html), which adds an item to the front\nof a List.\n- [`splice`](../docs/can.List.prototype.splice.html), which removes and inserts items\nanywhere in a List.\n\nWhen these methods are used to modify a List events are\nemitted that you can listen for, as well. See [the API for Lists](../docs/can.List.html) for more\ninformation.\n\n\n\n<span class=\"pull-left\">[&lsaquo; Application Foundations](ApplicationFoundations.html)</span>\n<span class=\"pull-right\">[The Define Plugin &rsaquo;](TheDefinePlugin.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "Observables",
    "title": "Observables",
    "type": "page",
    "parent": "Tutorial",
    "order": 3,
    "comment": " ",
    "disabletableofcontents": true
  },
  "Plugins": {
    "src": {
      "path": "docs/can-guides/plugins.md"
    },
    "body": "\nIn this guide you'll learn how to build a plugin for CanJS. As is standard with programming tutorials,\nwe’ll build something that says \"Hello World\".\n\n## Setup\n\nWe'll be using [Yeoman](http://yeoman.io) and a generator built to scaffold CanJS plugins. If you don't want to use Yeoman, you will have to create the files mentioned in this guide yourself. The [canjs-hello-world](https://github.com/ccummings/canjs-hello-world) repository is where you can grok all of the files the Yeoman generator creates.\n\n### 1) Install Yeoman\n\nThe first thing you need to do is install Yeoman and [`generator-canjs-plugin`](https://github.com/ccummings/generator-canjs-plugin) which will allow you to quickly scaffold a CanJS plugin.\n\nInstall both by running the following on the command line:\n\n\tnpm install -g yo generator-canjs-plugin\n\n_For help installing or using Yeoman, there is the [Yeoman getting started guide](http://yeoman.io/gettingstarted.html)_\n\n### 2) Run the generator\n\nNext create a directory for your plugin and `cd` into it:\n\n\tmkdir canjs-hello-world && cd canjs-hello-world\n\nThen run the generator:\n\n\tyo canjs-plugin\n\nAfter answering a series of questions about your plugin the generator will create the files and install all of the dependencies you need to develop, test and publish your CanJS plugin.\n\n## Develop\n\nNow that you have a scaffold in place, you'll start building your plugin.\n\n### Modify the Source\n\nA single source file will be placed in the `src` directory. This is where you will add your plugin code. Here's what your plugin should look like:\n\n\tcan.hello = function() {\n\t\treturn 'Hello World';\n\t};\n\n__Notice that the file includes bootstrapping that allows it to work with AMD loaders, Steal or stand alone with no dependency management tool.__\n\n### Write tests\n\nA [QUnit](https://qunitjs.com/) test file and runner are placed in the `test` folder. The `*_tests.js` file is where you will write tests for your plugin. Modify the `Hello World` test so it looks like this:\n\n\ttest('Hello World', function() {\n\t\tequal(can.hello(), 'Hello World', 'Works!');\n\t});\n\nYou can run these tests by opening `test/qunit.html` in a browser or by running `grunt test` on the command line. Do this now and make sure the test passes.\n\n### Create examples\n\nExamples for AMD, Steal and stand alone are placed in the `example` folder. Modify the `index.html` file in each folder to show people how to use your plugin.\n\nIn each of the 3 `index.html` files replace the line `//Demo JS goes here` with:\n\n\tconsole.log(can.hello());\n\nOpen these files in a browser and look at the console to see \"Hello World\" being logged.\n\n### Create Documentation\n\nIt's highly recommended that you create documentation for your plugin. You can use your plugin repo's wiki or generate a website for it using [GitHub pages](https://pages.github.com/).\n\n## Grunt work flow\n\nNow that you have developed a plugin, tests and examples, it’s time to build the plugin using Grunt. The following commands are available:\n\nRun jsbeautifier and JSHint:\n\n\tgrunt quality\n\nRun tests:\n\n\tgrunt test\n\nRun tests and places distributable files in the `dist` folder:\n\n\tgrunt build\n\n## Distribute your plugin with Bower\n\nThe easiest way to distribute your plugin is via [Bower](http://bower.io) In order to create a bower package you'll need:\n\n- A valid manifest file ([bower.json](http://bower.io/#defining-a-package)) in the root of the project\n- All code available at a Git endpoint (hosted at GitHub or BitBucket for example)\n- To register your plugin with Bower\n\n### The manifest\n\nA valid `bower.json` file is created by the generator. If you are coding your plugin from scratch run `bower init` and answer the series of prompts to generate your own.\n\n__Be sure to include relevant keywords in your manifest. For CanJS plugins use `can` and any other keywords that are relevant. For can.Components add a keyword of `can-components`.__\n\n### Git endpoint\n\nEach version of your plugin must have a [semantic version number](http://semver.org/) and a corresponding Git tag with the same version. You create a Git tag like this:\n\n\t$ git tag -a vX.Y.Z -m 'vX.Y.Z'\n\n### Register with Bower\n\nNow that you have a valid manifest a Git endpoint and Git tag you are ready to register your plugin. To do this use the `bower register` command:\n\n\t$ bower register [plugin-name] [git-endpoint]\n\n__[git-endpoint] is the URL to your repository, typically starting with `git://`.__\n\nYour plugin is now available via the [bower registry](http://bower.io/search)!\n\n## Wrapping up\n\nThat's all there is to it. In this guide you developed a CanJS plugin complete with tests and examples and learned how to distribute it via bower.\n\nIf you've created a CanJS plugin we'd love to hear about it over on [BitHub](http://bithub.com) [IRC](http://webchat.freenode.net/?channels=canjs) or our [forums](http://forums.donejs.com/c/canjs).\n",
    "description": "\n",
    "name": "Plugins",
    "title": "Developing Plugins",
    "type": "page",
    "parent": "contributing",
    "order": 0,
    "comment": " "
  },
  "Routing": {
    "src": {
      "path": "docs/can-guides/route.md"
    },
    "body": "\nHere is how you might use `can.route` without a template:\n\n```\n// Before we start, empty the hash.\nwindow.location.hash = '';\n\n// This means that can.route is empty.\ncan.route.attr(); // {}\n\n// Set the hash...\nwindow.location.hash = '#!id=7';\n// ...and can.route reflects that.\ncan.route.attr(); // {id: 7}\n\n// Set the route...\ncan.route.attr({type: 'todos'}, true);\n// ...and the hash reflects that.\nwindow.location.hash; // #!type=todos\n\n// Set a new property on the route...\ncan.route.attr('id', 6);\n// ...and the has changes again to reflect multiple properties.\nwindow.location.hash; // #!type=todos&id=6\n```\n\nIf you give `can.route` a template, you can make pretty URLs:\n\n```\n// Give can.route a template.\ncan.route(':type/:id');\n\n// If you set a hash that looks like the route...\nwindow.location.hash = '#!todos/5';\n// ... the route data changes accordingly.\ncan.route.attr(); // {type: 'todos', id: 5}\n\n// If the route data is changed...\ncan.route.attr({type: 'users', id: 29});\n// ...the hash is changed using the template.\nwindow.location.hash; // '#!users/7'\n\n// You can also supply defaults for routes.\ncan.route('', {type: 'recipe'});\n\n// Then if you change the hash...\nwindow.location.hash = '';\n// ...the route data reflects the defaults.\ncan.route.attr(); // {type: 'recipe'}\n```\n\n## Listening to events\n\nBecause `can.route` is an Observe, you can bind to it just like normal Observes:\n\n```\ncan.route.bind('id', function(ev, newVal, oldVal) {\n\tconsole.log('The hash\\'s id changed.');\n});\n```\n\nYou can listen to routing events in Controls with the _route_ event:\n\n```\nvar Routing = can.Control({\n\t'route': function() {\n\t\t// Matches every routing change, but gets passed no data.\n\t},\n\t'todos/:id route': function(data) {\n\t\t// Matches routes like #!todos/5,\n\t\t// and will get passed {id: 5} as data.\n\t},\n\t':type/:id route': function(data) {\n\t\t// Matches routes like #!recipes/5,\n\t\t// and will get passed {id: 5, type: 'recipes'} as data.\n\t}\n})\n```\n\n## Making URLs and links\n\n`can.route.url` takes a set of properties and makes a URL according to\n`can.route`'s current route.\n\n```\ncan.route(':type/:id', {type: 'todos'});\ncan.route.url({id: 7}); // #!todos/7\n```\n\n`can.route.link` does the same thing as `can.route.url`, but it returns an\nanchor element (in string form) ready to be inserted into HTML. You can also\nspecify extra propertires to be set on the element.\n\n```\nvar a = can.route.link(\n\t'Todo 5',\n\t{id: 7},\n\t{className: 'button'}\n);\n\na; // <a href=\"#!todos/7\" class=\"button\">Todo 5</a>\n```\n\n",
    "description": "\n[can.route](../docs/can.route.html) is the core of CanJS's routing functionality. It is a special\nObserve that updates `window.location.hash` when its properties change and\nupdates its properties when `window.location.hash` changes. You can give\n`can.route` a template to translate URLs into property values, but if no route\nis provided, it just serializes the route into standard URL-encoded notation.\n",
    "name": "Routing",
    "title": "Routing",
    "type": "page",
    "parent": "Tutorial",
    "order": 9
  },
  "Setup": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/setup.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - Recommended folder structure\n - Configuring and Downloading CanJS\n - Application Bootstrap\n\n<a name=\"chapter-code\"></a>\nGet the code for: [chapter: setup](/guides/examples/PlaceMyOrder/ch-0_canjs-getting-started.zip)\n\n- - -\n\nTo begin, we’ll use an example project that has all of the dependencies required\nfor the sample app that we’re going to build. The example project also has some\nCSS and images to make our example app a little bit more stylish. Download the example\nproject, by getting the <a href=\"#chapter-code\">code for this chapter</a> (see above).\n\n## Folder Structure\n\nThe example project has the following folder structure:\n\n<pre>\n└── /\n\t├── app.js\n\t├── components\n\t├── css\n\t├── images\n\t├── index.html\n\t├── libs\n\t└── models\n</pre>\n\nLet’s walk through each folder, and discuss it.\n\nThe `app.js` file is used to bootstrap our application. We’ll go over this\nin more detail <a href=\"#application-bootstrap\">below</a>.\n\nThe `components` folder is where we’ll put all of the parts that make\nup our application. A component-based structure makes it easier to both manage\nand port our application's components (should you, for example, want to use\na component in another application).\n\nThe `css` folder contains a `style.css` file that is used for the entire app.\nWe would typically recommend putting any CSS files in their respective component\nfolders, however we’ve only included one CSS file in this application for simplicity.\n\nThe `images` folder contains images that are used throughout the app.\nAgain, if you had images that were specific to a component, we would\nrecommend putting them in their respective component folder.\n\nThe `index.html` file is the HTML file that loads all of the app’s scripts and\nstyles.\n\nThe `libs` folder contains all of the app’s JavaScript dependencies.\n\nThe `models` folder contains some JSON files that we will use as fake server\nresponses and some JavaScript files that we’ll fill out later to mock an\nHTTP server.\n\n## Dependencies\n\nOur application will have the following dependencies:\n\n- CanJS\n- jQuery\n- can.fixture\n\n### CanJS\n\nThe easiest way to get CanJS is to use <a href=\"../download.html\" target=\"_blank\">the custom download page</a>,\nwhich allows you to download the specific parts of CanJS you need for your application.\n\nThe custom download page loads with all the elements in the core CanJS library\nalready selected. We want all of those in our build, so leave them checked.\nCanJS relies on an external core library for some of its functionality. The default option is\njQuery. That's what we’ll be working with here.\n\nThe right side of the page lists all of the plugins. From the list of plugins,\nselect the following:\n\n![CanJS plugins to select](../can/guides/images/setup/DownloadOptions.png)\n\nAt the bottom of the page, clicking the download button will prompt you to\ndownload a file called `can.custom.js`, which you can save to your local machine.\n\n### can.fixture\n\nThe [`can.fixture`](../docs/can.fixture.html) dependency is special because, normally,\nyou don't want it to be a part of your final application; however, it can be very\nhelpful during development. `can.fixture.js` allows you to simulate RESTful services.\nYou can <a href=\"http://canjs.com/release/2.3.0/can.fixture.js\" target=\"_blank\">download it here</a>.\n\n### jQuery\n\n<a href=\"http://jquery.com/download/\" target=\"_blank\">jQuery 2.x</a> is also\nrequired. We downloaded the most recent version of jQuery and put the `jquery.js`\nfile in the `libs` folder.\n\n## index.html <a name=\"index-file\"></a>\n\nOur `index.html` file currently looks like this:\n\n```html\n<!DOCTYPE html>\n<html>\n  <head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title>Place My Order</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\"/>\n  </head>\n  <body>\n    <!-- CanJS application root -->\n    <div id=\"can-main\"></div>\n    <script src=\"libs/jquery.js\"></script>\n    <script src=\"libs/can.custom.js\"></script>\n    <script src=\"libs/can.fixture.js\"></script>\n    <script src=\"app.js\"></script>\n  </body>\n</html>\n```\n\nAt the bottom of the page, just before the closing body tag, are all of the script\ntags. We’re using the jQuery edition of CanJS, so the first script tag\nloaded must be jQuery. Following jQuery, we load `can.custom.js`.\n\nEarlier, we mentioned including `can.fixture.js`. In a\nnormal project, once you connected to the actual REST services, you would\nremove `can.fixture.js`. In addition, to simplify things, we’ve provided a complete CSS\nfile for you.\n\n## Application Bootstrap <a name=\"application-bootstrap\"></a>\nThe `app.js` file is the script that will bootstrap our application. Edit the\nfile as follows:\n\n```\n$(function () {\n  $('#can-main').html('The Requisite \"Hello World\" Message');\n});\n```\n\nIf you open up your application in a browser, you should see:\n\n> The Requisite \"Hello World\" Message\n\nAt this point, we haven't done much. We aren't using CanJS at all yet.\nWe’re just using jQuery to set the HTML contents of a DOM element.\n\nSo, how do we get the application to actually *do something*? Building apps\nwith CanJS centers around building `can.Component`'s. Read on to the next\nchapter to learn more.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Getting Started](Tutorial.html)</span>\n<span class=\"pull-right\">[Application Design &rsaquo;](ApplicationDesign.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "Setup",
    "title": "Setup",
    "type": "page",
    "parent": "Tutorial",
    "order": 1,
    "disabletableofcontents": true,
    "comment": " "
  },
  "Why": {
    "src": {
      "path": "docs/can-guides/why.md"
    },
    "body": "\nCanJS is designed to be a very well-rounded JavaScript framework, useful to almost any client-side JavaScript\nteam.\n\nIt provides a wealth of JavaScript utilities that combine to make testable and repeatable Model-View-ViewModel\napplications with very little code.  \n\nCanJS provides the default MV\\* libraries to the [DoneJS](http://donejs.com) framework.  Checkout DoneJS's [quick\nstart guide](http://donejs.com/Guide.html) for an example of using CanJS to build a server-side rendered, real-time\nchat app that works as an Android, iOS, and Desktop app.\n\n<h2 id=\"Flexible\">Flexible</h2>\n\nCanJS is __flexible__. Unlike other frameworks, it's designed to work in almost any situation.\nYou can readily use third party plugins or\nmodify the DOM with jQuery directly.\nCanJS supports all browsers.\n\n<h2 id=\"Powerful\">Powerful</h2>\n\nCanJS is __powerful__. Create [custom elements](../docs/can.Component.html) with\n[one and two-way bindings](/docs/can.view.bindings.html).\nEasily [define](../docs/can.Map.prototype.define.html) the behavior of\nobservable objects and their derived values. Avoid memory\nleaks with smart model stores and smart event binding.  \n\n<h2 id=\"Fast\">Fast</h2>\n\nCanJS is __fast__. It is only about 20k. Its live-binding updates only what needs to be updated without requiring a\n\"diff\".  \n\n\n<h2 id=\"Friendly\">Friendly</h2>\n\nCanJS is __friendly__.  Our [fulltime](http://donejs.com/About.html#section=section_Fulltimeteam) and\n[core](http://donejs.com/About.html#section=section_Coreteam) team are extremely active on\n[gitter chat](https://gitter.im/canjs/canjs) and on the [forums](http://forums.donejs.com/c/canjs) and\nalways wanting to help.\n\n",
    "description": "\n",
    "name": "Why",
    "title": "Why CanJS?",
    "type": "page",
    "parent": "guides",
    "order": 1,
    "comment": " "
  },
  "can-component.static": {
    "name": "can-component.static",
    "title": "static",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 0
  },
  "can-component.prototype": {
    "name": "can-component.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 0
  },
  "can-component.prototype.events": {
    "src": {
      "path": "node_modules/can-component/docs/events.md"
    },
    "body": "\n\n## Use\n\n[can-component]'s events object allows you to provide low-level [can-control]-like abilities to a `Component`\nwhile still accessing `Component`'s objects and methods like [can-component::viewModel viewModel].  The following\nexample listens to clicks on elements with `className=\"next\"` and calls `.next()` on the component's viewModel.\n\n<div class='demo_wrapper' data-demo-src='can/component/examples/paginate_events_next.html'></div>\n\nThe events object can also listen to objects or properties on the component's [can-component::viewModel viewModel]. For instance, instead\nof using live-binding, we could listen to when offset changes and update the page manually:\n\n<div class='demo_wrapper' data-demo-src='can/component/examples/paginate_events_next_update_page.html'></div>\n\nComponents have the ability to bind to special inserted and removed events that are called when a component's tag has been inserted into or removed from the page:\n\n      events: {\n        \"inserted\": function(){\n          // called when the component's tag is inserted into the DOM \n        },\n        \"removed\": function(){\n          // called when the component's tag is removed from the DOM \n        }\n      }\n\n## High performance template rendering\n\nWhile [can-stache-bindings] conveniently allows you to call a [can-component::viewModel viewModel] method from a template like:\n\n    <input ($change)=\"doSomething\"/>\n    \nThis has the effect of binding an event handler directly to this element. Every element that has a `can-click` or similar attribute has an event handler bound to it. For a large grid or list, this could have a performance penalty.\n\nBy contrast, events bound using [can-component]'s events object use event delegation, which is useful for high performance template rendering. In a large grid or list, event delegation only binds a single event handler rather than one per row.\n\n",
    "description": "\nListen to events on elements and observables.\n",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "An object of event names and methods \nthat handle the event. For example:\n\n    Component({\n      events: {\n        \".next click\": function(){\n          this.viewModel.next()\n        }\n      },\n      viewModel: {\n        next: function(){\n          this.attr(\"offset\", this.offset + this.limit);\n        }\n      }\n    })\n\n\nA component's events object is used as the prototype of a [can-control]. The control gets created on the component's\nelement. The component's viewModel is available within event handlers as `this.viewModel`.\n\n",
        "template": [
          {
            "types": [
              {
                "type": "can-control.eventDescription"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-control.eventHandler"
              }
            ]
          }
        ]
      }
    ],
    "title": "events",
    "name": "can-component.prototype.events",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.helpers": {
    "src": {
      "path": "node_modules/can-component/docs/helpers.md"
    },
    "body": "\n\n## Use\n\n[can-component]'s helper object lets you provide helper functions that are localized to\nthe component's [can-component::template template].  The following example\nuses an `isSelected` helper to render content for selected items. Click\none of the following libraries to toggle them within the `selected` array. \n\n<div class='demo_wrapper' data-demo-src='can/component/examples/selected.html'></div>\n\n",
    "description": "\nHelper functions used with the component's template.\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-stache.helper"
              }
            ]
          }
        ],
        "description": "\n\nAn object of [can-stache] helper names and methods. The helpers are only\navailable within the component's template and source html. Helpers\nare always called back with `this` as the [can-component::viewModel viewModel].\n"
      }
    ],
    "title": "helpers",
    "name": "can-component.prototype.helpers",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.leakScope": {
    "src": {
      "path": "node_modules/can-component/docs/leakscope.md"
    },
    "body": "\n## Use\n\nA component's [can-component::leakScope leakScope] option controls if a \ncomponent's template can access the component's outer scope and the \nuser content can read the component's view model.\n\nLets define what __outer scope__, __component's template__ and __user content__ mean.\n\nIf I have a `<hello-world>` component in a template like:\n\n```\n{{#data}}\n\t<hello-world>{{subject}}</hello-world>\n{{/data}}\n```\n\nThe __outer scope__ of `<hello-world>` has `data` as its context.  The __user content__ of\n`<hello-world>` is the template between its tags.  In this case, the __user content__\nis `{{subject}}`.\n\nFinally, if `<hello-world>` is defined like:\n\n```\nComponent.extend({\n  tag: \"hello-world\",\n  template: stache(\"{{greeting}} <content/>{{exclamation}}\")\n})\n```\n\n`{{greeting}} <content/>{{exclamation}}` represents the __component's template__.\n\n## Example\n\nIf the following component is defined:\n\n    Component.extend({\n        tag: \"hello-world\",\n        leakScope: true, // the default value\n        template: stache(\"{{greeting}} <content/>{{exclamation}}\"),\n        viewModel: { subject: \"LEAK\", exclamation: \"!\" }\n    })\n\nAnd used like so:\n\n    <hello-world>{{subject}}</hello-world>\n\nWith the following data in the outer scope:\n\n    { greeting: \"Hello\", subject: \"World\"}\n\nWill render the following if `leakScope` is true:\n\n    <hello-world>Hello LEAK!</hello-world>\n\nBut if `leakScope` is false:\n\n    <hello-world>Hello World</hello-world>\n\nBecause when the scope isn't leaked, the __component's template__ \ndoes not see `exclamation`. The __user content__ does not see the \nviewModel's `subject` and uses the outer scope's `subject` which is `\"World\"`.\n\nUsing the `leakScope: false` option is useful for hiding and protecting\ninternal details of `Component`, potentially preventing accidental\nclashes.\n\n",
    "description": "Allow reading the outer scope values from a component's template and a component's viewModel values in the user content.\n\n",
    "types": [
      {
        "type": "Boolean",
        "description": "`false` limits reading to:\n \n- the component's viewModel from the component's template, and\n- the outer scope values from the user content.\n\n`true` adds the ability to read:\n\n- the outer [can-view-scope scope] values from the component's template, and\n- the component's [can-component.prototype.viewModel viewModel] values from the user content. \n \nThe default value is `true`.  This may reverse in 3.0.\n"
      }
    ],
    "title": "leakScope",
    "name": "can-component.prototype.leakScope",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.extend": {
    "src": {
      "path": "node_modules/can-component/docs/extend.md"
    },
    "body": "\n\n\nNote that inheriting from components works differently than other CanJS APIs. You can't call `.extend` on a particular component to create a \"subclass\" of that component. \n\nInstead, components work more like HTML elements. To reuse functionality from a base component, build on top of it with parent components that wrap other components in their template and pass any needed viewModel properties via attributes.\n\n",
    "description": "\nExtends the [can-component] constructor function.\n",
    "title": "extend",
    "name": "can-component.extend",
    "type": "function",
    "parent": "can-component.static",
    "signatures": [
      {
        "code": "Component.extend(proto)",
        "description": "\n\nExtends the [can-component] constructor function with prototype \nproperties and methods.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": [
                  {
                    "name": "tag",
                    "description": "Defines the\ntag on which instances of the component constructor function will be\ncreated.\n",
                    "types": [
                      {
                        "type": "can-component.prototype.tag"
                      }
                    ]
                  },
                  {
                    "name": "events",
                    "description": "Defines events on\ndom elements or observable objects the component listens to.\n\n",
                    "types": [
                      {
                        "type": "can-component.prototype.events"
                      }
                    ],
                    "optional": true
                  },
                  {
                    "name": "helpers",
                    "description": "Specifies mustache helpers\nused to render the component's template.\n",
                    "types": [
                      {
                        "type": "can-component.prototype.helpers"
                      }
                    ],
                    "optional": true
                  },
                  {
                    "name": "viewModel",
                    "description": "Specifies an object\nthat is is used to render the component's template.\n",
                    "types": [
                      {
                        "type": "can-component.prototype.viewModel"
                      }
                    ],
                    "optional": true
                  },
                  {
                    "name": "template",
                    "description": "Specifies the template\nrendered within the custom element.\n",
                    "types": [
                      {
                        "type": "can-component.prototype.tempate"
                      }
                    ],
                    "optional": true
                  }
                ]
              }
            ],
            "name": "proto",
            "description": "An object set as the prototype of the \nconstructor function. You will typically provide the following values\non the prototype object.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "tag",
              "description": "Defines the\ntag on which instances of the component constructor function will be\ncreated.\n",
              "types": [
                {
                  "type": "can-component.prototype.tag"
                }
              ]
            },
            {
              "name": "events",
              "description": "Defines events on\ndom elements or observable objects the component listens to.\n\n",
              "types": [
                {
                  "type": "can-component.prototype.events"
                }
              ],
              "optional": true
            },
            {
              "name": "helpers",
              "description": "Specifies mustache helpers\nused to render the component's template.\n",
              "types": [
                {
                  "type": "can-component.prototype.helpers"
                }
              ],
              "optional": true
            },
            {
              "name": "viewModel",
              "description": "Specifies an object\nthat is is used to render the component's template.\n",
              "types": [
                {
                  "type": "can-component.prototype.viewModel"
                }
              ],
              "optional": true
            },
            {
              "name": "template",
              "description": "Specifies the template\nrendered within the custom element.\n",
              "types": [
                {
                  "type": "can-component.prototype.tempate"
                }
              ],
              "optional": true
            }
          ]
        }
      ],
      "name": "proto",
      "description": "An object set as the prototype of the \nconstructor function. You will typically provide the following values\non the prototype object.\n"
    },
    "types": [],
    "comment": " "
  },
  "can-component.prototype.scope": {
    "src": {
      "path": "node_modules/can-component/docs/scope.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "scope",
    "name": "can-component.prototype.scope",
    "type": "property",
    "deprecated": [
      {
        "version": "2.2",
        "description": "In 2.2 `scope` has been renamed to [can-component::viewModel] to avoid confusion with [can-view-scope]. `scope` is still available for backwards compatibility.\n\n"
      }
    ]
  },
  "can-component.prototype.tag": {
    "src": {
      "path": "node_modules/can-component/docs/tag.md"
    },
    "body": "\n",
    "description": "\nSpecifies the HTML tag (or node-name) the [can-component] will be created on.\n",
    "types": [
      {
        "type": "String",
        "description": "The tag name the [can-component]\nwill be created on.  Tag names are typically lower cased and\nhypenated like: `foo-bar`.  Component's register their\ntag with [can-view-callbacks.tag tag].\n\n\n"
      }
    ],
    "title": "tag",
    "name": "can-component.prototype.tag",
    "type": "property",
    "parent": "can-component.prototype"
  },
  "can-component.prototype.template": {
    "src": {
      "path": "node_modules/can-component/docs/template.md"
    },
    "body": "\n\n\n## Use\n\nThe template specified by the `template` property works similar to \nthe [http://www.w3.org/TR/shadow-dom/ W3C Shadow DOM proposal]. It represents the contents\nof a custom element, while being able to reposition the user provided __source__ elements\nwith the `<content>` tag.\n\nThere are three things to understand about a [can-component]'s template:\n\n - It is inserted into the component's tag.\n - It is rendered with access to the component instance's viewModel.\n - `<content>` tags within the template act as insertion points for the source elements.\n\nThe following example demonstrates all three features:\n\n<div class='demo_wrapper' data-demo-src='can/component/examples/my_greeting_full.html'></div>\n\nThe following explains how each part works:\n\n__Component:__\n\n    Component({\n      tag: \"my-greeting\",\n      template: stache(\"<h1><content/></h1>\"),\n      viewModel: {\n        title: \"can-component\"\n      }\n    })\n\nThis registers a component for elements like `<my-greeting>`. Its template\nwill place an `<h1>` element directly within `<my-greeting>` and put\nthe original contents of `<my-greeting>` within the `<h1>`. The component's\n[can-component::viewModel viewModel] adds a title value.\n\n__Source template:__\n\n    <header>\n      <my-greeting>\n         {{site}} - {{title}}\n      </my-greeting>\n    </header>\n\nThe source template is the template that \nuses `<my-greeting>`.  In the demo, this is defined within a `<script>` \ntag.\n\nNotice:\n\n - There is content within `<my-greeting>`.\n - The content looks for a `site` and `title` value.\n\n__Source data:__\n\n\t\tstache(\"...\")({\n\t\t\tsite: \"CanJS\"\n\t\t})\n\nThis is how we render the source template that uses `<my-greeting>`. The template is rendered with `site` in its [can-component::viewModel].\n\n__HTML Result:__\n\n    <header>\n      <my-greeting>\n        <h1>CanJS - can-component</h1>\n      </my-greeting>\n    </header>\n\nThis is the result of the template transformations. The\ncontent within the original `<my-greeting>` is placed within the `<h1>` \ntag.  Also, notice that the original content is able to access data from\nthe source data and from the component's viewModel.\n \nThe following sections break this down more.\n\n\n## Template insertion\n\nThe template specified by template is rendered directly withing the custom tag.\n\nFor example the following component:\n\n    Component({\n      tag: \"my-greeting\",\n      template: stache(\"<h1>Hello There</h1>\")\n    });\n\nWith the following source html:\n\n    <header>\n      <my-greeting></my-greeting>\n    </header>\n\nProduces the following html:\n\n    <header>\n      <my-greeting><h1>Hello There</h1></my-greeting>\n    </header>\n\nHowever, if there was existing content within the source html, like:\n\n    <header>\n      <my-greeting>DO REMOVE ME!!!</my-greeting>\n    </header>\n\nthat content is removed, and replaced by the component's template:\n\n    <header>\n      <my-greeting><h1>Hello There</h1></my-greeting>\n    </header>\n\n### The `<content>` element\n\nUse the `<content>` element to place the source content in the \ncomponent's element within the component's \ntemplate. For example, if we change the component to look like:\n\n    Component({\n      tag: \"my-greeting\",\n      template: stache(\"<h1><content/></h1>\")\n    });\n\nand rendered with source html, like:\n\n    <my-greeting>Hello World</my-greeting>\n\nit produces:\n\n    <my-greeting><h1>Hello World</h1></my-greeting>\n\n### `<content>` element default content\n\nIf the user does not provide source content, the html \nbetween the `<content>` tags will be used. For example, if we \nchange the component to look like:\n\n    Component({\n      tag: \"my-greeting\",\n      template: stache(\"<h1><content>Hello World</content></h1>\")\n    });\n\nand rendered with source html like:\n\n    <my-greeting></my-greeting>\n\nit produces:\n\n    <my-greeting><h1>Hello World</h1></my-greeting>\n\n\n",
    "description": "\nProvides a template to render directly within the component's tag. The template is rendered with the\ncomponent's [can-component::viewModel viewModel].  `<content>` elements within the template are replaced by\nthe source elements within the component's tag.\n",
    "types": [
      {
        "type": "can-stache.renderer",
        "description": "A [can-stache.renderer] returned by [can-stache]. For example:\n\n    Component({\n      tag: \"my-tabs\",\n      template: stache(\"<ul>{{#panels}}<li>{{title}}</li> ...\")\n    })\n\n"
      },
      {
        "type": "String",
        "description": "The string contents of a [can-stache] template.  For example:\n\n    Component({\n      tag: \"my-tabs\",\n      template: \"<ul>{{#panels}}<li>{{title}}</li> ...\"\n    })\n\nNote: Using mustache is deprecated.  Please switch to [can-stache].\n\n"
      }
    ],
    "title": "template",
    "name": "can-component.prototype.template",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.viewModel": {
    "src": {
      "path": "node_modules/can-component/docs/view-model.md"
    },
    "body": "\n## Use\n\n[can-component]'s viewModel property is used to define an __object__, typically an instance\nof a [can-map], that will be used to render the component's \ntemplate. This is most easily understood with an example.  The following\ncomponent shows the current page number based off a `limit` and `offset` value:\n\n    Component.extend({\n      tag: \"my-paginate\",\n      viewModel: {\n        offset: 0,\n        limit: 20,\n        page: function(){\n          return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n        }\n      },\n      template: stache(\"Page {{page}}.\")\n    })\n\nIf this component HTML was inserted into the page like:\n\n    var template = stache(\"<my-paginate/>\")\n    $(\"body\").append(template())\n\nIt would result in:\n\n    <my-paginate>Page 1</my-paginate>\n    \nThis is because the provided viewModel object is used to extend a [can-map] like:\n\n    CustomMap = Map.extend({\n      offset: 0,\n      limit: 20,\n      page: function(){\n        return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n      }\n    })\n\nAny primitives found on a `Map`'s prototype (ex: `offset: 0`) are used as\ndefault values.\n\nNext, a new instance of CustomMap is created with the attribute data within `<my-paginate>`\n(in this case there is none) like:\n\n    componentData = new CustomMap(attrs);\n    \nAnd finally, that data is added to the [can-view-scope parentScope] of the component, used to \nrender the component's template, and inserted into the element:\n\n    var newviewModel = parentScope.add(componentData),\n        result = stache(\"Page {{page}}.\")(newviewModel);\n    $(element).html(result);\n\n## Values passed from attributes\n\nValues can be \"passed\" into the viewModel of a component, similar to passing arguments into a function. Using\n[can-stache-bindings], the following binding types can be setup:\n\n- [can-stache-bindings.toChild] - Update the component's viewModel when the parent scope value changes.\n- [can-stache-bindings.toParent] - Update the parent scope when the component's viewModel changes.\n- [can-stache-bindings.twoWay] - Update the parent scope or the component's viewModel when the other changes.\n\nAs mentioned in the deprecation warning above, using [can-stache], values are passed into components like this:\n\n    <my-paginate {offset}='index' {limit}='size'></my-paginate>\n\nThe above would create an offset and limit property on the component that are initialized to whatever index and size are, NOT two-way bind (between component and parent viewModels) \nthe offset and limit properties to the index and size.\n\nThe following component requires an `offset` and `limit`:\n\n    Component.extend({\n      tag: \"my-paginate\",\n      viewModel: {\n        page: function(){\n          return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n        }\n      },\n      template: stache(\"Page {{page}}.\")\n    });\n\nIf `<my-paginate>`'s source html is rendered like:\n\n    var template = stache(\"<my-paginate {offset}='index' {limit}='size'></my-paginate>\");\n    \n    var pageInfo = new Map({\n      index: 0,\n      size: 20\n    });\n    \n    $(\"body\").append( template( pageInfo ) );\n\n... `pageInfo`'s index and size are set as the component's offset and \nlimit attributes. If we were to change the value of `pageInfo`'s \nindex like:\n\n    pageInfo.attr(\"index\",20)\n\n... the component's offset value will change and its template will update to:\n\n    <my-paginate>Page 1</my-paginate>\n\n### Using attribute values\n\nYou can also pass a literal string value of the attribute. To do this in [can-stache], \nsimply pass any value not wrapped in single brackets, and the viewModel property will\nbe initialized to this string value:\n\n    <my-tag title=\"hello\"></my-tag>\n\nThe above will create a title property in the component's viewModel, which has a string `hello`.  \n\nIf the tag's `title` attribute is changed, it updates the viewModel property \nautomatically.  This can be seen in the following example:\n\n<div class='demo_wrapper' data-demo-src='can/component/examples/accordion.html'></div>\n\nClicking the __Change title__ button sets a `<panel>` element's `title` attribute like:\n\n    $(\"#out\").on(\"click\", \"button\", function(){\n      $(\"panel:first\").attr(\"title\", \"Users\")\n      $(this).remove();\n    });\n\n\n## Calling methods on viewModel from events within the template\n\nUsing html attributes like `can-EVENT-METHOD`, you can directly call a viewModel method\nfrom a template. For example, we can make `<my-paginate>` elements include a next\nbutton that calls the viewModel's `next` method like:\n\n    Component.extend({\n      tag: \"my-paginate\",\n      viewModel: {\n        offset: 0,\n        limit: 20,\n        next: function(context, el, ev){\n          this.attr(\"offset\", this.offset + this.limit);\n        },\n        page: function(){\n          return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n        }\n      },\n      template: stache(\"Page {{page}} <button ($click)='next()'>Next</button>\")\n    })\n\nviewModel methods get called back with the current context, the element that you are listening to and the event that triggered the callback.\n\n<div class='demo_wrapper' data-demo-src='can/component/examples/paginate_next.html'></div>\n\n## Publishing events on viewModels\n\nMaps can publish events on themselves. For instance, the following `<player-edit>` component,\ndispatches a `\"close\"` event when it's close method is called:\n\n```\nComponent.extend({\n  tag: \"player-edit\",\n  template: template,\n  viewModel: {\n    close: function(){\n      this.dispatch(\"close\");\n    }\n  }\n});\n```\n\nThese can be listened to with [can-stache-bindings.event] bindings like:\n\n```\n<player-edit \n  \t(close)=\"removeEdit()\" \n  \t{player}=\"editingPlayer\"/>\n```\n\nThe following demo uses this ability to create a close button that \nhides the player editor:\n\n<div class='demo_wrapper' data-demo-src='can/component/examples/paginate_next_event.html'></div>\n\n",
    "description": " \nProvides or describes a [can-map] constructor function or `Map` instance that will be\nused to retrieve values found in the component's [can-component::template template]. The map \ninstance is initialized with values specified by the component element's attributes.\n\n__Note:__ This page documents behavior of components in [can-stache]. [can-mustache] behaves\nslightly differently. If you want the behavior of components with [can-mustache], \nplease look at versions of this page prior to 2.3. In 2.3, use [can-stache-bindings] [can-stache-bindings.toChild], \n[can-stache-bindings.toParent] and [can-stache-bindings.twoWay] to setup viewModel \nbindings.\n\n",
    "types": [
      {
        "type": "Object",
        "description": "A plain JavaScript object that is used to define the prototype methods and properties of\n[can-construct constructor function] that extends [can-map]. For example:\n\n    Component.extend({\n      tag: \"my-paginate\",\n      viewModel: {\n        offset: 0,\n        limit: 20,\n        next: function(){\n          this.attr(\"offset\", this.offset + this.limit);\n        }\n      }\n    });\n",
        "options": []
      },
      {
        "type": "can-map",
        "description": "A `Map` constructor function will be used to create an instance of the observable\n`Map` placed at the head of the template's viewModel.  For example:\n\n    var Paginate = Map.extend({\n      offset: 0,\n      limit: 20,\n      next: function(){\n        this.attr(\"offset\", this.offset + this.limit);\n      }\n    })\n    Component.extend({\n      tag: \"my-paginate\",\n      viewModel: Paginate\n    })\n    \n"
      },
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "can-map",
              "description": "If an instance of `Map` is returned, that instance is placed\non top of the viewModel and used to render the component's template.\n"
            },
            {
              "type": "Object",
              "options": [],
              "description": "If a plain JavaScript object is returned, that is used as a prototype\ndefinition used to extend `Map`.  A new instance of the extended Map is created.\n"
            }
          ],
          "description": "Specifies one of the following:\n\n - The data used to render the component's template.\n - The prototype of a `Map` that will be used to render the component's template.\n "
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "attrs",
            "description": "An object of values specified by the custom element's attributes. For example,\na template rendered like:\n\n    stache(\"<my-element title='name'></my-element>\")({\n      name: \"Justin\"\n    })\n\nCreates an instance of following control:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(attrs){\n    \t  attrs.title //-> \"Justin\";\n    \t  return new Map(attrs);\n    \t}\n    })\n\nAnd calls the viewModel function with `attrs` like `{title: \"Justin\"}`.\n"
          },
          {
            "types": [
              {
                "type": "can-component"
              },
              {
                "type": ":"
              },
              {
                "type": ":"
              },
              {
                "type": "viewModel"
              }
            ],
            "name": "parentScope",
            "description": "\n\nThe viewModel the custom tag was found within.  By default, any attribute's values will\nbe looked up within the current viewModel, but if you want to add values without needing\nthe user to provide an attribute, you can set this up here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(attrs, parentScope){\n    \t  return new Map({title: parentScope.attr('name')});\n    \t}\n    });\n\nNotice how the attribute's value is looked up in `my-element`'s parent viewModel.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(attrs, parentScope, el){\n    \t  return new Map({title: el.getAttribute('title')});\n    \t}\n    });\n"
          }
        ],
        "description": "Returns the instance or constructor function of the object that will be added\nto the viewModel.\n"
      }
    ],
    "title": "viewModel",
    "name": "can-component.prototype.viewModel",
    "type": "property",
    "parent": "can-component.prototype",
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "name": "element",
      "description": "The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(attrs, parentScope, el){\n    \t  return new Map({title: el.getAttribute('title')});\n    \t}\n    });\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-map",
          "description": "If an instance of `Map` is returned, that instance is placed\non top of the viewModel and used to render the component's template.\n"
        },
        {
          "type": "Object",
          "options": [],
          "description": "If a plain JavaScript object is returned, that is used as a prototype\ndefinition used to extend `Map`.  A new instance of the extended Map is created.\n"
        }
      ],
      "description": "Specifies one of the following:\n\n - The data used to render the component's template.\n - The prototype of a `Map` that will be used to render the component's template.\n "
    },
    "comment": " "
  },
  "can-compute.asyncComputer": {
    "src": {
      "path": "node_modules/can-compute/docs/async_computer.md"
    },
    "body": "\n",
    "description": "\nA function that determines a value for an [can-compute.async async compute].\n",
    "type": "typedef",
    "title": "asyncComputer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "If a `setVal` argument is not provided, the return value\nis set as the current value of the compute.  If `setVal` is provided and\nundefined is returned, the current value remains until `setVal` is called.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The last set value of the compute.  This should be returned\nif you are doing an in-place compute. \n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "setVal",
            "description": "Called to update the value \nof the compute at a later time. \n"
          }
        ],
        "description": "The function callback to [can-compute.async] that determines\nthe value of the compute.\n"
      }
    ],
    "name": "can-compute.asyncComputer",
    "parent": "can-compute",
    "release": "2.1",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newVal"
            }
          ]
        }
      ],
      "optional": true,
      "name": "setVal",
      "description": "Called to update the value \nof the compute at a later time. \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "If a `setVal` argument is not provided, the return value\nis set as the current value of the compute.  If `setVal` is provided and\nundefined is returned, the current value remains until `setVal` is called.\n"
    }
  },
  "can-compute.async": {
    "src": {
      "path": "node_modules/can-compute/docs/async.md"
    },
    "body": "\n\n## Use\n\nThe following compute is a live list of todos for a given \nuserId. `todos` value would alternate between `null` and a Todo.List as `userId` changes.\n\n\n    var userId = canCompute(5)\n    \n    var todos = canCompute.async(null, function(oldTodoList, setValue){\n      Todo.findAll({ userId: userId() }, function(todos){\n        setValue(todos)\n      });\n      return null;\n    });\n\n\nThe following replaces the list in place:\n\n    var userId = canCompute(5)\n    \n    var todos = canCompute.async(new Todo.List(), function(todoList, setValue){\n      todoList.replace( Todo.findAll({ userId: userId() })\n      return todoList;\n    });\n\n",
    "description": "\nCreate a compute that can set its value after the computed function has been called.\n",
    "title": "async",
    "name": "can-compute.async",
    "type": "function",
    "parent": "can-compute",
    "release": "2.1",
    "hide": true,
    "signatures": [
      {
        "code": "canCompute.async(initialValue, computed(currentValue, setValue(newValue) )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "The",
            "description": "initial value of the compute.\n"
          },
          {
            "types": [
              {
                "type": "can-compute.asyncComputer"
              }
            ],
            "name": "computed",
            "description": "A function \nthat returns the current value of the compute and can optionally later call \nits `setValue` callback to update the value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "Returns a compute, but a compute that will \npossibly not have the correct value unless it is bound to.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute.asyncComputer"
        }
      ],
      "name": "computed",
      "description": "A function \nthat returns the current value of the compute and can optionally later call \nits `setValue` callback to update the value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "Returns a compute, but a compute that will \npossibly not have the correct value unless it is bound to.\n"
    },
    "comment": " "
  },
  "getListData": {
    "type": "function",
    "name": "getListData",
    "params": [
      {
        "name": "params",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 2,
      "codeLine": 6,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "",
    "description": "Get a list of instances\n",
    "returns": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "getData": {
    "type": "function",
    "name": "getData",
    "params": [
      {
        "name": "params",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 9,
      "codeLine": 13,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "",
    "description": "Get an instance\n",
    "returns": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "parseListData": {
    "type": "function",
    "name": "parseListData",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "listData",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 49,
      "codeLine": 55,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "\n",
    "description": "Provided by parse-data\n",
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "listData",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An array that represents the data\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An array that represents the data\n "
    }
  },
  "parseInstanceData": {
    "type": "function",
    "name": "parseInstanceData",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "instanceData",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 56,
      "codeLine": 62,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "\n",
    "description": "Provided by parse-data\n",
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "instanceData",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object of properties on the object\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object of properties on the object\n "
    }
  },
  "computeSettings": {
    "src": {
      "path": "node_modules/can-compute/docs/compute_settings.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "computeSettings",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "description": "A function that retrieves and returns the current value of the compute."
          },
          {
            "name": "set",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "description": "A function that is used when setting a new value of the compute.\n\nA function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can.computed compute] and the current value. If\n`set` returns a value, it is used to compare to the current value of the compute. Otherwise,\n`get` is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.\n\n`newVal` is the value being set, while `oldVal` is the previous value in the compute.\n"
          },
          {
            "name": "on",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ],
                    "name": "updated"
                  }
                ]
              }
            ],
            "description": "Called to setup binding to dependency events. Call `updated` when the compute's value needs to be updated.\n"
          },
          {
            "name": "off",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "Called to teardown binding.\n"
          }
        ]
      }
    ],
    "name": "computeSettings",
    "release": "2.1",
    "parent": "can.compute"
  },
  "can-compute.computed": {
    "src": {
      "path": "node_modules/can-compute/docs/computed.md"
    },
    "body": "",
    "description": "\n",
    "title": "compute",
    "name": "can-compute.computed",
    "type": "function",
    "parent": "can-compute",
    "signatures": [
      {
        "code": "compute( [newVal] )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "If `compute` is called with an argument, the first argument is used\nto set the compute to a new value. This may trigger a \n`\"change\"` event that can be listened for with [can.computed.bind].\n\nIf the compute is called without any arguments (`compute()`), it simply returns\nthe current value of the compute.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The current value of the compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "newVal",
      "description": "If `compute` is called with an argument, the first argument is used\nto set the compute to a new value. This may trigger a \n`\"change\"` event that can be listened for with [can.computed.bind].\n\nIf the compute is called without any arguments (`compute()`), it simply returns\nthe current value of the compute.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The current value of the compute.\n"
    }
  },
  "connect": {
    "type": "function",
    "name": "connect",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "String"
                  }
                ]
              },
              {
                "types": [
                  {
                    "type": "Behavior"
                  }
                ]
              },
              {
                "types": [
                  {
                    "type": "function",
                    "returns": {
                      "types": [
                        {
                          "type": "undefined"
                        }
                      ]
                    },
                    "params": []
                  }
                ]
              }
            ]
          }
        ],
        "name": "behaviors",
        "description": "- An array of behavior names or custom behaviors.\nThe order of named execution gets run in order."
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "options",
        "description": "\n"
      }
    ],
    "parent": "node_modules/can-connect/src/connect.js",
    "src": {
      "line": 1,
      "codeLine": 7,
      "path": "node_modules/can-connect/src/connect.js"
    },
    "body": "",
    "description": "",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "\n"
    }
  },
  "can-connect.behaviors": {
    "name": "can-connect.behaviors",
    "title": "Behaviors",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 1
  },
  "can-connect.modules": {
    "name": "can-connect.modules",
    "title": "Modules",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 2
  },
  "can-connect.types": {
    "name": "can-connect.types",
    "title": "Data Types",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 3
  },
  "can-connect": {
    "src": {
      "path": "node_modules/can-connect/src/can-connect.md"
    },
    "body": "\n`can-connect` comes with the following behaviors that:\n\nLoad data:\n\n - [can-connect/data/url/url] - Persist data to restful or other types of services.\n - [can-connect/data/parse/parse] - Extract response data into a format needed for other extensions.\n\nConvert data into special types:\n\n - [can-connect/constructor/constructor] - Create instances of a constructor function or list type.\n - [can-connect/constructor/store/store] - Create only a single instance for a given id or a single list for a set.\n\nReal time:\n\n - [can-connect/real-time/real-time] - Update lists and instances with server side events.\n\nCaching strategies:\n\n - [can-connect/fall-through-cache/fall-through-cache] - Respond with data from the [connection.cacheConnection] and\n   then update the response with data from the `raw CRUD Methods`.\n - [can-connect/data/inline-cache/inline-cache] - Use an inline cache for initial ajax requests.\n - [can-connect/cache-requests/cache-requests] - Save response data and use it for future requests.\n - [can-connect/data/combine-requests/combine-requests] - Combine overlapping or reduntant requests.\n\nCaching layers:\n\n - [can-connect/data/localstorage-cache/localstorage-cache] - LocalStorage caching connection.\n - [can-connect/data/memory-cache/memory-cache] - LocalStorage caching connection.\n\nThe following modules glue certain methods together:\n\n - [can-connect/data/callbacks/callbacks] - Glues the result of the `raw CRUD Methods` to callbacks.\n - [can-connect/data/callbacks-cache/callbacks-cache] - Calls [connection.cacheConnection] methods whenever `raw CRUD methods` are called.\n\n\nThe following modules are useful to CanJS specifically:\n\n - [can-connect/can/map/map] - Create instances of a special can.Map or can.List type.\n - [can-connect/can/super-map/super-map] - Create a connection for a can.Map or can.List that uses almost all the plugins.\n - [can-connect/can/model/model] - Inherit from a highly compatable [can.Model](http://canjs.com/docs/can.Model.html) implementation.\n - [can-connect/can/tag/tag] - Create a custom element that can load data into a template.\n\n## Overview\n\nThe \"can-connect\" module exports a `connect` function that is used to assemble different\nbehaviors and some options into a `connection`.  For example, the following uses `connect` and\nthe [can-connect/constructor/constructor] and [can-connect/data/url/url] behaviors to create a `todoConnection`\nconnection:\n\n```js\nvar connect = require(\"can-connect\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\nvar todoConnection = connect(\n  [constructor,dataUrl],\n  {\n    url: \"/services/todos\"\n  });\n```\n\nA connection typically provides the ability to\ncreate, read, update, or delete (CRUD) some data source. That data source is\nusually accessed through the \"Instance Interface\" methods:\n\n - [can-connect/connection.get]\n - [can-connect/connection.getList]\n - [can-connect/connection.save]\n - [can-connect/connection.destroy]\n\nFor example, to get all todos from \"GET /services/todos\", we could write the following:\n\n```\ntodoConnection.getList({}).then(function(todos){ ... });\n```\n\n__Behaviors__, like [can-connect/constructor/constructor] and [can-connect/data/url/url] implement,\nextend, or require some set of [interfaces](#section_Interfaces).  For example, [can-connect/data/url/url] implements\nthe \"Data Interface\" methods, and [can-connect/constructor/constructor] implements the\n\"Instance Interface\" methods.\n\nThe `connect` method calls these behaviors in the right order to create a connection. For instance,\nthe [can-connect/cache-requests/cache-requests] behavior must be applied after the [can-connect/data/url/url]\nconnection.  This is because [can-connect/cache-requests/cache-requests], overwrites [can-connect/data/url/url]'s\n[can-connect/connection.getListData] first check a cache for the data.  Only if the data is not present,\ndoes it call [can-connect/data/url/url]'s [can-connect/connection.getListData]. So even if we write:\n\n```js\nvar dataUrl = require(\"can-connect/data/url/url\");\nvar cacheRequests = require(\"can-connect/cache-requests/cache-requests/cache-requests\");\nconnect([cacheRequests,dataUrl])\n```\n\nor\n\n```\nconnect([dataUrl,cacheRequests])\n```\n\n... our connection will be built in the right order!\n\nA __connection__ is just an object with each behavior object on its prototype chain and\nits options object at the end of the prototype chain.\n\n\n## Use\n\nThis section covers how to install can-connect and then the basics of its use.\n\n### Install\n\nUse npm to install `can-connect`:\n\n```\n> npm install can-connect --save\n```\n\nThen, depending on your module loader, you'll do one of the following:\n\n#### StealJS\n\nImport can-connect and its behaviors like:\n\n```js\nimport connect from \"can-connect\";\nimport dataUrl from \"can-connect/data/url/\";\nimport constructor from \"can-connect/constructor/\";\n```\n\n#### Browserify\n\n`require` can-connect and its behaviors like:\n\n```js\nvar connect = require(\"can-connect\");\nvar dataUrl = require(\"can-connect/data/url/url\");\nvar constructor = require(\"can-connect/constructor/constructor\");\n```\n\n#### AMD\n\nConfigure a package to can-connect and its dependency can-set:\n\n```js\nrequire.config({\n  packages: [{\n    name: 'can-connect',\n    location: 'node_modules/can-connect/dist/amd',\n    main: 'can-connect'\n  },{\n    name: 'can-set',\n    location: 'node_modules/can-connect/node_modules/can-set/dist/amd',\n    main: 'src/set'\n  }]\n});\n```\n\nThen use `define` to load can-connect and its behaviors like:\n\n```js\ndefine([\"can-connect\",\"can-connect/data/url/url\", \"can-connect/constructor/constructor\"],\n      function(connect, dataUrl, constructor){\n\n});\n```\n\n\n\n\n### Basic connection\n\nTo use `can-connect`, it's typically best to start out with the most basic\nbehaviors: [can-connect/data/url/url] and [can-connect/constructor/constructor]. [can-connect/data/url/url]\nconnects the \"Data Interface\" to a restful service. [can-connect/constructor/constructor] adds\nan \"Instance Interface\" that can create, read, update and delete (CRUD) typed data\nusing the lower-level \"Data Interface\".\n\nBy `typed` data we mean data that is more than just plain JavaScript objects.  For\nexample, we might to create `todo` objects with an `isComplete` method:\n\n```js\nvar Todo = function(props){\n  Object.assign(this, props);\n};\n\nTodo.prototype.isComplete = function(){\n  return this.status === \"complete\";\n};\n```\n\nAnd, we might want a special list type with `completed` and `active` methods:\n\n```js\nvar TodoList = function(todos){\n  [].push.apply(this, todos);\n};\nTodoList.prototype = Object.create(Array.prototype);\n\nTodoList.prototype.completed = function(){\n  return this.filter(function(todo){\n    return todo.status === \"complete\";\n  });\n};\n\nTodoList.prototype.active = function(){\n  return this.filter(function(todo){\n    return todo.status !== \"complete\";\n  });\n};\n```\n\nWe can create a connection that connects a restful \"/api/todos\"\nservice to `Todo` instances and `TodoList` lists like:\n\n```js\nvar todoConnection = connect([constructor, dataUrl],{\n  url: \"/api/todos\",\n  list: function(listData, set){\n  \treturn new TodoList(listData.data);\n  },\n  instance: function(props) {\n  \treturn new Todo(props);\n  }\n});\n```\n\nAnd then use that connection to get a `TodoList` of `Todo`s:\n\n```\ntodoConnection.getList({}).then(function(todos){\n\tvar todosEl = document.getElementById(\"todos-list\");\n\ttodosEl.innerHTML = \"<h2>Active</h2>\"+\n\t\trender(todos.active())+\n\t\t\"<h2>Complete</h2>\"+\n\t\trender(todos.completed());\n});\n\nvar render = function(todos) {\n\treturn \"<ul>\"+todos.map(function(todo){\n\t\treturn \"<li>\"+todo.name+\n\t\t\t\t\"<input type='checkbox' \"+\n\t\t\t\t(todo.isComplete() ? \"checked\" : \"\")+\"/></li>\";\n\t}).join(\"\")+\"</ul>\";\n};\n```\n\nThe following demo shows the result:\n\n<div class='demo_wrapper' data-demo-src='can-connect/docs/demos/basics.html'></div>\n\nThis connection also lets you create, update, and destroy a Todo instance as follows:\n\n```js\nvar todo = new Todo({\n  name: \"take out trash\"\n})\n\n// POSTs to /api/todos name=take out trash\n// server returns {id: 5}\ntodoConnection.save( todo ).then(function(todo){\n  todo.id //-> 5\n  todo.name = 'take out garbage'\n\n  // PUTs to /api/todos/5 name=take out garbage\n  // server returns {id: 5, \"take out garbage\"}\n  todoConnection.save( todo ).then( function(todo){\n\n    // DELETEs to /api/todos/5\n    // server returns {}\n    todoConnection.destroy( todo ).then( function(todo){\n\n    });\n\n  });\n\n});\n```\n\n### Configure behaviors\n\nWhenever `connect` creates a connection, it always adds the [can-connect/base/base]\nbehavior. This behavior defines configurable options that are used by almost\nevery other behavior.  For example, if your data uses an `_id` property\nto uniquely identify todos, you\ncan specify this with [can-connect/base/base.idProp] like:\n\n```js\nvar todoConnection = connect([\"constructor\",\"data-url\"],{\n  url: \"/api/todos\",\n  idProp: \"_id\"\n});\n```\n\nOther behaviors list their configurable options in their own docs page.  \n\n### Overwrite behaviors\n\nIf configurable options are not enough, you can overwrite any behavior with your own behavior.\n\nFor example, the `constructor`'s [can-connect/constructor.updatedInstance] behavior\nsets the instance's properties to match the result of [can-connect/connection.updateData]. But if\nthe `PUT /api/todos/5 name=take out garbage` request returned `{}`, the following would result in\na todo with only an `id` property:\n\n```js\nvar todo = new Todo({id: 5, name: \"take out garbage\"})\n// PUTs to /api/todos/5 name=take out garbage\n// server returns {}\ntodoConnection.save( todo ).then( function(todo){\n\n  todo.id //-> 5\n  todo.name //-> undefined\n});\n```\n\nThe following overwrites the behavior of `updateData`:\n\n```js\nvar mergeDataBehavior = {\n  updateData: function(instance, data){\n    Object.assign(instance, data);\n  }\n}\n\n\nvar todoConnection = connect([\n    \"constructor\",\n    \"data-url\",\n    mergeDataBehavior\n  ],{\n  url: \"/api/todos\"\n});\n```\n\nYou can add your own behavior that overwrite all base behaviors by adding\nit to the end of the behaviors list.\n\n\n### CanJS use\n\nIf you are using CanJS, you can either:\n\n- use the [can-connect/can/map/map] behavior that overwrites\n  many methods and settings to work with `can.Map` and `can.List`.\n- use the [can-connect/can/super-map/super-map] helper to create a connection that bundles \"can/map\" and\n  many of the other extensions.\n\nUsing [can-connect/can/map/map] to create a connection looks like:\n\n```js\nvar Todo = can.Map.extend({ ... });\nTodo.List = can.List.extend({Map: Todo},{});\n\nvar todoConnection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/can/map/map/map\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/constructor/store/store\")\n  ],{\n  Map: Todo,\n  url: \"/todos\"\n});\n```\n\nWhen you bind on a `Todo` instance or `Todo.List` list, they will automatically call\n[can.connect/constructor-store.addInstanceReference] and [can.connect/constructor-store.addListReference].\n\nUsing [can-connect/can/super-map/super-map] to create a connection looks like:\n\n```\nvar Todo = can.Map.extend({ ... });\nTodo.List = can.List.extend({Map: Todo},{});\n\nvar todoConnection = superMap({\n  Map: Todo,\n  url: \"/todos\"\n});\n```\n\n### ReactJS use\n\nHelp us create a special ReactJS behavior that integrates\na connection with React's observable life-cycle. Read more [here](#section_Otheruse).\n\n### Angular use\n\nHelp us create a special AngularJS behavior that integrates\na connection with Angular's observable life-cycle. Read more [here](#section_Otheruse).\n\n### Backbone use\n\nHelp us create a special BackboneJS behavior that integrates\na connection with Backbone's observable life-cycle. Read more [here](#section_Otheruse).\n\n### Other use\n\nIntegrating `can-connect` with your framework is typically pretty easy.  In general,\nthe pattern involves creating a behavior that integrates with your framework's\nobservable instances. The [can-connect/can/map/map]\nbehavior can serve as a good guide. You'll typically want to implement the following\nin your behavior:\n\n`.instance` - Creates the appropriate observable object type.  \n`.list` - Creates the appropriate observable array type.  \n`.serializeInstance` - Return a plain object out of the observable object type.  \n`.serializeList` - Return a plain array out of the observable array type.  \n\n`.createdInstance` - Update an instance with data returned from `createData`.  \n`.updatedInstance` - Update an instance with data returned from `updateData`.  \n`.destroyedInstance` -  Update an instance with data returned from `destroyData`.  \n`.updatedList` - Update a list with raw data.\n\nAnd, in most frameworks you know when a particular observable is being used, typically\nobserved, and when it can be discarded.  In those places, you should call:\n\n[can.connect/constructor-store.addInstanceReference] - Call when an instance is being used.  \n[can.connect/constructor-store.deleteInstanceReference] - Call when an instance is no longer being used.  \n[can.connect/constructor-store.addListReference] - Call when a list is being used.  \n[can.connect/constructor-store.deleteListReference] - Called when a list is no longer being used.  \n\n\n## Interfaces\n\nThe following is a list of the most important interface methods and properties implemented\nor consumed by the core behaviors.\n\n### Identifiers\n\n`.id( props | instance ) -> String` - Returns a unique identifier for the instance or raw data.  \n`.idProp -> String=\"id\"` - The name of the unique identifier property.  \n`.listSet(list) -> set` - Returns the set a list represents.  \n`.listSetProp -> String=\"__listSet\"` - The property on a List that contains its set.  \n\nImplemented by [can-connect/base/base].\n\n### Instance Interface\n\nThe following methods operate on instances and lists.\n\n#### CRUD methods:\n\n`.getList(set) -> Promise<List>` - retrieve a list of instances.  \n`.getList(set) -> Promise<Instance>` - retrieve a single instance.   \n`.save(instance) -> Promise<Instance>` - creates or updates an instance.  \n`.destroy(instance) -> Promise<Instance>` - destroys an instance.  \n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [can-connect/constructor/store/store].\n\n#### Instance callbacks\n\n`.createdInstance(instance, props)` - An instance is created.  \n`.updatedInstance(instance, props)` - An instance is updated.  \n`.destroyedInstance(instance, props)` - An instance is destroyed.  \n`.updatedList(list, updatedListData, set)` - A list has been updated.  \n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [data-connect/real-time],\n[can-connect/constructor/callbacks-once].\n\n#### Hydrators and Serializers\n\n`.instance(props) -> Instance` - Creates an instance given raw data.  \n`.list({data: Array<Instance>}) -> List` - Creates a list given an array of instances.  \n`.hydrateInstance(props) -> Instance` - Provides an instance given raw data.  \n`.hydrateList({ListData}, set) -> List` - Provides a list given raw data.  \n`.hydratedInstance(instance)` - Called whenever an instance is created in memory.  \n`.hydratedList(list, set)` - Called whenever a list is created in memory.  \n`.serializeInstance(instance) -> Object` - Returns the serialized form of an instance.  \n`.serializeList(list) -> Array<Object>` - Returns the serialized form of a list and its instances.  \n\n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [can-connect/constructor/store/store],\n[can-connect/fall-through-cache/fall-through-cache].\n\n### Data Interface\n\nThe raw-data connection methods.  \n\n#### CRUD methods\n\n`.getListData(set) -> Promise<ListData>` - Retrieves list data.  \n`.updateListData(listData[, set]) -> Promise<ListData>` - Update a list's data.  \n`.getSets() -> Promise<Array<Set>>` - Returns the sets available to the connection.  \n\n\n`.getData(params) -> Promise<Object>` - Retrieves data for a particular item.  \n`.createData(props, cid) -> Promise<props>` - Creates instance data given the serialized form of the data.\n  A client ID is passed of the\n  instance that is being created.  \n`.updateData(props) -> Promise<props>` - Updates instance data given the\n  serialized form of the data.  \n`.destroyData(props) -> Promise<props>` - Destroys an instance given the seralized\nform of the data.  \n\n`.clear() -> Promise` - Clears all data in the connection.\n\nImplemented by [can-connect/data/url/url],\n[can-connect/data/localstorage-cache/localstorage-cache], [can-connect/data/memory-cache/memory-cache].\nOverwritten by [can-connect/cache-requests/cache-requests], [can-connect/data/combine-requests/combine-requests],\n[can-connect/data/inline-cache/inline-cache], [can-connect/fall-through-cache/fall-through-cache].\nConsumed by [can-connect/constructor/constructor].  \n\n#### Data Callbacks\n\n`.gotListData(listData, set) -> ListaData` - List data is retrieved.  \n`.gotData( props, params) -> props` - Instance data is retreived.  \n`.createdData( props, params, cid) -> props` - An instance's data is created.  \n`.updatedData( props, params) -> props` - An instance's data is updated.  \n`.destroyedData( props, params) -> props` - An instance's data is destroyed.  \n\nImplemented by [can-connect/data/callbacks/callbacks].  Overwritten by [can-connect/data/callbacks-cache/callbacks-cache],\n[can-connect/real-time/real-time].\n\n#### Response parsers\n\n`.parseListData(*) -> ListData` - Given the response of getListData, return the right object format.  \n`.parseInstanceData(*) -> props` - Given the response of getData, createData, updateData, and destroyData,\nreturn the right object format.\n\nImplemented by [can-connect/data/parse/parse].\n\n#### Store Interface\n\n`.addInstanceReference(instance)` - Signal that memory-unsafe actions can be performed on the instance.  \n`.deleteInstanceReference(instance)` - Signal that memory-unsafe actions should be removed.\n`.addListReference(list)` - Signal that memory-unsafe actions can be performed on the list.  \n`.deleteListReference(list)` - Signal that memory-unsafe actions should be removed.\n\nImplemented by [can-connect/constructor/store/store].\n\n#### Real-time Methods\n\n`createInstance( props ) -> Promise<instance>` - Inform the connection an instance has been created.  \n`updateInstance( props ) -> Promise<instance>` - Inform the connection an instance has been updated.  \n`destroyInstance( props ) -> Promise<instance>` - Inform the connection an instance has been destroyed.  \n\nImplemented by [can-connect/real-time/real-time].\n\n## Creating Behaviors\n\nTo create your own behavior, call `connect.behavior` with the name of your behavior and a function that\nreturns an object that defines the hooks you want to overwrite or provide:\n\n```js\nconnect.behavior(\"my-behavior\", function(baseBehavior){\n  return {\n    // Hooks here\n  };\n})\n```\n\nFor example, creating a simple localStorage behavior might look like:\n\n```js\nconnect.behavior(\"localstorage\", function(baseBehavior){\n  return {\n    getData: function(params){\n      var id = this.id(params);\n      return new Promise(function(resolve){\n        var data = localStorage.getItem(baseBehavior.name+\"/\"+id);\n        resolve( JSON.parse(data) )\n      });\n    },\n    createData: function(props){\n      var id = localStorage.getItem(baseBehavior.name+\"-ID\") || \"0\";\n\n      var nextId = ++JSON.parse( id );\n      localStorage.setItem(baseBehavior.name+\"-ID\"), nextId);\n      var id = this.idProp;\n      return new Promise(function(resolve){\n        props[id] = nextId;\n        localStorage.setItem(baseBehavior.name+\"/\"+nextId, props);\n        resolve( props )\n      });\n    },\n    updateData: function(){ ... },\n    destroyData: function(){ ...}\n  };\n})\n```\n\n",
    "description": "`can-connect` provides persisted data middleware. Use it to assemble powerful model layers for any JavaScript project.\n\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect",
    "parent": "can-core",
    "outline": "2",
    "comment": " "
  },
  "can-control.extend": {
    "src": {
      "path": "node_modules/can-control/docs/control.extend.md"
    },
    "body": "\n## Examples\n\n    // Control that writes \"hello world\"\n    HelloWorld = Control.extend({\n      init: function(element){\n        element.text(\"hello world\")  \n      }\n    });\n    new HelloWorld(\"#message\");\n    \n    // Control that shows how many times\n    // the element has been clicked on\n    ClickCounter = Control.extend({\n      init: function(){\n         this.count = 0;\n         this.element.text(\"click me\")\n      },\n      \"click\": function(){\n         this.count++;\n         this.element.text(\"click count = \"+this.count)\n      }\n    })\n    new ClickCounter(\"#counter\");\n \n    // Counter that counts a specified event\n    // type\n    CustomCounter = Control.extend({\n      defaults: {\n        eventType: \"click\"\n      }\n    },{\n      init: function(){\n        this.count = 0;\n        this.element.text(this.options.eventType+\" me\")\n      },\n      \"{eventType}\": function(){\n         this.count++;\n         this.element.text(this.options.eventType+\n           \" count = \"+\n           this.count);\n      }\n    })\n    new CustomCounter(\"#counter\");\n    new CustomCounter(\"#buy\",{\n      eventType: \"mouseenter\"\n    });\n    \n\n",
    "description": "\n",
    "title": "extend",
    "name": "can-control.extend",
    "type": "function",
    "parent": "can-control.static",
    "signatures": [
      {
        "code": "Control.extend([staticProperties,] instanceProperties)",
        "description": "\n\nCreate a new, extended, control constructor \nfunction. \n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "An object of properties and methods that are added the control constructor \nfunction directly. The most common property to add is [can-control.defaults].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"click\"` or `\"li mouseenter\"`) are setup\nas event handlers.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "constructs": {
                "types": [
                  {
                    "type": "can-construct"
                  }
                ]
              },
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "element"
                    }
                  ]
                },
                {
                  "types": [
                    {
                      "type": "options"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceProperties",
      "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"click\"` or `\"li mouseenter\"`) are setup\nas event handlers.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "constructs": {
            "types": [
              {
                "type": "can-construct"
              }
            ]
          },
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "element"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "options"
                }
              ]
            }
          ]
        }
      ],
      "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n"
    },
    "comment": " "
  },
  "can-control.defaults": {
    "src": {
      "path": "node_modules/can-control/docs/defaults.md"
    },
    "body": "\nDefault options provided for when a new control is created without values set in `options`.\n\n`defaults` provides default values for a Control's options.\nOptions passed into the constructor function will be shallowly merged\ninto the values from defaults in [can-control::setup], and\nthe result will be stored in [can-control::options this.options].\n\n\tMessage = Control.extend({\n\t  defaults: {\n\t\tmessage: \"Hello World\"\n\t  }\n\t}, {\n\t  init: function(){\n\t\tthis.element.text( this.options.message );\n\t  }\n\t});\n\n\tnew Message( \"#el1\" ); //writes \"Hello World\"\n\tnew Message( \"#el12\", { message: \"hi\" } ); //writes hi\n\n## Shared Properties\n\nNew instances of a Control will create a shallow copy of the default\noptions. Be aware as shallow copies keep a reference to object types, such as\nobjects, maps and computes.\n\n```\nvar Sample = Control.extend({\n  defaults: {\n    computedProp: can.compute(),\n    primitiveProp: 'sample'\n  }\n}, {});\n\nvar a = new Sample('div');\nvar b = new Sample('li');\n\n//`computedProp` will be shared across instances of the `Sample` control.\n//a.options.computedProp === b.options.computedProp\n```\n\n",
    "description": "Default values for the Control's options. \n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "defaults",
    "name": "can-control.defaults",
    "type": "property",
    "parent": "can-control.static",
    "comment": " "
  },
  "can-control.prototype.destroy": {
    "src": {
      "path": "node_modules/can-control/docs/destroy.md"
    },
    "body": "## Allowing Garbage Collection\n\nDestroy is called whenever a control's element is removed from the page using\nthe library's standard HTML modifier methods. This means that you\ndon't have to call destroy yourself and it\nwill be called automatically when appropriate.\n\nThe following `Clicker` widget listens on the window for clicks and updates\nits element's innerHTML. If we remove the element, the window's event handler\nis removed auto-magically:\n\n\n\tClicker = Control({\n\t\"{window} click\": function() {\n\t\tthis.element.html( this.count ?\n\t\tthis.count++ : this.count = 0 );\n\t}\n\t});\n\n\t// create a clicker on an element\n\tnew Clicker( \"#clickme\" );\n\n\t// remove the element\n\t$( '#clickme' ).remove();\n\nThe methods you can use that will destroy controls automatically by library:\n\n__jQuery and Zepto__\n\n- `$.fn.remove`\n- `$.fn.html`\n- `$.fn.replaceWith`\n- `$.fn.empty`\n\n__Dojo__\n\n- `dojo.destroy`\n- `dojo.empty`\n- `dojo.place (with the replace option)`\n\n__Mootools__\n\n- `Element.prototype.destroy`\n\n__YUI__\n\n- `Y.Node.prototype.remove`\n- `Y.Node.prototype.destroy`\n\n\n## Teardown in Destroy\n\nSometimes, you want to reset a controlled element back to its\noriginal state when the control is destroyed. Overwriting destroy\nlets you write teardown code of this manner.\n\n__NOTE__: When overwriting destroy, make sure you call Control's base functionality.\n\nThe following example changes an element's text when the control is\ncreated and sets it back when the control is removed:\n\n\tChanger = Control.extend({\n\t\tinit: function() {\n\t\t\tthis.oldText = this.element.text();\n\t\t\tthis.element.text( \"Changed!!!\" );\n\t\t},\n\t\tdestroy: function() {\n\t\t\tthis.element.text( this.oldText );\n\t\t\tcan.Control.prototype.destroy.call( this );\n\t\t}\n\t});\n\n\t// create a changer which changes #myel's text\n\tvar changer = new Changer( '#myel' );\n\n\t// destroy changer which will reset it\n\tchanger.destroy();\n\n## Base Functionality\n\nControl prepares the control for garbage collection by:\n\n- unbinding all event handlers\n- clearing references to this.element and this.options\n- clearing the element's reference to the control\n- removing it's `Control.pluginName` from the element's className\n\n",
    "description": "Remove a Control from an element and clean up the Control. ",
    "title": "destroy",
    "name": "can-control.prototype.destroy",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.destroy()",
        "description": "\n\nPrepares a control for garbage collection and is a place to\nreset any changes the control has made.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-control.static": {
    "name": "can-control.static",
    "title": "static",
    "type": "group",
    "parent": "can-control",
    "description": "",
    "order": 0
  },
  "can-control.prototype": {
    "name": "can-control.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-control",
    "description": "",
    "order": 0
  },
  "can-control": {
    "src": {
      "path": "node_modules/can-control/docs/control.md"
    },
    "body": "\n## The Control Lifecycle\n\nThe following walks through a control's lifecycle\nwith an example todo list widget.  It's broken up into the following\nlifecycle events:\n\n - Extending a control\n - Creating a control instance\n - Listening to events\n - Destroying a control\n\n## Extending a control\n\nThe following example builds up a basic todos widget for listing \nand completing todo items. Start by creating a control constructor \nfunction of your own by extending [can-control] and defining an instance init method.\n\n    var Todos = Control.extend({\n      init: function( element, options ) { ... }\n    });\n\n## Creating a control instance\n\nCreate an instance of the Todos control on the `todos` element with:\n\n    var todosControl = new Todos( '#todos', {} );\n\nThe control's associated [can.ejs EJS] template looks like:\n\n    <% todos.each(function( todo ) { %>\n      <li <%= (el) -> el.data( 'todo', todo ) %> >\n        <%= todo.attr( 'name' ) %>\n        <a href=\"javascript://\" class=\"destroy\">\n      </li>\n    <% }) %>\n\n### `init(element, options)`\n\n[can-control.prototype.init] is called with the below arguments when new instances of [can-control] are created:\n\n- __element__ - The wrapped element passed to the \n                control. Control accepts a\n                raw HTMLElement, a CSS selector, or a NodeList. This is\n                set as `this.element` on the control instance.\n- __options__ - The second argument passed to new Control, extended with\n                the can.Control's static __defaults__. This is set as \n                `this.options` on the control instance. Note that static is used\n                formally to indicate that _default values are shared across control instances_.\n\nAny additional arguments provided to the constructor will be passed as normal. Use [can.view] to produce a document fragment\nfrom your template and inject it in the passed element. Note that the `todos` parameter passed to [can.view] below\nis an instance of [can-list]:\n\n    var Todos = Control.extend({\n\n      //defaults are merged into the options arg provided to the constructor\n      defaults : { view: 'todos.ejs' }\n\n    }, {\n      init: function( element , options ) {\n\n        //create a pointer to the control's scope\n        var self = this;\n\n        //run the Todo model's .findAll() method to produce a can.List\n        Todo.findAll( {}, function( todos ) {\n\n            //create a document fragment with can.view\n            //and inject it into the provided element's body\n    \t\tself.element.html( can.view(self.options.view, todos) );\n        });\n      }\n    });\n    \n    // create a Todos Control with default options\n    new Todos( document.body.firstElementChild );\n    \n    // overwrite the template default\n    new Todos( '#todos', { template: 'specialTodos.ejs' } );\n\n### `this.element`\n\n[can-control::element] is the \nNodeList consisting of the element the control is created on. \n\n    var todosControl = new Todos( document.body.firstElementChild );\n    todosControl.element[0] //-> document.body.firstElementChild\n\nEach library wraps elements differently. If you are using jQuery, for example,\nthe element is wrapped with `jQuery( element )`.\n\n### `this.options`\n\n[can-control::options] is the second argument passed to \n`new Control()`, merged with the control's static __defaults__ property.\n\n## Listening to events\n\nControl automatically binds prototype methods that look\nlike event handlers. Listen to __click__'s on `<li>` elements like:\n\n    var Todos = Control.extend({\n      init: function( element , options ) {...},\n\n      'li click': function( li, event ) {\n        console.log( 'You clicked', li.text() );\n        \n        // let other controls know what happened\n        li.trigger( 'selected' );\n      }\n    });\n\nWhen an `<li>` is clicked, `\"li click\"` is called with:\n\n- The library-wrapped __element__ that was clicked\n- The __event__ data\n\nControl uses event delegation, so you can add `<li>`s without needing to rebind\nevent handlers.\n\nTo destroy a todo when its `<a href=\"javascript://\" class=\"destroy\">` link \nis clicked:\n\n    var Todos = can.Control.extend({\n      init: function( element, options ) {...},\n      \n      'li click': function( li ) {...},\n      \n      'li .destroy click': function( el, ev ) {\n        // get the li element that has todo data\n        var li = el.closest( 'li' );\n      \n        // get the model\n        var todo = li.data( 'todo' );\n  \n        //destroy it\n        todo.destroy();\n      }\n    });\n\nWhen the todo is destroyed, EJS's live binding will remove its LI automatically.\n\n### Templated Event Handlers Part 1 `\"{eventName}\"`\n\nCustomize event handler behavior with `\"{NAME}\"` in\nthe event handler name.  The following allows customization \nof the event that destroys a todo:\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n      \n      'li click': function( li ) { ... },\n      \n      'li .destroy {destroyEvent}': function( el, ev ) { \n        // previous destroy code here\n      }\n    });\n\n    // create Todos with this.options.destroyEvent\n    new Todos( '#todos', { destroyEvent: 'mouseenter' } );\n\nValues inside `{NAME}` are looked up on the control's `this.options` first,\nand then the `window`. For example, we could customize it instead like:\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n      \n      'li click': function( li ) { ... },\n  \n      'li .destroy {Events.destroy}': function( el, ev ) { \n        // previous destroy code here\n      }\n    });\n\n    // Events config\n    Events = { destroy: 'click' };\n\n    // Events.destroy is looked up on the window.\n    new Todos( '#todos' );\n\nThe selector can also be templated.\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n      \n      '{listElement} click': function( li ) { ... },\n      \n      '{listElement} .destroy {destroyEvent}': function( el, ev ) { \n        // previous destroy code here\n      }\n    });\n\n    // create Todos with this.options.destroyEvent\n    new Todos( '#todos',  { \n      destroyEvent: 'mouseenter', \n      listElement: 'li' \n    } );\n\n### Templated Event Handlers Part 2 `\"{objectName}\"`\n\nControl can also bind to objects other than `this.element` with\ntemplated event handlers.  This is _critical_\nfor avoiding memory leaks that are so common among MVC applications.  \n\nIf the value inside `{NAME}` is an object, Control will bind to that\nobject to listen for events. For example, the following tooltip listens to \nclicks on the window:\n\n    var Tooltip = Control.extend({\n      '{window} click': function( el, ev ) {\n        // hide only if we clicked outside the tooltip\n        if ( !this.element.has( ev.target ) ) {\n          this.element.remove();\n        }\n      }\n    });\n\n    // create a Tooltip\n    new Tooltip( $( '<div>INFO</div>' ).appendTo( el ) );\n    \nThis is convenient when listening for model changes. If EJS were not\ntaking care of removing `<li>`s after their associated models were destroyed,\nwe could implement it in `Todos` like:\n\n    var Todos = Control.extend({\n      init: function( element, options ) {...},\n      \n      'li click': function( li ) {...},\n      \n      'li .destroy click': function( el, ev ) {\n        // get the li element that has todo data\n        var li = el.closest( 'li' );\n      \n        // get the model\n        var todo = li.data( 'todo' );\n  \n        //destroy it\n        todo.destroy();\n      },\n      \n      '{Todo} destroyed': function( Todo, ev, todoDestroyed ) {\n        // find where the element\n        var index = this.todosList.indexOf( todoDestroyed );\n        this.element.children( ':nth-child(' + ( index + 1 ) + ')' )\n                    .remove();\n      }\n    });\n\n    new Todos( '#todos' );\n\n### `on()`\n\n[can-control::on] rebinds a control's event handlers. This is useful when you want\nto listen to a specific model and change it:\n\n    var Editor = Control.extend({\n      todo: function( todo ) {\n        this.options.todo = todo;\n        this.on();\n        this.setName();\n      },\n      \n      // a helper that sets the value of the input\n      // to the todo's name\n      setName: function() {\n        this.element.val( this.options.todo.name );\n      },\n      \n      // listen for changes in the todo\n      // and update the input\n      '{todo} updated': function() {\n        this.setName();\n      },\n\n      // when the input changes\n      // update the todo instance\n      'change': function() {\n        var todo = this.options.todo;\n        todo.attr( 'name', this.element.val() );\n        todo.save();\n      }\n    });\n\n    var todo1 = new Todo({ id: 6, name: 'trash' }),\n        todo2 = new Todo({ id: 6, name: 'dishes' });\n\n    // create the editor;\n    var editor = new Editor( '#editor' );\n\n    // show the first todo\n    editor.todo( todo1 );\n\n    // switch it to the second todo\n    editor.todo( todo2 );\n    \n\n## Destroying a control\n\n[can-control::destroy] unbinds a control's\nevent handlers and releases its element, but does not remove \nthe element from the page. \n\n    var todo = new Todos( '#todos' );\n    todo.destroy();\n\nWhen a control's element is removed from the page\n__destroy__ is called automatically.\n\n    new Todos( '#todos' );\n    $( '#todos' ).remove();\n    \nAll event handlers bound with Control are unbound when the control \nis destroyed (or its element is removed).\n\n_Brief aside on destroy and templated event binding. Taken \ntogether, templated event binding, and control's automatic\nclean-up make it almost impossible \nto write leaking applications. An application that uses\nonly templated event handlers on controls within the body\ncould free up all \ndata by calling `$(document.body).empty()`._\n\n## Tabs Example\n\nHere is an example of how to build a simple tab widget using Control:\n\n<iframe style=\"width: 100%; height: 300px\"\n        src=\"http://jsfiddle.net/donejs/kXLLt/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n",
    "description": "Create organized, memory-leak free, rapidly performing, stateful controls with declarative event binding. Use `Control` to create UI \ncontrols like tabs, grids, and context menus,\nand organize them into higher-order business rules with\n[can.route]. It can serve as both a traditional view and a traditional controller.\n\n",
    "type": "module",
    "title": "can-control",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "name": "can-control",
    "parent": "can-legacy",
    "download": "can/route",
    "test": [
      "can/route/test.html",
      "can/control/test.html"
    ],
    "inherits": "can",
    "link": "../docco/control/control.html docco",
    "signatures": [
      {
        "code": "Control( [staticProperties,] instanceProperties )",
        "description": "\n\nCreate a new, extended, control constructor \nfunction. This functionality is inherited from [can-construct] and is deprecated in favor of using \n[can-control.extend]. \n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "An object of properties and methods that are added the control constructor \nfunction directly. The most common property to add is [can-control.defaults].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"click\"` or `\"li mouseenter\"`) are setup\nas event handlers (see [Listening to events](#section_Listeningtoevents)).\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "constructs": {
                "types": [
                  {
                    "type": "can.Construct"
                  }
                ]
              },
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "element"
                    }
                  ]
                },
                {
                  "types": [
                    {
                      "type": "options"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n\n"
        }
      },
      {
        "code": "new Control( element, options )",
        "description": "\n\nCreate an instance of a control. [can.Control.prototype.setup] processes\nthe arguments and sets up event binding. Write your initialization\ncode in [can.Control.prototype.init]. Note, you never call `new Control()` directly,\ninstead, you call it on constructor functions extended from `Control`.\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "can-view-nodelist"
              },
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "element",
            "description": "Specifies the element the control will be created on.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Option values merged with [can-control.defaults Control.defaults]\nand set as [can-control::options this.options].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-control"
            }
          ],
          "description": "A new instance of the constructor function extending Control.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-control"
        }
      ],
      "description": "A new instance of the constructor function extending Control.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Option values merged with [can-control.defaults Control.defaults]\nand set as [can-control::options this.options].\n"
    },
    "comment": " "
  },
  "can-control.prototype.on": {
    "src": {
      "path": "node_modules/can-control/docs/on.md"
    },
    "body": "`this.on()` is used to rebind\nall event handlers when [can-control::options this.options] has changed.  It\ncan also be used to bind or delegate from other elements or objects.\n\n## Rebinding\n\nBy using templated event handlers, a control can listen to objects outside\n`this.element`.  This is extremely common in MVC programming.  For example,\nthe following control might listen to a task model's `completed` property and\ntoggle a strike className like:\n\n\tTaskStriker = Control({\n\t\t\"{task} completed\": function(){\n\t\t\tthis.update();\n\t\t},\n\t\tupdate: function(){\n\t\t\tif ( this.options.task.completed ) {\n\t\t\t\tthis.element.addClass( 'strike' );\n\t\t\t} else {\n\t\t\t\tthis.element.removeClass( 'strike' );\n\t\t\t}\n\t\t}\n\t});\n\n\tvar taskstriker = new TaskStriker({\n\t\ttask: new Task({ completed: 'true' })\n\t});\n\nTo update the `taskstriker`'s task, add a task method that updates\nthis.options and rebinds the event handlers for the new task like:\n\n\tTaskStriker = Control({\n\t\t\"{task} completed\": function(){\n\t\t\tthis.update();\n\t\t},\n\t\tupdate: function() {\n\t\t\tif ( this.options.task.completed ) {\n\t\t\t\tthis.element.addClass( 'strike' );\n\t\t\t} else {\n\t\t\t\tthis.element.removeClass( 'strike' );\n\t\t\t}\n\t\t},\n\t\ttask: function( newTask ) {\n\t\t\t\tthis.options.task = newTask;\n\t\t\t\tthis.on();\n\t\t\t\tthis.update();\n\t\t}\n\t});\n\n\tvar taskstriker = new TaskStriker({\n\t\ttask: new Task({ completed: true })\n\t});\n\n\t// Now, add a new task that is not yet completed\n\ttaskstriker.task(new Task({ completed: false }));\n\n## Adding new events\n\nIf events need to be bound to outside of the control and templated event handlers\nare not sufficient, you can call this.on to bind or delegate programmatically:\n\n\tinit: function() {\n\t\t// calls somethingClicked( el, ev )\n\t\tthis.on( 'click', 'somethingClicked' );\n\n\t\t// calls function when the window is clicked\n\t\tthis.on( window, 'click', function( ev ) {\n\t\t\t// do something\n\t\t});\n\t},\n\t\tsomethingClicked: function( el, ev ) {\n\t\t // ...\n\t}\n\n",
    "description": "Bind an event handler to a Control, or rebind all event handlers on a Control. \n",
    "title": "on",
    "name": "can-control.prototype.on",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.on([el,] selector, eventName, func)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "jQuery"
              },
              {
                "type": "collection"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "el",
            "defaultValue": "this.element",
            "description": "\nThe element to be bound.  If no element is provided, the control's element is used instead."
          },
          {
            "types": [
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "selector",
            "description": "A CSS selector for event delegation."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              },
              {
                "type": "String"
              }
            ],
            "name": "func",
            "description": "A callback function or the String name of a control function.  If a control\nfunction name is given, the control function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The id of the binding in this._bindings.\n\n`on(el, selector, eventName, func)` binds an event handler for an event to a selector under the scope of the given element.\n"
        }
      },
      {
        "code": "control.on()",
        "description": "\n\nRebind all of a control's event handlers.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of handlers bound to this Control.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of handlers bound to this Control.\n"
    },
    "comment": " "
  },
  "can-control.prototype.element": {
    "src": {
      "path": "node_modules/can-control/docs/element.md"
    },
    "body": "\nThe control instance's HTMLElement (or window) wrapped by the\nutil library for ease of use.\n\nIt is set by the first parameter to `new Construct( element, options )`\nin [can.Control::setup].  By default, a control listens to events on `this.element`.\n\n### Example - NodeList\n\nThe following `HelloWorld` control sets the control`s text to \"Hello World\":\n\n\tHelloWorld = Control({\n\t\tinit: function(){\n\t\t\tthis.element.text( 'Hello World' );\n\t\t}\n\t});\n\n\t// create the controller on the element\n\tnew HelloWorld( document.getElementById( '#helloworld' ) );\n\n## Wrapped NodeList\n\n`this.element` is a wrapped NodeList of one HTMLELement (or window).  This\nis for convenience in libraries like jQuery where all methods operate only on a\nNodeList.  To get the raw HTMLElement, write:\n\n\tthis.element[0] //-> HTMLElement\n\nThe following details the NodeList used by each library with\nan example of updating its text:\n\n__jQuery__ `jQuery( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Zepto__ `Zepto( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Dojo__ `new dojo.NodeList( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Mootools__ `$$( HTMLElement )`\n\n this.element.empty().appendText(\"Hello World\")\n\n__YUI__\n\n this.element.set(\"text\", \"Hello World\")\n\n## Changing `this.element`\n\nSometimes you don't want what's passed to `new Control`\nto be `this.element`.  You can change this by overwriting\nsetup or by unbinding, setting this.element, and rebinding.\n\n### Overwriting Setup\n\nThe following Combobox overwrites setup to wrap a\nselect element with a div.  That div is used\nas `this.element`. Notice how `destroy` sets back the\noriginal element.\n\n\tCombobox = Control({\n\t\tsetup: function( el, options ) {\n\t\t\tthis.oldElement = $( el );\n\t\t\tvar newEl = $( '<div/>' );\n\t\t\tthis.oldElement.wrap( newEl );\n\t\t\tcan.Control.prototype.setup.call( this, newEl, options );\n\t\t},\n\t\tinit: function() {\n\t\t\tthis.element //-> the div\n\t\t},\n\t\t\".option click\": function() {\n\t\t\t// event handler bound on the div\n\t\t},\n\t\tdestroy: function() {\n\t\t\tvar div = this.element; //save reference\n\t\t\tControl.prototype.destroy.call( this );\n\t\t\tdiv.replaceWith( this.oldElement );\n\t\t}\n\t});\n\n### Unbinding, setting, and rebinding.\n\nYou could also change this.element by calling\n[can.Control::off], setting this.element, and\nthen calling [can.Control::on] like:\n\n\tmove: function( newElement ) {\n\t\tthis.off();\n\t\tthis.element = $( newElement );\n\t\tthis.on();\n\t}\n\n",
    "description": "The element passed to the Control when creating a new instance. \n",
    "types": [
      {
        "type": "can-view-nodeList"
      }
    ],
    "title": "element",
    "name": "can-control.prototype.element",
    "type": "property",
    "parent": "can-control.prototype",
    "comment": " "
  },
  "can-control.eventHandler": {
    "src": {
      "path": "node_modules/can-control/docs/eventHandler.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "eventHandler(element, event)",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-control.eventHandler",
    "parent": "can-control.types",
    "signatures": [
      {
        "code": "function(element, event)",
        "description": "\n\n",
        "params": []
      }
    ]
  },
  "can-control.eventDescription": {
    "src": {
      "path": "node_modules/can-control/docs/eventDescription.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "eventDescription",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-control.eventDescription",
    "parent": "can-control.types",
    "signatures": [
      {
        "code": "\"[CONTEXT ][SELECTOR ]EVENTNAME\"",
        "description": "\n\n",
        "params": []
      }
    ]
  },
  "can-control.processors": {
    "src": {
      "path": "node_modules/can-control/docs/processors.md"
    },
    "body": "\n`processors` is an object that allows you to add new events to bind\nto on a control, or to change how existent events are bound. Each\nkey-value pair of `processors` is a specification that pertains to\nan event where the key is the name of the event, and the value is\na function that processes calls to bind to the event.\n\nThe processor function takes five arguments:\n\n- _el_: The Control's element.\n- _event_: The event type.\n- _selector_: The selector preceding the event in the binding used on the Control.\n- _callback_: The callback function being bound.\n- _control_: The Control the event is bound on.\n\nInside your processor function, you should bind _callback_ to the event, and\nreturn a function for can.Control to call when _callback_ needs to be unbound.\n(If _selector_ is defined, you will likely want to use some form of delegation\nto bind the event.)\n\nHere is a Control with a custom event processor set and two callbacks bound\nto that event:\n\n\tControl.processors.birthday = function(el, ev, selector, callback, control) {\n\tif(selector) {\n\t myFramework.delegate(ev, el, selector, callback);\n\t return function() { myFramework.undelegate(ev, el, selector, callback); };\n\t} else {\n\t myFramework.bind(ev, el, callback);\n\t return function() { myFramework.unbind(ev, el, callback); };\n\t}\n\t};\n\n\tControl(\"EventTarget\", { }, {\n\t'birthday': function(el, ev) {\n\t // do something appropriate for the occasion\n\t},\n\t'.grandchild birthday': function(el, ev) {\n\t // do something appropriate for the occasion\n\t}\n\t});\n\n\tvar target = new EventTarget('#person');\n\nWhen `target` is initialized, can.Control will call `Control.processors.birthday`\ntwice (because there are two event hookups for the _birthday_ event). The first\ntime it's called, the arguments will be:\n\n- _el_: A NodeList that wraps the element with id 'person'.\n- _ev_: `'birthday'`\n- _selector_: `''`\n- _callback_: The function assigned to `' birthday'` in the prototype section of `EventTarget`'s\ndefinition.\n- _control_: `target` itself.\n\nThe second time, the arguments are slightly different:\n\n- _el_: A NodeList that wraps the element with id 'person'.\n- _ev_: `'birthday'`\n- _selector_: `'.grandchild'`\n- _callback_: The function assigned to `'.grandchild birthday'` in the prototype section of `EventTarget`'s\ndefinition.\n- _control_: `target` itself.\n\nControl already has processors for these events:\n\n- change\n- click\n- contextmenu\n- dblclick\n- focusin\n- focusout\n- keydown\n- keyup\n- keypress\n- mousedown\n- mouseenter\n- mouseleave\n- mousemove\n- mouseout\n- mouseover\n- mouseup\n- reset\n- resize\n- scroll\n- select\n- submit\n\n",
    "description": "A collection of hookups for custom events on Controls. ",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "can-control.processor"
              }
            ]
          }
        ]
      }
    ],
    "title": "processors",
    "name": "can-control.processors",
    "type": "property",
    "parent": "can-control.static",
    "comment": " "
  },
  "can-control.prototype.options": {
    "src": {
      "path": "node_modules/can-control/docs/options.md"
    },
    "body": "\nThe `this.options` property is an Object that contains\nconfiguration data passed to a control when it is\ncreated (`new Control(element, options)`).\n\nIn the following example, an options object with\na message is passed to a `Greeting` control. The\n`Greeting` control changes the text of its [can-control::element element]\nto the options' message value.\n\n\tvar Greeting = Control.extend({\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message )\n\t\t}\n\t});\n\n\tnew Greeting(\"#greeting\",{message: \"I understand this.options\"});\n\nThe options argument passed when creating the control\nis merged with [can-control.defaults defaults] in\n[can-control.prototype.setup setup].\n\nIn the following example, if no message property is provided,\nthe defaults' message property is used.\n\n\tvar Greeting = Control.extend({\n\t\tdefaults: {\n\t\t\tmessage: \"Defaults merged into this.options\"\n\t\t}\n\t},{\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message )\n\t\t}\n\t});\n\n\tnew Greeting(\"#greeting\");\n\n",
    "description": "Options used to configure a control. \n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "options",
    "name": "can-control.prototype.options",
    "type": "property",
    "parent": "can-control.prototype",
    "comment": " "
  },
  "can-control.prototype.setup": {
    "src": {
      "path": "node_modules/can-control/docs/setup.md"
    },
    "body": "\n## Lifecycle of `setup`\n\nSetup, when called, does the following:\n\n### Sets this.element\n\nThe first parameter passed to new Control( el, options ) is expected to be\nan element.  This gets converted to a Wrapped NodeList element and set as\n[can-control.prototype.element this.element].\n\n### Adds the control's name to the element's className\n\nControl adds it's plugin name to the element's className for easier\ndebugging.  For example, if your Control is named \"Foo.Bar\", it adds\n\"foo_bar\" to the className.\n\n### Saves the control in $.data\n\nA reference to the control instance is saved in $.data.  You can find\ninstances of \"Foo.Bar\" like:\n\n\t$( '#el' ).data( 'controls' )[ 'foo_bar' ]\n\n### Merges Options\n\nMerges the default options with optional user-supplied ones.\nAdditionally, default values are exposed in the static [can-control.static.defaults defaults]\nso that users can change them.\n\n### Binds event handlers\n\nSetup does the event binding described in [can-control].\n\n",
    "description": "Perform pre-initialization logic for control instances and classes.  \n",
    "title": "setup",
    "name": "can-control.prototype.setup",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.setup(element, options)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "NodeList"
              },
              {
                "type": "String"
              }
            ],
            "name": "element",
            "description": "The element as passed to the constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "options",
            "description": "option values for the control.  These get added to\nthis.options and merged with [can-control.static.defaults defaults]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "undefined"
            },
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "options",
      "description": "option values for the control.  These get added to\nthis.options and merged with [can-control.static.defaults defaults]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.\n"
    },
    "comment": " "
  },
  "can-define.types": {
    "src": {
      "path": "node_modules/can-define/docs/define.types.md"
    },
    "body": "\n",
    "description": "Defines the type, initial value, and get, set, and serialize behavior for an\nobservable property. All type converters leave `null` and `undefined` as is except for\nthe `\"boolean\"` type converter.\n",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "observable",
            "description": "The default type behavior. It converts plain Objects to\n[can-define/map/map DefineMaps] and plain Arrays to [can-define/list/list DefineLists]. Everything else is left as is.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "any",
            "description": "Leaves the set value as is, performs no type conversion. Aliased as `*`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "string",
            "description": "Converts to a string with `\"\"+val`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "date",
            "description": "Converts to a JavaScript date using `Date.parse(val)` if a string is given or `new Date(val)` if a number is passed.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "number",
            "description": "Converts to a number with `+(val)`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "boolean",
            "description": "Converts to `false` if `val` is falsey, `\"0\"`, or `\"false\"`; otherwise, converts to `true`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "htmlbool",
            "description": "Like `boolean`, but converts to `true` if empty string (`\"\"`) is passed.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "compute",
            "description": "Allows computes to be passed and the property take on the value of the compute.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "stringOrObservable",
            "description": "Converts plain Objects to [can-define/map/map DefineMaps], plain Arrays to [can-define/list/list DefineLists] and everything else to strings.  This is useful for routing.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "title": "types",
    "name": "can-define.types",
    "type": "property",
    "parent": "can-define"
  },
  "can-define": {
    "src": {
      "path": "node_modules/can-define/docs/define.md"
    },
    "body": "",
    "description": "Exports the `can.define` method that defines observable properties and their behavior.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define",
    "parent": "can-core",
    "signatures": [
      {
        "code": "can.define(prototype, propDefinitions)",
        "description": "\n\nDefine observable properties, type conversion, and getter/setter logic to your constructor prototypes.\n\n```js\nvar Person = function(first, last){\n  this.first = first;\n  this.last = last;\n};\ncan.define(Person.prototype,{\n  first: {\n    type: \"string\"\n  },\n  last: {\n    type: \"string\"\n  },\n  fullName: {\n    get: function(){\n      return this.first+\" \"+this.last;\n    }\n  }\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "prototype",
            "description": "The prototype object of a constructor function.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "propDefinitions",
            "description": "An object of\nproperties and their definitions.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "propDefinitions",
      "description": "An object of\nproperties and their definitions.\n"
    }
  },
  "can-define.types.propDefinition": {
    "src": {
      "path": "node_modules/can-define/docs/types.propDefinition.md"
    },
    "body": "\n",
    "description": "\nDefines the type, initial value, and get, set, and serialize behavior for an\nobservable property.\n",
    "type": "typedef",
    "title": "propDefinition",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "value",
            "description": "Specifies the initial value of the property or\na function that returns the initial value.\n\n```js\n// A default age of `0`:\nvar Person = DefineMap.extend({\n  age: {value: 0}    \n});\n\nnew Person().age //-> 0\n```\n\n`Object` types should not be specified directly on `value` because that same object will\nbe shared on every instance of the Map.  Instead, a function that returns a fresh copy should be provided:\n\n```js\n// A default address object:\nvar Person = DefineMap.extend({\n  address: {\n    value: function(){\n      return {city: \"Chicago\", state: \"IL\"};\n    };\n  }    \n});\n\nnew Person().address //-> {city: \"Chicago\", state: \"IL\"};\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              },
              {
                "type": "*"
              }
            ]
          },
          {
            "name": "Value",
            "description": "Specifies a function that will be called with `new` whose result is\nset as the initial value of the attribute.\n\n```js\n// A default empty DefineList of hobbies:\nvar Person = DefineMap.extend({\n  hobbies: {Value: DefineList}\n});\n\nnew Person().hobbies //-> []\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "type",
            "description": "Specifies the type of the\nproperty.  The type can be specified as either a function\nthat returns the type coerced value or one of the [can-define.types] names.\n\n```js\nvar Person = DefineMap.extend({\n  age: {type: \"number\"},\n  hobbies: {\n    type: function(newValue){\n      if(typeof newValue === \"string\") {\n        return newValue.split(\",\")\n      } else if( Array.isArray(newValue) ) {\n        return newValue;\n      }\n    }\n  }\n});\n\nvar me = new Person({age: \"33\", hobbies: \"bball,js\"})\nme.age //-> 33\nme.hobbies //-> [\"bball\",\"js\"]\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              },
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "Type",
            "description": "A constructor function that takes\nthe value passed to [can.Map::attr attr] as the first argument and called with\nnew. For example, if you want whatever\ngets passed to go through `new Array(newValue)` you can do that like:\n\n```js\ndefine: {\n  items: {\n    Type: Array\n  }\n}\n```\n\nIf the value passed to [can.Map::attr attr] is already an Array, it will be left as is.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "set",
            "description": "A set function that specifies what should happen when an attribute\nis set on a [can.Map]. `set` is called with the result of `type` or `Type`. The following\ndefines a `page` setter that updates the map's offset:\n\n```js\ndefine: {\n  page: {\n    set: function(newVal){\n      this.attr('offset', (parseInt(newVal) - 1) *\n                           this.attr('limit'));\n    }\n  }\n}\n```\n",
            "types": [
              {
                "type": "can.Map.prototype.define.set"
              }
            ]
          },
          {
            "name": "get",
            "description": "A function that specifies how the value is retrieved.  The get function is\nconverted to an [can.compute.async async compute].  It should derive its value from other values\non the map. The following\ndefines a `page` getter that reads from a map's offset and limit:\n\n```js\ndefine: {\n  page: {\n    get: function (newVal) {\n\t  return Math.floor(this.attr('offset') /\n\t                    this.attr('limit')) + 1;\n\t}\n  }\n}\n```\n\nA `get` definition makes the property __computed__ which means it will not be serialized by default.\n",
            "types": [
              {
                "type": "can-define.types.get"
              }
            ]
          },
          {
            "name": "serialize",
            "description": "Specifies the behavior of the\nproperty when [can.Map::serialize serialize] is called.\n\nBy default, serialize does not include computed values. Properties with a `get` definition\nare computed and therefore are not added to the result.  Non-computed properties values are\nserialized if possible and added to the result.\n\n```js\nPaginate = can.Map.extend({\n  define: {\n    pageNum: {\n      get: function(){ return this.offset() / 20 }\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-> {offset: 40}\n```\n\nIf `true` is specified, computed properties will be serialized and added to the result.\n\n```js\nPaginate = can.Map.extend({\n  define: {\n    pageNum: {\n      get: function(){ return this.offset() / 20 },\n      serialize: true\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-> {offset: 40, pageNum: 2}\n```\n\nIf `false` is specified, non-computed properties will not be added to the result.\n\n```js\nPaginate = can.Map.extend({\n  define: {\n    offset: {\n      serialize: false\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-> {}\n```\n\nIf a [can.Map.prototype.define.serialize serialize function] is specified, the result\nof the function is added to the result.\n\n```js\nPaginate = can.Map.extend({\n  define: {\n    offset: {\n      serialize: function(offset){\n        return (offset / 20)+1\n      }\n    }\n  }\n});\n\np = new Paginate({offset: 40});\np.serialize() //-> {offset: 3}\n```\n",
            "types": [
              {
                "type": "can.Map.prototype.define.serialize"
              },
              {
                "type": "Boolean"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-define.types.propDefinition",
    "parent": "can-define.types"
  },
  "can-define.types.get": {
    "src": {
      "path": "node_modules/can-define/docs/types.get.md"
    },
    "body": "\n\n\n## Use\n\nGetter methods are useful for:\n\n - Defining virtual properties on a map.\n - Defining property values that change with their _internal_ set value.\n\n## Virtual properties\n\n\nVirtual properties are properties that don't actually store any value, but derive their value\nfrom some other properties on the map.\n\nWhenever a getter is provided, it is wrapped in a [can.compute], which ensures\nthat whenever its dependent properties change, a change event will fire for this property also.\n\n```\nvar Person = can.Model.extend({\n\tdefine: {\n\t\tfullName: {\n\t\t\tget: function () {\n\t\t\t\treturn this.attr(\"first\") + \" \" + this.attr(\"last\");\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar p = new Person({first: \"Justin\", last: \"Meyer\"});\n\np.attr(\"fullName\"); // \"Justin Meyer\"\n\np.bind(\"fullName\", function(ev, newVal){\n  newVal //-> \"Lincoln Meyer\";\n});\n\np.attr(\"first\",\"Lincoln\");\n```\n\n## Asyncronous virtual properties\n\nOften, a virtual property's value only becomes available after some period of time.  For example,\ngiven a `personId`, one might want to retrieve a related person:\n\n```\nvar AppState = can.Map.extend({\n  define: {\n    person: {\n      get: function(lastSetValue, setAttrValue){\n        Person.findOne({id: this.attr(\"personId\")})\n        \t.then(function(person){\n        \t\tsetAttrValue(person);\n        \t});\n      }\n    }\n  }\n});\n```\n\nAsyncronous properties should be bound to before reading their value.  If\nthey are not bound to, the `get` function will be called each time.\n\nThe following example will make multiple `Person.findOne` requests:\n\n```\nvar state = new AppState({personId: 5});\nstate.attr(\"person\") //-> undefined\n\n// called sometime later ...\nstate.attr(\"person\") //-> undefined\n```\n\nHowever, by binding, the compute only reruns the `get` function once `personId` changes:\n\n```\nvar state = new AppState({personId: 5});\n\nstate.bind(\"person\", function(){})\n\nstate.attr(\"person\") //-> undefined\n\n// called sometime later\nstate.attr(\"person\") //-> Person<{id: 5}>\n```\n\nA template like [can.stache] will automatically bind for you, so you can pass\n`state` to the template like the following without binding:\n\n```\nvar template = can.stache(\"<span>{{person.fullName}}</span>\");\nvar state = new AppState({});\nvar frag = template(state);\n\nstate.attr(\"personId\",5);\nfrag.childNodes[0].innerHTML //=> \"\"\n\n// sometime later\nfrag.childNodes[0].innerHTML //=> \"Lincoln Meyer\"\n\n```\n\nThe magic tags are updated as `personId`, `person`, and `fullName` change.\n\n\n## Properties values that change with their _internal_ set value\n\nA getter can be used to derive a value from a set value. A getter's\n`lastSetValue` argument is the last value set by [can.Map::attr].\n\nFor example, a property might be set to a compute, but when read, provides the value\nof the compute.\n\n```\nvar MyMap = can.Map.extend({\n  define: {\n    value: {\n      get: function( lastSetValue ){\n        return lastSetValue();\n      }\n    }\n  }\n});\n\nvar map = new MyMap();\nvar compute = can.compute(1);\nmap.attr(\"value\", compute);\n\nmap.attr(\"value\") //-> 1\ncompute(2);\nmap.attr(\"value\") //-> 2\n```\n\nThis technique should only be used when the `lastSetValue` is some form of\nobservable, that when it changes, can update the `getter` value.\n\nFor simple conversions, [can.Map.prototype.define.set] or [can.Map.prototype.define.type] should be used.\n\n## Updating the virtual property value\n\nIt's very common (and better performing) to update the virtual property value\ninstead of replacing it.\n\nThe following example creates an empty `locationIds` [can.List] when a new\ninstance of `Store` is created.  However, as `locations` change,\nthe [can.List] will be updated with the `id`s of the `locations`.\n\n\n```\nvar Store = can.Map.extend({\n\tdefine: {\n\t\tlocationIds: {\n\t\t\tValue: can.List,\n\t\t\tget: function(initialValue){\n\t\t\t\tvar ids = [];\n\t\t\t\tthis.attr('locations').each(function(location){\n\t\t\t\t\tids.push(location.attr(\"id\"));\n\t\t\t\t});\n\t\t\t\treturn initialValue.replace(ids);\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n",
    "description": "\nSpecify what happens when a certain property is read on a map. `get` functions\nwork like a [can.compute] and automatically update themselves when a dependent\nobservable value is changed.\n",
    "title": "get",
    "name": "can-define.types.get",
    "type": "function",
    "parent": "can.Map.prototype.define",
    "signatures": [
      {
        "code": "get( [lastSetValue] )",
        "description": "\n\n  Defines the behavior when a value is read on a [can.Map]. Used to provide properties that derive their value from\n  other properties of the map, or __update__ their value from\n  the changes in the value that was set.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The value last set by `.attr(property, value)`.  Typically, _lastSetValue_\nshould be an observable value, like a [can.compute] or promise. If it's not, it's likely\nthat a [can.Map.prototype.define.set define.set] should be used instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property.\n"
        }
      },
      {
        "code": "get( lastSetValue, setAttrValue(value) )",
        "description": "\n\n  Asynchronously defines the behavior when a value is read on a [can.Map]. Used to provide property values that\n  are available asynchronously.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "lastSetValue",
            "description": "The value last set by `.attr(property, value)`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "value"
                  }
                ]
              }
            ],
            "name": "setAttrValue",
            "description": "Updates the value of the property. This can be called\nmultiple times if needed.\n"
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of the property.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "value"
            }
          ]
        }
      ],
      "name": "setAttrValue",
      "description": "Updates the value of the property. This can be called\nmultiple times if needed.\n"
    },
    "comment": " "
  },
  "can-define/map/map.prototype.get": {
    "type": "function",
    "name": "can-define/map/map.prototype.get",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 161,
      "codeLine": 169,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Get a value that was not predefined. \n",
    "title": "get",
    "signatures": [
      {
        "code": "map.get(propName)",
        "description": "\n    ",
        "params": []
      }
    ]
  },
  "can-define/map/map.prototype.set": {
    "type": "function",
    "name": "can-define/map/map.prototype.set",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 173,
      "codeLine": 181,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Set a value that was not predefined. \n",
    "title": "set",
    "signatures": [
      {
        "code": "map.set(propName, value)",
        "description": "\n    ",
        "params": []
      }
    ]
  },
  "can-define/map/map.prototype.serialize": {
    "type": "function",
    "name": "can-define/map/map.prototype.serialize",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 191,
      "codeLine": 199,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Get a value that was not predefined. \n",
    "title": "serialize",
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n    ",
        "params": []
      }
    ]
  },
  "can-define/map/map.prototype.toObject": {
    "type": "function",
    "name": "can-define/map/map.prototype.toObject",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 202,
      "codeLine": 210,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Get a value that was not predefined. \n",
    "title": "toObject",
    "signatures": [
      {
        "code": "map.toObject()",
        "description": "\n    ",
        "params": []
      }
    ]
  },
  "can-define/map/map.prototype.each": {
    "type": "function",
    "name": "can-define/map/map.prototype.each",
    "parent": "can-define/map/map.prototype",
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.each.md"
    },
    "body": "\n```\nvar names = [];\nnew can.Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n    names.push(value);\n});\n\nnames; // ['Alice', 'Bob', 'Eve']\n\nnames = [];\nnew can.Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n    names.push(value);\n    if(key === 'b') {\n        return false;\n    }\n});\n\nnames; // ['Alice', 'Bob']\n```\n\n",
    "description": "Call a function on each property of a Map. \n",
    "title": "each",
    "signatures": [
      {
        "code": "map.each( callback(item, propName ) )",
        "description": "\n\n`each` iterates through the Map, calling a function\nfor each property value and key.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "propName"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "item"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "propName"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "comment": " "
  },
  "can.batch.start": {
    "type": "function",
    "name": "can.batch.start",
    "parent": "can.batch",
    "src": {
      "line": 15,
      "codeLine": 113,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "`can.batch.start` causes can.Map to begin an event batch. Until `[can.batch.stop]` is called, any\nevents that would result from calls to `[can.Map::attr attr]` are held back from firing. If you have\nlots of changes to make to can.Maps, batching them together can help performance &emdash; especially if\nthose can.Maps are live-bound to the DOM.\n\nIn this example, you can see how the _first_ and _change_ events are not fired (and their handlers\nare not called) until `can.batch.stop` is called.\n\n```\nvar person = new can.Map({\n    first: 'Alexis',\n    last: 'Abril'\n});\n\nperson.bind('first', function() {\n    console.log(\"First name changed.\"\");\n}).bind('change', function() {\n    console.log(\"Something changed.\");\n});\n\ncan.batch.start();\nperson.attr('first', 'Alex');\nconsole.log('Still in the batch.');\ncan.batch.stop();\n\n// the log has:\n// Still in the batch.\n// First name changed.\n// Something changed.\n```\n\nYou can also pass a callback to `can.batch.start` which will be called after all the events have\nbeen fired:\n```\ncan.batch.start(function() {\n    console.log('The batch is over.');\n});\nperson.attr('first', 'Izzy');\nconsole.log('Still in the batch.');\ncan.batch.stop();\n\n// The console has:\n// Still in the batch.\n// First name changed.\n// Something changed.\n// The batch is over.\n```\n\n## Calling `can.batch.start` multiple times\n\nIf you call `can.batch.start` more than once, `can.batch.stop` needs to be called\nthe same number of times before any batched events will fire. For ways\nto circumvent this process, see [can.batch.stop].\n\nHere is an example that demonstrates how events are affected by calling\n`can.batch.start` multiple times.\n\n```\nvar addPeople = function(observable) {\n    can.batch.start();\n    observable.attr('a', 'Alice');\n    observable.attr('b', 'Bob');\n    observable.attr('e', 'Eve');\n    can.batch.stop();\n};\n\n// In a completely different place:\nvar list = new can.Map();\nlist.bind('change', function() {\n    console.log('The list changed.');\n});\n\ncan.batch.start();\naddPeople(list);\nconsole.log('Still in the batch.');\n\n// Here, the console has:\n// Still in the batch.\n\ncan.batch.stop();\n\n// Here, the console has:\n// Still in the batch.\n// The list changed.\n// The list changed.\n// The list changed.\n```\n \n",
    "description": "Begin an event batch. \n",
    "title": "",
    "signatures": [
      {
        "code": "can.batch.start([batchStopHandler])",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "batchStopHandler",
            "description": "a callback that gets called after all batched events have been called\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "batchStopHandler",
      "description": "a callback that gets called after all batched events have been called\n"
    },
    "comment": " "
  },
  "can.batch.stop": {
    "type": "function",
    "name": "can.batch.stop",
    "parent": "can.batch",
    "src": {
      "line": 129,
      "codeLine": 178,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "`can.batch.stop` matches an earlier `[can.batch.start]` call. If `can.batch.stop` has been\ncalled as many times as `can.batch.start` (or if _force_ is true), all batched events will be\nfired and any callbacks passed to `can.batch.start` since the beginning of the batch will be\ncalled. If _force and _callStart_ are both true, a new batch will be started when all\nthe events and callbacks have been fired.\n\nSee `[can.batch.start]` for examples of `can.batch.start` and `can.batch.stop` in normal use.\n\nIn this example, the batch is forceably ended in the `addPeople` function.\n```\nvar addPeople = function(observable) {\n    can.batch.start();\n    observable.attr('a', 'Alice');\n    observable.attr('b', 'Bob');\n    observable.attr('e', 'Eve');\n    can.batch.stop(true);\n};\n\n// In a completely different place:\nvar list = new can.Map();\nlist.bind('change', function() {\n    console.log('The list changed.');\n});\n\ncan.batch.start();\naddPeople(list);\nconsole.log('Still in the batch.');\n\n// Here, the console has:\n// Still in the batch.\n\ncan.batch.stop();\n\n// Here, the console has:\n// The list changed.\n// The list changed.\n// The list changed.\n// Still in the batch.\n```\n \n",
    "description": "End an event batch. ",
    "title": "",
    "signatures": [
      {
        "code": "can.batch.stop([force[, callStart]])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "force",
            "defaultValue": "false",
            "description": "whether to stop batching events immediately"
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "callStart",
            "defaultValue": "false",
            "description": "whether to call `[can.batch.start can.batch.start]` after firing batched events\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "callStart",
      "defaultValue": "false",
      "description": "whether to call `[can.batch.start can.batch.start]` after firing batched events\n"
    },
    "comment": " "
  },
  "can.batch.trigger": {
    "type": "function",
    "name": "can.batch.trigger",
    "parent": "can.batch",
    "src": {
      "line": 221,
      "codeLine": 235,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "If events are currently being batched, calling `can.batch.trigger` adds an event\nto the batch. If events are not currently being batched, the event is triggered\nimmediately.\n \n",
    "description": "Trigger an event to be added to the current batch. ",
    "title": "",
    "signatures": [
      {
        "code": "can.batch.trigger(item, event [, args])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "can.Map"
              }
            ],
            "name": "item",
            "description": "the target of the event"
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": [
                  {
                    "name": "type",
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "event",
            "description": "the type of event, or an event object with a type given"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "the parameters to trigger the event with.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "args",
      "description": "the parameters to trigger the event with.\n"
    },
    "comment": " "
  },
  "can.util.bind": {
    "src": {
      "line": 1,
      "codeLine": 9,
      "path": "node_modules/can-event/lifecycle/lifecycle.js"
    },
    "type": "typedef",
    "body": "\n\n",
    "description": "\nProvides mixin-able bind and unbind methods. `bind()` calls `this._bindsetup`\nwhen the first bind happens and.  `unbind()` calls `this._bindteardown` when there\nare no more event handlers.\n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "bind",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "unbind",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can.util.bind"
  },
  "fixture.types.Store.findOne": {
    "type": "function",
    "name": "fixture.types.Store.findOne",
    "parent": "fixture.types.Store",
    "src": {
      "line": 161,
      "codeLine": 180,
      "path": "node_modules/can-fixture/helpers/legacyStore.js"
    },
    "body": "`store.findOne(request, response(item))` simulates a request to\nget a single item from the server by id.\n\n    todosStore.findOne({\n      url: \"/todos/5\"\n    }, function(todo){\n\n    });\n\n\t \n",
    "description": "Simulate a findOne request on a fixture. ",
    "title": "",
    "signatures": [
      {
        "code": "store.findOne(request, response)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "request",
            "description": "Parameters for the request."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "response",
            "description": "A function to call with the retrieved item.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "response",
      "description": "A function to call with the retrieved item.\n"
    },
    "comment": " "
  },
  "fixture.types.Store.destroy": {
    "type": "function",
    "name": "fixture.types.Store.destroy",
    "parent": "fixture.types.Store",
    "src": {
      "line": 208,
      "codeLine": 226,
      "path": "node_modules/can-fixture/helpers/legacyStore.js"
    },
    "body": "`store.destroy(request, response())` simulates\na request to destroy an item from the server.\n\n```\ntodosStore.destroy({\n  url: \"/todos/5\"\n}, function(){});\n```\n\t \n",
    "description": "Simulate destroying a Model on a fixture. ",
    "title": "",
    "signatures": [
      {
        "code": "store.destroy(request, callback)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "request",
            "description": "Parameters for the request."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "callback",
            "description": "A function to call after destruction.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "callback",
      "description": "A function to call after destruction.\n"
    },
    "comment": " "
  },
  "can-list.Map": {
    "src": {
      "path": "node_modules/can-list/docs/Map.md"
    },
    "body": "",
    "description": "Specify the Map type used to make objects added to this list observable. \n",
    "types": [
      {
        "type": "can-map",
        "description": "When objects are added to a `List`, those objects are converted into can.Map instances. For example:\n\n     var list = new List();\n     list.push({name: \"Justin\"});\n\n     var map = list.attr(0);\n     map.attr(\"name\") //-> \"Justin\"\n\nBy changing [can-list.Map], you can specify a different type of Map instance to create. For example:\n\n     var User = Map.extend({\n       fullName: function(){\n         return this.attr(\"first\")+\" \"+this.attr(\"last\")\n       }\n     });\n\n     User.List = List.extend({\n       Map: User\n     }, {});\n\n     var list = new User.List();\n     list.push({first: \"Justin\", last: \"Meyer\"});\n\n     var user = list.attr(0);\n     user.fullName() //-> \"Justin Meyer\"\n"
      }
    ],
    "title": "Map",
    "name": "can-list.Map",
    "type": "property",
    "parent": "can-list.static"
  },
  "can-list.extend": {
    "src": {
      "path": "node_modules/can-list/docs/extend.md"
    },
    "body": "",
    "description": "\n",
    "title": "extend",
    "name": "can-list.extend",
    "type": "function",
    "parent": "can-list.static",
    "signatures": [
      {
        "code": "List.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function. Learn more at [can.Construct.extend].\n\n```js\nvar MyList = List.extend({}, {\n\t// silly unnecessary method\n\tcount: function(){\n\t\treturn this.attr('length');\n\t}\n});\n\nvar list = new MyList([{}, {}]);\nconsole.log(list.count()); // -> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "If provided, adds the extened List constructor function to the window at the given name.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties and methods directly on the constructor function. The most common property to set is [can-list.Map].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "instanceProperties",
            "description": "Properties and methods on instances of this list type.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "instanceProperties",
      "description": "Properties and methods on instances of this list type.\n"
    }
  },
  "can-list.prototype": {
    "name": "can-list.prototype",
    "title": "Prototype",
    "type": "group",
    "parent": "can-list",
    "description": "",
    "order": 0
  },
  "can-list.static": {
    "name": "can-list.static",
    "title": "Static",
    "type": "group",
    "parent": "can-list",
    "description": "",
    "order": 1
  },
  "can-list.prototype.filter": {
    "src": {
      "path": "node_modules/can-list/docs/filter.md"
    },
    "body": "\nA filter function that accepts a function, which is run on every element of the list.  If the \nfilter callback returns true, the list returned will contain this item, false and it will not.\n\nReturns a new List instance.\n\t\n\tvar list = new List([1, 2, 3])\n\n\t// returns new List([1, 2])\n\tvar filtered = list.filter( function(item, index, list)\n\t{\n\t\treturn item < 3;\n\t}); \n\n",
    "description": "Filter the elements of a List, returning a new List instance with just filtered items. \n",
    "title": "filter",
    "name": "can-list.prototype.filter",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.filter(filterFunc, context)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "Boolean"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can.List"
                      }
                    ],
                    "name": "list"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "filterFunc",
            "description": "A function to call with each element of the list. Returning `false` will remove the index."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "The object to use as `this` inside the callback.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "context",
      "description": "The object to use as `this` inside the callback.\n"
    },
    "comment": " "
  },
  "can-list.prototype.attr": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.attr.md"
    },
    "body": "\n\n## Use\n\n`attr` gets or sets elements on the `List` it's called on. Here's a tour through how all of its forms work:\n\n     var people = new List(['Alex', 'Bill']);\n\n     // set an element:\n     people.attr(0, 'Adam');\n\n     // get an element:\n     people.attr(0); // 'Adam'\n     people[0]; // 'Adam'\n\n     // get all elements:\n     people.attr(); // ['Adam', 'Bill']\n\n     // extend the array:\n     people.attr(4, 'Charlie');\n     people.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n     // merge the elements:\n     people.attr(['Alice', 'Bob', 'Eve']);\n     people.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']\n\n## Deep properties\n\n`attr` can also set and read deep properties. All you have to do is specify the property name as you normally would if you weren't using `attr`.\n\n```\nvar people = new List([{name: 'Alex'}, {name: 'Bob'}]);\n\n// set a property:\npeople.attr('0.name', 'Alice');\n\n// get a property:\npeople.attr('0.name');  // 'Alice'\npeople[0].attr('name'); // 'Alice'\n\n// get all properties:\npeople.attr(); // [{name: 'Alice'}, {name: 'Bob'}]\n```\n\nThe discussion of deep properties under `[can-map.prototype.attr]` may also be enlightening.\n\n## Events\n\n`List`s emit five types of events in response to changes. They are:\n\n- the _change_ event fires on every change to a List.\n- the _set_ event is fired when an element is set.\n- the _add_ event is fired when an element is added to the List.\n- the _remove_ event is fired when an element is removed from the List.\n- the _length_ event is fired when the length of the List changes.\n\n### The _change_ event\n\nThe first event that is fired is the _change_ event. The _change_ event is useful\nif you want to react to all changes on an List.\n\n```\nvar list = new List([]);\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log('Something changed.');\n});\n```\n\nThe parameters of the event handler for the _change_ event are:\n\n- _ev_ The event object.\n- _index_ Where the change took place.\n- _how_ Whether elements were added, removed, or set.\n Possible values are `'add'`, `'remove'`, or `'set'`.\n- _newVal_ The elements affected after the change\n _newVal_ will be a single value when an index is set, an Array when elements\nwere added, and `undefined` if elements were removed.\n- _oldVal_ The elements affected before the change.\n_newVal_ will be a single value when an index is set, an Array when elements\nwere removed, and `undefined` if elements were added.\n\nHere is a concrete tour through the _change_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\nlist.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined\nlist.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined\nlist.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis\nlist.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam\n                               // [object Object], 1, set, Bob, Bill\nlist.removeAttr(1);            // [object Object], 1, remove, undefined, Bob\n```\n\n### The _set_ event\n\n_set_ events are fired when an element at an index that already exists in the List is modified. Actions can cause _set_ events to fire never also cause _length_ events to fire (although some functions, such as `[can-list.prototype.splice splice]` may cause unrelated sets of events to fire after being batched).\n\nThe parameters of the event handler for the _set_ event are:\n\n- _ev_ The event object.\n- _newVal_ The new value of the element.\n- _index_ where the set took place.\n\nHere is a concrete tour through the _set_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('set', function(ev, newVal, index) {\n    console.log(newVal + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');\nlist.attr(0, 'Adam');          // Adam, 0\nlist.attr(['Alice', 'Bob']);   // Alice, 0\n                               // Bob, 1\nlist.removeAttr(1);\n```\n\n### The _add_ event\n\n_add_ events are fired when elements are added or inserted\ninto the List.\n\nThe parameters of the event handler for the _add_ event are:\n\n- _ev_ The event object.\n- _newElements_ The new elements.\n If more than one element is added, _newElements_ will be an array. Otherwise, it is simply the new element itself.\n- _index_ Where the add or insert took place.\n\nHere is a concrete tour through the _add_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('add', function(ev, newElements, index) {\n    console.log(newElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0\nlist.attr(2, 'Eve');           // Eve, 2\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);\n```\n\n### The _remove_ event\n\n_remove_ events are fired when elements are removed from the list.\n\nThe parameters of the event handler for the _remove_ event are:\n\n- _ev_ The event object.\n- _removedElements_ The removed elements.\n If more than one element was removed, _removedElements_ will be an array. Otherwise, it is simply the element itself.\n- _index_ Where the removal took place.\n\nHere is a concrete tour through the _remove_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('remove', function(ev, removedElements, index) {\n    console.log(removedElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);            // Bob, 1\n```\n\n### The _length_ event\n\n_length_ events are fired whenever the list changes.\n\nThe parameters of the event handler for the _length_ event are:\n\n- _ev_ The event object.\n- _length_ The current length of the list.\n If events were batched when the _length_ event was triggered, _length_ will have the length of the list when `stopBatch` was called. Because of this, you may receive multiple _length_ events with the same _length_ parameter.\n\nHere is a concrete tour through the _length_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('length', function(ev, length) {\n    console.log(length);\n});\n\nlist.attr(['Alexis', 'Bill']); // 2\nlist.attr(2, 'Eve');           // 3\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);            // 2\n```\n\n",
    "description": "Get or set elements in a List. \n",
    "title": "attr",
    "name": "can-list.prototype.attr",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.attr()",
        "description": "\n\nGets an array of all the elements in this `List`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "An array with all the elements in this List.\n"
        }
      },
      {
        "code": "list.attr(index)",
        "description": "\n\nReads an element from this `List`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The element to read."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at _index_.\n"
        }
      },
      {
        "code": "list.attr(index, value)",
        "description": "\n\nAssigns _value_ to the index _index_ on this `List`, expanding the list if necessary.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The element to set."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign at _index_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      },
      {
        "code": "list.attr(elements[, replaceCompletely])",
        "description": "\n\nMerges the members of _elements_ into this List, replacing each from the beginning in order. If _elements_ is longer than the current List, the current List will be expanded. If _elements_ is shorter than the current List, the extra existing members are not affected (unless _replaceCompletely_ is `true`). To remove elements without replacing them, use `[can-map::removeAttr removeAttr]`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "elements",
            "description": "An array of elements to merge in.\n"
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "replaceCompletely",
            "defaultValue": "false",
            "description": "whether to completely replace the elements of List\n\nIf _replaceCompletely_ is `true` and _elements_ is shorter than the List, the existing extra members of the List will be removed.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "This list, for chaining.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "replaceCompletely",
      "defaultValue": "false",
      "description": "whether to completely replace the elements of List\n\nIf _replaceCompletely_ is `true` and _elements_ is shorter than the List, the existing extra members of the List will be removed.\n"
    },
    "comment": " "
  },
  "can-list.prototype.each": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.each.md"
    },
    "body": "```\nvar i = 0;\nnew List([1, 10, 100]).each(function(element, index) {\n    i += element;\n});\n\ni; // 111\n\ni = 0;\nnew List([1, 10, 100]).each(function(element, index) {\n    i += element;\n    if(index >= 1) {\n        return false;\n    }\n});\n\ni; // 11\n```\n\n",
    "description": "Call a function on each element of a List. ",
    "name": "can-list.prototype.each",
    "title": "each",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.each( callback(item, index) )",
        "description": "\n\n`each` iterates through the List, calling a function\nfor each element.\n\n```js\nvar list = new List([1, 2, 3]);\n\nlist.each(function(elem){\n\tconsole.log(elem);\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "this List, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "this List, for chaining\n"
    },
    "comment": " "
  },
  "can-list.prototype.map": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.map.md"
    },
    "body": "```\nvar list = new List([1, 10, 100, 1000, 10000, 100000]);\nvar newList = list.map(function(element, index, listReference) {\n  var result;\n\n  switch(index) {\n    case 0: {\n      result = false;\n      break;\n    }\n    case 1: {\n      result = undefined;\n      break;\n    }\n    case 2: {\n      result = element;\n      break;\n    }\n    case 3: {\n      result = element * 5;\n      break;\n    }\n    default: {\n      result = listReference[index] /= 2;\n      break;\n    }\n  }\n\n  return result;\n});\n\nconsole.log(list);    // [    1,        10, 100, 1000, 5000, 50000]\nconsole.log(newList); // [false, undefined, 100, 5000, 5000, 50000]\n```\n\n",
    "description": "Call a function on each element of a List and return a new List instance from the results. ",
    "title": "map",
    "name": "can-list.prototype.map",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.map( callback(item, index, listReference), context )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can.List"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each\nelement of the list."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "An optional object to use as `this` inside the callback.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "A new can.List instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "context",
      "description": "An optional object to use as `this` inside the callback.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "A new can.List instance.\n"
    },
    "comment": " "
  },
  "can-list.prototype.reverse": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.reverse.md"
    },
    "body": "```\nvar list = new List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n\n`reverse` calls `replace` internally and triggers corresponding `add`, `remove`, `change` and `length` events respectively.\n\n## Demo\n\n<div class='iframe_wrapper' data-iframe-src='can/list/doc/reverse.html' data-iframe-height='350'></div>\n",
    "description": "Reverse the order of a List. ",
    "title": "reverse",
    "name": "can-list.prototype.reverse",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\n`reverse` reverses the elements of the List in place.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "the List, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-list"
        }
      ],
      "description": "the List, for chaining\n"
    },
    "comment": " "
  },
  "can-list.prototype.splice": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.splice.md"
    },
    "body": " `splice` lets you remove elements from and insert elements into a List.\n\n This example demonstrates how to do surgery on a list of numbers:\n\n```\n var list = new List([0, 1, 2, 3]);\n\n // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n list.splice(2, 1, 'Alice', 'Bob');\n list.attr(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n ## Events\n\n `splice` causes the List it's called on to emit _change_ events,\n _add_ events, _remove_ events, and _length_ events. If there are\n any elements to remove, a _change_ event, a _remove_ event, and a\n _length_ event will be fired. If there are any elements to insert, a\n separate _change_ event, an _add_ event, and a separate _length_ event\n will be fired.\n\n This slightly-modified version of the above example should help\n make it clear how `splice` causes events to be emitted:\n\n```\n var list = new List(['a', 'b', 'c', 'd']);\n list.bind('change', function(ev, attr, how, newVals, oldVals) {\n     console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n });\n list.bind('add', function(ev, newVals, where) {\n     console.log('add: ' + newVals + ', ' + where);\n });\n list.bind('remove', function(ev, oldVals, where) {\n     console.log('remove: ' + oldVals + ', ' + where);\n });\n list.bind('length', function(ev, length) {\n     console.log('length: ' + length + ', ' + this.attr());\n });\n\n // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n list.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                    // remove: ['c'], 2\n                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                    // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                    // add: ['Alice', 'Bob'], 2\n                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n```\n\n More information about binding to these events can be found under [can.List.attr attr].\n\n",
    "description": "Insert and remove elements from a List. ",
    "title": "splice",
    "name": "can-list.prototype.splice",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newElements]])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "where to start removing or inserting elements\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "the number of elements to remove\n If _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the List.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newElements",
            "description": "elements to insert into the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the elements removed by `splice`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newElements",
      "description": "elements to insert into the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the elements removed by `splice`\n"
    },
    "comment": " "
  },
  "can-map.prototype": {
    "name": "can-map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-map",
    "description": "",
    "order": 0
  },
  "can-map.static": {
    "name": "can-map.static",
    "title": "static",
    "type": "group",
    "parent": "can-map",
    "description": "",
    "order": 1
  },
  "can-map.prototype.attr": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.attr.md"
    },
    "body": "`attr` gets or sets properties on the `Map` it's called on. Here's a tour through\nhow all of its forms work:\n\n\n    var people = new Map({});\n\n    // set a property:\n    people.attr('a', 'Alex');\n\n    // get a property:\n    people.attr('a'); // 'Alex'\n\n    // set and merge multiple properties:\n    people.attr({\n        a: 'Alice',\n        b: 'Bob'\n    });\n\n    // get all properties:\n    people.attr(); // {a: 'Alice', b: 'Bob'}\n\n    // set properties while removing others:\n    people.attr({\n        b: 'Bill',\n        e: 'Eve'\n    }, true);\n\n    people.attr(); // {b: 'Bill', e: 'Eve'}\n\n\n## Deep properties\n\n`attr` can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using `attr`.\n\n\n    var people = new Map({names: {}});\n\n    // set a property:\n    people.attr('names.a', 'Alice');\n\n    // get a property:\n    people.attr('names.a'); // 'Alice'\n    people.names.attr('a'); // 'Alice'\n\n    // get all properties:\n    people.attr(); // {names: {a: 'Alice'}}\n\n\nObjects that are added to Observes become Observes themselves behind the scenes,\nso changes to deep properties fire events at each level, and you can bind at any\nlevel. As this example shows, all the same events are fired no matter what level\nyou call `attr` at:\n\n\n    var people = new Map({names: {}});\n\n    people.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    people.names.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    people.bind('names', function(ev, newVal, oldVal) {\n        console.log('people names: ' + newVal + ', ' + oldVal);\n    });\n\n    people.names.bind('a', function(ev, newVal, oldVal) {\n        console.log('people.names a: ' + newVal + ', ' + oldVal);\n    });\n\n    people.bind('names.a', function(ev, newVal, oldVal) {\n        console.log('people names.a: ' + newVal + ', ' + oldVal);\n    });\n\n    people.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined\n                                  // people.names change: a, add, Alice, undefined\n                                  // people.names a: Alice, undefined\n                                  // people names.a: Alice, undefined\n\n    people.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined\n                                  // people.names change: b, add, Bob, undefined\n                                  // people.names b: Bob, undefined\n                                  // people names.b: Bob, undefined\n\n\n## Properties with dots in their name\n\nAs shown above, `attr` enables reading and setting deep properties so special care must be taken when property names include dots '`.`'. To read a property containing dots, escape each one using '`\\`'. This prevents `attr` from performing a deep lookup and throwing an error when the deep property is not found.\n\n```\nvar person = new Map({\n\t'first.name': 'Alice'\n});\n\nperson.attr('first.name'); // throws Error\nperson.attr('first\\.name'); // 'Alice'\n\n```\n\nWhen setting a property containing dots, pass an object to `attr` containing the property name and new value. Setting a property by passing a string to `attr` will attempt to set a deep property and will throw an error.\n\n```\nvar person = new Map({\n\t'first.name': 'Alice'\n});\n\nperson.attr('first.name', 'Bob'); // throws Error\nperson.attr('first\\.name', 'Bob'); // throws Error\nperson.attr({'first.name': 'Bob'}); // Works\n\n```\n\n## See also\n\nFor information on the events that are fired on property changes and how\nto listen for those events, see [can.Map.prototype.bind bind].\n\n",
    "description": "Get or set properties on a Map. \n",
    "title": "attr",
    "name": "can-map.prototype.attr",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 2,
    "signatures": [
      {
        "code": "map.attr()",
        "description": "\n\nGets a collection of all the properties in this `Map`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with all the properties in this `Map`.\n"
        }
      },
      {
        "code": "map.attr(key)",
        "description": "\n\nReads a property from this `Map`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the property to read"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value assigned to _key_.\n"
        }
      },
      {
        "code": "map.attr(key, value)",
        "description": "\n\nAssigns _value_ to a property on this `Map` called _key_.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the property to set"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "the",
            "description": "value to assign to _key_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      },
      {
        "code": "map.attr(obj[, removeOthers])",
        "description": "\n\nAssigns each value in _obj_ to a property on this `Map` named after the\ncorresponding key in _obj_, effectively merging _obj_ into the Map.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "a collection of key-value pairs to set.\nIf any properties already exist on the `Map`, they will be overwritten.\n"
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "removeOthers",
            "defaultValue": "false",
            "description": "whether to remove keys not present in _obj_.\nTo remove keys without setting other keys, use `[can.Map::removeAttr removeAttr]`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "removeOthers",
      "defaultValue": "false",
      "description": "whether to remove keys not present in _obj_.\nTo remove keys without setting other keys, use `[can.Map::removeAttr removeAttr]`.\n"
    },
    "comment": " "
  },
  "can-map.prototype.compute": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.compute.md"
    },
    "body": "\n`compute` is a convenience method for making computes from properties\nof Observes. More information about computes can be found under [can.compute].\n\n\n    var map = new Map({a: 'Alexis'});\n    var name = map.compute('a');\n    name.bind('change', function(ev, nevVal, oldVal) {\n        console.log('a changed from ' + oldVal + 'to' + newName + '.');\n    });\n\n    name(); // 'Alexis'\n\n    map.attr('a', 'Adam'); // 'a changed from Alexis to Adam.'\n    name(); // 'Adam'\n\n    name('Alice'); // 'a changed from Adam to Alice.'\n    name(); // 'Alice'\n\n",
    "description": "Make a can.compute from an observable property. \n",
    "title": "compute",
    "name": "can-map.prototype.compute",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 4,
    "signatures": [
      {
        "code": "map.compute(attrName)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "the property to bind to"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "a [can-compute] bound to _attrName_\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "the property to bind to"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "a [can-compute] bound to _attrName_\n"
    },
    "comment": " "
  },
  "can-map.prototype.bind": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.bind.md"
    },
    "body": "`bind` binds event handlers to property changes on `Map`s. When you change\na property using `attr`, two events are fired on the Map, allowing other parts\nof your application to map the changes to the object.\n\n## The _change_ event\n\nThe first event that is fired is the _change_ event. The _change_ event is useful\nif you want to react to all changes on a Map.\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('Something changed.');\n    });\n\n\nThe parameters of the event handler for the _change_ event are:\n\n- _ev_ The event object.\n- _attr_ Which property changed.\n- _how_ Whether the property was added, removed, or set. Possible values are `'add'`, `'remove'`, or `'set'`.\n- _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n- _oldVal_ This is the value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\nHere is a concrete tour through the _change_ event handler's arguments:\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log(ev + ', ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    o.attr('a', 'Alexis'); // [object Object], a, add, Alexis, undefined\n    o.attr('a', 'Adam');   // [object Object], a, set, Adam, Alexis\n    o.attr({\n        'a': 'Alice',      // [object Object], a, set, Alice, Adam\n        'b': 'Bob'         // [object Object], b, add, Bob, undefined\n    });\n    o.removeAttr('a');     // [object Object], a, remove, undefined, Alice\n\n\n(See also `[can.Map::removeAttr removeAttr]`, which removes properties).\n\n## The _property name_ event\n\nThe second event that is fired is an event whose type is the same as the changed\nproperty's name. This event is useful for noticing changes to a specific property.\n\n\n    var o = new Map({});\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log('The value of a changed.');\n    });\n\n\nThe parameters of the event handler for the _property name_ event are:\n\n- _ev_ The event object.\n- _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n- _oldVal_ The value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\nHere is a concrete tour through the _property name_ event handler's arguments:\n\n\n    var o = new Map({});\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log(ev + ', ' + newVal + ', ' + oldVal);\n    });\n\n    o.attr('a', 'Alexis'); // [object Object], Alexis, undefined\n    o.attr('a', 'Adam');   // [object Object], Adam, Alexis\n    o.attr({\n        'a': 'Alice',      // [object Object], Alice, Adam\n        'b': 'Bob'\n    });\n    o.removeAttr('a');     // [object Object], undefined, Alice\n\n\n## See also\n\nMore information about changing properties on Observes can be found under\n[can.Map.prototype.attr attr].\n\nFor a more specific way to changes on Observes, see the [can.Map.delegate] plugin.\n*/\n\n",
    "description": "Bind event handlers to a Map. \n",
    "title": "bind",
    "name": "can-map.prototype.bind",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 3,
    "signatures": [
      {
        "code": "map.bind(eventType, handler)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "the type of event to bind this handler to"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "comment": " "
  },
  "can-map.prototype.DEFAULT-ATTR": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.default-attr.md"
    },
    "body": "\n## Use\n\nWhen extending [can-map], if a prototype property is not a function,\nit is used as a default value on instances of the extended Map.  For example:\n\n```\nvar Paginate = Map.extend({\n    limit: 20,\n    offset: 0,\n    next: function(){\n        this.attr(\"offset\", this.attr(\"offset\")+this.attr(\"limit\"))\n    }\n});\n\nvar paginate = new Paginate({limit: 30});\n\npaginate.attr(\"offset\") //-> 0\npaginate.attr(\"limit\")  //-> 30\n\npaginate.next();\n\npaginate.attr(\"offset\") //-> 30\n```\n\n",
    "description": "Specify a default property and value. \n",
    "types": [
      {
        "type": "*",
        "description": "A value of any type other than a function that will\nbe set as the `DEFAULT-ATTR` attribute's value.\n"
      }
    ],
    "title": "DEFAULT-ATTR",
    "name": "can-map.prototype.DEFAULT-ATTR",
    "type": "property",
    "parent": "can-map.prototype",
    "order": 1,
    "comment": " "
  },
  "can-map.prototype.removeAttr": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.removeAttr.md"
    },
    "body": "`removeAttr` removes a property by name from a Map.\n\n\n    var people = new Map({a: 'Alice', b: 'Bob', e: 'Eve'});\n\n    people.removeAttr('b'); // 'Bob'\n    people.attr();          // {a: 'Alice', e: 'Eve'}\n\n\nRemoving an attribute will cause a _change_ event to fire with `'remove'`\npassed as the _how_ parameter and `undefined` passed as the _newVal_ to\nhandlers. It will also cause a _property name_ event to fire with `undefined`\npassed as _newVal_. An in-depth description at these events can be found\nunder `[can-map.prototype.attr attr]`.\n\n",
    "description": "Remove a property from a Map. \n",
    "title": "removeAttr",
    "name": "can-map.prototype.removeAttr",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 6,
    "signatures": [
      {
        "code": "map.removeAttr(attrName)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "the name of the property to remove"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value of the property that was removed\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "the name of the property to remove"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value of the property that was removed\n"
    },
    "comment": " "
  },
  "can-map.prototype.each": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.each.md"
    },
    "body": "\n    var names = [];\n    new Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n        names.push(value);\n    });\n\n    names; // ['Alice', 'Bob', 'Eve']\n\n    names = [];\n    new Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n        names.push(value);\n        if(key === 'b') {\n            return false;\n        }\n    });\n\n    names; // ['Alice', 'Bob']\n    \n\n",
    "description": "Call a function on each property of a Map. \n",
    "title": "each",
    "name": "can-map.prototype.each",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 5,
    "signatures": [
      {
        "code": "map.each( callback(item, propName ) )",
        "description": "\n\n`each` iterates through the Map, calling a function\nfor each property value and key.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "propName"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "item"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "propName"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "comment": " "
  },
  "can-map.prototype.serialize": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.serialize.md"
    },
    "body": "",
    "description": "Serialize this object to something that can be passed to `JSON.stringify`. \n",
    "title": "serialize",
    "name": "can-map.prototype.serialize",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 7,
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n\nGet the serialized Object form of the map.  Serialized\ndata is typically used to send back to a server.\n\n\n    o.serialize() //-> { name: 'Justin' }\n\n\nSerialize currently returns the same data\nas [can.Map.prototype.attrs].  However, in future\nversions, serialize will be able to return serialized\ndata similar to [can.Model].  The following will work:\n\n\n    new Map({time: new Date()})\n        .serialize() //-> { time: 1319666613663 }\n\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a JavaScript Object that can be\nserialized with `JSON.stringify` or other methods.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a JavaScript Object that can be\nserialized with `JSON.stringify` or other methods.\n"
    }
  },
  "can-map.prototype.unbind": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.unbind.md"
    },
    "body": "`unbind` unbinds event handlers previously bound with [can-map.prototype.bind bind].\nIf no _handler_ is passed, all handlers for the given event type will be unbound.\n\n\n    var i = 0,\n        increaseBy2 = function() { i += 2; },\n        increaseBy3 = function() { i += 3; },\n        o = new Map();\n\n    o.bind('change', increaseBy2);\n    o.bind('change', increaseBy3);\n    o.attr('a', 'Alice');\n    i; // 5\n\n    o.unbind('change', increaseBy2);\n    o.attr('b', 'Bob');\n    i; // 8\n\n    o.unbind('change');\n    o.attr('e', 'Eve');\n    i; // 8\n\n",
    "description": "Unbind event handlers from a Map. \n",
    "title": "unbind",
    "name": "can-map.prototype.unbind",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 8,
    "signatures": [
      {
        "code": "map.unbind(eventType[, handler])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "the type of event to unbind, exactly as passed to `bind`"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "handler",
            "description": "the handler to unbind\n\n```js\nvar map = new Map({ a: 1 });\n\nfunction log(){\n\tconsole.log(\"val\", map.attr(\"a\");\n}\n\nmap.bind(\"change\", log);\n\nmap.attr(\"a\", 2);\n\n// Bind callback called.\nmap.unbind(\"change\", log);\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "handler",
      "description": "the handler to unbind\n\n```js\nvar map = new Map({ a: 1 });\n\nfunction log(){\n\tconsole.log(\"val\", map.attr(\"a\");\n}\n\nmap.bind(\"change\", log);\n\nmap.attr(\"a\", 2);\n\n// Bind callback called.\nmap.unbind(\"change\", log);\n```\n"
    },
    "comment": " "
  },
  "can-map.keys": {
    "src": {
      "path": "node_modules/can-map/docs/static.keys.md"
    },
    "body": "",
    "description": "Returns an array of the map's keys. \n",
    "title": "keys",
    "name": "can-map.keys",
    "type": "function",
    "parent": "can-map.static",
    "order": 0,
    "signatures": [
      {
        "code": "Map.keys(map)",
        "description": "\n\n```js\nvar people = new Map({\n\t\ta: 'Alice',\n\t\tb: 'Bob',\n\t\te: 'Eve'\n});\n\nMap.keys(people); // ['a', 'b', 'e']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-map"
              }
            ],
            "name": "map",
            "description": "the `Map` to get the keys from"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "array An array containing the keys from _map_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "name": "map",
      "description": "the `Map` to get the keys from"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "array An array containing the keys from _map_.\n"
    }
  },
  "can-define/list/list": {
    "name": "can-define/list/list",
    "type": "module",
    "src": {
      "path": "node_modules/can-define/list/docs/define-list.md"
    },
    "body": "\n",
    "description": "Create observable list. \n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-core",
    "alias": "can.DefineMap",
    "inherits": "can.Construct",
    "signatures": [
      {
        "code": "new can.DefineList([items])",
        "description": "\n",
        "params": []
      }
    ]
  },
  "can-define/list/list.static": {
    "src": {
      "line": 34,
      "codeLine": 35,
      "path": "node_modules/can-define/list/list.js"
    },
    "type": "static",
    "body": "",
    "description": "",
    "name": "can-define/list/list.static",
    "parent": "can-define/list/list",
    "title": "static"
  },
  "can-define/list/list.prototype": {
    "src": {
      "line": 56,
      "codeLine": 57,
      "path": "node_modules/can-define/list/list.js"
    },
    "type": "prototype",
    "body": "",
    "description": "",
    "name": "can-define/list/list.prototype",
    "parent": "can-define/list/list",
    "title": "prototype"
  },
  "can-define/list/list.prototype.item": {
    "type": "function",
    "name": "can-define/list/list.prototype.item",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 93,
      "codeLine": 101,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "",
    "description": "Get a value that was not predefined. \n",
    "title": "item",
    "signatures": [
      {
        "code": "map.item(index, [newVal])",
        "description": "\n    ",
        "params": []
      }
    ]
  },
  "can-define/list/list.prototype.items": {
    "type": "function",
    "name": "can-define/list/list.prototype.items",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 109,
      "codeLine": 117,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "",
    "description": "Get a value that was not predefined. \n",
    "title": "items",
    "signatures": [
      {
        "code": "map.items()",
        "description": "\n    ",
        "params": []
      }
    ]
  },
  "can-define/list/list.prototype.each": {
    "src": {
      "line": 160,
      "codeLine": 200,
      "path": "node_modules/can-define/list/list.js"
    },
    "type": "function",
    "body": "```\nvar i = 0;\nnew can.Map([1, 10, 100]).each(function(element, index) {\n    i += element;\n});\n\ni; // 111\n\ni = 0;\nnew can.Map([1, 10, 100]).each(function(element, index) {\n    i += element;\n    if(index >= 1) {\n        return false;\n    }\n});\n\ni; // 11\n```\n    \n",
    "description": "Call a function on each element of a DefineList. \n",
    "title": "each",
    "name": "can-define/list/list.prototype.each",
    "parent": "can-define/list/list.prototype",
    "signatures": [
      {
        "code": "list.each( callback(item, index) )",
        "description": "\n\n`each` iterates through the Map, calling a function\nfor each element.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.DefineList"
            }
          ],
          "description": "this DefineList, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.DefineList"
        }
      ],
      "description": "this DefineList, for chaining\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.splice": {
    "type": "function",
    "name": "can-define/list/list.prototype.splice",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 200,
      "codeLine": 264,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "`splice` lets you remove elements from and insert elements into a DefineList.\n\nThis example demonstrates how to do surgery on a list of numbers:\n\n```\nvar list = new can.DefineList([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.attr(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n## Events\n\n`splice` causes the DefineList it's called on to emit _change_ events,\n_add_ events, _remove_ events, and _length_ events. If there are\nany elements to remove, a _change_ event, a _remove_ event, and a\n_length_ event will be fired. If there are any elements to insert, a\nseparate _change_ event, an _add_ event, and a separate _length_ event\nwill be fired.\n\nThis slightly-modified version of the above example should help\nmake it clear how `splice` causes events to be emitted:\n\n```\nvar list = new can.DefineList(['a', 'b', 'c', 'd']);\nlist.bind('change', function(ev, attr, how, newVals, oldVals) {\n    console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\nlist.bind('add', function(ev, newVals, where) {\n    console.log('add: ' + newVals + ', ' + where);\n});\nlist.bind('remove', function(ev, oldVals, where) {\n    console.log('remove: ' + oldVals + ', ' + where);\n});\nlist.bind('length', function(ev, length) {\n    console.log('length: ' + length + ', ' + this.attr());\n});\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                   // remove: ['c'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                   // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                   // add: ['Alice', 'Bob'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n```\n\nMore information about binding to these events can be found under [can.DefineList.attr attr].\n    \n",
    "description": "Insert and remove elements from a DefineList. ",
    "title": "splice",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newElements]])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "where to start removing or inserting elements\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "the number of elements to remove\nIf _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the DefineList.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newElements",
            "description": "elements to insert into the DefineList\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the elements removed by `splice`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newElements",
      "description": "elements to insert into the DefineList\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the elements removed by `splice`\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.push": {
    "name": "can-define/list/list.prototype.push",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 358,
      "codeLine": 399,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "`push` adds elements onto the end of a DefineList here is an example:\n\n```\nvar list = new can.DefineList(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\nIf you have an array you want to concatenate to the end\nof the DefineList, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new can.DefineList(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\n## Events\n\n`push` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`push` has a counterpart in [can.DefineList::pop pop], or you may be\nlooking for [can.DefineList::unshift unshift] and its counterpart [can.DefineList::shift shift].\n    \n",
    "description": "Add elements to the end of a list. ",
    "title": "push",
    "signatures": [
      {
        "code": "list.push(...elements)",
        "description": "\n\n`push` adds elements onto the end of a DefineList.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the DefineList\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the DefineList\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the DefineList\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the DefineList\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.unshift": {
    "name": "can-define/list/list.prototype.unshift",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 400,
      "codeLine": 441,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "`unshift` adds elements to the front of the list in bulk in the order specified:\n\n```\nvar list = new can.DefineList(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\nIf you have an array you want to concatenate to the beginning\nof the DefineList, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new can.DefineList(['Alice']);\n\nlist.unshift.apply(list, names);\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\n## Events\n\n`unshift` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`unshift` has a counterpart in [can.DefineList::shift shift], or you may be\nlooking for [can.DefineList::push push] and its counterpart [can.DefineList::pop pop].\n    \n",
    "description": "Add elements to the beginning of a DefineList. ",
    "title": "unshift",
    "signatures": [
      {
        "code": "list.unshift(...elements)",
        "description": "\n\n`unshift` adds elements onto the beginning of a DefineList.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the DefineList\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the DefineList\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the DefineList\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the DefineList\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.pop": {
    "name": "can-define/list/list.prototype.pop",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 475,
      "codeLine": 507,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "`pop` is the opposite action from `[can.DefineList.push push]`:\n\n```\nvar list = new can.DefineList(['Alice', 'Bob', 'Eve']);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the DefineList is not empty\nwhen it is called.\n\n## See also\n\n`pop` has its counterpart in [can.DefineList::push push], or you may be\nlooking for [can.DefineList::unshift unshift] and its counterpart [can.DefineList::shift shift].\n    \n",
    "description": "Remove an element from the end of a DefineList. ",
    "title": "pop",
    "signatures": [
      {
        "code": "list.pop()",
        "description": "\n\n`pop` removes an element from the end of a DefineList.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just popped off the DefineList, or `undefined` if the DefineList was empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just popped off the DefineList, or `undefined` if the DefineList was empty\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.shift": {
    "name": "can-define/list/list.prototype.shift",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 508,
      "codeLine": 542,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "`shift` is the opposite action from `[can.DefineList::unshift unshift]`:\n\n```\nvar list = new can.DefineList(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n\nlist.shift(); // 'Bob'\nlist.shift(); // 'Eve'\nlist.shift(); // 'Alice'\nlist.shift(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the DefineList is not empty\nwhen it is called.\n\n## See also\n\n`shift` has a counterpart in [can.DefineList::unshift unshift], or you may be\nlooking for [can.DefineList::push push] and its counterpart [can.DefineList::pop pop].\n    \n",
    "description": "Remove en element from the front of a list. ",
    "title": "shift",
    "signatures": [
      {
        "code": "list.shift()",
        "description": "\n\n`shift` removes an element from the beginning of a DefineList.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just shifted off the DefineList, or `undefined` if the DefineList is empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just shifted off the DefineList, or `undefined` if the DefineList is empty\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.indexOf": {
    "type": "function",
    "name": "can-define/list/list.prototype.indexOf",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 570,
      "codeLine": 596,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "```\nvar list = new can.DefineList(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1\n```\n\nIt is trivial to make a `contains`-type function using `indexOf`:\n\n```\nfunction(list, item) {\n    return list.indexOf(item) >= 0;\n}\n```\n    \n",
    "description": "Look for an item in a DefineList. ",
    "title": "indexOf",
    "signatures": [
      {
        "code": "list.indexOf(item)",
        "description": "\n\n`indexOf` finds the position of a given item in the DefineList.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "the item to find\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the position of the item in the DefineList, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "the item to find\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the position of the item in the DefineList, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.join": {
    "type": "function",
    "name": "can-define/list/list.prototype.join",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 605,
      "codeLine": 626,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "```\nvar list = new can.DefineList(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n\nvar beatles = new can.DefineList(['John', 'Paul', 'Ringo', 'George']);\nbeatles.join('&'); // 'John&Paul&Ringo&George'\n```\n    \n",
    "description": "Join a DefineList's elements into a string. ",
    "title": "join",
    "signatures": [
      {
        "code": "list.join(separator)",
        "description": "\n\n`join` turns a DefineList into a string by inserting _separator_ between the string representations\nof all the elements of the DefineList.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "separator",
            "description": "the string to seperate elements with\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the joined string\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "separator",
      "description": "the string to seperate elements with\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the joined string\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.reverse": {
    "type": "function",
    "name": "can-define/list/list.prototype.reverse",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 631,
      "codeLine": 649,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "```\nvar list = new can.DefineList(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n    \n",
    "description": "Reverse the order of a DefineList. ",
    "title": "reverse",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\n`reverse` reverses the elements of the DefineList in place.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can.DefineList"
            }
          ],
          "description": "the DefineList, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.DefineList"
        }
      ],
      "description": "the DefineList, for chaining\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.slice": {
    "type": "function",
    "name": "can-define/list/list.prototype.slice",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 655,
      "codeLine": 686,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "```\nvar list = new can.DefineList(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList.attr(); // ['Bob', 'Charlie', 'Daniel']\n```\n\n`slice` is the simplest way to copy a DefineList:\n\n```\nvar list = new can.DefineList(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy.attr();   // ['Alice', 'Bob', 'Eve']\nlist === copy; // false\n```\n    \n",
    "description": "Make a copy of a part of a DefineList. ",
    "title": "slice",
    "signatures": [
      {
        "code": "list.slice([start[, end]])",
        "description": "\n\n`slice` creates a copy of a portion of the DefineList.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "start",
            "defaultValue": "0",
            "description": "the index to start copying from\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "end",
            "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.DefineList"
            }
          ],
          "description": "a new `can.DefineList` with the extracted elements\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "end",
      "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.DefineList"
        }
      ],
      "description": "a new `can.DefineList` with the extracted elements\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.concat": {
    "type": "function",
    "name": "can-define/list/list.prototype.concat",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 693,
      "codeLine": 715,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "`concat` makes a new DefineList with the elements of the DefineList followed by the elements of the parameters.\n\n```\nvar list = new can.DefineList();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new can.DefineList(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n```\n    \n",
    "description": "Merge many collections together into a DefineList. ",
    "title": "concat",
    "signatures": [
      {
        "code": "list.concat(...args)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can.DefineList"
              },
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a DefineList, each of its elements will be added to\nthe end of the concatenated DefineList. Otherwise, the parameter itself will be added.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can.DefineList"
        },
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a DefineList, each of its elements will be added to\nthe end of the concatenated DefineList. Otherwise, the parameter itself will be added.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.forEach": {
    "type": "function",
    "name": "can-define/list/list.prototype.forEach",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 723,
      "codeLine": 743,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "`forEach` calls a callback for each element in the DefineList.\n\n```\nvar list = new can.DefineList([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.attr(index, element * element);\n});\nlist.attr(); // [1, 4, 9]\n```\n    \n",
    "description": "Call a function for each element of a DefineList. ",
    "title": "forEach",
    "signatures": [
      {
        "code": "list.forEach(callback[, thisArg])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "element"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "a function to call with each element of the DefineList\nThe three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the\ncurrent element of the list, and _list_ the DefineList the elements are coming from."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "the object to use as `this` inside the callback\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "the object to use as `this` inside the callback\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.replace": {
    "type": "function",
    "name": "can-define/list/list.prototype.replace",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 754,
      "codeLine": 816,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "`replace` replaces all the elements of this DefineList with new ones.\n\n`replace` is especially useful when `can.DefineList`s are live-bound into `[can.Control]`s,\nand you intend to populate them with the results of a `[can.Model]` call:\n\n```\ncan.Control({\n    init: function() {\n        this.list = new Todo.DefineList();\n        // live-bind the list into the DOM\n        this.element.html(can.view('list.stache', this.list));\n        // when this AJAX call returns, the live-bound DOM will be updated\n        this.list.replace(Todo.findAll());\n    }\n});\n```\n\nLearn more about [can.Model.DefineList making Lists of models].\n\n## Events\n\nA major difference between `replace` and `attr(newElements, true)` is that `replace` always emits\nan _add_ event and a _remove_ event, whereas `attr` will cause _set_ events along with an _add_ or _remove_\nevent if needed. Corresponding _change_ and _length_ events will be fired as well.\n\nThe differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:\n```\nvar attrList = new can.DefineList(['Alexis', 'Bill']);\nattrList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nvar replaceList = new can.DefineList(['Alexis', 'Bill']);\nreplaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nattrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n                                              // 1, set, Ben, Bill\nreplaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n                                              // 0, add, ['Adam', 'Ben'], ['Alexis', 'Bill']\n\nattrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n                                              // 1, remove, undefined, Ben\nreplaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n                                              // 0, add, Amber, ['Adam', 'Ben']\n\nattrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n                                              // 1, add, ['Bob', 'Eve'], undefined\nreplaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n                                              // 0, add, ['Alice', 'Bob', 'Eve'], Amber\n```\n    \n",
    "description": "Replace all the elements of a DefineList. ",
    "title": "replace",
    "signatures": [
      {
        "code": "list.replace(collection)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can.DefineList"
              },
              {
                "type": "can.Deferred"
              }
            ],
            "name": "collection",
            "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can.DefineList`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can.DefineList"
        },
        {
          "type": "can.Deferred"
        }
      ],
      "name": "collection",
      "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can.DefineList`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
    },
    "comment": " "
  },
  "can-set.Algebra": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.algebra.md"
    },
    "body": "",
    "description": "Creates an object that can perform binary operations on sets with an awareness of how certain properties represent the set.\n\n",
    "title": "",
    "name": "can-set.Algebra",
    "type": "function",
    "parent": "can-set",
    "signatures": [
      {
        "code": "new set.Algebra(compares...)",
        "description": "\n\nCreates an object that can perform binary operations on sets with\nan awareness of how certain properties represent the set.\n\n```js\nvar set = require(\"can-set\");\nvar algebra = new set.Algebra(\n  set.comparators.boolean(\"completed\"),\n  set.comparators.id(\"_id\")\n);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.compares"
              }
            ],
            "name": "compares",
            "description": "Each argument is a compares. These\nare returned by the functions on [can-set.comparators] or can be created\nmanually. \n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.Algebra"
            }
          ],
          "description": "Returns an instance of an algebra.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "name": "compares",
      "description": "Each argument is a compares. These\nare returned by the functions on [can-set.comparators] or can be created\nmanually. \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.Algebra"
        }
      ],
      "description": "Returns an instance of an algebra.\n"
    }
  },
  "can-set.comparators": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.comparators.md"
    },
    "body": "",
    "description": "Contains a collection of comparator generating functions. \nThe following functions create `compares` objects that can be mixed together to create a set `Algebra`.\n\n```js\nvar algebra = new set.Algebra(\n  {\n    // ignore this property in set algebra\n    sessionId:  function(){ return true }\n  },\n  set.comparators.boolean(\"completed\"),\n  set.comparators.rangeInclusive(\"start\",\"end\")\n);\n```\n\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "",
    "name": "can-set.comparators",
    "type": "property",
    "parent": "can-set"
  },
  "can-set.comparator": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.comparator.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "comparator",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-set.comparator",
    "parent": "can-set",
    "signatures": [
      {
        "code": "comparator(aValue, bValue, a, b, prop, algebra)",
        "description": "\n\nA comparator function returns algebra values for two values for a given property.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "aValue",
            "description": "The value of A's property in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "bValue",
            "description": "The value of A's property in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "a",
            "description": "The A set in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "b",
            "description": "The B set in a set difference A and B (A  B)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "Boolean"
            }
          ],
          "description": "A comparator function should either return a Boolean which indicates if `aValue` and `bValue` are\nequal or an `AlgebraResult` object that details information about the union, intersection, and difference of `aValue` and `bValue`.\n\nAn `AlgebraResult` object has the following values:\n\n- `union` - A value the represents the union of A and B.\n- `intersection` - A value that represents the intersection of A and B.\n- `difference` - A value that represents all items in A that are not in B.\n- `count` - The count of the items in A.\n\nFor example, if you had a `colors` property and A is `[\"Red\",\"Blue\"]` and B is `[\"Green\",\"Yellow\",\"Blue\"]`, the\nAlgebraResult object might look like:\n\n```js\n{\n  union: [\"Red\",\"Blue\",\"Green\",\"Yellow\"],\n  intersection: [\"Blue\"],\n  difference: [\"Red\"],\n  count: 2000\n}\n```\n\nThe count is `2000` because there might be 2000 items represented by colors \"Red\" and \"Blue\".  Often\nthe real number can not be known.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "b",
      "description": "The B set in a set difference A and B (A  B)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Boolean"
        }
      ],
      "description": "A comparator function should either return a Boolean which indicates if `aValue` and `bValue` are\nequal or an `AlgebraResult` object that details information about the union, intersection, and difference of `aValue` and `bValue`.\n\nAn `AlgebraResult` object has the following values:\n\n- `union` - A value the represents the union of A and B.\n- `intersection` - A value that represents the intersection of A and B.\n- `difference` - A value that represents all items in A that are not in B.\n- `count` - The count of the items in A.\n\nFor example, if you had a `colors` property and A is `[\"Red\",\"Blue\"]` and B is `[\"Green\",\"Yellow\",\"Blue\"]`, the\nAlgebraResult object might look like:\n\n```js\n{\n  union: [\"Red\",\"Blue\",\"Green\",\"Yellow\"],\n  intersection: [\"Blue\"],\n  difference: [\"Red\"],\n  count: 2000\n}\n```\n\nThe count is `2000` because there might be 2000 items represented by colors \"Red\" and \"Blue\".  Often\nthe real number can not be known.\n"
    }
  },
  "can-set.compares": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.compares.md"
    },
    "body": "",
    "description": "An object of property names and `comparator` functions. \n```js\n{\n  // return `true` if the values should be considered the same:\n  lastName: function(aValue, bValue){\n    return (\"\"+aValue).toLowerCase() === (\"\"+bValue).toLowerCase();\n  }\n}\n```\n\n\n",
    "type": "typedef",
    "title": "compares",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-set.comparator"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-set.compares",
    "parent": "can-set"
  },
  "can-set": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.md"
    },
    "body": "",
    "description": " \ncan-set is a utility for comparing [sets](http://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation) that are represented by the parameters commonly passed to service requests.\n\nOnce you've imported `set` into your project, use it to create a `set.Algebra` and then use that to compare and perform operations on sets.  \n\n```js\nvar set = require('can-set');\n// create an algebra\nvar algebra = new set.Algebra(\n    // specify the unique identifier on data\n    set.comparators.id(\"_id\"),  \n    // specify that completed can be true, false or undefined\n    set.comparators.boolean(\"completed\"),\n    // specify properties that define pagination\n    set.comparators.rangeInclusive(\"start\",\"end\"),\n    // specify the property that controls sorting\n    set.comparators.sort(\"orderBy\"),\n)\n\n// compare two sets\nalgebra.subset({start: 2, end: 3}, {start: 1, end: 4}) //-> true\nalgebra.difference({} , {completed: true}) //-> {completed: false}\n\n// perform operations on sets\nalgebra.getSubset({start: 2,end: 3},{start: 1,end: 4},\n            [{id: 1},{id: 2},{id: 3},{id: 4}])\n//-> [{id: 2},{id: 3}]\n```\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-set",
    "parent": "can-core"
  },
  "exports": {
    "name": "exports",
    "type": "property",
    "parent": "node_modules/can-set/src/clause.js",
    "src": {
      "line": 5,
      "codeLine": 12,
      "path": "node_modules/can-set/src/clause.js"
    },
    "body": "\nnew clause.Where()\n\nThis is so we can tell what type of clause some properties are for.\n\n",
    "description": "Exports a clause constructor functions like:\n"
  },
  "can-set.comparators.enum": {
    "type": "function",
    "name": "can-set.comparators.enum",
    "parent": "can-set.comparators",
    "src": {
      "line": 136,
      "codeLine": 148,
      "path": "node_modules/can-set/src/comparators.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "set.comparators.enum(property, propertyValues)",
        "description": "\n\nMakes a comparator for a set of values.\n\n```\nvar compare = set.comparators.enum(\"type\", [\"new\",\"accepted\",\"pending\",\"resolved\"])\n```\n ",
        "params": []
      }
    ]
  },
  "can-set.comparators.rangeInclusive": {
    "type": "function",
    "name": "can-set.comparators.rangeInclusive",
    "parent": "can-set.comparators",
    "src": {
      "line": 175,
      "codeLine": 191,
      "path": "node_modules/can-set/src/comparators.js"
    },
    "body": "",
    "description": "Supports ranged properties. \n",
    "title": "",
    "signatures": [
      {
        "code": "set.comparators.rangeInclusive(startIndexProperty, endIndexProperty)",
        "description": "\n\nMakes a comparator for two ranged properties that specify a range of items\nthat includes both the startIndex and endIndex.  For example, a range of\n[0,20] loads 21 items.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "startIndexProperty",
            "description": "The starting property name"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "endIndexProperty",
            "description": "The ending property name"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a comparator\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "endIndexProperty",
      "description": "The ending property name"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a comparator\n "
    }
  },
  "can-set.comparators.boolean": {
    "type": "function",
    "name": "can-set.comparators.boolean",
    "parent": "can-set.comparators",
    "src": {
      "line": 264,
      "codeLine": 284,
      "path": "node_modules/can-set/src/comparators.js"
    },
    "body": "",
    "description": "Supports boolean properties. \n",
    "title": "",
    "signatures": [
      {
        "code": "set.comparators.boolean(property)",
        "description": "\n\nMakes a compare object with a `property` function that has the following logic:\n\n```js\nA(true) ∪ B(false) = undefined\n\nA(undefined) \\ B(true) = false\nA(undefined) \\ B(false) = true\n```\n\nIt understands that `true` and `false` are complementary sets that combined to `undefined`. Another way to think of this is that if you load `{complete: false}` and `{complete: true}` you've loaded `{}`.\n\n ",
        "params": []
      }
    ]
  },
  "can-set.comparators.sort": {
    "type": "function",
    "name": "can-set.comparators.sort",
    "parent": "can-set.comparators",
    "src": {
      "line": 309,
      "codeLine": 339,
      "path": "node_modules/can-set/src/comparators.js"
    },
    "body": "",
    "description": "Defines the sortable property and behavior. \n",
    "title": "",
    "signatures": [
      {
        "code": "set.comparators.sort(prop, [sortFunc])",
        "description": "\n\nDefines the sortable property and behavior.\n\n```js\nvar algebra = new set.Algebra(set.comparators.sort(\"sortBy\"));\nalgebra.index(\n  {sortBy: \"name desc\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 1\n\nalgebra.index(\n  {sortBy: \"name\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "The sortable property."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "sortPropValue"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "item1"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "item2"
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "sortFunc",
            "description": "The\nsortable behavior. The default behavior assumes the sort property value\nlooks like `PROPERTY DIRECTION` (ex: `name desc`)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "sortPropValue"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "item1"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "item2"
                }
              ]
            }
          ]
        }
      ],
      "optional": true,
      "name": "sortFunc",
      "description": "The\nsortable behavior. The default behavior assumes the sort property value\nlooks like `PROPERTY DIRECTION` (ex: `name desc`)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
    }
  },
  "can-set.comparators.id": {
    "type": "function",
    "name": "can-set.comparators.id",
    "parent": "can-set.comparators",
    "src": {
      "line": 347,
      "codeLine": 376,
      "path": "node_modules/can-set/src/comparators.js"
    },
    "body": "",
    "description": "Defines the identify property. \n",
    "title": "",
    "signatures": [
      {
        "code": "set.comparators.id(prop)",
        "description": "\n\nDefines the property name on items that uniquely\nidentifies them. This is the default sorted property if no\n[can-set.comparators.sort] is provided.\n\n```js\nvar algebra = new set.Algebra(set.comparators.id(\"_id\"));\nalgebra.index(\n  {sortBy: \"name desc\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 1\n\nalgebra.index(\n  {sortBy: \"name\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "The property name that defines the unique property id."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "prop",
      "description": "The property name that defines the unique property id."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
    }
  },
  "subsetComparesType": {
    "type": "function",
    "name": "subsetComparesType",
    "params": [
      {
        "name": "a",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "b",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "aParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "bParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "prop",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "compares",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-set/src/compare.js",
    "src": {
      "line": 171,
      "codeLine": 177,
      "path": "node_modules/can-set/src/compare.js"
    },
    "body": " \n",
    "description": "Checks if A is a subset of B.  If A is a subset of B if:\n- A \\ B = undefined\n- A ∩ B = defined\n- B ∩ A = defined\n"
  },
  "properSubsetComparesType": {
    "type": "function",
    "name": "properSubsetComparesType",
    "params": [
      {
        "name": "a",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "b",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "aParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "bParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "prop",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "compares",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-set/src/compare.js",
    "src": {
      "line": 238,
      "codeLine": 241,
      "path": "node_modules/can-set/src/compare.js"
    },
    "body": " \n",
    "description": "Checks if A is a subset of B.  If A is a subset of B, A \\ B will be undefined. But B \\ A will be defined.\n"
  },
  "can-set.Translate": {
    "type": "function",
    "name": "can-set.Translate",
    "parent": "can-set",
    "src": {
      "line": 9,
      "codeLine": 33,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "",
    "title": "",
    "signatures": [
      {
        "code": "new set.Translate(clauseType, propertyName)",
        "description": "\n\nLocalizes a clause's properties within another nested property.\n\n```js\nvar algebra = new set.Algebra(\n  new set.Translate(\"where\",\"$where\")\n);\nalgebra.has(\n  {$where: {complete: true}},\n  {id: 5, complete: true}\n) //-> true\n```\n\nThis is useful when filters (which are `where` clauses) are\nwithin a nested object.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "clause",
            "description": "A clause type.  One of `'where'`, `'order'`, `'paginate'`, `'id'`."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "propertyName",
            "description": "The property name which contains the clauses's properties."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "set.compares"
            }
          ],
          "description": "A set compares object that can do the translation.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "propertyName",
      "description": "The property name which contains the clauses's properties."
    },
    "_curReturn": {
      "types": [
        {
          "type": "set.compares"
        }
      ],
      "description": "A set compares object that can do the translation.\n"
    }
  },
  "Algebra": {
    "type": "function",
    "name": "Algebra",
    "params": [],
    "parent": "node_modules/can-set/src/set-core.js",
    "src": {
      "line": 49,
      "codeLine": 56,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "\nnew set.Algebra(Where(),Paginate(),Sort())\n\n\n",
    "description": "An `Algebra` internally keeps different properties organized by clause type.\nIf an object comes in that isn't a clause type, it's assuemd to be a where.\n"
  },
  "can-set.Algebra.prototype.equal": {
    "type": "function",
    "name": "can-set.Algebra.prototype.equal",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 249,
      "codeLine": 265,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "algebra.equal(a, b)",
        "description": "\n\n  Returns true if the two sets the exact same.\n\n  ```js\n  algebra.equal({type: \"critical\"}, {type: \"critical\"}) //-> true\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the two sets are equal.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the two sets are equal.\n "
    }
  },
  "can-set.Algebra.prototype.subset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.subset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 268,
      "codeLine": 285,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "algebra.subset(a, b)",
        "description": "\n\nReturns true if _A_ is a subset of _B_ or _A_ is equal to _B_ (_A_ ⊆ _B_).\n\n```js\nalgebra.subset({type: \"critical\"}, {}) //-> true\nalgebra.subset({}, {}) //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `a` is a subset of `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `a` is a subset of `b`.\n "
    }
  },
  "can-set.Algebra.prototype.properSubset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.properSubset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 308,
      "codeLine": 325,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "algebra.properSubset(a, b)",
        "description": "\n\nReturns true if _A_ is a strict subset of _B_ (_A_ ⊂ _B_).\n\n```js\nalgebra.properSubset({type: \"critical\"}, {}) //-> true\nalgebra.properSubset({}, {}) //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `a` is a subset of `b` and not equal to `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `a` is a subset of `b` and not equal to `b`.\n "
    }
  },
  "can-set.Algebra.prototype.difference": {
    "type": "function",
    "name": "can-set.Algebra.prototype.difference",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 328,
      "codeLine": 360,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "algebra.difference(a, b)",
        "description": "\n\nReturns a set that represents the difference of sets _A_ and _B_ (_A_ \\ _B_), or\nreturns if a difference exists.\n\n```js\nalgebra1 = new set.Algebra(set.comparators.boolean(\"completed\"));\nalgebra2 = new set.Algebra();\n\n// A has all of B\nalgebra1.difference( {} , {completed: true} ) //-> {completed: false}\n\n// A has all of B, but we can't figure out how to create a set object\nalgebra2.difference( {} , {completed: true} ) //-> true\n\n// A is totally inside B\nalgebra2.difference( {completed: true}, {} )  //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.set"
            },
            {
              "type": "Boolean"
            }
          ],
          "description": "If an object is returned, it is difference of sets _A_ and _B_ (_A_ \\ _B_).\n\nIf `true` is returned, that means that _B_ is a subset of _A_, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is no difference or the sets are not comparable.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.set"
        },
        {
          "type": "Boolean"
        }
      ],
      "description": "If an object is returned, it is difference of sets _A_ and _B_ (_A_ \\ _B_).\n\nIf `true` is returned, that means that _B_ is a subset of _A_, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is no difference or the sets are not comparable.\n "
    }
  },
  "can-set.Algebra.prototype.union": {
    "type": "function",
    "name": "can-set.Algebra.prototype.union",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 392,
      "codeLine": 413,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "algebra.union(a, b)",
        "description": "\n\nReturns a set that represents the union of _A_ and _B_ (_A_ ∪ _B_).\n\n```js\nalgebra.union(\n  {start: 0, end: 99},\n  {start: 100, end: 199},\n) //-> {start: 0, end: 199}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.set"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If an object is returned, it is the union of _A_ and _B_ (_A_ ∪ _B_).\n\nIf `undefined` is returned, it means a union can't be created.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.set"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If an object is returned, it is the union of _A_ and _B_ (_A_ ∪ _B_).\n\nIf `undefined` is returned, it means a union can't be created.\n "
    }
  },
  "can-set.Algebra.prototype.intersection": {
    "type": "function",
    "name": "can-set.Algebra.prototype.intersection",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 446,
      "codeLine": 467,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "algebra.count(set)",
        "description": "\n\nReturns the number of items that might be loaded by the `set`. This makes use of set.Algebra's\nBy default, this returns Infinity.\n\n```js\nvar algebra =  new set.Algebra({\n  set.comparators.rangeInclusive(\"start\", \"end\")\n});\nalgebra.count({start: 10, end: 19}) //-> 10\nalgebra.count({}) //-> Infinity\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "set",
            "description": "[description]"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of items in the set if known, `Infinity`\nif unknown.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.set"
        }
      ],
      "name": "set",
      "description": "[description]"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of items in the set if known, `Infinity`\nif unknown.\n "
    }
  },
  "can-set.Algebra.prototype.has": {
    "type": "function",
    "name": "can-set.Algebra.prototype.has",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 470,
      "codeLine": 493,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "algebra.has(set, props)",
        "description": "\n\nUsed to tell if the `set` contains the instance object `props`.\n\n```\nvar algebra = new set.Algebra(\n  new set.Translate(\"where\",\"$where\")\n);\nalgebra.has(\n  {\"$where\": {playerId: 5}},\n  {id: 5, type: \"3pt\", playerId: 5, gameId: 7}\n) //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "set",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An instance's raw data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Returns `true` if `props` belongs in `set` and\n`false` it not.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An instance's raw data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Returns `true` if `props` belongs in `set` and\n`false` it not.\n "
    }
  },
  "can-set.Algebra.prototype.index": {
    "type": "function",
    "name": "can-set.Algebra.prototype.index",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 520,
      "codeLine": 549,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "algebra.index(set, items, item)",
        "description": "\n\nReturns where `item` should be inserted into `items` which is represented by `set`.\n\n```js\nalgebra = new set.Algebra(\n  set.comparators.sort(\"orderBy\")\n);\nalgebra.index(\n  {orderBy: \"age\"},\n  [{id: 1, age: 3},{id: 2, age: 5},{id: 3, age: 8},{id: 4, age: 10}],\n  {id: 6, age: 3}\n)  //-> 2\n```\n\nThe default sort property is what is specified by\n[can-set.comparators.id]. This means if that if the sort property\nis not specified, it will assume the set is sorted by the specified\nid property.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "set",
            "description": "The `set` that describes `items`."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "items",
            "description": "An array of data objects."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "item",
            "description": "The data object to be inserted."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The position to insert `item`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "item",
      "description": "The data object to be inserted."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The position to insert `item`.\n "
    }
  },
  "can-set.Algebra.prototype.getSubset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.getSubset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 573,
      "codeLine": 597,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "algebra.getSubset(a, b, bData)",
        "description": "\n\nGets `a` set's items given a super set `b` and its items.\n\n```js\nalgebra.getSubset(\n  {type: \"dog\"},\n  {},\n  [{id: 1, type:\"cat\"},\n   {id: 2, type: \"dog\"},\n   {id: 3, type: \"dog\"},\n   {id: 4, type: \"zebra\"}]\n) //-> [{id: 2, type: \"dog\"},{id: 3, type: \"dog\"}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "a",
            "description": "The set whose data will be returned."
          },
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "b",
            "description": "A superset of set `a`."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "bData",
            "description": "The data in set `b`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The data in set `a`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "bData",
      "description": "The data in set `b`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "The data in set `a`.\n "
    }
  },
  "can-set.Algebra.prototype.getUnion": {
    "type": "function",
    "name": "can-set.Algebra.prototype.getUnion",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 613,
      "codeLine": 639,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "algebra.getUnion(a, b, aItems, bItems)",
        "description": "\n\nUnifies items from set A and setB into a single array of items.\n\n```js\nalgebra = new set.Algebra(\n  set.comparators.rangeInclusive(\"start\",\"end\")\n);\nalgebra.getUnion(\n  {start: 1,end: 2},\n  {start: 2,end: 4},\n  [{id: 1},{id: 2}],\n  [{id: 2},{id: 3},{id: 4}]);\n  //-> [{id: 1},{id: 2},{id: 3},{id: 4}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set.set"
              }
            ],
            "name": "b",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "aItems",
            "description": "Set `a`'s items."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "bItems",
            "description": "Set `b`'s items."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns items in both set `a` and set `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "bItems",
      "description": "Set `b`'s items."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns items in both set `a` and set `b`.\n "
    }
  },
  "can-stache.Acquisition": {
    "src": {
      "path": "node_modules/can-stache/docs/acquisition.md"
    },
    "body": "\n__Raw Text__\n\nRaw text can be templated by passing the text containing your template.  For example:\n\n\tvar text = \"My body lies over the {{.}}\",\n\t\ttemplate = stache(text),\n\t\tfragment = template(\"ocean\");\n\t\n\tdocument.body.appendChild(fragment);\n\n",
    "description": "\nThere are number of ways to acquire templates such as: raw text,\nURL, or script tags in the markup.\n",
    "name": "can-stache.Acquisition",
    "title": "Template Acquisition",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 3
  },
  "can-stache.scopeAndContext": {
    "src": {
      "path": "node_modules/can-stache/docs/context.md"
    },
    "body": "\n## Scope and Contexts\n\nEvery part of a stache template is rendered with a \ngiven [can-view-scope scope]. The scope is used to lookup \nvalues. A scope can contain multiple places to lookup values. \n\nLets look at what happens with the scope the following example:\n\n```\nTemplate:\n\t<h1>{{message}} {{#person}}{{first}}  {{last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\"},\n\t  last: \"Abril\",\n\t  message: \"Hello\" }\n\nResult:\n\t<h1>Hello Alexis Abril</h1>\n```\n\n1. The template is rendered with `Data` as the only item in the scope. `scope:[Data]`\n2. `{{message}} is looked up within `Data`.\n3. `{{#person}}` adds the `person` object to the top of the scope. `scope:[Data,Data.person]`\n4. `{{first}}` is looked up in the scope.  It will be found on `Data.person`.\n5. `{{last}}` is looked up in the scope.  \n   1. `last` is looked in `Data.person`, it's not found.\n   2. `last` is looked up in `Data` and returned.\n6. `{{/person}}` removes `person` from the scope. `scope:[Data]`\n\nThe scope used to lookup a value can be controlled by adding `../` or `./` before a \nkey. For instance, if we wanted to make sure `last` was only going to lookup on `person`,\nwe could change the template to:\n\n```\nTemplate:\n\t<h1>{{message}} {{#person}}{{first}}  {{./last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\"},\n\t  last: \"Abril\",\n\t  message: \"Hello\" }\n\nResult:\n\t<h1>Hello Alexis </h1>\n```\n\n[can-stache.tags.section Sections], Helpers, \nand [can-component custom elements] can modify the scope used to render a subsection.\n\n## Older\n\n\nWhen using [can-stache.Basics tags] in Stache, the `key` in `[can-stache.tags.escaped {{key}}]` \nreferences a property on the current context object. The default context always points to the data \nobject initially passed to the template.\n\nInstead of simply referencing a key matching a property on the current context object, a full path can \nbe included instead. When a path is found, Stache will look for a matching property using the entire path:\n\n\tTemplate:\n\t\t{{person.name}}\n\n\tData:\n\t\t{ \n\t\t\tperson: {\n\t\t\t\tname: \"Austin\"\n\t\t\t}\n\t\t}\n\n\tResult:\n\t\tAustin\n\nAdditionally, the current context can be changed by using [can-stache.Sections sections]. Anytime a section \nis opened, any tags inside of it will use that object as the local context for any key lookups:\n\n\tTemplate:\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\n\tData:\n\t\t{ \n\t\t\tperson: {\n\t\t\t\tname: \"Austin\"\n\t\t\t}\n\t\t}\n\n\tResult:\n\t\tAustin\n\nIf the key used within a section is not found on the local context, Stache will look up the \nstack of contexts until it finds a matching key:\n\n\tTemplate:\n\t\t{{#person}}\n\t\t\t{{name}} is {{age}}\n\t\t{{/person}}\n\n\tData:\n\t\t{ \n\t\t\tperson: {\n\t\t\t\tname: \"Austin\"\n\t\t\t}\n\t\t\tage: 29\n\t\t}\n\n\tResult:\n\t\tAustin is 29\n\t\t\n\n",
    "description": "\n",
    "name": "can-stache.scopeAndContext",
    "title": "Scope and Context",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 1
  },
  "can-stache.expressions": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions.md"
    },
    "body": "\n```\n{{helper key1 \"string\" method(key2, 1, prop1=key3) prop2=key4}}\n```\n\nThere are 5 expression types stache supports:\n\n - Literal expression  like `{{\"string\"}}`\n - KeyLookup expressions like `{{key}}`\n - Hash expression like `{{prop=key}}`\n - Call expressions like `{{method(arg)}}`\n - Helper expressions like `{{helper arg}}`\n\n## Literal expressions\n\nLiteral expressions specify JS primitive values like:\n\n- Strings `\"strings\"`\n- Numbers `5`\n- Booleans `true` or `false`\n- And `null` or `undefined`\n\nThey are usually passed as arguments to Call or Helper expressions like:\n\n```\n{{pluralize \"dog\" 2}}\n{{task.filter(\"completed\",true)}}\n```\n\n## KeyLookup expressions\n\nA [can-stache.key KeyLookup expression] specifies a value in the [can-view-scope scope] or\n[can-view-scope.Options HelperOptions scope] that will be looked up.  KeyLookup expressions\ncan be the entire stache expression like:\n\n```\n{{key}}\n```\n\nOr they can makeup the method, helper, arguments and hash value parts of\nCall, Helper, and Hash expressions:\n\n```\n{{method(arg1,arg2}}          Call\n{{helper arg1 arg2}}          Helper\n{{method( prop=hashValue )}}  Hash\n```\n\nThe value looked up by a KeyLookup depends on what the key looks like, and\nwhat expression type the KeyLookup is within.\n\nFor example, `{{method(~./key)}}` will call `method` with \nthe a compute that looks up the value of `key` only in the top of the [can-view-scope scope].\n\nIn general the rules are as follows:\n\n - __call expression arguments__ `{{method(key)}}` - values are passed.\n - __helper expression arguments__ `{{helper key}}` - computes are passed.\n - __hash value in call expression__ `{{method(hash=key)}}` - values are set as property values.\n - __hash value in helper expression__ `{{method hash=key}}` - computes are set as property values.\n - __special operator__ `{{%index}}` - lookup values in a special context provided by some helpers.\n - __compute operator__ `{{method(~key)}}` - pass a compute instead of a value.\n - __at operator__ `{{method(@key}}` - pass a function instead of trying to read the value of the function.\n - __current context__ `{{./key}}` - only lookup key at the top of the scope.\n - __parent context__ `{{../key}}` - lookup the value in the parent context.\n - __context__ `{{.}}` - return the current context/top of the scope.\n\n## Hash expression\n\nA hash expression sepecifies a property value on an options object in a call expression\nand property value on the the hash object in a helper expression.\n\nFor example, in a call expression:\n\n```\nTemplate:\n\t{{method(prop=key)}}\n\nData:\n\t{\n\t  method: function(arg){},\n\t  key: canCompute(\"value\")\n\t}\n```\n\n`method` will be called with `{prop: \"value\"}` as `arg`.\n\nIn a helper expression:\n\n```\nTemplate:\n\t{{method prop=key}}\n\nData:\n\t{\n\t  method: function(options){},\n\t  key: canCompute(\"value\")\n\t}\n```\n\n`method` will be called with `{prop: compute<\"value\">}` as `options.hash`.\n\n## Call expression\n\nA call expression calls a function looked up in the [can-view-scope scope] followed by \nthe [can-view-scope.Options helpers scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize(type,ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return type+(count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nCall expression arguments are commma (,) seperated.  If a Hash expression is an argument,\nan object with the hash properties and values will be passed. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize(word=type count=ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(options){\n\t    return options.word+(options.count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n\n## Helper expression\n\nA helpers expression calls a function looked up in the [can-view-scope.Options helpers scope] followed by \nthe [can-view-scope scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize type ages.length}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return \"data-pluralize\"\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(type, count){\n\t    return type+(count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nHelper expression arguments that are observable are passed a compute.  This is\nin contrast to Call expressions that get passed the value.\n\nHelper expression arguments are space seperated.  If a Hash expression is an argument,\nthe hash properties and values will be added to the helper options object. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize word=type count=ages.length}}</h1>\n\nData:\n\t{\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(helperOptions){\n\t    return helperOptions.hash.type+(helperOptions.hash.count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n\n",
    "description": "\nIn addition to different magic tag types, stache supports different expression \ntypes.  These can be used in various combinations to call [can-stache.registerHelper helper methods]\nor [can-component::viewModel viewModel methods].  The following is an example of all the expressions\ncombined:\n",
    "name": "can-stache.expressions",
    "title": "Expressions",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 2
  },
  "can-stache.helper": {
    "src": {
      "path": "node_modules/can-stache/docs/helper.md"
    },
    "body": "\n## Use\n\nThe following template:\n\n    <p>{{madLib \"Lebron James\" verb 4}}</p>\n\nRendered with\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements.\n\n    stache.registerHelper('madLib', \n      function(subject, verb, number){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n    });\n    \n\nWhile keys are normally resolved as basic objects like strings or numbers, \nthere are special cases where they act differently than a normal \ntag. Whenever a [can-compute.computed] or function \nobject is an argument for a helper, the original object is used \nas the argument instead of the value that the function returns.\n\nIf a [can-stache.key] represents a [can-map] attribute,\nit is converted to a [can-compute.computed] getter/setter \nfunction. This enables 2-way binding helpers.  \n\nFor example, the following helper two-way binds an input element's\nvalue to a [can-compute.computed]:\n\n    stache.registerHelper('value',function(value){\n        return function(el){\n          value.bind(\"change\",function(ev, newVal){\n            el.value = newVal;\n          })\n          el.onchange = function(){\n            value(this.value);\n          }\n          el.value = value();\n        }\n    });\n    \nAnd used by the following template:\n\n    <input type=\"text\" {{me.value name}}/>\n    \nAnd rendered with:\n    \n    {me: new Map({name: \"Payal\"})}\n\n\n## Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can \nbe used to create stache tags that have rich behavior. \n\nIf the helper is called __within a tag__ like:\n\n    <ul {{sortable}}/>\n\nThe returned function is called with the `<ul>` element:\n\n    stache.registerHelper(\"sortable\",function(){\n      return function(el){\n        $(el).slider();\n      }\n    });\n\nIf the helper is called __between tags__ like:\n\n    <ul>{{items}}</ul>\n    \nThe returned function is called with a temporary element. The \nfollowing helper would be called with a temporary `<li>` element:\n\n    stache.registerHelper(\"items\",function(){\n      return function(li){\n        \n      }\n    });\n\nThe temporary element depends on the parent element. The default temporary element\nis a `<span>` element.\n\n\n\n\n",
    "description": "A helper function passed to [can-stache.registerHelper]. \n",
    "type": "typedef",
    "title": "helper",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            },
            {
              "type": "String"
            },
            {
              "type": "can.contentArray"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "HTMLElement"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The content to be inserted into\nthe template.\n"
        },
        "params": [
          {
            "variable": true,
            "types": [
              {
                "type": "*"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-stache.sectionOptions"
              }
            ]
          },
          {
            "variable": true,
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-compute"
              }
            ],
            "optional": true,
            "name": "arg",
            "description": "Arguments passed from the tag. After the helper\nname, any space seperated [can-stache.key keys], numbers or \nstrings are passed as arguments. [can-stache.key Keys] that \nread an observable value are passed as [can-compute.computed]'s.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.helperOptions"
              }
            ],
            "name": "options",
            "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions \n- a `hash` object of the maps passed to the helper \n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "can-stache.context"
            }
          ],
          "description": "The context the helper was\ncalled within.\n"
        }
      }
    ],
    "name": "can-stache.helper",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helperOptions"
        }
      ],
      "name": "options",
      "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions \n- a `hash` object of the maps passed to the helper \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        },
        {
          "type": "String"
        },
        {
          "type": "can.contentArray"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ]
            }
          ]
        }
      ],
      "description": "The content to be inserted into\nthe template.\n"
    },
    "comment": " "
  },
  "can-stache.helperOptions": {
    "src": {
      "path": "node_modules/can-stache/docs/helperOptions.md"
    },
    "body": "",
    "description": "The options argument passed to a [can-stache.helper helper function]. \n",
    "type": "typedef",
    "title": "helperOptions",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "fn",
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "description": "Renders the \"truthy\" subsection \nBLOCK.  `options.fn` is only available if the helper is called as a \n[can-stache.tags.section section] or [can-stache.tags.inverse inverse section] like:\n`{{#helper}}` or `{{^helper}}.  The subsection BLOCK's \n\nAvailable if the helper is called \nas a section or inverse section. \n[can-stache.helpers.sectionHelper section helper] is called.  Call `fn` to\nrender the BLOCK with the specified `context`.\n",
            "optional": true
          },
          {
            "name": "inverse",
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "description": "Provided if a \n[can-stache.helpers.sectionHelper section helper] is called \nwith [can-stache.helpers.else {{else}}].  Call `inverse` to\nrender the INVERSE with the specified `context`.\n",
            "optional": true
          },
          {
            "name": "hash",
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      },
                      {
                        "type": "String"
                      },
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "An object containing all of the final \narguments listed as `name=value` pairs for the helper.\n\t\n\t{{helper arg1 arg2 name=value other=3 position=\"top\"}}\n\n\toptions.hash = {\n\t\tname: <context_lookup>.value,\n\t\tother: 3,\n\t\tposition: \"top\"\n\t}\n"
          },
          {
            "name": "context",
            "description": "The current context the stache helper is called within.\n\n    \n    \n    var temp = stache(\n      \"{{#person.name}}{{helper}}{{/person.name}}\");\n    \n    var data = {person: {name: {first: \"Justin\"}}};\n    \n    stache.registerHelper(\"helper\", function(options){\n    \n      options.context === data.person //-> true\n      \n    })\n    \n    \n    temp(data);\n    \n    \n",
            "types": [
              {
                "type": "*"
              }
            ]
          },
          {
            "name": "scope",
            "description": "An object that represents the current context and all parent \ncontexts.  It can be used to look up [can-stache.key key] values in the current scope.\n\n    var temp = stache(\n      \"{{#person.name}}{{helper}}{{/person.name}}\");\n    \n    var data = {person: {name: {first: \"Justin\"}}};\n    \n    stache.registerHelper(\"helper\", function(options){\n    \n      options.scope.attr(\"first\")   //-> \"Justin\"\n      options.scope.attr(\"person\")  //-> data.person\n      \n    })\n    \n    \n    temp(data);\n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "An object that represents the local stache helpers.  It can be used to look \nup [can-stache.key key] values\n\n    var temp = stache(\"{{#person.name}}{{helper}}{{/person.name}}\");\n    \n    var data = {person: {name: \"Justin\"}};\n    \n    stache.registerHelper(\"helper\", function(options){\n    \n      options.options.attr(\"helpers.specialHelper\") //-> function\n      \n    })\n    \n    \n    temp(data, {\n      specialHelper: function(){ ... }\n    });\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-stache.helperOptions",
    "parent": "can-stache.types"
  },
  "can-stache.Helpers": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers.md"
    },
    "body": "\nHelpers are functions that can be registered and called from within templates. While stache is \nintended to be logic-less, helpers enable the execution of logic from within a stache template.\n\nStache includes a number of built-in helpers, but custom helpers can be registered as well. \nThe majority of these built-in helpers have [can-stache.Basics basic tag] equivalents.\n\n## Built-in Helpers\n\nThe `[can-stache.tags.section {{#if key}}]` helper is used for **if** statements. The **if** helper is equivalent \nto using a `[can-stache.tags.section {{#key}}]` section. If they key passed to the helper is **truthy**, the \nsection will be rendered.\n\n\tTemplate: \n\t\t{{#if friends}}\n\t\t\tI have friends!\n\t\t{{/if}}\n\n\tData: \n\t\t{\n\t\t\tfriends: true\n\t\t}\n\n\tResult:\n\t\tI have friends!\n\nWhen using the `[can-stache.helpers.if {{#if key}}]` helper, or any other helper for that matter, \nthe special `[can-stache.helpers.else {{else}}] helper becomes available. `{{else}}` is equivalent to \nan [can-stache.helpers.inverse {{^key}}] inverse section (rendering **falsey** data), except that it \nonly uses a single tag and exists inside \na helper section.\n\n\tTemplate: \n\t\t<ul>\n\t\t\t{{#if friends}}\n\t\t\t\t</li>{{name}}</li>\n\t\t\t{{else}}\n\t\t\t\t<li>No friends.</li>\n\t\t\t{{/if}}\n\t\t</ul>\n\n\tData: \n\t\t{\n\t\t\tfriends: false\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>No friends.</li>\n\t\t</ul>\n\nThe `[can-stache.helpers.unless {{#unless key}}]` helper is equivalent to using a \n`[can-stache.helpers.inverse {{^key}}]` inverse section. If they key passed to the helper is **falsey**, the \nsection will be rendered.\n\n\tTemplate: \n\t\t{{#unless friends}}\n\t\t\tYou don't have any friends!\n\t\t{{/unless}}\n\n\tData: \n\t\t{\n\t\t\tfriends: []\n\t\t}\n\n\tResult:\n\t\tYou don't have any friends!\n\nThe `[can-stache.helpers.each {{#each key}}]` helper is equivalent to using a \n`[can-stache.tags.section {{#key}}]` section for iterating an array. In this case, the entire array \nwill be rendered using the inner text item by item.\n\n\tTemplate: \n\t\t<ul>\n\t\t\t{{#each friends}}\n\t\t\t\t<li>{{name}}</li>\n\t\t\t{{/each}}\n\t\t</ul>\n\n\tData: \n\t\t{ \n\t\t\tfriends: [ \n\t\t\t\t{ name: \"Austin\" }, \n\t\t\t\t{ name: \"Justin\" } \n\t\t\t] \n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>Austin</li>\n\t\t\t<li>Justin</li>\n\t\t</ul>\n\nThe `[can-stache.helpers.with {{#with key}}]` helper is equivalent to using a \n`[can-stache.tags.section {{#key}}]` section for regular objects. The helper will change \nthe current context so that all tags inside will look for keys on the local context first.\n\n\tTemplate: \n\t\t<h1>Hi {{name}}</h1>\n\t\t{{#with friend}}\n\t\t\t<p>You have a new friend: {{name}}</p>\n\t\t{{/with}}\n\n\tData: \n\t\t{\n\t\t\tname: \"Andy\",\n\t\t\tfriend: { name: \"Justin\" } \n\t\t}\n\n\tResult:\n\t\t<h1>Hi Austin</h1>\n\t\t<p>You have a new friend: Justin</p>\n\nWhen using the `[can-stache.helpers.is {{#is key1 key2}}]` helper you can simply compare\nkey1 and key2. If the result of comparsion is **truthy**, the section will be rendered.\n\n\tTemplate: \n\t\t<ul>\n\t\t{{#is name 'Alex'}}\n\t\t\t</li>Your name is {{name}}</li>\n\t\t{{else}}\n\t\t\t<li>Your name is not Alex!</li>\n\t\t{{/is}}\n\t\t</ul>\n\n\tData: \n\t\t{\n\t\t\tname: 'John'\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>Your name is not Alex!</li>\n\t\t</ul>\n\nThe `[can-stache.helpers.data {{data key}}]` helper is another special helper for data associations that \nwill save the current context on the active DOM element with [can.data].\n\n\tTemplate:\n\t\t<ul>\n\t\t\t<li id=\"personli\" {{data 'person'}}>{{name}}</li>\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tname: 'Austin'\n\t\t}\n\n\tThe data can be retrieved later with:\n\t\tvar nameObject = can.data(can.$('#personli'), 'person'); \n\n## Registering Helpers\n\nYou can register your own global helper with the `[can-stache.registerHelper registerHelper]` method, or \na local helper (just accessible by the template being rendered) by passing in an object containing helper functions to [can.view].\n\nLocalization is a good example of a custom helper you might implement\nin your application. The below example takes a given key and \nreturns the localized value using \n[jQuery Globalize](https://github.com/jquery/globalize).\n\n\tstache.registerHelper('l10n', function(str, options){\n\t\treturn Globalize != undefined \n\t\t\t? Globalize.localize(str) \n\t\t\t: str;\n\t});\n\nOr another way to do this:\n\n\tcan.view(\"//path/to/template.stache\", data, {\n\t\tl10n: function(str, options){\n\t\t\treturn Globalize != undefined \n\t\t\t\t? Globalize.localize(str) \n\t\t\t\t: str;\n\t\t}\n\t})\n\nIn the template, invoke the helper by calling the helper\nname followed by any additional arguments.\n\t\n\tTemplate:\n\t\t<span>{{l10n 'mystring'}}</span>\n\n\tResult:\n\t\t<span>my string localized</span>\n\n__Helpers with can-map attributes__\n\nIf a Map attribute is passed as an argument to a helper, it is converted to a can.compute getter/setter function.  This is to allow creating 2-way binding type functionality between a can-map attribute and a form element. For example in your template:\n\n\t<div>{{addPrefix name}}</div>\n\nYour helper would look like:\n\n\tvar item = new Map({name: \"Brian\"}),\n\t    frag = can.view(\"#template\", item, {\n\t      addPrefix: function(name){\n\t        return \"Mr.\" + name()\n\t      }\n\t    });\n\nNote we're calling `name()` in order to read its contents.\n\n__Multiple Arguments__\n\nYou can pass multiple arguments just by putting a space between\nthat and the previous argument like so:\n\n\t{{helper 'cat' 'hat'}}\n\n\tstache.registerHelper('helper', function(arg1, arg2, options){\n\t\t// arg1 -> 'cat'\n\t\t// arg2 -> 'hat'\n\t});\n\n__Evaluating Helpers__\n\nIf you want to use a helper with a [can-stache.Sections section], you need to call\n`options.fn(context)` in your return statement. This will return a \nstring with the resulting evaluated [can-stache.Sections section].\n\nSimilarly, you can call `options.inverse(context)` to evaluate the \ntemplate between an `{{else}}` tag and the closing tag.\n\nFor example, when a route matches the string passed to our\nrouting helper it will show/hide the text.\n\n\tstache.registerHelper('routing', function(str, options){\n\t\tif (route.attr('filter') === str)\n\t\t\treturn options.fn(this);\n\t\t}\n\t});\n\n\t{{#routing 'advanced'}}\n\t\tYou have applied the advanced filter.\n\t{{/routing}}\n\t\n__Advanced Helpers__\n\nHelpers can be passed normal objects, native objects like numbers and strings, \nas well as a hash object. The hash object will be an object literal containing \nall ending arguments using the `key=value` syntax. The hash object will be provided \nto the helper as `options.hash`. Additionally, when using [can-stache.Sections section] with the helper, \nyou can set a custom context by passing the object instead of `this`.\n\n\tstache.registerHelper('exercise', function(group, action, \n\t\t\t\t\t\t\t\t\t\t\tnum, options){\n\t\tif (group && group.length > 0 && action && num > 0) {\n\t\t\treturn options.fn({\n\t\t\t\tgroup: group,\n\t\t\t\taction: action,\n\t\t\t\twhere: options.hash.where,\n\t\t\t\twhen: options.hash.when,\n\t\t\t\tnum: num\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\treturn options.inverse(this);\n\t\t}\n\t});\n\n\t{{#exercise pets 'walked' 3 where='around the block' when=time}}\n\t\tAlong with the {{#group}}{{.}}, {{/group}}\n\t\twe {{action}} {{where}} {{num}} times {{when}}.\n\t{{else}}\n\t\tWe were lazy today.\n\t{{/exercise}}\n\t\n\t{\n\t\tpets: ['cat', 'dog', 'parrot'],\n\t\ttime: 'this morning'\n\t}\n\t\nThis would output:\n\n\tAlong with the cat, dog, parrot, we walked around the block \n\t3 times this morning.\n\t\nWhereas an empty data object would output:\n\n\tWe were lazy today.\n\n",
    "description": "\n# Helpers\n",
    "name": "can-stache.Helpers",
    "title": "Helpers",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 4
  },
  "can-stache.Binding": {
    "src": {
      "path": "node_modules/can-stache/docs/livebinding.md"
    },
    "body": "\nIt's very common as the page is interacted with that the underlying \ndata represented in the page changes.  Typically, you have callbacks \nin your AJAX methods or events and then update the content of your \ncontrols manually.\n\nIn this example, we have a simple user welcome screen.\n\n\t<h1>Welcome {{user}}!</h1>\n\t<p>\n\t\t{{#if messages}}\n\t\t\tYou have {{messages}} new messages.\n\t\t{{else}}\n\t\t\tYou no messages.\n\t\t{{/messages}}\n\t</p>\n\n\tvar data = new Map({\n\t\tuser: 'Tina Fey',\n\t\tmessages: 0\n\t});\n\n\tvar template = stache(document.querySelector(\"#template\").innerHTML, data);\n\nThe template evaluates the `messages` and adds the hooks for live binding automatically.\nSince we have no message it will render:\n\n\t<h1>Welcome Tina Fey!</h1>\n\t<p>You no messages.</p>\n\nNow say we have a request that updates\nthe `messages` attribute to have `5` messages.  We \ncall the [attr](can-map.prototype.attr) method on the [can-map] to update\nthe attribute to the new value.\n\n\tdata.attr('message', 5)\n\n\nAfter [can-map] receives this update, it will automatically\nupdate the paragraph tag to reflect the new value.\n\n\t<p>You have 5 new message.</p>\n\n\nFor more information visit the [can-map] documentation.\n\n### Binding between components\nIf you are looking for information on bindings between components like this:\n```\n(event)=\"key()\" for event binding.\n{prop}=\"key\" for one-way binding to a child.\n{^prop}=\"key\" for one-way binding to a parent.\n{(prop)}=\"key\" for two-way binding.\n```\nSee [can-stache-bindings].\n\n",
    "description": "\nLive binding refers to templates which update themselves \nas the data used in the stache tags change.\n",
    "name": "can-stache.Binding",
    "title": "Live Binding",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 5
  },
  "can-stache.helpers.partial": {
    "src": {
      "path": "node_modules/can-stache/docs/partials.md"
    },
    "body": "\nPartials are templates embedded in other templates.  Partials begin with a greater than sign, like `{{>my_partial}}`.  Partials inherit the calling context.  \n\nPartials render at runtime, so recursive partials are possible but make sure you avoid infinite loops.\n\nFor example, this template and partial:\n\n__base.mustache__\n\n```\n<h2>Names</h2>\n{{#names}}\n\t{{>user.stache}}\n{{/names}}\n```\n\n__user.mustache__\n\n```\n<strong>{{name}}</strong>\n```\n\nThe resulting expanded template at render time would look like:\n\n```\n<h2>Names</h2>\n{{#names}}\n\t<strong>{{name}}</strong>\n{{/names}}\n```\n\n## Acquiring Partials\n\n__Referencing Files__\n\nPartials can reference a file path and file name in the template.\n\nThe following template uses a relative path (relative to the current page):\n\n```\n<script id=\"template\" type=\"text/stache\">\n\t{{>views/test_template.stache}}\n</script>\n```\n\nThe following template uses an absolute path (rooted to steal's root directory):\n\n```\n<script id=\"template\" type=\"text/stache\">\n\t{{>//myapp/accordion/views/test_template.stache}}\n</script>\n```\n\n\n",
    "description": "\n",
    "title": "{{>key}}",
    "name": "can-stache.helpers.partial",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 6,
    "signatures": [
      {
        "code": "{{>key}}",
        "description": "\n\nRender another template within the current template.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent \n[can-stache.context context]. If the value is a function or [can-compute.computed], the \nfunction's return value is used.\n\nIf the key value is:\n\n - `undefined` - the key's name (ex: user.stache in `{{>user.stache}}`).\n\n - `string` - the string value is used to lookup a view in [can.view].\n\n - `function` - the function is called with the current scope.\n\nstache looks for a template in the following places:\n\n1. A registered view\n2. An id of an element\n3. A url to load the template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The value of the rendered template is inserted into\nthe page.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A key that references a value within the current or parent \n[can-stache.context context]. If the value is a function or [can-compute.computed], the \nfunction's return value is used.\n\nIf the key value is:\n\n - `undefined` - the key's name (ex: user.stache in `{{>user.stache}}`).\n\n - `string` - the string value is used to lookup a view in [can.view].\n\n - `function` - the function is called with the current scope.\n\nstache looks for a template in the following places:\n\n1. A registered view\n2. An id of an element\n3. A url to load the template.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The value of the rendered template is inserted into\nthe page.\n\n"
    },
    "comment": " "
  },
  "can-stache.magicTagTypes": {
    "src": {
      "path": "node_modules/can-stache/docs/magicTagTypes.md"
    },
    "body": "\nRendering behavior is controled with magic tags that look like `{{}}`.  There\nare two main forms of magic tags:\n\n - Insertion tags - insert their value into the result like `{{key}}` and `{{{key}}}`.\n - Section tags - optional render a sub-section like `{{#key}} ... {{/key}}`. \n\nLets see the general behavior of each tag type:\n\n### Insertion Tags\n\nInsertion tags render a value into result.\n\n#### [can-stache.tags.escaped]\n\nInserts the escaped value of `key` into the result. This is your most common tag.\n\n```\nTemplate:\n\t<div>{{name}}</div>\n\nData:\n\t{ name: \"<b>Justin</b>\" }\n\nResult:\n\t<div>&lt;b&gt;Justin&lt;/b&gt;</div>\n```\n\n#### [can-stache.tags.unescaped]\n\nInserts the unescaped value of `key` into the result.\n\n```\nTemplate:\n\t<div>{{{name}}}</div>\n\nData:\n\t{ name: \"<b>Justin</b>\" }\n\nResult:\n\t<div><b>Justin</b></div>\n```\n\n#### [can-stache.helpers.partial]\n\nRenders another template with the same context as the current context.\n\n```\nvar template = stache(\"<h1>{{>title}}</h1>\");\n  \n\t\nvar frag = template(\n\t{message: \"Hello\"},\n\t{\n\t\tpartials: { title: \tstache(\"<blink>{{message}}</blink>”) }\n\t});\n\t\n\tfrag //-> <h1><blink>Hello</blink></h1>\n```\n\nOther ways to load and reference partials are discussed [can-stache.helpers.partial here]. \n\n#### [can-stache.tags.comment]\n\nIgnores the magic tag.\n\n```\nTemplate:\n\t<h1>{{!message}}</h1>\n\nData:\n\t{ message: \"<blink>Hello</blink>\" };\n\nResult:\n\t<h1></h1>\n```\n\n### Section Tags\n\nSection tags are passed a subsection and an optional inverse subsection. They\noptionally render the subsections and insert them into the result.\n\n#### [can-stache.tags.section {{#key}} ... {{/key}}]\n\nRenders the subsection or inverse subsection depending on the value of key.\n\nIf `key` is truthy, renders the subsection: \n\n```\nTemplate:\n\t<h1>{{#shown}}Hello{{/shown}}</h1>\n\nData:\n\t{ shown: true };\n\nResult:\n\t<h1>Hello</h1>\n```\n\nThe subsection is rendered with the `key` value as the top of the scope:\n\n```\nTemplate:\n\t<h1>{{#person}}Hello {{first}}  {{person.last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\", last: \"Abril\"} };\n\nResult:\n\t<h1>Hello Alexis Abril</h1>\n```\n\n\nIf `key` is falsey, renders the inverse subsection if present: \n\n```\nTemplate:\n\t<h1>{{#shown}}Hello{{else}}Goodbye{{/shown}}</h1>\n\nData:\n\t{ shown: false };\n\nResult:\n\t<h1>Goodbye</h1>\n```\n\nIf `key` is array-like and its `length` is greater than 0, the subsection\nis rendered with each item in the array as the top of the scope:\n\n```\nTemplate:\n\t<p>{{#items}}{{.}} {{/items}}</p>\n\nData:\n\t{items: [2,4,8,16]}\n\nResult:\n\t<p>2 4 8 16 </p>\n```\n\nIf `key` is array-like and its `length` is 0, the inverse subsection\nis rendered:\n\n```\nTemplate:\n\t<p>{{#items}}{{.}} {{else}}No items{{/items}}</p>\n\nData:\n\t{items: []}\n\nResult:\n\t<p>No items</p>\n```\n\n#### [can-stache.tags.inverse {{^key}} ... {{/key}}]\n\nThe [can-stache.tags.inverse inverse] section does the opposite of the\nnormal [can-stache.tags.section] tag.  That is, it renders\nthe subsection when [can-stache.tags.section] would render the inverse subsection \nand it renders the inverse subsection when [can-stache.tags.section] would\nrender the subsection.\n\n```\nTemplate:\n\t<h1>{{^shown}}Hello{{/shown}}</h1>\n\nData:\n\t{ shown: false };\n\nResult:\n\t<h1>Hello</h1>\n``` \n\n",
    "description": "\n## Magic tag types\n",
    "name": "can-stache.magicTagTypes",
    "title": "Magic Tag Types",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 0
  },
  "can-stache.key": {
    "src": {
      "path": "node_modules/can-stache/docs/key.md"
    },
    "body": "\n\n## Use\n\nA key references a value within the [can-view-scope scope] of a \ntemplate being rendered. In the following example, the \nkey is `name`:\n\n    <h1>{{name}}</h1>\n    \nIf this template is rendered with:\n\n    {\n      name: \"Austin\"\n    }\n\nThe template writes out:\n\n    <h1>Austin</h1>\n\nA scope is a collection of multiple contexts. By default, a \nkey walks up the scope to each context until it finds a value. For example,\na template like:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{last}}\n      {{/children}}\n\nRendered with:\n\n    {\n      first: \"Barry\", last: \"Meyer\",\n      children: [\n        {first: \"Kim\", last: \"Sully\"},\n        {first: \"Justin\"},\n      ]\n    }\n\nWrites out:\n\n    Barry Meyer\n        Kim Sully\n        Justin Meyer\n\nWhen `last` is looked up on the `{first: \"Justin\"}` object and not found,\nit will then try to read the parent context's `last` property.  This is\nwhy \"Justin Meyer\" is written out.\n\nKeys have different operators that control the values that are \nlooked up or the value that is returned:\n\n- __value lookup__ `EXPRESSION.key`\n- __current context__ `./key`\n- __parent context__ `../key`\n- __context__ `.` or `this`\n- __special__ `%special`\n- __template variable__ `*key`\n- __at__ `@key`\n- __compute__ `~key`\n\n\n\n## Default key return values by expression and data types\n\nKeys can have slightly different default behavior depending if they are used in:\n\n - [helper arguments](can-stache.expressions.html#section_Helperexpression) like: `{{helper some.key}}`\n \nwhen compared to the other places they are used:\n\n - [lookup expressions](can-stache.expressions.html#section_KeyLookupexpressions) like: `{{some.key}}`\n - [call-expression arguments](can-stache.expressions.html#section_Callexpression) like: `{{helper(some.key)}}`\n - [can-stache-bindings.can-EVENT event bindings] like: `($click)=\"method(some.key)\"`\n - [can-stache-bindings data bindings] like: `{some-attr}=\"some.key\"`\n\nFurthermore keys return different values depending on the data type.\n\nIn general:\n\n - Functions are called to get their return value. (Use the AT operator `@` to prevent this).\n - Keys in helper expression arguments that find observable data return \n   a [can-compute.computed] that represents the value. \n - Keys in other expressions return the value.\n - If no observable data is found, the key's value is returned in all expressions.\n\nThe following illustrates what `some.key` would return given\ndifferent data structures as a helper expression and in all other expressions.\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}};\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A non-observable JS object with intermeidate functions:\n{some: function(){ return {key: \"value\"}}}\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A observable can-map\n{some: new Map({key: \"value\"})}\n   // Helper -> canCompute(\"value\")\n   // Other  -> \"value\"\n\n// A method on an observable can-map that reads observables\nvar Some = Map.extend({key: function(){ return this.attr(\"value\")}})\n{some: new Some({value: \"value\"})}\n   // Helper -> canCompute(\"value\")\n   // Other  -> \"value\"\n```\n\n## context operators `./`, `../`, `.` and `this`\n\nSometimes, especially with recursive templates, you want to control which\ncontext is used to lookup.  Adding `./` before the key name will \nonly look up in the current context.\n\nThe following template:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{./last}}\n      {{/children}}\n\nRendered with:\n\n    {\n      first: \"Barry\", last: \"Meyer\",\n      children: [\n        {first: \"Kim\", last: \"Sully\"},\n        {first: \"Justin\"},\n      ]\n    }\n\nWrites out:\n\n    Barry Meyer\n        Kim Sully\n        Justin \n\nNotice that `{{./last}}` returns nothing because there's no `last` property\nin the `{first: \"Justin\"}` object.\n\n\nAdding `../` before a key will lookup the key starting in the parent \ncontext.  By changing the previous template to:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{../last}}\n      {{/children}}\n\nIt will write out:\n\n    Barry Meyer\n        Kim Meyer\n        Justin Meyer\n\nYou can use `.././last` to lookup `last` _only_ in the parent context.\n\n\nTo write out the current context, write `{{.}}` or `{{this}}`. For example,\na template like:\n\n    {{#each names}}{{.}} {{/each}}\n\nWith data like:\n\n    {names: [\"Jan\",\"Mark\",\"Andrew\"]}\n\nWill write out:\n\n    Jan Mark Andrew \n\n## at operator `@`\n\nThe AT operator indicates to return whatever value is at a key, regardless\nif it's a function or a compute.\n\nThe following illustrates what `some@key` would return given\ndifferent data structures:\n\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}} \n   //-> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   //-> function(){ return \"value\"; }\n\n// A non-observable JS object with intermeidate functions:\n{some: function(){ return {key: \"value\"}}}\n   //-> \"value\"\n\n// A observable can-map\n{some: new Map({key: \"value\"})}\n   //-> \"value\"\n\n// A method on an observable can-map that reads observables\nvar Some = Map.extend({key: function(){ return this.attr(\"value\")}})\n{some: new Some({value: \"value\"})}\n   //-> function(){ return this.attr(\"value\")}\n```\n\nWhere `some@key` returns a function, that function is \"bound\" via `.bind(context)`\nto the parent object.  This means that calling the function will\nhave `this` set to what is expected.\n\nIf the AT operator is used at the start of a key like:\n\n```\n{{method(@key)}}\n```\n\nThis will return whatever is at the `key` property on the first context in the scope\nto have a non-undefined `key` value.\n\nThe AT operator can be used multiple times within a value lookup expression like:\n\n```\n{{method(models@Todo@findAll)}}\n```\n\n\n## compute operator `~`\n\nThe compute operator can be used in non helper expressions to pass\na compute instead of a value if an observable is found.  This\nmakes non-helper expression arguments behave similar to helper \nexpression arguments.\n\nThe following illustrates what `~some.key` would return given\ndifferent data structures:\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}} \n   //-> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   //-> \"value\"\n\n// A non-observable JS object with intermeidate functions:\n{some: function(){ return {key: \"value\"}}}\n   //-> \"value\"\n\n// A observable can-map\n{some: new Map({key: \"value\"})}\n   //-> canCompute(\"value\")\n\n// A method on an observable can-map that reads observables\nvar Some = Map.extend({key: function(){ return this.attr(\"value\")}})\n{some: new Some({value: \"value\"})}\n   //-> canCompute(function(){ return this.attr(\"value\")})\n```\n\nNotice that `~` should only be used once in a value lookup expression.\n\n## template variable operator `*`\n\nEvery template contains a context which is able to store values\nlocal to the template. Keys with `*` reference variables in that context.\n\nTemplate variables are often used to pass data between \ncomponents. `<component-a>` exports its `propA` value to the\ntemplate variable `*variable`.  This is, in turn, used to update\nthe value of `propB` in `<component-b>`.\n\n```\n<component-a {^prop-a}=\"*variable\"/>\n<component-b {prop-b}=\"*variable\"/>\n```\n\nTemplate variables are global to the template. Similar to JavaScript `var` \nvariables, template variables do not have block leve scope.  The following\ndoes not work:\n\n```\n{{#each something}}\n\t<component-a {^prop-a}=\"*variable\"/>\n\t<component-b {prop-b}=\"*variable\"/>\n{{/each}}\n```\n\nTo work around this, an `localContext` helper could be created as follows:\n\n```\nstache.regsiterHelper(\"localContext\", function(options){\n  return options.fn(new Map());\n});\n```\n\nAnd used like:\n\n```\n{{#each something}}\n\t{{#localContext}}\n\t  <component-a {^prop-a}=\"./variable\"/>\n\t  <component-b {prop-b}=\"./variable\"/>\n\t{{/localContext}}\n{{/each}}\n```\n\n## special operator `%`\n\n[can-stache-bindings.can-EVENT Event bindings] and some helpers like [can-stache.helpers.each]\nprovide special values that start with `%` to prevent potential collisions with\nother values.  \n\n### %index and %key\n\nWhen looping over an array or [can-list], you an use `%index` to write out\nthe index of each property:\n\n    {{#each task}}\n      <li>{{%index}} {{name}}</li>\n    {{/each}}\n    \nIndexes start at 0.  If you want to start at 1, you can create a helper like:\n\n    stache.registerHelper('%indexNum', function(options){\n      return options.scope.attr(\"%index\")+1;\n    })\n\nAnd use it like:\n\n    {{#each task}}\n      <li>{{%indexNum}} {{name}}</li>\n    {{/each}}\n\n### %element\n\nIn an event binding, `%element` references the DOM element the event happened on:\n\n```\n<input ($click)=\"doSomething(%element.value)\"/>\n```\n\n### %event\n\nIn an event binding, `%event` references the dispatched event object:\n\n```\n<input ($click)=\"doSomething(%event)/>\"\n```\n\n### %viewModel\n\nIn an event binding, `%viewModel` references the view model of the current element:\n\n```\n<my-component (closed)=\"doSomething(%viewModel)\"/>\n```\n\n",
    "description": "A named reference to a value in the [can-view-scope scope] or  [can-view-scope.Options helper scope] in a template.\n\n",
    "type": "typedef",
    "title": "key",
    "types": [
      {
        "type": "String",
        "description": "\n\nA key specifies a value in the [can-view-scope scope] or \n[can-view-scope.Options options] of a template being rendered. The\nkey is used to look up a value in the scope.\n\nWhat the key looks like changes the behavior of how a value is looked up in \nthe scope. Keys can look like:\n\n - `{{name}}` - Single property name.\n - `{{name.first}}` - Multiple property names.\n - `{{foo\\\\.bar}}` - Single property name that includes a dot character.\n - `{{./name}}` - Single property in the current context.\n - `{{../name}}` - Single property in the parent context.\n - `{{.}}` or `{{this}}` - The current context.\n - `{{../.}}` - The parent context.\n - `{{@key}}` - Pass the value at key, even if it's a function or a compute.\n - `{{~key}}` - Pass a compute as the key's value instead of the value.\n - `{{*variable}}` - Reference a value in template scope.\n - `{{%key}}` - A special value that is added to scope. Examples:\n    - `{{%index}}` - The index of a value in an array or [can-list].\n    - `{{%key}}` - The property name of a value within an object or [can-map].\n    - `{{%element}}` - The element an event was dispatched on.\n    - `{{%event}}` - The event object.\n    - `{{%viewModel}}` - The viewModel of the current element.\n"
      }
    ],
    "name": "can-stache.key",
    "parent": "can-stache.types",
    "comment": " "
  },
  "can-stache.renderer": {
    "src": {
      "path": "node_modules/can-stache/docs/renderer.md"
    },
    "body": "\nA \"renderer\" function is a function returned by various [can.view] APIs that can be used\nto render data into a documentFragment.\n\n",
    "description": "A function returned by [can-stache] that renders a  template into an html documentFragment.\n\n",
    "type": "typedef",
    "title": "renderer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ],
          "description": "A documentFragment that contains the HTML rendered by the template.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "An object of data used to render the template.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "helpers",
            "description": "Local helper functions used by the template. \n"
          }
        ]
      }
    ],
    "name": "can-stache.renderer",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                }
              ]
            }
          ]
        }
      ],
      "name": "helpers",
      "description": "Local helper functions used by the template. \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        }
      ],
      "description": "A documentFragment that contains the HTML rendered by the template.\n"
    },
    "comment": " "
  },
  "can-stache.safeString": {
    "src": {
      "path": "node_modules/can-stache/docs/safeString.md"
    },
    "body": "\nIf you write a helper that generates its own HTML, you will\nusually want to return a `stache.safeString.` In this case,\nyou will want to manually escape parameters with [can-util/js/strin/string.esc].\n\n\n    stache.registerHelper('link', function(text, url) {\n      text = string.esc(text);\n      url  = string.esc(url);\n    \n      var result = '<a href=\"' + url + '\">' + text + '</a>';\n      return stache.safeString(result);\n    });\n\n\nRendering:\n\n```\n<div>{{link \"Google\", \"http://google.com\"}}</div>\n```\n\nResults in:\n\n```\n<div><a href=\"http://google.com\">Google</a></div>\n```\n\nAs an anchor tag whereas if we would have just returned the result rather than a\n`stache.safeString` our template would have rendered a div with the escaped anchor tag.\n\n\n",
    "description": "\n",
    "title": "safeString",
    "name": "can-stache.safeString",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.safeString(str)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "A string you don't want to become escaped."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A string flagged by `mustache` as safe, which will\nnot become escaped, even if you use [can-stache.tags.unescaped](triple slash).\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "A string you don't want to become escaped."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A string flagged by `mustache` as safe, which will\nnot become escaped, even if you use [can-stache.tags.unescaped](triple slash).\n"
    },
    "comment": " "
  },
  "can-stache.Sections": {
    "src": {
      "path": "node_modules/can-stache/docs/sections.md"
    },
    "body": "\nThe most basic form of section will simply render a section of code if the key referenced is considered **truthy** (has a value):\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\n\tData:\n\t\t{\n\t\t\tperson: {\n\t\t\t\tname: \"Andy\"\n\t\t\t}\n\t\t}\n\n\tResult:\n\t\tHello!\n\t\tAndy\n\nWhenever the key doesn't exist or the value is **falsey**, the section won't be rendered:\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\n\tData:\n\t\t{}\n\n\tResult:\n\t\tHello!\n\nHowever, this scenario can be covered through the use of an inverse section \n(`[can-stache.tags.inverse {{^key}}]` followed by `[can-stache.tags.close {{/key}}]`):\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\t\t{{^person}}\n\t\t\tNo one is here.\n\t\t{{/person}}\n\n\tData:\n\t\t{}\n\n\tResult:\n\t\tHello!\n\t\tNo one is here.\n\n## Iteration\n\nThere is a special case for sections where the key references an array. In this case, the section iterates \nthe entire array, rendering the inner text for each item in the array. Arrays are considered **truthy** if \nthey aren't empty. The `{{.}}` tag will reference the current item within the array during iteration (which is \nprimarily used when the items in the array are primitives like strings and numbers).\n\n\tTemplate:\n\t\t{{#people}}\n\t\t\t{{.}} \n\t\t{{/people}}\n\n\tData:\n\t\t{\n\t\t\tpeople: [\"Andy\", \"Austin\", \"Justin\"]\n\t\t}\n\n\tResult:\n\t\tAndy Austin Justin\n\n## Understanding when to use Sections with lists\n\nSection iteration will re-render the entire section for any change in the list. It is the prefered method to\nuse when a list is replaced or changing significantly. Whereas [can-stache.helpers.each {{#each key}}] iteration\nwill do basic diffing and aim to only update the DOM where the change occured. When doing single list item\nchanges frequently, [can-stache.helpers.each {{#each key}}] iteration is the faster choice.\n\nFor example, assuming \"list\" is a [can-list] instance:\n\n{{#if list}} will check for the truthy value of list. This is akin to checking for the truthy value of any JS object and will result to true, regardless of list contents or length.\n\n{{#if list.length}} will check for the truthy value of the length attribute. If you have an empty list, the length will be 0, so the #if will result to false and no contents will be rendered. If there is a length >= 1, this will result to true and the contents of the #if will be rendered.\n\n{{#each list}} and {{#list}} both iterate through an instance of [can-list], however we setup the bindings differently.\n\n{{#each list}} will setup bindings on every individual item being iterated through, while {{#list}} will not. This makes a difference in two scenarios:\n\n1) You have a large list, with minimal updates planned after initial render. In this case, {{#list}} might be more advantageous as there will be a faster initial render. However, if any part of the list changes, the entire {{#list}} area will be re-processed.\n\n2) You have a large list, with many updates planned after initial render. A grid with many columns of editable fields, for instance. In this case, you many want to use {{#each list}}, even though it will be slower on initial render(we're setting up more bindings), you'll have faster updates as there are now many sections.\n\n",
    "description": "\nSections (`[can-stache.tags.section {{#key}}]` followed by `[can-stache.tags.close {{/key}}]`) have multiple uses \ndepending on what type of object is passed to the section. In all cases, using a section will change \nthe current [can-stache.context context].\n",
    "name": "can-stache.Sections",
    "title": "Sections",
    "type": "page"
  },
  "can-stache.sectionRenderer": {
    "src": {
      "path": "node_modules/can-stache/docs/sectionRenderer.md"
    },
    "body": "\n## Use\n\nRenderer functions are provided to stache [can-stache.helper helpers] on \nthe [can-stache.helperOptions options] argument and are used to render the\ncontent between sections. The `context` and `helpers` option let you control\nthe data and helpers used to render the section.\n\nThe following example adds `{first: \"Justin\"}` to the lookup \ndata. Notice how the section has access to `first` and `last`.\n\n    stache.registerHelper(\"myhelper\", function(options){\n      var section = options.fn({first: \"Justin\"});\n      return $(\"<h1>\").append( section );\n    })\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1>Justin Meyer</h1>\n\nIf no `context` is provided, the current context is passed.  Notice\nhow the section has access to `last`:\n\n    stache.registerHelper(\"myhelper\", function(options){\n      \n       var section = options.fn();\n       return $(\"<h1>\").append( section );\n      \n    });\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1> Meyer</h1>\n    \nIf a [can-view-scope] is provided, it is used to render the \nsection. Notice how `last` is not available in the section:\n\n    stache.registerHelper(\"myhelper\", function(options){\n      \n      var section = options.fn( new Scope( {first: \"Justin\"}) );\n      return $(\"<h1>\").append( section );\n      \n    });\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1>Justin </h1>\n\n\n\n\n",
    "description": "Renders a section. These functions are usually provided as `.fn` and `.inverse` on a stache helper's [can-stache.helperOptions options].\n\n",
    "type": "typedef",
    "title": "sectionRenderer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            },
            {
              "type": "String"
            }
          ],
          "description": "Returns the rendered result of the helper. If the\nsection is within a tag, like:\n\n    <h1 {{#helper}}class='power'{{/helper}}>\n\na String is returned.  \n\nIf the section is outside a tag like: \n\n    <div> {{#helper}}<h2>Tasks</h2>{{/helper}} </div>\n    \na documentFragment is returned.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-view-scope"
              }
            ],
            "optional": true,
            "name": "context",
            "description": "Specifies the data the section is rendered \nwith.  If a [can-view-scope] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current scope as it's parent.  If nothing is provided, the current\nscope is used to render the section.\n"
          },
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-view-scope.Options"
              }
            ],
            "optional": true,
            "name": "helpers",
            "description": "Specifies the helpers the section is rendered \nwith.  If a [can-view-scope.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.\n"
          }
        ]
      }
    ],
    "name": "can-stache.sectionRenderer",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "can-view-scope.Options"
        }
      ],
      "optional": true,
      "name": "helpers",
      "description": "Specifies the helpers the section is rendered \nwith.  If a [can-view-scope.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        },
        {
          "type": "String"
        }
      ],
      "description": "Returns the rendered result of the helper. If the\nsection is within a tag, like:\n\n    <h1 {{#helper}}class='power'{{/helper}}>\n\na String is returned.  \n\nIf the section is outside a tag like: \n\n    <div> {{#helper}}<h2>Tasks</h2>{{/helper}} </div>\n    \na documentFragment is returned.\n"
    },
    "comment": " "
  },
  "can-stache.simpleHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/simplehelper.md"
    },
    "body": "\nstache.simpleHelper\n\n## Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create mustache tags that have rich behavior.\n\nIf the helper is called __within a tag__ like:\n\n    <ul {{sortable}}/>\n\nThe returned function is called with the `<ul>` element:\n\n    stache.registerSimpleHelper(\"sortable\",function(){\n      return function(el){\n        $(el).slider();\n      }\n    });\n\nIf the helper is called __between tags__ like:\n\n    <ul>{{items}}</ul>\n\nThe returned function is called with a temporary element. The\nfollowing helper would be called with a temporary `<li>` element:\n\n    stache.registerSimpleHelper(\"items\",function(){\n      return function(li){\n\n      }\n    });\n\nThe temporary element depends on the parent element. The default temporary element\nis a `<span>` element.\n\n\n\n\n",
    "description": "A helper function passed to [can-stache.registerSimpleHelper]. \n",
    "type": "typedef",
    "title": "simpleHelper",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "HTMLElement"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The content to be inserted into\nthe template.\n"
        },
        "params": [
          {
            "variable": true,
            "types": [
              {
                "type": "*"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-stache.sectionOptions"
              }
            ]
          },
          {
            "variable": true,
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "arg",
            "description": "Arguments passed from the tag. After the helper\nname, any space seperated [can-stache.key keys], numbers or\nstrings are passed as arguments.\n\nThe following template:\n\n    <p>{{madLib \"Lebron James\" verb 4}}</p>\n\nRendered with\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements.\n\n    stache.registerSimpleHelper('madLib',\n      function(subject, verb, number){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n    });\n\nUnlike [can-stache.helper] simple helpers will always pass the actual\nvalue (instead of a compute).\n"
          },
          {
            "types": [
              {
                "type": "can-stache.helperOptions"
              }
            ],
            "name": "options",
            "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "can-stache.context"
            }
          ],
          "description": "The context the helper was\ncalled within.\n"
        }
      }
    ],
    "name": "can-stache.simpleHelper",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helperOptions"
        }
      ],
      "name": "options",
      "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ]
            }
          ]
        }
      ],
      "description": "The content to be inserted into\nthe template.\n"
    },
    "comment": " "
  },
  "can-stache.pages": {
    "name": "can-stache.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 0
  },
  "can-stache.static": {
    "name": "can-stache.static",
    "title": "Methods",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 1
  },
  "can-stache.types": {
    "name": "can-stache.types",
    "title": "Types",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 2
  },
  "can-stache.tags": {
    "name": "can-stache.tags",
    "title": "Basic Tags",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 3
  },
  "can-stache.htags": {
    "name": "can-stache.htags",
    "title": "Helper Tags",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 4
  },
  "can-stache": {
    "src": {
      "path": "node_modules/can-stache/docs/stache.md"
    },
    "body": "\n\n\n## Use\n\nStache templates are a [mustache](https://mustache.github.io/mustache.5.html) and [handlebars](http://handlebarsjs.com/) compatable \nsyntax.  They are used to:\n\n- Convert data into HTML.\n- Update the HTML when observable data changes.\n- Provide custom elements and bindings.\n\nThe following \ncreates a stache template, renders it with data, and inserts\nthe result into the page:\n\n```\n// renderer is a \"renderer function\"\nvar renderer = stache(\"<h1>Hello {{subject}}</h1>\");\n\n// \"renderer functions\" render a template and return a\n// document fragment.\nvar fragment = renderer({subject: \"World\"})\n\n// A document fragment is a collection of elements that can be \n// used with jQuery or with normal DOM methods.\nfragment //-> <h1>Hello World</h1>\ndocument.body.appendChild(fragment)\n``` \n\nRender a template with observable data like [can-map]s or [can-list]s and the HTML will update\nwhen the observable data changes.\n\n```\nvar renderer = stache(\"<h1>Hello {{subject}}</h1>\");\nvar map = new Map({subject: \"World\"});\nvar fragment = renderer(map)\ndocument.body.appendChild(fragment)\n\nmap.attr(\"subject\",\"Earth\");\n\ndocument.body.innerHTML //-> <h1>Hello Earth</h1>\n``` \n\nThere's a whole lot of behavior that `stache` provides.  The following walks through\nthe most important stuff:\n\n- [can-stache.magicTagTypes] - The different tag types like `{{key}}` and `{{#key}}...{{/key}}`\n- [can-stache.scopeAndContext] - How key values are looked up.\n- [can-stache.expressions] - Supported expression types like `{{helper arg}}` and `{{method(arg)}}`\n- [can-stache.Acquisition] - How to load templates into your application.\n- [can-stache.Helpers] - The built in helpers and how to create your own.\n- [can-stache.Binding] - How live binding works.\n\n## Differences from [can-mustache]\n`stache` is largely compatable with [can-mustache].  There are three main differences:\n\n - Passes values in the scope to [can-component] with `{key}`.\n - [can-stache.sectionRenderer section renderers] return documentFragments.\n - [can-mustache.helpers.elementCallback Element callbacks] like `{{(el) -> CODE}}` are no longer supported.\n\n\n### Passing values in the scope to Components\nA [can-mustache] template passes values from the scope to a [can-component]\nby specifying the key of the value in the attribute directly.  For example:\n\n    Component.extend({\n      tag: \"my-tag\",\n      template: \"<h1>{{greeting}}</h1>\"\n    });\n    var template = mustache(\"<my-tag greeting='message'></my-tag>\");\n\n    var frag = template({\n      message: \"Hi\"\n    });\n\n    frag //-> <my-tag greeting='message'><h1>Hi</h1></my-tag>\n\nWith stache, you wrap the key with `{}`. For example:\n\n    Component.extend({\n      tag: \"my-tag\",\n      template: \"<h1>{{greeting}}</h1>\"\n    });\n    var template = stache(\"<my-tag greeting='{message}'></my-tag>\");\n\n    var frag = template({\n      message: \"Hi\"\n    });\n\n    frag //-> <my-tag greeting='{message}'><h1>Hi</h1></my-tag>\n\nIf the key was not wrapped, the template would render:\n\n    frag //-> <my-tag greeting='message'><h1>message</h1></my-tag>\n\nBecause the attribute value would be passed as the value of `greeting`.\n\n### Section renderers return documentFragments\n\nA [can-mustache.sectionRenderer Mustache section renderer] called\nlike `options.fn()` or `options.inverse()` would always return a String. For example,\nthe following would wrap the `.fn` section in an `<h1>` tag:\n\n    mustache.registerHelper(\"wrapH1\", function(options.fn()){\n       return \"<h1>\"+options.fn()+\"</h1>\";\n    });\n\n    var template = mustache(\"{{#wrapH1}}Hi There!{{/#wrapH1}}\");\n    template() //-> <h1>Hi There</h1>\n\n`stache`'s [can-stache.sectionRenderer section renderers] return documentFragments when sections\nare not contained within an html element. This means the result of the previous helper would be:\n\n    <h1>[object DocumentFragment]</h1>\n\nInstead, helper functions should manipulate the document fragment into the desired response.  With\njQuery, this can be done like:\n\n    stache.registerHelper(\"wrapH1\", function(options.fn()){\n       return $(\"<h1>\").append( options.fn() );\n    });\n\n    var template = stache(\"{{#wrapH1}}Hi There!{{/#wrapH1}}\");\n    template() //-> <h1>Hi There</h1>\n\n\n### Element callbacks are no longer supported\n\n`can-mustache` supported [can-mustache.helpers.elementCallback element callbacks] like `{{(el) -> CODE}}`. These\nare not supported in `stache`.  Instead, create a helper that returns a function or register\na [can-view-callbackr.attr custom attribute].\n\n    stache.registerHelper(\"elementCallback\", function(){\n      return function(el){\n        CODE\n      }\n    });\n\n    viewCallbacks.tag(\"element-callback\", function(el){\n      CODE\n    })\n\n## Tags\n\n\n",
    "description": "Live binding Mustache and Handlebars-comptable templates. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-stache",
    "parent": "can-core",
    "release": "2.1",
    "link": "../docco/view/stache/mustache_core.html docco",
    "test": "can/view/stache/test/test.html",
    "plugin": "can/view/stache",
    "download": "http://canjs.us/release/latest/can.stache.js",
    "signatures": [
      {
        "code": "stache(template)",
        "description": "\n\nProcesses the template and returns a renderer function that renders the template\nwith data and local helpers.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "The text of a mustache template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A [can-stache.renderer renderer] function that returns a live document fragment\nthat can be inserted in the page.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "template",
      "description": "The text of a mustache template.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A [can-stache.renderer renderer] function that returns a live document fragment\nthat can be inserted in the page.\n"
    },
    "comment": " ",
    "api": "can-stache.tags"
  },
  "can.stache.Lookup": {
    "src": {
      "line": 23,
      "codeLine": 30,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "type": "typedef",
    "body": "",
    "description": "",
    "hide": true,
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "types": [
              {
                "type": "String"
              }
            ],
            "description": "A value in the scope to look up.\n"
          }
        ]
      }
    ],
    "name": "can.stache.Lookup"
  },
  "makeEvaluator": {
    "type": "function",
    "name": "makeEvaluator",
    "params": [
      {
        "name": "scope",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "helperOptions",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "nodeList",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": "Either null, #, ^. > is handled elsewhere"
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "exprData",
        "description": "Data about what was in the mustache expression"
      },
      {
        "types": [
          {
            "type": "renderer"
          }
        ],
        "optional": true,
        "name": "truthyRenderer",
        "description": "Used to render a subsection"
      },
      {
        "types": [
          {
            "type": "renderer"
          }
        ],
        "optional": true,
        "name": "falseyRenderer",
        "description": "Used to render the inverse subsection"
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "optional": true,
        "name": "stringOnly",
        "description": "A flag to indicate that only strings will be returned by subsections."
      },
      {
        "types": [
          {
            "type": "can.view.Options"
          }
        ],
        "name": "The",
        "description": "option helpers in which the expression is evaluated."
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 70,
      "codeLine": 82,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Given a mode and expresion data, returns a function that evaluates that expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "stringOnly",
      "description": "A flag to indicate that only strings will be returned by subsections."
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "An 'evaluator' function that evaluates the expression.\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "An 'evaluator' function that evaluates the expression.\n "
    }
  },
  "makeLiveBindingPartialRenderer": {
    "type": "function",
    "name": "makeLiveBindingPartialRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "partialName",
        "description": "the name of the partial."
      },
      {
        "name": "state",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 179,
      "codeLine": 186,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns a renderer function that live binds a partial.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "partialName",
      "description": "the name of the partial."
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            }
          ],
          "context": {
            "types": [
              {
                "type": "HTMLElement"
              }
            ]
          }
        }
      ],
      "description": "A renderer function\nlive binds a partial.\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            }
          ],
          "context": {
            "types": [
              {
                "type": "HTMLElement"
              }
            ]
          }
        }
      ],
      "description": "A renderer function\nlive binds a partial.\n "
    }
  },
  "makeStringBranchRenderer": {
    "type": "function",
    "name": "makeStringBranchRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": ""
      },
      {
        "name": "expressionString",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 238,
      "codeLine": 245,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Return a renderer function that evaluates to a string.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "can.stache.Expression"
        }
      ],
      "name": "expression",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can.view.Scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-stache.renderer"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.renderer"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can.view.Scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-stache.renderer"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.renderer"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "makeLiveBindingBranchRenderer": {
    "type": "function",
    "name": "makeLiveBindingBranchRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": ""
      },
      {
        "name": "expressionString",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The html state of where the expression was found.\n "
      },
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 279,
      "codeLine": 286,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns a renderer function that evaluates the mustache expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The html state of where the expression was found.\n "
    }
  },
  "splitModeFromExpression": {
    "type": "function",
    "name": "splitModeFromExpression",
    "params": [
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The state of HTML where the expression was found.\n "
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 381,
      "codeLine": 387,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns the mustache mode split from the rest of the expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The state of HTML where the expression was found.\n "
    }
  },
  "cleanLineEndings": {
    "type": "function",
    "name": "cleanLineEndings",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "template",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 407,
      "codeLine": 413,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Prunes line breaks accoding to the mustache specification.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "template",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    }
  },
  "Options": {
    "name": "Options",
    "type": "property",
    "parent": "node_modules/can-stache/src/utils.js",
    "src": {
      "line": 7,
      "codeLine": 11,
      "path": "node_modules/can-stache/src/utils.js"
    },
    "body": " \n",
    "description": "The Options scope.\n",
    "hide": true
  },
  "can-stache-bindings": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/bindings.md"
    },
    "body": "\n\n## Use\n\nThe `can-stache-bindings` plugin provides [can-view-callbacks.attr custom attributes] useful for template declarative event, one-way and two-way \nbindings on element attributes, component [can-component::viewModel viewModels], and the [can-view-scope scope]. Bindings look like:\n\n- `(event)=\"key()\"` for event binding.\n- `{prop}=\"key\"` for one-way binding to a child.\n- `{^prop}=\"key\"` for one-way binding to a parent.\n- `{(prop)}=\"key\"` for two-way binding.\n\nAdding $ to a binding like `($event)=\"key()\"` changes the binding from the `viewModel` to the element's attributes or properties.\n\nThe following are the bindings that should be used with [can-stache] and are compatible with the upcoming \n3.0 release:\n\n#### [can-stache-bindings.event event]\n\nBinds to `childEvent` on `<my-component>`'s [can-component::viewModel viewModel] and calls \n`method` on the [can-view-scope scope] with the specified arguments:\n\n```\n<my-component (child-event)=\"method('primitive', key, hash1=key1)\"/>\n```\n\nBinds to `domEvent` on `<my-component>` and calls \n`method` on the [can-view-scope scope] with the specified arguments.\n\n```\n<my-component ($dom-event)=\"method('primitive', key, hash1=key1)\"/>\n```\n\n#### [can-stache-bindings.toChild one-way to child]\n\nUpdates `childProp` in `<my-component>`'s [can-component::viewModel viewModel] with `value` in the [can-view-scope scope]:\n\n```\n<my-component {child-prop}=\"value\"/>\n```\n\nUpdates the `child-attr` attribute or property on `<my-component>` with `value` \nin the [can-view-scope scope]:\n\n```\n<my-component {$child-attr}=\"value\"/>\n```\n\n#### [can-stache-bindings.toParent one-way to parent]\n\nUpdates `value` in the [can-view-scope scope]  with `childProp` \nin `<my-component>`'s [can-component::viewModel viewModel]:\n\n```\n<my-component {^child-prop}=\"value\"/>\n```\n\nUpdates `value` \nin the [can-view-scope scope] with the `child-attr` attribute or property on `<my-component>`:\n\n```\n<my-component {^$child-attr}=\"value\"/>\n```\n\n#### [can-stache-bindings.twoWay two-way]\n\nUpdates `childProp` in `<my-component>`'s [can-component::viewModel viewModel] with `value` in the [can-view-scope scope] and vice versa:\n\n```\n<my-component {(child-prop)}=\"value\"/>\n```\n\nUpdates the `child-attr` attribute or property on `<my-component>` with `value` \nin the [can-view-scope scope] and vice versa:\n\n```\n<my-component {($child-attr)}=\"value\"/>\n```\n\n\n",
    "description": "\nProvides template event, one-way, and two-way bindings. \n",
    "type": "module",
    "title": "",
    "name": "can-stache-bindings",
    "parent": "can-core",
    "link": "../docco/view/bindings/bindings.html docco",
    "comment": " "
  },
  "can-stache-bindings.can-EVENT": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/can-event.md"
    },
    "body": "\n\n## Use\n\nBy adding `can-EVENT='methodKey'` to an element, the function pointed to\nby `methodKey` is bound to the element's `EVENT` event. The function can be\npassed any number of arguments from the surrounding scope, or `name=value`\nattributes for named arguments. Direct arguments will be provided to the\nhandler in the order they were given, except `name=value` arguments, which\nwill all be given as part of a `hash` argument inserted after all direct\narguments.\n\nIf no `argKey`s or `hashKey`s are provided, the methodKey will be called with the\n`@content`, `@element` and `@event` as arguments.\n\nThe following uses `can-click={items.splice @index 1}` to remove a\nitem from `items` when that item is clicked on.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/can-event-args.html'></div>\n\n## Special Event Types\n\ncan.view.bindings supports creating special event types \n(events that aren't natively triggered by the DOM), which are \nbound by adding attributes like `can-SPECIAL='KEY'`. This is \nsimilar to [$.special](http://benalman.com/news/2010/03/jquery-special-events/).\n\n### can-enter / (enter)\n\ncan-enter is a special event that calls its handler whenever the enter \nkey is pressed while focused on the current element. For example: \n\n\t<input type='text' can-enter='{save}' />\n\nThe above template snippet would cause the save method \n(in the [can.mustache Mustache] [can-view-scope scope]) whenever \nthe user hits the enter key on this input.\n\n",
    "description": "\n",
    "title": "can-EVENT",
    "name": "can-stache-bindings.can-EVENT",
    "type": "function",
    "deprecated": [
      {
        "version": "2.2",
        "description": "Use [can.view.bindings.event event binding] (`($EVENT)=\"METHOD()\"`) instead.\n"
      }
    ],
    "signatures": [
      {
        "code": "(EVENT)='{methodKey [argKey..] [hashName=hashKey...]}'",
        "description": "\n\nSpecify a callback function to be called on a particular event. This is a shorthand for `can-EVENT` attributes.\n",
        "params": []
      },
      {
        "code": "can-EVENT='{methodKey [argKey..] [hashName=hashKey...]}'",
        "description": "\n\nSpecify a callback function to be called on a particular event. You can create your own special event types.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "EVENT",
            "description": "A event name like `click` or `keyup`.  If you are\nusing jQuery, you can listen to jQuery special events too.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "methodKey",
            "description": "A named key value in the current scope.  The value\nshould be a function.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "optional": true,
            "name": "argKey",
            "variable": true,
            "description": "Key values that will be passed as\narguments to the `methodKey` function value.  Key values can \nbe read from the scope, or literals like `\"foo\"`, `1`, etc.\n\nThe following key values are also supported:\n\n - `@element` - The element the event happened upon.\n - `@event` - The event object.\n - `@viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `@context` - The current context.\n - `@scope` - The current [can-view-scope Scope].\n\nIf no `argKey`s or `hashKey`s are provided, the methodKey will be called with the\n`@context`, `@element` and `@event` as arguments.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "hashName",
            "description": "A property name \nthat gets added to the `hash` argument.  The hash argument is the\nlast value passed to the function specified by `methodKey`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "hashKey",
            "description": "Specifies value that is added \nto the `hash` argument for a `hashName` value.  `hashKey` supports\nthe same key values as `argKey`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "hashKey",
      "description": "Specifies value that is added \nto the `hash` argument for a `hashName` value.  `hashKey` supports\nthe same key values as `argKey`.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.event": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/event.md"
    },
    "body": "\n## Use\n\nThe use of `(event)` bindings changes between listening on __DOM events__ and __viewModel events__.\n\n## DOM events\n\nTo listen on a DOM event, wrap the event name with `($event)` like:\n\n```\n<div ($click)=\"doSomething()\"/>\n```\n\nBy adding `($EVENT)='methodKey()'` to an element, the function pointed to\nby `methodKey` is bound to the element's `EVENT` event. The function can be\npassed any number of arguments from the surrounding scope, or `name=value`\nattributes for named arguments. Direct arguments will be provided to the\nhandler in the order they were given.\n\nThe following uses `($click)=\"items.splice(%index,1)\"` to remove a\nitem from `items` when that item is clicked on.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/event-args.html'></div>\n\n### Special Event Types\n\n[can-stache-bindings] supports creating special event types \n(events that aren't natively triggered by the DOM), which are \nbound by adding attributes like `($SPECIAL)='KEY'`. This is \nsimilar to [$.special](http://benalman.com/news/2010/03/jquery-special-events/).\n\n### ($enter)\n\n`($enter)` is a special event that calls its handler whenever the enter \nkey is pressed while focused on the current element. For example: \n\n\t<input type='text' ($enter)='save()' />\n\nThe above template snippet would call the save method \n(in the [can-view-scope scope]) whenever \nthe user hits the enter key on this input.\n\n## viewModel events\n\nTo listen on a [can-component Component's] [can-component::viewModel viewModel], wrap the event name with `(event)` like:\n\n```\n<player-edit \n  \t(close)=\"removeEdit()\" \n  \t{player}=\"editingPlayer\"/>\n```\n\nViewModels can publish events on themselves. The following `<player-edit>` component\n dispatches a `\"close\"` event on itself when its `close` method is called:\n\n```\nComponent.extend({\n  tag: \"player-edit\",\n  template: can.view('player-edit-stache'),\n  viewModel: {\n    close: function(){\n      this.dispatch(\"close\");\n    }\n  }\n});\n```\n\nThe following demo uses this ability to create a close button that \nhides the player editor:\n\n<div class='demo_wrapper' data-demo-src='can/component/examples/paginate_next_event.html'></div>\n\n",
    "description": "Listen to events on elements or component view models. \n",
    "title": "(event)",
    "name": "can-stache-bindings.event",
    "type": "function",
    "parent": "can-stache-bindings",
    "order": 0,
    "signatures": [
      {
        "code": "($DOM_EVENT)='CALL_EXPRESSION'",
        "description": "\n\nSpecify a callback function to be called on a particular DOM event.\n\n```\n<div ($click)=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "DOM_EVENT",
            "description": "A DOM event name like \"click\". jQuery custom events can also\nbe given. \n"
          },
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression like `method(key)` that is called when the `DOM_EVENT` \nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `$element` - The element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope scope].\n"
          }
        ]
      },
      {
        "code": "(VIEW_MODEL_EVENT)='CALL_EXPRESSION'",
        "description": "\n\nSpecify a callback function to be called on a particular [can-component::viewModel viewModel] event.\n\n```\n<my-component (show)=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "DOM_EVENT",
            "description": "A DOM event name like \"click\". jQuery custom events can also\nbe given. \n"
          },
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression like `method(key)` that is called when the `DOM_EVENT` \nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `$element` - The [can.$] wrapped element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope].\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.expressions"
        }
      ],
      "name": "CALL_EXPRESSION",
      "description": "A call expression like `method(key)` that is called when the `DOM_EVENT` \nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `$element` - The [can.$] wrapped element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope].\n\n"
    },
    "comment": " "
  },
  "can-stache-bindings.can-value": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/can-value.md"
    },
    "body": "\n\n## Use\n\nAdd a `can-value=\"KEY\"` attribute to an input or select element and\nthe element's value will be cross-bound to an observable value specified by `KEY`.\n\nDepending on the element and the element's type, `can-value` takes on\ndifferent behaviors.  If an input element has a type\nnot listed here, the behavior is the same as the `text` type.\n\n## input type=text\n\nCross binds the input's string text value with the observable value.\n\nThe value of the observable is changed after the input's `change` event,\nwhich is after `blur`.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/hyperloop.html'></div>\n\n## input type=checkbox\n\nCross binds the checked property to a true or false value. An alternative\ntrue and false value can be specified by setting `can-true-value` and\n`can-false-value` attributes.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/input-checkbox.html'></div>\n\n## input type='radio'\n\nIf the radio element is checked, sets the observable specified by `can-value` to match the value of `value` attribute.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/input-radio.html'></div>\n\n## select\n\nCross binds the selected option value with an observable value.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/select.html'></div>\n\n## textarea\n\nCross binds the textarea's string text value with the observable value.\n\nThe value of the observable is changed after the textarea's `change` event,\nwhich is after `blur`.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/textarea.html'></div>\n\n",
    "description": "\nSets up two way bindings in a template.\n",
    "title": "can-value",
    "name": "can-stache-bindings.can-value",
    "type": "function",
    "deprecated": [
      {
        "version": "2.3",
        "description": "Use [can-stache-bindings.twoWay two way binding] like `{($value)}=\"KEY\"` instead.\n"
      }
    ],
    "signatures": [
      {
        "code": "can-value='KEY'",
        "description": "\n\nBinds the element's value or checked property to the value specified by\nkey. Example:\n\n    <input type='text' can-value='first.name'/>\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A named value in the current scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-mustache.key"
        }
      ],
      "name": "key",
      "description": "A named value in the current scope.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.can-value-checkbox": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/input-checkbox.md"
    },
    "body": "\n\n## Use\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/input-checkbox.html'></div>\n\n## Using can-true-value\n\nAn alternative true and false value can be specified by setting `can-true-value` and\n`can-false-value` attributes.  This is used for setting up a \"boolean\" property that only has two possible valid values, \nwhose values are modelled by the true/false checked property of a checkbox, as in the following example:\n\n\t<input type='checkbox' can-value='sex' can-true-value='male' can-false-value='female'/>\n\nIn this case, the data passed in contains a 'sex' property which is either 'male' or 'female'. Specifying the string values for true and false in the attributes forces the data to two way bind using these string properties.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/input-checkbox-trueval.html'></div>\n\n",
    "description": "\nCross bind a value to a checkbox.\n",
    "title": "input type=checkbox",
    "name": "can-stache-bindings.can-value-checkbox",
    "type": "function",
    "parent": "can-stache-bindings.can-value",
    "signatures": [
      {
        "code": "<input type='checkbox' can-value='KEY' can-true-value='TRUEVALUE' can-false-value='FALSEVALUE'/>",
        "description": "\n\nCross binds the checked property to a true or false value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current scope.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "TRUEVALUE",
            "description": "Used to set the checked value of `KEY`.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "FALSEVALUE",
            "description": "Used to set the unchecked value of `KEY`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "FALSEVALUE",
      "description": "Used to set the unchecked value of `KEY`.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.reference": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/reference.md"
    },
    "body": "\n## Use\n\nExport a view model to the references scope by adding an attribute with the \nhypenated name of the reference scope property:\n\n```\n<year-selector *year-selector />\n```\n\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/reference-one-way.html'></div>\n\n",
    "description": "Export a viewModel into a template's references scope. \n",
    "title": "*REFERENCE",
    "name": "can-stache-bindings.reference",
    "type": "function",
    "parent": "can-stache-bindings",
    "order": 4,
    "signatures": [
      {
        "code": "*ref-prop",
        "description": "\n\n  A shorthand for exporting an element's viewModel to the reference scope.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "ref-prop",
            "description": "The name of the property to set in the template's 'references' scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "ref-prop",
      "description": "The name of the property to set in the template's 'references' scope.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.can-value-radio": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/input-radio.md"
    },
    "body": "\n\n## Use\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/input-radio.html'></div>\n\n",
    "description": "\nCross bind a value to a radio input.\n",
    "title": "input type=radio",
    "name": "can-stache-bindings.can-value-radio",
    "type": "function",
    "parent": "can-stache-bindings.can-value",
    "signatures": [
      {
        "code": "<input type='radio' can-value='KEY' value='VALUE'/>",
        "description": "\n\nIf the radio element is checked, sets the observable specified by `can-value` to match the value of \n`value` attribute.  \n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current scope. It should reference a\na [can-map] property or a [can-compute.computed].\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "VALUE",
            "description": "Used to set the value of `KEY` when the radio input is checked.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "VALUE",
      "description": "Used to set the value of `KEY` when the radio input is checked.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.can-value-select-multiple": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/select-multiple.md"
    },
    "body": "\n\n## Use\n\nSelect elements with the multiple attribute (`<select multiple can-value=\"KEY\"/>`)\nhave a specified behavior if the value of KEY is Array like, a String, or \nundefined.\n\n## Cross binding to Arrays\n\n`<select>` tags with a multiple attribute cross bind\na [can-map] property, [can-compute.computed] or [can-list]\nin sync with the selected items of the `<select>` element.\n\nFor example, the following template:\n\n    <select multiple can-value=\"colors\">\n      <option value='red'>Red</option>\n      <option value='green'>Green</option>\n      <option value='yellow'>Yellow</option>\n    </select>\n\nCould be rendered with one of the following:\n\n    // A can-map property\n    new Map({colors: []})\n\n    // A compute\n    { colors: canCompute([]) }\n\n    // A can.List\n    { colors: new List() }\n    \n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/select_multiple.html'></div>\n\n## Cross binding Strings\n\nIf the [can-map] property or [can-compute.computed] value is a \nstring like:\n\n    new Map({color: \"red;green\"});\n    { colors: canCompute(\"red;green\") }\n\nThe string will be split by `\";\"`. The items in the split\nstring are used as values to match against `<option>` tag values.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/select_multiple_string.html'></div>\n\n## Cross binding undefined \n\nIf the `KEY` value begins as undefined [can-map] property like:\n\n    new Map({colors: undefined});\n    \nThe property will be converted to a [can-list].\n\nIf the `KEY` value begins as an undefined [can-compute.computed] like:\n    \n    {colors: canCompute()}\n\nThe value of the compute will be set to an array.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/select_multiple_undefined.html'></div>\n\n",
    "description": "\nCross bind a value to a `<select>` element with multiple selections permitted.\n",
    "title": "select multiple",
    "name": "can-stache-bindings.can-value-select-multiple",
    "type": "function",
    "parent": "can.view.bindings.can-value",
    "release": "2.1",
    "signatures": [
      {
        "code": "<select multiple can-value='KEY'/>",
        "description": "\n\nCross binds the selected option values with an observable value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can.mustache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY`'s value should be either Array-like, a String,\nor `undefined`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can.mustache.key"
        }
      ],
      "name": "KEY",
      "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY`'s value should be either Array-like, a String,\nor `undefined`.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.toChild": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/to-child.md"
    },
    "body": "\n## Use\n\n`{child-prop}=\"key\"` is used to pass values from the scope to a component.  You can use CallExpressions like:\n\n```\n<player-scores {scores}=\"game.scoresForPlayer('Alison')\"/>\n<player-scores {scores}=\"game.scoresForPlayer('Jeff')\"/>\n```\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/to-child.html'></div>\n\n",
    "description": "One-way bind a value in the parent scope to the [can-component::viewModel viewModel]. \n",
    "title": "{to-child}",
    "name": "can-stache-bindings.toChild",
    "type": "function",
    "parent": "can-stache-bindings",
    "order": 1,
    "signatures": [
      {
        "code": "{child-prop}=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` in [can-component::viewModel viewModel]. It also updates `childProp` with the value of `key` when `key` changes.\n\n  ```\n  <my-component {some-prop}=\"value\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property to set in the \ncomponent's viewmodel.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "key",
            "description": "A KeyLookup or Call expression whose value\nis used to set as `childProp`. \n"
          }
        ]
      },
      {
        "code": "{$child-prop}=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` property or attribute on the element. \n\n  ```\n  <input {$value}=\"name\"/>\n  ```\n\n  This signature works, but the following should be used instead:\n  \n  ```\n  <input value=\"{{name}}\"/>\n  ```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache-bindings.can-value-select": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/select.md"
    },
    "body": "\n\n## Use\n\nThe following cross bind's a `<select>` to a `person` map's `attending` property:\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/select.html'></div>\n\n",
    "description": "\nCross bind a value to a `<select>` element.\n",
    "title": "select",
    "name": "can-stache-bindings.can-value-select",
    "type": "function",
    "parent": "can-stache-bindings.can-value",
    "signatures": [
      {
        "code": "<select can-value='KEY'/>",
        "description": "\n\nCross binds the selected option value with an observable value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY` should specify either a [can-map] property or\na [can-compute.computed].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "KEY",
      "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY` should specify either a [can-map] property or\na [can-compute.computed].\n"
    },
    "comment": " "
  },
  "can-stache-bindings.toParent": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/to-parent.md"
    },
    "body": "\n## Use\n\nThe use of `{^to-parent}` bindings changes between exporting __viewModel properties__ or __DOM properties__.\n\n## Exporting ViewModel properties\n\n`{^child-prop}=\"key\"` can be used to export single values or the complete view model from a \nchild component into the parent scope. Typically, the values are exported to the references scope.\n\nIn the following example, it connects the __selected__ driver in `<drivers-list>` with an editable __plateName__ in\n`<edit-plate>`:\n\n    <drivers-list {^selected}=\"*editing\"/>\n    <edit-plate {(plate-name)}=\"*editing.licensePlate\"/>\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/to-parent.html'></div>\n\t\n## Exporting DOM properties\n\n`{^$child-prop}=\"key\"` can be used to export an attribute value into the scope.  For example:\n\n```\n<input {^$value}=\"name\"/>\n```\n\nUpdates `name` in the scope when the `<input>` element's `value` changes.\n\n## Exporting Functions\n\nYou can export a function to the parent scope with a binding like:\n\n```\n<my-tabs {^@add-panel}=\"@*addPanel\">\n```\n\nAnd pass the method like:\n\n```\n<my-panel {add-panel}=\"@*addPanel\" title=\"CanJS\">CanJS Content</my-panel>\n```\n\nCheck it out in this demo:\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/to-parent-function.html'></div>\n\nNotice that `@` is used to prevent reading the function.  \n\n\n",
    "description": "One-way bind a value in the current [can-component::viewModel viewModel] to the parent scope. \n",
    "title": "{^to-parent}",
    "name": "can-stache-bindings.toParent",
    "type": "function",
    "parent": "can-stache-bindings",
    "order": 2,
    "signatures": [
      {
        "code": "{^child-prop}=\"key\"",
        "description": "\n\nExports `childProp` in the [can-component::viewModel viewModel] to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n`key` with the value of `childProp` when `childProp` changes.\n\n```\n<my-component {^some-prop}=\"value\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property to export from the \nchild components viewmodel. Use `{^this}` or `{^.}` to export the entire viewModel.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The name of the property to set in the parent scope.\n"
          }
        ]
      },
      {
        "code": "{^$child-prop}=\"key\"",
        "description": "\n\n  Exports the element's `childProp` property or attribute to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n  `key` with the value of `childProp` when `childProp` changes.\n\n  ```\n  <input {^$value}=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element's property or attribute to export.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The name of the property to set in the parent scope.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The name of the property to set in the parent scope.\n\n"
    },
    "comment": " "
  },
  "can-stache-bindings.twoWay": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/two-way.md"
    },
    "body": "\n## Use\n\n`{(child-prop)}=\"key\"` is used to two-way bind a value in a [can-component::viewModel viewModel] to\na value in the  [can-view-scope scope].  If one value changes, the other value is updated.\n\nThe following two-way binds the `<edit-plate>` element's `plateName` to the `editing.licensePlate`\nvalue in the scope.  This allows `plateName` to update if `editing.licensePlate` changes and\n`editing.licensePlate` to update if `plateName` changes.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/two-way.html'></div>\n\nThis demo can be expressed a bit easier with the references scope:\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/reference.html'></div>\n\n## Initialization\n\nWhen a binding is being initialized, the behavior of what the viewModel and scope properties\nare set to depends on their initial values.\n\nIf the viewModel value is `not undefined` and the scope is `undefined`, scope will be set to the viewModel value.\n\nIf the viewModel value is `undefined` and the scope is `not undefined`, viewModel will be set to the scope value.\n\nIf both the viewModel and scope are `not undefined`, viewModel will be set to the scope value.\n\n\n",
    "description": "Two-way bind a value in the [can-component::viewModel viewModel] or the element to the parent scope. \n",
    "title": "{(two-way)}",
    "name": "can-stache-bindings.twoWay",
    "type": "function",
    "parent": "can-stache-bindings",
    "order": 3,
    "signatures": [
      {
        "code": "{(child-prop)}=\"key\"",
        "description": "\n\n  Two-way binds `childProp` in the  [can-component::viewModel viewModel] to \n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n  \n  ```\n  <my-component {(some-prop)}=\"value\"/>\n  ```\n  \n  When setting up the binding:\n  \n  - If `childProp` is `undefined`, `key` will be set to `childProp`.\n  - If `key` is `undefined`, `childProp` will be set to `key`.\n  - If both `childProp` and `key` are defined, `key` will be set to `childProp`.\n  \n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property of the viewModel to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The name of the property to two-way bind in the parent scope.\n"
          }
        ]
      },
      {
        "code": "{($child-prop)}=\"key\"",
        "description": "\n\n  Two-way binds the element's `childProp` property or attribute to \n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n\n  ```\n  <input {($value)}=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element's property or attribute to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The name of the property to two-way bind in the parent scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The name of the property to two-way bind in the parent scope.\n"
    },
    "comment": " "
  },
  "can-util/dom": {
    "name": "can-util/dom",
    "type": "module",
    "parent": "can-util",
    "src": {
      "line": 0,
      "codeLine": 6,
      "path": "node_modules/can-util/dom/dom.js"
    },
    "body": "",
    "description": "A collection of modules that operate on DOM. \n",
    "title": "can-util/dom",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/js": {
    "name": "can-util/js",
    "type": "module",
    "parent": "can-util",
    "src": {
      "line": 0,
      "codeLine": 6,
      "path": "node_modules/can-util/js/js.js"
    },
    "body": "",
    "description": "Utilities for manipulating JavaScript data structures. \n",
    "title": "can-util/js",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-vdom/make-document/": {
    "name": "can-vdom/make-document/",
    "type": "function",
    "parent": "node_modules/can-vdom/make-document/make-document.js",
    "src": {
      "line": 0,
      "codeLine": 5,
      "path": "node_modules/can-vdom/make-document/make-document.js"
    },
    "body": "\n",
    "description": "\nExports a function that when called, returns a dom-light document object.\n",
    "title": ""
  },
  "can-vdom/make-parser/": {
    "name": "can-vdom/make-parser/",
    "type": "module",
    "parent": "node_modules/can-vdom/make-parser/make-parser.js",
    "src": {
      "line": 0,
      "codeLine": 7,
      "path": "node_modules/can-vdom/make-parser/make-parser.js"
    },
    "body": "\n",
    "description": "\nReturns a function that can generate a HTML->TOKENs parser\ngiven a document.\n",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ]
  },
  "can-view-callbacks.attr": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/attr.md"
    },
    "body": "\n\nRegisters the `attrHandler` callback when `attributeName` is found \nin a template.\n\n\n## Use\n\n`can.view.attr` is used to add custom behavior to elements that contain a \nspecified html attribute. Typically it is used to mixin behavior (whereas \n[can.view.tag] is used to define behavior).\n\nThe following example adds a jQueryUI tooltip to any element that has \na `tooltip` attribute like `<div tooltip=\"Click to edit\">Name</div>`.\n\n\n<div class='demo_wrapper' data-demo-src='can/view/doc/tooltip.html'></div>\n\n## Listening to attribute changes\n\nIn the previous example, the content of the tooltip was static. However,\nit's likely that the tooltip's value might change. For instance, the template\nmight want to dynamically update the tooltip like:\n\n    <button tooltip=\"{{deleteTooltip}}\">\n      Delete\n    </button>\n\nWhere `deleteTooltip` changes depending on how many users are selected:\n\n    deleteTooltip: function(){\n      var selectedCount = selected.attr(\"length\");\n      if(selectedCount) {\n        return \"Delete \"+selectedCount+\" users\";\n      } else {\n        return \"Select users to delete them.\";\n      }\n    }\n\n\nThe [can.events.attributes attributes] event can be used to listen to when\nthe toolip attribute changes its value like:\n\n\n    can.view.attr(\"tooltip\", function( el, attrData ) {\n    \n      var updateTooltip = function(){\n        $(el).tooltip({\n          content: el.getAttribute(\"tooltip\"), \n          items: \"[tooltip]\"\n        });\n      };\n      \n      $(el).bind(\"attributes\", function(ev){\n        if(ev.attributeName === \"tooltip\") {\n          updateTooltip();\n        }\n      });\n      \n      updateTooltip();\n\t\t\t\n    })\n\nTo see this behavior in the following demo, hover the mouse over the \"Delete\" button.  Then\nselect some users and hover over the \"Delete\" button again:\n\n<div class='demo_wrapper' data-demo-src='can/view/doc/dynamic_tooltip.html'></div>\n\n\n## Reading values from the scope.\n\nIt's common that attribute mixins need complex, observable data to\nperform rich behavior. The attribute mixin is able to read\ndata from the element's [can.view.Scope scope]. For example, \n__toggle__ and __fade-in-when__ will need the value of `showing` in:\n\n    <button toggle=\"showing\">\n      {{#showing}}Show{{else}}Hide{{/showing}} more info</button>\n    <div fade-in-when=\"showing\">\n      Here is more info!\n    </div>\n    \nThese values can be read from [can.view.attrData attrData]'s scope like:\n\n    attrData.scope.attr(\"showing\")\n\nBut often, you want to update scope value or listen when the scope value \nchanges. For example, the __toggle__ mixin might want to update `showing`\nand the __fade-in-when__ mixin needs to know when \nthe `showing` changes.  Both of these can be achived by \nusing [can.view.Scope::compute compute] to get a get/set compute that is\ntied to the value in the scope:\n\n    var showing = attrData.scope.compute(\"showing\")\n\nThis value can be written to by `toggle`:\n\n\n    can.view.attr(\"toggle\", function(el, attrData){\n    \n      var attrValue = el.getAttribute(\"toggle\")\n          toggleCompute = attrData.scope.compute(attrValue);\n\t\n      $(el).click(function(){\n        toggleCompute(! toggleCompute() )\n      })\n\t\n    })\n\nOr listened to by `fade-in-when`:\n\n    can.view.attr(\"fade-in-when\", function( el, attrData ) {\n      var attrValue = el.getAttribute(\"fade-in-when\");\n          fadeInCompute = attrData.scope.compute(attrValue),\n          handler = function(ev, newVal, oldVal){\n            if(newVal && !oldVal) {\n              $(el).fadeIn(\"slow\")\n            } else if(!newVal){\n              $(el).hide()\n            }\n          }\n\n      fadeInCompute.bind(\"change\",handler);\n\n      ...\n    })\n\nWhen you listen to something other than the attribute's element, remember to\nunbind the event handler when the element is [can.events.removed removed] from the page:\n\n    $(el).bind(\"removed\", function(){\n      fadeInCompute.unbind(handler);\n    });\n\n<div class='demo_wrapper' data-demo-src='can/view/doc/fade_in_when.html'></div>\n\n## When to call\n\n`can.view.attr` must be called before a template is processed. When [using `can.view` to create a renderer function](http://canjs.com/docs/can.view.html#sig_can_view_idOrUrl_), `can.view.attr` must be called before the template is loaded, not simply before it is rendered.\n\n\t\t//Call can.view.attr first\n\t\tcan.view.attr('tooltip', tooltipFunction);\n\t\t//Preload a template for rendering\n\t\tvar renderer = can.view('app-template');\n\t\t//No calls to can.view.attr after this will be used by `renderer`\n\n\n\n",
    "description": "\nRegister custom behavior for an attribute.\n",
    "title": "attr",
    "name": "can-view-callbacks.attr",
    "type": "function",
    "signatures": [
      {
        "code": "callbacks.attr(attributeName, attrHandler(el, attrData))",
        "description": "\n\n```js\nvar callbacks = require(\"can-view-callbacks\");\n\ncallbacks.attr(\"show-when\", function(el, attrData){\n\tvar prop = el.getAttribute(\"show-when\");\n\tvar compute = attrData.compute(prop);\n\n\tvar showOrHide = function(){\n\t\tvar val = compute();\n\t\tif(val) {\n\t\t\tel.style.display = 'block';\n\t\t} else {\n\t\t\tel.style.display = 'hidden';\n\t\t}\n\t};\n\n\tcompute.bind(\"change\", showOrHide);\n\tshowOrHide();\n\n\tel.addEventListener(\"removed\", function onremove(){\n\t\tcompute.unbind(\"change\", showOrHide);\n\t\tel.removeEventListener(\"removed\", onremove);\n\t});\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "RegExp"
              }
            ],
            "name": "attributeName",
            "description": "A lower-case attribute name or regular expression\nthat matches attribute names. Examples: `\"my-fill\"` or `/my-\\w/`.  \n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "HTMLElement"
                      }
                    ],
                    "name": "el"
                  },
                  {
                    "types": [
                      {
                        "type": "can.view.attrData"
                      }
                    ],
                    "name": "attrData"
                  }
                ]
              }
            ],
            "name": "attrHandler",
            "description": "\n\nA function that adds custom behavior to `el`.  \n"
          }
        ],
        "release": "2.1"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ],
              "name": "el"
            },
            {
              "types": [
                {
                  "type": "can.view.attrData"
                }
              ],
              "name": "attrData"
            }
          ]
        }
      ],
      "name": "attrHandler",
      "description": "\n\nA function that adds custom behavior to `el`.  \n"
    },
    "comment": " "
  },
  "can-view-callbacks": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/can-view-callbacks.md"
    },
    "body": "\nAllows registering callback functions that will be called when tags and attributes are rendered in [can-view-target].\n\n## Registering tags\n\n[can-view-callbacks.tag callbacks.tag] allows you to register a tag that custom behavior will be attached to.\n\nThis will style elements using the *blue-el* tag with a blue background.\n\n```js\nvar callbacks = require(\"can-view-callbacks\");\n\ncallbacks.tag(\"blue-el\", function(el){\n\tel.style.background = \"blue\";\n});\n```\n\n```html\n<blue-el><p>Some content with a blue background, gross!</p></blue-el>\n```\n\n## Registering attributes\n\nSimilarly you can register a callback for an attribute. Here we are using a regular expression to match an attribute that starts with `foo-`:\n\n```js\ncallbacks.attr(/foo-[\\w\\.]+/, function(el, attrData){\n\t// Get the part after foo-\n\tvar attrValue = attrData.attributeName.substr(4);\n\n\t// Set it's content\n\tel.textContent = attrValue;\n});\n```\n\nSo that:\n\n```html\n<div foo-bar></div>\n```\n\nRenders as:\n\n```html\n<div foo-bar>bar</div>\n```\n\n",
    "description": "Registered callbacks for behaviors \n",
    "type": "module",
    "title": "can-view-callbacks",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-callbacks",
    "parent": "can-infrastructure",
    "comment": " "
  },
  "can-view-callbacks.attrData": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/attrData.md"
    },
    "body": " \n",
    "description": "\nThe data provided to [can.view-callbacks.attr].\n",
    "type": "typedef",
    "title": "attrData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "scope",
            "description": "The scope of the element.\n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "The mustache helpers and other non-data values passed to the template.\n",
            "types": [
              {
                "type": "can.view.Options"
              }
            ]
          },
          {
            "name": "attributeName",
            "description": "The attribute name that was matched.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-view-callbacks.attrData"
  },
  "can-view-callbacks.tag": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/tag.md"
    },
    "body": "\n## Use\n\nCheck out this video where we talk about different possiblities to use callbacks.tag:\n\n<iframe width=\"662\" height=\"372\" src=\"https://www.youtube.com/embed/ahjd5OQcs7c\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n`callbacks.tag` is a low-level way to add custom behavior to custom elements. Often, you\nwant to do this with [can-component]. However, [can-view-callbacks.tag callbacks.tag] is\nuseful for when [can-component] might be considered overkill.  For example, the\nfollowing creates a [jQueryUI DatePicker](http://api.jqueryui.com/datepicker/) everytime a\n`<jqui-datepicker>` element is found:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker()\n    })\n\n\nThe `tagHandler`'s [can.view.tagData tagData] argument is an object \nthat contains the mustache [can.view.Scope scope] and helper [can.view.Options options] \nwhere `el` is found and a [can.view.renderer subtemplate] that renders the contents of the\ntemplate within the custom tag.\n\n## Getting values from the template\n\n`tagData.scope` can be used to read data from the template.  For example, if I wanted\nthe value of `\"format\"` within the current template, it could be read like:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker({format: tagData.scope.attr(\"format\")})\n    })\n\n    var template = mustache(\"<jqui-datepicker></jqui-datepicker>\")\n    template({format: \"mm/dd/yy\"})\n    \n`tagData.options` contains the helpers and partials provided \nto the template.  A helper function might need to be called to get the current value of format like:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker({format: tagData.options.attr(\"helpers.format\")()})\n    })\n\n    var template = mustache(\"<jqui-datepicker></jqui-datepicker>\")\n    template({},{format: function(){\n      return \"mm/dd/yy\"\n    }})\n\n## Responding to changing data\n\nOften, data passed to a template is observable.  If you use [can-view-callbacks.tag], you must\nlisten and respond to chagnes yourself.  Consider if format is property on a\n`settings` [can.Map] like:\n\n    var settings = new Map({\n      format: \"mm/dd/yy\"\n    })\n\nYou want to update the datepicker if `format` changes.  The easist way to do this\nis to use [can.view.Scope Scope's compute] method which returns a get-set\ncompute that is tied to a key value:\n\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n    \n      var formatCompute = tagData.scope.compute(\"format\"),\n          changeHandler = function(ev, newVal){\n            $(el).datepicker(\"option\",\"format\", newVal});\n          }\n      \n      formatCompute.bind(\"change\",changeHandler)\n      \n      changeHandler({}, formatCompute());\n      \n      ... \n      \n    })\n\n    var template = mustache(\"<jqui-datepicker/>\")\n    template(settings)\n\nIf you listen on something outside the tag, it's a good practice to stop listening\nwhen the element is [can.events.removed removed] from the page:\n\n    $(el).bind(\"removed\", function(){\n      formatCompute.unbind(\"change\",changeHandler)\n    })\n\n\n## Subtemplate\n\nIf content is found within a custom tag like:\n\n    var template = mustache(\n      \"<my-form>\\\n         <input value=\"{{first}}\"/>\\\n         <input value=\"{{last}}\"/>\\\n       </my-form>\")\n\nA seperate template function is compiled and passed\nas `tagData.subtemplate`.  That subtemplate can\nbe rendered with custom data and options. For example:\n\n    callbacks.tag(\"my-form\", function(el, tagData){\n       var frag = tagData.subtemplate({\n         first: \"Justin\"\n       }, tagData.options)\n       \n       $(el).html( frag )\n    })\n    \n    template({\n      last: \"Meyer\" \n    })\n    \n\nIn this case, the sub-template will not get a value for `last`.  To\ninclude the original data in the subtemplate's scope, [can.view.Scope::add add] to\nthe old scope like:\n\n    callbacks.tag(\"my-form\", function(el, tagData){\n       var frag = tagData.subtemplate(\n         tagData.scope.add({ first: \"Justin\" }), \n         tagData.options)\n       \n       $(el).html( frag )\n    })\n    \n    template({\n      last: \"Meyer\" \n    })\n \n\n",
    "description": "\n",
    "title": "tag",
    "name": "can-view-callbacks.tag",
    "type": "function",
    "signatures": [
      {
        "code": "callbacks.tag(tagName, tagHandler(el, tagData))",
        "description": "\n\nRegisters the `tagHandler` callback when `tagName` is found \nin a template. \n\n```js\nvar $ = require(\"jquery\");\nrequire(\"jquery-datepicker\");\nvar callbacks = require(\"can-view-callbacks\");\n\ncallbacks.tag(\"date-picker\", function(el){\n\t$(el).datePicker();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "A lower-case, hypenated or colon-seperated html \ntag. Example: `\"my-widget\"` or `\"my:widget\"`.  It is considered a best-practice to \nhave a hypen or colon in all custom-tag names.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "can.view.Scope"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "HTMLElement"
                      }
                    ],
                    "name": "el"
                  },
                  {
                    "types": [
                      {
                        "type": "can.view.tagData"
                      }
                    ],
                    "name": "tagData"
                  }
                ]
              }
            ],
            "name": "tagHandler",
            "description": "\n\nAdds custom behavior to `el`.  If `tagHandler` returns data, it is used to \nrender `tagData.subtemplate` and the result is inserted as the childNodes of `el`.\n"
          }
        ],
        "release": "2.1"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "can.view.Scope"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ],
              "name": "el"
            },
            {
              "types": [
                {
                  "type": "can.view.tagData"
                }
              ],
              "name": "tagData"
            }
          ]
        }
      ],
      "name": "tagHandler",
      "description": "\n\nAdds custom behavior to `el`.  If `tagHandler` returns data, it is used to \nrender `tagData.subtemplate` and the result is inserted as the childNodes of `el`.\n"
    },
    "comment": " "
  },
  "can-view-callbacks.tagData": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/tagData.md"
    },
    "body": "\n\n",
    "description": "\nThe data passed to [can-view-callbacks.tag].\n",
    "type": "typedef",
    "title": "tagData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "subtemplate",
            "description": "If the special tag has content,\nthe content can be rendered with subtemplate.  For example:\n\n    callbacks.tag(\"foo-bar\", function(el, tagData){\n      var frag = tagData.subtemplate(tagData.scope, tagData.options);\n      $(el).html(frag);\n    })\n    ",
            "types": [
              {
                "type": "can.view.renderer"
              }
            ],
            "optional": true
          },
          {
            "name": "scope",
            "description": "The scope of the element.  \n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "The mustache helpers and other non-data values passed to the template.\n",
            "types": [
              {
                "type": "can.view.Options"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-view-callbacks.tagData"
  },
  "can-view-live.attr": {
    "type": "function",
    "name": "can-view-live.attr",
    "parent": "can-view-live",
    "src": {
      "line": 2,
      "codeLine": 21,
      "path": "node_modules/can-view-live/lib/attr.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "live.attr(el, attributeName, compute)",
        "description": "\n\nKeep an attribute live to a [can-compute].\n\n```js\nvar div = document.createElement('div');\nvar compute = canCompute(\"foo bar\");\nlive.attr(div,\"class\", compute);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "The element whos attribute will be kept live."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attributeName",
            "description": "The attribute name."
          },
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "The compute.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "compute",
      "description": "The compute.\n\n"
    }
  },
  "can-view-live": {
    "name": "can-view-live",
    "type": "module",
    "parent": "can-infrastructure",
    "src": {
      "line": 11,
      "codeLine": 38,
      "path": "node_modules/can-view-live/lib/core.js"
    },
    "body": "\n\n\n## Use\n\n[can-view-live] is an object with utlitiy methods for setting up\nlive-binding in relation to different parts of the DOM and DOM elements.  For\nexample, to make an `<h2>`'s text stay live with\na compute:\n\n    var text = canCompute(\"Hello World\");\n    var textNode = $(\"h2\").text(\" \")[0].childNodes[0];\n    live.text(textNode, text);\n\n\n\n",
    "description": "\nSetup live-binding between the DOM and a compute manually.\n",
    "title": "can-view-live",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "An",
            "description": "object with the live-binding methods:\n[can-view-live.html], [can-view-live.list], [can-view-live.text],\n[can-view-live.attr] and [can-view-live.attrs].\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "release": "2.0.4",
    "comment": " "
  },
  "can.view.live.replace": {
    "type": "function",
    "name": "can.view.live.replace",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "HTMLElement"
                  }
                ]
              }
            ]
          }
        ],
        "name": "nodes",
        "description": "An array of elements.  There should typically be one element."
      },
      {
        "types": [
          {
            "type": "String"
          },
          {
            "type": "HTMLElement"
          },
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "val",
        "description": "The content that should replace\n`nodes`.  If a string is passed, it will be [can.view.hookup hookedup].\n"
      },
      {
        "types": [
          {
            "type": "function",
            "returns": {
              "types": [
                {
                  "type": "undefined"
                }
              ]
            },
            "params": []
          }
        ],
        "optional": true,
        "name": "teardown",
        "description": "A callback if these elements are torn down.\n "
      }
    ],
    "parent": "can.view.live",
    "src": {
      "line": 112,
      "codeLine": 126,
      "path": "node_modules/can-view-live/lib/core.js"
    },
    "body": "\n",
    "description": "\nReplaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\ncorrect.\n",
    "title": "",
    "release": "2.0.4",
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "teardown",
      "description": "A callback if these elements are torn down.\n "
    }
  },
  "can-view-live.html": {
    "type": "function",
    "name": "can-view-live.html",
    "parent": "can-view-live",
    "src": {
      "line": 6,
      "codeLine": 38,
      "path": "node_modules/can-view-live/lib/html.js"
    },
    "body": "\n",
    "description": "\nLive binds a compute's value to a collection of elements.\n",
    "title": "",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.html(el, compute, [parentNode])",
        "description": "\n\n`live.html` is used to setup incremental live-binding on a block of html.\n\n```js\n// a compute that change's it's list\nvar greeting = compute(function(){\n  return \"Welcome <i>\"+me.attr(\"name\")+\"</i>\"\n});\n\nvar placeholder = document.createTextNode(\" \");\n$(\"#greeting\").append(placeholder);\n\nlive.html(placeholder, greeting);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "An html element to replace with the live-section.\n"
          },
          {
            "types": [
              {
                "type": "can.compute"
              }
            ],
            "name": "compute",
            "description": "A [can.compute] whose value is HTML.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "optional": true,
            "name": "parentNode",
            "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "optional": true,
      "name": "parentNode",
      "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
    }
  },
  "can-view-live.text": {
    "type": "function",
    "name": "can-view-live.text",
    "parent": "can-view-live",
    "src": {
      "line": 3,
      "codeLine": 12,
      "path": "node_modules/can-view-live/lib/text.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.text(el, compute, [parentNode], [nodeList])",
        "description": "\n\nReplaces one element with some content while keeping [can-view-live.nodeLists nodeLists] data correct.\n",
        "params": []
      }
    ]
  },
  "can-view-live.list": {
    "type": "function",
    "name": "can-view-live.list",
    "parent": "can-view-live",
    "src": {
      "line": 64,
      "codeLine": 104,
      "path": "node_modules/can-view-live/lib/list.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.list(el, list, render, context, [parentNode])",
        "description": "\n\nLive binds a compute's list incrementally.\n\n```js\n// a compute that change's it's list\nvar todos = compute(function(){\n  return new Todo.List({page: can.route.attr(\"page\")})\n})\n\nvar placeholder = document.createTextNode(\" \");\n$(\"ul#todos\").append(placeholder);\n\ncan.view.live.list(\n  placeholder,\n  todos,\n  function(todo, index){\n    return \"<li>\"+todo.attr(\"name\")+\"</li>\"\n  });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "An html element to replace with the live-section.\n"
          },
          {
            "types": [
              {
                "type": "can-compute"
              },
              {
                "type": "can-list"
              },
              {
                "type": "can-define/list/list"
              }
            ],
            "name": "list",
            "description": "An observable list type.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "String"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ],
                    "name": "index"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "render",
            "description": "A function that when called with\nthe incremental item to render and the index of the item in the list.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "The `this` the `render` function will be called with.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "optional": true,
            "name": "parentNode",
            "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "optional": true,
      "name": "parentNode",
      "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
    }
  },
  "can-view-parser.ParserHandler.attrEnd": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrEnd.md"
    },
    "body": "",
    "description": "",
    "title": "attrEnd",
    "name": "can-view-parser.ParserHandler.attrEnd",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "attrEnd(attrName)",
        "description": "\n\nCalled at the end of parsing an attribute; after the [can-view-parser.ParserHandler.attrStart] and [can-view-parser.ParserHandler.attrValue] functions have been called.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "The name of the attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The name of the attribute.\n"
    }
  },
  "can-view-parser.ParserHandler.attrStart": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrStart.md"
    },
    "body": "",
    "description": "",
    "title": "attrStart",
    "name": "can-view-parser.ParserHandler.attrStart",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "attrStart(attrName)",
        "description": "\n\nCalled when an attribute is found on an element.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "The name of the attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The name of the attribute.\n"
    }
  },
  "can-view-parser.ParserHandler.chars": {
    "src": {
      "path": "node_modules/can-view-parser/docs/chars.md"
    },
    "body": "",
    "description": "",
    "title": "chars",
    "name": "can-view-parser.ParserHandler.chars",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "chars(value)",
        "description": "\n\nCalled when [CharacterData](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData) is found within a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The character data within the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The character data within the tag.\n"
    }
  },
  "can-view-parser.ParserHandler.attrValue": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrValue.md"
    },
    "body": "",
    "description": "",
    "title": "attrValue",
    "name": "can-view-parser.ParserHandler.attrValue",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "attrValue(value)",
        "description": "\n\nCalled when an attribute's **value** has been found.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The value discovered associated with an attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The value discovered associated with an attribute.\n"
    }
  },
  "can-view-parser.ParseHandler.close": {
    "src": {
      "path": "node_modules/can-view-parser/docs/close.md"
    },
    "body": "",
    "description": "",
    "title": "close",
    "name": "can-view-parser.ParseHandler.close",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "close(tagName)",
        "description": "\n\nCalled when a closing tag is found. If no closing tag exists for this tag (because it is self-closing) this function will not be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "tagName",
      "description": "The name of the tag.\n"
    }
  },
  "can-view-parser.ParserHandler.comment": {
    "src": {
      "path": "node_modules/can-view-parser/docs/comment.md"
    },
    "body": "",
    "description": "",
    "title": "comment",
    "name": "can-view-parser.ParserHandler.comment",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "comment(value)",
        "description": "\n\nCalled when a [Comment](https://developer.mozilla.org/en-US/docs/Web/API/Comment) is found within a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The Comment within the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The Comment within the tag.\n"
    }
  },
  "can-view-parser.ParserHandler.done": {
    "src": {
      "path": "node_modules/can-view-parser/docs/done.md"
    },
    "body": "",
    "description": "",
    "title": "done",
    "name": "can-view-parser.ParserHandler.done",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "done()",
        "description": "\n\nCalled at the end of parsing the template.\n",
        "params": []
      }
    ]
  },
  "can-view-parser": {
    "src": {
      "path": "node_modules/can-view-parser/docs/can-view-parser.md"
    },
    "body": "",
    "description": "Parse HTML and mustache tokens. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-parser",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "parse(html, handler, [returnIntermediate])",
        "description": "\n\nParse an html string:\n\n```js\nvar parser = require(\"can-view-parser\");\n\nvar html = '<h1><span bob=\"phillips\"></span><span bob=\"meyers\"></span>' +\n\t'</h1>';\n\nvar bobs = {};\nvar curAttr;\n\nparser(html, {\n\tattrStart: function(attrName){\n\t\tcurAttr = attrName;\n\t},\n\tattrValue: function(value){\n\t\tbobs[curAttr] = value;\n\t}\n});\n\nfor(var first in bobs) {\n\tvar last = bobs[first];\n\tconsole.log(\"Hello\", first, last);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "html",
            "description": "A mustache and html string to parse or an intermediate object the represents a previous parsing."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "handler",
            "description": "An object of callbacks."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "returnIntermediate",
            "defaultValue": "false",
            "description": "If true, returns a JS object representation of the parsing.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "returnIntermediate",
      "defaultValue": "false",
      "description": "If true, returns a JS object representation of the parsing.\n"
    }
  },
  "can-view-parser.ParseHandler.end": {
    "src": {
      "path": "node_modules/can-view-parser/docs/end.md"
    },
    "body": "",
    "description": "",
    "title": "end",
    "name": "can-view-parser.ParseHandler.end",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "end(tagName, unary)",
        "description": "\n\nCalled at the end of parsing a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "unary",
            "description": "If this tag is unary (has no closing tag).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "unary",
      "description": "If this tag is unary (has no closing tag).\n"
    }
  },
  "can-view-parser.ParseHandler": {
    "src": {
      "path": "node_modules/can-view-parser/docs/parse-handler.md"
    },
    "body": "",
    "description": "An object consisting of callback functions that handle stages in the parsing process. \n",
    "type": "typedef",
    "title": "ParseHandler",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-parser.ParseHandler"
  },
  "can-view-parser.ParseHandler.start": {
    "src": {
      "path": "node_modules/can-view-parser/docs/start.md"
    },
    "body": "",
    "description": "",
    "title": "start",
    "name": "can-view-parser.ParseHandler.start",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "start(tagName, unary)",
        "description": "\n\nCalled when parsing a tag begins.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "unary",
            "description": "If this tag is unary (has no closing tag).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "unary",
      "description": "If this tag is unary (has no closing tag).\n"
    }
  },
  "can-view-scope.types": {
    "name": "can-view-scope.types",
    "title": "types",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope": {
    "src": {
      "path": "node_modules/can-view-scope/docs/can-view-scope.md"
    },
    "body": "\n## Use\n\nA [can-view-scope] represents a lookup context and parent contexts\nthat can be used to lookup a [can-mustache.key key] value.\n\nIf no parent scope is provided, only the scope's context will be \nexplored for values.  For example:\n\n    var data = {name: {first: \"Justin\"}},\n    \tscope = new Scope(data);\n    \n    scope.attr(\"name.first\") //-> \"Justin\"\n    scope.attr(\"length\")     //-> undefined\n\nHowever, if a `parent` scope is provided, key values will be\nsearched in the parent's context after the initial context is explored.  For example:\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n    \tjustin = list[0];\n    \t\n    var listScope = new Scope(list),\n    \tcurScope = new Scope(justin, listScope)\n    \n    curScope.attr(\"name\") //-> \"Justin\"\n    curScope.attr(\"length\") //-> 2\n\nUse [can-view-scope::add add] to easily create a new scope from a parent scope like:\n\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n    \tjustin = list[0];\n    \t\n    var curScope = new Scope(list).add(justin);\n    \n    curScope.attr(\"name\") //-> \"Justin\"\n    curScope.attr(\"length\") //-> 2\n\n",
    "description": "Create a lookup node for [can-mustache.key keys]. \n\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-scope",
    "parent": "can-infrastructure",
    "inherits": "can",
    "test": "can/view/scope/test.html",
    "signatures": [
      {
        "code": "new Scope(context, [parent])",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "A value that represents the \ncurrent context. This is often an object or observable and is the first\nplace a `key` is looked up.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope"
              }
            ],
            "optional": true,
            "name": "parent",
            "description": "The parent scope. If a `key` value\nis not found in the current scope, it will then look in the parent\nscope.\n"
          }
        ],
        "release": "2.0.1",
        "returns": {
          "types": [
            {
              "type": "can-view-scope"
            }
          ],
          "description": "Returns a scope instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope"
        }
      ],
      "optional": true,
      "name": "parent",
      "description": "The parent scope. If a `key` value\nis not found in the current scope, it will then look in the parent\nscope.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-view-scope"
        }
      ],
      "description": "Returns a scope instance.\n"
    },
    "comment": " "
  },
  "can-view-scope.add": {
    "src": {
      "path": "node_modules/can-view-scope/docs/add.md"
    },
    "body": "\n## Use\n\n`scope.add(context)` creates a new scope object that\nfirst looks up values in context and then in the\nparent `scope` object.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.attr(\"name\") //-> \"Justin\"\n    curScope.attr(\"length\") //-> 2\n\n",
    "description": "\n",
    "title": "add",
    "name": "can-view-scope.add",
    "type": "function",
    "signatures": [
      {
        "code": "scope.add(context)",
        "description": "\n\nAdd an object (which could be another Scope, a Map, or a plain object) to the scope.\n\n```js\nvar scope = new Scope({ foo: \"bar\" }).add({ baz: \"qux\" });\n\nscope.attr(\"baz\"); // -> \"qux\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "The context of the new scope object.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-view-scope"
            }
          ],
          "description": "A scope object.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "context",
      "description": "The context of the new scope object.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-view-scope"
        }
      ],
      "description": "A scope object.\n"
    },
    "comment": " "
  },
  "can-view-scope.attr": {
    "src": {
      "path": "node_modules/can-view-scope/docs/attr.md"
    },
    "body": "\n## Use\n\n`scope.attr(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.attr(\"name\"); //-> \"Justin\"\n    curScope.attr(\"length\"); //-> 2\n\nPrefixing a key with `\"./\"` prevents any parent scope look ups.\nPrefixing a key with one or more `\"../\"` shifts the lookup path\nthat many levels up.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}];\n    list.name = \"Programmers\";\n    list.surname = \"CanJS\";\n\n    var justin = list[0];\n    var brian = list[1];\n    var curScope = new Scope(list).add(justin).add(brian);\n\n    curScope.attr(\"name\"); //-> \"Brian\"\n    curScope.attr(\"surname\"); //-> \"CanJS\"\n    curScope.attr(\"./surname\"); //-> undefined\n    curScope.attr(\"../name\"); //-> \"Justin\"\n    curScope.attr(\"../surname\"); //-> \"CanJS\"\n    curScope.attr(\".././surname\"); //-> \"undefined\"\n    curScope.attr(\"../../name\"); //-> \"Programmers\"\n\n",
    "description": "\n",
    "title": "attr",
    "name": "can-view-scope.attr",
    "type": "function",
    "signatures": [
      {
        "code": "scope.attr(key)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-mustache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.compute": {
    "src": {
      "path": "node_modules/can-view-scope/docs/compute.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "compute",
    "name": "can-view-scope.compute",
    "type": "function",
    "signatures": [
      {
        "code": "scope.compute(key, [options])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope.readOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options that configure how the `key` gets read.\n"
          }
        ],
        "release": "2.1",
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute that can get or set `key`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope.readOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options that configure how the `key` gets read.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute that can get or set `key`.\n"
    }
  },
  "can-view-scope.computeData": {
    "src": {
      "path": "node_modules/can-view-scope/docs/compute_data.md"
    },
    "body": "\n## Use\n\n`scope.computeData(key, options)` is used heavily by [can-mustache] to get the value of\na [can-mustache.key key] value in a template. Configure how it reads values in the\nscope and what values it returns with the [can-view-scope.readOptions options] argument.\n\n    var context = new Map({\n      name: {first: \"Curtis\"}\n    })\n    var scope = new Scope(context)\n    var computeData = scope.computeData(\"name.first\");\n\n    computeData.scope === scope //-> true\n    computeData.initialValue    //-> \"Curtis\"\n    computeData.compute()       //-> \"Curtis\"\n\nThe `compute` value is writable.  For example:\n\n    computeData.compute(\"Andy\")\n    context.attr(\"name.first\") //-> \"Andy\"\n\n",
    "description": "\n",
    "title": "computeData",
    "name": "can-view-scope.computeData",
    "type": "function",
    "signatures": [
      {
        "code": "scope.computeData(key)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope.readOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options that configure how the `key` gets read.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": [
                {
                  "name": "compute",
                  "description": "A compute that returns the\nvalue of `key` looked up in the scope's context or parent context. This compute can\nalso be written to, which will set the observable attribute or compute value at the\nlocation represented by the key.\n",
                  "types": [
                    {
                      "type": "can-compute.computed"
                    }
                  ]
                },
                {
                  "name": "scope",
                  "description": "The scope the key was found within. The key might have\nbeen found in a parent scope.\n",
                  "types": [
                    {
                      "type": "can-view-scope"
                    }
                  ]
                },
                {
                  "name": "initialData",
                  "description": "The initial value at the key's location.\n",
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An object with the following values:\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope.readOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options that configure how the `key` gets read.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "compute",
              "description": "A compute that returns the\nvalue of `key` looked up in the scope's context or parent context. This compute can\nalso be written to, which will set the observable attribute or compute value at the\nlocation represented by the key.\n",
              "types": [
                {
                  "type": "can-compute.computed"
                }
              ]
            },
            {
              "name": "scope",
              "description": "The scope the key was found within. The key might have\nbeen found in a parent scope.\n",
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "name": "initialData",
              "description": "The initial value at the key's location.\n",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An object with the following values:\n"
    },
    "types": [],
    "comment": " "
  },
  "can-zone.prototype.addWait": {
    "src": {
      "path": "node_modules/can-zone/docs/addWait.md"
    },
    "body": "",
    "description": "\n",
    "title": "addWait",
    "name": "can-zone.prototype.addWait",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.addWait()",
        "description": "\n\nAdds a wait to the [can-zone Zone]. Adding a wait will delay the Zone's Promise from resolving (the promise created by calling [can-zone.prototype.run zone.run]) by incrementing its internal counter.\n\nUsually a corresponding [can-zone.prototype.removeWait] will be called to decrement the counter.\n\n```js\nnew Zone().run(function(){\n\n\tvar zone = Zone.current;\n\n\tzone.addWait(); // counter at 1\n\tzone.removeWait(); // counter at 0, Promise resolves\n\n}).then(function(){\n\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.ZoneSpec": {
    "src": {
      "path": "node_modules/can-zone/docs/ZoneSpec.md"
    },
    "body": "",
    "description": " A ZoneSpec is the way you tap into the lifecycle hooks of a [can-zone Zone]. The hooks are described below.\n\nUsing these hooks you can do things like create timers and override global variables that will change the *shape* of code that runs within the Zone.\n\n",
    "type": "typedef",
    "title": "ZoneSpec",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "created",
            "description": "\n\nCalled when the zone is first created, after all ZoneSpecs have been parsed. this is useful if you need to do setup behavior that covers the entire zone lifecycle.\n\n```js\nnew Zone({\n\tcreated: function(){\n\t\t// Called as soon as `new Zone` is called\n\t}\n});\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "beforeRun",
            "description": "\n\nCalled immediately before the **Zone.prototype.run** function is called.\n\n```js\nvar zone = new Zone({\n\tbeforeRun: function(){\n\t\t// Setup that needs to happen immediately before running\n\t\t// the zone function\n\t}\n});\n\nzone.run(function() { ... });\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "beforeTask",
            "description": "\n\nCalled before each Task is called. Use this to override any globals you want to exist during the execution of the task:\n\n```js\nnew Zone({\n\tbeforeTask: function(){\n\t\twindow.setTimeout = mySpecialSetTimeout;\n\t}\n});\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "ended",
            "description": "\n\nCalled when the Zone has ended and is about to exit (it's Promise will resolve).\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "hooks",
            "description": "\n\n**hooks** allows you to specify custom hooks that your plugin calls. This is mostly to communicate between plugins that inherit each other.\n\n```js\nvar barZone = {\n\tcreated: function(){\n\t\tthis.execHook(\"beforeBar\");\n\t},\n\n\thooks: [\"beforeBar\"]\n};\n\nvar fooZone = {\n\tbeforeBar: function(){\n\t\t// Called!\n\t},\n\tplugins: [barZone]\n};\n\nnew Zone({\n\tplugins: [fooZone]\n});\n\nzone.run(function() { ... });\n```\n",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "string"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "name": "plugins",
            "description": "\n\nAllows specifying nested [can-zone.ZoneSpec ZoneSpecs] that the current depends on. This allows creating rich plugins that depend on other plugins (ZoneSpecs). You can imagine having a bunch of tiny plugins that do one thing and then composing them together into one meta-plugin that is more end-user friendly.\n\nSimilar to the [can-zone Zone] constructor you can either specify [can-zone.ZoneSpec] objects or functions that return ZoneSpec objects. The former gives you a closure specific to the Zone, which is often needed for variables. These two forms are equivalent:\n\n```js\nvar specOne = {\n\tcreated: function(){\n\n\t}\n};\n\nvar specTwo = function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t}\n};\n\nvar zone = new Zone({\n\tplugins: [ specOne, specTwo ]\n});\n```\n",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-zone.ZoneSpec"
                      },
                      {
                        "type": "can-zone.makeZoneSpec"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone.ZoneSpec",
    "parent": "can-zone.types"
  },
  "can-zone.static": {
    "name": "can-zone.static",
    "title": "static",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.prototype": {
    "name": "can-zone.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.types": {
    "name": "can-zone.types",
    "title": "types",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.modules": {
    "name": "can-zone.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.plugins": {
    "name": "can-zone.plugins",
    "title": "plugins",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone": {
    "src": {
      "path": "node_modules/can-zone/docs/can-zone.md"
    },
    "body": "\n## Use\n\n**can-zone** is a library that aids in tracking asynchronous calls in your application. To create a new Zone call it's constructor function with `new`:\n\n```js\nvar zone = new Zone();\n```\n\nThis gives you a [can-zone Zone] from which you can run code using [can-zone.prototype.run zone.run]:\n\n```js\nzone.run(function(){\n\t\n\tsetTimeout(function(){\n\n\t}, 500);\n\n})\nthen(function(){\n\n});\n```\n\nThe function you provide to [can-zone.prototype.run] will be run within the Zone. This means any calls to asynchronous functions (in this example `setTimeout`)\twill be waited on.\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone",
    "parent": "can-ecosystem",
    "signatures": [
      {
        "code": "new Zone()",
        "description": "\n\nCreates a new Zone with no additional overrides. Can then call [can-zone.prototype.run zone.run] to call a function within the Zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar zone = new Zone();\n\nzone.run(function(){\n\n\treturn \"hello world\";\n\n}).then(function(data){\n\tdata.result // -> \"hello world\"\n});\n```\n",
        "params": []
      },
      {
        "code": "new Zone(zoneSpec)",
        "description": "\n\nCreate a new Zone using the provided [can-zone.ZoneSpec] to configure the Zone. The following examples configures a Zone that will time out after 5 seconds.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar timeoutSpec = function(){\n\tvar timeoutId;\n\n\treturn {\n\t\tcreated: function(){\n\t\t\ttimeoutId = setTimeout(function(){\n\t\t\t\tZone.error(new Error(\"This took too long!\"));\n\t\t\t}, 5000);\n\t\t},\n\t\tended: function(){\n\t\t\tclearTimeout(timeoutId);\n\t\t}\n\t};\n};\n\nvar zone = new Zone(timeoutSpec);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-zone.ZoneSpec"
              },
              {
                "type": "can-zone.makeZoneSpec"
              }
            ],
            "name": "zoneSpec",
            "description": "A [can-zone.ZoneSpec] object or a [can-zone.makeZoneSpec function that returns] a ZoneSpec object.\n\nThese two are equivalent:\n\n```js\nnew Zone({\n\tcreated: function(){\n\t\t\n\t}\n});\n\nnew Zone(function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t};\n});\n```\n\nThe latter form is useful so that you have a closure specific to that [can-zone Zone].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        },
        {
          "type": "can-zone.makeZoneSpec"
        }
      ],
      "name": "zoneSpec",
      "description": "A [can-zone.ZoneSpec] object or a [can-zone.makeZoneSpec function that returns] a ZoneSpec object.\n\nThese two are equivalent:\n\n```js\nnew Zone({\n\tcreated: function(){\n\t\t\n\t}\n});\n\nnew Zone(function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t};\n});\n```\n\nThe latter form is useful so that you have a closure specific to that [can-zone Zone].\n"
    },
    "comment": " "
  },
  "can-zone.current": {
    "src": {
      "path": "node_modules/can-zone/docs/current.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "can-zone"
      }
    ],
    "title": "current",
    "name": "can-zone.current",
    "type": "property",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.current",
        "description": "\n\nRepresents the currently running [can-zone zone]. If the code using **Zone.current** is not running within a zone the value will be undefined.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar myZone = new Zone();\n\nmyZone.run(function(){\n\n\tZone.current === myZone;\n\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.prototype.data": {
    "src": {
      "path": "node_modules/can-zone/docs/data.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "data",
    "name": "can-zone.prototype.data",
    "type": "property",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.data",
        "description": "\n\nYou might want to get data back from can-zone, for example if you are using the library to track asynchronous rendering requests. Each zone contains a **data** object which can be used to store artibitrary values.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"http://example.com\");\nxhr.onload = function(){\n\t// Save this data for later\n\tZone.current.data.xhr = xhr.responseText;\n};\nxhr.send();\n```\n\n",
        "params": []
      }
    ]
  },
  "can-zone.error": {
    "src": {
      "path": "node_modules/can-zone/docs/error.md"
    },
    "body": "",
    "description": "\n",
    "title": "error",
    "name": "can-zone.error",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.error(err)",
        "description": "\n\nAllows you to add an error to the currently running zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\n\tsetTimeout(function(){\n\t\tZone.error(new Error(\"oh no\"));\n\t}, 100);\n\n}).then(null, function(error){\n\terror; // -> {message: \"oh no\"}\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Error"
              }
            ],
            "name": "err",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Error"
        }
      ],
      "name": "err",
      "description": "\n"
    }
  },
  "can-zone.makeZoneSpec": {
    "src": {
      "path": "node_modules/can-zone/docs/makeZoneSpec.md"
    },
    "body": "\nUsing a function rather than a ZoneSpec object gives you a closure where you can store local variables that will be specific to the [can-zone Zone] you are running in.\n\n",
    "description": "\nA function that returns a [can-zone.ZoneSpec] object. This can be used any place where a [can-zone.ZoneSpec] is accepted.\n",
    "type": "typedef",
    "title": "makeZoneSpec",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "can-zone.ZoneSpec"
            }
          ],
          "description": "A [can-zone.ZoneSpec]\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-zone.prototype.data"
              }
            ],
            "name": "data",
            "description": "The [can-zone Zone's] data object, useful when you want to append data to the Zone.\n\nThis examples wraps [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to keep count of how many elements are created, and appends the count to [can-zone.prototype.data] when the Zone ends.\n\n```js\nvar mySpec = function(data){\n\tvar realCreateElement,\n\t\tcount = 0;\n\n\treturn {\n\t\tbeforeTask: function(){\n\t\t\trealCreateElement = document.createElement;\n\t\t\tdocument.createElement = function(){\n\t\t\t\tcount++;\n\t\t\t\treturn realCreateElement.apply(this, arguments);\n\t\t\t};\n\t\t},\n\t\tafterTask: function(){\n\t\t\tdocument.createElement = realCreateElement;\n\t\t},\n\t\tended: function(){\n\t\t\tdata.elementsCreated = count;\n\t\t}\n\t};\n};\n\nvar zone = new Zone(mySpec);\n\nzone.run(function(){\n\t// Do stuff here\n})\n.then(function(data){\n\tdata.elementsCreated; // -> 5\n});\n```\n"
          }
        ]
      }
    ],
    "name": "can-zone.makeZoneSpec",
    "parent": "can-zone.types",
    "_curParam": {
      "types": [
        {
          "type": "can-zone.prototype.data"
        }
      ],
      "name": "data",
      "description": "The [can-zone Zone's] data object, useful when you want to append data to the Zone.\n\nThis examples wraps [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to keep count of how many elements are created, and appends the count to [can-zone.prototype.data] when the Zone ends.\n\n```js\nvar mySpec = function(data){\n\tvar realCreateElement,\n\t\tcount = 0;\n\n\treturn {\n\t\tbeforeTask: function(){\n\t\t\trealCreateElement = document.createElement;\n\t\t\tdocument.createElement = function(){\n\t\t\t\tcount++;\n\t\t\t\treturn realCreateElement.apply(this, arguments);\n\t\t\t};\n\t\t},\n\t\tafterTask: function(){\n\t\t\tdocument.createElement = realCreateElement;\n\t\t},\n\t\tended: function(){\n\t\t\tdata.elementsCreated = count;\n\t\t}\n\t};\n};\n\nvar zone = new Zone(mySpec);\n\nzone.run(function(){\n\t// Do stuff here\n})\n.then(function(data){\n\tdata.elementsCreated; // -> 5\n});\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        }
      ],
      "description": "A [can-zone.ZoneSpec]\n"
    }
  },
  "can-zone.ignore": {
    "src": {
      "path": "node_modules/can-zone/docs/ignore.md"
    },
    "body": "\n## Use\n\n**Zone.ignore** is used to prevent a function from being waited on within a Zone. Normally a Zone's calls to functions like `setTimeout` and `XMLHttpRequest` are waited on before the [can-zone.prototype.run run promise] is resolved, but in some cases you might not want to wait on these calls; for example if there is a very long delay or a delay that will not result in rendering to take place.\n\nProvide Zone.ignore a function and it will return a function that can be called in it's place.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar fn = Zone.ignore(function(){\n\t// do any asynchronous stuff here\n});\n\nfn(); // waits ignored\n```\n\n",
    "description": "\n",
    "title": "ignore",
    "name": "can-zone.ignore",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.ignore(fn)",
        "description": "\n\nCreates a function that, when called, will not track any calls. This might be needed if you are calling code that does unusual things, like using setTimeout recursively indefinitely.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\tfunction recursive(){\n\t\tsetTimeout(function(){\n\t\t\trecursive();\n\t\t}, 20000);\n\t}\n\n\tvar fn = Zone.ignore(recursive);\n\n\t// This call will not be waited on.\n\tfn();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "A function that contains calls to asynchronous functions that are needing to be ignored.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function in which calls to [can-zone.prototype.addWait] and [can-zone.prototype.removeWait] will be ignored, preventing the Zone's promise from remaining unresolved while asynchronous activity continues within.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "A function that contains calls to asynchronous functions that are needing to be ignored.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function in which calls to [can-zone.prototype.addWait] and [can-zone.prototype.removeWait] will be ignored, preventing the Zone's promise from remaining unresolved while asynchronous activity continues within.\n"
    },
    "comment": " "
  },
  "can-zone/register": {
    "src": {
      "path": "node_modules/can-zone/docs/register.md"
    },
    "body": "",
    "description": " \nIn order to do it's magic, [can-zone] has to register handlers for all of the common JavaScript async operations. If you have code (or a dependency with this code) that does:\n\n```js\nvar st = setTimeout;\n```\n\nAnd this module loads before can-zone, any time `st` is used we won't be able to track that within the Zone.\n\nTo work around this, **can-zone/register** is used as a script that you run before any other modules.\n\n### In Node\n\n```js\nrequire(\"can-zone/register\");\n```\n\nAt the top of your entry-point script.\n\n### In the Browser\n\nYou can either add a script tag above all others:\n\n```js\n<script src=\"node_modules/can-zone/register.js\"></script>\n```\n\nOr, if you're using a module loader / bundler, configure it so that can-zone/register is placed above all others in the bundle.\n\n",
    "type": "module",
    "title": "can-zone/register",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone/register",
    "parent": "can-zone.modules"
  },
  "can-zone.prototype.removeWait": {
    "src": {
      "path": "node_modules/can-zone/docs/removeWait.md"
    },
    "body": "",
    "description": "\n",
    "title": "removeWait",
    "name": "can-zone.prototype.removeWait",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.removeWait()",
        "description": "\n\nDecrements the [can-zone Zone's] internal counter that is used to decide when its [can-zone.prototype.run run Promise] will resolve.\n\nUsually used in conjuction with [can-zone.prototype.addWait]. Most of the time you'll want to use [can-zone.waitFor], but in some cases where a callback is not enough to know waiting is complete, using addWait/removeWait gives you finer grained control.\n\n```js\nvar zone = new Zone();\n\nvar obj = new SomeObject();\n\n// This is only done when the event.status is 3\nobj.onprogress = function(ev){\n\tif(ev.status === 3) {\n\t\tzone.removeWait();\n\t}\n};\n\nzone.addWait();\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.prototype.run": {
    "src": {
      "path": "node_modules/can-zone/docs/run.md"
    },
    "body": "",
    "description": "\n",
    "title": "run",
    "name": "can-zone.prototype.run",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.run(fn)",
        "description": "\n\nRuns a function within a [can-zone Zone]. Calling run will set the Zone's internal Promise which will only resolve once all asynchronous calls within `fn` are complete.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "Any function which needs to run within the Zone. The function will be executed immediately.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-zone.prototype.data"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that will resolve with the Zone's [can-zone.prototype.data] object.\n\n```js\nvar zone = new Zone();\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\t\tzone.data.foo = \"bar\";\n\t});\n\n}).then(function(data){\n\tdata.foo // -> \"bar\"\n});\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "Any function which needs to run within the Zone. The function will be executed immediately.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-zone.prototype.data"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that will resolve with the Zone's [can-zone.prototype.data] object.\n\n```js\nvar zone = new Zone();\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\t\tzone.data.foo = \"bar\";\n\t});\n\n}).then(function(data){\n\tdata.foo // -> \"bar\"\n});\n```\n"
    }
  },
  "can-zone.waitFor": {
    "src": {
      "path": "node_modules/can-zone/docs/waitFor.md"
    },
    "body": "",
    "description": "\n",
    "title": "waitFor",
    "name": "can-zone.waitFor",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.waitFor(fn)",
        "description": "\n\n**Zone.waitFor** is a function that creates a callback that can be used with any async functionality. Calling Zone.waitFor registers a wait with the currently running request and returns a function that, when called, will decrement the wait count.\n\nThis is useful if there is async functionality other than what [we implement](#tasks). You might be using a library that has C++ bindings and doesn't go through the normal JavaScript async APIs.\n\n```js\nvar Zone = require(\"can-zone\");\nvar fs = require(\"fs\");\n\nfs.readFile(\"data.json\", \"utf8\", Zone.waitFor(function(){\n\t// We waited on this!\n}));\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "\n"
    }
  },
  "ApplicationDesign": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/application-design.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - Designing an Application\n- - -\n\nThe first step in putting together a CanJS app is sketching out the states of your application.\n\nWe’ll be building a small application called “Place My Order”. Place My Order is a\nwebsite that lets you select from available restaurants in your area, view their\nmenus, and purchase items for delivery. For this sample application, we’ll keep\nthings pretty simple. We won’t worry about registration, authentication, or\npayment processing.\n\nLet’s walk through the different states of our application.\n\n## Home\n\n![place-my-order.com home page](../can/guides/images/application-design/Home.png)\n\nThe Home state includes a header for navigation and a quick summary of the website’s\npurpose. You can see the main purposes of the website: \n\n - order from a restaurant\n - see your order history.\n\n## Restaurants\n\n![Restaurant locator page](../can/guides/images/application-design/RestaurantLocator.png)\n\nThe Restaurants state is the starting point for finding a restaurant from which you\nwant to order. Restaurants are displayed by region. To show a list of restaurants,\nfirst select a (U.S.) state and city.\n\n### Finding a Restaurant\n\n![Restaurant list page](../can/guides/images/application-design/RestaurantList.png)\n\nThe list of restaurants includes details about each restaurant, such as its rating\nand hours, as well as a “Place My Order” button.\n\n### Restaurant Details\n\n![Restaurant details page](../can/guides/images/application-design/RestaurantDetails.png)\n\nThe restaurant details state displays more information about a selected restaurant and an\norder button to start the ordering process.\n\n### Ordering from a Restaurant\n\n![Restaurant order form](../can/guides/images/application-design/RestaurantOrderForm.png)\n\nThe order state has a simple menu and form for collecting the user’s information. \nAt the bottom of the page, we show a total amount for the order and a button to \nplace the order.\n\n### Order Confirmation\n\n![Restaurant order confirmation page](../can/guides/images/application-design/RestaurantOrderConfirmation.png)\n\nThe order confirmation state shows the items the user selected, a total,\nand the personal information they’ve provided with the order. Note that this state\nalso has a link to restart the ordering process, should the user want to place another \norder at the same restaurant.\n\n## Order History\n\n![Order history page](../can/guides/images/application-design/OrderHistory.png)\n\nThe order history state has a list of orders with different statuses: new, preparing,\nin delivery, and delivered. This state allows you to mark orders with different\nstatuses as they move through the workflow.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Setup](Setup.html)</span>\n<span class=\"pull-right\">[Constructors &rsaquo;](Constructors.html)</span>\n\n</div>\n\n\n",
    "description": "\n",
    "name": "ApplicationDesign",
    "title": "Application Design",
    "type": "page",
    "parent": "Tutorial",
    "order": 2,
    "disabletableofcontents": true,
    "comment": " "
  },
  "AppStateAndRouting": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/app-state-and-routing.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - AppState\n - Basic Routing\n - Binding the AppState Object to the Application and Routes\n\nGet the code for: [chapter: app state and routing](/guides/examples/PlaceMyOrder/ch-3_canjs-getting-started.zip)\n- - -\n\nAs mentioned in the [introduction](Tutorial.html), CanJS suggests using a global\n`appState` object to manage the state of your application. The `appState` object\nis bound to two things:\n\n1. The application’s base template\n2. The application’s routing\n\nSince you already know about creating instances of `can.Map`, creating an\n`appState` object, which is a `can.Map`, will be easy. Let’s see how this works.\nOpen up your `app.js` file and update it as shown below.\n\n```\n$(function () {\n\tvar AppState = can.Map.extend({});\n\n\tvar appState = new AppState();\n\n\t// Bind the application state to the root of the application\n\t$('#can-main').html(can.view('main.stache', appState));\n\n\t// Set up the routes\n\tcan.route(':page', { page: 'home' });\n\tcan.route(':page/:slug', { slug: null });\n\tcan.route(':page/:slug/:action', { slug: null, action: null });\n\n\t$('body').on('click', 'a[href=\"javascript://\"]', function(ev) {\n\t\tev.preventDefault();\n\t});\n\n\t// Bind the application state to the can.route\n\tcan.route.map(appState);\n\n\tcan.route.ready();\n\n\t//appState.attr('page', 'restaurants');\n\n\tappState.bind('change', function(ev, prop, change, newVal, oldVal) {\n\t\talert('Changed the “' + prop + '” property from “' + oldVal + '” to “' + newVal + '”.');\n\t});\n});\n```\n\n## Routing\nBefore we dive into the details of the `appState` object, let’s quickly discuss \nrouting. Routing in CanJS allows us to manage browser history and client state by \nsynchronizing the `window.location.hash` with a `can.Map`. In other words, we can \nuse routing to reflect the state of our application or set the state of our application. \nOne of the things that makes routing powerful is that it records the state of the\napplication in the browser’s history. We’ll see some specific examples of this\nas we proceed.\n\nIn our application, we setup routing by:\n\n- defining the possible routes by calling `can.route`,\n- binding our `appState` object to the route with a call to `can.route.map`, and\n- calling `can.route.ready()`, which sets up two-way binding between the\n  browser’s `window.location.hash` and the `can.route`’s internal `can.Map`.\n\nOn lines 10–12, we define all the potential routes in our application and the\nproperties on the `appState` object. Let’s look at each line individually.\n\n```\ncan.route(':page', { page: 'home' });\n```\n\nThis line does two things:\n\n1. Creates a base route that is bound to one property: `page`.\n2. Sets the default value of the `page` property to `'home'`.\n\nIn our app, this will allow the following URLs:\n\n- `#!` (which will set `page` to `'home'` because that’s the default)\n- `#!orders/` (which will set `page` to `'orders'`)\n- `#!restaurants/` (which will set `page` to `'restaurants'`)\n\n```\ncan.route(':page/:slug', { slug: null });\n```\n\nThis line does two things:\n\n1. Binds a new `slug` property to our `appState` object.\n2. Sets the default value of the `slug` property to `null`.\n\nThis makes the following URLs possible:\n\n- `#!restaurants/spago/` (`page` will be `'restaurants'` and `slug` will be `'spago'`)\n\nAnything in the second part of the URL will be the `slug` property on our\n`appState` object.\n\n```\ncan.route(':page/:slug/:action', { slug: null, action: null });\n```\n\nThis line does two things:\n\n1. Binds a new `action` property to our `appState` object.\n2. Sets the default value of the `action` property to `null`.\n\nThis makes the following URLs possible:\n\n- `#!restaurants/spago/order/` for order confirmation; again, `action` will be `'order'`\n\nLet’s take a moment to see how these routes are bound to our `appState` object.\nNotice the `//appState.attr('page', 'restaurants');` line at the end of our\n`app.js` file; let’s uncomment that line so it looks like\n`appState.attr('page', 'restaurants');`\n\nNow, refresh the app in your browser. The path will now be `#!restaurants`,\nand you’ll notice that the Restaurants link in the navigation is highlighted.\n\n![place-my-order.com home page](../can/guides/images/app-state-routing/app_state_route_rest.png)\n\nNote that, after we initialized our routes, updating the value of our\n`appState`’s `page` property caused the route to update as well.\nThe value of the `page` property was serialized and appended\nto the `window.location.hash`.\n\nLet’s see what happens if we adjust the value of the hash. To monitor this\nchange, we’ve included the following lines:\n\n```\nappState.bind('change', function(ev, prop, change, newVal, oldVal) {\n\talert('Changed the “' + prop + '” property from “' + oldVal + '” to “' + newVal + '”.');\n});\n```\n\nThese lines use [`can.Map.bind`](../docs/can.Map.prototype.bind.html) to\nwatch for changes to the `appState` object. Go ahead and change the URL from\n`#!restaurants` to `#!orders`. You should see an alert with this message:\n\n![place-my-order.com home page](../can/guides/images/app-state-routing/change_state_alert.png)\n\nIt was mentioned earlier that we bound our AppState to the application’s `main.stache`. \nThis is the key to connecting the AppState to our [components](Components.html). \nBecause the `appState` object is bound to our main template, which includes the rest of \nthe components in the app, *these attributes will automatically be included in the scope of\nthe components*.\n\nBefore moving on, let’s remove the following lines from our application:\n\n```\nappState.attr('page', 'restaurants');\n\nappState.bind('change', function(ev, prop, change, newVal, oldVal) {\n\talert('Changed the “' + prop + '” property from “' + oldVal + '” to “' + newVal + '”.');\n});\n```\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Stache Templates](StacheTemplates.html)</span>\n<span class=\"pull-right\">[Components &rsaquo;](Components.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "AppStateAndRouting",
    "title": "App State and Routing",
    "type": "page",
    "parent": "Tutorial",
    "order": 6,
    "disabletableofcontents": true,
    "comment": " "
  },
  "Constructors": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/constructors.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - Constructors in CanJS\n  - The `extend` function\n  - The `init` function\n- - -\n\nBefore we work with any of the objects in CanJS, it will be helpful for us to\nunderstand [can.Construct](../docs/can.Construct.html). We won’t be working\nwith `can.Construct` directly. However, many of the objects in CanJS are derived from\n`can.Construct`. Understanding it will make it easier for you to understand other\nconcepts we’re going to cover.\n\n`can.Construct` provides a way to easily use the power of prototypal\ninheritance without worrying about hooking up all the particulars\nyourself. Without going into exhaustive detail, `can.Construct` contains\na few functions we’ll encounter frequently in other objects:\n\n- Prototype\n  - init\n- Static\n  - extend\n\nWe’ll look at the extend function first.\n\n## The extend function\n`can.Construct`’s `extend` function is used to create\n“constructor functions” that inherit from the base constructor function. \nTo create a constructor function of your own, call __can.Construct__ with the:\n\n- __staticProperties__ that are attached directly to the constructor, and\n- instance __prototypeProperties__.\n\n__can.Construct__ sets up the prototype chain so subclasses can be further\nextended and sub-classed as far as you like:\n\n```\nvar Order = can.Construct.extend({\n  init: function(){},\n\n  customer: function() { ... },\n  \n  needAddress: function( account ) {\n    return false;\n  }\n});\n\nvar CarryOutOrder = Order.extend({\n  needAddress: function( account ) {\n    return account.hasAddress();\n  }\n});\n```\n\nIf only one set of properties is passed to __can.Construct__, it's assumed to\nbe the prototype properties.  If two sets of properties are passed, the\nfirst argument are static properties, the second argument are prototype\nproperties.\n\n```\ncan.Construct.extend({\n  // Static properties here\n}, {\n  // Blank object as second parameter\n});\n```\n\nThis example is highlighted because calling a `can.Construct` with two parameters, \nthe last of which is an empty object, is common. Also common is the mistake of\nommitting the last parameter of the call, which can lead to unexpected behavior.\n\n\n## The init function\n\nWhen a constructor is called with the `new` keyword, __can.Construct__ creates the instance and\ncalls [init](../docs/can.Construct.prototype.init.html) with\nthe arguments passed to `new Constructor(...)`. `init` is where initialization code\nshould go. Inside of the `init` function, the `this` keyword will refer to the\nnew object instance created by the constructor. Additionaly, `this` will contain \nthe instance properties you pass to the constructor. A common thing to do in `init` \nis save the arguments passed into the constructor. An example is below:\n\n```\nvar Order = can.Construct.extend({\n  init: function(price, item) {\n    this.price = price;\n    this.item = item;\n  }\n});\n\nvar order = new Order(20, 'Green Eggs & Ham');\n```\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Application Design](ApplicationDesign.html)</span>\n<span class=\"pull-right\">[Observables &rsaquo;](Observables.html)</span>\n\n</div>\n\n\n",
    "description": "\n",
    "name": "Constructors",
    "title": "Constructors",
    "type": "page",
    "parent": "Tutorial",
    "order": 3,
    "disabletableofcontents": true,
    "comment": " "
  },
  "Components": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/components.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - First `can.Component`\n  - Auto Instantiation\n  - Anatomy of a `can.Component`\n\nGet the code for: [chapter: components](/guides/examples/PlaceMyOrder/ch-4_canjs-getting-started.zip)\n\n- - -\n\n<a name=\"first-component\"></a>\n## First can.Component\nIf you recall from the introduction, a [`can.Component`](../docs/can.Component.html) is like a self-contained,\nmini web application; in other words, it’s encapsulated. Because `can.Component`’s are\nencapsulated, they should each contain their own:\n\n- View template file (.stache file)\n- JavaScript file\n- CSS file\n\nThis is why we created a `components` folder for our app&mdash;instead of, say, a\n`js` folder. Each component we develop will be in a folder that contains all\nthe files that support that component. This makes components portable,\nenabling you to reuse them across projects. It also isolates them, making\nthem easier to test and maintain.\n\nPut the following code inside `components/restaurant_list/restaurant_list.js`:\n\n```\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: {\n    currentRestaurant: 'Hello Restaurant Customer'\n  }\n});\n```\n\nAdd the following code to `components/restaurant_list/restaurant_list.stache`:\n\n```\n<h1>{{currentRestaurant}}</h1>\n```\n\nFinally, we need to add a reference to `components/restaurant_list/restaurant_list.js`\nin the index.html file. Find this line:\n\n```\n<!-- Replace with restaurant list component script -->\n```\n\nand replace it with this line:\n\n```\n<script src=\"components/restaurant_list/restaurant_list.js\"></script>\n```\n\nNow, go back out to your app in the browser and refresh it. On the Restaurants page, you should\nsee it printing: \"Hello Restaurant Customer\".\n\n![Hello Restaurant Customer message](../can/guides/images/components/HelloRestaurantCustomer.png)\n\n### Auto Instantiation\n\nIf you recall from [our previous discussion regarding `can.Construct`](Constructors.html), whenever you\ndeclare an object using `can.Construct`, it must be instantiated. Normally, you\nwould either directly instantiate objects using the `new` keyword, or pass the\nconstructor to an object that would create instances of it. *`can.Component` is\nan exception.*\n\nAll we have to do is declare the `can.Component` using its `extend` function.\nOnce you declare your `can.Component`, you’ve registered your component with CanJS.\nWhen CanJS parses the `main.stache` file and encounters the\n`<pmo-restaurant-list>` tag, it will automatically instantiate the `can.Component`\nassociated with it, generate the component’s view inside of its custom tag,\nand bind that view to your component’s scope.\n\n### Basic Anatomy of a can.Component\n\nThe `can.Component` we created above had three properties.\n\n- [tag](#tag),\n- [template](#template), and\n- [viewModel](#viewmodel)\n\n```\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: {\n    currentRestaurant: 'Hello Restaurant Customer'\n  }\n});\n```\n\n<a name=\"tag\"></a>\n#### The “tag” Property\nThe `can.Component`’s `tag` property associates that\n`can.Component` with a specific, custom HTML tag.\n\nAs mentioned above, when the template containing the `can.Component`’s tag is\nparsed, the `can.Component` is instantiated and the contents of its rendered\ntemplate are inserted as the HTML contents of the custom tag.\n\n<a name=\"template\"></a>\n#### Template\nThe `template` property of the `can.Component` contains the string\nvalue of the `can.Component`’s template. Note that the template property just\ncontains a string value. You can inline the template, if it is small. However,\nthe recommended way of working with templates, to maintain separation of\nconcerns, is to keep them in their own files and load them using `can.view`, as\nwe have done here.\n\n<a name=\"viewmodel\"></a>\n#### View Model\nThe `viewModel` object is the `can.Component`’s view model. The view\nmodel is an abstraction of the view that exposes public properties and\nfunctions. Any property or function defined on the view model object is available\nfrom the `can.Component`’s template as either a Stache data key, or a function.\nIn our example above, we created the property `currentRestaurant` and then\nreferenced it as a Stache data key in our template.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; App State and Routing](AppStateAndRouting.html)</span>\n<span class=\"pull-right\">[View Models &rsaquo;](ViewModels.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "Components",
    "title": "Components",
    "type": "page",
    "parent": "Tutorial",
    "order": 7,
    "disabletableofcontents": true,
    "comment": " "
  },
  "DataModelsAndFixtures": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/data-models-and-fixtures.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - `can.Model`\n - `can.fixture`\n - Connecting `can.Model` with `can.Component`\n\nGet the code for: [chapter: data models and fixtures](/guides/examples/PlaceMyOrder/ch-6_canjs-getting-started.zip)\n\n- - -\n\nThe next item we’re going to go over is [can.Model](../docs/can.Model.html).\nModels make interacting with JSON REST services *really easy*. They do this by\nencapsulating most of the code required to connect to a service and managing\nthe data the service returns. Additionally, `can.Model` extends\n[can.Map](../docs/can.Map.html), meaning that the objects returned have all of\nthe features of a `can.Map`, such as being [observable](Observables.html).\n\nFor applications requiring real-time, high performance, restful data connections \nyou should check out [can-connect](http://connect.canjs.com/). For our simple case,\nwe’ll use `can.Model` to provide data for our state and city elements from\nthe last chapter.\n\nFirst, let’s open the `models/state.js` file and add the following code:\n\n```\nvar State = can.Model.extend({\n  findAll: 'GET /api/states'\n}, {\n  // Include second, empty parameter object to set instanceProperties\n});\n```\n\nThen add the following to `models/city.js`:\n\n```\nvar City = can.Model.extend({\n  findAll: 'GET /api/cities'\n}, {\n  // Include second, empty parameter object to set instanceProperties\n});\n```\n\nBecause it is a [can.Construct](../docs/can.Construct.html), `can.Model.extend`\ncan take up to three parameters:\n\n1. `name`\n2. `staticProperties`\n3. `instanceProperties`\n\nA `can.Model`’s `staticProperties` parameter has several reserved properties you\ncan add that simplify accessing data from a JSON REST service. These\nproperties are:\n\n1. `findAll`\n2. `findOne`\n3. `create`\n4. `update`\n5. `destroy`\n\nThe `find*`, `create`, `update`, and `destroy` functions are available directly\noff of the object definition (i.e., they are static). The `destroy` function is\navailable off of specific instances of a `can.Model`. We’ll see how to\nuse these below.\n\n**Reminder**: The number of parameters you pass in to an `extend` function is\nimportant. If you pass in a single parameter object, the `extend` function will\nuse that to set the `instanceProperties`. If you pass in two parameter\nobjects, the *first* object passed in will be used to set the\n`staticProperties`. The second parameter will be used to set the\n`instanceProperties`. Here, we only want to set the `staticProperties`, so we\nmust pass in a second, empty object.\n\nA few examples below illustrate this important point:\n\n```\nvar MyModel = can.Model.extend({\n  findAll: function () {\n    // Static function\n  }\n}, {\n  destroy: function () {\n    // Instance function\n  }\n});\n\nMyModel.findAll(); // Reference a function defined on the constructor\n\nvar modelInstance = new MyModel();\nmodelInstance.destroy(); // Reference a function defined on the prototype\n```\n\n## The Data for Our Model\n\nWe’re not going to connect to a server to retrieve our data; however, we’re\ngoing to code our model as if we were. How can this possibly work? CanJS\nprovides a handy utility, `can.fixture`, that we can use to easily mimic the\nfunctionality of connecting to a server. `can.fixture`\nintercepts an AJAX request and simulates a server response with a file or a\nfunction. You can use `can.fixture` to develop JavaScript independently of\nbackend services.\n\n`can.fixture` is not included with the base CanJS package. It’s a good practice\nto keep it separate from your production CanJS library, which is why we\ndownloaded and used it a separate script tag, rather than including it\nwith our custom download. *If you use `can.fixture` during development, remember\nto remove it once you need to connect to your REST services*.\n\nLet’s create a fixture that will respond to our requests for the list of states.\nAdd the following code to the `models/fixtures.js` file:\n\n```\ncan.fixture('GET /api/states', 'models/states.json');\n```\n\nThe first argument to `can.fixture`, `GET /api/states`, tells CanJS to\nintercept any `GET` requests to the resource `/api/states`. The second argument\nis a path to a file with the data the fixture will return. Because we’re simulating \na `findAll` function, we need to return an array. The `findAll` function \nexpects an array. By default, if it does not receive one, it will throw an error. \nIf you need to connect to services that return data that doesn’t match the expected \nreturn type of the `find*` functions, don’t fret. There are ways to manage this, \nwhich we’ll work with later on.\n\nLet’s also create a fixture that will respond to our requests for the list\nof cities for each state. This one is going to be a little different because\nwe want to be able to return a different list depending on which state is\nincluded in the request. Thankfully, `can.fixture` is flexible and allows\nyou to dynamically respond to requests. Let’s add the following code to the\n`models/fixtures.js` file:\n\n```\ncan.fixture('GET /api/cities', function(request, response) {\n\tcan.ajax({\n\t\turl: 'models/' + request.data.state + '.json',\n\t\tsuccess: function(data) {\n\t\t\tresponse(data);\n\t\t}\n\t});\n});\n```\n\nThe first argument to `can.fixture`, `GET /api/cities`, is similar to our\nrestaurants example: we’re setting up this fixture to intercept any `GET`\nrequests to `/api/cities`. The second argument, however, is different: it\nis a function that returns the data we want to get when the application makes\na service call. In our example, we’re making an AJAX request (via\n[can.ajax](../docs/can.ajax.html)) to get the fixture data from a JSON file,\nthen responding to the request with the data we fetched.\n\n## Connecting the Model to the Component\n\nIt’s time to connect all of this together in our view model. Simply open up\n`components/restaurant_list/restaurant_list.js`, find the states property:\n\n```\n\t\tstates: {\n\t\t\tvalue: [\n\t\t\t\t{\n\t\t\t\t\tcities: ['Green Bay', 'Milwaukee'],\n\t\t\t\t\tname: 'Wisconsin'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcities: ['Detroit', 'Ann Arbor'],\n\t\t\t\t\tname: 'Michigan'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcities: ['Chicago', 'Peoria'],\n\t\t\t\t\tname: 'Illinois'\n\t\t\t\t}\n\t\t\t]\n\t\t},\n```\n\nand replace it with this:\n\n```\n\t\tstates: {\n\t\t\tget: function() {\n\t\t\t\treturn State.findAll({});\n\t\t\t}\n\t\t},\n```\n\nIn the same file, find the cities property:\n\n```\n\t\tcities: {\n\t\t\tget: function() {\n\t\t\t\tvar state = this.attr('state');\n\t\t\t\treturn state && this.attr('citiesByState')[state];\n\t\t\t}\n\t\t},\n```\n\nand replace it with this:\n\n```\n\t\tcities: {\n\t\t\tget: function() {\n\t\t\t\tvar state = this.attr('state');\n\t\t\t\treturn state ? City.findAll({ state: state }) : null;\n\t\t\t}\n\t\t},\n```\n\nYou can remove the `citiesByState` property since we won’t be using it anymore.\nLet’s also update the `components/restaurant_list/restaurant_list.stache` file\nto match the changes we made in the view model. The most significant change is\nthat our `cities` and `states` properties now return a [promise](../docs/can.List.plugins.promise.html)\ninstead of just an array. Find the `form` element:\n\n```\n  <form class=\"form\">\n    <div class=\"form-group\">\n      <label>State</label>\n      <select {($value)}=\"state\">\n        {{^if state}}\n        <option value=\"\">Choose a state</option>\n        {{/if}}\n        {{#each states}}\n        <option value=\"{{name}}\">{{name}}</option>\n        {{/each}}\n      </select>\n    </div>\n    <div class=\"form-group\">\n      <label>City</label>\n      <select {($value)}=\"city\">\n        {{^if city}}\n        <option value=\"\">Choose a city</option>\n        {{/if}}\n        {{#each cities}}\n        <option>{{.}}</option>\n        {{/each}}\n      </select>\n    </div>\n  </form>\n```\n\nand replace it with this new one:\n\n```\n  <form class=\"form\">\n    <div class=\"form-group\">\n      <label>State</label>\n      <select {($value)}=\"state\" {{#if states.isPending}}disabled{{/if}}>\n        {{#if states.isPending}}\n          <option value=\"\">Loading...</option>\n        {{else}}\n          {{^if state}}\n          <option value=\"\">Choose a state</option>\n          {{/if}}\n          {{#each states.value}}\n          <option value=\"{{short}}\">{{name}}</option>\n          {{/each}}\n        {{/if}}\n      </select>\n    </div>\n    <div class=\"form-group\">\n      <label>City</label>\n      <select {($value)}=\"city\" {{^if state}}disabled{{/if}}>\n        {{#if cities.isPending}}\n          <option value=\"\">Loading...</option>\n        {{else}}\n          {{^if city}}\n          <option value=\"\">Choose a city</option>\n          {{/if}}\n          {{#each cities.value}}\n          <option>{{name}}</option>\n          {{/each}}\n        {{/if}}\n      </select>\n    </div>\n  </form>\n```\n\nNote that there are a few ways to call a `findAll` function on a `can.Model`. The\nfirst way is to call the function explicitly. Using the `State` model as an\nexample, that would look like this:\n\n```\nState.findAll({ /* paramsObject */ },\n  function(returnedObject){\n    // ...\n  },\n  function(errorObject){\n    // ...\n  });\n```\n\nWe also have the ability to use `can.Deferred`, which allows us to chain\ncallback functions off of each other. You can read more about this from the\n[jQuery API](https://api.jquery.com/category/deferred-object/). Using this\nmethod, we could write our `findAll` like this:\n\n```\nState.findAll({ /* paramsObject */ })\n  /* When the API call succeeds, .done() is called */\n  .done(function(returnedObject) {\n    // ...\n  })\n  /* When the API call errors, .fails() is called */\n  .fail(function(errorObject) {\n    // ...\n  });\n```\n\nBoth are acceptable, but throughout the guide we will use the Deferred method\nas it more explicitly states which callback function is which.\n\nFinally, let’s add the scripts we modified to our `index.html` file.\nFind these lines:\n\n```\n\t<!-- Replace with city model script -->\n\t<!-- Replace with fixtures script -->\n\t<!-- Replace with state model script -->\n```\n\nand replace it with these lines:\n\n```\n\t<script src=\"models/city.js\"></script>\n\t<script src=\"models/fixtures.js\"></script>\n\t<script src=\"models/state.js\"></script>\n```\n\nLet’s go back to our app now and see what happens! If everything went\naccording to plan, you should be able to refresh the Restaurants page\nand see the same list that we had before. Selecting a state, then a city,\nshould work the same as well.\n\n![set up state selector](../can/guides/images/view-models/view_model_city.png)\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; View Models](ViewModels.html)</span>\n<span class=\"pull-right\">[Loading States &rsaquo;](LoadingStates.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "DataModelsAndFixtures",
    "title": "Data Models and Fixtures",
    "type": "page",
    "parent": "Tutorial",
    "order": 9,
    "disabletableofcontents": true,
    "comment": " "
  },
  "EventHandling": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/event-handling.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Event Handling\n\nGet the code for: [chapter: event handling](/guides/examples/PlaceMyOrder/ch-8_canjs-getting-started.zip)\n\n- - -\n\nCanJS makes it easy to handle any\n[any standard DOM event](https://developer.mozilla.org/en-US/docs/Web/Events), \nsuch as a `change` event, in your component. To add an event handler, we\nhave to make changes in two places:\n\n1. The view template\n2. The `can.Component` view model\n\nBefore we can work with an example, let’s get the restaurant details page\nworking. When you go to the Restaurants page in your browser, then select\na state and city, then click the “Place My Order” button next to a restaurant,\nthe page will have a `pmo-restaurant-details` element without any content.\n\n![Empty pmo-restaurant-details element](../can/guides/images/event-handling/EmptyRestaurantDetails.png)\n\nAs we’ve discussed earlier, you need to include the component’s script\nfile to register the component with CanJS. While we’re at it, we’re going to\ninclude the scripts for the rest of the components that we’re going to use.\nLet’s edit the `index.html` file by replacing these lines:\n\n```html\n\t<!-- Replace with order component script -->\n\t<!-- Replace with order details component script -->\n\t<!-- Replace with order history component script -->\n\t<!-- Replace with order list component script -->\n\t<!-- Replace with order phone component script -->\n```\n\nwith these lines:\n\n```html\n\t<script src=\"components/order/order.js\"></script>\n\t<script src=\"components/order_details/order_details.js\"></script>\n\t<script src=\"components/order_list/order_list.js\"></script>\n\t<script src=\"components/order_history/order_history.js\"></script>\n\t<script src=\"components/order_phone/order_phone.js\"></script>\n```\n\nWe have just one more file we need to include before we move on. This\nsection is going to introduce orders from a restaurant, and\nwe’ll want to have an `Order` model. Find this line:\n\n```\n\t<!-- Replace with order model script -->\n```\n\nand replace it with this line:\n\n```\n    <script src=\"models/order.js\"></script>\n```\n\nNow, if you refresh the page, you’ll see the details for Spago.\n\n![Restaurant details page](../can/guides/images/application-design/RestaurantDetails.png)\n\nIf you click the “Order from Spago” button, you’ll find yourself with a menu, a\nname field, and an address field; however, we’re missing one important piece of\ncustomer information: a phone number. Let’s build a `phone-validator`\ncomponent to collect this information, and add some event handling to\nvalidate the field as the user types.\n\nThere are two ways you can add event handling to an element:\n - by adding an attribute with the event name prefixed by `can-`.\n - by adding an attribute with the event name surrounded in parenthesis, e.g., `(click)`.\n\n```html\n<!--Example using can- syntax-->\n<input name=\"phone\" type=\"text\" can-keyup=\"{setPhoneValue @element.val}\">\n   \n<!--Example using () syntax-->\n<input name=\"phone\" type=\"text\" ($keyup)=\"setPhoneValue(@element.val)\">\n```\n\nOf these, the preferred method is to use parenthesis to surround the event name.\nAgain, [any standard DOM event](https://developer.mozilla.org/en-US/docs/Web/Events) is supported.\nMore information about `can.stache's` event and two-way binding syntaxes can be found at [can.view.bindings](http://localhost:8080/docs/can.view.bindings.html).\n\nIn addition to defining an event, you can pass certain predefined parameters \nto the method that handles the event. These parameters include:\n\n   - @element - The can.$ wrapped element where the event occurred.\n   - @event - The event object&mdash;or properties off of that object.\n   - @viewModel - If the element is a can.Component, the component's viewModel.\n   - @context - The current context.\n\nYou are not limited to these parameters. Any valid value can be passed in to the \nhandler method. Separate method parameters with a space, e.g. `{{myMethod arg1 arg2}}`\n\nLet’s open the `components/order_phone/order_phone.stache` file and add the\nfollowing:\n\n```html\n<div class=\"form-group{{#if error}} has-error{{/if}}\">\n  <label>Phone:</label>\n  <input name=\"phone\" type=\"text\" ($keyup)=\"setPhoneValue(@element.val)\">\n  {{#if error}}\n    {{#eq order.phone '911'}}\n      <p>That's not your real number :-(</p>\n    {{else}}\n      <p>Please enter a phone number in the format 555-555-5555</p>\n    {{/eq}}\n  {{/if}}\n</div>\n```\n\nNotice the `<input />` element with a `($keyup)` event handler. Whenever there\nis a `keyup` event in the `input`, the code in the value will be executed. We’re \nalso passing `@element.val` to the `setPhoneValue` helper. Let’s\nadd the component’s JavaScript to the `components/order_phone/order_phone.js`\nfile:\n\n```\nvar PhoneViewModel = can.Map.extend({\n  error: function(){\n    var phone = this.attr(\"order\").attr(\"phone\");\n    return phone && (!/^(\\d|-)*$/.test(phone) || phone === \"911\");\n  },\n\n  setPhoneValue: function(val){\n    this.attr('order').attr('phone', val);\n  }\n});\n\ncan.Component.extend({\n  tag: 'phone-validator',\n  viewModel: PhoneViewModel,\n  template: can.view('components/order_phone/order_phone.stache')\n});\n```\n\nHere you can see the `setPhoneValue` helper function, which takes the `val`\npassed to it by the template and sets the `phone` property of the\ncomponent’s `order` property to `val`.\n\nBut how do errors show up? The template is using the `error` property on the\ncomponent, which looks like this:\n\n```\n  error: function(){\n    var phone = this.attr(\"order\").attr(\"phone\");\n    return phone && (!/^(\\d|-)*$/.test(phone) || phone === \"911\");\n  },\n```\n\nNotice that the `error` property uses `this.attr(\"order\").attr(\"phone\")` in\nits getter. Because of CanJS’s [observables](Observables.html), CanJS is\naware of us setting that value in our `setPhoneValue` helper, and thus only\nruns the getter again (called “recomputing the value”) when\nthe value has changed. When the `setPhoneValue` helper sets the value, CanJS\nrecomputes the `error` property’s value, which will return an error if you\ntype “911” or anything that doesn’t look like a phone number.\n\n![Restaurant order error when you type 911 as your phone number](../can/guides/images/event-handling/RestaurantOrderError911.png)\n\nNote that you can place as many event handlers as you need on an element. Adding event\nhandlers in this way directly binds the events to the element. This can impact\nperformance in situations where you have many elements to bind events to. For\nmore performant event binding, you can use the `can.Component`’s [events\nproperty](../docs/can.Component.prototype.events.html). Discussing this is beyond\nthe scope of this introduction. See the API for more details.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Loading States](LoadingStates.html)</span>\n<span class=\"pull-right\">[Web Service Communication &rsaquo;](WebServiceCommunication.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "EventHandling",
    "title": "Event Handling",
    "type": "page",
    "parent": "Tutorial",
    "order": 11,
    "disabletableofcontents": true,
    "comment": " "
  },
  "LoadingStates": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/loading-states.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Loading States\n\nGet the code for: [chapter: loading states](/guides/examples/PlaceMyOrder/ch-7_canjs-getting-started.zip)\n\n- - -\n\nLoading data from a remote server never happens immediately, so it’s a best\npractice to show some sort of indicator to improve the user’s experience.\nCanJS makes this easy with observable promises.\n\nNow that we have the cities and states loading from our fixtures, let’s get\na list of restaurants when a city is selected. Let’s start by modifying\nthe `components/restaurant_list/restaurant_list.js` file. Find this line:\n\n```\n\t\t// Restaurant code will go here\n```\n\nand replace it with these lines:\n\n```\n\t\trestaurants: {\n\t\t\tget: function(){\n\t\t\t\tvar city = this.attr('city'),\n\t\t\t\t\tstate = this.attr('state');\n\n\t\t\t\treturn state && city ?\n\t\t\t\t\tRestaurant.findAll({\n\t\t\t\t\t\t'address.state': state,\n\t\t\t\t\t\t'address.city': city\n\t\t\t\t\t}) : null;\n\t\t\t}\n\t\t}\n```\n\nHere, we’re adding a new `restaurants` property that is a promise returned\nby `can.Model.findAll()` (if a city and state are selected). This promise\nhas a few properties:\n\n- `isPending`: indicates that the promise hasn’t been resolved or rejected\n- `isResolved`: indicates that the promise has been resolved\n- `value`: the value of the resolved promise\n\nNow let’s make use of this new property and it’s attributes in our\n`components/restaurant_list/restaurant_list.stache` template. Find this line:\n\n```\n  <!-- Restaurants code will go here -->\n```\n\nand replace it with these lines:\n\n```\n  {{#if restaurants.isPending}}\n  <div class=\"restaurant loading\"></div>\n  {{/if}}\n\n  {{#if restaurants.isResolved}}\n    {{#each restaurants.value}}\n    <div class=\"restaurant\">\n      <img src=\"{{images.thumbnail}}\" width=\"100\" height=\"100\">\n      <h3>{{name}}</h3>\n      {{#address}}\n      <div class=\"address\">\n        {{street}}<br />{{city}}, {{state}} {{zip}}\n      </div>\n      {{/address}}\n\n      <div class=\"hours-price\">\n        $$$<br />\n        Hours: M-F 10am-11pm\n        <span class=\"open-now\">Open Now</span>\n      </div>\n\n      <a class=\"btn\" href=\"{{ routeUrl(page='restaurants' slug=slug) }}\">Place My Order</a>\n      <br />\n    </div>\n    {{/each}}\n  {{/if}}\n```\n\nYou’ll notice the `{{#if restaurants.isPending}}` and\n`{{#if restaurants.isResolved}}` lines; the first is for showing a loading\nindicator while the restaurants are being loaded, and the second is for\nshowing the list of restaurants once they’ve been fetched from the server\n(or in our case, from the fixtures). After they have,\n`{{#each restaurants.value}}` iterates over the list of restaurants to show\nthem on the page.\n\nSpeaking of fixtures, let’s modify our `models/fixtures.js` file. Add the\nfollowing lines:\n\n```\ncan.fixture('GET /api/restaurants', 'models/restaurants.json');\ncan.fixture('GET /api/restaurants/{_id}', 'models/spago.json');\n```\n\nThe first line will let us make a `GET` request to `/api/restaurants` to\nfetch the list of restaurants. The second line will return data for\na specific restaurant. Normally, this would be dynamic, depending on which\nrestaurant we want info for. For simplicity, however, we’re\nresponding with the same fixture data regardless of which restaurant is\nrequested.\n\nGo ahead and refresh the Restaurants page in your browser. Now, we can\nselect a state, a city, and then immediately see a list of restaurants!\n\n![Restaurant list](../can/guides/images/application-design/RestaurantList.png)\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Data Models and Fixtures](DataModelsAndFixtures.html)</span>\n<span class=\"pull-right\">[Event Handling &rsaquo;](EventHandling.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "LoadingStates",
    "title": "Loading States",
    "type": "page",
    "parent": "Tutorial",
    "order": 10,
    "disabletableofcontents": true,
    "comment": " "
  },
  "Recap": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/recap.md"
    },
    "body": "\n<div class=\"getting-started\">\n\nWe’ve come a long way since we started developing our first CanJS application.\nNice work! Together, we’ve covered:\n\n- The recommended application structure.\n- Building a `can.Component`.\n- Binding to templates with `can.view`.\n- Accessing service-exposed data with `can.Model`.\n- Interrupting service calls to mimic server responses with `can.fixture`.\n- Tying the application together with an Application State object.\n- Binding the Application State object with the base template, and the\n  application's route to enable routing.\n\nThose are all the pieces you need to start building applications with CanJS\ntoday.\n\n<!--\nIf you're interested in more advanced topics, like using CanJS with\nDependency Management utilities like StealJS, Require, or Browserify, see the\n[appendices](#appendices) for more information.\n-->\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Web Service Communication](WebServiceCommunication.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "Recap",
    "title": "Recap",
    "type": "page",
    "parent": "Tutorial",
    "order": 13,
    "comment": " "
  },
  "StacheTemplates": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/stache-templates.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Stache Templates\n\nGet the code for: [chapter: stache templates](/guides/examples/PlaceMyOrder/ch-2_canjs-getting-started.zip)\n\n- - -\n\nNow that we have a basic sketch of our application, and we've covered a few CanJS fundamentals,\nit’s time for us to start working with the sample application. We'll begin with the\napplication's templates.\n\nAs mentioned in the [introduction](./Tutorial.html), we’re using Stache templates in\nour app. Remember that when we downloaded our custom build of CanJS, we\nincluded the [can.stache](../docs/can.stache.html) plugin. \n\nWe can create a simple template, render it to a document fragment and insert it into the page like\nthe following:\n\n```\nvar template = can.stache(\"<h1>{{message}}</h1>\");\nvar frag = template({message: \"Hello World\"});\n$(\"body\").append(frag);\n```\n\nStache templates look similar to normal HTML, except they contain magic tags that contain\na very simple language that can be used to:\n\n- [lookup and insert values into the html output](#context)\n- [loop over arrays and can.Lists](#enumeration)\n- [control-flow behavior like if and switch](#conditionallogic)\n- [render other templates with partials](#partials)\n- perform custom control-flow behavior\n\n\nStache templates support both [Mustache](https://github.com/janl/mustache.js/)\nand [Handlebar](http://handlebarsjs.com/) syntax. For more\ninformation on the details of these formats, see their respective websites.\n\nIt will be easiest for us to look at these with an example, so let’s work with\none. Open up your `components/order_details/order_details.stache` file.\nIt should look like this:\n\n\n```html\n{{#with order}}\n  <h3>Thanks for your order {{name}}!</h3>\n  <div>\n  \t<label class=\"control-label\">Confirmation Number: {{_id}}</label>\n  </div>\n\n  <h4>Items ordered:</h4>\n  <ul class=\"list-group panel\">\n    {{#each items}}\n      <li class=\"list-group-item\">\n        <label>\n          {{name}} <span class=\"badge\">${{price}}</span>\n        </label>\n      </li>\n    {{/each}}\n\n    <li class=\"list-group-item\">\n      <label>Total <span class=\"badge\">${{total}}</span></label>\n    </li>\n  </ul>\n\n  <div><label class=\"control-label\">Phone: {{phone}}</label></div>\n  <div><label class=\"control-label\">Address: {{address}}</label></div>\n{{/with}}\n```\n\n<a name=\"context\"></a>\n## Value lookup\n\nAssume for the moment that we have the following `customerOrder` map passed in to our Stache template:\n\n```\n{\n   customerNumber: 12543,\n   customerType: 'Business',\n   order: {\n      name: 'Rudloph Steiner',\n      _id: 837267,\n      items: [\n         {\n            name: 'Garden Gnome',\n            price: 23.70\n         }\n      ],\n      total: 23.70,\n      phone: '+49 170 345 6789',\n      address: 'Beuselstrasse 15, Berlin',\n      \n      total: function(){\n        var sum = 0;\n        this.items.forEach(function(item){\n          sum += item.price;\n        });\n        return sum;\n      }\n   }\n}\n```\n\nIf we want to show the `customerType` in a `<span>` we can do that in a stache template like the following:\n\n```\n<span>{{customerType}}</span>\n```\n\nWhat's inside the magic tags, in this case `customerType`, is a \n[key lookup expression](../docs/can.stache.expressions.html#section_KeyLookupexpressions). \n[Keys](../docs/can.stache.key.html) are used to lookup values in the \n[template scope](../docs/can.view.Scope.html).  \n\nA DOT(`.`) operator\ncan be used to lookup nested values.  For example:\n\n```\n<h3>Thanks for your order {{order.name}}!</h3>\n<span>{{customerType}}</span>\n```\n\nSimilar to variable lookup JavaScript, a stache key lookup can search for a value in multiple places.\nEach of these places is called a __context__.  The collection of all available contexts for a key lookup\nis called a [scope](../docs/can.view.Scope.html).\n\nThe root context is\nthe data passed to a template. In this case, the root context is the `customerOrder`\nobject at the begining of this section.  This is why `{{customerType}}` outputs `Business`.\n\n[Sections](../docs/can.stache.tags.section.html)\ncreate contexts in Stache.  A section begins with `{{#EXPRESSION}}` or `{{^EXPRESSION}}`\nand ends with `{{/EXPRESSION}}`.  In the following example `{{#with order}}` \ndefines a section whose scope lookup starts finding values in the \n`customerOrder`'s `order` object first:\n\n```html\n{{#with order}}\n  <h3>Thanks for your order {{name}}!</h3>\n  <span>{{customerType}}</span>\n{{#with order}}\n```\n\nIn between `{{#with order}}` and `{{/with}}`, the scope's contexts look like:\n\n```\n[\n  customerOrder.order,\n  customerOrder\n]\n```\n\nThe top of the scope is called the __current context__.  In this case it is `customerOrder.order`.\n\n\nWhen `{{name}}` is looked up, it will first look for `name` on the __current context__.  As that value\nexists, `Rudloph Steiner` will be returned.\n\nWhen `{{customerType}}` is looked up, it will look for `customerType` on the __current context__.  As\nthat value does not exist, the next context, `customerOrder`, will be searched. The value of \n`customerOrder.customerType` will be returned.\n\nFrom within a given scope, you can reference the __current context__ or control which context\nshould be used to find values.\n\nSee examples below:\n\n```html\n{{#with order}}\n   <div>My Current Context Object: {{.}}</div> <!-- references the order object-->\n   <div>My Parent Context Object: {{../.}}</div>  <!-- references the customerOrder object--> \n   <div>An Item on my Parent Context's Object: {{../customerNumber}}</div>\n   <div>My Parent's Parent Context Object: {{../../.}}</div> <!-- example of how you might access the parent of a parent -->\n{{/with}}\n```\n\n<a name=\"enumeration\"></a>\n## Looping over arrays\nEnumerating allows you to loop through the contents of an iterable item. We’ve done this above for\nthe options in our select dropdown. The `{{#each key}} ... {{/each}}` tag set\nis used to iterate over an enumerable collection, such as an array. In the\nexample above, we are looping over an array of objects. As with [sections](#context),\nthe properties of the objects we are iterating over are accessible\nfrom data keys inside the `#each` scope without dot notation. In the example\nabove, we saw:\n\n```html\n{{#each items}}\n  <li class=\"list-group-item\">\n\t<label>\n\t  {{name}} <span class=\"badge\">${{price}}</span>\n\t</label>\n  </li>\n{{/each}}\n```\n\nBecause the context of the `{{#each}}` block is `items`, we can reference\nthe `name` and `price` properties of `items` directly&mdash;i.e, we don't need to\nwrite `{{items.name}}` or `{{items.price}}`, we can just write `{{name}}` or `{{price}}`.\n\nCall expressions can also be passed \nto [#each](../docs/can.stache.helpers.each.html). For example, a ViewModel might\nhave a method to get menu items for a particular menu like `\"dinner\"` or \n`\"lunch\"` like:\n\n```\nvar OrderViewModel = can.Map.extend({\n  itemsForMenuType: function(type){\n    return this.attr(\"menu.items\").filter(function(item){\n      return item.attr(\"type\") === type;\n    })\n  }\n})\n```\n\nCall this method and return its result to `#each` like:\n\n```\n{{#each itemsForMenuType(\"lunch\")}}\n  <li>...</li>\n{{/each}}\n```\n\nNote that [#key](../docs/can.stache.tags.section.html) can also\nbe used to loop through objects with enumerable properties. In general,\n[#each](../docs/can.stache.helpers.each.html) should be used if the key references\n[can.List](../docs/can.List.html) or Arrays that have or often have incremental updates. [#key](../docs/can.stache.tags.section.html)\nshould be used when the list is replaced by a list with items that look\nnothing like the previous list's items.\n\n<a name=\"conditionallogic\"></a>\n## Conditional Logic\nStache templates have a limited capacity for conditional logic. Open up your\n`main.stache` file. It should look like this:\n\n```\n{{> header.stache}}\n\n{{#eq page \"home\"}}\n  {{> home.stache}}\n{{/eq}}\n\n{{#eq page \"restaurants\"}}\n  {{#if slug}}\n    {{#eq action 'order'}}\n      <pmo-order {(slug)}=\"slug\"></pmo-order>\n    {{/eq}}\n    {{^if action}}\n      <pmo-restaurant-details {(slug)}=\"slug\"></pmo-restaurant-details>\n    {{/if}}\n  {{else}}\n    <pmo-restaurant-list></pmo-restaurant-list>\n  {{/if}}\n{{/eq}}\n\n{{#eq page \"orders\"}}\n  <pmo-order-history></pmo-order-history>\n{{/eq}}\n```\n\nYou’ll see two different helpers: `eq` and `if`. The `eq` helper takes two\narguments: the first being the key that is within the current section, and\nthe second a value to compare to the first argument to see if they are equal.\nThe `if` helper checks for one truthy argument before rendering what the\n`if` block contains.\n\nYou might also notice the use of the `^` character, which will render the\nsection if the result of the helper is false. In other words, you can write\n`{{^if action}}content{{/if}}` instead of `{{#if action}}{{else}}content{{/if}}`\n\nIn general, it’s best to keep complex logic out of your templates. Their main function\nshould be to display data from the view model. If you need to use more complex logic \nto display data in your templates, you can use a helper. Helpers are not covered in detail \nin this guide; but you can get more information on them in the API: [Helpers](../docs/can.Component.prototype.helpers.html)\n\n<a name=\"partials\"></a>\n## Partials\nYou can nest templates in other templates by using partials. Partials inherit\nthe context from which they are called. They are evaluated at render time, so you\nshould be careful to avoid infinite loops. To include a partial, put its URL or\nID inside `{{> }}`.\n\nIn our example above, you can see that `{{> header.stache}}` includes the\n`header.stache` file into the template.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; The Define Plugin](TheDefinePlugin.html)</span>\n<span class=\"pull-right\">[App State and Routing &rsaquo;](AppStateAndRouting.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "StacheTemplates",
    "title": "Stache Templates",
    "type": "page",
    "parent": "Tutorial",
    "order": 5,
    "disabletableofcontents": true,
    "comment": " "
  },
  "TheDefinePlugin": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/the-define-plugin.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - The Define Plugin\n\n*There is no code to download for this chapter*\n- - -\n\nThe `define` plugin allows you to finely control the the behavior of the\nattributes on a `can.Map`. For any property you declare in the `define` plugin,\nyou can control its:\n\n- [set](#set)\n- [get](#get)\n- [type](#type)\n- [value](#value)\n- [remove](#remove)\n- [serialization](#serialization)\n\nBefore we get into the properties of the define plugin, however, let’s look at how to set it up.\nCreating a define is as simple as adding a define property to the instance properties\nof the `can.Map`. This property is an object literal. Remember from our conversation on \n[`can.Construct`](Constructors.html) that passing in one argument to a `can.Construct` will set \nits instance properties. This is important to know should you create a `can.Map` that has both\ninstance and static properties, and you want to use the define plugin. Below are two examples:\n\n```\n//can.Map with one argument\nvar Person = can.Map.extend({\n    define: {\n        //define properties go here\n        myProperty: {\n           //property attributes\n        }\n    }\n});\n\n//can.Map with two arguments\nvar Person = can.Map.extend(\n{\n   //static properties go here\n},\n{\n    define: {\n        //define properties go here\n        myProperty: {\n           //property attributes\n        }\n    }\n});\n```\n\n<a name=\"set\"></a>\n### set \nA [set](../docs/can.Map.prototype.define.set.html) function defines what happens when a value is set on a `can.Map`.\nIt is typically used to update other attributes on the `can.Map` as a side\neffect, or coerce the set value into specific format.\n\nThe setter function can take two optional arguments:\n\n- `newVal`: The type function coerced value the user intends to set on the `can.Map`\n- `setVal`: A callback that can set the value of the property asynchronously.\n\nWhen using a setter function, the final value of the attribute is determined\nby the value the setter function returns. If the function returns a value,\nthat value is used as the value of the attribute. If `undefined` is\nreturned, the behavior depends on the number of arguments the setter\n*declares*, as below:\n\n```\n// If the setter does not specify the newValue argument,\n// the attribute value is set to whatever was passed to attr.\nset: function() { ... }\n\n// If the setter specifies the newValue argument only,\n// the attribute value will be removed\nset: function(newValue) { ... }\n\n// If the setter specifies both newValue and setValue, the value of\n// the property will not be updated until setValue is called\nset: function(newValue, setValue) { ... }\n```\n\n<a name=\"get\"></a>\n### get \nA [get](../docs/can.Map.prototype.define.get.html) function defines what happens when a value is read on a `can.Map`.\nIt is typically used to provide properties that derive their value from other\nproperties of the map, as below: \n\n```\nvar Person = can.Map.extend({\n    define: {\n        fullName: {\n            get: function () {\n                return this.attr(\"first\") + \" \" + this.attr(\"last\");\n            }\n        }\n    }\n});\n```\n\n`get` is passed two optional arguments: `lastSetValue` and `resolve`.  \n\n`lastSetValue` is the last value the property was set to.  This, among other uses,\ncan be used to update a list in place instead of replacing it.  The following\nkeeps `taskIds` updated with all of `tasks`' ids:\n\n```\nvar Person = can.Map.extend({\n    define: {\n        taskIds: {\n            Value: can.List,\n            get: function(initialValue){\n                var ids = this.attr('tasks').map(function(task){\n                    return task.attr(\"id\");\n                });\n                return initialValue.replace(ids);\n            }\n        }\n    }\n});\n```\n\n\n\n`resolve` can asynchronously set the retrived value of a \n\"bound\" property.  The following makes `person` update when `personId` changes. \n`person` will be a `Person` instance retrieved from the server.\n\n```\nvar AppViewModel = can.Map.extend({\n  define: {\n    person: {\n      get: function(lastSetValue, resolve){\n        Person.findOne({id: this.attr(\"personId\")})\n            .then(resolve);\n      }\n    }\n  }\n});\n```\n\nAsynchronous getters must be bound to to behave correctly.  In most apps, this happens\nautomatically because observables are \"bound\" by a template.  However,\nwhen testing, you'll need to remember to [bind](../docs/can.Map.prototype.bind.html)\non that property before reading it. Here's how one might test the previous `AppViewModel`:\n\n```\nvar appVM = new AppViewModel({\n  personId: 5\n});\n\nappVM.bind(\"person\", function(ev, newVal, oldVal){\n  // `person` will change from undefined to a\n  // Person instance.\n  ok(newVal instanceof Person)\n});\n\n// appVM is `undefined` here because \n// `Person.findOne` hasn't returned yet\nappVM.attr(\"person\") //-> undefined\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n<a name=\"type\"></a>\n### type \nThe [type](/docs/can.Map.prototype.define.type.html) property converts a value passed to an `attr` setter function\ninto a specific value type. The type can be specified as either a type\nfunction, or one of the following strings:\n\n- `string` - Converts the value to a string.\n- `date` - Converts the value to a date or `null` if the date can not be converted.\n- `number` - Passes the value through `parseFloat`.\n- `boolean` - Converts falsey values (such as `\"\"` or `0`) to `false` and everything else to `true`.\n- `*` - Prevents the default coercion of Objects to can.Maps and Arrays to can.Lists.\n\nThere are two ways to define the `type` property: \n\n - `Type`\n - `type` \n\n`Type`, uppercase, makes sure that the set value is an \n[instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) the provided\nconstructor function.  If not, the constructor function will be called with `new` and passed the set value as the first\nargument.\n\nIn contrast, `type`, lowercase, is called no matter what and expected to return the value that should be set on the map.\n\n```\ndefine: {\n  items: {\n    type: function(newValue){\n      return typeof newValue === \"string\" ?  newValue.split(\",\") : newValue;\n    }\n  }\n}\n```\n\n<a name=\"value\"></a>\n### value \n\nSets the default value for instances of the `can.Map`. If the default\nvalue should be an object of some type, it should be specified as the return\nvalue of a function, so that all instances of the map don't point to the same\nobject. This is because JavaScript passes primitives by value, and all other\nvalues (objects, arrays, etc.) by reference.\n\n```\ndefine: {\n  prop: {\n    value: function(){ return []; }\n  }\n}\n```\n\nAs with `type`, above, there are two ways to define the `value` property: `Value`,\nor `value`. [Value](../docs/can.Map.prototype.define.ValueConstructor.html), uppercase, provides a constructor function, ensuring that\na new instance of `Value` is made for each map instance. If [value](../docs/can.Map.prototype.define.value.html) is not an function,\nthat value will be the default value of the attribute. If `value` is a function, \nthat function's return value will be used as the default value of the attribute.\n\n<a name=\"remove\"></a>\n### remove \n\nThe [remove](../docs/can.Map.prototype.define.remove.html) property is called  when an attribute is removed. This is often used to remove other related properties.\n\n<a name=\"serialization\"></a>\n### serialization \nThe last property we’ll talk about is [serialization](https://en.wikipedia.org/wiki/Serialization). The\n[serialize](../docs/can.Map.prototype.define.serialize.html) property defines how the attribute will behave when the map is\nserialized. Managing this property can be useful when serializing complex types like dates,\narrays, or objects into strings. You can also control whether or not a\ngiven property can be serialized. Returning `undefined` from a serialization\nfunction for any property means this property will not be part of the\nserialized object. Managing serialization is an important consideration in [routing](AppStateAndRouting.html). \nWe’ll see how this works when we discuss routing in a later chapter.\n\n```\ndefine: {\n  locationIds: {\n    serialize: false\n  }\n}\n```\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Observables](Observables.html)</span>\n<span class=\"pull-right\">[Stache Templates &rsaquo;](StacheTemplates.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "TheDefinePlugin",
    "title": "The Define Plugin",
    "type": "page",
    "parent": "Tutorial",
    "order": 4,
    "disabletableofcontents": true,
    "comment": " "
  },
  "Tutorial": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/tutorial.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n*Better Apps, Faster*\n\nCanJS is a lightweight, modern JavaScript <a href=\"https://en.wikipedia.org/wiki/Model_View_ViewModel\" target=\"_blank\">MVVM</a>\nframework that’s fast and easy to use, while remaining robust and extensible\nenough to power some of the most trafficked websites in the world. This guide \nwill walk you through an analysis of a small e-commerce app built with CanJS called __Place My Order__. \nIn each relevant section, we’ll give you some code to play with\nso you will have hands on experience working with CanJS.\n\n![place-my-order.com home page](../can/guides/images/application-design/Home.png)\n\nFor a version of this guide that walks through testing, documenting, building, and deploying the same\napplication, checkout [DoneJS's In Depth Guide](http://donejs.com/place-my-order.html).  This\nguide focuses more on the CanJS parts. \n\n## The Basics\n\nEvery CanJS application contains:\n\n- [Observables](#observables),\n- [Models](#models),\n- [ViewModels](#view-models)\n- [Views](#views),\n- [Custom Elements](#custom_elements), and\n- [Routing with an AppViewModel](#routing)\n\n<a name=\"observables\"></a>\n### Observables\nObservable objects provide a way for you to make changes to data and listen to\nthose changes. Observables such as [can.List](../docs/can.List.html), [can.Map](../docs/can.Map.html), and\n[can.compute](../docs/can.compute.html) provide the\nfoundation for models, view-models, view bindings, and even routing in your app. [can.compute](../docs/can.compute.html)\nis able to combine observable values into new observable values. \n\n[Example: Creating a derived value from source observables.](http://justinbmeyer.jsbin.com/koqaxe/edit?js,console)\n\n```\nvar info = can.compute(function(){\n  return person.attr(\"first\")+\" \"+person.attr(\"last\")+\n    \" likes \"+ hobbies.join(\", \")+\".\";\n});\n```\n\nThe [define plugin](../docs/can.Map.prototype.define.html) allows you to define rich property behaviors on\ncustom Map types. \n\n[Example: Creating a derived value as part of a custom type.](http://justinbmeyer.jsbin.com/wuwifaf/edit?js,console)\n```\nPerson = can.Map.extend({\n  define: {\n    fullName: {\n      get: function(){\n        return this.attr(\"first\")+\" \"+this.attr(\"last\");\n      }\n    }\n  }\n});\n```\n\n\n<a name=\"models\"></a>\n### Models\nModels let you get and modify data from the server. They also hydrate \nraw, serialized service data into more useful (and observable) typed \ndata in the client. [can.Model](../docs/can.Model.html) makes it easy to connect to restful services\nand perform Create, Retrieve, Update, and Delete (CRUD) operations. \n\nFor applications requiring real-time, high performance, restful data connections you should check out [can-connect](http://connect.canjs.com/).\n\n[Example: Simulate a restful service and create, update, and delete its data.](http://justinbmeyer.jsbin.com/codubev/edit?js,console)\n```\n// Create an order.\nvar order = new Order({\n  price: 20\n});\n\n// Create it on the server.\norder.save().then(function(order){\n  // Change its values and\n  // update it on the server.\n  return order.attr(\"price\",22)\n       .save();\n}).then(function(order){\n  // Destroy it on the server.\n  return order.destroy();\n});\n```\n\n<a name=\"view-models\"></a>\n### ViewModels\n\nViewModels contain the state and model data used by views to create HTML. They also\ncontain methods that the views can call. Custom [can.Map](../docs/can.Map.html) types\nare used as easily unit-testable view-models.  \n\n[Example: Define and test a view-model that derives values from source state.](http://jsbin.com/sotero/edit?js,output)\n```\nvar RestaurantListVM = can.Map.extend({\n  define: {\n    restaurants: {\n      get: function() {\n        var state = this.attr('state'),\n            city = this.attr('city');\n\n        if(state && city) {\n          return Restaurant.findAll({\n            'address.state': state,\n            'address.city': city\n          });\n        }\n\n        return null;\n      }\n    }\n  }\n});\n```\n\n<a name=\"views\"></a>\n### Views \n\nViews are passed a view-model and generate visual output that’s meaningful to a user - in our case that\noutput is HTML.  Views are able to:\n\n- Listen to changes in view-models and models and update the HTML (__one-way bindings__). \n- Listen to HTML events, like clicks, and call methods on the view-models and models (__event bindings__).\n- Listen to form elements changing and update view-model and model data (__two-way bindings__). \n\nIn CanJS, the preferred method for creating views is using [can.stache](../docs/can.stache.html) \ntemplates. `can.stache` uses mustache/handlebars syntax. `can.stache`'s event and two-way binding\nsyntaxes can be found at [can.view.bindings](../docs/can.view.bindings.html).\n\nAt this time, `can.stache` is supplied as a supporting\nlibrary, which means you must explicitly add it to your application. We’ll see\nhow to do that when we set up our application in the next chapter. In 3.0, \nStache will part of the core CanJS lib.\n\n[Example: Generate HTML for the previous example's view-model.](http://justinbmeyer.jsbin.com/gewavi/edit?html,output)\n```\n<label>State</label>\n{{#if states.isPending}}\n  <select disabled><option>Loading...</option></select>\n{{else}}\n  <select {($value)}=\"state\">\n    {{^if state}}\n      <option value=\"\">Choose a state</option>\n    {{/if}}\n    {{#each states.value}}\n      <option value=\"{{short}}\">{{name}}</option>\n    {{/each}}\n  </select>\n{{/if}}\n```\n\n<a name=\"custom_elements\"></a>\n### Custom Elements\n\nCustom HTML Elements are how CanJS encapsulates and orchestrates different pieces of \nfunctionality within an application. Custom elements are built with \n[can.Component](../docs/can.Component.html) and combine a\nview-model and view.\n\n[Example: Encapsulate rich select behavior with a custom <select-loader> element.](http://justinbmeyer.jsbin.com/sonuwuc/edit?html,js,output)\n```\n<select-loader {promise}=\"states\" {(value)}=\"state\"\n               choose-text=\"Choose a state\">\n  {{#each states.value}}\n    <option value=\"{{short}}\">{{name}}</option>\n  {{/each}}\n</select-loader>\n```\n\n<a name=\"routing\"></a>\n### Routing with an AppViewModel\n\nCanJS maintains a reciprocal relationship between the browser's url\nand a [can.Map](../docs/can.Map.html) view-model. This view-model instance\nrepresents the state of the application as a whole and so is\ncalled the `appViewModel`.  When the url changes,\nCanJS will update the properties of the `appViewModel`.  When\nthe `appViewModel` changes, CanJS will update the url.  \n\n[can.route](../docs/can.route.html) is used to setup the relationship between the \n`appViewModel` and the URL. It can be used with both [pushstate](../docs/can.route.pushstate.html) and\nhashchange (the default) routing.  \n\n[Example: Route between <home-page> and <restaurants-page> custom elements.](http://jsbin.com/surokag/edit?html,js,output)\n```\n{{#eq page 'home'}}\n  <home-page/>\n{{else}}\n  <restaurants-page/>\n{{/eq}}\n```\n```\nvar AppViewModel = can.Map.extend({\n  define: {}\n});\n// Create an instance of that map\nvar appViewModel = new AppViewModel();\n\n// Connect the map to the browser's URL\ncan.route.map(appViewModel);\n\n// Define pretty routing rules\ncan.route(\":page\",{page: \"home\"});\n\n// Start the two-way binding between the URL and the `appViewModel`.\ncan.route.ready();\n```\n\nApplication ViewModels free developers \nfrom worrying about what the url looks like. Instead, you focus on\nupdating the state of the application.\n\n## Using the Getting Started Guide\nEach chapter in the Getting Started Guide is prefaced with an overview of the\ntopics covered in that chapter. The overview section also contains a link where\nyou can download a zip file containing the code relevant to that chapter, as follows:\n\n- - -\n**In this Chapter**\n - Topic 1\n - Topic 2\n - Connecting `can.Model`’s with `can.Component`’s\n\nGet the code for: [chapter 0](/guides/examples/PlaceMyOrder/ch-0_canjs-getting-started.zip)\n\n- - -\n\n- - -\n\n<span class=\"pull-right\">[Setup &rsaquo;](Setup.html)</span>\n\n</div>\n<script src=\"http://static.jsbin.com/js/embed.min.js?3.35.5\"></script>\n\n",
    "description": "\n",
    "name": "Tutorial",
    "title": "Getting Started Tutorial",
    "type": "page",
    "parent": "guides",
    "order": 3,
    "disabletableofcontents": true,
    "comment": " "
  },
  "ViewModels": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/view-models.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Getting and Setting Scope Properties\n - View Models\n\nGet the code for: [chapter: view models](/guides/examples/PlaceMyOrder/ch-5_canjs-getting-started.zip)\n\n- - -\n\nIn the last chapter, we created the `currentRestaurant` component, and included it in our\ntemplate. Let’s add a little bit more advanced functionality: two select elements,\nwhere selecting an option in the first one changes the options in the second.\n\nOpen your `components/restaurant_list/restaurant_list.stache` and edit it as follows:\n\n```\n<div class=\"restaurants\">\n  <h2 class=\"page-header\">Restaurants</h2>\n  <form class=\"form\">\n    <div class=\"form-group\">\n      <label>State</label>\n      <select {($value)}=\"state\">\n        {{^if state}}\n        <option value=\"\">Choose a state</option>\n        {{/if}}\n        {{#each states}}\n        <option value=\"{{name}}\">{{name}}</option>\n        {{/each}}\n      </select>\n    </div>\n    <!-- The city select will go here -->\n  </form>\n\n  <!-- Restaurants code will go here -->\n</div>\n```\n\nIn the above code, you can see one select element for selecting a state. You can\nsee `{{#each}}` being used to create the list of options. You can also see that\nif no state is selected, the “Choose a state” message is included as an option\nuntil one has been selected.\n\nLet’s modify our `components/restaurant_list/restaurant_list.js` file to include\nwhat’s needed for our partial:\n\n```\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: can.Map.extend({\n    define: {\n      state: {\n        value: null,\n        set: function(newState) {\n          if (newState) {\n            alert('Selected “' + newState + '” state.');\n          }\n          return newState;\n        }\n      },\n      states: {\n        value: [\n          {\n            cities: ['Green Bay', 'Milwaukee'],\n            name: 'Wisconsin'\n          },\n          {\n            cities: ['Detroit', 'Ann Arbor'],\n            name: 'Michigan'\n          },\n          {\n            cities: ['Chicago', 'Peoria'],\n            name: 'Illinois'\n          }\n        ]\n      },\n      // City code will go here\n    }\n  })\n});\n```\n\nHere we’re using [the define plugin](TheDefinePlugin.html) to set up two new\nproperties: \n- `state` to keep track of the selected state, and \n- `states` with the list of states that can be selected. \n\nIn the `state` setter, we’re showing an alert when a new state is selected. \nIf you refresh the Restaurants page, you should see a select element with the \nstates as options; when you select a state, an alert will appear with the selected \nstate’s name.\n\n![set up state selector](../can/guides/images/view-models/view_model_state.png)\n\n## Getting and Setting Scope Properties\nIt’s important to understand how to get and set the properties\nof the view model. Getting and setting are done through the `attr` function off of\nthe `viewModel` object, in this case `this` is bound to the scope, because we’re\nwithin a method of the scope. Let’s look at an example.\n\nOpen up `components/restaurant_list/restaurant_list.js` and replace this:\n\n```\n// City code will go here\n```\n\nwith this:\n\n```\n      cities: {\n        get: function() {\n          var state = this.attr('state');\n          return state && this.attr('citiesByState')[state];\n        }\n      },\n      citiesByState: {\n        get: function() {\n          var citiesByState = {};\n          this.attr('states').forEach(function(state) {\n            citiesByState[state.name] = state.cities;\n          });\n          return citiesByState;\n        }\n      },\n      city: {\n        value: null\n      }\n```\n\nThis code creates three new properties: \n- `city` with the name of the city that’s selected, \n- `citiesByState` which is an object that has the list of cities by state name, and \n- `cities` which is the list of cities for the selected state.\n\nLet’s update the stache file to take advantage of these new properties.\nOpen `components/restaurant_list/restaurant_list.stache` and find this line:\n\n```\n<!-- The city select will go here -->\n```\n\nand replace it with this:\n\n```\n    <div class=\"form-group\">\n      <label>City</label>\n      <select {($value)}=\"city\">\n        {{^if city}}\n        <option value=\"\">Choose a city</option>\n        {{/if}}\n        {{#each cities}}\n        <option>{{.}}</option>\n        {{/each}}\n      </select>\n    </div>\n```\n\nThis new part of the template will show a select element with the cities\nfor the selected state as options. Note that when no city is selected,\nthe element will have a “Choose a city” option.\n\nIf you refresh the Restaurants page, you’ll see the new city select\nelement that has options as soon as you select a state. However, there’s\na bug: if you change the state, the first city for the new state is automatically\nselected, even though the user hasn’t made a city choice. Let’s fix this\nby nullifying the city when the state changes. Find the state setter:\n\n```\n        set: function(newState) {\n          if (newState) {\n            alert('Selected “' + newState + '” state.');\n          }\n          return newState;\n        }\n```\n\nand replace it with this:\n\n```\n        set: function() {\n          // Remove the city when the state changes\n          this.attr('city', null);\n        }\n```\n\nNotice that we are nullifying the city property when the state changes.\nIf you refresh the Restaurants page in your browser, select a state,\nselect a city, then select another state, you’ll see the “Choose a city”\noption in the city select element instead of the first city in that\nstate.\n\n![set up state selector](../can/guides/images/view-models/view_model_city.png)\n\n## Separating the Component & View Model\nIt’s considered a best practice to keep your `can.Components`\nthin. This helps maintain readability and maintainability. To accomplish this,\nyou extract your scope from the `can.Component` into a `can.Map`.\n\nOpen up `components/restaurant_list/restaurant_list.js` and replace the\ncontents of the file with this:\n\n```\nvar RestaurantListViewModel = can.Map.extend({\n  define: {\n    state: {\n      value: null,\n      set: function() {\n        // Remove the city when the state changes\n        this.attr('city', null);\n      }\n    },\n    states: {\n      value: [\n        {\n          cities: ['Green Bay', 'Milwaukee'],\n          name: 'Wisconsin'\n        },\n        {\n          cities: ['Detroit', 'Ann Arbor'],\n          name: 'Michigan'\n        },\n        {\n          cities: ['Chicago', 'Peoria'],\n          name: 'Illinois'\n        }\n      ]\n    },\n    cities: {\n      get: function() {\n        var state = this.attr('state');\n        return state && this.attr('citiesByState')[state];\n      }\n    },\n    citiesByState: {\n      get: function() {\n        var citiesByState = {};\n        this.attr('states').forEach(function(state) {\n          citiesByState[state.name] = state.cities;\n        });\n        return citiesByState;\n      }\n    },\n    city: {\n      value: null\n    }\n  }\n});\n\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: RestaurantListViewModel\n});\n```\n\nIf you go back out to your application and refresh the page, it should all\nlook and work the same. What we’ve done, by separating out the view model, \nis make the code easier to read and maintain.\n\nIn the next chapter, we’ll learn about working with more realistic data by\nadding REST service interaction with `can.Model`.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Components](Components.html)</span>\n<span class=\"pull-right\">[Data Models and Fixtures &rsaquo;](DataModelsAndFixtures.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "ViewModels",
    "title": "View Models",
    "type": "page",
    "parent": "Tutorial",
    "order": 8,
    "disabletableofcontents": true,
    "comment": " "
  },
  "WebServiceCommunication": {
    "src": {
      "path": "docs/can-guides/getting-started-tutorial/web-service-communication.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n  - Saving and Updating a can.Model\n\nGet the code for: [chapter: web service communication](/guides/examples/PlaceMyOrder/ch-9_canjs-getting-started.zip)\n\n- - -\n\nTo illustrate sending data to a service, let’s implement saving an order in\nour `pmo-order` component. In the `components/order/order.js` file, locate\nwhere the `placeOrder` property is defined:\n\n```\n  placeOrder: function() {\n  },\n```\n\nand replace it with this implementation:\n\n```\n  placeOrder: function() {\n    var order = this.attr('order');\n    this.attr('saveStatus', order.save());\n    return false;\n  },\n```\n\nLet’s see what's going on here:\n - The first line in the getter function gets the `order`, \n - the second sets the `saveStatus` property on the component’s view model to whatever the `save` method on the `order` object returns, and\n - the third line returns `false` to stop the `form` element’s default submission behavior.\n\n## Saving and updating a model\nLet’s look at a few items in the code above.\nUnlike data access functions (e.g., `findAll`, `findOne`),\nwhich are called statically off of the prototype, the `save`, `update`, and\n`delete` functions are called off of a specific instance of a model. So, if\nwe want to create a new order, we will need to work with an instance of the\n`Order` model.\n\nTo provide fixture support for saving our `can.Model`, open up `models/fixtures.js`\nand add the following fixture:\n\n```\ncan.fixture({\n  'POST /api/orders': function(request, response){\n    var data = request.data;\n\n    response(can.extend({}, data, {\n      \"_id\":\"556f1503fdf0425207000001\"\n    }));\n  },\n\n  'GET /api/orders': 'models/orders.json'\n});\n```\n\nHere, you can see that we’re implementing the `save` functionality by\nresponding to `POST` requests to `/api/orders` with the original request\ndata, plus an `_id` property.\n\nWe also added support for `GET` requests to `/api/orders` so we can provide\norder history functionality.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Event Handling](EventHandling.html)</span>\n<span class=\"pull-right\">[Recap &rsaquo;](Recap.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "WebServiceCommunication",
    "title": "Web Service Communication",
    "type": "page",
    "parent": "Tutorial",
    "order": 12,
    "disabletableofcontents": true,
    "comment": " "
  },
  "BuildAnApplicationWithData": {
    "src": {
      "path": "docs/can-guides/recipes/build-an-app-with-remote-data.md"
    },
    "body": "\nIn CanJS, `can.Model` adds functionality to `can.Map` to\nwork with data on a server.  It enables you to:\n\n - Get and modify data from a server\n - Listen to changes made to the data on the server\n - Unify service data with other objects in your application\n\n`can.Model` allows you to access data from a server\neasily:\n\n```\nvar Todo = can.Model.extend({\n  findAll: 'GET /todos',\n  findOne: 'GET /todos/{id}',\n  create:  'POST /todos',\n  update:  'PUT /todos/{id}',\n  destroy: 'DELETE /todos/{id}'\n},{});\n```\n\nUsing *any* server with a [*REST* interface](http://blog.mashape.com/post/60820526317/list-of-40-tutorials-on-how-to-create-an-api),\n `can.Model` enables create, read, update, and destroy functionality.\n\n## Create a Chat Application\n\nTo put together a chat application, we’ll use two methods\nfrom `can.Model` to fetch the messages and create new ones:\n\n```\nvar Message = can.Model({\n\tfindAll : 'GET ' + myServerUrl + '/messages',\n\tcreate : 'POST ' + myServerUrl + '/messages'\n},{});\n```\n\nIn a chat component's scope, we will use the `Message` model to\nsave new messages and observe changes to the Model.\n[`new Message.List({})`](http://canjs.com/docs/can.Model.List.html#sig_newcan_Model_List__models__) is a shortcut to perform\nthe [`findAll`](http://canjs.com/docs/can.Model.findAll.html) operation on a `can.Model` and\nreturn a `can.List`.\n\n```\n...\n\tscope: {\n\t\t\tmessages: new Message.List({}),\n\t\t\tnewMessage: \"\"\n...\n```\n\nThe tabs Component used `can-click` to listen for click events.\nSince this chat application uses a `<form>` for sending messages, we’ll use\n`can-submit` to specify an event handler.\n\nThere’s one more helper used in the template: [`can-value`](http://canjs.com/docs/can.view.bindings.can-value.html).\nThis automatically two-way binds the value of an input field to an observable\nproperty on the `scope` of the component (in this case, `newMessage`).\n\n```\ncan.Component.extend({\n  tag: 'chat',\n  template: '<ul id=\"messages\">' +\n\t\t\t  '{{#each messages}}' +\n\t\t\t  '<li>{{body}}</li>' +\n\t\t\t  '{{/each}}' +\n\t\t\t'</ul>' +\n\t\t\t'<form id=\"create-message\" action=\"\" can-submit=\"submitMessage\">' +\n\t\t\t\t'<input type=\"text\" id=\"body\" placeholder=\"type message here...\"' +\n\t\t\t\t'can-value=\"newMessage\" />' +\n\t\t\t'</form>',\n...\n```\n\nWhen `submitMessage` is called, a new `Message` is created\nwith `new Message()`. Since `can-value` was declared on the `input` element, `newMessage` will\nalways be the current text in the `input` field.\nThe body of the message is fetched from\nthe Component's `newMessage` attribute when a user submits the form.\n\nTo save the new message to the server, call `save()`.\n\n```\nsubmitMessage: function(scope, el, ev){\n\tev.preventDefault();\n\tnew Message({body: this.attr(\"newMessage\")}).save();\n\tthis.attr(\"newMessage\", \"\");\n}\n```\n\nFinally, when a new `Message` is created, the `messages` list\nmust be updated.\n\n```\nevents: {\n\t'{Message} created': function(construct, ev, message){\n\t\tthis.scope.attr('messages').push(message);\n\t}\n}\n```\n\nThere are two ways that messages are added: from the current user,\nor from another user. In the next section, we demonstrate how to use\n[socket.io](http://socket.io/) to update the `Message` model with messages\nfrom other users in real time. Binding to the `created` event for **all**\nmessages allows us to create a single entry point that pushes new messages\nto the `scope`, [regardless of where those messages are from.](http://canjs.com/docs/can.Model.html#section_Listentochangesindata)\n\nWhen the chat Component is loaded, messages are loaded from the server\nusing `can.Model` and `new Message.List({})`.  When a new message is\nsubmitted:\n\n1. `submitMessage` is called via the event handler bound by the `can-submit` attribute\n2. a new `Message` is created and saved to the server\n3. `'{Message} created'` detects this change and adds the new message to `messages`\n4. The template is automatically updated since `messages` is an observable `can.List`\n\n## Add real-time functionality\n\nThis example uses [socket.io](http://socket.io/)\nto enable real-time functionality. This guide won't go\ninto detail on how to use `socket.io`, but for real-time\nchat the application needs two more things.\n\nWhen a message is created on another chat client, `socket.io`\nwill notify this client by triggering the `message-created` event,\nwich will render the new message in the page by adding it to the\n`Message` model.\n\n```\nvar socket = io.connect(myServerUrl);\nsocket.on('message-created', function(message){\n\tnew Message(message).created();\n});\n```\n\nTo keep the `created` event from firing\ntwice, we modify the `create` function in the model.\nIf there was simply a `return` statement, `Model` would\ncreate and fire a `create` event, which `socket` is already\ndoing. By returning a `Deferred`, we prevent firing of\none of these events.\n\n```\nvar Message = can.Model({\n\tfindAll : 'GET ' + myServerUrl + '/messages',\n\tcreate : function(attrs) {\n\t\t$.post(myServerUrl + '/messages', attrs);\n\t\t//keep '{Message} created' from firing twice\n\t\treturn $.Deferred();\n\t}\n},{});\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/afC94/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n",
    "description": "\n",
    "name": "BuildAnApplicationWithData",
    "title": "Build an App with Remote Data",
    "type": "page",
    "parent": "Recipes",
    "order": 6,
    "comment": " "
  },
  "BuildWidgets": {
    "src": {
      "path": "docs/can-guides/recipes/build-widgets.md"
    },
    "body": "\nPrevious recipes have demonstrated how to change page content and introduced\nevent handling. The following recipes will introduce `can.Component`,\nwhich allows for straightforward widget construction by packaging\ntemplate, state, and event handling code in one place.\n\nWhile similar *behavior* can be accomplished with `can.Control`,\nbuilding a Component enables building reusable widgets using custom\nHTML tags.\n\n## Create a Component\n\nThe previous recipe that displays a list of people can instead\nbe represented as a component.\n\n```\n<people></people>\n```\n\nBy specifying `people` as the tag, a component is created wherever `<people></people>`\nappears in a template.\n\n```\ncan.Component.extend({\n\ttag: 'people',\n```\n\nThe `scope` object on a `Component` contains the component's state, data,\nand behavior. Here, it specifies how to `remove` a person from the list:\n\n```\n\tscope: {\n\t\tpeople: people,\n\t\tremove: function( person ) {\n\t\t\tvar people = this.attr(\"people\");\n\t\t\tvar index = people.indexOf(person);\n\t\t\tpeople.splice(index, 1);\n\t\t}\n\t}\n});\n```\n\nThe template for the component itself is passed via the `template`\nproperty. This can either be an external file or a string.\nEach `li` uses `can-click`, [which declares an event binding.](http://canjs.com/docs/can.view.bindings.can-EVENT.html)\nHere, `remove` inside the component's\nscope will be called with the relevant `people` object\nas an argument.\n\n```\nscope: {\n\ttemplate: '<ul>' +\n\t\t\t\t'{{#each people}}' +\n\t\t\t\t'<li can-click=\"remove\">' +\n\t\t\t\t\t'{{lastname}}, {{firstname}}' +\n\t\t\t\t'</li>' +\n\t\t\t\t'{{/each}}' +\n\t\t\t\t'</ul>',\n...\n```\n\nThis behaves similarly to the `can.Control` from above.\nHowever, the `<people>` tag can be used without having\nany knowledge about the inner workings of the widget.\nUsing declarative HTML tags, a component can be used\nwithout writing any javascript. The template, state,\nand behavior are all combined into one Component.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/WBM9z/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n## Build a Tabs Widget\n\nA tabs widget could be instantiated with the following HTML:\n\n```\n<tabs>\n\t<panel title=\"Fruit\">Oranges, Apples, Pears</panel>\n\t<panel title=\"Vegetable\">Carrot, Lettuce, Rutabega</panel>\n\t<panel title=\"Grains\">Bread, Pasta, Rice</panel>\n</tabs>\n```\n\nA designer that understands HTML can put together a template for a `tabs`\nwidget without understanding anything other than the syntax.\nThis is one of the most useful features of components.\n\n## Tabs Widget Behavior\n\nBefore implementing the component itself, we’ll\ndefine an observable *view model*--the `scope` object\nof the UI element. This makes the code modular and easier\nto manage (and also allows for unit testing).\n\nIn order to accurately represent a tabs widget,\na `TabsViewModel` needs:\n<ul>\n<li>An observable list of panels</li>\n<li>A state variable with the active panel</li>\n<li>Helper methods to add, remove, and activate panels</li>\n</ul>\n\nSince TabsViewModel is a `can.Map`, the `panels` property is\nautomatically converted to a `can.List`.\nThe `active` property references the `panel` object\nthat should currently be displayed.\n\n```\nvar TabsViewModel = can.Map.extend({\n\tpanels: [],\n\tactive: null,\n\taddPanel: function( panel ){\n\t\tvar panels = this.attr(\"panels\");\n\t\tpanels.push(panel);\n\t\tpanel.attr(\"visible\", false);\n\t\t//activate panel if it is the first one\n\t\tif ( panels.attr(\"length\") === 1 ){\n\t\t\tthis.activate( panel );\n\t\t}\n\t},\n\tremovePanel: function( panel ){\n\t\tvar panels = this.attr(\"panels\");\n\t\tvar index = panels.indexOf(panel);\n\t\tpanels.splice(index, 1);\n\t\t//activate a new panel if panel being removed was the active panel\n\t\tif( this.attr(\"active\") === panel ){\n\t\t\tpanels.attr(\"length\") ? this.activate(panels[0]) : this.attr(\"active\", null)\n\t\t}\n\t},\n\tactivate: function( panel ){\n\t\tvar active = this.attr(\"active\")\n\t\tif( active !== panel ){\n\t\t\tactive && active.attr(\"visible\", false);\n\t\t\tthis.attr(\"active\", panel.attr(\"visible\", true));\n\t\t}\n\t}\n});\n```\n\n### Tabs Widget Component\n\nNow that the view model is defined, making a component is simply\na matter of defining the way the tabs widget is displayed.\n\nThe template for a `tabs` component needs a list of panel titles\nthat will `activate` that panel when clicked. By calling `activate`\nwith a panel as the argument, the properties of the `panel` can\nbe manipulated. By changing the `visible` property of a panel,\na template can be used to display or hide the panel accordingly.\n\nFor this component, our template should look something like this:\n\n```\n<tabs>\n\t<panel title=\"Fruits\">Apples, Oranges</panel>\n\t<panel title=\"Vegetables\">Carrots, Celery</panel>\n</tabs>\n```\n\nA designer can create a `tabs` component with `panel` components inside it.\nThe `template` object on the tabs component's scope needs to be able to render\nthe content that is inside of the `<tabs>` tag. To do this, we simply use the\n`<content>` tag, which will render everything within the component's tags:\n\n```\ncan.Component.extend({\n\ttag: \"tabs\",\n\tscope: TabsViewModel,\n\ttemplate: \"<ul>\\\n\t\t\t\t{{#each panels}}\\\n\t\t\t\t\t<li can-click='activate'>{{title}}</li>\\\n\t\t\t\t{{/each}}\\\n\t\t\t\t</ul>\\\n\t\t\t\t<content />\"\n});\n```\n\nThe `tabs` component contains panels, which are also defined\nas components. The tabs template contains the logic for whether\nthe panel is visible (`visible` is controlled by the tabs\ncomponent's `activate` method).\n\nEach panel's `scope` contains a title, which should be\ntaken from the `title` attribute in the `<panel>` tag.\nIf you want to set the string value of a Component's\nattribute as a `scope` variable, use  `@'`.\n\n```\ncan.Component.extend({\ntag: \"panel\",\ntemplate: \"{{#if visible}}<content />{{/if}}\",\nscope: {\n\ttitle: \"@\"\n},\n...\n```\n\nIn addition to the `scope` property, a component has an\n[`events` property](http://canjs.com/docs/can.Component.prototype.events.html).\nThis `events` property uses a `can.Control` instantiated inside\nthe component to handle events.\n\nSince we defined behavior for adding panels on the parent\n`tabs` component, we should use this method whenever a `panel`\nis inserted into the page (and an `inserted` event is triggered).\nTo add the panel to the `tabs` component's scope, we call the\n`addPanel` method by accessing the parent scope with `this.element.parent().scope()`:\n\n```\n...\n\tevents: {\n\t\tinserted: function() {\n\t\t\tthis.element.parent().scope().addPanel( this.scope )\n\t\t},\n\t\tremoved: function() {\n\t\t\tthis.element.parent().scope().addPanel( this.scope )\n\t\t}\n\t}\n});\n```\n\nWith this component, any time a `<tabs>` element with\n`<panel>` elements is put in a page, a tabs widget will\nautomatically be created. This allows application behavior\nand design to be compartmentalized from each other.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/x6TJK/2/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n",
    "description": "\n",
    "name": "BuildWidgets",
    "title": "Build Widgets/UI Elements",
    "type": "page",
    "parent": "Recipes",
    "order": 5,
    "comment": " "
  },
  "CreateALiveTimestamp": {
    "src": {
      "path": "docs/can-guides/recipes/create-a-live-timestamp.md"
    },
    "body": "\nThis recipe demonstrates how to generate a 'live' timestamp\nthat displays in a human-readable format. This means handling\napplication state that changes over time, as well as making\ninformation rendered in a template human-readable using a helper function.\n\nFirst, we’ll add a `createdAt` property to the data like:\n\n```\n var data = new can.Map({\n   message: \"Hello World\",\n   createdAt: new Date()\n });\n```\n\nOn the page, this should be displayed as a human readable\ntimestamp:\n\n```\n <h1>Hello World <i>created just now</i></h1>\n```\n\n__and__ as time passes, the timestamp will update to:\n\n```\n<h1>Hello World <i>created a few seconds ago</i></h1>\n```\n\n__and__ then update to \"some seconds ago\" and so forth.\n\nTo accomplish this, create a `prettyDate` [stache helper](../docs/can.stache.helper.html) that converts\ndates into a human readable format.  A helper function is called from within the template where its result\nwill be displayed.  The following calls `prettyDate` with an observable value of `createdAt`.\n\n```\n<h1>\n  {{message}}\n  <i>created {{prettyDate createdAt}}</i>\n</h1>\n```\n\nTo call a function from a template, [register](../docs/can.stache.registerHelper.html) it with `can.view`.\nThe third argument passed to `can.view` is an object with helper functions, so the `dateHelper` function\ncan be registered as `prettyView`.\n\n```\nvar dateHelper = function ( date ) {\n\t//helper function\n};\n\nvar frag = can.view(\"app-template\", data, {prettyDate: dateHelper});\n```\n\nIn this helper, `date` is not a Date object, instead it is an observable [can.compute](../docs/can.compute.html) that\ncontains the `createdAt` value.  A `can.compute` is an observable that contains a single value.  To read the value,\ncall the compute like you would any other function:\n\n```\ndate() //-> Date\n```\n\nWe need to compare `date` with the current time. The current time\nwill be represented by a compute:\n\n```\nvar now = can.compute( new Date() )\n```\n\nAs the current time changes, we update `now` with the new time. To change the value of a `can.compute`,\ncall it with its new value as an argument:\n\n```\n// update that property every second\nsetTimeout(function(){\n\tnow( new Date() );\n\tsetTimeout(arguments.callee, 1000);\n}, 1000)\n```\n\nThe `prettyDate` helper will read and compare the `date` and `now` compute to\nget the time elapsed in seconds:\n\n```\nvar timeElapsed = ( now() - date() ) / 1000\n```\n\nUsing the `timeElapsed`, `prettyDate` returns human readable timestamps:\n\n```\nif(timeElapsed < 1.2){\n\treturn \"just now\"\n} else if (timeElapsed < 10) {\n\treturn \"a couple seconds ago\"\n}\n...\nelse {\n\treturn Math.round(difference/60)+\" minutes ago\"\n}\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/VQNSH/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "CreateALiveTimestamp",
    "title": "Create a Live Timestamp",
    "type": "page",
    "parent": "Recipes",
    "order": 3,
    "comment": " "
  },
  "HandleUserInteraction": {
    "src": {
      "path": "docs/can-guides/recipes/handle-user-interaction.md"
    },
    "body": "\nWhen a user does something, such as clicking, an `event` occurs. Event handlers specify\nhow [JavaScript should respond to an event](http://bitovi.com/blog/2010/10/a-crash-course-in-how-dom-events-work.html).\n\nThis recipe will introduce handling a click event using a [`can.Control`](http://canjs.com/docs/can.Control).\nUsing a list of people like previous recipes, clicking any individual person's name\nwill remove that person from the list.\n\nPrevious examples have used jQuery's event handlers:\n\n```\n$(\"#push\").click(function(){\n  //handle the event\n});\n```\n\nCanJS provides a few different ways to respond to events. As well as\nmaking application code simpler, using CanJS to handle events can help to\nautomatically prevent [memory leaks](http://bitovi.com/blog/2012/04/zombie-apocolypse.html).\n\nTo handle events, extend `can.Control`.\n\n```\nvar PeopleList = can.Control.extend({\n\t//behavior\n});\n```\n\nYou create a `can.Control` by [calling it as a constructor function](http://canjs.com/docs/can.Control.html#sig_newcan_Control_element_options_).\nThe first argument is the element the control will be created on.\nThe second argument is an object of options.\n\n\tnew PeopleList('#my-app', {people: people});\n\nA `can.Control` handles events with functions declared with two arguments: an\nelement or list of elements (using a jQuery-style selector) and a specific event.\nBelow, this is 'li click', meaning when any `li` elements that are `clicked` the\nfunction will be called to handle the click event.\n\n```\nvar PeopleList = can.Control.extend({\n  init: function( element, options ){\n  \tthis.people = new can.List(options.people);\n  \tthis.element.html( can.view('app-template', {\n  \t\t//defines people in the template as the observable can.List\n  \t\tpeople: this.people\n  \t}));\n  },\n  'li click': function( li, event ){\n  \t//Handle the click event\n  }\n};\n```\n\nWhen the constructor function is called and the `can.Control`\nis instantiated:\n\n1. The `init` method is called\n2. An observable `can.List` is created from `people`\n3. The list is rendered using `can.view` so when the list changes, so will the view\n\n```\nvar people = [\n\t{firstname: \"John\", lastname: \"Doe\"},\n\t{firstname: \"Emily\", lastname: \"Dickinson\"},\n\t{firstname: \"William\", lastname: \"Adams\"},\n\t{firstname: \"Stevie\", lastname: \"Nicks\"},\n\t{firstname: \"Bob\", lastname: \"Barker\"}\n];\n```\n\nWhen the event handler for a `click` runs, it needs a way\nto access the object associated with the `li` that was clicked.\nWith the [`data`](http://canjs.com/docs/can.stache.helpers.data.html) helper,\nthe element will retain a reference\nto the object it is associated with (in this case, a `person`).\n\n```\n<ul>\n{{#each people}}\n\t<li {{data 'person'}}>\n\t\t{{lastname}}, {{firstname}}\n\t</li>\n{{/each}}\n</ul>\n```\n\nFinally, the event handler must be defined. In a `can.Control`,\nan event handler function [can be defined with a string containing\na selector and an event](http://canjs.com/docs/can.Control.html#section_Listeningtoevents).\nIn this case, these are `li` and `click`, respectively,\nsince we want to handle click events on each list item.\n\n```\nvar PeopleList = can.Control.extend({\n  init: function(){\n\t...\n  },\n  'li click': function( li, event ) {\n  \tvar people = this.people;\n  \tvar person = li.data('person');\n  \tvar index = people.indexOf(person);\n  \tpeople.splice(index, 1);\n  }\n});\n```\n\nWhen a user clicks a list item:\n\n 1. The function bound to `li click` is called\n 2. The object associated with that list item is accessed using the `data` helper\n 3. That 'person's data is removed from the observable list of `people`\n 4. The template updates automatically\n\nAs a reminder, though event handlers respond to actions on the page,\nthey should *change application state or data* (e.g. make a change to a `can.Map`)\nrather than modifying the DOM directly (e.g. toggling a class).\nThis will update the page automatically, keeping code manageable.\n\nThis is *one* way to handle events. Others will be covered\nin the following recipes while building widgets.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/F9kzt/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "HandleUserInteraction",
    "title": "Handle User Interaction",
    "type": "page",
    "parent": "Recipes",
    "order": 4,
    "comment": " "
  },
  "ShowAList": {
    "src": {
      "path": "docs/can-guides/recipes/recipes-show-a-list.md"
    },
    "body": "\nTo make an Array observable, pass it to [can.List](../docs/can.List.html).\n\n```\nvar people = new can.List([\n\t{firstname: \"John\", lastname: \"Doe\"},\n\t{firstname: \"Emily\", lastname: \"Dickinson\"}\n]);\n\nvar frag = can.view(\"app-template\", {people: people})\n$(\"#my-app\").html(frag);\n```\n\nTo show a list of data within a stache template, use the `#each` operator.\n\n```\n<ul>\n{{#each people}}\n  <li>\n\t{{lastname}}, {{firstname}}\n  </li>\n{{/each}}\n</ul>\n```\n\nInside the `#each` block, the attributes are scoped to individual\nobjects in the list of `people`.\n\nTo make changes to the list, use an Array method such as\n[push](/docs/can.List.prototype.push.html)\nor [pop](/docs/can.List.prototype.pop.html).\n\n```\n// adds a new person\npeople.push({firstname: \"Paul\", lastname: \"Newman\"})\n// removes the last person\npeople.pop()\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/Pgbpa/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "ShowAList",
    "title": "Show a List in a Template",
    "type": "page",
    "parent": "Recipes",
    "order": 3,
    "comment": " "
  },
  "Recipes": {
    "src": {
      "path": "docs/can-guides/recipes/recipes.md"
    },
    "body": "\n## Get Started\n\nThere are a variety of ways to get CanJS.  Read the [using CanJS guide](http://canjs.com/guides/Using.html)\nfor comprehensive list.  For the following recipes, we will load CanJS\nwith a `<script>` tag pointed to CanJS's CDN.\n\nCreate a file called `myapp.html` and put the following in it to get started:\n\n```\n<script src=\"//code.jquery.com/jquery-1.10.1.min.js\"></script>\n<script src=\"//canjs.com/release/2.0.4/can.jquery.js\"></script>\n<script type=\"text/stache\" id=\"app-template\">\n//Template will go here\n</script>\n<script>\n//Application code will go here\n</script>\n\n<!-- CanJS needs a place to put your application -->\n<div id=\"my-app\"></div>\n```\n\nTo follow along with the other recipes, you can also use\n[this JSFiddle](http://jsfiddle.net/donejs/GE3yf/) as a template.\n\nYou can also [Download CanJS](http://canjs.com/download.html)\nor follow [other tutorials](http://canjs.com/guides/Tutorial.html) to get\nstarted, but for the rest of the examples, we’ll be using this\nsetup.\n\n## Request a Recipe\n\nTo request a new recipe or vote on an upcoming one, [submit an issue](https://github.com/canjs/canjs.com/issues)\nto the `canjs.com` respository on GitHub.\n\n",
    "description": "\n",
    "name": "Recipes",
    "title": "Recipes",
    "type": "page",
    "parent": "guides",
    "order": 4,
    "comment": " "
  },
  "SayHelloWorld": {
    "src": {
      "path": "docs/can-guides/recipes/say-hello-world.md"
    },
    "body": "\nIn CanJS, content is displayed using *templates*.  Instead of manually\nchanging elements in the DOM, you create a template and CanJS\nautomatically updates the page from the data in your application code.\n\n## Template\n\nIn the template section of `myapp.html`, put the following:\n\n```\n<script type=\"text/stache\" id=\"app-template\">\n\t<h1>{{message}}</h1>\n</script>\n```\n\nThis template displays the value of `message`.\n\n## Pass message to the Template\n\nTemplates are rendered with [can.view](../docs/can.view.html), which takes two arguments: the first is the `id` of the template,\nand the second is the data passed to the template (in this case,\nan object with a `message` property).\n\nRender the template with a `message` and insert it into the page with:\n\n```\n<script>\n// Give message a value\nvar data = {message: \"Hello World!\"};\n\n// Pass the id of the template and the data, containing our message to can.view\nvar frag = can.view(\"app-template\", data);\n\n//Load the DocumentFragment in the page\n$(\"#my-app\").html( frag )\n</script>\n```\n\n> `frag` is a [DocumentFragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment). A DocumentFragment\n> is a lightweight container of HTMLElements that can be inserted in the page quickly. They can be used\n> anywhere a normal HTMLElement is used.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/GE3yf/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "SayHelloWorld",
    "title": "Say \"Hello World\"",
    "type": "page",
    "parent": "Recipes",
    "order": 1,
    "comment": " "
  },
  "ShowAndHideElements": {
    "src": {
      "path": "docs/can-guides/recipes/show-and-hide-elements.md"
    },
    "body": "\nInstead of showing and hiding elements by changing the DOM\ndirectly like:\n\n```\n$(\"h1\").show()\n$(\"h1\").hide()\n```\n\nMake the template show or hide those elements when a value\nchanges.\n\n```\n{{#if visible}}\n  <h1>{{message}}</h1>\n{{/if}}\n```\n\nWhen the button is clicked, change the observable value.\n\n```\ndata.attr(\"visible\", !data.attr(\"visible\"))\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/eFss4/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n### Application State\n\nTypically, it’s not a good idea to mix view state and application data.\nIn the previous example, the `message` is application data, while the\n`visible` property represents view state. In CanJS, state and data\nshould be separated using different observables.\n\n```\nvar data = new can.Map({message: \"Hello World!\"}),\n\tstate = new can.Map({visible: true});\n\nvar frag = can.view(\"app-template\", {\n  data: data,\n  state: state\n});\n```\n\nAs an application gets more complex, separating state from data\nmakes things more maintainable.\n",
    "description": "\n",
    "name": "ShowAndHideElements",
    "title": "Show and Hide Elements",
    "type": "page",
    "parent": "Recipes",
    "order": 3,
    "comment": " "
  },
  "UpdateText": {
    "src": {
      "path": "docs/can-guides/recipes/update-text.md"
    },
    "body": "\nCanJS will update the page automatically when [observable](http://sourcemaking.com/design_patterns/observer)\ndata changes. To make observable data, pass raw data to [can.Map](../docs/can.Map.html),\n[can.List](../docs/can.List.html) or [can.compute](../docs/can.compute.html) like:\n\n```\nvar data = new can.Map({message: \"Hello World!\"});\n```\n\nTo change the message, use the [attr()](../docs/can.Map.prototype.attr.html) method of `can.Map`.\n\n```\ndata.attr(\"message\", \"Goodbye World!\")\n```\n\nWhen the button is clicked in the example below, the message is\nchanged with `data.attr()`.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/quTtE/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n",
    "description": "\n",
    "name": "UpdateText",
    "title": "Update Text in the Page",
    "type": "page",
    "parent": "Recipes",
    "order": 2,
    "comment": " "
  },
  "Using": {
    "src": {
      "path": "docs/can-guides/setting-up-canjs/setting-up-canjs.md"
    },
    "body": "\nCanJS can be downloaded or installed in many ways:\n\n - npm\n - the zip download (on the homepage)\n - the download builder (on the homepage)\n - loaded from our cdn\n - bower\n\nOnce downloaded or installed, CanJS can be loaded in a variety of ways:\n\n - StealJS,\n - RequireJS\n - Browserify\n - `<script>` tags\n\nThe following lists how to setup common combinations.  If you don't see yours, please\nask on the [forums](http://forums.donejs.com/c/canjs) or [gitter chat](https://gitter.im/canjs/canjs).\n\n## JSBins\n\nNot yet committed to CanJS? Or just want to play around? Use one of these JSBins:\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/venaje/embed?html,js,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.5\"></script>\n\n  - [jQuery](http://justinbmeyer.jsbin.com/venaje/edit?html,js,output)\n  - [Zepto](http://justinbmeyer.jsbin.com/veqola/edit?html,js,output)\n\n## CDN\n\nAnother quick way to start locally is by loading scripts from our CDN:\n\n    <html>\n    <head>\n        <title>CanJS Test</title>\n    </head>\n    <body>\n        <script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.js\"></script>\n        <script src=\"http://canjs.com/release/latest/can.jquery.js\"></script>\n        <script src=\"http://canjs.com/release/latest/can.map.define.js\"></script>\n        <script src=\"http://canjs.com/release/latest/can.stache.js\"></script>\n        <script type='text/stache' id='app'>\n        \t<hello-world/>\n        </script>\n\n        <script type=\"text/javascript\">\n            can.Component.extend({\n            \ttag: 'hello-world',\n            \ttemplate: can.stache(\"<h1>{{message}}</h1>\"),\n            \tviewModel: {\n            \t\tmessage: \"Hi there!\"\n            \t}\n            });\n            $(\"body\").append(can.view(\"app\",{}));\n        </script>\n    </body>\n    </html>\n\nThis loads CanJS's core and its two most common plugins [define](../docs/can.Map.prototype.define.html)\nand [stache](../docs/can.stache.html).  Checkout the [release folder](https://github.com/bitovi/canjs.com/tree/gh-pages/release/latest)\nfor the list of other plugins you can add.\n\nIf you want to use Zepto instead of jQuery, load Zepto instead of jQuery and `can.zepto.js` instead of `can.jquery.js` like:\n\n    <script src=\"http://zeptojs.com/zepto.js\"></script>\n    <script src=\"http://canjs.com/release/latest/can.zepto.js\"></script>\n\nA list of all available CDN releases and files can be found [here](https://github.com/canjs/canjs.com/tree/gh-pages/release).\n\n__Note:__ We highly recommend to always reference a specific version and never `latest` directly in a production environment.\nLatest can contain backwards incompatible releases __and will break your application__.\n\n## StealJS and NPM\n\nIf you are installing CanJS from npm and using StealJS, you should\ncheckout [DoneJS](http://donejs.com).  It has comprehensive guides on using\nStealJS and CanJS together.\n\nTo use StealJS and CanJS outside DoneJS, install the [can](https://www.npmjs.com/package/can), [steal](https://www.npmjs.com/package/steal) and `jquery` packages:\n\n```\n> npm install can --save\n> npm install steal --save\n> npm install jquery --save\n```\n\nNext, create a `main.stache` template for your app:\n\n```\n<!-- main.stache -->\n<h1>{{message}}</h1>\n```\n\nNext, create a `main` module for your application. Import CanJS's core,\njQuery, and your template to say \"Hello World\":\n\n```\n// main.js\nimport can from \"can\";\nimport $ from \"jquery\";\nimport template from \"./main.stache!\";\n\nvar data = new can.Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nFinally, create a page that loads `steal.js` and specifies `\"main\"` as the main module:\n\n```\n<html>\n  <body>\n    <script src=\"./node_modules/steal/steal.js\" data-main=\"main\"></script>\n  </body>\n</html>\n```\n\nIt's better if you import just what you need.  Instead of loading all of CanJS's core,\nwe can load just `\"can/map/map\"` like:\n\n```\n// main.js\nimport Map from \"can/map/map\";\nimport $ from \"jquery\";\nimport template from \"./main.stache!\";\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nStealJS supports \"modlet\" module names that end with \"/\".  This means that the above could\nalso be written like:\n\n```\n// main.js\nimport Map from \"can/map/\";\nimport $ from \"jquery\";\nimport template from \"./main.stache!\";\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nBesides ES6 modules, StealJS supports AMD, and CommonJS.  You could also write `main.js` like:\n\n```\n// main.js\nvar Map = require(\"can/map/\");\nvar $ = require(\"jquery\");\nvar template = require(\"./main.stache!\");\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\n### Building to production\n\nIf you are using StealJS and CanJS outside of DoneJS, [this guide](http://blog.bitovi.com/using-canjs-2-2-with-stealjs/)\nwalks through getting a production build.\n\n## Browserify and NPM\n\nThe [can npm package](https://www.npmjs.com/package/can) works with browserify. After installing `can`:\n\n```\n> npm install can --save\n```\n\nRequire the core `can` modules like:\n\n```\nvar can = require(\"can\");\n```\n\nYou can also `require` specific modules:\n\n```\nvar Component = require(\"can/component/component\");\nComponent.extend({ ... });\n```\n\nNote that nearly all module names repeat the folder name (ex: `can/view/stache/stache`).\n\n### Requiring templates\n\nYou can require any CanJS templates using the [can-compilify](https://www.npmjs.com/package/can-compilify) Browserify\ntransform. Complete instructions for installing and using the transform are available on [npm](https://www.npmjs.com/package/can-compilify).\n\nInstall can-compilify:\n\n```\n> npm install can --save\n```\n\nRequire a template in your code:\n\n```\n// app.js\nvar Map = require(\"can/map/\");\nvar $ = require(\"jquery\");\nvar template = require(\"./main.stache\");\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nAnd include the can-compilify transform from the command line:\n\n```\n> browserify -t can-compilify app.js > app.bundle.js\n```\n\nYou could also add can-compilify to your package.json.\n\n### Building templates to production\n\nUsing the can-compilify tranform, your production bundle(s) will include a compiled version of your\ntemplates so no extra setup is required.\n\n## RequireJS from NPM, the Download or Bower\n\nThe Zip Download (on the [homepage](http://canjs.com)) contains the following\nAMD formatted scripts that can be loaded with RequireJS.\n\n- `amd/` - CanJS provided as AMD modules\n- `amd-dev/` - CanJS AMD modules with development messages\n\nThese files are also available in the [can NPM package](npmjs.com/package/can)'s `dist` folder.  Install\nthe `can` package like:\n\n```\n> npm install can --save\n```\n\nYou'll find these files in `node_modules/can/dist`.\n\nThese files are also available in the `canjs` bower package.  Install `canjs` like:\n\n> bower install canjs --save\n\nYou'll find these files in `bower_components/can/dist`.\n\nThe following section contains quick how to load CanJS with RequireJS for different libraries.\n\n### jQuery\n\nIn RequireJS a simple configuration looks like this:\n\n    <script type=\"text/javascript\" src=\"require.js\"></script>\n    <script type=\"text/javascript\">\n      require.config({\n        paths : {\n          \"jquery\" : \"http://code.jquery.com/jquery-2.0.3\",\n          \"can\": \"path/to/can/amd\"\n        }\n      });\n\n      require(['can/control', 'can/view/stache'], function(Control, stache) {\n        // Use Stache and Control\n        var MyControl = Control.extend({\n          init: function() {\n            this.element.html(can.view('path/to/view.stache', this.options));\n          }\n        });\n      });\n    </script>\n\nThe `can` module is a shortcut that loads CanJS's core plugins and returns the `can` namespace:\n\n    require(['can'], function(can) {\n      // Use can.Component, can.view etc.\n    });\n\n### Building templates to production\n\nBundling templates with the rest of your JavaScript can dramatically reduce the number of requests.  \n\nUse the [can-compile](https://github.com/canjs/can-compile#loading-with-requirejs) project\nto build templates into an AMD module that can be used by `r.js` to build the app.\n\n\n## Script tags from NPM, the Download, or Bower\n\nThe Zip Download (on the [homepage](http://canjs.com)) contains the following\n\"global\" scripts that can be loaded with just a `<script>` tag.\n\n- `can.<library>.js` (e.g. `can.jquery.js`) - The core build for a supported library\n- `can.<library>.dev.js` - A development build logging useful messages for a supported library\n- `can.<library>.min.js` - The minified core build for a supported library\n- `can.<type>.<plugin>` - Individual builds for each official CanJS plugin\n\n\nThese are also available in the [can NPM package](npmjs.com/package/can)'s `dist` folder.  Install\nthe `can` package like:\n\n```\n> npm install can --save\n```\n\nYou'll find these files in `node_modules/can/dist`.\n\nThese files are also available in the `canjs` bower package.  Install `canjs` like:\n\n> bower install canjs --save\n\nYou'll find these files in `bower_components/can/dist`.\n\nThe following section contains quick how to load CanJS with a `<script>` tag using\nthese files for each library it supports.\n\n### jQuery\n\nCanJS supports jQuery in the latest 1.X and 2.X version. Include jQuery before your CanJS jQuery build to get started:\n\n    <script src=\"//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js\">\n    </script>\n    <script src=\"can.jquery.js\"></script>\n    <script>\n      $(function() {\n        // start using CanJS\n        var Todo = can.Map.extend({\n          ...\n        });\n      });\n    </script>\n\n### Building templates to production\n\nCanJS can pre-compile [Stache](/docs/can.stache.html) views into JavaScript functions contained within a single file in order to avoid\nadditional requests for view files in production. When using\nCanJS standalone use the [can-compile](https://github.com/daffl/can-compile) Node module. Install with\n\n```\n> npm install can-compile -g\n```\n\nAnd in your project root folder run:\n\n```\n> can-compile --out views.production.js\n```\n\nThis will create `views.production.js` in the current folder containing all pre-compiled views. When loaded into your page CanJS will use the per-compiled views instead of making an Ajax request to retrieve them.\n\n\n## Script tags with the download builder\n\nThe download builder on the homepage lets you customize what modules are included in a global\nscript.  After downloading that script, the use of that script is just like [loading CanJS with script tag using the zip download](#section_ScripttagsfromNPM_theDownload_orBower).\n\n",
    "description": "CanJS is packaged in multiple ways so that it can fit into any development workflow. Learn how to setup CanJS in different environments. \n",
    "name": "Using",
    "title": "Setting up CanJS",
    "type": "page",
    "parent": "guides",
    "order": 2,
    "outline": "2",
    "comment": " "
  },
  "can-connect/connection.createData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/createData.md"
    },
    "body": "",
    "description": "Creates instance data given the serialized form of the instance. \n",
    "type": "typedef",
    "title": "connection.createData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise with the data that will be passed to [connection.createdData].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "cid",
            "description": "A unique id that represents the instance that is being created.\n"
          }
        ],
        "description": "\n\nCreates instance data given the serialized form of the data. Returns any additional properties that should be added to the\ninstance. A client ID is passed of the instance that is being created.\n"
      }
    ],
    "name": "can-connect/connection.createData",
    "parent": "can-connect.DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "cid",
      "description": "A unique id that represents the instance that is being created.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise with the data that will be passed to [connection.createdData].\n"
    }
  },
  "can-connect.DataInterface": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/data_interface.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "DataInterface",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-connect.DataInterface",
    "parent": "can-connect.types",
    "signatures": [
      {
        "code": "DataInterface",
        "description": "\n",
        "params": []
      }
    ]
  },
  "can-connect/connection.destroyData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/destroyData.md"
    },
    "body": "",
    "description": "Destroys an instance given the serialized form of the instance. \n",
    "type": "typedef",
    "title": "connection.destroyData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves with any properties that should be added to the instance.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          }
        ],
        "description": "\n\nDestroys an instance given the seralized form of the data.  Returns any additional properties that should be added to the instance.\n"
      }
    ],
    "name": "can-connect/connection.destroyData",
    "parent": "can-connect.DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves with any properties that should be added to the instance.\n"
    }
  },
  "can-connect/connection.getData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getData.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "connection.getData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect/connection.getData",
    "parent": "can-connect.DataInterface"
  },
  "can-connect/connection.getListData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getListData.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/url/url] make it easy to implement `getListData`, but it can be as simple as:\n\n```\nvar connection = connect([],{\n  getListData: function(set){\n    return $.get(set)\n  }\n})\n```\n\n",
    "description": "Retrieves list data for a particular set. \n",
    "type": "typedef",
    "title": "connection.getListData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the [can-connect.listData] format.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to the list data for a particular set.\n"
      }
    ],
    "name": "can-connect/connection.getListData",
    "parent": "can-connect.DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the [can-connect.listData] format.\n"
    },
    "comment": " "
  },
  "can-connect/connection.getSets": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getSets.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "connection.getSets",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect/connection.getSets",
    "parent": "can-connect.DataInterface"
  },
  "can-connect/connection.updateData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/updateData.md"
    },
    "body": "",
    "description": "Updates an instance's data. \n",
    "type": "typedef",
    "title": "connection.updateData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "props"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves with any properties that should be added to the instance.\nThis should include the [can-connect/base/base.idProp] of the instance.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The serialized instance data.\n"
          }
        ],
        "description": "\n\n  Updates instance data given the serialized form of the data. Returns any\n  additional properties that should be added to the instance.\n"
      }
    ],
    "name": "can-connect/connection.updateData",
    "parent": "can-connect.DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The serialized instance data.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "props"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves with any properties that should be added to the instance.\nThis should include the [can-connect/base/base.idProp] of the instance.\n"
    }
  },
  "connection.updateListData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/updateListData.md"
    },
    "body": "\n",
    "description": "Updates list data for a particular set. \n",
    "type": "typedef",
    "title": "connection.updateListData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the updated [can-connect.listData].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "A object that represents the set of data needed to be loaded.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "set",
            "description": "The set of data that is updating.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to the list data for a particular set.\n"
      }
    ],
    "name": "connection.updateListData",
    "parent": "can-connect.DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "set",
      "description": "The set of data that is updating.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the updated [can-connect.listData].\n"
    },
    "comment": " "
  },
  "can-connect/connection.destroy": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/destroy.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.destroy",
    "name": "can-connect/connection.destroy",
    "type": "function",
    "parent": "can-connect.InstanceInterface"
  },
  "can-connect/connection.get": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/get.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.get",
    "name": "can-connect/connection.get",
    "type": "function",
    "parent": "can-connect.InstanceInterface"
  },
  "can-connect/connection.getList": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/getList.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.getList",
    "name": "can-connect/connection.getList",
    "type": "function",
    "parent": "can-connect.InstanceInterface",
    "signatures": [
      {
        "code": "connection.getList(set)",
        "description": "\n\n  Loads a List\n",
        "params": [
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": "A set object that represents the list of data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "List",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Instance"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "name": "set",
      "description": "A set object that represents the list of data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "List",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Instance"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    }
  },
  "can-connect/connection.save": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/save.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.save",
    "name": "can-connect/connection.save",
    "type": "function",
    "parent": "can-connect.InstanceInterface"
  },
  "connection.algebra": {
    "src": {
      "path": "node_modules/can-connect/docs/options/algebra.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Algebra"
      }
    ],
    "title": "algebra",
    "name": "connection.algebra",
    "type": "property",
    "parent": "can-connect.options"
  },
  "can-connect.InstanceInterface": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/instance_interface.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "InstanceInterface",
    "name": "can-connect.InstanceInterface",
    "parent": "can-connect.types",
    "signatures": [
      {
        "code": "InstanceInterface",
        "description": "\n\nBlah\n",
        "params": []
      }
    ]
  },
  "connection.cacheConnection": {
    "src": {
      "path": "node_modules/can-connect/docs/options/cacheConnection.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "connection"
      }
    ],
    "title": "cacheConnection",
    "name": "connection.cacheConnection",
    "type": "property",
    "parent": "can-connect.options"
  },
  "connection.id": {
    "src": {
      "path": "node_modules/can-connect/docs/options/id.md"
    },
    "body": "",
    "description": "",
    "title": "id",
    "name": "connection.id",
    "type": "function",
    "parent": "can-connect.options"
  },
  "connection.idProp": {
    "src": {
      "path": "node_modules/can-connect/docs/options/idProp.md"
    },
    "body": "",
    "description": "",
    "title": "idProp",
    "name": "connection.idProp",
    "type": "property",
    "parent": "can-connect.options"
  },
  "connection.list": {
    "src": {
      "path": "node_modules/can-connect/docs/options/list.md"
    },
    "body": "",
    "description": "\n",
    "title": "list",
    "name": "connection.list",
    "type": "function",
    "parent": "can-connect.options",
    "signatures": [
      {
        "code": "connection.list( instancesData, set )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": [
                  {
                    "name": "data",
                    "types": [
                      {
                        "type": "Array",
                        "template": [
                          {
                            "types": [
                              {
                                "type": "Object",
                                "options": []
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "instancesData",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "List"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "data",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "name": "instancesData",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "List"
        }
      ],
      "description": "\n"
    }
  },
  "connection.listSet": {
    "src": {
      "path": "node_modules/can-connect/docs/options/listSet.md"
    },
    "body": "",
    "description": "",
    "title": "listSet",
    "name": "connection.listSet",
    "type": "function",
    "parent": "can-connect.options"
  },
  "connection.instance": {
    "src": {
      "path": "node_modules/can-connect/docs/options/instance.md"
    },
    "body": "",
    "description": "",
    "title": "instance",
    "name": "connection.instance",
    "type": "function",
    "parent": "can-connect.options"
  },
  "can-connect.listData": {
    "src": {
      "path": "node_modules/can-connect/docs/types/listData.md"
    },
    "body": "\n\n## Use\n\n[can-connect/connection.getListData] should return a promise that resolves\nan object that looks like:\n\n```\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ]\n}\n```\n\nThe object must have a `data` property that is an Array of \ninstanceData.\n\nThe object can have other meta information related to the data\nthat has been loaded.  For example, `count` might be the total\nnumber of items the server has:\n\n```\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ],\n  count: 1000\n}\n```\n",
    "description": "\nThe data resolved by [can-connect/connection.getListData].\n",
    "type": "typedef",
    "title": "ListData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "data",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "Foo\n"
          }
        ]
      }
    ],
    "name": "can-connect.listData",
    "parent": "can-connect.types",
    "comment": " "
  },
  "can-connect/base/base": {
    "type": "module",
    "name": "can-connect/base/base",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 1,
      "codeLine": 25,
      "path": "node_modules/can-connect/src/base/base.js"
    },
    "body": "\n\n## Use\n\nThe `\"base\"` behavior is added automatically to every connection created by `connect`. So even we do:\n\n```\nvar connection = connect([],{});\n```\n\nThe connection still has `\"base\"` functionality:\n\n```\nconnection.id({id: 1}) //-> 1\n```\n\n",
    "description": "\nThe base behavior added to every `connect` behavior.\n",
    "title": "",
    "signatures": [
      {
        "code": "base(options)",
        "description": "\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/base/base.id": {
    "type": "function",
    "name": "can-connect/base/base.id",
    "parent": "can-connect/base/base",
    "src": {
      "line": 27,
      "codeLine": 82,
      "path": "node_modules/can-connect/src/base/base.js"
    },
    "body": "\n\n## Use\n\nMany extensions, such as the [can-connect/constructor/store/store], need\nto have a unique identifier for an instance or instance data.  The\n`connection.id` method should return that.\n\nTypically, an item's `id` is a simply propertly value on the object.\nFor example, `todo` data might look like:\n\n```js\n{_id: 5, name: \"do the dishes\"}\n```\n\nIn this case, [can-connect/base/base.algebra]'s `id` comparator should be set to\n\"_id\" like:\n\n```js\nvar algebra = new set.Algebra({\n  set.comparators.id(\"_id\")\n});\nconnect([...],{algebra: algebra});\n```\n\nHowever,\nsome data sources have compound ids.  For example, \"Class Assignment\"\nconnection might be represented by two properties, the `studentId` and the\n`classId`.  For this kind of setup, you can provide your own id function as\nfollows:\n\n```js\nvar classAssignmentConnection = connect(['data-url'],{\n  url: \"/class_assignments\",\n  id: function(classAssignment){\n    return classAssignment.studentId+\"-\"+classAssignment.classId;\n  }\n});\n```\n\t \n",
    "description": "\nUniquely identify an instance or raw instance data.\n",
    "title": "id",
    "signatures": [
      {
        "code": "connection.id(instance)",
        "description": "\n\n  Returns the [can-connect/base/base.idProp] if it exists, otherwise the [can-connect/base/base.algebra]'s\n  id values, otherwise the `id` property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "The instance or raw `props` for an instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "Number"
            }
          ],
          "description": "A string or number uniquely representing `instance`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "The instance or raw `props` for an instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Number"
        }
      ],
      "description": "A string or number uniquely representing `instance`.\n"
    },
    "comment": " "
  },
  "can-connect/base/base.idProp": {
    "name": "can-connect/base/base.idProp",
    "type": "property",
    "parent": "can-connect/base/base",
    "src": {
      "line": 103,
      "codeLine": 126,
      "path": "node_modules/can-connect/src/base/base.js"
    },
    "body": "\n## Use\n\n```\nconnect([\"data-url\"],{\n  idProp: \"_id\"\n});\n```\n\n\t \n",
    "description": "\n",
    "types": [
      {
        "type": "String",
        "description": "The name of the property that uniquely identifies\nan instance.  Defaults to `\"id\"`.\n"
      }
    ],
    "title": "idProp",
    "deprecated": [
      {
        "version": "0.5.3",
        "description": "Instead of specifying hte idProp it should be\nset on the algebra passed to the connection.\n\nSpecifies the property that uniquely identifies an instance.\n"
      }
    ],
    "comment": " "
  },
  "can-connect/base/base.listSet": {
    "type": "function",
    "name": "can-connect/base/base.listSet",
    "parent": "can-connect/base/base",
    "src": {
      "line": 127,
      "codeLine": 162,
      "path": "node_modules/can-connect/src/base/base.js"
    },
    "body": "\n\n## Use\n\nMany extensions, such as the [can-connect/constructor/store/store], need\nto have a unique identifier for a list.  The\n`connection.listSet` method should return that.\n\nTypically, an item's `set` is an expando property added to\na list.  For example, a list of todos might looks like todos\nafter the following has run:\n\n```\nvar todos = [{_id: 5, name: \"do the dishes\"}]\ntodos.set = {due: 'today'};\n```\n\nIn this case [can-connect/base/base.listSetProp] should be set to `\"set\"`.\n\n\t \n",
    "description": "\nUniquely identify the set a list represents.\n",
    "title": "listSet",
    "signatures": [
      {
        "code": "connection.listSet(list)",
        "description": "\n\n  Returns the [can-connect/base/base.listSetProp] if it exists.\n",
        "params": [
          {
            "types": [
              {
                "type": "List"
              }
            ],
            "name": "list",
            "description": "A list instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object that can be passed to `JSON.stringify`\nto represent the list.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "List"
        }
      ],
      "name": "list",
      "description": "A list instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object that can be passed to `JSON.stringify`\nto represent the list.\n"
    },
    "comment": " "
  },
  "can-connect/base/base.listSetProp": {
    "name": "can-connect/base/base.listSetProp",
    "type": "property",
    "parent": "can-connect/base/base",
    "src": {
      "line": 165,
      "codeLine": 185,
      "path": "node_modules/can-connect/src/base/base.js"
    },
    "body": "\n\n## Use\n\n```\nconnect([\"data-url\"],{\n  listSetProp: \"set\"\n});\n```\n\n\t \n",
    "description": "\nSpecifies the property that uniquely identifies a list.\n",
    "types": [
      {
        "type": "String",
        "description": "The name of the property that uniquely identifies\nthe list.  Defaults to `\"__listSet\"`.\n"
      }
    ],
    "title": "listSetProp",
    "comment": " "
  },
  "can-connect/base/base.algebra": {
    "body": "\n## Use\n\n```\nvar algebra = new set.Algebra(set.props.range(\"start\",\"end\"));\n\nconnect([...behavior names...],{\n  algebra: algebra\n});\n```\n\t \n",
    "description": "\n",
    "types": [
      {
        "type": "can-set.Algebra",
        "description": "A set algebra that is used by\nmany behaviors to compare the `set` objects passed to\n[can-connect/connection.getListData] and [can-connect/connection.getList]. By\ndefault no algebra is provided.\n"
      }
    ],
    "title": "algebra",
    "name": "can-connect/base/base.algebra",
    "type": "property",
    "parent": "can-connect/base/base",
    "comment": " "
  },
  "can-connect/base/base.cacheConnection": {
    "body": "\n\n## Use\n\n```\nvar cacheConnection = connect(['data-memory-cache'],{})\n\nconnect([...behavior names...],{\n  cacheConnection: cacheConnection\n});\n```\n\t \n",
    "description": "\nA connection used for caching.\n",
    "types": [
      {
        "type": "can-connect.DataInterface",
        "options": [
          {
            "name": "A",
            "description": "connection that can be used for\n\"Data Interface\" requests. Several behaviors\nlook for this property.  By `cacheConnection` is null.\n",
            "types": [
              {
                "type": "connection"
              }
            ]
          }
        ]
      }
    ],
    "title": "cacheConnection",
    "name": "can-connect/base/base.cacheConnection",
    "type": "property",
    "parent": "can-connect/base/base",
    "comment": " "
  },
  "can-connect/cache-requests/cache-requests.data": {
    "name": "can-connect/cache-requests/cache-requests.data",
    "title": "Data Interface",
    "type": "group",
    "parent": "can-connect/cache-requests/cache-requests",
    "description": "",
    "order": 0
  },
  "can-connect/cache-requests/cache-requests.algebra": {
    "name": "can-connect/cache-requests/cache-requests.algebra",
    "title": "Algebra",
    "type": "group",
    "parent": "can-connect/cache-requests/cache-requests",
    "description": "",
    "order": 0
  },
  "can-connect/cache-requests/cache-requests": {
    "type": "module",
    "name": "can-connect/cache-requests/cache-requests",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 8,
      "codeLine": 89,
      "path": "node_modules/can-connect/src/cache-requests/cache-requests.js"
    },
    "body": "\n\n## Use\n\nUse `cache-requests` in combination with a cache\nlike [can-connect/data/memory-cache/memory-cache] or [can-connect/data/localstorage-cache/localstorage-cache].  For example,\n\n```\nvar cacheConnection = connect([\"memory-cache\"],{});\n\nvar todoConnection = connect([\"data-url\",\"cache-requests\"],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\"\n})\n```\n\nThis will make it so response data is cached in memory.  For example, if\ntoday's todos are loaded:\n\n```\ntodoConnection.getListData({due: \"today\"})\n```\n\nAnd later, a subset of those todos are loaded:\n\n```\ntodoConnection.getListData({due: \"today\", status: \"critical\"})\n```\n\nThe original request's data will be used.\n\n## Using Algebra\n\n`cache-requests` can also \"fill in\" the data the cache is mising if you provide\nit the necessary [set algebra](https://github.com/canjs/can-set).\n\nFor example, if you requested paginated data like:\n\n```\ntodoConnection.getListData({start: 1, end: 10})\n```\n\nAnd then later requested:\n\n```\ntodoConnection.getListData({start: 1, end: 20})\n```\n\n... with the appropriate configuration, `cache-requests` will only request `{start: 11, end: 20}`.\nThat configuration looks like:\n\n```\nvar algebra = new set.Algebra( set.comparators.range(\"start\",\"end\") );\n\nvar cacheConnection = connect([\"memory-cache\"],{algebra: algebra});\n\nvar todoConnection = connect([\"data-url\",\"cache-requests\"],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\",\n  algebra: algebra\n})\n```\n\nNotice that `cacheConnection`s often share many of the same options as the\nprimary connection.\n\n",
    "description": "\nCaches reponse data and uses it to prevent future requests or make future requests smaller.\n",
    "title": "",
    "signatures": [
      {
        "code": "cacheRequests( baseConnction )",
        "description": "\n\n  Overwrites [can-connect/cache-requests/cache-requests.getListData] to use set logic to\n  determine which data is already in [can-connect/base/base.cacheConnection] or needs to be loaded from the base connection.\n\n  It then gets data from the cache and/or the base connection, merges it, and returns it.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/cache-requests/cache-requests.getDiff": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getDiff",
    "parent": "can-connect/cache-requests/cache-requests.algebra",
    "src": {
      "line": 93,
      "codeLine": 134,
      "path": "node_modules/can-connect/src/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nCompares the available set data to the requested data and returns\nthe data that should be loaded from the cache and the data loaded\nfrom the base connection.\n",
    "title": "getDiff",
    "signatures": [
      {
        "code": "connection.getDiff( set, availableSets )",
        "description": "\n\n  This attempts to find the minimal amount of data to load by\n  going through each `availableSet` and doing a [subset](https://github.com/canjs/can-set#setsubset)\n  test and a [set difference](https://github.com/canjs/can-set#setdifference) with\n  `set`.\n\n  If `set` is a subset of an `availableSet`, `{cached: set}` will be returned.\n\n  If there is a difference of `set` and an `availableSet`, the difference\n  will be what's `needed`.  The intersection of `set` and that\n  `availableSet` will be what's `cached`.  A `count` will be taken of\n  what's `needed` resulting in an object like:\n\n  ```\n  {\n    needed: {start: 50, end: 99},\n    cached: {start: 0, end: 49},\n    count: 49\n  }\n  ```\n\n  Finally, `getDiff` will pick the diff objet with the lowest count. If there\n  is no diff object, `{needed: set}` is returned.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": "The set that is being loaded."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Set"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "availableSets",
            "description": "An array of available sets in the\n[can-connect/base/base.cacheConnection]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": [
                        {
                          "name": "needs",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        },
                        {
                          "name": "cached",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Set"
                }
              ]
            }
          ]
        }
      ],
      "name": "availableSets",
      "description": "An array of available sets in the\n[can-connect/base/base.cacheConnection]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": [
                    {
                      "name": "needs",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    },
                    {
                      "name": "cached",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\n\n\t "
    }
  },
  "can-connect/cache-requests/cache-requests.getUnion": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getUnion",
    "parent": "can-connect/cache-requests/cache-requests.algebra",
    "src": {
      "line": 172,
      "codeLine": 189,
      "path": "node_modules/can-connect/src/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nReturns the union of the cached and needed data.\n",
    "title": "getUnion",
    "signatures": [
      {
        "code": "connection.getUnion(set, diff, neededData, cachedData)",
        "description": "\n\n  Uses [can-set.getUnion](https://github.com/canjs/can-set#setgetunion) to merge the two sets.\n",
        "params": [
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": "The set requested."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "diff",
            "description": "The result of [can-connect/cache-requests/cache-requests.getDiff]."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "neededData",
            "description": "The data loaded from the base connection."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "cachedData",
            "description": "The data loaded from the [can-connect/base/base.cacheConnection].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "Return the merged cached and requested data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "name": "cachedData",
      "description": "The data loaded from the [can-connect/base/base.cacheConnection].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "Return the merged cached and requested data.\n\t "
    }
  },
  "can-connect/cache-requests/cache-requests.getListData": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getListData",
    "parent": "can-connect/cache-requests/cache-requests.data",
    "src": {
      "line": 193,
      "codeLine": 211,
      "path": "node_modules/can-connect/src/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nOnly request data that hasn't already been loaded by [can-connect/base/base.cacheConnection].\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Overwrites a base connection's `getListData` to use data in the [can-connect/base/base.cacheConnection]\n  whenever possible.  This works by [can-connect/connection.getSets getting the stored sets] and doing a\n  [can-connect/cache-requests/cache-requests.getDiff diff] to see what should be loaded from the cache\n  or from the base connection.\n\n  With that information, this `getListData` requests data from the cache and/or the base\n  connection.  Once it has been recieved, it combines the data with [can-connect/cache-requests/cache-requests.getUnion].\n",
        "params": [
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": "\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "name": "set",
      "description": "\n\t "
    }
  },
  "can-connect/constructor/constructor.crud": {
    "name": "can-connect/constructor/constructor.crud",
    "title": "CRUD Methods",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 0
  },
  "can-connect/constructor/constructor.callbacks": {
    "name": "can-connect/constructor/constructor.callbacks",
    "title": "CRUD Callbacks",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 1
  },
  "can-connect/constructor/constructor.hydrators": {
    "name": "can-connect/constructor/constructor.hydrators",
    "title": "Hydrators",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 2
  },
  "can-connect/constructor/constructor.serializers": {
    "name": "can-connect/constructor/constructor.serializers",
    "title": "Serializers",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 3
  },
  "can-connect/constructor/constructor.helpers": {
    "name": "can-connect/constructor/constructor.helpers",
    "title": "Helpers",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 4
  },
  "can-connect/constructor/constructor": {
    "name": "can-connect/constructor/constructor",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 2,
      "codeLine": 82,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nThe `constructor` behavior allows you to hydrate the raw, serialized representation of\nyour application's data into a typed representation with additional methods and behaviors.\n\nFor example, you might want to be able to load data as a particular JavaScript Constructor\nfunction that has a helper methods that act upon the serialized data.\n\nAn example might be loading data from a `\"/todos\"` service and being able to call `.timeLeft()`\non the todos that you get back like:\n\n```\ntodoConnection.get({id: 6}).then(function(todo){\n  todo.timeLeft() //-> 60000\n})\n```\n\nThe following creates a `todoConnection` that does exactly that:\n\n```\nvar Todo = function(data){\n  for(var prop in data) {\n   this[prop] = data;\n  }\n};\nTodo.prototype.timeLeft = function(){\n  return new Date() - this.dueDate\n};\n\nvar todoConnection = connect(\"constructor\",\"data-url\",{\n  url: \"/todos\"\n  instance: function(data){\n    return new Todo(data);\n  }\n});\n```\n\nThe `constructor` extension is still useful even if you want to keep your data as plain\nJavaScript objects (which its default behavior).  The `constructor` extension describes\nthe in-memory representation of your data on the client.  Other extensions need to know this\nrepresentation for advanced behavior like [can-connect/real-time/real-time] or [can-connect/fall-through-cache/fall-through-cache].\n\n## CRUD Methods\n\nThe `constructor` extension supplies methods that create, read, update and\ndelete (CRUD) typed representations of raw connection data.\n\n## CRUD Callbacks\n\nThe `constructor` function \"CRUD Methods\" call \"CRUD Callbacks\" with the\nthe \"data interface\" response data. These callbacks update the state of\nthe typed representation.\n\n## Instantaitors\n\nThese methods are used to create a typed instance or typed list given raw \"data interface\"\nobjects.\n\n## Serializers\n\nThese methods convert the typed instance or typed list into a representation for the\n\"data interface\".\n\n\n\n",
    "description": "\nConnect \"data interface\" methods to rich representations of data.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructor(baseConnection)",
        "description": "\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/constructor/constructor.cidStore": {
    "name": "can-connect/constructor/constructor.cidStore",
    "type": "property",
    "parent": "can-connect/constructor/constructor.helpers",
    "src": {
      "line": 96,
      "codeLine": 102,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\t \n",
    "description": "\nA WeakReferenceMap that contains instances being created by their `._cid` property.\n",
    "types": [
      {
        "type": "WeakReferenceMap"
      }
    ],
    "title": "cidStore"
  },
  "can-connect/constructor/constructor.get": {
    "type": "function",
    "name": "can-connect/constructor/constructor.get",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 105,
      "codeLine": 134,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nCall `.get()` with the parameters that identify the instance\nyou want to load.  `.get()` will return a promise that resolves\nto your instance.\n\n```\ntodoConnection.get({id: 6}).then(function(todo){ })\n```\n\n\t \n",
    "description": "\nGet a single instance from the \"data interface\".\n",
    "title": "get",
    "signatures": [
      {
        "code": "connection.get(set)",
        "description": "\n\n  Gets an instance from [can-connect/connection.getData] and runs the resulting data\n  through [can-connect/constructor/constructor.hydrateInstance].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An instance that represents the data that was loaded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "An instance that represents the data that was loaded.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.getList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.getList",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 141,
      "codeLine": 170,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nCall `.getList()` with the parameters that identify the instance\nyou want to load.  `.getList()` will return a promise that resolves\nto your instance.\n\n```\ntodoConnection.getList({due: 'today'}).then(function(todos){ })\n```\n\n\t \n",
    "description": "\nGet a single instance from the \"data interface\".\n",
    "title": "getList",
    "signatures": [
      {
        "code": "connection.getList(set)",
        "description": "\n\n  Gets an instance from [can-connect/connection.getListData] and runs the resulting data\n  through [can-connect/constructor.hydrateList].\n",
        "params": [
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "List",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Instance"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An instance that represents the data that was loaded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "name": "set",
      "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "List",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Instance"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "An instance that represents the data that was loaded.\n"
    },
    "comment": " "
  },
  "can-connect/constructor.hydrateList": {
    "type": "function",
    "name": "can-connect/constructor.hydrateList",
    "parent": "can-connect/constructor/constructor.hydrators",
    "src": {
      "line": 179,
      "codeLine": 196,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nMakes a list type object given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList(listData, set)",
        "description": "\n\n  Calls [can-connect/constructor/constructor.hydrateInstance] with each raw instance data item and then\n  calls [can-connect/constructor.list] with an array of the instances.  If [can-connect/constructor.list]\n  is not provided, a normal array is used.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "set",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "List"
            }
          ],
          "description": "The data type used to represent the list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "set",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "List"
        }
      ],
      "description": "The data type used to represent the list.\n\t "
    }
  },
  "can-connect/constructor/constructor.hydrateInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.hydrateInstance",
    "parent": "can-connect/constructor/constructor.hydrators",
    "src": {
      "line": 215,
      "codeLine": 230,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nMakes a type object given raw data.\n",
    "title": "hydrateInstance",
    "signatures": [
      {
        "code": "connection.hydrateInstance(listData)",
        "description": "\n\n  If [can-connect/constructor.instance] is available passes `props` to that\n  and returns that value.  Otherwise, returns a clone of `props`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties returned by [can-connect/connection.getData].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Instance"
            }
          ],
          "description": "The data type used to represent the list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties returned by [can-connect/connection.getData].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "description": "The data type used to represent the list.\n\t "
    }
  },
  "can-connect/constructor.save": {
    "type": "function",
    "name": "can-connect/constructor.save",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 237,
      "codeLine": 325,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\n## Use\n\nTo use `save`, create a connection, then an instance, and call `.save()` with it.\n\n```\n// Create a connection:\nvar todoConnection = connect(['constructor','data-url'],{\n  url: \"/todos\"\n})\n\n// Create an instance:\nvar todo = {name: \"do dishes\"};\n\n// Call .save():\ntodoConnection.save(todo)\n```\n\nThis will POST to `/todos` with the `todo` data.  The server response data\nmight look something like:\n\n```\n{\n id: 5,\n ownerId: 9\n}\n```\n\nThis data will be passed to [can-connect/constructor.createdInstance] which will default\nto adding those properties to `todo`, resulting in `todo` looking like:\n\n```\n{\n name: \"do dishes\",\n id: 5,\n ownerId: 9\n}\n```\n\nTo update the todo, change a property and call `.save()` again:\n\n```\n// Change a property:\ntodo.name = \"Do dishes!!\";\n\n// Call .save()\ntodoConnection.save(todo)\n```\n\nThis will PUT to `/todos` with the `todo` data.  The server response data\nshould look something like:\n\n```\n{\n name: \"Do dishes!!\",\n id: 5,\n ownerId: 9\n}\n```\n\nThis data will be passed to [can-connect/constructor.updatedInstance] which will default\nto setting all of `todos` properties to look like the response data.\n\t \n",
    "description": "Creates or updates an instance using the underlying data interface. \n",
    "title": "save",
    "signatures": [
      {
        "code": "connection.save( instance )",
        "description": "\n\n  Checks if the instance has an [can-connect/base/base.id] or not.  If it\n  has an id, the instance will be updated; otherwise, it will be created.\n\n  To create an instance, the instance is added to the [can-connect/constructor.cidStore],\n  and its [can-connect/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.createData].  If `createData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor.createdInstance] is called.\n\n  To update an instance, its [can-connect/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.updateData]. If `updateData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor.updatedInstance] is called.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to create or save.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Instance"
            }
          ],
          "description": "resolves to the same instance that was passed to `save`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to create or save.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "description": "resolves to the same instance that was passed to `save`.\n"
    },
    "comment": " "
  },
  "can-connect/constructor.destroy": {
    "src": {
      "line": 355,
      "codeLine": 434,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "type": "function",
    "body": "\n## Use\n\nTo use `save`, create a connection, then an instance, and call `.save()` with it.\n\n```\n// Create a connection:\nvar todoConnection = connect(['constructor','data-url'],{\n  url: \"/todos\"\n})\n\n// Create an instance:\nvar todo = {name: \"do dishes\"};\n\n// Call .save():\ntodoConnection.save(todo)\n```\n\nThis will POST to `/todos` with the `todo` data.  The server response data\nmight look something like:\n\n```\n{\n\tid: 5,\n ownerId: 9\n}\n```\n\nThis data will be passed to [can-connect/constructor.createdInstance] which will default\nto adding those properties to `todo`, resulting in `todo` looking like:\n\n```\n{\n name: \"do dishes\",\n id: 5,\n ownerId: 9\n}\n```\n\nTo update the todo, change a property and call `.save()` again:\n\n```\n// Change a property:\ntodo.name = \"Do dishes!!\";\n\n// Call .save()\ntodoConnection.save(todo)\n```\n\nThis will PUT to `/todos` with the `todo` data.  The server response data\nshould look something like:\n\n```\n{\n name: \"Do dishes!!\",\n id: 5,\n ownerId: 9\n}\n```\n\nThis data will be passed to [can-connect/constructor.updatedInstance] which will default\nto setting all of `todos` properties to look like the response data.\n\t \n",
    "description": "Destroys an instance using the underlying data interface. \n",
    "title": "destroy",
    "name": "can-connect/constructor.destroy",
    "parent": "can-connect/constructor/constructor.crud",
    "signatures": [
      {
        "code": "connection.destroy( instance )",
        "description": "\n\n  To destroy an instance, its [can-connect/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.destroyData]. If `destroyData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor.destroyedInstance] is called.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to create or save.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Instance"
            }
          ],
          "description": "resolves to the same instance that was passed to `save`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to create or save.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "description": "resolves to the same instance that was passed to `save`.\n"
    },
    "comment": " "
  },
  "can-connect/constructor.createdInstance": {
    "type": "function",
    "name": "can-connect/constructor.createdInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 448,
      "codeLine": 462,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being created with the result of [can-connect/connection.createData].\n",
    "title": "createdInstance",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n  Adds every property and value in `props` to `instance`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.createData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.createData].\n\t "
    }
  },
  "can-connect/constructor.updatedInstance": {
    "type": "function",
    "name": "can-connect/constructor.updatedInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 465,
      "codeLine": 480,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being updated with the result of [can-connect/connection.updateData].\n",
    "title": "updatedInstance",
    "signatures": [
      {
        "code": "connection.updatedInstance( instance, props )",
        "description": "\n\n  Sets the properties in `instance` to match the properties and values in `props`\n  with the exception of [can-connect/base/base.idProp], which it leaves alone.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.updateData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.updateData].\n\t "
    }
  },
  "can-connect/constructor.updatedList": {
    "type": "function",
    "name": "can-connect/constructor.updatedList",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 483,
      "codeLine": 501,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates a list with new data.\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedInstance( instance, props )",
        "description": "\n\n  [can-connect/constructor/constructor.hydrateInstance Hydrates] instances with `listData`'s data\n  and attempts to merge them into `list`.  The merge is able to identify simple insertions\n  and removals of elements instead of replacing the entire list.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "list",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The raw data usd to update `list`.\n"
          },
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": "The set of data `listData` represents.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "name": "set",
      "description": "The set of data `listData` represents.\n\t "
    }
  },
  "can-connect/constructor.destroyedInstance": {
    "type": "function",
    "name": "can-connect/constructor.destroyedInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 511,
      "codeLine": 526,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being destroyed with the result of [can-connect/connection.destroyData].\n",
    "title": "destroyedInstance",
    "signatures": [
      {
        "code": "connection.destroyedInstance( instance, props )",
        "description": "\n\n  Sets the properties in `instance` to match the properties and values in `props`\n  with the exception of [can-connect/base/base.idProp], which it leaves alone.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.destroyData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.destroyData].\n\t "
    }
  },
  "can-connect/constructor.serializeInstance": {
    "type": "function",
    "name": "can-connect/constructor.serializeInstance",
    "parent": "can-connect/constructor/constructor.serializers",
    "src": {
      "line": 529,
      "codeLine": 543,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "",
    "description": "Returns the serialized form of an instance. \n",
    "title": "serializeInstance",
    "signatures": [
      {
        "code": "connection.serializeInstance( instance )",
        "description": "\n\n  This implementation simply clones the `instance` object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to serialize.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A serialized representation of the instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to serialize.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A serialized representation of the instance.\n\t "
    }
  },
  "can-connect/constructor.serializeList": {
    "type": "function",
    "name": "can-connect/constructor.serializeList",
    "parent": "can-connect/constructor/constructor.serializers",
    "src": {
      "line": 546,
      "codeLine": 562,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "",
    "description": "Returns the serialized form of an list. \n",
    "title": "serializeList",
    "signatures": [
      {
        "code": "connection.serializeList( list )",
        "description": "\n\n  This implementation simply returns an `Array` containing the result of\n  [can-connect/constructor.serializeInstance] called on each item in the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "List"
              }
            ],
            "name": "list",
            "description": "The instance to serialize.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "A serialized representation of the list.\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "List"
        }
      ],
      "name": "list",
      "description": "The instance to serialize.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "A serialized representation of the list.\n\n\t "
    }
  },
  "can-connect/constructor.isNew": {
    "type": "function",
    "name": "can-connect/constructor.isNew",
    "params": [
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "instance",
        "description": "The instance to test.\n"
      }
    ],
    "parent": "can-connect/constructor/constructor.helpers",
    "src": {
      "line": 568,
      "codeLine": 578,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nReturns if this instance has not been persisted.\n",
    "title": "isNew",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "The instance to test.\n"
    },
    "returns": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the instance has not been persisted.\n\t "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the instance has not been persisted.\n\t "
    }
  },
  "can-connect/constructor.list": {
    "body": "\n\n## Use\n\nIf you have a special type of list with helper functions you'd like to have available,\nyou can do that in `list`.  The following makes it so `getList` resolves to array-like\nobjects that have a `completed` function.\n\n```\nvar MyList = Object.create(Array.prototype);\nMyList.prototype.completed = function(){\n  return this.filter(function(){ return this.completed });\n};\n\nvar todosConnection = connect([\"constructor\",\"data-url\"], {\n  url: \"todos\",\n  list: function(listData, set){\n    var collection = Object.create(MyList);\n    Array.apply(collection, listData.data);\n    collection.__listSet = set;\n    return collection;\n  }\n});\n```\n\nThis allows:\n\n```\ntodosConnection.getList({}).then(function(todos){\n  console.log(\"There are\",todos.completed().length, \"completed todos\")\n});\n```\n\n\nNotice that we added the `__listSet` data on the list. This is useful\nfor other extensions.\n\n\t \n",
    "description": "\nReturns the appropraite form of list.\n",
    "title": "list",
    "name": "can-connect/constructor.list",
    "type": "property",
    "parent": "can-connect/constructor/constructor.hydrators",
    "signatures": [
      {
        "code": "connection.list( listInstanceData, set )",
        "description": "\n\n  Takes an object with a data property that is an array of instances returned by\n  [can-connect/constructor/constructor.hydrateInstance] and should return the right type of list.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": [
                  {
                    "name": "data",
                    "types": [
                      {
                        "type": "Array",
                        "template": [
                          {
                            "types": [
                              {
                                "type": "Instance"
                              }
                            ]
                          }
                        ]
                      }
                    ],
                    "description": "\n"
                  }
                ]
              }
            ],
            "name": "listInstanceData",
            "description": "\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "set",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "List"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "set",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "List"
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/constructor.instance": {
    "src": {
      "line": 641,
      "codeLine": 696,
      "path": "node_modules/can-connect/src/constructor/constructor.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\nIf you have a special type of list with helper functions you'd like to have available,\nyou can do that in `list`.  The following makes it so `getList` resolves to array-like\nobjects that have a `completed` function.\n\n```\nvar MyList = Object.create(Array.prototype);\nMyList.prototype.completed = function(){\n  return this.filter(function(){ return this.completed });\n};\n\nvar todosConnection = connect([\"constructor\",\"data-url\"], {\n  url: \"todos\",\n  list: function(listData, set){\n    var collection = Object.create(MyList);\n    Array.apply(collection, listData.data);\n    collection.__listSet = set;\n    return collection;\n  }\n});\n```\n\nThis allows:\n\n```\ntodosConnection.getList({}).then(function(todos){\n  console.log(\"There are\",todos.completed().length, \"completed todos\")\n});\n```\n\n\nNotice that we added the `__listSet` data on the list. This is useful\nfor other extensions.\n\n\t \n",
    "description": "\nReturns the typed form of the serialized data.\n",
    "title": "instance",
    "name": "can-connect/constructor.instance",
    "parent": "can-connect/constructor/constructor.hydrators",
    "signatures": [
      {
        "code": "connection.instance( props )",
        "description": "\n\n  Takes an object with a data property that is an array of instances returned by\n  [can-connect/constructor/constructor.hydrateInstance] and should return the right type of list.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Instance"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/fall-through-cache/fall-through-cache.data": {
    "name": "can-connect/fall-through-cache/fall-through-cache.data",
    "title": "Data Callbacks",
    "type": "group",
    "parent": "can-connect/fall-through-cache/fall-through-cache",
    "description": "",
    "order": 0
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrators": {
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "title": "Hydrators",
    "type": "group",
    "parent": "can-connect/fall-through-cache/fall-through-cache",
    "description": "",
    "order": 0
  },
  "can-connect/fall-through-cache/fall-through-cache": {
    "name": "can-connect/fall-through-cache/fall-through-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 69,
      "path": "node_modules/can-connect/src/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n\n## Use\n\nTo use the `fall-through-cache`, create a connection with a\n[can-connect/base/base.cacheConnection] and a behavior that implements\n[can-connect/connection.getData] and [can-connect/connection.getListData].\n\n```\nvar cache = connect(['data-localstorage-cache'],{\n  name: \"todos\"\n});\n\nvar todoConnection = connect([\n   'fall-through-cache',\n   'data-url',\n   'constructor',\n   'constructor-store'\n  ], {\n  url: \"/todos\",\n  cacheConnection: cache\n});\n```\n\nThen, make requests.  If the cache has the data,\nit will be returned immediately, and then the item or list updated later\nwith the response from the base connection:\n\n```\ntodoConnection.getList({due: \"today\"}).then(function(todos){\n\n})\n```\n\n## Demo\n\nThe following shows the `fall-through-cache` behavior.\n\n<div class='demo_wrapper' data-demo-src='can-connect/src/fall-through-cache/fall-through-cache.html'></div>\n\nClicking\n\"Completed\" or \"Incomplete\" will make one of the following requests and\ndisplay the results in the page:\n\n```\ntodoConnection.getList({completed: true});\ntodoConnection.getList({completed: false});\n```\n\nIf you click back and forth between \"Completed\" and \"Incomplete\" multiple times\nyou'll notice that the old data is displayed immediately and then\nupdated after about a second.\n\n\n",
    "description": "\nA fall through cache that checks another `cacheConnection`.\n",
    "title": "",
    "signatures": [
      {
        "code": "fallThroughCache( baseConnection )",
        "description": "\n\n  Implements a `getData` and `getListData` that\n  check their [can-connect/base/base.cacheConnection] for data and then\n  in the background update the instance or list with data\n  retrieved using the base connection.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrateList": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrateList",
    "parent": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "src": {
      "line": 75,
      "codeLine": 92,
      "path": "node_modules/can-connect/src/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nReturns a List instance given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList(listData, set)",
        "description": "\n\n  Calls the base `hydrateList` to create a List for `listData`.\n\n  Then, Looks for registered hydrateList callbacks for a given `set` and\n  calls them.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "List"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "List"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.getListData": {
    "src": {
      "line": 113,
      "codeLine": 140,
      "path": "node_modules/can-connect/src/fall-through-cache/fall-through-cache.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nGet raw data from the cache if available, and then update\nthe list later with data from the base connection.\n",
    "title": "getListData",
    "name": "can-connect/fall-through-cache/fall-through-cache.getListData",
    "parent": "can-connect/fall-through-cache/fall-through-cache.data",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Checks the [can-connect/base/base.cacheConnection] for `set`'s data.\n\n  If the cache connection has data, the cached data is returned. Prior to\n  returning the data, the [can-connect/constructor.hydrateList] method\n  is intercepted so we can get a handle on the list that's being created\n  for the returned data. Once the intercepted list is retrieved,\n  we use the base connection to get data and update the intercepted list and\n  the cacheConnection.\n\n  If the cache connection does not have data, the base connection\n  is used to load the data and the cached connection is updated with that\n  data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": "The set to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that returns the\nraw data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "name": "set",
      "description": "The set to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that returns the\nraw data.\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrateInstance": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrateInstance",
    "parent": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "src": {
      "line": 181,
      "codeLine": 197,
      "path": "node_modules/can-connect/src/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nReturns an instance given raw data.\n",
    "title": "hydrateInstance",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  Calls the base `hydrateInstance` to create an Instance for `props`.\n\n  Then, Looks for registered hydrateInstance callbacks for a given [can-connect/base/base.id] and\n  calls them.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Instance"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.getData": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.getData",
    "parent": "can-connect/fall-through-cache/fall-through-cache.data",
    "src": {
      "line": 217,
      "codeLine": 244,
      "path": "node_modules/can-connect/src/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nGet raw data from the cache if available, and then update\nthe instance later with data from the base connection.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Checks the [can-connect/base/base.cacheConnection] for `params`'s data.\n\n  If the cache connection has data, the cached data is returned. Prior to\n  returning the data, the [can-connect/constructor/constructor.hydrateInstance] method\n  is intercepted so we can get a handle on the instance that's being created\n  for the returned data. Once the intercepted instance is retrieved,\n  we use the base connection to get data and update the intercepted instance and\n  the cacheConnection.\n\n  If the cache connection does not have data, the base connection\n  is used to load the data and the cached connection is updated with that\n  data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "The set to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that returns the\nraw data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "The set to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that returns the\nraw data.\n\t "
    }
  },
  "can-connect/real-time/real-time.methods": {
    "name": "can-connect/real-time/real-time.methods",
    "title": "Methods",
    "type": "group",
    "parent": "can-connect/real-time/real-time",
    "description": "",
    "order": 0
  },
  "can-connect/real-time/real-time.callbacks": {
    "name": "can-connect/real-time/real-time.callbacks",
    "title": "Data Callbacks",
    "type": "group",
    "parent": "can-connect/real-time/real-time",
    "description": "",
    "order": 1
  },
  "can-connect/real-time/real-time": {
    "name": "can-connect/real-time/real-time",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 131,
      "path": "node_modules/can-connect/src/real-time/real-time.js"
    },
    "body": "\n\n## Use\n\nTo use `real-time`, create a connection with its dependent\nbehaviors like:\n\n```\nvar todoConnection = connect(\n   [\"real-time\",\n    \"constructor\",\n    \"constructor-store\",\n    \"constructor-callbacks-once\",\n    \"data-url\"],{\n  url: \"/todos\"\n});\n```\n\nNext, use the connection to load lists and save those lists in the\nstore:\n\n```\ntodoConnection.getList({complete: false}).then(function(todos){\n  todoConnection.addListReference(todos);\n})\n```\n\nFinally, use one of the  [can-connect/real-time/real-time.createInstance],\n[can-connect/real-time/real-time.updateInstance], and\n[can-connect/real-time/real-time.destroyInstance] methods to tell the connection\nthat data has changed.  The connection will update (by calling splice)\neach list accordingly.\n\n\n## Example\n\nThe following demo shows two lists that use this connection.  The\n\"Run Code\" button sends the connection data changes which the\nconnection will then update lists accordingly:\n\n\n<div class='demo_wrapper' data-demo-src='can-connect/src/real-time/real-time.html'></div>\n\nThis example creates a `todoList` function and `todoItem` function\nthat manage the behavior of a list of todos and a single todo respectfully.\nIt uses [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe)\nto observe changes in the todo list and individual todo data. Other\nframeworks will typically provide their own observable system.\n\n### todoList\n\nWhen `todoList` is created, it is passed the `set` of data to load.  It uses\nthis to get todos from the `todoConnection` like:\n\n\n```\ntodosConnection.getList(set).then(function(retrievedTodos){\n```\n\nIt then adds those `todos` to the [can-connect/constructor/store/store.listStore] so\nthey can be updated automatically.  And, it listens to changes in `todos` and calls an `update` function:\n\n```\ntodosConnection.addListReference(todos);\nObject.observe(todos, update, [\"add\", \"update\", \"delete\"] );\n```\n\nThe update function is able to inserted new `todoItem`s in the page when items are added\nto or removed from `todos`.  We exploit that by calling `update` as if it just added\neach todo in the list:\n\n```\nupdate(todos.map(function(todo, i){\n  return {\n    type: \"add\",\n    name: \"\"+i\n  };\n}));\n```\n\n### todoItem\n\nThe `todoItem` creates an element that updates with changes\nin its `todo`.  It listens to changes in the `todo` and saves\nthe todo in the [can-connect/constructor/store/store.instanceStore] with the\nfollowing:\n\n```\nObject.observe(todo, update, [\"add\", \"update\", \"delete\"] );\ntodosConnection.addInstanceReference(todo);\n```\n\nA `todoItem` needs to be able to stop listening on the `todo` and remove itself from the\n`instanceStore` if the `todo` is removed from the page.  To provide this teardown\nfunctionality, `todoItem` listens to a `\"removed\"` event on its element and\n`unobserves` the todo and removes it from the `instanceStore`:\n\n```\n$(li).bind(\"removed\", function(){\n  Object.unobserve(todo, update, [\"add\", \"update\", \"delete\"] );\n  todosConnection.deleteInstanceReference(todo);\n});\n```\n\n",
    "description": "\nUpdate lists to include or exclude instances based\non set logic.\n",
    "title": "",
    "signatures": [
      {
        "code": "realTime( baseConnection )",
        "description": "\n\n  Overwrites the \"data callback\" methods and provides\n  [can-connect/real-time/real-time.createInstance],\n  [can-connect/real-time/real-time.updateInstance], and\n  [can-connect/real-time/real-time.destroyInstance] methods\n  that\n  update lists to include or exclude a created,\n  updated, or destroyed instance.\n\n  An instance is put in a list if it is a\n  [set.subset](https://github.com/canjs/can-set#setsubset)\n  of the [can-connect/base/base.listSet].\n\n  Currently, all items are added at the end of the list\n  until [set.add](https://github.com/canjs/can-set/issues/2)\n  is in `can-set`.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/real-time/real-time.createInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.createInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 138,
      "codeLine": 175,
      "path": "node_modules/can-connect/src/real-time/real-time.js"
    },
    "body": "\n\n## Use\n\nWith a `real-time` connection, call `createInstance` when an instance is created that\nthe connection itself did not make.  For instance, the following might listen to\n[socket.io](http://socket.io/) for when a `todo` is created and update the connection\naccordingly:\n\n```\nsocket.on('todo created', function(todo){\n  todoConnection.createInstance(order);\n});\n```\n\n\t \n",
    "description": "\nProgramatically indicate a new instance has been created.\n",
    "title": "createInstance",
    "signatures": [
      {
        "code": "connection.createInstance(props)",
        "description": "\n\n  If there is no instance in the [can-connect/constructor/store/store.instanceStore]\n  for `props`'s [can-connect/base/base.id], an instance is [can-connect/constructor/constructor.hydrateInstance hydrated],\n  added to the store, and then [can-connect/real-time/real-time.createdData] is called with\n  `props` and the hydrated instance's serialized data. [can-connect/real-time/real-time.createdData]\n  will add this instance to any lists the instance belongs to.\n\n  If this instance has already been created, calls\n  [can-connect/real-time/real-time.updateInstance] with `props`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/real-time/real-time.createdData": {
    "type": "function",
    "name": "can-connect/real-time/real-time.createdData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "src": {
      "line": 197,
      "codeLine": 218,
      "path": "node_modules/can-connect/src/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nCalled whenever instance data is created.\n",
    "title": "createdData",
    "signatures": [
      {
        "code": "connection.createdData(props, params, [cid])",
        "description": "\n\n  Updates lists with the created instance.\n\n  Gets the instance created for this request. Then, updates the instance with\n  the response data `props`.\n\n  Next, it goes through every list in the [can-connect/constructor/store/store.listStore],\n  test if the instance's data belongs in that list.  If it does,\n  adds the instance's data to the serialized list data and\n  [can-connect/constructor.updatedList updates the list].\n\n\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/real-time/real-time.updatedData": {
    "src": {
      "line": 232,
      "codeLine": 246,
      "path": "node_modules/can-connect/src/real-time/real-time.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nCalled whenever instance data is updated.\n",
    "title": "updatedData",
    "name": "can-connect/real-time/real-time.updatedData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "signatures": [
      {
        "code": "connection.updatedData(props, params)",
        "description": "\n\n  Gets the instance that is updated, updates\n  it with `props` and the adds or removes it to\n  lists it belongs in.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ],
          "description": "Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        }
      ],
      "description": "Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t "
    }
  },
  "can-connect/real-time/real-time.updateInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.updateInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 257,
      "codeLine": 273,
      "path": "node_modules/can-connect/src/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nProgramatically indicate a new instance has been updated.\n",
    "title": "updateInstance",
    "signatures": [
      {
        "code": "connection.updateInstance(props)",
        "description": "\n\n  Calls [can-connect/real-time/real-time.updatedData] in the right way so\n  that the instance is updated and added to or removed from\n  any lists it belongs in.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the instance that\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "the updated instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties of the instance that\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "the updated instance.\n\t "
    }
  },
  "can-connect/real-time/real-time.destroyedData": {
    "type": "function",
    "name": "can-connect/real-time/real-time.destroyedData",
    "params": [
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "props",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "params",
        "description": "\n\t "
      }
    ],
    "parent": "can-connect/real-time/real-time.callbacks",
    "src": {
      "line": 290,
      "codeLine": 297,
      "path": "node_modules/can-connect/src/real-time/real-time.js"
    },
    "body": "",
    "description": "\n",
    "title": "destroyedData",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "\n\t "
    }
  },
  "can-connect/real-time/real-time.destroyInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.destroyInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 308,
      "codeLine": 323,
      "path": "node_modules/can-connect/src/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nProgramatically indicate a new instance has been destroyed.\n",
    "title": "destroyInstance",
    "signatures": [
      {
        "code": "connection.destroyInstance(props)",
        "description": "\n\n  Gets or creates an instance from `props` and uses\n  it to call [can-connect/real-time/real-time.destroyedData]\n  correctly.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the destroyed instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise with the destroyed instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties of the destroyed instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise with the destroyed instance.\n\t "
    }
  },
  "can-connect/service-worker": {
    "type": "module",
    "name": "can-connect/service-worker",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect.behaviors",
    "src": {
      "line": 5,
      "codeLine": 10,
      "path": "node_modules/can-connect/src/service-worker/service-worker.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "hide": true
  },
  "can-define/map/map.prototype": {
    "name": "can-define/map/map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map.static": {
    "name": "can-define/map/map.static",
    "title": "static",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map": {
    "src": {
      "path": "node_modules/can-define/map/docs/define-map.md"
    },
    "body": "",
    "description": "Create observable objects. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define/map/map",
    "parent": "can-core",
    "alias": "can.DefineMap",
    "inherits": "can.Construct",
    "signatures": [
      {
        "code": "new can.DefineMap([props])",
        "description": "\n\nCreates a new instance of DefineMap or an extended DefineMap.\n\n```js\nvar person = new can.DefineMap({\n  first: \"Justin\",\n  last: \"Meyer\"\n})\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the map with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "An instance of `can.DefineMap` with the properties from _props_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "props",
      "description": "Properties and values to seed the map with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "An instance of `can.DefineMap` with the properties from _props_.\n"
    }
  },
  "can-define/map/map.extend": {
    "src": {
      "path": "node_modules/can-define/map/docs/static.extend.md"
    },
    "body": "",
    "description": "Create a custom map type \n",
    "title": "extend",
    "name": "can-define/map/map.extend",
    "type": "function",
    "parent": "can-define/map/map.static",
    "signatures": [
      {
        "code": "can.DefineMap.extend([name,] [static,] prototype)",
        "description": "\n\nExtends can.DefineMap, or constructor functions derived from can.DefineMap,\nto create a new constructor function.\n\n```js\nvar Person = can.DefineMap.extend(\n  \"Person\",\n  {seal: true},\n  {\n    first: \"string\",\n    last: {type: \"string\"},\n    fullName: {\n      get: function(){\n        return this.first+\" \"+this.last;\n      }\n    },\n    age: {value: 0},\n  });\n\nvar me = new Person({first: \"Justin\", last: \"Meyer\"})\nme.fullName //-> \"Justin Meyer\"\nme.age      //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Provides an optional name for this type that will\nshow up nicely in debuggers.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "static",
            "description": "Static properties that are set directly on the\nconstructor function.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      },
                      {
                        "type": "String"
                      },
                      {
                        "type": "can-define.types"
                      },
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "prototype",
            "description": "A definition of the properties or methods on this type.\n\nIf the property definition is a __plain function__, it's considered a method.\n\n```js\nvar Person = DefineMap.extend({\n  sayHi: function(){ console.log(\"hi\"); }\n});\n\nvar me = new Person();\nme.sayHi();\n```\n\nIf the property definition is a __string__, it's considered a `type` setting to be looked up in [can-define.types can.define.types].\n\n```js\nvar Person = DefineMap.extend({\n  age: 'number',\n  isCool: 'boolean',\n  hobbies: 'observable'\n});\n\nvar me = new Person({age: '33', isCool: 'false', hobbies: ['js','bball']});\nme.age    //-> 33\nme.isCool //-> false\nme.hobbies instanceof DefineList //-> true\n```\n\n\nIf the property definition is a Constructor function, it's considered a `Type` setting.\n\n```js\nvar Address = DefineMap.extend({\n  zip: 'number'\n});\nvar Person = DefineMap.extend({\n  address: Address\n});\n\nvar me = new Person({address: {zip: '60048'}});\nme.address.zip //-> 60048\n```\n\nIf the property is an __object__, it's considered to be a [can-define.types.propDefinition].\n\n```js\nvar Person = DefineMap.extend({\n  fullName: {\n    get: function() {\n      return this.first+\" \"+this.last;\n    },\n    set: function(newVal) {\n      var parts = newVal.split(\" \");\n      this.first = parts[0];\n      this.last = parts[1];\n    }\n  },\n  // slick way of creating an 'inline' type.\n  address: {\n    Type: {\n      zip: \"number\"\n    }\n  }\n});\n\nvar me = new Person({fullName: \"Rami Myer\", address: {zip: '60048'}});\nme.first       //-> \"Rami\"\nme.address.zip //-> 60048\n```\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "A DefineMap constructor function.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                },
                {
                  "type": "String"
                },
                {
                  "type": "can-define.types"
                },
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "prototype",
      "description": "A definition of the properties or methods on this type.\n\nIf the property definition is a __plain function__, it's considered a method.\n\n```js\nvar Person = DefineMap.extend({\n  sayHi: function(){ console.log(\"hi\"); }\n});\n\nvar me = new Person();\nme.sayHi();\n```\n\nIf the property definition is a __string__, it's considered a `type` setting to be looked up in [can-define.types can.define.types].\n\n```js\nvar Person = DefineMap.extend({\n  age: 'number',\n  isCool: 'boolean',\n  hobbies: 'observable'\n});\n\nvar me = new Person({age: '33', isCool: 'false', hobbies: ['js','bball']});\nme.age    //-> 33\nme.isCool //-> false\nme.hobbies instanceof DefineList //-> true\n```\n\n\nIf the property definition is a Constructor function, it's considered a `Type` setting.\n\n```js\nvar Address = DefineMap.extend({\n  zip: 'number'\n});\nvar Person = DefineMap.extend({\n  address: Address\n});\n\nvar me = new Person({address: {zip: '60048'}});\nme.address.zip //-> 60048\n```\n\nIf the property is an __object__, it's considered to be a [can-define.types.propDefinition].\n\n```js\nvar Person = DefineMap.extend({\n  fullName: {\n    get: function() {\n      return this.first+\" \"+this.last;\n    },\n    set: function(newVal) {\n      var parts = newVal.split(\" \");\n      this.first = parts[0];\n      this.last = parts[1];\n    }\n  },\n  // slick way of creating an 'inline' type.\n  address: {\n    Type: {\n      zip: \"number\"\n    }\n  }\n});\n\nvar me = new Person({fullName: \"Rami Myer\", address: {zip: '60048'}});\nme.first       //-> \"Rami\"\nme.address.zip //-> 60048\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "A DefineMap constructor function.\n"
    }
  },
  "can-define/map/map.seal": {
    "src": {
      "path": "node_modules/can-define/map/docs/static.seal.md"
    },
    "body": "\n",
    "description": "Defines if instances of the map should be [sealed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal) in development. \n",
    "types": [
      {
        "type": "Boolean",
        "description": "If `true`, in development, instances of this object will be [sealed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal).  In  [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) errors will be thrown when undefined properties are set.  This is the default\nbehavior of [can-define/map/map.extend extended DefineMaps]:\n\n```js\n\"use strict\";\nvar Person = can.DefineMap.extend({});\nvar me = new Person();\nme.age = 33 //-> throws \"TypeError: Can't add property age, object is not extensible\"\n```\n\nIf `false`, the object will not be sealed.  This is the default behavior of\nunextended [can-define/map/map DefineMaps].  Use [can-define/map/map.prototype.get] and [can-define/map/map.prototype.set] to get and set values:\n\n```js\nvar person = new can.DefineMap();\nperson.set(\"first\",\"Justin\");\nperson.set(\"last\",\"Meyer\");\n\nperson.get(\"first\") //-> \"Justin\"\nperson.get(\"last\") //-> \"Meyer\"\n```\n\nSet `seal` to `false` on objects that have an indeterminate number of properties:\n\n```js\nvar Style = can.DefineMap.extend({\n  seal: false\n},{\n  cssText: {\n    get: function(){\n      return _.map(this.get(), function(val, prop){\n        return prop+\": \"+val;\n      }).join(\";\")\n    }\n  }\n});\nvar style = new Style();\nstyle.set(\"color\",\"green\");\nstyle.set(\"font\",\"awesome\");\nstyle.cssText //-> \"color:green; font: awesome;\"\n```\n"
      }
    ],
    "title": "seal",
    "name": "can-define/map/map.seal",
    "type": "property",
    "parent": "can-define/map/map.static"
  },
  "can-stache.helpers.default": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/default.md"
    },
    "body": "\nThe `default` helper is contextual inside of a [can-stache.helpers.switch] block. It acts as a fall-through in case none of the [can-stache.helpers.case] helpers resolved.\n\nFor more information on how `{{#default}}` is used check:\n\n- [can-stache.helpers.switch {{#switch expr}}]\n- [can-stache.helpers.case {{#case expr}}]\n\n",
    "description": "\n",
    "title": "{{#default}}",
    "name": "can-stache.helpers.default",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 15,
    "signatures": [
      {
        "code": "{{#default}}BLOCK{{/default}}",
        "description": "\n\nRenders the `BLOCK` if no [can-stache.helpers.case] blocks within the switch resolved.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache"
              }
            ],
            "name": "BLOCK",
            "description": "a template to be rendered.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "DocumentFragment"
            }
          ],
          "description": "A fragment, containing the rendered block.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache"
        }
      ],
      "name": "BLOCK",
      "description": "a template to be rendered.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "A fragment, containing the rendered block.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.data": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/data.md"
    },
    "body": "\n## Use\n\nIt is common to want some data in the template to be available\non an element.  `{{data name}}` allows you to save the\ncontext so it can later be retrieved by [can.data] or\n`$.fn.data`. \n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/juxem/latest/embed?html,js,output\">JS Bin</a><script src=\"http://static.jsbin.com/js/embed.js\"></script>\n\n### Getting more specific\n\nBy passing a key name as the second argument to the data helper, you can specify which data is used: `{{data name key}}`.\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/munuco/latest/embed?html,js,output\">JS Bin</a><script src=\"http://static.jsbin.com/js/embed.js\"></script>\n\n",
    "description": "",
    "title": "{{data name}}",
    "name": "can-stache.helpers.data",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 7,
    "signatures": [
      {
        "code": "{{data name[ key]}}",
        "description": "\n\nAdds the current [can-stache.context context] to the\nelement's [can-data].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the data attribute to use for the\ncontext.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "name",
      "description": "The name of the data attribute to use for the\ncontext.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.case": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/case.md"
    },
    "body": "\nThe `case` helper is contextual inside of a [can-stache.helpers.switch] block. The parent switch contains an `expr` that will be matched against the case `expr` and if they are equal the block will be returned.\n\nFor more information on how `{{#case}}` is used check:\n\n- [can-stache.helpers.switch {{#switch expr}}]\n- [can-stache.helpers.default {{#default}}]\n\n",
    "description": "\n",
    "title": "{{#case expr}}",
    "name": "can-stache.helpers.case",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 14,
    "signatures": [
      {
        "code": "{{#case expr}}BLOCK{{/case}}",
        "description": "\n\nRenders the `BLOCK` when `expr` matches the `expr` provided in the parent [can-stache.helpers.switch].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.expression"
              }
            ],
            "name": "expr",
            "description": "An expression or key that references a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache"
              }
            ],
            "name": "BLOCK",
            "description": "a template that will render if the case clause resolves.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "DocumentFragment"
            }
          ],
          "description": "A fragment, possibly containing the rendered `BLOCK`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache"
        }
      ],
      "name": "BLOCK",
      "description": "a template that will render if the case clause resolves.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "A fragment, possibly containing the rendered `BLOCK`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.each": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/each.md"
    },
    "body": "\n## Use\n\nUse the `each` helper to iterate over a array\nof items and render the block between the helper and the slash. For example,\n\nThe template:\n\n    <ul>\n      {{#each friends}}\n        <li>{{name}}</li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    {friends: [{name: \"Austin\"},{name: \"Justin\"}]}\n\nRenders:\n\n    <ul>\n      <li>Austin</li>\n      <li>Justin</li>\n    </ul>\n\n## Object iteration\n\nAs of 2.1, you can now iterate over properties of objects and attributes with\nthe `each` helper. When iterating over [can-map] it will only iterate over the\nmap's [can-map.keys] and none of the hidden properties of a Map. For example,\n\nThe template:\n\n    <ul>\n      {{#each person}}\n        <li>{{.}}</li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    {person: {name: 'Josh', age: 27}}\n\nRenders:\n\n    <ul>\n      <li>Josh</li>\n      <li>27</li>\n    </ul>\n\n## Understanding when to use #each with lists\n\n{{#each key}} iteration will do basic diffing and aim to only update the DOM where the change occured. Whereas\n[can-stache.Sections Sections] iteration will re-render the entire section for any change in the list.\n[can-stache.Sections Sections] iteration is the prefered method to use when a list is replaced or changing significantly.\nWhen doing single list item changes frequently, {{#each key}} iteration is the faster choice.\n\nFor example, assuming \"list\" is a [can-list] instance:\n\n{{#if list}} will check for the truthy value of list. This is akin to checking for the truthy value of any JS object and will result to true, regardless of list contents or length.\n\n{{#if list.length}} will check for the truthy value of the length attribute. If you have an empty list, the length will be 0, so the #if will result to false and no contents will be rendered. If there is a length >= 1, this will result to true and the contents of the #if will be rendered.\n\n{{#each list}} and {{#list}} both iterate through an instance of [can-list], however we setup the bindings differently.\n\n{{#each list}} will setup bindings on every individual item being iterated through, while {{#list}} will not. This makes a difference in two scenarios:\n\n1) You have a large list, with minimal updates planned after initial render. In this case, {{#list}} might be more advantageous as there will be a faster initial render. However, if any part of the list changes, the entire {{#list}} area will be re-processed.\n\n2) You have a large list, with many updates planned after initial render. A grid with many columns of editable fields, for instance. In this case, you many want to use {{#each list}}, even though it will be slower on initial render(we're setting up more bindings), you'll have faster updates as there are now many sections.\n\n",
    "description": "\n",
    "title": "{{#each key}}",
    "name": "can-stache.helpers.each",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 5,
    "signatures": [
      {
        "code": "{{#each key}}BLOCK{{/each}}",
        "description": "\n\nRender the block of text for each item in key's value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's\nreturn value is used.\n\nIf the value of the key is a [can-list], the resulting HTML is updated when the\nlist changes. When a change in the list happens, only the minimum amount of DOM\nelement changes occur.\n\nIf the value of the key is a [can-map], the resulting HTML is updated whenever\nattributes are added or removed. When a change in the map happens, only\nthe minimum amount of DOM element changes occur.\n"
          },
          {
            "types": [
              {
                "type": "can-stache"
              }
            ],
            "name": "BLOCK",
            "description": "A template that is rendered for each item in\nthe `key`'s value. The `BLOCK` is rendered with the context set to the item being rendered.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache"
        }
      ],
      "name": "BLOCK",
      "description": "A template that is rendered for each item in\nthe `key`'s value. The `BLOCK` is rendered with the context set to the item being rendered.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.else": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/else.md"
    },
    "body": "\n## Use\n\nFor more information on how `{{else}}` is used checkout:\n\n - [can-stache.helpers.if {{if key}}]\n - [can-stache.tags.sectionHelper {{#helper}}]\n\n\n",
    "description": "\n",
    "title": "{{else}}",
    "name": "can-stache.helpers.else",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 3,
    "signatures": [
      {
        "code": "{{#helper}}BLOCK{{else}}INVERSE{{/helper}}",
        "description": "\n\nCreates an `inverse` block for a [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache"
              }
            ],
            "name": "INVERSE",
            "description": "a stache template coverted to a\nfunction and set as the [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache"
        }
      ],
      "name": "INVERSE",
      "description": "a stache template coverted to a\nfunction and set as the [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.index": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/index.md"
    },
    "body": "\n\n## Use\n\nWhen iterating over and array or list of items, you might need to render the index\nof the item. Use the `@index` directive to do so. For example,\n\nThe template:\n\n    <ul>\n      {{#each items}}\n        <li> {{@index}} - {{.}} </li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    { items: ['Josh', 'Eli', 'David'] }\n\nRenders:\n\n    <ul>\n      <li> 0 - Josh </li>\n      <li> 1 - Eli </li>\n      <li> 2 - David </li>\n    </ul>\n\n\n",
    "description": "\n",
    "title": "{{@index}}",
    "name": "can-stache.helpers.index",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 10,
    "signatures": [
      {
        "code": "{{@index [offset]}}",
        "description": "\n\nInsert the index of an Array or [can-list] we are iterating on with [#each](can-stache.helpers.each)\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "offset",
            "description": "The number to optionally offset the index by.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "offset",
      "description": "The number to optionally offset the index by.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.helper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/helper.md"
    },
    "body": "\n## Use\n\nThe `{{helper}}` syntax is used to call out to stache [can-stache.helper helper functions] functions\nthat may contain more complex functionality. `helper` is a [can-stache.key key] that must match either:\n\n - a [can-stache.registerHelper registered helper function], or\n - a function in the current or parent [can-stache.context contexts]\n\nThe following example shows both cases.\n\nThe Template:\n\n    <p>{{greeting}} {{user}}</p>\n\nRendered with data:\n\n    {\n      user: function(){ return \"Justin\" }\n    }\n\nAnd a with a registered helper like:\n\n    stache.registerHelper('greeting', function(){\n      return \"Hello\"\n    });\n\nResults in:\n\n    <p>Hello Justin</p>\n\n## Arguments\n\nArguments can be passed from the template to helper function by\nlisting space seperated strings, numbers or other [can-stache.key keys] after the\n`helper` name.  For example:\n\nThe template:\n\n    <p>{{madLib \"Lebron James\" verb 4}}</p>\n\nRendered with:\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements:\n\n    stache.registerHelper('madLib',\n      function(subject, verb, number, options){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n    });\n\nIf an argument `key` value is a [can-map] property, the Observe's\nproperty is converted to a getter/setter [can-compute.computed]. For example:\n\nThe template:\n\n    <p>What! My name is: {{mr user.name}}</p>\n\nRendered with:\n\n    {user: new Map({name: \"Slim Shady\"})}\n\nNeeds the helper to check if name is a function or not:\n\n    stache.registerHelper('mr',function(name){\n      return \"Mr. \"+ (typeof name === \"function\" ?\n                      name():\n                      name)\n    })\n\nThis behavior enables two way binding helpers and is explained in more detail\non the [can-stache.helper helper functions] docs.\n\n## Hash\n\nIf enumerated arguments isn't an appropriate way to configure the behavior\nof a helper, it's possible to pass a hash of key-value pairs to the\n[can-stache.helperOptions helper option argument]'s\nhash object.  Properties and values are specified\nas `hashProperty=hashValue`.  For example:\n\nThe template:\n\n    <p>My {{excuse who=pet how=\"shreded\"}}</p>\n`\nAnd the helper:\n\n    stache.registerHelper(\"excuse\",function(options){\n      return [\"My\",\n        options.hash.who || \"dog\".\n        options.hash.how || \"ate\",\n        \"my\",\n        options.hash.what || \"homework\"].join(\" \")\n    })\n\nRender with:\n\n    {pet: \"cat\"}\n\nResults in:\n\n    <p>My cat shareded my homework</p>\n\n## Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create stache tags that have rich behavior. Read about it\non the [can-stache.helper helper function] page.\n\n\n",
    "description": "Calls a stache helper function and inserts its return value into the rendered template.\n\n",
    "title": "{{helper args hashes}}",
    "name": "can-stache.helpers.helper",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 0,
    "signatures": [
      {
        "code": "{{helper [args...] [hashProperty=hashValue...]}}",
        "description": "\n\nCalls a stache helper function or a function. For example:\n\nThe template:\n\n    <p>{{madLib \"Lebron James\" verb 4 foo=\"bar\"}}</p>\n\nRendered with:\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements:\n\n    stache.registerHelper('madLib',\n      function(subject, verb, number, options){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n        // options.hash.foo -> \"bar\"\n    });\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "helper",
            "description": "A key that finds a [can-stache.helper helper function]\nthat is either [can-stache.registerHelper registered] or found within the\ncurrent or parent [can-stache.context context].\n"
          },
          {
            "variable": true,
            "types": [
              {
                "type": "can-stache.key"
              },
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Space seperated arguments\nthat get passed to the helper function as arguments. If the key's value is a:\n\n - [can-map] - A getter/setter [can-compute.computed] is passed.\n - [can-compute.computed] - The compute is passed.\n - `function` - The function's return value is passed.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "hashProperty",
            "description": "\n\nA property name that gets added to a [can-stache.helperOptions helper options]'s\nhash object.\n"
          },
          {
            "variable": true,
            "types": [
              {
                "type": "can-stache.key"
              },
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "name": "hashValue",
            "description": "A value that gets\nset as a property value of the [can-stache.helperOptions helper option argument]'s\nhash object.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "variable": true,
      "types": [
        {
          "type": "can-stache.key"
        },
        {
          "type": "String"
        },
        {
          "type": "Number"
        }
      ],
      "name": "hashValue",
      "description": "A value that gets\nset as a property value of the [can-stache.helperOptions helper option argument]'s\nhash object.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.if": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/if.md"
    },
    "body": "\n## Use\n\n`{{#if key}}` provides explicit conditional truthy tests. For example,\n\nThe template:\n\n    {{#if user.isFemale}}\n      {{#if user.isMarried}}\n        Mrs\n      {{/if}}\n      {{#if user.isSingle}}\n        Miss\n      {{/if}}\n    {{/if}}\n\nRendered with:\n\n    {user: {isFemale: true, isMarried: true}}\n\nResults in:\n\n    Mrs\n\nIf can be used with [can-stache.helpers.else {{else}}] too. For example,\n\n    {{#if user.isFemale}}\n      {{#if user.isMarried}}\n        Mrs\n      {{else}}\n        Miss\n      {{/if}}\n    {{/if}}\n\nRendered with:\n\n    {user: {isFemale: true, isMarried: false}}\n\nResults in:\n\n    Miss\n\n",
    "description": "",
    "title": "{{#if key}}",
    "name": "can-stache.helpers.if",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 2,
    "signatures": [
      {
        "code": "{{#if key}}BLOCK{{/if}}",
        "description": "\n\nRenders the `BLOCK` template within the current template.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used.\n"
          },
          {
            "types": [
              {
                "type": "can-stache"
              }
            ],
            "name": "BLOCK",
            "description": "A stache template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "If the key's value is truthy, the `BLOCK` is rendered with the\ncurrent context and its value is returned; otherwise, an empty string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache"
        }
      ],
      "name": "BLOCK",
      "description": "A stache template.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "If the key's value is truthy, the `BLOCK` is rendered with the\ncurrent context and its value is returned; otherwise, an empty string.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.is": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/is.md"
    },
    "body": "\nThe `is` helper compares expr1 and expr2 and renders the blocks accordingly.\n\n\t{{#is expr1 expr2}}\n\t\t// truthy\n\t{{else}}\n\t\t// falsey\n\t{{/is}}\n\n",
    "description": "\n",
    "title": "{{#is expr1 expr2}}",
    "name": "can-stache.helpers.is",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 12,
    "signatures": [
      {
        "code": "{{#is expr...}}BLOCK{{/is}}",
        "description": "\n\nRenders the `BLOCK` template within the current template.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.expression"
              }
            ],
            "optional": true,
            "name": "expr",
            "variable": true,
            "description": "An expression or key that references a value within the current or parent\n"
          },
          {
            "types": [
              {
                "type": "can-stache"
              }
            ],
            "name": "BLOCK",
            "description": "A template that is rendered\nif the result of comparsion `expr1` and `expr2` value is truthy.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "DocumentFragment"
            }
          ],
          "description": "If the key's value is truthy, the `BLOCK` is rendered with the\ncurrent context and its value is returned; otherwise, an empty string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache"
        }
      ],
      "name": "BLOCK",
      "description": "A template that is rendered\nif the result of comparsion `expr1` and `expr2` value is truthy.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "If the key's value is truthy, the `BLOCK` is rendered with the\ncurrent context and its value is returned; otherwise, an empty string.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.key": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/key.md"
    },
    "body": "\n\n## Use\n\nUse `{{@key}}` to render the property or attribute name of an Object or Map, when iterating over it with [can-stache.helpers.each each]. For example,\n\nThe template:\n\n    <ul>\n      {{#each person}}\n        <li> {{@key}}: {{.}} </li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    { person: {name: 'Josh', age: 27, likes: 'Stache, JavaScript, High Fives'} }\n\nRenders:\n\n    <ul>\n      <li> name: Josh </li>\n      <li> age: 27 </li>\n      <li> likes: Stache, JavaScript, High Fives </li>\n    </ul>\n\n\n",
    "description": "\n",
    "title": "{{@key}}",
    "name": "can-stache.helpers.key",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 11,
    "signatures": [
      {
        "code": "{{@key}}",
        "description": "\n\nInsert the property name of an Object or attribute name of a [can-map] that we iterate over with [#each](can-stache.helpers.each)\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache.helpers.joinBase": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/joinBase.md"
    },
    "body": "\nThe `joinBase` helper is used to create urls within your application for static resources, such as images. An example usage:\n\n    {{joinBase \"hello/\" name \".png\"}}\n\nWhere `name` is a scope value, this might return `http://example.com/app/hello/world.png` if the application is `http://example.com/app`.\n\nThe url to join with is determined by the following factors:\n\n* If attempting to load a relative url, such as `{{joinBase \"../foo.png\"}}` and using StealJS the template's address will be used as a reference to look up the location.\n* If the `can.baseURL` string is set, this will be used.\n* If the `System.baseURL` is set, this will be used.\n* Lastly we fall back to `location.pathname`.\n\n",
    "description": "\n",
    "title": "{{joinBase args}}",
    "name": "can-stache.helpers.joinBase",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 16,
    "signatures": [
      {
        "code": "{{joinBase expr}}",
        "description": "\n\nReturn an application-relative url for a resource.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.expression"
              }
            ],
            "optional": true,
            "name": "expr",
            "variable": true,
            "description": "An expression or key that references a value within the current or parent scope.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "An application-relative url.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.expression"
        }
      ],
      "optional": true,
      "name": "expr",
      "variable": true,
      "description": "An expression or key that references a value within the current or parent scope.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "An application-relative url.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.log": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/log.md"
    },
    "body": "",
    "description": "\n",
    "title": "{{log}}",
    "name": "can-stache.helpers.log",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 9,
    "signatures": [
      {
        "code": "{{#log [message]}}",
        "description": "\n\nLogs the context of the current block with an optional message.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "message",
            "description": "An optional message to log out in addition to the\ncurrent context.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "message",
      "description": "An optional message to log out in addition to the\ncurrent context.\n"
    }
  },
  "can-stache.registerHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/registerHelper.md"
    },
    "body": "\nRegisters a helper with the Mustache system.\nPass the name of the helper followed by the\nfunction to which Mustache should invoke.\nThese are run at runtime.\n\n",
    "description": "Register a helper. \n",
    "title": "registerHelper",
    "name": "can-stache.registerHelper",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerHelper(name, helper)",
        "description": "\n\nThe following template:\n\n```handlebars\n{{upper foo}}\n```\n\n```js\nstache.registerHelper(\"upper\", function(str){\n\treturn str.toUpperCase();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the helper."
          },
          {
            "types": [
              {
                "type": "can-stache.helper"
              }
            ],
            "name": "helper",
            "description": "The helper function.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helper"
        }
      ],
      "name": "helper",
      "description": "The helper function.\n"
    },
    "comment": " "
  },
  "can-stache.registerSimpleHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/registerSimpleHelper.md"
    },
    "body": "\nRegisters a helper with the Mustache system that always returns\nthe arguments value (instead of a compute).\nPass the name of the helper followed by the\nfunction to which Mustache should invoke.\nThese are run at runtime.\n\n",
    "description": "Register a helper. \n",
    "title": "registerSimpleHelper",
    "name": "can-stache.registerSimpleHelper",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerSimpleHelper(name, helper)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the helper."
          },
          {
            "types": [
              {
                "type": "can-stache.simplehelper"
              }
            ],
            "name": "helper",
            "description": "The helper function.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.simplehelper"
        }
      ],
      "name": "helper",
      "description": "The helper function.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.routeCurrent": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/routeCurrent.md"
    },
    "body": "\n\n## Use\n\nUse the `routeCurrent` helper like:\n\n```\n<li {{#routeCurrent page=\"recipe\" id=5}}class='active'{{/routeCurrent}}>\n  <a href='{{routeUrl page=\"recipe\" id=5}}'>{{recipe.name}}</a>\n</li>\n```\n\nWith default routes and a url like `#!&page=5&id=5`, this produces:\n\n```\n<li class='active'>\n  <a href='#!&page=5&id=5'>{{recipe.name}}</a>\n</li>\n```\n\nIt this functionality could use call expressions like:\n\n```\n<li {{#routeCurrent(page=\"recipe\" id=5)}}class='active'{{/routeCurrent}}>\n  <a href='{{ routeCurrent(page=\"recipe\" id=5) }}'>{{recipe.name}}</a>\n</li>\n```\n\n\nThe following demo uses `routeCurrent` and [can-stache.helpers.routeUrl] to \ncreate links that update [can-route]'s `page` attribute:\n\n<div class='demo_wrapper' data-demo-src='can/view/stache/doc/helpers/route-url.html'></div>\n\nIt also writes out the current url like:\n\n```\n{{ routeCurrent(undefined,true) }}\n```\n\nThis calls `route.url({}, true)` which has the effect of writing out\nthe current url.\n\n\n",
    "description": "\nReturns if the hash values match the [can-route]'s current properties.\n",
    "title": "{{#routeCurrent hash}}",
    "name": "can-stache.helpers.routeCurrent",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 7,
    "signatures": [
      {
        "code": "{{#routeCurrent hashes}}SUBEXPRESSION{{/routeCurrent}}",
        "description": "\n\n  Renders `SUBEXPRESSION` if the `hashes` passed to [can-route.current route.current] returns `true`.\n  Renders the [can-stache.helpers.else] expression if [can-route.current route.current] returns `false`.\n  ",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "hashes",
            "description": "A hash expression like `page='edit' recipeId=id`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The result of `SUBEXPRESSION` or `{{else}}` expression.\n"
        }
      },
      {
        "code": "routeCurrent([hashes])",
        "description": "\n\n  Calls [can-route.current route.current] with `hashes` and returns the result.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "hashes",
            "description": "A hash expression like `page='edit' recipeId=id`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Returns the result of calling [can-route.current route.current].\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Returns the result of calling [can-route.current route.current].\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-stache.expressions"
        }
      ],
      "name": "hashes",
      "description": "A hash expression like `page='edit' recipeId=id`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.routeUrl": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/routeUrl.md"
    },
    "body": "\n\n## Use\n\nUse the `routeUrl` helper like:\n\n```\n<a href='{{routeUrl page=\"recipe\" id=5}}'>{{recipe.name}}</a>\n```\n\nThis produces (with no pretty routing rules):\n\n```\n<a href='#!&page=5&id=5'>{{recipe.name}}</a>\n```\n\nIt this functionality could also be written as:\n\n```\n<a href='{{ routeUrl(page=\"recipe\" id=5) }}'>{{recipe.name}}</a>\n```\n\nUsing call expressions/parenthesis lets you pass the `merge` option to `route`.  This\nlets you write a url that only changes specified properties:\n\n```\n<a href='{{ routeUrl(id=5, true) }}'>{{recipe.name}}</a>\n```\n\n\n\n\nThe following demo uses `routeUrl` and [can-stache.helpers.routeCurrent] to \ncreate links that update [can-route]'s `page` attribute:\n\n<div class='demo_wrapper' data-demo-src='can/view/stache/doc/helpers/route-url.html'></div>\n\nIt also writes out the current url like:\n\n```\n{{ routeUrl(undefined,true) }}\n```\n\nThis calls `route.url({}, true)` which has the effect of writing out\nthe current url.\n\n\n",
    "description": "\nReturns a url using [can-route.url route.url].\n",
    "title": "{{routeUrl hashes}}",
    "name": "can-stache.helpers.routeUrl",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 7,
    "signatures": [
      {
        "code": "{{routeUrl hashes [,merge]}}",
        "description": "\n\nPasses the hashes to `route.url` and returns the result.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "hashes",
            "description": "A hash expression like `page='edit' recipeId=id`.\n"
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Pass `true` to create a url that merges `hashes` into the \ncurrent [can-route] properties.  Passing the `merge` argument is only available \nin [can-stache.expressions Call expressions] like `routeUrl(id=itemId, true)`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the result of calling `route.url`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "merge",
      "description": "Pass `true` to create a url that merges `hashes` into the \ncurrent [can-route] properties.  Passing the `merge` argument is only available \nin [can-stache.expressions Call expressions] like `routeUrl(id=itemId, true)`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the result of calling `route.url`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.sectionHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/sectionHelper.md"
    },
    "body": "\n\n## Use\n\nRead the [use section of {{helper}}](can-stache.helpers.helper.html#section_Use) to better understand how:\n\n - [Helper functions are found](can-stache.helpers.helper.html#section_Arguments)\n - [Arguments are passed to the helper](can-stache.helpers.helper.html#section_Arguments)\n - [Hash values are passed to the helper](can-stache.helpers.helper.html#section_Hash)\n\nRead how [helpers that return functions](can-stache.helper.html#section_Returninganelementcallbackfunction) can\nbe used for rich behavior like 2-way binding.\n\n\n\n",
    "description": "\nCalls a stache helper function with a block, and optional inverse\nblock.\n",
    "title": "{{#helper args hashes}}",
    "name": "can-stache.helpers.sectionHelper",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 1,
    "signatures": [
      {
        "code": "{{#helper [args...] [hashName=hashValue...]}}BLOCK{{/helper}}",
        "description": "\n\nCalls a stache helper function or a function with a block to\nrender.\n\nThe template:\n\n    <p>{{#countTo number}}{{num}}{{/countTo}}</p>\n\nRendered with:\n\n    {number: 5}\n\nWill call the `countTo` helper:\n\n    stache.registerHelper('countTo',\n      function(number, options){\n        var out = [];\n        for(var i =0; i < number; i++){\n          var docFrag = options.fn({num: i+1});\n          out.push( docFrag.textContent );\n        }\n        return out.join(\" \");\n    });\n\nResults in:\n\n    <p>1 2 3 4 5</p>\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "helper",
            "description": "A key that finds a [can-stache.helper helper function]\nthat is either [can-stache.registerHelper registered] or found within the\ncurrent or parent [can-stache.context context].\n"
          },
          {
            "variable": true,
            "types": [
              {
                "type": "can-stache.key"
              },
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Space seperated arguments\nthat get passed to the helper function as arguments. If the key's value is a:\n\n - [can-map] - A getter/setter [can-compute.computed] is passed.\n - [can-compute.computed] - The compute is passed.\n - `function` - The function's return value is passed.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "hashProperty",
            "description": "\n\nA property name that gets added to a [can-stache.helperOptions helper options]'s\nhash object.\n"
          },
          {
            "variable": true,
            "types": [
              {
                "type": "can-stache.key"
              },
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "name": "hashValue",
            "description": "A value that gets\nset as a property value of the [can-stache.helperOptions helper option argument]'s\nhash object.\n"
          },
          {
            "types": [
              {
                "type": "stache"
              }
            ],
            "name": "BLOCK",
            "description": "A stache template that gets compiled and\npassed to the helper function as the [can-stache.helperOptions options argument's] `fn`\nproperty.\n\n"
          }
        ]
      },
      {
        "code": "{{#helper [args...] [hashName=hashValue...]}}BLOCK{{else}}INVERSE{{/helper}}",
        "description": "\n\nCalls a stache helper function or a function with a `fn` and `inverse` block to\nrender.\n\nThe template:\n\n    <p>The bed is\n       {{#isJustRight firmness}}\n          pefect!\n       {{else}}\n          uncomfortable.\n       {{/justRight}}</p>\n\nRendered with:\n\n    {firmness: 45}\n\nWill call the `isJustRight` helper:\n\n    stache.registerHelper('isJustRight',\n      function(number, options){\n        if(number > 50){\n          return options.fn(this);\n        } else {\n          return options.inverse(this);\n        }\n    });\n\nResults in:\n\n    <p>The bed is uncomfortable.</p>\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "helper",
            "description": "A key that finds a [can-stache.helper helper function]\nthat is either [can-stache.registerHelper registered] or found within the\ncurrent or parent [can-stache.context context].\n"
          },
          {
            "variable": true,
            "types": [
              {
                "type": "can-stache.key"
              },
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Space seperated arguments\nthat get passed to the helper function as arguments. If the key's value is a:\n\n - [can-map] - A getter/setter [can-compute.computed] is passed.\n - [can-compute.computed] - The compute is passed.\n - `function` - The function's return value is passed.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "hashProperty",
            "description": "\n\nA property name that gets added to a [can-stache.helperOptions helper options]'s\nhash object.\n"
          },
          {
            "variable": true,
            "types": [
              {
                "type": "can-stache.key"
              },
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "name": "hashValue",
            "description": "A value that gets\nset as a property value of the [can-stache.helperOptions helper option argument]'s\nhash object.\n"
          },
          {
            "types": [
              {
                "type": "stache"
              }
            ],
            "name": "BLOCK",
            "description": "A stache template that gets compiled and\npassed to the helper function as the [can-stache.helperOptions options argument's] `fn`\nproperty.\n"
          },
          {
            "types": [
              {
                "type": "stache"
              }
            ],
            "name": "INVERSE",
            "description": "A stache template that gets compiled and\npassed to the helper function as the [can-stache.helperOptions options argument's] `inverse`\nproperty.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "stache"
        }
      ],
      "name": "INVERSE",
      "description": "A stache template that gets compiled and\npassed to the helper function as the [can-stache.helperOptions options argument's] `inverse`\nproperty.\n\n"
    },
    "comment": " "
  },
  "can-stache.helpers.with": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/with.md"
    },
    "body": "\nStache typically applies the context passed in the section\nat compiled time.  However, if you want to override this\ncontext you can use the `with` helper.\n\n    {{#with arr}}\n      // with\n    {{/with}}\n\n",
    "description": "\n",
    "title": "{{#with key}}",
    "name": "can-stache.helpers.with",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 6,
    "signatures": [
      {
        "code": "{{#with key}}BLOCK{{/with}}",
        "description": "\n\nChanges the context within a block.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's\nreturn value is used.\n"
          },
          {
            "types": [
              {
                "type": "can-stache"
              }
            ],
            "name": "BLOCK",
            "description": "A template that is rendered\nwith the context of the `key`'s value.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache"
        }
      ],
      "name": "BLOCK",
      "description": "A template that is rendered\nwith the context of the `key`'s value.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.switch": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/switch.md"
    },
    "body": "\nThe `switch` helper is used to render a block where one of several cases matches expr. It works just like a JavaScript switch.\n\n\n\t{{#switch page}}\n\n\t\t{{#case \"cart\"}}\n\t\t\t<can-import from=\"cart\">\n\t\t\t\t<cart-page></cart-page>\n\t\t\t</can-import>\n\t\t{{/case}}\n\n\t\t{{#default}}\n\t\t\t<can-import from=\"home\">\n\t\t\t\t<home-page></home-page>\n\t\t\t</can-import>\n\t\t{{/default}}\n\n\t{{/switch}}\n\n\n",
    "description": "\n",
    "title": "{{#switch expr}}",
    "name": "can-stache.helpers.switch",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 13,
    "signatures": [
      {
        "code": "{{#switch expr}}BLOCK{{/switch}}",
        "description": "\n\nRenders the `BLOCK` with contextual [can-stache.helpers.case] and [can-stache.helpers.default] helpers.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.expression"
              }
            ],
            "name": "expr",
            "description": "An expression or key that references a value that will be switched on.\n"
          },
          {
            "types": [
              {
                "type": "can-stache"
              }
            ],
            "name": "BLOCK",
            "description": "a template that is rendered, uses [can-stache.helpers.case] and [can-stache.helpers.default] helpers to match `expr`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "DocumentFragment"
            }
          ],
          "description": "A fragment containing the rendered `BLOCK`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache"
        }
      ],
      "name": "BLOCK",
      "description": "a template that is rendered, uses [can-stache.helpers.case] and [can-stache.helpers.default] helpers to match `expr`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "A fragment containing the rendered `BLOCK`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.unless": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/unless.md"
    },
    "body": "\nThe `unless` helper evaluates the inverse of the value\nof the key and renders the block between the helper and the slash.\n\n    {{#unless expr}}\n      // unless\n    {{/unless}}\n\n",
    "description": "\n",
    "title": "{{#unless key}}",
    "name": "can-stache.helpers.unless",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 4,
    "signatures": [
      {
        "code": "{{#unless key}}BLOCK{{/unless}}",
        "description": "\n\nRender the block of text if the key's value is falsey.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's\nreturn value is used.\n"
          },
          {
            "types": [
              {
                "type": "can-stache"
              }
            ],
            "name": "BLOCK",
            "description": "A template that is rendered\nif the `key`'s value is falsey.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache"
        }
      ],
      "name": "BLOCK",
      "description": "A template that is rendered\nif the `key`'s value is falsey.\n"
    },
    "comment": " "
  },
  "can-stache.tags.close": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/close.md"
    },
    "body": "",
    "description": "\n",
    "title": "{{/key}}",
    "name": "can-stache.tags.close",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 4,
    "signatures": [
      {
        "code": "{{/key}}",
        "description": "\n\nEnds a [can-stache.tags.section {{#key}}] or [can-stache.tags.sectionHelper {{#helper}}]\nblock.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "optional": true,
            "name": "key",
            "description": "A key that matches the opening key or helper name. It's also\npossible to simply write `{{/}}` to end a block.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "optional": true,
      "name": "key",
      "description": "A key that matches the opening key or helper name. It's also\npossible to simply write `{{/}}` to end a block.\n"
    }
  },
  "can-stache.tags.comment": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/comment.md"
    },
    "body": "\n",
    "description": "A comment that doesn't get inserted into the rendered result. \n",
    "title": "{{!key}}",
    "name": "can-stache.tags.comment",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 7,
    "signatures": [
      {
        "code": "{{!key}}",
        "description": "\n\nThe comment tag operates similarly to a `<!-- -->` tag in HTML. It exists in your template but never shows up.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "Everything within this tag is completely ignored."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "Everything within this tag is completely ignored."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n"
    }
  },
  "can-stache.tags.inverse": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/inverse.md"
    },
    "body": "\n## Use\n\nInverted sections match falsey values. An inverted section\nsyntax is similar to regular sections except it begins with a caret\nrather than a pound. If the value referenced is falsey, the section\nwill render. For example:\n\n\nThe template:\n\n    <ul>\n        {{#friends}}\n            </li>{{name}}</li>\n        {{/friends}}\n        {{^friends}}\n            <li>No friends.</li>\n        {{/friends}}\n    </ul>\n\nAnd data:\n\n    {\n        friends: []\n    }\n\nResults in:\n\n\n    <ul>\n        <li>No friends.</li>\n    </ul>\n\n\n",
    "description": "\n",
    "title": "{{^key}}",
    "name": "can-stache.tags.inverse",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 5,
    "signatures": [
      {
        "code": "{{^key}}BLOCK{{/key}}",
        "description": "\n\nRender blocks of text if the value of the key\nis falsey.  An inverted section syntax is similar to regular\nsections except it begins with a caret rather than a\npound. If the value referenced is falsey, the section will render.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\n[can-stache.context context]. If the value is a function or [can-compute.computed], the\nfunction's return value is used.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "\n\nDepending on the value's type, the following actions happen:\n\n- A `truthy` value - the block is not rendered.\n- A `falsey` value - the block is rendered.\n\nThe rendered result of the block or an empty string is returned.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A key that references a value within the current or parent\n[can-stache.context context]. If the value is a function or [can-compute.computed], the\nfunction's return value is used.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n\nDepending on the value's type, the following actions happen:\n\n- A `truthy` value - the block is not rendered.\n- A `falsey` value - the block is rendered.\n\nThe rendered result of the block or an empty string is returned.\n"
    },
    "comment": " "
  },
  "can-stache.tags.escaped": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/escaped.md"
    },
    "body": "\n## Use\n\n`{{key}}` insert data into the template. It most commonly references\nvalues within the current [can-stache.context context]. For example:\n\nRendering:\n\n    <h1>{{name}}</h1>\n\nWith:\n\n    {name: \"Austin\"}\n\nResults in:\n\n    <h1>Austin</h1>\n\nIf the key value is a String or Number, it is inserted into the template.\nIf it is `null` or `undefined`, nothing is added to the template.\n\n\n## Nested Properties\n\nStache supports nested paths, making it possible to\nlook up properties nested deep inside the current context. For example:\n\nRendering:\n\n    <h1>{{book.author}}</h1>\n\nWith:\n\n    {\n      book: {\n        author: \"Ernest Hemingway\"\n      }\n    }\n\nResults in:\n\n    <h1>Ernest Hemingway</h1>\n\n## Looking up values in parent contexts\n\nSections and block helpers can create their own contexts. If a key's value\nis not found in the current context, it will look up the key's value\nin parent contexts. For example:\n\nRendering:\n\n    {{#chapters}}\n       <li>{{title}} - {{name}}</li>\n    {{chapters}}\n\nWith:\n\n    {\n      title: \"The Book of Bitovi\"\n      chapters: [{name: \"Breakdown\"}]\n    }\n\nResults in:\n\n    <li>The Book of Bitovi - Breakdown</li>\n\n\n",
    "description": "Insert the value of the [can-stache.key key] into the output of the template.\n\n\n",
    "title": "{{key}}",
    "name": "can-stache.tags.escaped",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 0,
    "signatures": [
      {
        "code": "{{key}}",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references one of the following:\n\n - A [can-stache.registerHelper registered helper].\n - A value within the current or parent\n   [can-stache.context context]. If the value is a function or [can-compute.computed], the\n   function's return value is used.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            },
            {
              "type": "*"
            }
          ],
          "description": "\n\nIf the value is a:\n\n - `null` or `undefined` - an empty string is inserted into the rendered template result.\n - `String` or `Number` - the value is inserted into the rendered template result.\n - `Function` - A [can.view.hook hookup] attribute or element is inserted so this function will be called back with the DOM element after it is created.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A key that references one of the following:\n\n - A [can-stache.registerHelper registered helper].\n - A value within the current or parent\n   [can-stache.context context]. If the value is a function or [can-compute.computed], the\n   function's return value is used.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        },
        {
          "type": "*"
        }
      ],
      "description": "\n\nIf the value is a:\n\n - `null` or `undefined` - an empty string is inserted into the rendered template result.\n - `String` or `Number` - the value is inserted into the rendered template result.\n - `Function` - A [can.view.hook hookup] attribute or element is inserted so this function will be called back with the DOM element after it is created.\n"
    },
    "comment": " "
  },
  "can-stache.tags.unescaped": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/unescaped.md"
    },
    "body": "\n",
    "description": "Insert the unescaped value of the [can-stache.key key] into the output of the template.\n\n",
    "title": "{{{key}}}",
    "name": "can-stache.tags.unescaped",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 1,
    "signatures": [
      {
        "code": "{{{key}}}",
        "description": "\n\nBehaves just like [can-stache.tags.escaped {{key}}] and [can-stache.helpers.helper {{helper}}] but does not\nescape the result.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            },
            {
              "type": "*"
            }
          ],
          "description": "\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        },
        {
          "type": "*"
        }
      ],
      "description": "\n\n"
    }
  },
  "can-stache.tags.unescaped2": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/unescaped_amp.md"
    },
    "body": "\n",
    "description": "Insert the unescaped value of the [can-stache.key key] into the output of the template.\n\n",
    "title": "{{&key}}",
    "name": "can-stache.tags.unescaped2",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 2,
    "signatures": [
      {
        "code": "{{&key}}",
        "description": "\n\nThe `{{&key}}` tag is an alias for [can-stache.tags.unescaped {{{key}}}], behaving just\nlike [can-stache.tags.escaped {{key}}] and [can-stache.helpers.helper {{helper}}] but does not\nescape the result.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            },
            {
              "type": "*"
            }
          ],
          "description": "\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        },
        {
          "type": "*"
        }
      ],
      "description": "\n\n"
    }
  },
  "can-stache.tags.section": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/section.md"
    },
    "body": "\nSections contain text blocks and evaluate whether to render it or not.  If\nthe object evaluates to an array it will iterate over it and render the block\nfor each item in the array.  There are four different types of sections.\n\n## Falseys or Empty Arrays\n\nIf the value returns a `false`, `undefined`, `null`, `\"\"` or `[]` we consider\nthat a *falsey* value.\n\nIf the value is falsey, the section will **NOT** render the block.\n\n    {\n      friends: false\n    }\n\n    {{#friends}}\n      Never shown!\n    {{/friends}}\n\n\n## Arrays\n\nIf the value is a non-empty array, sections will iterate over the\narray of items, rendering the items in the block.\n\nFor example, a list of friends will iterate\nover each of those items within a section.\n\n    {\n        friends: [\n            { name: \"Austin\" },\n            { name: \"Justin\" }\n        ]\n    }\n\n    <ul>\n        {{#friends}}\n            <li>{{name}}</li>\n        {{/friends}}\n    </ul>\n\nwould render:\n\n    <ul>\n        <li>Austin</li>\n        <li>Justin</li>\n    </ul>\n\nReminder: Sections will reset the current context to the value for which it is iterating.\nSee the [basics of contexts](#Basics) for more information.\n\n## Truthys\n\nWhen the value is a non-falsey object but not a list, it is considered truthy and will be used\nas the context for a single rendering of the block.\n\n    {\n        friends: { name: \"Jon\" }\n    }\n\n    {{#friends}}\n        Hi {{name}}\n    {{/friends}}\n\nwould render:\n\n    Hi Jon!\n\n## Understanding when to use Sections with lists\n\nSection iteration will re-render the entire section for any change in the list. It is the prefered method to\nuse when a list is replaced or changing significantly. Whereas [can-stache.helpers.each {{#each key}}] iteration\nwill do basic diffing and aim to only update the DOM where the change occured. When doing single list item\nchanges frequently, [can-stache.helpers.each {{#each key}}] iteration is the faster choice.\n\nFor example, assuming \"list\" is a [can-list] instance:\n\n{{#if list}} will check for the truthy value of list. This is akin to checking for the truthy value of any JS object and will result to true, regardless of list contents or length.\n\n{{#if list.length}} will check for the truthy value of the length attribute. If you have an empty list, the length will be 0, so the #if will result to false and no contents will be rendered. If there is a length >= 1, this will result to true and the contents of the #if will be rendered.\n\n{{#each list}} and {{#list}} both iterate through an instance of [can-list], however we setup the bindings differently.\n\n{{#each list}} will setup bindings on every individual item being iterated through, while {{#list}} will not. This makes a difference in two scenarios:\n\n1) You have a large list, with minimal updates planned after initial render. In this case, {{#list}} might be more advantageous as there will be a faster initial render. However, if any part of the list changes, the entire {{#list}} area will be re-processed.\n\n2) You have a large list, with many updates planned after initial render. A grid with many columns of editable fields, for instance. In this case, you many want to use {{#each list}}, even though it will be slower on initial render(we're setting up more bindings), you'll have faster updates as there are now many sections.\n\n",
    "description": "\n",
    "title": "{{#key}}",
    "name": "can-stache.tags.section",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 3,
    "signatures": [
      {
        "code": "{{#key}}BLOCK{{/key}}",
        "description": "\n\nRender blocks of text one or more times, depending\non the value of the key in the current context.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\n[can-stache.context context]. If the value is a function or [can-compute.computed], the\nfunction's return value is used.\n\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "\n\nDepending on the value's type, the following actions happen:\n\n- `Array` or [can-list] - the block is rendered for\n  each item in the array. The [can-stache.context context] is set to\n  the item within each block rendering.\n- A `truthy` value - the block is rendered with the [can-stache.context context]\n  set to the value.\n- A `falsey` value - the block is not rendered.\n\nThe rendered result of the blocks, block or an empty string is returned.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A key that references a value within the current or parent\n[can-stache.context context]. If the value is a function or [can-compute.computed], the\nfunction's return value is used.\n\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n\nDepending on the value's type, the following actions happen:\n\n- `Array` or [can-list] - the block is rendered for\n  each item in the array. The [can-stache.context context] is set to\n  the item within each block rendering.\n- A `truthy` value - the block is rendered with the [can-stache.context context]\n  set to the value.\n- A `falsey` value - the block is not rendered.\n\nThe rendered result of the blocks, block or an empty string is returned.\n"
    },
    "comment": " "
  },
  "can-util/dom/child-nodes/child-nodes": {
    "type": "module",
    "name": "can-util/dom/child-nodes/child-nodes",
    "parent": "can-util/dom",
    "src": {
      "line": 0,
      "codeLine": 20,
      "path": "node_modules/can-util/dom/child-nodes/child-nodes.js"
    },
    "body": "",
    "description": "",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "childNodes(node)",
        "description": "\n\nGet all of the childNodes of a given node.\n\n```js\nvar stache = require(\"can-stache\");\nvar childNodes = require(\"can-util/child-nodes/child-nodes\");\n\nvar html = \"<div><h1><span></span></h1></div>\";\nvar frag = stache(html)();\n\nconsole.log(childNodes(frag)[0].nodeName); // -> DIV\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "node",
            "description": "The Node that you want child nodes for.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "node",
      "description": "The Node that you want child nodes for.\n"
    }
  },
  "can.view.attr.map": {
    "name": "can.view.attr.map",
    "type": "property",
    "parent": "can.view.elements",
    "src": {
      "line": 23,
      "codeLine": 44,
      "path": "node_modules/can-util/dom/attr/attr.js"
    },
    "body": "\nA mapping of\nspecial attributes to their JS property. For example:\n\n    \"class\" : \"className\"\n\nmeans get or set `element.className`. And:\n\n     \"checked\" : true\n\nmeans set `element.checked = true`.\n\n\nIf the attribute name is not found, it's assumed to use\n`element.getAttribute` and `element.setAttribute`.\n\t \n",
    "description": "\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Boolean"
              },
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "title": "",
    "hide": true
  },
  "can-util/dom/data/data": {
    "name": "can-util/dom/data/data",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 13,
      "codeLine": 23,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "Allows associating data as a key/value pair for a particular DOM Node.\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n```\n\n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/data/data.get": {
    "type": "function",
    "name": "can-util/dom/data/data.get",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 38,
      "codeLine": 50,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.get",
    "signatures": [
      {
        "code": "domData.get.call(el, key)",
        "description": "\n\nGet data that was stored in a DOM Node using the specified `key`.\n\n```js\nvar metadata = domData.get.call(el, \"metadata\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A string used as a unique key for storing data associated with this DOM Node.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A string used as a unique key for storing data associated with this DOM Node.\n "
    }
  },
  "can-util/dom/data/data.set": {
    "name": "can-util/dom/data/data.set",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 55,
      "codeLine": 67,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.set",
    "signatures": [
      {
        "code": "domData.set.call(el, key, value)",
        "description": "\n\nSet data to be associated with a DOM Node using the specified `key`. If data already exists for this key, it will be overwritten.\n\n```js\ndomData.set.call(el, \"metadata\", {\n  foo: \"bar\"\n});\n```\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/dispatch/dispatch": {
    "type": "module",
    "name": "can-util/dom/dispatch/dispatch",
    "parent": "can-util/dom",
    "src": {
      "line": 3,
      "codeLine": 15,
      "path": "node_modules/can-util/dom/dispatch/dispatch.js"
    },
    "body": "",
    "description": "",
    "title": "dispatch",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "dispatch.call(el, event, args, bubbles)",
        "description": "\n\nDispatch an event on an element.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "An object specifies options applied to this event."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Arguments passed into this event."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "bubbles",
            "defaultValue": "true",
            "description": "Specifies whether this event should bubble (by default it will).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "bubbles",
      "defaultValue": "true",
      "description": "Specifies whether this event should bubble (by default it will).\n"
    }
  },
  "can-util/dom/events/events": {
    "name": "can-util/dom/events/events",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 0,
      "codeLine": 9,
      "path": "node_modules/can-util/dom/events/events.js"
    },
    "body": "",
    "description": "Allows you to listen to a domEvent and special domEvents. \n```js\nvar domEvents = require(\"can-util/dom/events/events\");\n```\n\n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/mutate/mutate": {
    "name": "can-util/dom/mutate/mutate",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 87,
      "codeLine": 104,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "Mutate an element by appending, inserting, and removing DOM nodes. Use this so that on the server \"inserted\" will be fired. \n```js\nvar mutate = require(\"can-util/dom/mutate/mutate\");\n\nvar el = document.createElement(\"div\");\n\nel.addEventListener(\"inserted\", function(){\n  console.log(\"Inserted was fired!\");\n});\n\nmutate.appendChild.call(document.body, el);\n```\n\n",
    "title": "can-util/dom/mutate/mutate",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.appendChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.appendChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 105,
      "codeLine": 110,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "appendChild",
    "signatures": [
      {
        "code": "mutate.appendChild.call(el, child)",
        "description": "\nUsed to append a node to an element and trigger the \"inserted\" event on all of the newly inserted children. Since `can.inserted` takes an array we convert the child to an array, or in the case of a DocumentFragment we first convert the childNodes to an array and call inserted on those.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.insertBefore": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.insertBefore",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 124,
      "codeLine": 129,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "insertBefore",
    "signatures": [
      {
        "code": "mutate.insertBefore.call(el, ref, child)",
        "description": "\nLike mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"inserted\" event.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.removeChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.removeChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 143,
      "codeLine": 148,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "removeChild",
    "signatures": [
      {
        "code": "mutate.removeChild.call(el, child)",
        "description": "\nLike mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"removed\" event.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.replaceChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.replaceChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 156,
      "codeLine": 161,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "replaceChild",
    "signatures": [
      {
        "code": "mutate.replaceChild.call(el, child)",
        "description": "\nLike mutate.appendChild and mutate.removeChild, used to replace a node with another node and trigger \"removed\" on the removed element and \"inserted\" on the inserted elements.\n ",
        "params": []
      }
    ]
  },
  "warn": {
    "type": "function",
    "name": "warn",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "out",
        "description": "the message\n "
      }
    ],
    "parent": "node_modules/can-util/js/dev/dev.js",
    "src": {
      "line": 4,
      "codeLine": 11,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "body": "",
    "description": "Adds a warning message to the console.\n```\ncan.dev.warn(\"something evil\");\n```\n",
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "out",
      "description": "the message\n "
    }
  },
  "log": {
    "type": "function",
    "name": "log",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "out",
        "description": "the message\n "
      }
    ],
    "parent": "node_modules/can-util/js/dev/dev.js",
    "src": {
      "line": 24,
      "codeLine": 31,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "body": "",
    "description": "Adds a message to the console.\n```\ncan.dev.log(\"hi\");\n```\n",
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "out",
      "description": "the message\n "
    }
  },
  "can-util/js/assign/assign": {
    "type": "module",
    "name": "can-util/js/assign/assign",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 25,
      "path": "node_modules/can-util/js/assign/assign.js"
    },
    "body": "",
    "description": "",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "assign(target, source)",
        "description": "\n\nA simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.\n\n```js\nvar assign = require(\"can-util/js/assign/assign\");\n\nvar obj = {};\n\nassign(obj, {\n  foo: \"bar\"\n});\n\nconsole.log(obj.foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The destination object. This object's properties will be mutated based on the object provided as `source`."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "The source object whose own properties will be applied to `target`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the `target` argument.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "The source object whose own properties will be applied to `target`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the `target` argument.\n"
    }
  },
  "can-util/js/each/each": {
    "src": {
      "path": "node_modules/can-util/js/each/each.md"
    },
    "body": "",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/each/each",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "each(elements, callback, context)",
        "description": "\n\nLoop over each element in an Array-Like data structure.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "ArrayLike"
              }
            ],
            "name": "elements",
            "description": ""
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "element"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "key"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "elements"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "the context object\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "context",
      "description": "the context object\n"
    }
  },
  "can-util/js/deep-assign/deep-assign": {
    "src": {
      "path": "node_modules/can-util/js/deep-assign/deep-assign.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/deep-assign/deep-assign",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "deepAssign(target, [ ... sources ])",
        "description": "\n\nAssign properties from a source object to a target object, deeply copying properties that are objects or arrays.\n\n```js\nvar deepAssign = require(\"can-util/js/deep-assign/deep-assign\");\n\nvar dest = deepAssign({}, {\n  obj: {\n\t\tfoo: \"bar\"\n\t}\n}, {\n  arr: [{ hello: \"world\" }]\n});\n\nconsole.log(dest.obj.foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The target object who's properties will be assigned from the source objects."
          },
          {
            "variable": true,
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "Source objects from which properties will be assigned to the `target` object. Sources will be copied deeply; meaning any object or array properties will be traversed and copied (like a clone).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "variable": true,
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "Source objects from which properties will be assigned to the `target` object. Sources will be copied deeply; meaning any object or array properties will be traversed and copied (like a clone).\n"
    }
  },
  "can-util/js/import/import": {
    "type": "module",
    "name": "can-util/js/import/import",
    "parent": "can-util/js",
    "src": {
      "line": 3,
      "codeLine": 21,
      "path": "node_modules/can-util/js/import/import.js"
    },
    "body": "",
    "description": "",
    "title": "import",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "importModule(moduleName, parentName)",
        "description": "\n\n```js\nvar importModule = require(\"can-util/js/import/import\");\n\nimportModule(\"foo.stache\").then(function(){\n  // module was imported\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "moduleName",
            "description": "The module to be imported."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "parentName",
            "description": "A parent module that will be used as a reference for resolving relative module imports."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that will resolve when the module has been imported.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "parentName",
      "description": "A parent module that will be used as a reference for resolving relative module imports."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that will resolve when the module has been imported.\n"
    }
  },
  "can-util/js/is-browser-window/is-browser-window": {
    "type": "module",
    "name": "can-util/js/is-browser-window/is-browser-window",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 19,
      "path": "node_modules/can-util/js/is-browser-window/is-browser-window.js"
    },
    "body": "",
    "description": "",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isBrowserWindow()",
        "description": "\n\nReturns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).\n\n```js\nvar isBrowserWindow = require(\"can-util/js/is-browser-window/is-browser-window\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isBrowserWindow()) {\n  console.log(GLOBAL() === window); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the environment is a Browser window.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the environment is a Browser window.\n"
    }
  },
  "can-util/js/is-empty-object/is-empty-object": {
    "type": "module",
    "name": "can-util/js/is-empty-object/is-empty-object",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 20,
      "path": "node_modules/can-util/js/is-empty-object/is-empty-object.js"
    },
    "body": "",
    "description": "",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isEmptyObject(obj)",
        "description": "\n\nUsed to determine if an object is an empty object (an object with no properties) such as `{}`.\n\n```js\nvar isEmptyObject = require(\"can-util/js/is-empty-object/is-empty-object\");\n\nconsole.log(isEmptyObject({})); // -> true\n\nconsole.log(isEmptyObject({ a: 1 })); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "Any object."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is an object with no properties.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "Any object."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is an object with no properties.\n"
    }
  },
  "can-util/js/is-array-like/is-array-like": {
    "src": {
      "path": "node_modules/can-util/js/is-array-like/is-array-like.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-array-like/is-array-like",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isArrayLike(obj)",
        "description": "\n\nDetermines if an object is \"array like\", meaning it can be looped over. Any object with a `.length` property is array like.\n\n```js\nvar isArrayLike = require(\"can-util/js/is-array-like/is-array-like\");\n\n// Arrays\nconsole.log(isArrayLike([{ foo: \"bar\" }])); // -> true\n\n// Strings\nconsole.log(isArrayLike(\"some string\")); // -> true\n\n// Objects with .length property\nconsole.log(isArrayLike({ length: 11 })); // -> true\n\n// Numbers and Booleans are not.\nconsole.log(isArrayLike(true)); // -> false\nconsole.log(isArrayLike(13)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "Any object type."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True, if the object is similar to an array.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "Any object type."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True, if the object is similar to an array.\n"
    }
  },
  "can-util/js/is-function": {
    "type": "module",
    "name": "can-util/js/is-function",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 17,
      "path": "node_modules/can-util/js/is-function/is-function.js"
    },
    "body": "",
    "description": "\n",
    "title": "/is-function",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isFunction(value)",
        "description": "\n\n```js\nvar isFunction = require(\"can-util/js/is-function/is-function\");\n\nconsole.log(isFunction(function(){})); // -> true\n\nconsole.log(isFunction({})); // -> false\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the provided argument is a function.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the provided argument is a function.\n"
    }
  },
  "can-util/js/is-node/is-node": {
    "type": "module",
    "name": "can-util/js/is-node/is-node",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 18,
      "path": "node_modules/can-util/js/is-node/is-node.js"
    },
    "body": "",
    "description": "Determines if your code is running in [Node.js](https://nodejs.org). ",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isNode()",
        "description": "\n\n```js\nvar isNode = require(\"can-util/js/is-node/is-node\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isNode()) {\n  console.log(GLOBAL() === global); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if running in Node.js\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if running in Node.js\n"
    }
  },
  "can-util/js/global/global": {
    "body": "",
    "description": "",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/global/global",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "GLOBAL()",
        "description": "\n\nReturns the global that this environment provides. It will be one of:\n\n* **Browser**: `window`\n* **Web Worker**: `self`\n* **Node.js**: `global`\n\n```js\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nvar g = GLOBAL();\n\n// In a browser\nconsole.log(g === window); // -> true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The global object for this JavaScript environment.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The global object for this JavaScript environment.\n"
    }
  },
  "can-util/js/is-plain-object/is-plain-object": {
    "src": {
      "path": "node_modules/can-util/js/is-plain-object/is-plain-object.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-plain-object/is-plain-object",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isPlainObject(obj)",
        "description": "\n\nAttempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:\n\n1. Objects with prototypes (created using the `new` keyword).\n2. Booleans.\n3. Numbers.\n4. NaN.\n\n```js\nvar isPlainObject = require(\"can-util/js/is-plain-object/is-plain-object\");\n\n// Created with {}\nconsole.log(isPlainObject({})); // -> true\n\n// new Object\nconsole.log(isPlainObject(new Object())); // -> true\n\n// Custom object\nvar Ctr = function(){};\nvar obj = new Ctr();\n\nconsole.log(isPlainObject(obj)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-util/js/join-uris/join-uris": {
    "src": {
      "path": "node_modules/can-util/js/join-uris/join-uris.md"
    },
    "body": "",
    "description": "Join together a URI path to a base. ",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/join-uris/join-uris",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "joinURIs(base, href)",
        "description": "\n\nProvides a convenient way to join together URIs handling relative paths.\n\n```js\nvar joinURIs = require(\"can-util/js/join-uris\");\n\nvar base = \"http://example.com/some/long/path\";\nvar href = \"../../images/foo.png\";\n\nvar res = joinURIs(base, href);\n\nconsole.log(res); // -> http://example.com/images/foo.png\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "base",
            "description": ""
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "href",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The result of joining the two parts.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "href",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The result of joining the two parts.\n"
    }
  },
  "can-util/js/is-promise/is-promise": {
    "type": "module",
    "name": "can-util/js/is-promise/is-promise",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 21,
      "path": "node_modules/can-util/js/is-promise/is-promise.js"
    },
    "body": "",
    "description": "",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isPromise(obj)",
        "description": "\n\nDetermines if an object is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar isPromise = require(\"can-util/js/is-promise/is-promise\");\n\nvar promise = new Promise(function(resolve){\n  resolve();\n});\n\nconsole.log(isPromise(promise)); // -> true\nconsole.log(isPromise(\"foo bar\")); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be tested."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be tested."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a Promise.\n"
    }
  },
  "can-util/js/is-web-worker/is-web-worker": {
    "body": "",
    "description": "Determines if the code is running with a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers). ",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-web-worker/is-web-worker",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isWebWorker()",
        "description": "\n\n```js\nvar isWebWorker = require(\"can-util/js/is-web-worker/is-web-worker\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isWebWorker()) {\n  console.log(GLOBAL() === self); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if running in a Web Worker.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if running in a Web Worker.\n"
    }
  },
  "can-util/js/is-string/is-string": {
    "type": "module",
    "name": "can-util/js/is-string/is-string",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 18,
      "path": "node_modules/can-util/js/is-string/is-string.js"
    },
    "body": "",
    "description": "Determines if the provided argument is a string. ",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isString(obj)",
        "description": "\n\n```js\nvar isString = require(\"can-util/js/is-string/is-string\");\n\nconsole.log(isString(\"foo\")); // -> true\nconsole.log(isString(String(\"foo\")); // -> true\n\nconsole.log(isString({})); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "An object to test if is a string."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "An object to test if is a string."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a string.\n"
    }
  },
  "can-zone/timeout.TimeoutError": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/timeouterror.md"
    },
    "body": "\n",
    "description": "A special type of Error that also includes the number of milliseconds that were waited before timing out. \nThe error object is included with the timeout module:\n\n```js\nvar timeout = require(\"can-zone/timeout\");\n\nvar TimeoutError = timeout.TimeoutError;\n// Maybe use this to check `instanceof`.\n```\n\n",
    "type": "typedef",
    "title": "TimeoutError",
    "types": [
      {
        "type": "Error",
        "options": [
          {
            "name": "timeout",
            "description": "Specifies the timeout that was exceeded.\n",
            "types": [
              {
                "type": "Number"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/timeout.TimeoutError",
    "parent": "can-zone/timeout"
  },
  "can-zone/debug": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/debug.md"
    },
    "body": "\n## Use\n\nThe **debug** zone gives you information about which tasks failed to complete in case of a timeout. It is to be used with [./timeout.md](can-zone/timeout).\n\nWhen a timeout occurs the debug Zone will appending debug information to the Zone's [data](https://github.com/canjs/can-zone/blob/master/docs/data.md) property, which can be retrieved when the Zone's promise is rejected:\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nvar zone = new Zone(debug(5000);\n\nzone.run(function(){\n\n\tsetTimeout(function(){}, 10000);\n\n}).catch(err){\n\n\tvar debugInfo = zone.data.debugInfo;\n\n});\n```\n\n## DebugInfo\n\nThe **DebugInfo** is an array of objects that contain information about which tasks failed to complete. Each object has a shape of:\n\n```js\n{\n\t\"task\": \"setTimeout\",\n\t\"stack\": Error ....\"\n}\n```\n\n### DebugInfo[].task\n\nA *string* identifier of the task that failed to complete. This can be any of the [asynchronous tasks](https://github.com/canjs/can-zone#tasks) supported by can-zone like `setTimeout` or `Promise`.\n\n### DebugInfo[].stack\n\nA *string* stack trace taken as a snapshot when the task was called. This allows you t see the source of the call to help debug why the task never completed.\n\n## debug(timeout)\n\nCreate a debug Zone by passing the debug function a timeout in milliseconds:\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nnew Zone({\n\tplugins: [\n\t\tdebug(5000)\n\t]\n});\n```\n\n## debug(timeoutZone)\n\nCreate a debug Zone by passing in a timeout Zone that was already created:\n\n```js\nvar timeout = require(\"can-zone/timeout\");\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nvar timeoutZone = timeout(5000);\nvar debugZone = debug(timeoutZone);\n\nnew Zone({\n\tplugins: [\n\t\ttimeoutZone,\n\t\tdebugZone\n\t]\n});\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-zone/debug",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone/debug",
    "parent": "can-zone.plugins",
    "signatures": [
      {
        "code": "debug(ms)",
        "description": "\n\nCreates a new [can-zone.ZoneSpec] that can be provided to your Zone, timing out in `ms` (milliseconds).\n\n```js\nvar Zone = require(\"can-zone\");\nvar debug = require(\"can-zone/debug\");\n\nvar zone = new Zone({\n\tplugins: [debug(5000)]\n})\n.catch(function(err){\n\tvar info = zone.data.debugInfo;\n});\n```\n\nSee the [can-zone/debug.DebugInfo] type for a list of properties \n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "ms",
            "description": "The timeout, in milliseconds, before the [can-zone Zone] will be rejected and debug information attached to the [can-zone.prototype.data zone's data] object.\n"
          }
        ]
      },
      {
        "code": "debug(timeoutZone)",
        "description": "\n\nLike the previous signature, but directly pass it a [can-zone/timeout timeout ZoneSpec] object that you create yourself.\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar timeoutZone = timeout(5000);\nvar debugZone = debug(timeoutZone):\n\n...\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-zone/timeout"
              }
            ],
            "name": "timeoutZone",
            "description": "A [can-zone.ZoneSpec] created using the timeout plugin.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-zone/timeout"
        }
      ],
      "name": "timeoutZone",
      "description": "A [can-zone.ZoneSpec] created using the timeout plugin.\n"
    },
    "comment": " "
  },
  "can-zone/timeout": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/timeout.md"
    },
    "body": "\n## Use\n\nThe timeout zone allows you to specify a timeout for your Zone. If the Zone promise doesn't resolve before timing out, the Zone promise will be rejected by the plugin.\n\nThe **timeout** zone is a function that takes a timeout in milliseconds.\n\nThe Promise will reject with a special type of Error, a [can-zone/timeout.TimeoutError].\n\n```js\nvar Zone = require(\"can-zone\");\nvar timeout = require(\"can-zone/timeout\");\nvar TimeoutError = timeout.TimeoutError;\n\nvar zone = new Zone({\n\tplugins: [\n\t\ttimeout(2000)\n\t]\n});\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\n\t}, 5000);\n\n}).then(null, function(err){\n\n\t// err.timeout -> 2000\n\n});\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-zone/timeout",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "ms"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/timeout",
    "parent": "can-zone.plugins",
    "signatures": [
      {
        "code": "timeout(ms)",
        "description": "\n\nCreates a [can-zone.ZoneSpec] that you can use as a plugin for your [can-zone Zone] in order to timeout after a certain length of time (as `ms`).\n\nIf the Zone times out it's [can-zone.prototype.run run promise] will be rejected with a [can-zone/timeout.TimeoutError], a special error that also includes the number of milliseconds waited before timing out.\n\n```js\nvar Zone = require(\"can-zone\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar zone = new Zone({\n\tplugins: [ timeout(5000) ]\n});\n\nzone.run(function(){\n\tsetTimeout(function(){\n\n\t}, 10000); // waiting over 5 sec\n})\n.catch(function(err){\n\t// Called because we exceeded the timeout.\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "ms",
            "description": "The number of milliseconds to wait before timing out the [can-zone Zone].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-zone.ZoneSpec"
            }
          ],
          "description": "A ZoneSpec that can be passed as a plugin.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "ms",
      "description": "The number of milliseconds to wait before timing out the [can-zone Zone].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        }
      ],
      "description": "A ZoneSpec that can be passed as a plugin.\n"
    },
    "comment": " "
  },
  "can-zone/debug.DebugInfo": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/debuginfo.md"
    },
    "body": "",
    "description": "An array of objects containing information useful for debugging. Gives you the name of the **task** that failed to complete and a **stack** trace of where the error occured. \nEach object has a shape of:\n\n```js\n{\n\t\"task\": \"setTimeout\",\n\t\"stack\": Error ....\"\n}\n```\n\n",
    "type": "typedef",
    "title": "DebugInfo",
    "types": [
      {
        "type": "Array",
        "template": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ],
        "options": [
          {
            "name": "task",
            "description": "An identifier of the task that failed to complete. This can be any of the [asynchronous tasks](https://github.com/canjs/can-zone#tasks) supported by can-zone like `setTimeout` or `Promise`.\n\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "stack",
            "description": "A stack trace taken as a snapshot when the task was called. This allows you t see the source of the call to help debug why the task never completed.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/debug.DebugInfo",
    "parent": "can-zone/debug"
  },
  "can-connect/can/map/map.id": {
    "type": "function",
    "name": "can-connect/can/map/map.id",
    "parent": "can-connect/can/map/map.identifiers",
    "src": {
      "line": 41,
      "codeLine": 57,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "body": "\n",
    "description": "\nReturns a unique identifier value for an instance.\n",
    "title": "id",
    "signatures": [
      {
        "code": "connection.id( instance )",
        "description": "\n\n  Reads [can-connect/base/base.idProp] so that it's observable unless\n  the id is being read as part of the map being bound or\n  unbound.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "instance",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "name": "instance",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/map/map.serializeInstance": {
    "type": "function",
    "name": "can-connect/can/map/map.serializeInstance",
    "parent": "can-connect/can/map/map.serializers",
    "src": {
      "line": 82,
      "codeLine": 90,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCalls `instance.serialize()`.\n",
    "title": "serializeInstance",
    "signatures": [
      {
        "code": "connection.serializeInstance( instance )",
        "description": "\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.serializeList": {
    "type": "function",
    "name": "can-connect/can/map/map.serializeList",
    "parent": "can-connect/can/map/map.serializers",
    "src": {
      "line": 93,
      "codeLine": 101,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCalls `list.serialize()`.\n",
    "title": "serializeList",
    "signatures": [
      {
        "code": "connection.serializeList( list )",
        "description": "\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.Map": {
    "src": {
      "line": 104,
      "codeLine": 132,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```\nvar Todo = CanMap.extend({\n  complete: function(){\n    this.attr(\"complete\", true);\n  }\n});\n\nvar todoConnection = connect([\"can/map\",\"constructor\",\"data-url\"],{\n  Map: Todo,\n  url: \"/todos\"\n})\n```\n\t \n",
    "description": "\nSpecify what type of `CanMap` should be hydrated.\n",
    "types": [
      {
        "type": "CanMap",
        "description": "Defaults to `CanMap` if a Map is\nnot specified.\n"
      }
    ],
    "title": "Map",
    "name": "can-connect/can/map/map.Map",
    "parent": "can-connect/can/map/map.hydrators",
    "comment": " "
  },
  "can-connect/can/map/map._List": {
    "src": {
      "line": 132,
      "codeLine": 167,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```\nvar Todo = CanMap.extend({\n  complete: function(){\n    this.attr(\"complete\", true);\n  }\n});\nvar Todo.List = CanList.extend({Map: Todo},{\n  completed: function(){\n    this.filter(function(todo){\n      return todo.attr(\"complete\");\n    });\n  }\n});\n\nvar todoConnection = connect([\"can/map\",\"constructor\",\"data-url\"],{\n  Map: Todo,\n  List: Todo.List,\n  url: \"/todos\"\n});\n```\n\t \n",
    "description": "\nSpecify what type of `CanList` should be hydrated.\n",
    "types": [
      {
        "type": "CanList",
        "description": "Defaults to [can-connect/can/map/map.Map]'s `.List` and\nthen `CanList` if `connection.List` is not specified.\n"
      }
    ],
    "title": "List",
    "name": "can-connect/can/map/map._List",
    "parent": "can-connect/can/map/map.hydrators",
    "comment": " "
  },
  "can-connect/can/map/map.instance": {
    "type": "function",
    "name": "can-connect/can/map/map.instance",
    "parent": "can-connect/can/map/map.hydrators",
    "src": {
      "line": 167,
      "codeLine": 177,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCreates a `Map` instance.\n",
    "title": "instance",
    "signatures": [
      {
        "code": "connection.instance( props )",
        "description": "\n\n  Uses the [can-connect/can/map/map.Map] property if available, otherwise\n  creates the base `CanMap`.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.list": {
    "type": "function",
    "name": "can-connect/can/map/map.list",
    "parent": "can-connect/can/map/map.hydrators",
    "src": {
      "line": 181,
      "codeLine": 199,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCreates a `CanList` instance given raw data.\n",
    "title": "list",
    "signatures": [
      {
        "code": "connection.list(listData, set)",
        "description": "\n\n  Uses the [can-connect/can/map/map._List] property if available, otherwise\n  creates the [can-connect/can/map/map.Map].List if available, and then finally\n  defaults to the base `CanList`.\n\n  This will add properties on `listData` to the list too.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "List"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "List"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/map/map.updatedList": {
    "type": "function",
    "name": "can-connect/can/map/map.updatedList",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "src": {
      "line": 210,
      "codeLine": 220,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "body": "\n",
    "description": "\nUpdates a list with response data.\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedList( list, listData, set)",
        "description": "\n\n  Updates the list within a batch event.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.createdInstance": {
    "src": {
      "line": 251,
      "codeLine": 263,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.createData].\n",
    "title": "createdInstance",
    "name": "can-connect/can/map/map.createdInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"created\" event on the map and the map's constructor function.\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.updatedInstance": {
    "src": {
      "line": 264,
      "codeLine": 275,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.updateData].\n",
    "title": "updatedInstance",
    "name": "can-connect/can/map/map.updatedInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"updated\" event on the map and the map's constructor function.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.destroyedInstance": {
    "src": {
      "line": 276,
      "codeLine": 287,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.destroyData].\n",
    "title": "destroyedInstance",
    "name": "can-connect/can/map/map.destroyedInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.destroyedInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"destroyed\" event on the map and the map's constructor function.\n\t ",
        "params": []
      }
    ]
  },
  "CanMap.getList": {
    "type": "function",
    "name": "CanMap.getList",
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 365,
      "codeLine": 371,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "body": " \n",
    "description": "\nAlias of [CanMap.getList]. You should use `.getList()`.\n",
    "title": "getList",
    "signatures": [
      {
        "code": "Map.getList(set)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "CanList"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "CanList"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " ",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "connection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ]
  },
  "CanMap.get": {
    "type": "function",
    "name": "CanMap.get",
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 376,
      "codeLine": 404,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "body": "\n\n## Use\n\n```\nvar Todo = CanMap.extend({});\n\nconnect([\"can/map\",\"constructor\",\"data-url\"],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nTodo.get({id: 5}).then(function(todo){\n\n});\n```\n \n",
    "description": "\nGets an instance of the map type.\n",
    "title": "get",
    "signatures": [
      {
        "code": "Map.get(params)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "params",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "CanMap"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "params",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "CanMap"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "CanMap.findOne": {
    "type": "function",
    "name": "CanMap.findOne",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "connection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 410,
      "codeLine": 416,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "body": " \n",
    "description": "\nAlias of [CanMap.get]. You should use `.get()`.\n",
    "title": "findOne"
  },
  "CanMap.prototype.isNew": {
    "src": {
      "line": 452,
      "codeLine": 464,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map has not been persisted.\n",
    "title": "isNew",
    "name": "CanMap.prototype.isNew",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isNew()",
        "description": "\n\n  Returns `true` if [can-connect/base/base.id] is 0 or truthy.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n\t "
    }
  },
  "CanMap.prototype.isSaving": {
    "src": {
      "line": 472,
      "codeLine": 484,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map is currently being saved.\n",
    "title": "isSaving",
    "name": "CanMap.prototype.isSaving",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isSaving()",
        "description": "\n\n  Returns `true` if .save() has been called, but has not resolved yet.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n\t "
    }
  },
  "CanMap.prototype.isDestroying": {
    "src": {
      "line": 490,
      "codeLine": 502,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map is currently being destroyed.\n",
    "title": "isDestroying",
    "name": "CanMap.prototype.isDestroying",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isSaving()",
        "description": "\n\n  Returns `true` if .destroy() has been called, but has not resolved yet.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n\t "
    }
  },
  "CanMap.prototype.save": {
    "src": {
      "line": 508,
      "codeLine": 537,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\n```\nvar Todo = CanMap.extend({});\n\nconnect([\"can/map\",\"constructor\",\"data-url\"],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nnew Todo({name: \"dishes\"}).save();\n```\n\t \n",
    "description": "\nPersists the map's data to the connection.\n",
    "title": "save",
    "name": "CanMap.prototype.save",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.save( [success], [error] )",
        "description": "\n\n  Calls [can-connect/connection.save].\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "success",
            "description": "A function that is called if the save is successful."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function that is called if the save is rejected."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance is successful.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function that is called if the save is rejected."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance is successful.\n"
    },
    "comment": " "
  },
  "CanMap.prototype.destroy": {
    "src": {
      "line": 545,
      "codeLine": 574,
      "path": "node_modules/can-connect/src/can/map/map.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\n```\nvar Todo = CanMap.extend({});\n\nconnect([\"can/map\",\"constructor\",\"data-url\"],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nnew Todo({name: \"dishes\"}).save(function(todo){\n  todo.destroy();\n});\n```\n\t \n",
    "description": "\nDelete's the instance with the connection.\n",
    "title": "destroy",
    "name": "CanMap.prototype.destroy",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.destroy( [success], [error] )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "success",
            "description": "A function that is called if the destroy is successful."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function that is called if the destroy is rejected."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance is successful.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function that is called if the destroy is rejected."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance is successful.\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.map-static": {
    "name": "can-connect/can/map/map.map-static",
    "title": "Map Static Methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 0
  },
  "can-connect/can/map/map.map": {
    "name": "can-connect/can/map/map.map",
    "title": "Map Instance Methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 1
  },
  "can-connect/can/map/map.hydrators": {
    "name": "can-connect/can/map/map.hydrators",
    "title": "Hydrators",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 2
  },
  "can-connect/can/map/map.serializers": {
    "name": "can-connect/can/map/map.serializers",
    "title": "Serializers",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 3
  },
  "can-connect/can/map/map.identifiers": {
    "name": "can-connect/can/map/map.identifiers",
    "title": "Identifiers",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 4
  },
  "can-connect/can/map/map.instance-callbacks": {
    "name": "can-connect/can/map/map.instance-callbacks",
    "title": "Instance Callbacks",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 5
  },
  "can-connect/can/map/map": {
    "src": {
      "path": "node_modules/can-connect/src/can/map/map.md"
    },
    "body": "\n\n## Use\n\nThe `can/map` behavior make a connection use instances of a [can.Map](http://canjs.com/docs/can.Map.html) and\n[can.List](http://canjs.com/docs/can.List.html).  It also adds methods to the [can.Map](http://canjs.com/docs/can.Map.html)\nthat use the connection for retrieving, creating, updating, and destroying Map instances.\n\nTo use `can/map`, first create a Map and List constructor function:\n\n```\nvar Todo = can.Map.extend({\n  canComplete: function(ownerId) {\n    return this.attr(\"ownerId\") === ownerId;\n  }\n});\n\nvar TodoList = can.List.extend({\n  Map: Todo\n},{\n  incomplete: function(){\n    return this.filter(function(todo){\n      return !todo.attr(\"complete\")\n    });\n  }\n});\n```\n\nNext, pass the Map and List constructor functions to `connect` as options. The following\ncreates a connection that connects `Todo` and `TodoList` to a restful URL:\n\n```js\nvar connect = require(\"can-connect\");\n\nvar todoConnection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/can/map/map\")\n],{\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\"\n});\n```\n\nNow the connection can be used to CRUD `Todo` and `TodoList`s:\n\n```\ntodoConnection.getList({}).then(function(todos){\n  var incomplete = todos.incomplete();\n  incomplete.attr(0).canComplete( 5 ) //-> true\n})\n```\n\nHowever, because `can/map` adds methods to the `Map` option, you can use `Todo` directly to\nCRUD `Todo` and `TodoList`s:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.attr({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nConnects a [can.Map](http://canjs.com/docs/can.Map.html) to everything that needs to be connected to\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect/can/map/map",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "canMap( baseConnect )",
        "description": "\n\n  Implements the hydrators, serializers, identifiers, and instance\n  callback interfaces so they work with a [can.Map](http://canjs.com/docs/can.Map.html) and\n  [can.List](http://canjs.com/docs/can.List.html).\n  Adds static and prototype methods to the Map that make use of the connection's\n  methods.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/super-map": {
    "src": {
      "path": "node_modules/can-connect/src/can/super-map/super-map.md"
    },
    "body": "\n\n## Use\n\nThe `can-connect/can/super-map` module exports a helper function that creates a connection\nwith the \"standard\" behaviors in can-connect and hooks it up to a\n[can.Map](http://canjs.com/docs/can.Map.html) and [can.List](http://canjs.com/docs/can.List.html).\n\nIf you are using CanJS, this is an easy way to create a connection that can be useful and\nfast in most circumstances.\n\nTo use it, first define a Map and List constructor function:\n\n```\nvar Todo = can.Map.extend({ ... });\nvar TodoList = can.List.extend({Map: Todo},{ ... });\n```\n\nNext, call `superMap` with all of the options needed by the behaviors that `superMap` adds:\n\n```\nvar todoConnection = superMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nAs, [can-connect/can/map/map] adds CRUD methods to the `Map` option, you can use those to create,\nread, update and destroy todos:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.attr({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nCreate connection with many of the best behaviors in can-connect and hook it up to\na [can.Map](http://canjs.com/docs/can.Map.html).\n",
    "type": "module",
    "title": "can/super-map",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect/can/super-map",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "superMap(options)",
        "description": "\n\n  Creates a connection with the following behaviors: [can-connect/constructor/constructor],\n  [can-connect/can/map/map],\n  [can-connect/constructor/store/store],\n  [can-connect/data/callbacks/callbacks],\n  [can-connect/data/callbacks-cache/callbacks-cache],\n  [can-connect/data/combine-requests/combine-requests],\n  [can-connect/data/inline-cache/inline-cache],\n  [can-connect/data/parse/parse],\n  [can-connect/data/url/url],\n  [can-connect/real-time/real-time],\n  [can-connect/fall-through-cache/fall-through-cache],\n  [can-connect/constructor/callbacks-once].\n\n  And creates a [can-connect/data/localstorage-cache/localstorage-cache] to use as a [can-connect/base/base.cacheConnection].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/tag/tag": {
    "src": {
      "line": 0,
      "codeLine": 32,
      "path": "node_modules/can-connect/src/can/tag/tag.js"
    },
    "type": "module",
    "body": "\n## Use\n\n```\nconnect.tag(\"order-model\", connection);\n```\n\n```\n<order-model get-list=\"{type=orderType}\">\n  <ul>\n  \\{{#isPending}}<li>Loading</li>\\{{/isPending}}\n  \\{{#isResolved}}\n    \\{{#each value}}\n      <li>\\{{name}}</li>\n    \\{{/each}}\n  \\{{/isResolved}}\n  </ul>\n</order-model>\n```\n\n\n",
    "description": "\nMakes either getList or getInstance\n",
    "title": "",
    "name": "can-connect/can/tag/tag",
    "parent": "can-connect.modules",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "tagName",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "connection",
        "description": "\n"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "connection",
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/can/model/model": {
    "src": {
      "path": "node_modules/can-connect/src/can/model/model.md"
    },
    "body": "\n## Use\n\n`can-connect/can/model` is for backwards compatability\nwith [can.Model](http://canjs.com/docs/can.Model.html) so that developers can migrate\nto `can-connect` without having to rewrite their models immediately.\n\nHowever, use of `can.Model` will be deprecated in CanJS 3.0. Instead of extending `can.Model`,\nextend `can.Map` and `can.List` and use the [can-connect/can/map/map] behavior to connect your Map and List to a connection:\n\n```\nvar Todo = can.Map.extend({ ... });\n\nvar TodoList = can.List.extend({\n  Map: Todo\n},{ ... });\n\nvar todoConnection = connect([\"data-url\",\"constructor\",\"can/map\"],{\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\"\n});\n```\n\nOr, use the [can-connect/can/super-map/super-map] function to create a connection with the \"standard\" behaviors:\n\n```\nvar todoConnection = superMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nFor your legacy code, you should just need to import \"can-connect/can/model/\" instead of \"can/model/\" like:\n\n```\nimport Model from \"can-connect/can/model/\";\n\nTodo = Model.extend({\n  findAll: \"/todos\"\n},{});\n\nTodo.findAll({}).then(function(todos){\n\n});\n```\n\n## Upgrading can.Models to can-connect\n\nThis section walks through making the necessary changes to upgrade a legacy can.Model to use `can-connect` and its\nbehaviors.  We'll convert a `can.Model` and `can.Model.List` that looks like:\n\n```\nTodo = can.Model.extend({\n  resource: \"/\",\n  destroy: \"POST /todos/{id}/delete\",\n  findOne: function(params){\n    return $.get(\"/todos/\"+params._id);\n  },\n\n  parseModels: function(data){\n    return data.todos;\n  },\n  parseModel: \"todo\",\n\n  id: \"_id\",\n},{\n  method: function(){ ... },\n  define: { ... }\n});\n\nTodo.List = Todo.List.extend({ ... });\n```\n\nConverting this to use `can-connect` looks like:\n\n```\nTodo = can.Map.extend({\n  method: function(){ ... },\n  define: { ... }\n});\nTodo.List = can.List.extend({\n  Map: Todo\n},{ ... })\n\nconnect([\"data-url\",\"data-parse\",\n        \"constructor\",\"constructor-store\",\n        \"can-map\"],\n  {\n    Map: Todo,\n    List: Todo.List,\n\n    url: {\n      resource: \"/\",\n      destroyData: \"POST /todos/{id}/delete\",\n      getData: function(params){\n        return $.get(\"/todos/\"+params._id);\n      }\n    },\n\n    parseListData: function(data){\n      return data.todos;\n    },\n    parseInstanceProp: \"todo\",\n\n    idProp: \"_id\"\n  });\n```\n\nInstead of `Todo.findAll` and `Todo.findOne`, use `Todo.getList` and `Todo.get`.\n\nLets break this down in the following sections.\n\n### Defining the Map and List\n\nThe first step is to pull out the parts of the Model and Model.List that define the\nobservable Map and List's behavior into a `can.Map` and `can.List`:\n\n```\nTodo = can.Map.extend({\n  method: function(){ ... },\n  define: { ... }\n});\nTodo.List = can.List.extend({\n  Map: Todo\n},{ ... })\n```\n\nOne of the main advantegous of `can-connect` is that it lets seperate persistence behavior\nfrom property behavior.\n\n### Connecting the Map and List to behaviors\n\nThe next step is to connect the Map and List to the right behaviors.  The following\nadds behaviors with similar functionality to legacy `can.Map` and uses the [can-connect/can/map/map] behavior\n(which makes use of [can-connect/constructor/constructor]) to connect the connection to the provided Map and List types:\n\n```\nconnect([\"data-url\",\"data-parse\",\n        \"constructor\",\"constructor-store\",\n        \"can-map\"],\n  {\n    Map: Todo,\n    List: Todo.List,\n    ...\n  })\n```\n\n### Connecting to urls\n\nThe [can-connect/data/url/url] behavior supports CRUDing data from urls.  It can be configured like:\n\n```\nconnect([\"data-url\", ...],\n  {\n    ...\n    url: {\n      resource: \"/\",\n      destroyData: \"POST /todos/{id}/delete\",\n      getData: function(params){\n        return $.get(\"/todos/\"+params._id);\n      }\n    },\n    ...\n  });\n```\n\n### Correcting response data\n\nThe [can-connect/data/parse/parse] behavior supports correcting response data.  It can be configured like:\n\n```\nconnect([..., \"data-parse\", ...],\n  {\n    ...\n    parseListData: function(data){\n      return data.todos;\n    },\n    parseInstanceProp: \"todo\",\n    ...\n  });\n```\n\n### Specifying the id\n\nThe id of a model is used in a variety of ways.  It's part of the [can-connect/base/base] behavior\nadded to every connection.  You can customize which property represents the id with [can-connect/base/base.idProp].\n\n```\nconnect([...],\n  {\n    idProp: \"_id\"\n  });\n```\n\n### Retrieving data\n\nThe [can-connect/can/map/map] behavior adds a `getList` and `get` method to the `Map` option.  Use them in\nplace of `findAll` and `findOne`:\n\n```\nTodo.findAll({}).then(function(todosList){ ... });\nTodo.findOne({id: 5}).then(function(todo){ ... });\n```\n\n## Differences from can.Model\n\nModel's produced from `can-connect/can/model`:\n\n - Do not support `makeFindAll` or `makeFindOne`.  If your legacy code did this, you can probably add it as a custom behavior.\n - Has the instance store at `Model.store`, but items should be retrieved like `Model.store.get(id)`.\n - Should not use `Model.models` or `Model.model` to correct Ajax data and should instead use `Models.parseModel` and `Model.parseModels`.\n - Uses a Promise polyfill, not jQuery's promises.\n\n",
    "description": "Exports a constructor that works very similar to [can.Model](http://canjs.com/docs/can.Model.html). \n",
    "type": "module",
    "title": "",
    "name": "can-connect/can/model/model",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "Model.extend( static, prototype )",
        "description": "\n\n\tDefines a [map](http://canjs.com/docs/can.Map.html) that has almost all of the functionality of\n\t[can.Model](http://canjs.com/docs/can.Model.html).\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/constructor/callbacks-once": {
    "name": "can-connect/constructor/callbacks-once",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 14,
      "path": "node_modules/can-connect/src/constructor/callbacks-once/callbacks-once.js"
    },
    "body": "\n",
    "description": "\nPrevents unecessary calls to the instance callback methods.\n",
    "title": "",
    "signatures": [
      {
        "code": "constructorCallbacksOnce(baseBehavior)",
        "description": "\n\n  Prevents duplicate calls to the instance callback methods by tracking\n  the last data the methods were called with.  If called with the\n  same data again, it does not call the base behavior's instance callback.\n\n\n",
        "params": []
      }
    ]
  },
  "can-connect/constructor/callbacks-once.createdData": {
    "src": {
      "line": 20,
      "codeLine": 28,
      "path": "node_modules/can-connect/src/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.createData]. The result of this function will be used\nas the new response data.\n",
    "title": "createdData",
    "name": "can-connect/constructor/callbacks-once.createdData",
    "parent": "can-connect/constructor/callbacks-once"
  },
  "can-connect/constructor/callbacks-once.updatedData": {
    "src": {
      "line": 29,
      "codeLine": 37,
      "path": "node_modules/can-connect/src/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.updateData]. The result of this function will be used\nas the new response data.\n",
    "title": "updatedData",
    "name": "can-connect/constructor/callbacks-once.updatedData",
    "parent": "can-connect/constructor/callbacks-once"
  },
  "can-connect/constructor/callbacks-once.destroyedData": {
    "src": {
      "line": 38,
      "codeLine": 46,
      "path": "node_modules/can-connect/src/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.destroyData]. The result of this function will be used\nas the new response data.\n",
    "title": "destroyedData",
    "name": "can-connect/constructor/callbacks-once.destroyedData",
    "parent": "can-connect/constructor/callbacks-once"
  },
  "can-connect/data/callbacks/callbacks": {
    "name": "can-connect/data/callbacks/callbacks",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 10,
      "path": "node_modules/can-connect/src/data/callbacks/callbacks.js"
    },
    "body": "\n\n\n",
    "description": "\nGlues the result of the raw `Data Interface` methods to callbacks. This is\nuseful if you want something to happen with raw data anytime raw data is requested\nor manipulated.\n",
    "title": ""
  },
  "can-connect/data/callbacks/callbacks.gotListData": {
    "name": "can-connect/data/callbacks/callbacks.gotListData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 15,
      "codeLine": 23,
      "path": "node_modules/can-connect/src/data/callbacks/callbacks.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.getListData]. The result of this function will be used\nas the new response data.\n",
    "title": "gotListData"
  },
  "can-connect/data/callbacks/callbacks.createdData": {
    "name": "can-connect/data/callbacks/callbacks.createdData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 25,
      "codeLine": 33,
      "path": "node_modules/can-connect/src/data/callbacks/callbacks.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.createData]. The result of this function will be used\nas the new response data.\n",
    "title": "createdData"
  },
  "can-connect/data/callbacks/callbacks.updatedData": {
    "name": "can-connect/data/callbacks/callbacks.updatedData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 34,
      "codeLine": 42,
      "path": "node_modules/can-connect/src/data/callbacks/callbacks.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.updateData]. The result of this function will be used\nas the new response data.\n",
    "title": "updatedData"
  },
  "can-connect/data/callbacks/callbacks.destroyedData": {
    "name": "can-connect/data/callbacks/callbacks.destroyedData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 43,
      "codeLine": 51,
      "path": "node_modules/can-connect/src/data/callbacks/callbacks.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.destroyData]. The result of this function will be used\nas the new response data.\n",
    "title": "destroyedData"
  },
  "can-connect/constructor/store/store.stores": {
    "name": "can-connect/constructor/store/store.stores",
    "title": "Stores",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 0
  },
  "can-connect/constructor/store/store.crud": {
    "name": "can-connect/constructor/store/store.crud",
    "title": "CRUD Methods",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 1
  },
  "can-connect/constructor/store/store.hydrators": {
    "name": "can-connect/constructor/store/store.hydrators",
    "title": "Hydrators",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 2
  },
  "can-connect/constructor/store/store": {
    "name": "can-connect/constructor/store/store",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 80,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe `constructor-store` extension is used to:\n - provide a store of instances and lists used by the client.\n - prevent multiple instances from being hydrated for the same [can-connect/base/base.id] or multiple\n   lists for the same [can-connect/base/base.listSet].\n\nThe stores provide access to an instance\nby its [can-connect/base/base.id] or a list by its [can-connect/base/base.listSet]. These stores are\nused by other extensions like [can-connect/real-time/real-time] and [can-connect/fall-through-cache/fall-through-cache].\n\nLets see how `constructor-store`'s behavior be used to prevent multiple\ninstances from being hydrated.  This example allows you to create multiple instances of a `todoEditor` that loads\nand edits a todo instance.\n\n<div class='demo_wrapper' data-demo-src='can-connect/src/constructor/store/store.html'></div>\n\nYou'll notice that you can edit one todo's name and the other\ntodo editors update.  This is because each `todoEditor` gets the same instance in memory.  So that when it\nupdates the todo's name ...\n\n```\nelement.firstChild.onchange = function(){\n  todo.name = this.value;\n};\n```\n\n... the other widgets update because they have bound on the same instance:\n\n```\nObject.observe(todo, update, [\"update\"] );\ntodosConnection.addInstanceReference(todo);\n```\n\nEach `todoEditor` gets the same instance because they called [can-connect/constructor/store/store.addListReference]\nwhich makes it so anytime a todo with `id=5` is requested, the same instance is returned.\n\nNotice that if you change an input element, and click \"Create Todo Editor\", all the `todoEditor`\nwidgets are set back to the old text.  This is because whenever data is loaded from the server,\nit is passed to [can-connect/constructor.updatedInstance] which defaults to overwriting any current\nproperties with those from the server.\n\nTo make sure the server has the latest, you can save a todo by hitting \"ENTER\".\n\nFinally, this widget cleans itself up nicely when it is removed by unobserving the\n`todo` instance and\n[can-connect/constructor/store/store.deleteInstanceReference deleting the instance reference]. Doing this\nprevents memory leaks.\n\n```\nObject.unobserve(todo, update, [\"update\"] );\ntodosConnection.deleteInstanceReference(todo);\n```\n\n\n\n\n",
    "description": "\nSupports saving and retrieving lists and instances in a store.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructorStore(baseConnection)",
        "description": "\n\n  Overwrites baseConnection so it contains a store for\n  instances and lists.  It traps calls to the\n  [can-connect/constructor/store/store.hydrateInstance] and\n  [can-connect/constructor/store/store.hydrateList] methods to\n  use instances or lists in the store if available. It\n  overwrites \"CRUD METHODS\" to make sure that while any request\n  is pending, all lists and instances are added to the store.\n  Finally, it provides methods to add and remove items in the\n  store via reference counting.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/constructor/store/store.instanceStore": {
    "name": "can-connect/constructor/store/store.instanceStore",
    "type": "property",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 87,
      "codeLine": 93,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\t \n",
    "description": "\nA store of instances mapped by [can-connect/base/base.id].\n",
    "types": [
      {
        "type": "WeakReferenceMap"
      }
    ],
    "title": "instanceStore"
  },
  "can-connect/constructor/store/store.listStore": {
    "name": "can-connect/constructor/store/store.listStore",
    "type": "property",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 94,
      "codeLine": 99,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\t \n",
    "description": "A store of lists mapped by [can-connect/base/base.listSet].\n",
    "types": [
      {
        "type": "WeakReferenceMap"
      }
    ],
    "title": "listStore"
  },
  "can-connect/constructor/store/store.addInstanceReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.addInstanceReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 117,
      "codeLine": 181,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe [can-connect/constructor/store/store.instanceStore] contains a collection of instances\ncreated for each [can-connect/base/base.id]. The `instanceStore` is used to prevent creating the\nsame instance multiple times.  Instances need to be added to this store for this behavior\nto happen.  To do this, call `addInstanceReference` like the following:\n\n```\n// A basic connection:\nvar todoConnection = connect([\n  'constructor-store',\n  'constructor',\n  'data-url'],\n  {\n    url: \"/todos\"\n  });\n\nvar originalTodo;\n\n// Get a todo:\ntodoConnection.get({id: 5}).then(function( todo ){\n\n  // Add it to the store\n  todoConnection.addInstanceReference(todo);\n  originalTodo = todo;\n});\n```\n\nNow, if you were to retrieve the same data sometime later,\nit would be the same instance.\n\n```\ntodoConnection.get({id: 5}).then(function( todo ){\n\n  todo === originalTodo //-> true\n});\n```\n\nThe `.getData`  response data is passed with `originalTodo` to [can-connect/constructor.updatedInstance]\nwhich can update the `originalTodo` with the new data.\n\n\nAll these instances stay in memory.  Use [can-connect/constructor/store/store.deleteInstanceReference]\nto remove them.\n\nTypically, `addInstanceReference` is called when something expresses interest in the interest, such\nas an event binding, and `deleteInstanceReference` is called when interest is removed.\n\n\t \n",
    "description": "\nAdds a reference to an instance so it can be easily looked up.\n",
    "title": "addInstanceReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Adds a reference to an instance in the [can-connect/constructor/store/store.instanceStore] by [can-connect/base/base.id].\n  The number of references are incremented.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to add.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to add.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.deleteInstanceReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.deleteInstanceReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 201,
      "codeLine": 232,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\n`deleteInstanceReference` is called to remove references to instances in\nthe [can-connect/constructor/store/store.instanceStore] so the instances maybe garbage\ncollected.  It's usually called when the application or some part of the application no\nlonger is interested in an instance.\n\n[can-connect/constructor/store/store.addInstanceReference] has an example of adding\nan instance to the store.  The following continues that example to remove\nthe `originalTodo` from the store:\n\n```\ntodoConnection.deleteInstanceReference(originalTodo);\n```\n\n\t \n",
    "description": "\nRemoves a reference to an instance by [can-connect/base/base.id] so it can be garbage collected.\n",
    "title": "deleteInstanceReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Decrements the number of references to an instance in the [can-connect/constructor/store/store.instanceStore].\n  Removes the instance if there are no longer any references.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to remove.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to remove.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.addListReference": {
    "type": "property",
    "name": "can-connect/constructor/store/store.addListReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 235,
      "codeLine": 300,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe [can-connect/constructor/store/store.listStore] contains a collection of lists\ncreated for each [can-connect/base/base.listSet]. The `listStore` is used to prevent creating the\nsame list multiple times and for identifying a list for a given set. Lists need to be added to this store for this behavior\nto happen.  To do this, call `addListReference` like the following:\n\n```\n// A basic connection:\nvar todoConnection = connect([\n  'constructor-store',\n  'constructor',\n  'data-url'],\n  {\n    url: \"/todos\"\n  });\n\nvar dueToday;\n\n// Get a todo:\ntodoConnection.getList({due: \"today\"}).then(function( todos ){\n\n  // Add it to the store\n  todoConnection.addListReference(todos, {due: \"today\"});\n  dueToday = todos;\n});\n```\n\nNow, if you were to retrieve the same data sometime later,\nit would be the same list.\n\n```\ntodoConnection.get({due: \"today\"}).then(function( todos ){\n\n  todos === dueToday //-> true\n});\n```\n\nThe `.getListData`  response data is passed with `dueToday` to [can-connect/constructor.updatedList]\nwhich can update `dueToday` with the new data.\n\nAll these lists stay in memory.  Use [can-connect/constructor/store/store.deleteListReference]\nto remove them.\n\nTypically, `addListReference` is called when something expresses interest in the list, such\nas an event binding, and `deleteListReference` is called when interest is removed.\n\n\t \n",
    "description": "\nAdds a reference to a list so it can be easily looked up.\n",
    "types": [
      {
        "type": "WeakReferenceMap"
      }
    ],
    "title": "addListReference",
    "signatures": [
      {
        "code": "connection.addListReference( list[, set] )",
        "description": "\n\n  Adds a reference to a list in the [can-connect/constructor/store/store.listStore].  The number of\n  references are incremented.\n",
        "params": [
          {
            "types": [
              {
                "type": "List"
              }
            ],
            "name": "list",
            "description": "The list to add.\n"
          },
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "optional": true,
            "name": "set",
            "description": "The set this list represents if it can't be identified with [can-connect/base/base.listSet].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "optional": true,
      "name": "set",
      "description": "The set this list represents if it can't be identified with [can-connect/base/base.listSet].\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.deleteListReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.deleteListReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 306,
      "codeLine": 337,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\n`deleteListReference` is called to remove references to lists in\nthe [can-connect/constructor/store/store.listStore] so the lists maybe garbage\ncollected.  It's usually called when the application or some part of the application no\nlonger is interested in an list.\n\n[can-connect/constructor/store/store.addListReference] has an example of adding\na list to the store.  The following continues that example to remove\nthe `dueToday` from the store:\n\n```\ntodoConnection.deleteListReference(dueToday);\n```\n\n\t \n",
    "description": "\nRemoves a reference to a list by [can-connect/base/base.listSet] so it can be garbage collected.\n",
    "title": "deleteListReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Decrements the number of references to an list in the [can-connect/constructor/store/store.listStore].\n  Removes the list if there are no longer any references.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "list",
            "description": "The list to remove.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "name": "list",
      "description": "The list to remove.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.hydratedInstance": {
    "src": {
      "line": 343,
      "codeLine": 356,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nCalled whenever [can-connect/constructor/store/store.hydrateInstance] is called with the hydration result.\n",
    "title": "hydratedInstance",
    "name": "can-connect/constructor/store/store.hydratedInstance",
    "parent": "can-connect/constructor/store/store.hydrators",
    "signatures": [
      {
        "code": "hydratedInstance(instance)",
        "description": "\n\n  If there are pending requests, the instance is kept in the [can-connect/constructor/store/store.instanceStore].\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              }
            ],
            "name": "instance",
            "description": "The hydrated instance.\n\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "name": "instance",
      "description": "The hydrated instance.\n\n\t "
    }
  },
  "can-connect/constructor/store/store.hydrateInstance": {
    "src": {
      "line": 367,
      "codeLine": 382,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns a instance given raw data.\n",
    "title": "hydrateInstance",
    "name": "can-connect/constructor/store/store.hydrateInstance",
    "parent": "can-connect/constructor/store/store.hydrators",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  Overwrites the base `hydratedInstance` so that if a matching instance is\n  in the [can-connect/constructor/store/store.instanceStore], that instance will\n  be [can-connect/constructor.updatedInstance updated] with `props` and returned.\n  If there isn't a matching instance, the base `hydrateInstance` will be called.\n\n  No matter what, [can-connect/constructor/store/store.hydratedInstance] is called.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/constructor/store/store.hydratedList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.hydratedList",
    "parent": "can-connect/constructor/store/store.hydrators",
    "src": {
      "line": 395,
      "codeLine": 409,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nCalled whenever [can-connect/constructor/store/store.hydrateList] is called with the hydration result.\n",
    "title": "hydratedList",
    "signatures": [
      {
        "code": "hydratedList(list)",
        "description": "\n\n  If there are pending requests, the list is kept in the [can-connect/constructor/store/store.listStore].\n",
        "params": [
          {
            "types": [
              {
                "type": "List"
              }
            ],
            "name": "list",
            "description": "The hydrated list.\n\n\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "List"
        }
      ],
      "name": "list",
      "description": "The hydrated list.\n\n\n\t "
    }
  },
  "can-connect/constructor/store/store.hydrateList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.hydrateList",
    "parent": "can-connect/constructor/store/store.hydrators",
    "src": {
      "line": 422,
      "codeLine": 437,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nReturns a list given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList(props)",
        "description": "\n\n  Overwrites the base `hydrateList` so that if a matching list is\n  in the [can-connect/constructor/store/store.listStore], that list will\n  be [can-connect/constructor.updatedList updated] with `listData` and returned.\n  If there isn't a matching list, the base `hydrateList` will be called.\n\n  No matter what, [can-connect/constructor/store/store.hydratedList] is called.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/constructor/store/store.getList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.getList",
    "params": [
      {
        "name": "params",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 450,
      "codeLine": 459,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\n\t \n",
    "description": "\nOverwrites [can-connect/connection.getList] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] or [can-connect/constructor/store/store.hydrateList hydrated lists]\nare kept in the store until the response resolves.\n",
    "title": "getList"
  },
  "can-connect/constructor/store/store.get": {
    "type": "function",
    "name": "can-connect/constructor/store/store.get",
    "params": [
      {
        "name": "params",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 471,
      "codeLine": 479,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\t \n",
    "description": "\nOverwrites [can-connect/connection.get] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "get"
  },
  "can-connect/constructor/store/store.save": {
    "type": "function",
    "name": "can-connect/constructor/store/store.save",
    "params": [
      {
        "name": "instance",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 492,
      "codeLine": 501,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\n\t \n",
    "description": "\nOverwrites [can-connect/connection.save] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "save"
  },
  "can-connect/constructor/store/store.destroy": {
    "type": "function",
    "name": "can-connect/constructor/store/store.destroy",
    "params": [
      {
        "name": "instance",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 522,
      "codeLine": 530,
      "path": "node_modules/can-connect/src/constructor/store/store.js"
    },
    "body": "\t \n",
    "description": "\nOverwrites [can-connect/connection.destroy] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "destroy"
  },
  "can-connect/data/callbacks-cache/callbacks-cache": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 8,
      "path": "node_modules/can-connect/src/data/callbacks-cache/callbacks-cache.js"
    },
    "body": "\n",
    "description": "\nCalls [can-connect/base/base.cacheConnection] methods whenever\nthe [can-connect/data/callbacks data interface callbacks] are called. This is\nuseful for making sure a [can-connect/base/base.cacheConnection] is updated whenever data is updated.\n",
    "title": ""
  },
  "can-connect/data/callbacks-cache/callbacks-cache.createdData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.createdData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 14,
      "codeLine": 21,
      "path": "node_modules/can-connect/src/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.createData]. Calls `createData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "createdData"
  },
  "can-connect/data/callbacks-cache/callbacks-cache.updatedData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.updatedData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 22,
      "codeLine": 29,
      "path": "node_modules/can-connect/src/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.updateData]. Calls `updateData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "updatedData"
  },
  "can-connect/data/callbacks-cache/callbacks-cache.destroyedData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.destroyedData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 30,
      "codeLine": 37,
      "path": "node_modules/can-connect/src/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.destroyData]. Calls `destroyData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "destroyedData"
  },
  "can-connect/data/combine-requests.data-methods": {
    "name": "can-connect/data/combine-requests.data-methods",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.options": {
    "name": "can-connect/data/combine-requests.options",
    "title": "Options",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.algebra": {
    "name": "can-connect/data/combine-requests.algebra",
    "title": "Algebra Methods",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.types": {
    "name": "can-connect/data/combine-requests.types",
    "title": "Types",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests/combine-requests": {
    "type": "module",
    "name": "can-connect/data/combine-requests/combine-requests",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 7,
      "codeLine": 69,
      "path": "node_modules/can-connect/src/data/combine-requests/combine-requests.js"
    },
    "body": "\n\n## Use\n\nCreate a connection with the `data-combine-requests` plugin like:\n\n```\nvar todosConnection = connect([\"data-combine-requests\",\"data-url\"],{\n  url: \"/todos\"\n});\n```\n\nBy default, the following will only make a single request if made at the same time:\n\n```\ntodosConnection.getListData({})\ntodosConnection.getListData({userId: 5});\ntodosConnection.getListData({userId: 5, type: \"critical\"});\n```\n\nThis is because [can-set](https://github.com/canjs/can-set) knows that\n`{userId: 5, type: \"critical\"}` and `{userId: 5}` are subsets of `{}`.\n\nFor more advanced combining, use set algebra.  The following supports\ncombining ranges:\n\n```\nvar todosConnection = connect([\"data-combine-requests\",\"data-url\"],{\n  url: \"/todos\",\n  algebra: new Algebra(set.comparators.range(\"start\",\"end\"))\n});\n```\n\nNow the following will make single request:\n\n```\ntodosConnection.getListData({start: 0, end: 49})\ntodosConnection.getListData({start: 0, end: 5});\ntodosConnection.getListData({start: 50, end: 99});\n```\n\n\n",
    "description": "\nCombines multiple incoming requests into one if possible.\n",
    "title": "",
    "signatures": [
      {
        "code": "dataCombineRequests(baseConnection)",
        "description": "\n\n  Overwrites [can-connect/data/combine-requests.getListData] to collect the requested\n  sets for\n  some [can-connect/data/combine-requests.time].  Once that time has expired, it tries\n  to take the [can-connect/data/combine-requests.unionPendingRequests union] of those sets. It\n  makes requests with those unioned sets. Once the unioned set data has returned,\n  the original requests re satisified by getting\n  [can-connect/data/combine-requests.getSubset subsets] of the unioned set data.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/combine-requests.unionPendingRequests": {
    "type": "function",
    "name": "can-connect/data/combine-requests.unionPendingRequests",
    "parent": "can-connect/data/combine-requests.algebra",
    "src": {
      "line": 73,
      "codeLine": 121,
      "path": "node_modules/can-connect/src/data/combine-requests/combine-requests.js"
    },
    "body": "\n## Use\n\nThis function gets called automatically.  However, it converts something like:\n\n```\n[\n  {set: {completed: false}, deferred: def1},\n  {set: {completed: true}, deferred: def2}\n]\n```\n\nto\n\n```\n[\n  {\n   set: {},\n   pendingRequests: [\n     {set: {completed: false}, deferred: def1},\n     {set: {completed: true}, deferred: def2}\n   ]\n  }\n]\n```\n\n\t \n",
    "description": "\n",
    "title": "unionPendingRequests",
    "signatures": [
      {
        "code": "connection.unionPendingRequests( pendingRequests )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-connect/data/combine-requests.PendingRequest"
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "\n\nAn array of objects, each containing:\n\n- `set` - the requested set\n- `deferred` - a deferred that will be resolved with this sets data\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": [
                        {
                          "name": "set",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        },
                        {
                          "name": "pendingRequests",
                          "types": [
                            {
                              "type": "can-connect/data/combine-requests.PendingRequest"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\nReturns an array of each of the unioned requests to be made.  Each unionized request should have:\n\n- `set` - the set to request\n- `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the set satisfies.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/data/combine-requests.PendingRequest"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\nAn array of objects, each containing:\n\n- `set` - the requested set\n- `deferred` - a deferred that will be resolved with this sets data\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": [
                    {
                      "name": "set",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    },
                    {
                      "name": "pendingRequests",
                      "types": [
                        {
                          "type": "can-connect/data/combine-requests.PendingRequest"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\nReturns an array of each of the unioned requests to be made.  Each unionized request should have:\n\n- `set` - the set to request\n- `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the set satisfies.\n"
    },
    "comment": " "
  },
  "can-connect/data/combine-requests.getSubset": {
    "type": "function",
    "name": "can-connect/data/combine-requests.getSubset",
    "parent": "can-connect/data/combine-requests.algebra",
    "src": {
      "line": 169,
      "codeLine": 184,
      "path": "node_modules/can-connect/src/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nReturn the items that belong to an initial request.\n",
    "title": "getSubset",
    "signatures": [
      {
        "code": "connection.getSubset( set, unionSet, data )",
        "description": "\n\n  This implementation uses [can-set's getSubset](https://github.com/canjs/can-set#setgetsubset) with [can-connect/base/base.algebra].\n",
        "params": [
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": "the subset initially requested"
          },
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "unionSet",
            "description": "the combined set that was actually requested"
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "data",
            "description": "the data from the combined set"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "the data that belongs to `set`\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "name": "data",
      "description": "the data from the combined set"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "the data that belongs to `set`\n\t "
    }
  },
  "can-connect/data/combine-requests.time": {
    "name": "can-connect/data/combine-requests.time",
    "type": "property",
    "parent": "can-connect/data/combine-requests.options",
    "src": {
      "line": 187,
      "codeLine": 196,
      "path": "node_modules/can-connect/src/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nSpecifies the amount of time to wait to combine requests.\n",
    "types": [
      {
        "type": "Number",
        "description": "Defaults to `1` which means that only requests made within the same\n\"thread of execution\" will be combined.\n\t "
      }
    ],
    "title": "time"
  },
  "can-connect/data/combine-requests.getListData": {
    "type": "function",
    "name": "can-connect/data/combine-requests.getListData",
    "parent": "can-connect/data/combine-requests.data-methods",
    "src": {
      "line": 197,
      "codeLine": 214,
      "path": "node_modules/can-connect/src/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nTries to combine requests using set logic.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData( set )",
        "description": "\n\n  Collects the sets for calls to `getListData` for\n  some [can-connect/data/combine-requests.time].  Once that time has expired, it tries\n  to take the [union](https://github.com/canjs/can-set#setunion) of those sets. It\n  makes requests with those unioned sets. Once the unioned set data has returned,\n  the original requests re satisified by taking\n  [subsets](https://github.com/canjs/can-set#setgetSubset) of the unioned set data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "set",
            "description": "\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "set",
      "description": "\n\t "
    }
  },
  "can-connect/data/combine-requests.PendingRequest": {
    "src": {
      "line": 263,
      "codeLine": 270,
      "path": "node_modules/can-connect/src/data/combine-requests/combine-requests.js"
    },
    "type": "typedef",
    "body": "",
    "description": "\n",
    "title": "PendingRequest",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "set",
            "types": [
              {
                "type": "Set"
              }
            ],
            "description": "A [can-set](https://github.com/canjs/can-set) set object."
          },
          {
            "name": "deferred",
            "types": [
              {
                "type": "Deferred"
              }
            ],
            "description": "A defferred that can be used to resolve or reject a promise.\n"
          }
        ]
      }
    ],
    "name": "can-connect/data/combine-requests.PendingRequest",
    "parent": "can-connect/data/combine-requests.types"
  },
  "can-connect/data/inline-cache/inline-cache.data-methods": {
    "name": "can-connect/data/inline-cache/inline-cache.data-methods",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/inline-cache/inline-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/inline-cache/inline-cache.globals": {
    "name": "can-connect/data/inline-cache/inline-cache.globals",
    "title": "Globals",
    "type": "group",
    "parent": "can-connect/data/inline-cache/inline-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/inline-cache/inline-cache": {
    "type": "module",
    "name": "can-connect/data/inline-cache/inline-cache",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 3,
      "codeLine": 53,
      "path": "node_modules/can-connect/src/data/inline-cache/inline-cache.js"
    },
    "body": "\n\n## Use\n\nCreate a connection with `data-inline-cache` and a [connection.name].\n\n```\nvar todosConnection = connect([\"data-inline-cache\",\"data-url\"],{\n  url: \"/api/todos\",\n  name: \"todos\"\n})\n```\n\nMake the page respond with an `INLINE_CACHE` that contains the name of the\nconnection and a mapping of ids or sets to the response data:\n\n```\n<script>\nINLINE_CACHE = {\n  \"todos\": {\n    1: {id: 1, name: \"dishes\"},\n    \"{\\\"completed\\\": true}\": {data: [{...},{...}]}\n  }\n}\n</script>\n```\n\nNow, the first time the following requests are made, the cached data will be used:\n\n```\ntodosConnection.get({id: 1})\ntodosConnection.getList({completed: true})\n```\n\n\n\n",
    "description": "\nUse data embedded in the page response instead of making a request.\n",
    "title": "",
    "signatures": [
      {
        "code": "dataInlineCache( baseBehavior )",
        "description": "\n\n  Makes requests look for their data in a\n  [can-connect/data/inline-cache/inline-cache.INLINE_CACHE] object.  If it is found,\n  that entry in the cache is deleted so future requests will pass through.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/inline-cache/inline-cache.INLINE_CACHE": {
    "name": "can-connect/data/inline-cache/inline-cache.INLINE_CACHE",
    "type": "property",
    "parent": "can-connect/data/inline-cache/inline-cache.globals",
    "src": {
      "line": 55,
      "codeLine": 70,
      "path": "node_modules/can-connect/src/data/inline-cache/inline-cache.js"
    },
    "body": "\n",
    "description": "\nContains response data for requests that should not be made.\n",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n  A mapping of a [connection.name] to an Object that contains the\n  cached data for that connection.  That inner object is a mapping\n  between either [can-connect/base/base.id ids] or [can-connect/base/base.listSet serialized sets] to\n  response data for those requests.\n\n\n ",
        "template": [
          {
            "types": [
              {
                "type": "connection.name"
              }
            ]
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "id"
                      },
                      {
                        "type": "Set"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can-connect.listData"
                      },
                      {
                        "type": "props"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "title": "INLINE_CACHE"
  },
  "can-connect/data/inline-cache/inline-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/inline-cache/inline-cache.getListData",
    "parent": "can-connect/data/inline-cache/inline-cache.data-methods",
    "src": {
      "line": 88,
      "codeLine": 106,
      "path": "node_modules/can-connect/src/data/inline-cache/inline-cache.js"
    },
    "body": "\n",
    "description": "\nUses data in [can-connect/data/inline-cache/inline-cache.INLINE_CACHE] if available.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData( set )",
        "description": "\n\n  Looks if there is a key in [can-connect/data/inline-cache/inline-cache.INLINE_CACHE]\n  that matches `set`.  If there is, it uses that key's value for the\n  response data and deletes that key so it can not be reused.\n\n  If there is no matching `key`, the base `getListData` is used.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "set",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "set",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/data/inline-cache/inline-cache.getData": {
    "type": "function",
    "name": "can-connect/data/inline-cache/inline-cache.getData",
    "parent": "can-connect/data/inline-cache/inline-cache.data-methods",
    "src": {
      "line": 119,
      "codeLine": 137,
      "path": "node_modules/can-connect/src/data/inline-cache/inline-cache.js"
    },
    "body": "\n",
    "description": "\nUses data in [can-connect/data/inline-cache/inline-cache.INLINE_CACHE] if available.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getListData( set )",
        "description": "\n\n  Looks if there is a key in [can-connect/data/inline-cache/inline-cache.INLINE_CACHE]\n  that matches the [can-connect/base/base.id] of `params`.  If there is, it uses that key's value for the\n  response data and deletes that key so it can not be reused.\n\n  If there is no matching `key`, the base `getData` is used.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "props"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "props"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.identifiers": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache.identifiers",
    "title": "Indentifiers",
    "type": "group",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/localstorage-cache/localstorage-cache.data-methods": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache",
    "description": "",
    "order": 1
  },
  "can-connect/data/localstorage-cache/localstorage-cache": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 41,
      "path": "node_modules/can-connect/src/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n\n## Use\n\n`data-localstorage-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n[can-connect/cache-requests/cache-requests].  Make sure you configure the connection's [can-connect/data/localstorage-cache/localstorage-cache.name].\n\n```\nvar cacheConnection = connect([\"data-localstorage-cache\"],{\n  name: \"todos\"\n});\n\nvar todoConnection = connect([\"data-url\",\"fall-through-cache\"],{\n  url: \"/services/todos\",\n  cacheConnection: cacheConnection\n});\n```\n\n\n",
    "description": "\nSaves raw data in localStorage.\n",
    "title": "",
    "signatures": [
      {
        "code": "localStorage( baseConnection )",
        "description": "\n\n  Creates a cache of instances and a cache of sets of instances that is\n  accessible to read via [can-connect/data/localstorage-cache/localstorage-cache.getSets],\n  [can-connect/data/localstorage-cache/localstorage-cache.getData], and [can-connect/data/localstorage-cache/localstorage-cache.getListData].\n  The caches are updated via [can-connect/data/localstorage-cache/localstorage-cache.createData],\n  [can-connect/data/localstorage-cache/localstorage-cache.updateData], [can-connect/data/localstorage-cache/localstorage-cache.destroyData],\n  and [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n\n  [can-connect/data/localstorage-cache/localstorage-cache.createData],\n  [can-connect/data/localstorage-cache/localstorage-cache.updateData],\n  [can-connect/data/localstorage-cache/localstorage-cache.destroyData] are able to move items in and out\n  of sets.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.name": {
    "src": {
      "line": 202,
      "codeLine": 224,
      "path": "node_modules/can-connect/src/data/localstorage-cache/localstorage-cache.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```\nvar cacheConnection = connect([\"data-localstorage-cache\"],{\n  name: \"todos\"\n});\n```\n\t \n",
    "description": "\nSpecify a name to use when saving data in localstorage.\n",
    "types": [
      {
        "type": "String",
        "description": "This name is used to find and save data in\nlocalstorage. Instances are saved in `{name}/instance/{id}`\nand sets are saved in `{name}/set/{set}`.\n"
      }
    ],
    "title": "name",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.name",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.identifiers",
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.clear": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.clear",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 226,
      "codeLine": 235,
      "path": "node_modules/can-connect/src/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nResets the memory cache so it contains nothing.\n",
    "title": "clear",
    "signatures": [
      {
        "code": "connection.clear()",
        "description": "\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getSets": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getSets",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 260,
      "codeLine": 281,
      "path": "node_modules/can-connect/src/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n\n## Use\n\n```\nconnection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n```\n\n\t \n",
    "description": "\nReturns the sets contained within the cache.\n",
    "title": "getSets",
    "signatures": [
      {
        "code": "connection.getSets(set)",
        "description": "\n\n  Returns the sets added by [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the list of sets.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the list of sets.\n"
    },
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getListData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 284,
      "codeLine": 301,
      "path": "node_modules/can-connect/src/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nGets a set of data from localstorage.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Goes through each set add by [can-connect/data/memory-cache.updateListData]. If\n  `set` is a subset, uses [can-connect/base/base.algebra] to get the data for the requested `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": "An object that represents the data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "name": "set",
      "description": "An object that represents the data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 315,
      "codeLine": 331,
      "path": "node_modules/can-connect/src/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nGet an instance's data from localstorage.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Looks in localstorage for the requested instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A promise that resolves to the item if the memory cache has this item.\nIf localstorage does not have this item, it rejects the promise.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A promise that resolves to the item if the memory cache has this item.\nIf localstorage does not have this item, it rejects the promise.\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.updateListData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.updateListData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 341,
      "codeLine": 356,
      "path": "node_modules/can-connect/src/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nSaves a set of data in the cache.\n",
    "title": "updateListData",
    "signatures": [
      {
        "code": "connection.updateListData(listData, set)",
        "description": "\n\n  Tries to merge this set of data with any other saved sets of data. If\n  unable to merge this data, saves the set by itself.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Promise resolves if and when the data has been successfully saved.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Promise resolves if and when the data has been successfully saved.\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.createData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.createData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 378,
      "codeLine": 389,
      "path": "node_modules/can-connect/src/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is created and should be added to cache.\n",
    "title": "createData",
    "signatures": [
      {
        "code": "connection.createData(props)",
        "description": "\n\n  Adds `props` to the stored list of instances. Then, goes\n  through every set and adds props the sets it belongs to.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.updateData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.updateData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 401,
      "codeLine": 412,
      "path": "node_modules/can-connect/src/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is updated.\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "connection.updateData(props)",
        "description": "\n\n  Overwrites the stored instance with the new props. Then, goes\n  through every set and adds or removes the instance if it belongs or not.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.destroyData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.destroyData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 444,
      "codeLine": 455,
      "path": "node_modules/can-connect/src/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance should be removed from the cache.\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "connection.destroyData(props)",
        "description": "\n\n  Goes through each set of data and removes any data that matches\n  `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.data-methods": {
    "name": "can-connect/data/memory-cache/memory-cache.data-methods",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/memory-cache/memory-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/memory-cache/memory-cache": {
    "name": "can-connect/data/memory-cache/memory-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 30,
      "path": "node_modules/can-connect/src/data/memory-cache/memory-cache.js"
    },
    "body": "\n\n## Use\n\n`data-memory-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n[can-connect/cache-requests/cache-requests].\n\n\n\n",
    "description": "\nSaves raw data in JavaScript memory that disappears when the page refreshes.\n",
    "title": "",
    "signatures": [
      {
        "code": "memoryCache( baseConnection )",
        "description": "\n\n  Creates a cache of instances and a cache of sets of instances that is\n  accessible to read via [can-connect/data/memory-cache/memory-cache.getSets],\n  [can-connect/data/memory-cache/memory-cache.getData], and [can-connect/data/memory-cache/memory-cache.getListData].\n  The caches are updated via [can-connect/data/memory-cache/memory-cache.createData],\n  [can-connect/data/memory-cache/memory-cache.updateData], [can-connect/data/memory-cache/memory-cache.destroyData],\n  and [can-connect/data/memory-cache/memory-cache.updateListData].\n\n  [can-connect/data/memory-cache/memory-cache.createData],\n  [can-connect/data/memory-cache/memory-cache.updateData],\n  [can-connect/data/memory-cache/memory-cache.destroyData] are able to move items in and out\n  of sets.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/memory-cache/memory-cache.getSets": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getSets",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 149,
      "codeLine": 170,
      "path": "node_modules/can-connect/src/data/memory-cache/memory-cache.js"
    },
    "body": "\n\n## Use\n\n```\nconnection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n```\n\n\t \n",
    "description": "\nReturns the sets contained within the cache.\n",
    "title": "getSets",
    "signatures": [
      {
        "code": "connection.getSets(set)",
        "description": "\n\n  Returns the sets added by [can-connect/data/memory-cache/memory-cache.updateListData].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the list of sets.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the list of sets.\n"
    },
    "comment": " "
  },
  "can-connect/data/memory-cache/memory-cache.clear": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.clear",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 175,
      "codeLine": 184,
      "path": "node_modules/can-connect/src/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nResets the memory cache so it contains nothing.\n",
    "title": "clear",
    "signatures": [
      {
        "code": "connection.clear()",
        "description": "\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getListData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 188,
      "codeLine": 205,
      "path": "node_modules/can-connect/src/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nGets a set of data from the memory cache.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Goes through each set add by [can-connect/data/memory-cache/memory-cache.updateListData]. If\n  `set` is a subset, uses [can-connect/base/base.algebra] to get the data for the requested `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": "An object that represents the data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "name": "set",
      "description": "An object that represents the data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.updateListData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.updateListData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 226,
      "codeLine": 241,
      "path": "node_modules/can-connect/src/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nSaves a set of data in the cache.\n",
    "title": "updateListData",
    "signatures": [
      {
        "code": "connection.updateListData(listData, set)",
        "description": "\n\n  Tries to merge this set of data with any other saved sets of data. If\n  unable to merge this data, saves the set by itself.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Promise resolves if and when the data has been successfully saved.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Promise resolves if and when the data has been successfully saved.\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.getData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 265,
      "codeLine": 281,
      "path": "node_modules/can-connect/src/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nGet an instance's data from the memory cache.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Looks in the instance store for the requested instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A promise that resolves to the item if the memory cache has this item.\nIf the memory cache does not have this item, it rejects the promise.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A promise that resolves to the item if the memory cache has this item.\nIf the memory cache does not have this item, it rejects the promise.\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.createData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.createData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 293,
      "codeLine": 304,
      "path": "node_modules/can-connect/src/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is created and should be added to cache.\n",
    "title": "createData",
    "signatures": [
      {
        "code": "connection.createData(props)",
        "description": "\n\n  Adds `props` to the stored list of instances. Then, goes\n  through every set and adds props the sets it belongs to.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.updateData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.updateData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 317,
      "codeLine": 328,
      "path": "node_modules/can-connect/src/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is updated.\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "connection.updateData(props)",
        "description": "\n\n  Overwrites the stored instance with the new props. Then, goes\n  through every set and adds or removes the instance if it belongs or not.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.destroyData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.destroyData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 362,
      "codeLine": 373,
      "path": "node_modules/can-connect/src/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance should be removed from the cache.\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "connection.destroyData(props)",
        "description": "\n\n  Goes through each set of data and removes any data that matches\n  `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/parse/parse": {
    "name": "can-connect/data/parse/parse",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 51,
      "path": "node_modules/can-connect/src/data/parse/parse.js"
    },
    "body": "\n\n## Use\n\n`data-parse` is used to modify the response data of \"data interface\" methods to comply with what\nis expected by \"instance interface\" methods.  For example, if a service was returning list data\nat the `/services/todos` url like:\n\n```\n{\n  todos: [\n    {todo: {id: 0, name: \"dishes\"}},\n    {todo: {id: 2, name: \"lawn\"}}\n  ]\n}\n```\n\nThat service does not return [can-connect.listData] in the right format which should look like:\n\n```\n{\n  data: [\n    {id: 0, name: \"dishes\"},\n    {id: 2, name: \"lawn\"}\n  ]\n}\n```\n\nTo correct this, you can configure `data-parse` to use the [connection.parseListProp] and [connection.parseInstanceProp]\nas follows:\n\n```\nconnect([\"data-parse\",\"data-url\"],{\n parseListProp: \"todos\",\n parseInstanceProp: \"todo\"\n})\n```\n\n\n",
    "description": "\nExtract response data into a format needed for other extensions.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "dataParse(baseConnection)",
        "description": "\n\n  Adds the data parse connection behavior to another connection.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseListData": {
    "type": "function",
    "name": "can-connect/data/parse/parse.parseListData",
    "parent": "can-connect/data/parse/parse",
    "src": {
      "line": 60,
      "codeLine": 122,
      "path": "node_modules/can-connect/src/data/parse/parse.js"
    },
    "body": "\n## Use\n\n`parseListData` comes in handy when dealing with a poorly designed API\nthat can be improved with data transformation.\n\nSuppose an endpoint responds with a status of 200 OK, even when the\nrequest generates an empty result set. Worse yet, instead of representing\nan emtpy set with an empty list, it removes the property.\n\nA request to `/services/todos` may return:\n```\n{\n  todos: [\n    {todo: {id: 0, name: \"dishes\"}},\n    {todo: {id: 2, name: \"lawn\"}}\n  ]\n}\n```\n\nWhat if a request for `/services/todos?filterName=bank` responds with\n200 OK:\n```\n{\n}\n```\n\nThis response breaks its own schema. One way to bring it in line\nwith a format compatible with [can-connect.listData] is:\n\n```\nconnect([\"data-parse\",\"data-url\"],{\n  parseListProp: \"todos\",\n  parseListData(responseData) {\n    if (responseData && !responseData.todos) {\n      responseData = { todos: [] };\n    }\n\n    return responseData;\n  }\n})\n```\n    \n",
    "description": "Given the response of [can-connect/connection.getListData] returns it in the [can-connect.listData] format.\n\n",
    "title": "parseListData",
    "signatures": [
      {
        "code": "connection.parseListData(responseData, xhr, headers)",
        "description": "\n\n  This function will use [connection.parseListProp] to find the array like data\n  for each instance to be created.  It will then use [connection.parseInstanceData]\n  on each item in the array like data.  Finally, it will return data in the\n  [can-connect.listData] format.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "The response data from the AJAX request\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "An object like `{data: [props, props, ...]}`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "responseData",
      "description": "The response data from the AJAX request\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "An object like `{data: [props, props, ...]}`\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseInstanceData": {
    "type": "function",
    "name": "can-connect/data/parse/parse.parseInstanceData",
    "parent": "can-connect/data/parse/parse",
    "src": {
      "line": 152,
      "codeLine": 208,
      "path": "node_modules/can-connect/src/data/parse/parse.js"
    },
    "body": "\n## Use\n\n`parseInstanceData` comes in handy when dealing with a poorly designed API\nthat can be improved with data transformation.\n\nSuppose a request to `/services/todos` returns:\n```\n{\n  baseUrl: \"/proxy/share\",\n  todo: {\n    id: 0,\n    name: \"dishes\",\n    friendFaceUrl: \"friendface?id=0\",\n    fiddlerUrl: \"fiddler?id=0\"\n  }\n}\n```\n\nThe baseUrl property is meta-data that needs to be incorporated into the\ninstance data. One way to deal with this is:\n\n```\nconnect([\"data-parse\",\"data-url\"],{\n  parseInstanceProp: \"todo\",\n  parseInstanceData(responseData) {\n    ['friendFaceUrl', 'fiddlerUrl'].map(urlProp => {\n      responseData.todo[urlProp] = [\n        responseData.baseUrl,\n        responseData.todo[urlProp]\n      ].join('/');\n    });\n\n    return responseData;\n  }\n})\n```\n    \n",
    "description": "Returns the properties that should be used to [connection.hydrateInstance make an instance] given the results of [can-connect/connection.getData], [can-connect/connection.createData], [can-connect/connection.updateData],\nand [can-connect/connection.destroyData].\n\n",
    "title": "parseInstanceData",
    "signatures": [
      {
        "code": "connection.parseInstanceData(responseData, xhr, headers)",
        "description": "\n\n  This function will use [connection.parseInstanceProp] to find the data object\n  representing the instance that will be created.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The data that should be passed to [connection.hydrateInstance].\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "responseData",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The data that should be passed to [connection.hydrateInstance].\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseListProp": {
    "body": "\n\n## Use\n\nSet `parseListProp` if your response data does not look like: `{data: [props, props]}`.\n\nFor example, if [can-connect/connection.getListData] returns data like:\n\n```\n{\n\t  todos: [{id: 1, name: \"dishes\"}, {id: 2, name: \"lawn\"}]\n}\n```\n\nSet `parseListProp` to `\"todos\"` like:\n\n```\ncan.connect([\"data-parse\",\"data-url\"],{\n  url : \"/todos\",\n  parseListProp: \"todos\"\n});\n```\n\n\t \n",
    "description": "\nThe property to find the array-like data that represents each instance item.\n",
    "types": [
      {
        "type": "String",
        "description": "[can-connect/data/parse/parse.parseListData] uses this property to find an array-like data struture\non the result of [can-connect/connection.getListData].\n"
      }
    ],
    "title": "parseListProp",
    "name": "can-connect/data/parse/parse.parseListProp",
    "type": "property",
    "parent": "can-connect/data/parse/parse",
    "comment": " "
  },
  "connection.parseInstanceProp": {
    "src": {
      "line": 250,
      "codeLine": 289,
      "path": "node_modules/can-connect/src/data/parse/parse.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\nSet `parseInstanceData` if your response data does not directly contain the data you would like to pass to\n[connection.hydrateInstance].\n\nFor example, if [can-connect/connection.getData] returns data like:\n\n```\n{\n  todo: {\n\t   id: 1,\n    name: \"dishes\"\n  }\n}\n```\n\nSet `parseInstanceProp` to `\"todo\"` like:\n\n```\ncan.connect([\"data-parse\",\"data-url\"],{\n  url : \"/todos\",\n  parseInstanceProp: \"todo\"\n});\n```\n\t \n",
    "description": "\nThe property to find the data that represents an instance item.\n",
    "types": [
      {
        "type": "String",
        "description": "[connection.parseInstanceData] uses this property's value to\n[connection.hydrateInstance make an instance].\n"
      }
    ],
    "title": "parseInstanceProp",
    "name": "connection.parseInstanceProp",
    "parent": "can-connect/data/parse/parse",
    "comment": " "
  },
  "can-connect/data/url/url.data-methods": {
    "name": "can-connect/data/url/url.data-methods",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/url/url",
    "description": "",
    "order": 0
  },
  "can-connect/data/url/url.option": {
    "name": "can-connect/data/url/url.option",
    "title": "Options",
    "type": "group",
    "parent": "can-connect/data/url/url",
    "description": "",
    "order": 0
  },
  "can-connect/data/url/url": {
    "name": "can-connect/data/url/url",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 91,
      "path": "node_modules/can-connect/src/data/url/url.js"
    },
    "body": "\n## Use\n\nThe `data-url` behavior implements many of the `data interface`\nmethods to send instance data to a URL.\n\nFor example, the following `todoConnection`:\n\n```js\nvar todoConnection = can.connect([\"data-url\"],{\n  url: {\n    getListData: \"GET /todos\",\n    getData: \"GET /todos/{id}\",\n    createData: \"POST /todos\",\n    updateData: \"PUT /todos/{id}\",\n    destroyData: \"DELETE /todos/{id}\"\n  }\n});\n```\n\nWill make the following request when the following\nmethods are called:\n\n```\n// GET /todos?due=today\ntodoConnection.getListData({due: \"today\"});\n\n// GET /todos/5\ntodosConnection.getData({id: 5})\n\n// POST /todos \\\n// name=take out trash\ntodosConnection.createData({\n  name: \"take out trash\"\n});\n\n// PUT /todos/5 \\\n// name=do the dishes\ntodosConnection.updateData({\n  name: \"do the dishes\",\n  id: 5\n});\n\n// DELETE /todos/5\ntodosConnection.destroyData({\n  id: 5\n});\n```\n\nThere's a few things to notice:\n\n1. URL values can include simple templates like `{id}`\n   that replace that part of the URL with values in the data\n   passed to the method.\n2. GET and DELETE request data is put in the URL using [jQuery.param](http://api.jquery.com/jquery.param/).\n3. POST and PUT requests put data that is not templated in the URL in POST or PUT body\n   as form encoded data.\n4. If a provided URL doesn't include the method, the following default methods are provided:\n   - `getListData` - `GET`\n   - `getData` - `GET`\n   - `createData` - `POST`\n   - `updateData` - `PUT`\n   - `destroyData` - `DELETE`\n\nIf [connection.url] is provided as a string like:\n\n```js\nvar todoConnection = can.connect([\"data-url\"],{\n  url: \"/todos\"\n});\n```\n\nThis does the same thing as the first `todoConnection` example.\n\n",
    "description": "\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior",
        "description": "\n\nUses the [can-connect/data/url/url.url] option to implement the behavior of\n[can-connect/connection.getListData],\n[can-connect/connection.getData],\n[can-connect/connection.createData],\n[can-connect/connection.updateData], and\n[can-connect/connection.destroyData] to make an AJAX request\nto urls.\n"
      }
    ],
    "comment": " "
  },
  "can-connect/data/url/url.url": {
    "src": {
      "line": 132,
      "codeLine": 177,
      "path": "node_modules/can-connect/src/data/url/url.js"
    },
    "type": "property",
    "body": "\n",
    "description": "\nSpecify the url and methods that should be used for the \"Data Methods\".\n",
    "types": [
      {
        "type": "String",
        "description": "If a string is provided, it's assumed to be a RESTful interface. For example,\nif the following is provided:\n\n```\nurl: \"/services/todos\"\n```\n\n... the following methods and requests are used:\n\n - `getListData` - `GET /services/todos`\n - `getData` - `GET /services/todos/{id}`\n - `createData` - `POST /services/todos`\n - `updateData` - `PUT /services/todos/{id}`\n - `destroyData` - `DELETE /services/todos/{id}`\n"
      },
      {
        "type": "Object",
        "options": [],
        "description": "If an object is provided, it can customize each method and URL directly\nlike:\n\n```\nurl: {\n  getListData: \"GET /services/todos\",\n  getData: \"GET /services/todo/{id}\",\n  createData: \"POST /services/todo\",\n  updateData: \"PUT /services/todo/{id}\",\n  destroyData: \"DELETE /services/todo/{id}\"\n}\n```\n\nYou can provide a `resource` property that works like providing `url` as a string, but overwrite\nother values like:\n\n```\nurl: {\n  resource: \"/services/todo\",\n  getListData: \"GET /services/todos\"\n}\n```\n"
      }
    ],
    "title": "url",
    "name": "can-connect/data/url/url.url",
    "parent": "can-connect/data/url/url.option"
  },
  "can-connect/data/url/url.getListData": {
    "name": "can-connect/data/url/url.getListData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 182,
      "codeLine": 186,
      "path": "node_modules/can-connect/src/data/url/url.js"
    },
    "body": "",
    "description": " \n",
    "title": "getListData"
  },
  "can-connect/data/url/url.getData": {
    "name": "can-connect/data/url/url.getData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 187,
      "codeLine": 191,
      "path": "node_modules/can-connect/src/data/url/url.js"
    },
    "body": "",
    "description": " \n",
    "title": "getData"
  },
  "can-connect/data/url/url.createData": {
    "name": "can-connect/data/url/url.createData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 192,
      "codeLine": 196,
      "path": "node_modules/can-connect/src/data/url/url.js"
    },
    "body": "",
    "description": " \n",
    "title": "createData"
  },
  "can-connect/data/url/url.updateData": {
    "name": "can-connect/data/url/url.updateData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 197,
      "codeLine": 201,
      "path": "node_modules/can-connect/src/data/url/url.js"
    },
    "body": "",
    "description": " \n",
    "title": "updateData"
  },
  "can-connect/data/url/url.destroyData": {
    "name": "can-connect/data/url/url.destroyData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 202,
      "codeLine": 206,
      "path": "node_modules/can-connect/src/data/url/url.js"
    },
    "body": "",
    "description": " \n",
    "title": "destroyData"
  },
  "can-connect/data/worker.getListData": {
    "src": {
      "line": 66,
      "codeLine": 74,
      "path": "node_modules/can-connect/src/data/worker/worker.js"
    },
    "type": "function",
    "body": "\t \n",
    "description": "\nIf passed a [can-connect/data/worker.worker] option, overwritten\nto forward calling this method on a connection in the worker that\nshares this connection's [can-connect/data/worker.name].\n",
    "title": "getListData",
    "name": "can-connect/data/worker.getListData",
    "parent": "can-connect/data/worker.data"
  },
  "can-connect/data/worker.updateListData": {
    "src": {
      "line": 75,
      "codeLine": 83,
      "path": "node_modules/can-connect/src/data/worker/worker.js"
    },
    "type": "function",
    "body": "\t \n",
    "description": "\nIf passed a [can-connect/data/worker.worker] option, overwritten\nto forward calling this method on a connection in the worker that\nshares this connection's [can-connect/data/worker.name].\n",
    "title": "updateListData",
    "name": "can-connect/data/worker.updateListData",
    "parent": "can-connect/data/worker.data"
  },
  "can-connect/data/worker.getSets": {
    "src": {
      "line": 84,
      "codeLine": 92,
      "path": "node_modules/can-connect/src/data/worker/worker.js"
    },
    "type": "function",
    "body": "\t \n",
    "description": "\nIf passed a [can-connect/data/worker.worker] option, overwritten\nto forward calling this method on a connection in the worker that\nshares this connection's [can-connect/data/worker.name].\n",
    "title": "getSets",
    "name": "can-connect/data/worker.getSets",
    "parent": "can-connect/data/worker.data"
  },
  "can-connect/data/worker.clear": {
    "src": {
      "line": 93,
      "codeLine": 101,
      "path": "node_modules/can-connect/src/data/worker/worker.js"
    },
    "type": "function",
    "body": "\t \n",
    "description": "\nIf passed a [can-connect/data/worker.worker] option, overwritten\nto forward calling this method on a connection in the worker that\nshares this connection's [can-connect/data/worker.name].\n",
    "title": "clear",
    "name": "can-connect/data/worker.clear",
    "parent": "can-connect/data/worker.data"
  },
  "can-connect/data/worker.getData": {
    "src": {
      "line": 102,
      "codeLine": 110,
      "path": "node_modules/can-connect/src/data/worker/worker.js"
    },
    "type": "function",
    "body": "\t \n",
    "description": "\nIf passed a [can-connect/data/worker.worker] option, overwritten\nto forward calling this method on a connection in the worker that\nshares this connection's [can-connect/data/worker.name].\n",
    "title": "getData",
    "name": "can-connect/data/worker.getData",
    "parent": "can-connect/data/worker.data"
  },
  "can-connect/data/worker.createData": {
    "src": {
      "line": 111,
      "codeLine": 119,
      "path": "node_modules/can-connect/src/data/worker/worker.js"
    },
    "type": "function",
    "body": "\t \n",
    "description": "\nIf passed a [can-connect/data/worker.worker] option, overwritten\nto forward calling this method on a connection in the worker that\nshares this connection's [can-connect/data/worker.name].\n",
    "title": "createData",
    "name": "can-connect/data/worker.createData",
    "parent": "can-connect/data/worker.data"
  },
  "can-connect/data/worker.updateData": {
    "src": {
      "line": 120,
      "codeLine": 128,
      "path": "node_modules/can-connect/src/data/worker/worker.js"
    },
    "type": "function",
    "body": "\t \n",
    "description": "\nIf passed a [can-connect/data/worker.worker] option, overwritten\nto forward calling this method on a connection in the worker that\nshares this connection's [can-connect/data/worker.name].\n",
    "title": "updateData",
    "name": "can-connect/data/worker.updateData",
    "parent": "can-connect/data/worker.data"
  },
  "can-connect/data/worker.destroyData": {
    "src": {
      "line": 129,
      "codeLine": 137,
      "path": "node_modules/can-connect/src/data/worker/worker.js"
    },
    "type": "function",
    "body": "\t \n",
    "description": "\nIf passed a [can-connect/data/worker.worker] option, overwritten\nto forward calling this method on a connection in the worker that\nshares this connection's [can-connect/data/worker.name].\n",
    "title": "destroyData",
    "name": "can-connect/data/worker.destroyData",
    "parent": "can-connect/data/worker.data"
  },
  "can-connect/data/worker.name": {
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "String",
        "description": "The connection must be provided a unique name.\n\t\t "
      }
    ],
    "title": "name",
    "name": "can-connect/data/worker.name",
    "type": "property",
    "parent": "can-connect/data/worker.identifiers"
  },
  "can-connect/data/worker.worker": {
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Worker",
        "description": "A web-worker that \"data instance\" methods will be sent to.  This\nweb-worker should include a connection that matches the name of the window's\nconnection.\n\t\t "
      }
    ],
    "title": "worker",
    "name": "can-connect/data/worker.worker",
    "type": "property",
    "parent": "can-connect/data/worker.identifiers"
  },
  "can-connect/data/worker/worker.identifiers": {
    "name": "can-connect/data/worker/worker.identifiers",
    "title": "Identifiers",
    "type": "group",
    "parent": "can-connect/data/worker/worker",
    "description": "",
    "order": 0
  },
  "can-connect/data/worker/worker.data": {
    "name": "can-connect/data/worker/worker.data",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/worker/worker",
    "description": "",
    "order": 0
  },
  "can-connect/data/worker/worker": {
    "src": {
      "path": "node_modules/can-connect/src/data/worker/worker.md"
    },
    "body": "\n## Use\n\nThe best way to use `data-worker` is to create a connection module that works when loaded in\neither the `window` or in a [Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers).\nThis pattern tends to work even if workers are not supported.\n\nThe following creates a connection that does the work of [can-connect/cache-requests/cache-requests],\n[can-connect/data/url/url], and [can-connect/data/memory-cache/memory-cache] in a worker thread.  \n\n<div class='demo_wrapper' data-demo-src='can-connect/src/data/worker/demo/worker.html'></div>\n\nThe `todo_connection` module can be found [here](https://github.com/canjs/can-connect/blob/master/src/data/worker/demo/todo_connection.js)\nand looks like the following:\n\n\n```\n// Create a cache.  This will only be used\n// by the workerthread using the `cache-requests` behavior.\nvar cache = connect(['data-memory-cache'],{\n\tname: \"todos-cache\"\n});\n\n// If we are in the WINDOW thread, because there is a document,\n// create a worker that loads the `todo_connection` module.\nvar worker;\nif(typeof document !== \"undefined\") {\n\tvar workerURL = System.stealURL+\"?main=todo_connection\";\n\tworker = new Worker( workerURL );\n}\n\nvar todoConnection = connect([\n\t\"data-url\",\n\t\"cache-requests\",\n\t\"data-worker\",\n\t\"constructor\",\n\t\"constructor-store\"],\n  {\n    url: \"/todos\",\n    cacheConnection: cache,\n    worker: worker,\n    name: \"todos\"\n  });\n```\n\n\n\nThe things to notice:\n\n1. A `Worker` should be passed as the `worker` option\nthat loads a connection with the same name as the connection in the `window`.  In thise case, the same\nconnection module is loaded so everything works.\n\n2. A single `Worker` could load multiple connection modules and perform other behavior.  \n\n### Split Connection Logic\n\nTHe previous example used a single module that was loaded by both the window and the worker.\nThis doesn't have to be the case.  Two different modules could be used.  For example, `todo-window.js` and\n`todo-worker.js`.  Each might look like:\n\n```\n// todo-window.js\nvar workerURL = System.stealURL+\"?main=models/todo-worker\";\n\nvar todoConnection = connect([\n\t\"data-worker\",\n\t\"constructor\",\n\t\"constructor-store\"],\n  {\n    worker: new Worker( workerURL ),\n    name: \"todos\"\n  });\n```\n\n```\n// todo-worker.js\nvar cache = connect(['data-memory-cache'],{\n\tname: \"todos-cache\"\n});\n\nvar todoConnection = connect([\n\t\"data-url\",\n\t\"cache-requests\",\n\t\"data-worker\"],\n  {\n    url: \"/todos\",\n    cacheConnection: cache,\n    name: \"todos\"\n  });\n```\n\nHowever, the problem with the two-module approach is that it will not work\nif Workers are not supported by your browser.\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "name": "can-connect/data/worker/worker",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "dataWorker(baseConnection)",
        "description": "\n\nIf a [Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)\nis provided, overwrites the \"data interface methods\" to package the arguments and send them as\npart of a `postMessage` to the Worker.\n\n\nIf a `Worker` is not provided, it is assumed \"data-worker\" is being added\nwithin a worker thread.  It listens to messages sent to the Worker, calls the specified \"data interface method\"\nand sends a message back with the result.\n\nAny data methods called on the `window` connection will wait until the `worker` connection\nhas established a handshake.\n",
        "params": []
      }
    ],
    "comment": " "
  }
}
