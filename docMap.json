{
  "steal-stache": {
    "src": {
      "path": "node_modules/steal-stache/steal-stache.md"
    },
    "body": "\n\n## Use\n\nWith [StealJS](https://stealjs.com) being used from `node_modules` like this:\n\n```html\n<script src=\"node_modules/steal/steal.js\"></script>\n```\n\nStart by installing `steal-stache` with npm:\n\n```shell\nnpm install steal-stache --save\n```\n\nThen add the plugins configuration to your `package.json`:\n\n```json\n{\n  ...\n  \"steal\": {\n    ...\n    \"plugins\": [\"steal-stache\"]\n  }\n}\n```\n\nNow you can load [can-stache] modules like this:\n\n```js\nimport todosStache from \"todos.stache\"\ntodosStache([{name: \"dishes\"}]) //-> <documentFragment>\n```\n\n## Specifying Dependencies\n\nThis plugin allows [can-view-import <can-import>] elements that specify\ntemplate dependencies:\n\n\n```\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\n",
    "description": "\nA [StealJS](http://stealjs.com) extension that allows stache templates as dependencies.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "steal-stache",
    "parent": "can-views",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/steal-stache/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-stache": "^3.10.0",
        "can-stache-bindings": "^3.2.0",
        "can-view-import": "^3.1.0",
        "jquery": "2.x - 3.x"
      },
      "deprecated": false,
      "description": "Load can-stache templates with StealJS",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-test-helpers": "^1.1.0",
        "can-view-nodelist": "^3.1.0",
        "jshint": "^2.9.4",
        "steal": "^1.5.11",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "stealjs",
        "donejs"
      ],
      "main": "steal-stache.js",
      "name": "steal-stache",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/steal-stache.git"
      },
      "scripts": {
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release"
      },
      "system": {
        "main": "steal-stache",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "steal-tools"
        ],
        "npmAlgorithm": "flat",
        "ext": {
          "stache": "steal-stache"
        }
      },
      "version": "3.1.2"
    },
    "signatures": [
      {
        "code": "STACHE_MODULE_NAME!steal-stache",
        "description": "\n\nImport a [can-stache stache] module in your code and use it to render.\n\n```js\nvar template = require(\"./main.stache\");\nvar Map = require(\"can-map\");\n\nvar map = new Map();\nvar frag = template(map);\n\n// frag is a live-bound DocumentFragment\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "name": "STACHE_MODULE_NAME",
            "description": "The module name of a stache template. This\nwill typically be something like `templates/main.stache`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A renderer function that will render the template into a document fragment.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "moduleName"
        }
      ],
      "name": "STACHE_MODULE_NAME",
      "description": "The module name of a stache template. This\nwill typically be something like `templates/main.stache`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A renderer function that will render the template into a document fragment.\n"
    },
    "comment": " "
  },
  "about": {
    "src": {
      "path": "docs/can-canjs/about.md"
    },
    "body": "\nCanJS is an evolving and improving set of client-side JavaScript architectural libraries that balances innovation and stability. It targets experienced developers building complex applications with long futures ahead of them.\n\nCanJS is part of the [DoneJS](https://donejs.com/) family of open source projects.  The [DoneJS Team](https://donejs.com/About.html#team) and [Bitovi](https://www.bitovi.com) are responsible for CanJS. They steer its direction, add features, fix bugs, and help you become successful. Feel free to say hello anytime on [Gitter chat](https://gitter.im/canjs/canjs) or the [forums](https://forums.donejs.com/c/canjs).\n\n<div class=\"hero-images\">\n    <img\n        class=\"tortoise\"\n        srcset=\"../docs/images/home/Home-Tortoise-bw.png 1x, ../docs/images/home/Home-Tortoise-bw-x2.png 2x\"\n        src=\"../docs/images/home/Home-Tortoise-bw.png\"/>\n    <img\n        class=\"hare\"\n        srcset=\"../docs/images/home/Home-Hare-bw.png 1x, ../docs/images/home/Home-Hare-bw-x2.png 2x\"\n        src=\"../docs/images/home/Home-Tortoise-bw.png\"/>\n</div>\n\n**CanJS’s goals are briefly summarized in its mission statement:**\n\n> To minimize the cost of building and maintaining JavaScript applications by balancing innovation and stability, helping developers transcend a changing technology landscape.\n\n## Why CanJS?\n\n* Read more about [guides/mission our mission] and how we’ve been accomplishing those goals for 10 years.\n\n* If CanJS’s heart isn’t enough to convince you it’s a good fit, read up on its [guides/technical].\n\n* CanJS is used by some of the largest companies in the world. Find out who on [guides/who-uses-canjs]\n\n* Learn about CanJS’s future plans, how we make them, and how you can influence them on the [roadmap] page.\n\n",
    "description": " Learn about CanJS’s [guides/mission mission], [guides/technical technical highlights], [guides/who-uses-canjs who uses CanJS], and our [roadmap future roadmap].\n\n",
    "name": "about",
    "title": "About",
    "type": "page",
    "parent": "canjs",
    "order": 0,
    "comment": " "
  },
  "can-core": {
    "src": {
      "path": "docs/can-canjs/can-core.md"
    },
    "body": "\n## Use\n\nCanJS’s core libraries are the best, most hardened and generally useful modules.  \nEach module is part of an independent package, so you\nshould install the ones you use directly:\n\n```\nnpm install can-component can-compute can-connect can-define can-route can-route-pushstate can-set can-stache can-stache-bindings --save\n```\n\n\nLet’s explore each module a bit more.\n\n## can-compute\n\n[can-compute]s represent an observable value.  A compute can contain its\nown value and notify listeners of changes like:\n\n```js\nvar compute = require(\"can-compute\");\n\nvar name = compute(\"Justin\");\n\n// read the value\nname() //-> \"Justin\"\n\nname.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Matthew\"\n\toldVal //-> \"Justin\"\n});\n\nname(\"Matthew\");\n```\n\nMore commonly, a compute derives its value from other observables.  The following\n`info` compute derives its value from a `person` map, `hobbies` list, and `age`\ncompute:\n\n```js\nvar DefineMap = require(\"can-define/map/map\"),\n\tDefineList = require(\"can-define/list/list\"),\n\tcompute = require(\"can-compute\");\n\nvar person = new DefineMap({first: \"Justin\", last: \"Meyer\"}),\n\thobbies = new DefineList([\"js\",\"bball\"]),\n\tage = compute(33);\n\nvar info = compute(function(){\n\treturn person.first +\" \"+ person.last+ \" is \"+age()+\n\t\t\"and like \"+hobbies.join(\", \")+\".\";\n});\n\ninfo() //-> \"Justin Meyer is 33 and likes js, bball.\"\n\ninfo.on(\"change\", function(ev, newVal){\n\tnewVal //-> \"Justin Meyer is 33 and likes js.\"\n});\n\nhobbies.pop();\n```\n\n\n## can-define\n\n[can-define/map/map] and [can-define/list/list] allow you to create observable\nmaps and lists with well-defined properties.  You can\n[can-define.types.propDefinition define a property’s type initial value, enumerability, getter-setters and much more].\nFor example, you can define the behavior of a `Todo` type and a `TodoList` type as follows:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({           // A todo has a:\n  name: \"string\",                       // .name that’s a string\n  complete: {                           // .complete that’s\n\ttype: \"boolean\",                    //        a boolean\n\tvalue: false                        //        initialized to false\n  },                                    \n  dueDate: \"date\",                      // .dueDate that’s a date\n  get isPastDue(){                      // .pastDue that returns if the\n\treturn new Date() > this.dueDate;   //        dueDate is before now\n  },\n  toggleComplete: function(){           // .toggleComplete method that\n    this.complete = !this.complete;     //        changes .complete\n  }\n});\n\nvar TodoList = DefineList.extend({      // A list of todos:     \n  \"#\": Todo,                            // has numeric properties\n                                        //         as todos\n\n  get completeCount(){                  // has .completeCount that\n    return this.filter(\"complete\")      //         returns # of\n\t           .length;                 //         complete todos\n  }\n});\n```\n\nThis allows you to create a Todo, read its properties, and\ncall back its methods like:\n\n```js\nvar dishes = new Todo({\n\tname: \"do dishes\",\n\t// due yesterday\n\tdueDate: new Date() - 1000 * 60 * 60 * 24\n});\ndishes.name      //-> \"do dishes\"\ndishes.isPastDue //-> true\ndishes.complete  //-> false\ndishes.toggleComplete()  \ndishes.complete  //-> true\n```\n\nAnd it allows you to create a `TodoList`, access its items and properties\nlike:\n\n```js\nvar todos = new TodoList( dishes, {name: \"mow lawn\", dueDate: new Date()});\ntodos.length         //-> 2\ntodos[0].complete    //-> true\ntodos.completeCount //-> 1\n```\n\nThese observables provide the foundation\nfor data connection (models), view-models and even routing in your application.\n\n## can-set\n\n[can-set] models a service layer’s behavior as a [can-set.Algebra set.Algebra]. Once modeled, other libraries such as [can-connect] or [can-fixture] can\nadd a host of functionality like: real-time behavior, performance optimizations, and\nsimulated service layers.\n\nA `todosAlgebra` set algebra for a `GET /api/todos` service might look like:\n\n```js\nvar set = require(\"can-set\");\nvar todosAlgebra = new set.Algebra(\n    // specify the unique identifier property on data\n    set.prop.id(\"_id\"),  \n    // specify that completed can be true, false or undefined\n    set.prop.boolean(\"complete\"),\n    // specify the property that controls sorting\n    set.prop.sort(\"orderBy\")\n)\n```\n\nThis assumes that the service:\n\n - Returns data where the unique property name is `_id`:\n   ```js\n   GET /api/todos\n   -> [{_id: 1, name: \"mow lawn\", complete: true},\n       {_id: 2, name: \"do dishes\", complete: false}, ...]\n   ```\n - Can filter by a `complete` property:\n   ```js\n   GET /api/todos?complete=false\n   -> [{_id: 2, name: \"do dishes\", complete: false}, ...]\n   ```\n - Sorts by an `orderBy` property:\n   ```js\n   GET /api/todos?orderBy=name\n   -> [{_id: 2, name: \"do dishes\", complete: false},\n       {_id: 1, name: \"mow lawn\", complete: true}]\n   ```\n\nIn the next section will use `todoAlgebra` to build a model with [can-connect].\n\n## can-connect\n\n[can-connect] connects a data type, typically a `DefineMap` and its `DefineList`,\nto a service layer. This is often done via the\n[can-connect/can/base-map/base-map] module which bundles many common behaviors\ninto a single api:\n\n```js\nvar baseMap = require(\"can-connect/can/base-map/base-map\"),\n    DefineMap = require(\"can-define/map/map\"),\n    DefineList = require(\"can-define/list/list\"),\n\tset = require(\"can-set\");\n\nvar Todo = DefineMap.extend({\n\t...\n});\nvar TodosList = DefineMap.extend({\n\t\"#\": Todo,\n\t...\n});\nvar todosAlgebra = new set.Algebra({\n\t...\n});\n\nvar connection = baseMap({\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList,\n\talgebra: todosAlgebra,\n\tname: \"todo\"\n});\n```\n\n`baseMap` extends the `Map` type, in this case, `Todo`, with\nthe ability to make requests to the service layer.\n\n - [can-connect/can/map/map.getList Get a list] of Todos\n   ```js\n   Todo.getList({complete: true}).then(function(todos){})\n   ```\n - [can-connect/can/map/map.get Get] a single Todo\n   ```js\n   Todo.get({_id: 6}).then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.save Create] a Todo\n   ```js\n   var todo = new Todo({name: \"do dishes\", complete: false})\n   todo.save().then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.save Update] an [can-connect/can/map/map.prototype.isNew already created] Todo\n   ```js\n   todo.complete = true;\n   todo.save().then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.destroy Delete] a Todo\n   ```js\n   todo.destroy().then(function(todo){})\n   ```\n\n[can-connect] is also middleware, so custom connections can\nbe assembled too:\n\n```js\nvar base = require(\"can-connect/base/base\");\nvar dataUrl = require(\"can-connect/data-url/data-url\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar map = require(\"can-connect/can/map/map\");\n\nvar options = {\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList,\n\talgebra: todosAlgebra,\n\tname: \"todo\"\n}\nvar connection = map(constructor(dataUrl(base(options))));\n```\n\n## can-stache\n\n[can-stache] provides live binding mustache and handlebars syntax. While\ntemplates should typically be loaded with a module loader like [steal-stache],\nyou can create a template programmatically that lists out todos within a\npromise loaded from `Todo.getList` like:\n\n```js\nvar stache = require(\"can-stache\");\n\n// Creates a template\nvar template = stache(\n\t\"<ul>\"+\n\t\t\"{{#if todos.isPending}}<li>Loading…</li>{{/if}}\"+\n\t\t\"{{#if todos.isResolved}}\"+\n\t\t\t\"{{#each todos.value}}\"+\n\t\t\t\t\"<li class='{{#complete}}complete{{/complete}}'>{{name}}</li>\"+\n\t\t\t\"{{else}}\"+\n\t\t\t\t\"<li>No todos</li>\"+\n\t\t\t\"{{/each}}\"+\n\t\t\"{{/if}}\"+\n\t\"</ul>\");\n\n// Calls the template with some data\nvar frag = template({\n\ttodos: Todo.getList({})\n});\n\n// Inserts the result into the page\ndocument.body.appendChild(frag);\n```\n\n[can-stache] templates use magic tags like `{{}}` to control what\ncontent is rendered. The most common forms of those magic tags are:\n\n - [can-stache.tags.escaped {{key}}] - Insert the value at `key` in the page. If `key` is a function or helper, run it and insert the result.\n - [can-stache.tags.section {{#key}}...{{/key}}] - Render the content between magic tags based on some criteria.  \n\n[can-stache] templates return document fragments that update whenever\ntheir source data changes.\n\n## can-component\n\n[can-component] creates custom elements with unit-testable view models. It\ncombines a view model created by [can-define/map/map] with a template\ncreated by [can-stache].\n\n```js\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\n// Defines the todos-list view model\nvar TodosListVM = DefineMap.extend({\n\t// An initial value that is a promise containing the\n\t// list of all todos.\n\ttodos: {\n\t\tvalue: function(){\n\t\t\treturn Todo.getList({});\n\t\t}\n\t},\n\t// A method that toggles a todo’s complete property\n\t// and updates the todo on the server.\n\ttoggleComplete: function(todo){\n\t\ttodo.complete = !todo.complete;\n\t\ttodo.save();\n\t}\n});\n\nComponent.extend({\n\ttag: \"todos-list\",\n\tViewModel: TodosVM,\n\tview: stache(\n\t\t\"<ul>\"+\n\t\t\t\"{{#if todos.isPending}}<li>Loading…</li>{{/if}}\"+\n\t\t\t\"{{#if todos.isResolved}}\"+\n\t\t\t\t\"{{#each todos.value}}\"+\n\t\t\t\t\t\"<li on:click='toggleComplete(.)'\"+\n\t\t\t\t\t     \"class='{{#complete}}complete{{/complete}}'>{{name}}</li>\"+\n\t\t\t\t\"{{else}}\"+\n\t\t\t\t\t\"<li>No todos</li>\"+\n\t\t\t\t\"{{/each}}\"+\n\t\t\t\"{{/if}}\"+\n\t\t\"</ul>\");\n});\n```\n\n## can-stache-bindings\n\n[can-stache-bindings] provides [can-view-callbacks.attr custom attributes] for\n[can-stache] event and data bindings.\n\nBindings look like:\n\n - `on:event=\"key()\"` for [can-stache-bindings.event event binding].\n - `prop:from=\"key\"` for [can-stache-bindings.toChild one-way binding to a child].\n - `prop:to=\"key\"` for [can-stache-bindings.toParent one-way binding to a parent].\n - `prop:bind=\"key\"` for [can-stache-bindings.twoWay two-way binding].\n\n[can-stache-bindings.event Event] binding examples:\n\n```html\n<!-- calls `toggleComplete` when the li is clicked -->\n<li on:click=\"toggleComplete(.)\"/>\n\n<!-- calls `resetData` when cancel is dispatched on `my-modal`’s view model -->\n<my-modal on:cancel=\"resetData()\"/>\n```\n\n[can-stache-bindings.toChild One-way to child] examples:\n\n```html\n<!-- updates input’s `checked` property with the value of complete -->\n<input type=\"checkbox\" checked:from=\"complete\"/>\n\n<!-- updates `todo-lists`’s  `todos` property with the result of `getTodos`-->\n<todos-list todos:from=\"getTodos(complete=true)\"/>\n```\n\n[can-stache-bindings.toChild One-way to parent] examples:\n\n```html\n<!-- updates `complete` with input’s `checked` property -->\n<input type=\"checkbox\" checked:to=\"complete\"/>\n\n<!-- updates `todosList` with `todo-lists`’s `todos` property -->\n<todos-list todos:to=\"todosList\"/>\n```\n\n[can-stache-bindings.twoWay Two-way] examples:\n\n```html\n<!-- Updates the input’s `value` with `name` and vice versa -->\n<input type=\"text\" value:bind=\"name\"/>\n\n<!-- Updates `date-picker`’s `date` with `dueDate` and vice versa -->\n<date-picker date:bind=\"dueDate\"/>\n```\n\n## can-route and can-route-pushstate\n\n[can-route] connects a `DefineMap`’s properties to values in the\nurl. Create a map type, [canjs/doc/can-route.map connect it to the url], and [can-route.ready begin routing] like:\n\n```js\nvar route = require(\"can-route\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar AppViewModel = DefineMap.extend({\n\tseal: false\n},{\n\t// Sets the default type to string\n\t\"#\": \"string\",\n\ttodoId: \"string\",\n\ttodo: {\n\t\tget: function(){\n\t\t\tif(this.todoId) {\n\t\t\t\treturn Todo.get({_id: this.todoId})\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar appViewModel = new AppViewModel();\nroute.map(appViewModel);\n\nroute.ready();\n```\n\nWhen the url changes, to something like `#!&todoId=5`, so will the\n`appViewModel`’s `todoId` and `todo` property:\n\n```js\nappViewModel.todoId //-> \"5\"\nappViewModel.todo   //-> Promise<Todo>\n```\n\nSimilarly, if `appViewModel`’s `todoId` is set like:\n\n```js\nappViewModel.todoId = 6;\n```\n\nThe hash will be updated:\n\n```js\nwindow.location.hash //-> \"#!&todoId=6\"\n```\n\nThe `route` function can be used to specify pretty routing rules that\ntranslate property changes to a url and a url to property changes. For example,\n\n```js\n// a route like:\nroute(\"todo/{todoId}\");\n\n// and a hash like:\nwindow.location.hash = \"#!todo/7\";\n\n// produces an appViewModel like:\nappViewModel.serialize() //-> {route: \"todo/{todoId}\", todoId: \"7\"}\n```\n\n[can-route-pushstate] adds [pushstate](https://developer.mozilla.org/en-US/docs/Web/API/History_API) support. It\nmixes in this behavior so you just need to import the module:\n\n```js\nvar route = require(\"can-route\");\nrequire(\"can-route-pushstate\");\n```\n\n\n## Want to learn more?\n\nIf you haven’t already, check out the [guides] page on how to learn CanJS.  Specifically, you’ll\nwant to check out the [guides/chat] and [guides/todomvc] to learn the basics of using CanJS’s\ncore libraries.  After that, check out the [guides/api] on how to use and learn from these API docs.\n\n",
    "description": "The best, most hardened and generally useful libraries in CanJS.   \n",
    "name": "can-core",
    "title": "Core",
    "type": "page",
    "parent": "api",
    "order": 10,
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "can-ecosystem": {
    "src": {
      "path": "docs/can-canjs/can-ecosystem.md"
    },
    "body": "\n",
    "description": "Useful libraries that extend or add important features to the core collection. \n",
    "name": "can-ecosystem",
    "title": "Ecosystem",
    "type": "page",
    "parent": "api",
    "order": 12,
    "comment": " "
  },
  "can-infrastructure": {
    "src": {
      "path": "docs/can-canjs/can-infrastructure.md"
    },
    "body": "\n## Use\n\nThe infrastructure collection of libraries are lower-level utility libraries that\nare used by the [can-core] and [can-ecosystem] collections.  They can also\nbe used by applications directly.\n\nLet’s explore what’s available.\n\n## can-event\n\n[can-event] is a mixin that adds event dispatching and listening functionality\non your objects. The following shows creating a `Person` constructor function\nwhose instances can produce events that can be listened to.\n\n```js\nvar canEvent = require(\"can-event\");\nvar assign = require(\"can-util/js/assign/assign\");\n\n// Create the Person type\nfunction Person(){ ... };\nPerson.prototype.method = function(){ ... };\n\n// Add event mixin:\nassign(Person.prototype, canEvent);\n\n// Create an instance\nvar me = new Person();\n\n// Now listen and dispatch events!\nme.addEventListener(\"name\", function(){ ... });\n\nme.dispatch(\"name\");\n```\n\n[can-event/batch/batch] adds event batching abilities to the [can-event] event system.\n[can-event/async/async] adds asynchronous batched event dispatching to the [can-event] event system.\n\n## can-observation\n\n[can-observation] provides a mechanism to notify when an observable has been read and a way to observe those reads called within a given function.  [can-observation] provides the foundation for [can-compute]’s abilities.\n\nUse [can-observation.add Observation.add] to signal when an an observable value has been read.\nThe following makes the `Person` type’s `getName()` observable:\n\n```js\nvar Observation = require(\"can-observation\");\nvar canEvent = require(\"can-event\");\nvar assign = require(\"can-util/js/assign/assign\");\n\n// Create the Person type\nfunction Person(){};\nPerson.prototype.setName = function(newName){\n\tvar oldName = this.name;\n\tthis.name = newName;\n\tthis.dispatch(\"name\", [newName, oldName]);\n};\nPerson.prototype.getName = function(){\n\tObservation.add(this, \"name\");\n\treturn this.name;\n};\n```\n\nThe `Observation` constructor can be used, similar to a [can-compute] to observe\na function’s return value by tracking calls to `Observation.add`\n\n```js\nvar person = new Person();\nperson.setName(\"Justin\");\n\n\nvar greetingObservation = new Observation(function(){\n\treturn person.getName() + \" says hi!\";\n}, null, function(newValue){\n\tconsole.log(newValue);\n});\ngreetingObservation.start();\n\ngreetingObservation.value //-> \"Justin says hi!\"\n\nperson.setName(\"Matt\") //-> console.logs \"Matt says hi!\";\n```\n\n## can-util\n\n[can-util] is a collection of many different modules that provide various JavaScript\nand DOM related utilities.\n\n### DOM Utilities\n\nThe DOM utilities consist of:\n\n - Node and Element helpers: [can-util/dom/child-nodes/child-nodes], [can-util/dom/class-name/class-name], [can-util/dom/data/data], [can-util/dom/frag/frag].\n - Event helpers: [can-util/dom/dispatch/dispatch], [can-util/dom/events/delegate/delegate], [can-util/dom/events/attributes/attributes], [can-util/dom/events/inserted/inserted], [can-util/dom/events/removed/removed].\n - Ajax helpers: [can-util/dom/ajax/ajax].\n - Environment identification helpers: [can-util/dom/document/document].\n\nAnd the [can-util/dom/mutate/mutate] helper which should be used to manipulate DOM\nnodes in elements that do not support [MutationObservers](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver).  \n\n\n### JS Utilities\n\nThe JS utilities consist of:\n\n- Functional helpers: [can-util/js/each/each], [can-util/js/assign/assign], [can-util/js/deep-assign/deep-assign], [can-util/js/make-array/make-array].\n- Type detection helpers: [can-util/js/is-array-like/is-array-like],  [can-util/js/is-empty-object/is-empty-object], [can-util/js/is-function], [can-util/js/is-plain-object/is-plain-object], [can-util/js/is-promise/is-promise], [can-util/js/is-string/is-string], [can-util/js/types/types].\n- Environment detection helpers: [can-util/js/is-browser-window/is-browser-window], [can-util/js/is-node/is-node], [can-util/js/is-web-worker/is-web-worker].\n- Environment identification helpers: [can-util/js/global/global], [can-util/js/import/import], [can-util/js/base-url/base-url].\n- Polyfills - [can-util/js/set-immediate/set-immediate].\n- URL helpers: [can-param], [can-deparam], [can-util/js/join-uris/join-uris].\n- Diffing helpers: [can-util/js/diff/diff], [can-util/js/diff-object/diff-object].\n- String helpers: [can-util/js/string/string], [can-util/js/string-to-any/string-to-any].\n- Object identification helpers: [can-util/js/cid/cid].\n\n\n## can-view-callbacks\n\n[can-view-callbacks] lets you register callbacks for specific elements or attributes found in\ntemplates.\n\n```js\nvar callbacks = require(\"can-view-callbacks\");\n\ncallbacks.tag(\"blue-el\", function(el){\n    el.style.background = \"blue\";\n});\n```\n\n## can-view-live\n\nSets up a live-binding between the DOM and a compute.\n\n```js\nvar live = require(\"can-view-live\");\nvar compute = require(\"can-compute\");\nvar frag = require(\"can-util/dom/frag/frag\");\n\nvar message = compute(\"World\");\n\nvar content = frag(\"Hello\",\"\",\"!\");\n\nlive.text(content.childNodes[1], message);\n\ndocument.body.appendChild(content);\n\nmessage(\"Earth\");\n\ndocument.body.innerHTML //-> Hello Earth!\n```\n\n## can-view-nodelist\n\n[can-view-nodelist] is used to maintain the structure of HTML nodes produced by a\ntemplate. For example, a [can-stache] template like:\n\n```\n{{#if over21}}name:{{{highlight name}}}.{{/if}}\n```\n\nMight result in a nodeList structure that looks like:\n\n```\nif[\n\tTextNode(\"name:\"),\n\thighlight[<b>Justin</b>]\n]\n```\n\nThis is to say that the `#if over21` nodeList will contain a text node for `\"name:\"`\nand the `highlight name` nodeList.  The `highlight name` nodeList will contain the\nhtml content resulting from that helper (`<b>Justin</b>`).\n\n## can-view-parser\n\n[can-view-parser] parses HTML and handlebars/mustache tokens.  \n\n```js\nvar parser = require(\"can-view-parser\");\n\nvar html = '<h1><span first=\"foo\"></span><span second=\"bar\"></span></h1>';\n\nvar attrs = [];\n\nparser(html, {\n    attrStart: function(attrName){\n        attrs.push(attrName)\n    }\n});\n\nattrs //-> [\"first\", \"second\"]\n```\n\n## can-view-scope\n\n[can-view-scope] provides a lookup node within a contextual lookup. This is similar\nto a call object in closure in JavaScript.  Consider how `message`, `first`, and `last` are looked up in the following JavaScript:\n\n```js\nvar message = \"Hello\"\nfunction outer(){\n    var last = \"Abril\";\n\n    function inner(){\n        var first = \"Alexis\";\n        console.log(message + \" \"+ first + \" \" + last);\n    }\n    inner();\n}\nouter();\n```\n\n[can-view-scope] can be used to create a similar lookup path:\n\n```js\nvar globalScope = new Scope({message: \"Hello\"});\nvar outerScope = globalScope.add({last: \"Abril\"});\nvar innerScope = outerScope.add({first: \"Alexis\"});\ninnerScope.get(\"message\") //-> Hello\ninnerScope.get(\"first\")   //-> Alexis\ninnerScope.get(\"last\")    //-> Abril\n```\n\n## can-view-target\n\n[can-view-target] is used to create a document fragment that can be quickly cloned but\nhave callbacks called quickly on specific elements within the cloned fragment.\n\n```js\nvar viewTarget = require(\"can-view-target\");\n\nvar target = viewTarget([\n    {\n        tag: \"h1\",\n        callbacks: [function(data){\n            this.className = data.className\n        }],\n        children: [\n            \"Hello \",\n            function(){\n                this.nodeValue = data.message\n            }\n        ]\n    },\n]);\n\n// target.clone -> <h1>|Hello||</h1>\n// target.paths -> path: [0], callbacks: [], children: {paths: [1], callbacks:[function(){}]}\n\nvar frag = target.hydrate({className: \"title\", message: \"World\"});\n\nfrag //-> <h1 class='title'>Hello World</h1>\n```\n\n## can-cid\n\n[can-cid] is used to get a unique identifier for an object, optionally prefixed by a type name. Once set, the unique identifier does not change, even if the type name changes on subsequent calls.\n\n```js\nvar cid = require(\"can-cid\");\nvar x = {};\nvar y = {};\n\nconsole.log(cid(x, \"demo\")); // -> \"demo1\"\nconsole.log(cid(x, \"prod\")); // -> \"demo1\"\nconsole.log(cid(y));         // -> \"2\"\n```\n\n## can-types\n\n[can-types] is used to provide default types or test if something is of a certain type.\n\n```js\nvar types = require(\"can-types\");\nvar oldIsMapLike = types.isMapLike;\ntypes.isMapLike = function(obj){\n  return obj instanceof DefineMap || oldIsMapLike.apply(this, arguments);\n};\ntypes.DefaultMap = DefineMap;\n```\n\n## can-namespace\n\n[can-namespace] is a namespace where can-* packages can be registered.\n\n```js\nvar namespace = require('can-namespace');\n\nvar unicorn = {\n\t// ...\n};\n\nif (namespace.unicorn) {\n\tthrow new Error(\"You can't have two versions of can-unicorn, check your dependencies\");\n} else {\n\tmodule.exports = namespace.unicorn = unicorn;\n}\n```\n\n## can-symbol\n\n[can-symbol] contains Symbols used to detail how CanJS may operate on different objects.\n\n```js\nvar MyIDSymbol = CanSymbol(\"my_ID\");\n\nvar obj = {};\nobj[MyIDSymbol] = 1;\n```\n\n## can-reflect\n\n[can-reflect] allows reflection on unknown data types.\n\n```js\nvar foo = new DefineMap({ bar: \"baz\" });\n\ncanReflect.getKeyValue(foo, \"bar\"); // -> \"baz\"\n```\n\n",
    "description": "Utility libraries that power the core and ecosystem collection. \n",
    "name": "can-infrastructure",
    "title": "Infrastructure",
    "type": "page",
    "parent": "api",
    "order": 11,
    "comment": " "
  },
  "can-legacy": {
    "src": {
      "path": "docs/can-canjs/can-legacy.md"
    },
    "body": "\n",
    "description": "Former libraries that we still accept patches for, but are not under active development.\n\n",
    "name": "can-legacy",
    "title": "Legacy",
    "type": "page",
    "parent": "api",
    "order": 13,
    "comment": " "
  },
  "canjs": {
    "src": {
      "path": "docs/can-canjs/canjs.md"
    },
    "body": "\n## Getting Started\n\nGet started with CanJS by following one of the tutorials below.\n\n<div class=\"getting-started-icons\">\n    <div class=\"titled-list\">\n        <h3>Start from scratch</h3>\n        <ul>\n            <li>\n                <a href=\"doc/guides/setup.html\">\n                    <div>\n                        <img src=\"../docs/images/home/gear.svg\">\n                    </div>\n                    Setting Up CanJS\n                </a>\n            </li>\n        </ul>\n    </div>\n    <div class=\"or-separator\">\n        or\n    </div>\n    <div class=\"titled-list\">\n        <h3>Build a demo app</h3>\n        <ul>\n            <li>\n                <a href=\"doc/guides/chat.html\" title=\"Learn how to build a real-time chat app.\">\n                    <div>\n                        <img src=\"../docs/images/home/chat-bubble.svg\">\n                    </div>\n                    Chat Guide\n                </a>\n            </li>\n            <li>\n                <a href=\"doc/guides/todomvc.html\" title=\"Learn how to build the classic TodoMVC app.\">\n                    <div>\n                        <img src=\"../docs/images/home/check-mark.svg\">\n                    </div>\n                    TodoMVC Guide\n                </a>\n            </li>\n            <li>\n                <a href=\"doc/guides/atm.html\" title=\"Learn how to build an Automated Teller Machine app.\">\n                    <div>\n                        <img src=\"../docs/images/home/credit-card.svg\">\n                    </div>\n                    ATM Guide\n                </a>\n            </li>\n        </ul>\n    </div>\n    <div class=\"clear-both\"></div>\n</div>\n\n## Missing Something?\n\nIs there an itch that CanJS doesn’t scratch?  Let us know\non [Gitter chat](https://gitter.im/canjs/canjs) or the [forums](https://forums.donejs.com/c/canjs).\nWe like contributions of all sorts.  Read the [guides] _Contributing_ section for more details.\n\n## Love Something?\n\nLet us know by giving us a star on [GitHub](https://github.com/canjs/canjs) and following on [Twitter](https://twitter.com/canjs).  If there’s a particular package you like, make sure to star that too. Check out the [guides/contributing/evangelism Evangelism Guide] on\nhow to help spread the word!\n\n",
    "description": "CanJS is an evolving and improving set of client side JavaScript architectural libraries that balances innovation and stability. It targets experienced developers building complex applications with long futures ahead of them. \n<div class=\"hero-images\">\n    <img\n        class=\"tortoise\"\n        srcset=\"docs/images/home/Home-Tortoise-bw.png 1x, docs/images/home/Home-Tortoise-bw-x2.png 2x\"\n        src=\"docs/images/home/Home-Tortoise-bw.png\"\n        style=\"\"/>\n    <img\n        class=\"hare\"\n        srcset=\"docs/images/home/Home-Hare-bw.png 1x, docs/images/home/Home-Hare-bw-x2.png 2x\"\n        src=\"docs/images/home/Home-Tortoise-bw.png\"/>\n</div>\n\nIf you’re new to the project, the best place to start is the [about] page, where you’ll\nfind CanJS’s [guides/mission Mission] and [guides/technical Technical Highlights]. Then, go to the [guides] page to find\nthe [guides/chat Chat], [guides/todomvc TodoMVC], and [guides/atm ATM] guides.\n\n",
    "name": "canjs",
    "title": "CanJS",
    "type": "page",
    "dest": "../index",
    "outline": "0",
    "package": {
      "name": "can",
      "version": "3.11.0",
      "main": "can.js",
      "scripts": {
        "preversion": "npm test",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "testee": "testee test/index.html --browsers firefox",
        "testee-production": "testee test/production.html --browsers firefox",
        "http-server": "http-server -p 3000 --silent",
        "test": "npm run test-development && npm run test-production",
        "test-development": "npm run build && npm run testee",
        "test-production": "npm run build && npm run build-tests && npm run testee-production",
        "ci": "npm run build && npm run test && node test/test-sauce-labs.js",
        "release:pre": "npm version prerelease && npm run build && npm publish --tag=pre",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:major": "npm version major && npm run build && npm publish",
        "build": "node build.js",
        "build-tests": "node test/build.js",
        "document": "bit-docs",
        "document:force": "bit-docs -fd"
      },
      "title": "CanJS",
      "description": "MIT-licensed, client-side, JavaScript framework that makes building rich web applications easy.",
      "keywords": [
        "CanJS",
        "DoneJS"
      ],
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "web": "http://bitovi.com/"
      },
      "homepage": "http://canjs.com/",
      "repository": {
        "type": "git",
        "url": "git@github.com:canjs/canjs.git",
        "github": "https://github.com/canjs/canjs"
      },
      "dependencies": {
        "can-ajax": "canjs/can-ajax#master",
        "can-attribute-encoder": "canjs/can-attribute-encoder#master",
        "can-cid": "canjs/can-cid#master",
        "can-component": "canjs/can-component#master",
        "can-compute": "canjs/can-compute#master",
        "can-connect": "canjs/can-connect#master",
        "can-connect-cloneable": "canjs/can-connect-cloneable#master",
        "can-connect-feathers": "canjs/can-connect-feathers#master",
        "can-connect-ndjson": "canjs/can-connect-ndjson#master",
        "can-connect-signalr": "canjs/can-connect-signalr#master",
        "can-construct": "canjs/can-construct#master",
        "can-construct-super": "canjs/can-construct-super#master",
        "can-control": "canjs/can-control#master",
        "can-define": "canjs/can-define#master",
        "can-define-lazy-value": "canjs/can-define-lazy-value#master",
        "can-define-stream": "canjs/can-define-stream#master",
        "can-define-stream-kefir": "canjs/can-define-stream-kefir#master",
        "can-define-validate-validatejs": "canjs/can-define-validate-validatejs#master",
        "can-deparam": "canjs/can-deparam#master",
        "can-ejs": "canjs/can-ejs#master",
        "can-element": "canjs/can-element#master",
        "can-event": "canjs/can-event#master",
        "can-fixture": "canjs/can-fixture#master",
        "can-fixture-socket": "canjs/can-fixture-socket#master",
        "can-globals": "canjs/can-globals#master",
        "can-jquery": "canjs/can-jquery#master",
        "can-kefir": "canjs/can-kefir#master",
        "can-list": "canjs/can-list#master",
        "can-map": "canjs/can-map#master",
        "can-map-backup": "canjs/can-map-backup#master",
        "can-map-define": "canjs/can-map-define#master",
        "can-namespace": "canjs/can-namespace#master",
        "can-ndjson-stream": "canjs/can-ndjson-stream#master",
        "can-observation": "canjs/can-observation#master",
        "can-observe": "canjs/can-observe#master",
        "can-param": "canjs/can-param#master",
        "can-react-component": "canjs/can-react-component#master",
        "can-reflect": "canjs/can-reflect#master",
        "can-reflect-promise": "canjs/can-reflect-promise#master",
        "can-route": "canjs/can-route#master",
        "can-route-pushstate": "canjs/can-route-pushstate#master",
        "can-set": "canjs/can-set#master",
        "can-simple-dom": "canjs/can-simple-dom#master",
        "can-simple-map": "canjs/can-simple-map#master",
        "can-simple-observable": "canjs/can-simple-observable#master",
        "can-stache": "canjs/can-stache#master",
        "can-stache-bindings": "canjs/can-stache-bindings#master",
        "can-stache-converters": "canjs/can-stache-converters#master",
        "can-stache-key": "canjs/can-stache-key#master",
        "can-stream": "canjs/can-stream#master",
        "can-stream-kefir": "canjs/can-stream-kefir#master",
        "can-symbol": "canjs/can-symbol#master",
        "can-types": "canjs/can-types#master",
        "can-util": "canjs/can-util#master",
        "can-validate": "canjs/can-validate#master",
        "can-validate-legacy": "canjs/can-validate-legacy#master",
        "can-validate-validatejs": "canjs/can-validate-validatejs#master",
        "can-vdom": "canjs/can-vdom#master",
        "can-view-autorender": "canjs/can-view-autorender#master",
        "can-view-callbacks": "canjs/can-view-callbacks#master",
        "can-view-href": "canjs/can-view-href#master",
        "can-view-import": "canjs/can-view-import#master",
        "can-view-live": "canjs/can-view-live#master",
        "can-view-model": "canjs/can-view-model#master",
        "can-view-nodelist": "canjs/can-view-nodelist#master",
        "can-view-parser": "canjs/can-view-parser#master",
        "can-view-scope": "canjs/can-view-scope#master",
        "can-view-target": "canjs/can-view-target#master",
        "can-zone": "canjs/can-zone#master",
        "react-view-model": "canjs/react-view-model#master"
      },
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "can-make-map": "canjs/can-make-map#master",
        "can-test-helpers": "^1.0.1",
        "es6-promise": "^4.1.0",
        "feathers": "^2.0.3",
        "feathers-authentication-client": "^0.1.6",
        "feathers-hooks": "^1.7.1",
        "feathers-rest": "^1.5.0",
        "feathers-socketio": "^1.4.2",
        "funcunit": "^3.4.2",
        "github": "^11.0.0",
        "http-server": "^0.10.0",
        "jquery": "2.x - 3.x",
        "jquery-ui": "^1.12.0",
        "prop-types": "^15.5.10",
        "qunitjs": "^2.4.0",
        "react": "^16.0.0",
        "react-dom": "^16.0.0",
        "socket.io-client": "^1.7.2",
        "steal": "^1.5.5",
        "steal-conditional": "^0.4.0",
        "steal-css": "^1.2.4",
        "steal-qunit": "^1.0.1",
        "steal-stache": "canjs/steal-stache#master",
        "steal-tools": "^1.3.6",
        "test-saucelabs": "0.0.2",
        "testee": "^0.7.0"
      },
      "demos": [
        "http://canjs.us/#examples",
        "http://canjs.us/recipes"
      ],
      "googleAnalyticsTrackingCode": "UA-2302003-11",
      "licenses": [
        {
          "type": "MIT",
          "url": "http://opensource.org/licenses/mit-license.php"
        }
      ],
      "steal": {
        "npmAlgorithm": "flat",
        "main": "can",
        "npmIgnore": [
          "bit-docs",
          "testee",
          "async",
          "saucelabs",
          "test-saucelabs",
          "wd",
          "http-server"
        ],
        "meta": {
          "socket.io-client/dist/socket.io": {
            "format": "cjs"
          }
        },
        "configDependencies": [
          "./node_modules/steal-conditional/conditional.js"
        ]
      },
      "bit-docs": {
        "html": {
          "dependencies": {
            "normalize.css": "^5.0.0",
            "steal-conditional": "^0.3.6",
            "steal-stache": "^3.0.5"
          },
          "package": {
            "devDependencies": {
              "flexibility": "^2.0.1"
            },
            "steal": {
              "configDependencies": [
                "./node_modules/steal-conditional/conditional"
              ]
            }
          },
          "static": [],
          "templates": []
        },
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.6",
          "bit-docs-tag-sourceref": "^0.0.3",
          "bit-docs-generate-html": "^0.8.0",
          "bit-docs-generate-searchmap": "^0.2.0-pre.2",
          "bit-docs-html-canjs": "^1.2.0-pre.3",
          "bit-docs-prettify": "^0.1.1",
          "bit-docs-html-highlight-line": "^0.2.2",
          "bit-docs-tag-demo": "^0.3.0",
          "bit-docs-tag-package": "^0.0.5"
        },
        "glob": {
          "pattern": "{node_modules,docs}/{can-*,steal-stache,react-view-model}/**/*.{js,md}",
          "ignore": [
            "node_modules/can-wait/examples/**/*",
            "node_modules/can-*/dist/**/*",
            "node_modules/*/node_modules/**/*"
          ]
        },
        "altVersions": {
          "2.3.33": "https://v2.canjs.com"
        },
        "parent": "canjs",
        "minifyBuild": true
      }
    },
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "community": {
    "src": {
      "path": "docs/can-canjs/community.md"
    },
    "body": "\n<ul class=\"icon-list\">\n  <li>\n    <a href=\"https://gitter.im/canjs/canjs\" target=\"_blank\">\n      <img src=\"../docs/images/community/icon-gittr-gray.svg\">\n      Chat with us on Gitter\n    </a>\n  </li>\n  <li>\n    <a href=\"https://github.com/canjs/canjs\" target=\"_blank\">\n      <img src=\"../docs/images/community/icon-github-gray.svg\">\n      Star us on GitHub\n    </a>\n  </li>\n  <li>\n    <a href=\"http://stackoverflow.com/search?q=canjs\" target=\"_blank\">\n      <img src=\"../docs/images/community/icon-stackoverflow-gray.svg\">\n      Ask questions on Stack Overflow\n    </a>\n  </li>\n  <li>\n    <a href=\"https://forums.donejs.com/c/canjs\" target=\"_blank\">\n      <img src=\"../docs/images/community/icon-forums-gray.svg\">\n      Visit our forums\n    </a>\n  </li>\n  <li>\n    <a href=\"https://www.meetup.com/find/?keywords=canjs&radius=Infinity\" target=\"_blank\">\n      <img src=\"../docs/images/community/icon-meetup-gray.svg\">\n      Find a local Meetup group\n    </a>\n  </li>\n  <li>\n    <a href=\"https://www.youtube.com/channel/UCM_xC8UOHt2ay5wz-3gotmg\" target=\"_blank\">\n      <img src=\"../docs/images/community/icon-youtube-gray.svg\">\n      Watch videos on YouTube\n    </a>\n  </li>\n  <li>\n    <a href=\"https://twitter.com/canjs\" target=\"_blank\">\n      <img src=\"../docs/images/community/icon-twitter-gray.svg\">\n      Follow us on Twitter\n    </a>\n  </li>\n  <li>\n    <a href=\"https://www.bitovi.com/blog/topic/canjs\" target=\"_blank\">\n      <img src=\"../docs/images/community/icon-rss-gray.svg\">\n      Read our blog\n    </a>\n  </li>\n</ul>\n\n## Upcoming Events\n\n[DoneJS.com’s Upcoming Events](https://donejs.com/community.html#events) section has a list of meetup events in the near future!\n\n## Contribute to CanJS\n\nCheck out the [guides/contribute Contribution guide] for information on [guides/contributing/bug-report reporting bugs], [guides/contributing/feature-suggestion suggesting features], and more!\n\n## Support\n\nLooking for professional help in the form of development services, support, or training?\n\n[Bitovi](https://www.bitovi.com) is the primary corporate sponsor of CanJS. [Contact Bitovi](https://www.bitovi.com/contact) to find help for your project.\n\nIf your company offers CanJS consulting services, [edit this page on GitHub](https://github.com/canjs/canjs/edit/master/docs/can-canjs/community.md) and submit a pull request to add yourself.\n\n",
    "description": " Get involved with one of the most inviting communities on the internet!\n\n",
    "name": "community",
    "title": "Community",
    "type": "page",
    "parent": "canjs",
    "order": 3,
    "outline": "0",
    "comment": " "
  },
  "can-observables": {
    "name": "can-observables",
    "title": "Observables",
    "type": "group",
    "parent": "api",
    "description": "",
    "order": 1
  },
  "can-data-modeling": {
    "name": "can-data-modeling",
    "title": "Data Modeling",
    "type": "group",
    "parent": "api",
    "description": "",
    "order": 2
  },
  "can-views": {
    "name": "can-views",
    "title": "Views",
    "type": "group",
    "parent": "api",
    "description": "",
    "order": 3
  },
  "can-routing": {
    "name": "can-routing",
    "title": "Routing",
    "type": "group",
    "parent": "api",
    "description": "",
    "order": 4
  },
  "can-js-utilities": {
    "name": "can-js-utilities",
    "title": "JS Utilities",
    "type": "group",
    "parent": "api",
    "description": "",
    "order": 5
  },
  "can-dom-utilities": {
    "name": "can-dom-utilities",
    "title": "DOM Utilities",
    "type": "group",
    "parent": "api",
    "description": "",
    "order": 6
  },
  "can-data-validation": {
    "name": "can-data-validation",
    "title": "Data Validation",
    "type": "group",
    "parent": "api",
    "description": "",
    "order": 7
  },
  "can-typed-data": {
    "name": "can-typed-data",
    "title": "Typed Data",
    "type": "group",
    "parent": "api",
    "description": "",
    "order": 8
  },
  "can-polyfills": {
    "name": "can-polyfills",
    "title": "Polyfills",
    "type": "group",
    "parent": "api",
    "description": "",
    "order": 9
  },
  "api": {
    "src": {
      "path": "docs/can-canjs/can-api.md"
    },
    "body": "\n## Collections\n\nCanJS is made of many independent packages and modules.  Those packages and modules are\norganized within the following collections.  Read on to get an overview of each collection’s\npackages.  Please star what you like so we know where to put our effort.\n\n\n### [can-core Core Collection]\n\n_The best, most hardened and generally useful libraries in CanJS._\n\n<div class=\"module-list\">\n\n- **[can-compute]** <small><%can-compute.package.version%></small> Observable values and observable composite values\n  - `npm install can-compute --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-compute\">Star</a>\n- **[can-define]** <small><%can-define.package.version%></small> Observable objects\n  - `npm install can-define --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-define\">Star</a>\n- **[can-set]** <small><%can-set.package.version%></small> Service modeling\n  - `npm install can-set --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-set\">Star</a>\n- **[can-connect]** <small><%can-connect.package.version%></small> Data connection\n  - `npm install can-connect --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-connect\">Star</a>\n- **[can-stache]** <small><%can-stache.package.version%></small> Live binding templates\n  - `npm install can-stache --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stache\">Star</a>\n- **[can-component]** <small><%can-component.package.version%></small> Custom elements\n  - `npm install can-component --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-component\">Star</a>\n- **[can-stache-bindings]** <small><%can-stache-bindings.package.version%></small> View bindings\n  - `npm install can-stache-bindings --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stache-bindings\">Star</a>\n- **[can-route]** <small><%can-route.package.version%></small> Routing\n  - `npm install can-route --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-route\">Star</a>\n- **[can-route-pushstate]** <small><%can-route-pushstate.package.version%></small> Pushstate routing\n  - `npm install can-route-pushstate --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-route-pushstate\">Star</a>\n\n</div>\n\n### [can-infrastructure Infrastructure Collection]\n\n_Utility libraries that power the core collection._\n\n<div class=\"module-list\">\n\n- **[can-event]** <small><%can-event.package.version%></small> Event mixin\n  - `npm install can-event --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-event\">Star</a>\n- **[can-control]** <small><%can-control.package.version%></small> DOM widget constructor\n  - `npm install can-control --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-control\">Star</a>\n- **[can-util]** <small><%can-util.package.version%></small> Low-level JS and DOM utilities\n  - `npm install can-util --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-util\">Star</a>\n- **[can-construct]** <small><%can-construct.package.version%></small> Extensible constructors\n  - `npm install can-construct --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-construct\">Star</a>\n- **[can-observation]** <small><%can-observation.package.version%></small> Observation notification\n  - `npm install can-observation --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-observation\">Star</a>\n- **[can-simple-map]** <small><%can-simple-map.package.version%></small> Simple observable object\n  - `npm install can-simple-map --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-simple-map\">Star</a>\n- **[can-simple-observable]** <small><%can-simple-observable.package.version%></small> Create an observable value\n  - `npm install can-simple-observable --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-simple-observable\">Star</a>\n- **[can-view-callbacks]** <small><%can-view-callbacks.package.version%></small> Register custom elements or attributes in can-stache\n  - `npm install can-view-callbacks --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-callbacks\">Star</a>\n- **[can-view-model]** <small><%can-view-model.package.version%></small> Read a view-model from a custom element\n  - `npm install can-view-model --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-model\">Star</a>\n- **[can-view-scope]** <small><%can-view-scope.package.version%></small> Scope lookup\n  - `npm install can-view-scope --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-scope\">Star</a>\n- **[can-view-parser]** <small><%can-view-parser.package.version%></small> Parses HTML and magic tags\n  - `npm install can-view-parser --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-parser\">Star</a>\n- **[can-view-target]** <small><%can-view-target.package.version%></small> A fast-path DOM fragment compile target\n  - `npm install can-view-target --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-target\">Star</a>\n- **[can-view-live]** <small><%can-view-live.package.version%></small> Update the DOM with a compute\n  - `npm install can-view-live --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-live\">Star</a>\n- **[can-view-nodelist]** <small><%can-view-nodelist.package.version%></small> Maintains live-binding relationships\n  - `npm install can-view-nodelist --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-nodelist\">Star</a>\n- **[can-cid]** <small><%can-cid.package.version%></small> Get a unique identifier for objects\n  - `npm install can-cid --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-cid\">Star</a>\n- **[can-deparam]** <small><%can-deparam.package.version%></small> Deserialize a query string into an array or object\n  - `npm install can-deparam --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-deparam\">Star</a>\n- **[can-param]** <small><%can-param.package.version%></small> Serialize an array or object into a query string\n  - `npm install can-param --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-param\">Star</a>\n- **[can-types]** <small><%can-types.package.version%></small> A stateful container for CanJS type information\n  - `npm install can-types --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-types\">Star</a>\n- **[can-namespace]** <small><%can-namespace.package.version%></small> Namespace where can-* packages are registered\n  - `npm install can-namespace --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-namespace\">Star</a>\n- **[can-symbol]** <small><%can-symbol.package.version%></small> Symbols used to detail how CanJS may operate on different objects\n  - `npm install can-symbol --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-symbol\">Star</a>\n- **[can-reflect]** <small><%can-reflect.package.version%></small> Perform reflection on unknown data types\n  - `npm install can-reflect --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-reflect\">Star</a>\n- **[can-react-component]** <small><%can-react-component.package.version%></small> Create a React component out of a CanComponent.\n  - `npm install can-react-component --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-react-component\">Star</a>\n- **[react-view-model]** <small><%react-view-model.package.version%></small> Create an auto-rendering container component with an observable view-model.\n  - `npm install react-view-model --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/react-view-model\">Star</a>\n- **[can-ajax]** <small><%can-ajax.package.version%></small> jQuery-inspired AJAX request library.\n  - `npm install can-ajax --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-ajax\">Star</a>\n- **[can-globals]** <small><%can-globals.package.version%></small> An environment agnostic container for global variables.\n  - `npm install can-globals --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-globals\">Star</a>\n- **[can-define-lazy-value]** <small><%can-define-lazy-value.package.version%></small> An environment agnostic container for global variables.\n  - `npm install can-define-lazy-value --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-define-lazy-value\">Star</a>\n\n</div>\n\n### [can-ecosystem Ecosystem Collection]\n\n_Useful libraries that add important features or extend the core collection._\n\n<div class=\"module-list\">\n\n- **[can-fixture]** <small><%can-fixture.package.version%></small> Simulate AJAX requests\n  - `npm install can-fixture --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-fixture\">Star</a>\n- **[can-fixture-socket]** <small><%can-fixture-socket.package.version%></small> Simulate sockets\n  - `npm install can-fixture-socket --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-fixture-socket\">Star</a>\n- **[can-connect-feathers]** <small><%can-connect-feathers.package.version%></small> Create connections to a FeathersJS API server.\n  - `npm install can-connect-feathers --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-connect-feathers\">Star</a>\n- **[can-connect-signalr]** <small><%can-connect-signalr.package.version%></small> Create connections to a FeathersJS API server.\n  - `npm install can-connect-signalr --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-connect-signalr\">Star</a>\n- **[can-connect-cloneable]** <small><%can-connect-cloneable.package.version%></small> Make clones of Maps.\n  - `npm install can-connect-cloneable --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-connect-cloneable\">Star</a>\n- **[can-connect-ndjson]** <small><%can-connect-ndjson.package.version%></small> Create connection to an NDJSON stream service\n  - `npm install can-connect-ndjson --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-connect-ndjson\">Star</a>\n- **[can-zone]** <small><%can-zone.package.version%></small> Track asynchronous activity\n  - `npm install can-zone --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-zone\">Star</a>\n- **[can-stache-converters]** <small><%can-stache-converters.package.version%></small> Form two-way binding helpers\n  - `npm install can-stache-converters --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stache-converters\">Star</a>\n- **[steal-stache]** <small><%steal-stache.package.version%></small> Import can-stache templates as dependencies with [https://stealjs.com StealJS]\n  - `npm install steal-stache --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/steal-stache\">Star</a>\n- **[can-view-import]** <small><%can-view-import.package.version%></small> Import modules within can-stache templates\n  - `npm install can-view-import --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-import\">Star</a>\n- **[can-view-autorender]** <small><%can-view-autorender.package.version%></small> Automatically render templates in script tags\n  - `npm install can-view-autorender --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-autorender\">Star</a>\n- **[can-jquery]** <small><%can-jquery.package.version%></small> jQuery integrations\n  - `npm install can-jquery --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-jquery\">Star</a>\n- **[can-construct-super]** <small><%can-construct-super.package.version%></small> Call can-construct base methods easily\n  - `npm install can-construct-super --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-construct-super\">Star</a>\n- **[can-vdom]** <small><%can-vdom.package.version%></small> A virtual DOM that supports can-stache\n  - `npm install can-vdom --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-vdom\">Star</a>\n- **[can-kefir]** <small><%can-kefir.package.version%></small> Use streams in [can-stache].\n  - `npm install can-kefir --save`\n  - <a class=\"github-button\" href=\"<PROJECT_GITHUB_URL>\">Star</a>\n- **[can-stream-kefir]** <small><%can-stream-kefir.package.version%></small> Convert observable values into streams\n  - `npm install can-stream-kefir --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stream-kefir\">Star</a>\n- **[can-define-stream]** <small><%can-define-stream.package.version%></small> Define property values using streams\n  - `npm install can-define-stream --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-define-stream\">Star</a>\n- **[can-validate]** <small><%can-validate.package.version%></small> Validation tools and types definitions\n  - `npm install can-validate --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-validate\">Star</a>\n- **[can-validate-validatejs]** <small><%can-validate-validatejs.package.version%></small> Create validators with ValidateJS\n  - `npm install can-validate-validatejs --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-validate-validatejs\">Star</a>\n- **[can-define-validate-validatejs]** <small><%can-define-validate-validatejs.package.version%></small> Validation for DefineMaps using the ValidateJS library\n  - `npm install can-define-validate-validatejs --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-define-validate-validatejs\">Star</a>\n- **[can-ndjson-stream]** <small><%can-ndjson-stream.package.version%></small> Convert ndjson stream into a ReadableStream of JS objects\n  - `npm install can-ndjson-stream --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-ndjson-stream\">Star</a>\n- **[can-element]** <small><%can-element.package.version%></small> Create custom elements\n\t- `npm install can-element --save`\n\t- <a class=\"github-button\" href=\"https://github.com/canjs/can-element\">Star</a>\n\n</div>\n\n### [can-legacy Legacy Collection]\n\n_Former libraries that are not under active development, but we\nstill accept patches._\n\n<div class=\"module-list\">\n\n- **[can-map]** <small><%can-map.package.version%></small> Observable map\n  - `npm install can-map --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-map\">Star</a>\n- **[can-list]** <small><%can-list.package.version%></small> Observable lists\n  - `npm install can-list --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-list\">Star</a>\n- **[can-map-define]** <small><%can-map-define.package.version%></small> Define property behavior\n  - `npm install can-map-define --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-map-define\">Star</a>\n- **[can-map-backup]** <small><%can-map-backup.package.version%></small> Save the last state\n  - `npm install can-map-backup --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-map-backup\">Star</a>\n- **[can-ejs]** <small><%can-ejs.package.version%></small> EJS templates\n  - `npm install can-ejs --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-ejs\">Star</a>\n- **[can-view-href]** <small><%can-view-href.package.version%></small> Older routing view helpers\n  - `npm install can-view-href --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-href\">Star</a>\n- **[can-validate-legacy]** <small><%can-validate-legacy.package.version%></small> Validation plugin for can-map's.\n  - `npm install can-validate-legacy --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-validate-legacy\">Star</a>\n</div>\n\n## The `can` Package\n\nWhile CanJS is designed to be used and should be used\nas independent packages, we still publish a `can` package\nwith a version number, currently `<%canjs.package.version%>`.\nWe do this so there is a specified version of all of the\nsub-project packages that are __integration tested__ to work together.  \n\nThe `can` package uses [semantic versioning](http://semver.org/)\nwith respect to the [can-core] and [can-infrastructure] collections\nonly.  Read the [guides/contributing/releases Release Guide] for more information on CanJS’s release process.\n\nThe sub-project package versions for `can <%canjs.package.version%>`\nare listed below. Copy the ones you use into your `package.json`\nif you want to use the same packages that were tested as part of\nCanJS `<%canjs.package.version%>`’s release.\n\n__Core Collection__\n\n```\n  \"can-component\": \"<%can-component.package.version%>\",\n  \"can-compute\": \"<%can-compute.package.version%>\",\n  \"can-connect\": \"<%can-connect.package.version%>\",\n  \"can-define\": \"<%can-define.package.version%>\",\n  \"can-route\": \"<%can-route.package.version%>\",\n  \"can-route-pushstate\": \"<%can-route-pushstate.package.version%>\",\n  \"can-set\": \"<%can-set.package.version%>\",\n  \"can-stache\": \"<%can-stache.package.version%>\",\n  \"can-stache-bindings\": \"<%can-stache-bindings.package.version%>\",\n```  \n\n__Infrastructure Collection__\n\n```js\n  \"can-construct\": \"<%can-stache-bindings.package.version%>\",\n  \"can-control\": \"<%can-control.package.version%>\",\n  \"can-event\": \"<%can-event.package.version%>\",\n  \"can-observation\": \"<%can-observation.package.version%>\",\n  \"can-simple-map\": \"<%can-simple-map.package.version%>\",\n  \"can-simple-observable\": \"<%can-simple-observable.package.version%>\",\n  \"can-util\": \"<%can-util.package.version%>\",\n  \"can-view-callbacks\": \"<%can-view-callbacks.package.version%>\",\n  \"can-view-live\": \"<%can-view-live.package.version%>\",\n  \"can-view-model\": \"<%can-view-model.package.version%>\",\n  \"can-view-nodelist\": \"<%can-view-nodelist.package.version%>\",\n  \"can-view-parser\": \"<%can-view-parser.package.version%>\",\n  \"can-view-scope\": \"<%can-view-scope.package.version%>\",\n  \"can-view-target\": \"<%can-view-target.package.version%>\",\n```\n\n__Ecosystem collection__\n\n```\n  \"can-construct-super\": \"<%can-construct-super.package.version%>\",\n  \"can-define-stream\": \"<%can-define-stream.package.version%>\",\n  \"can-fixture\": \"<%can-fixture.package.version%>\",\n  \"can-fixture-socket\": \"<%can-fixture-socket.package.version%>\",\n  \"can-jquery\": \"<%can-jquery.package.version%>\",\n  \"can-stache-converters\": \"<%can-stache-converters.package.version%>\",\n  \"can-stream-kefir\": \"<%can-stream-kefir.package.version%>\",\n  \"can-vdom\": \"<%can-vdom.package.version%>\",\n  \"can-view-autorender\": \"<%can-view-autorender.package.version%>\",\n  \"can-view-import\": \"<%can-view-import.package.version%>\",\n  \"can-zone\": \"<%can-zone.package.version%>\",\n  \"steal-stache\": \"<%steal-stache.package.version%>\",\n```\n\n__Legacy Collection__\n\n```js\n  \"can-ejs\": \"<%can-ejs.package.version%>\",\n  \"can-list\": \"<%can-list.package.version%>\",\n  \"can-map\": \"<%can-map.package.version%>\",\n  \"can-map-backup\": \"<%can-map-backup.package.version%>\",\n  \"can-map-define\": \"<%can-map-define.package.version%>\",\n  \"can-view-href\": \"<%can-view-href.package.version%>\",\n```\n\n",
    "description": " Welcome to the CanJS API documentation! Learn about all the packages that make-up CanJS and how they work together to help you build amazing applications!\n\n",
    "name": "api",
    "title": "API Docs",
    "type": "page",
    "parent": "canjs",
    "order": 2,
    "outline": "1",
    "package": {
      "name": "can",
      "version": "3.11.0",
      "main": "can.js",
      "scripts": {
        "preversion": "npm test",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "testee": "testee test/index.html --browsers firefox",
        "testee-production": "testee test/production.html --browsers firefox",
        "http-server": "http-server -p 3000 --silent",
        "test": "npm run test-development && npm run test-production",
        "test-development": "npm run build && npm run testee",
        "test-production": "npm run build && npm run build-tests && npm run testee-production",
        "ci": "npm run build && npm run test && node test/test-sauce-labs.js",
        "release:pre": "npm version prerelease && npm run build && npm publish --tag=pre",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:major": "npm version major && npm run build && npm publish",
        "build": "node build.js",
        "build-tests": "node test/build.js",
        "document": "bit-docs",
        "document:force": "bit-docs -fd"
      },
      "title": "CanJS",
      "description": "MIT-licensed, client-side, JavaScript framework that makes building rich web applications easy.",
      "keywords": [
        "CanJS",
        "DoneJS"
      ],
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "web": "http://bitovi.com/"
      },
      "homepage": "http://canjs.com/",
      "repository": {
        "type": "git",
        "url": "git@github.com:canjs/canjs.git",
        "github": "https://github.com/canjs/canjs"
      },
      "dependencies": {
        "can-ajax": "canjs/can-ajax#master",
        "can-attribute-encoder": "canjs/can-attribute-encoder#master",
        "can-cid": "canjs/can-cid#master",
        "can-component": "canjs/can-component#master",
        "can-compute": "canjs/can-compute#master",
        "can-connect": "canjs/can-connect#master",
        "can-connect-cloneable": "canjs/can-connect-cloneable#master",
        "can-connect-feathers": "canjs/can-connect-feathers#master",
        "can-connect-ndjson": "canjs/can-connect-ndjson#master",
        "can-connect-signalr": "canjs/can-connect-signalr#master",
        "can-construct": "canjs/can-construct#master",
        "can-construct-super": "canjs/can-construct-super#master",
        "can-control": "canjs/can-control#master",
        "can-define": "canjs/can-define#master",
        "can-define-lazy-value": "canjs/can-define-lazy-value#master",
        "can-define-stream": "canjs/can-define-stream#master",
        "can-define-stream-kefir": "canjs/can-define-stream-kefir#master",
        "can-define-validate-validatejs": "canjs/can-define-validate-validatejs#master",
        "can-deparam": "canjs/can-deparam#master",
        "can-ejs": "canjs/can-ejs#master",
        "can-element": "canjs/can-element#master",
        "can-event": "canjs/can-event#master",
        "can-fixture": "canjs/can-fixture#master",
        "can-fixture-socket": "canjs/can-fixture-socket#master",
        "can-globals": "canjs/can-globals#master",
        "can-jquery": "canjs/can-jquery#master",
        "can-kefir": "canjs/can-kefir#master",
        "can-list": "canjs/can-list#master",
        "can-map": "canjs/can-map#master",
        "can-map-backup": "canjs/can-map-backup#master",
        "can-map-define": "canjs/can-map-define#master",
        "can-namespace": "canjs/can-namespace#master",
        "can-ndjson-stream": "canjs/can-ndjson-stream#master",
        "can-observation": "canjs/can-observation#master",
        "can-observe": "canjs/can-observe#master",
        "can-param": "canjs/can-param#master",
        "can-react-component": "canjs/can-react-component#master",
        "can-reflect": "canjs/can-reflect#master",
        "can-reflect-promise": "canjs/can-reflect-promise#master",
        "can-route": "canjs/can-route#master",
        "can-route-pushstate": "canjs/can-route-pushstate#master",
        "can-set": "canjs/can-set#master",
        "can-simple-dom": "canjs/can-simple-dom#master",
        "can-simple-map": "canjs/can-simple-map#master",
        "can-simple-observable": "canjs/can-simple-observable#master",
        "can-stache": "canjs/can-stache#master",
        "can-stache-bindings": "canjs/can-stache-bindings#master",
        "can-stache-converters": "canjs/can-stache-converters#master",
        "can-stache-key": "canjs/can-stache-key#master",
        "can-stream": "canjs/can-stream#master",
        "can-stream-kefir": "canjs/can-stream-kefir#master",
        "can-symbol": "canjs/can-symbol#master",
        "can-types": "canjs/can-types#master",
        "can-util": "canjs/can-util#master",
        "can-validate": "canjs/can-validate#master",
        "can-validate-legacy": "canjs/can-validate-legacy#master",
        "can-validate-validatejs": "canjs/can-validate-validatejs#master",
        "can-vdom": "canjs/can-vdom#master",
        "can-view-autorender": "canjs/can-view-autorender#master",
        "can-view-callbacks": "canjs/can-view-callbacks#master",
        "can-view-href": "canjs/can-view-href#master",
        "can-view-import": "canjs/can-view-import#master",
        "can-view-live": "canjs/can-view-live#master",
        "can-view-model": "canjs/can-view-model#master",
        "can-view-nodelist": "canjs/can-view-nodelist#master",
        "can-view-parser": "canjs/can-view-parser#master",
        "can-view-scope": "canjs/can-view-scope#master",
        "can-view-target": "canjs/can-view-target#master",
        "can-zone": "canjs/can-zone#master",
        "react-view-model": "canjs/react-view-model#master"
      },
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "can-make-map": "canjs/can-make-map#master",
        "can-test-helpers": "^1.0.1",
        "es6-promise": "^4.1.0",
        "feathers": "^2.0.3",
        "feathers-authentication-client": "^0.1.6",
        "feathers-hooks": "^1.7.1",
        "feathers-rest": "^1.5.0",
        "feathers-socketio": "^1.4.2",
        "funcunit": "^3.4.2",
        "github": "^11.0.0",
        "http-server": "^0.10.0",
        "jquery": "2.x - 3.x",
        "jquery-ui": "^1.12.0",
        "prop-types": "^15.5.10",
        "qunitjs": "^2.4.0",
        "react": "^16.0.0",
        "react-dom": "^16.0.0",
        "socket.io-client": "^1.7.2",
        "steal": "^1.5.5",
        "steal-conditional": "^0.4.0",
        "steal-css": "^1.2.4",
        "steal-qunit": "^1.0.1",
        "steal-stache": "canjs/steal-stache#master",
        "steal-tools": "^1.3.6",
        "test-saucelabs": "0.0.2",
        "testee": "^0.7.0"
      },
      "demos": [
        "http://canjs.us/#examples",
        "http://canjs.us/recipes"
      ],
      "googleAnalyticsTrackingCode": "UA-2302003-11",
      "licenses": [
        {
          "type": "MIT",
          "url": "http://opensource.org/licenses/mit-license.php"
        }
      ],
      "steal": {
        "npmAlgorithm": "flat",
        "main": "can",
        "npmIgnore": [
          "bit-docs",
          "testee",
          "async",
          "saucelabs",
          "test-saucelabs",
          "wd",
          "http-server"
        ],
        "meta": {
          "socket.io-client/dist/socket.io": {
            "format": "cjs"
          }
        },
        "configDependencies": [
          "./node_modules/steal-conditional/conditional.js"
        ]
      },
      "bit-docs": {
        "html": {
          "dependencies": {
            "normalize.css": "^5.0.0",
            "steal-conditional": "^0.3.6",
            "steal-stache": "^3.0.5"
          },
          "package": {
            "devDependencies": {
              "flexibility": "^2.0.1"
            },
            "steal": {
              "configDependencies": [
                "./node_modules/steal-conditional/conditional"
              ]
            }
          },
          "static": [],
          "templates": []
        },
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.6",
          "bit-docs-tag-sourceref": "^0.0.3",
          "bit-docs-generate-html": "^0.8.0",
          "bit-docs-generate-searchmap": "^0.2.0-pre.2",
          "bit-docs-html-canjs": "^1.2.0-pre.3",
          "bit-docs-prettify": "^0.1.1",
          "bit-docs-html-highlight-line": "^0.2.2",
          "bit-docs-tag-demo": "^0.3.0",
          "bit-docs-tag-package": "^0.0.5"
        },
        "glob": {
          "pattern": "{node_modules,docs}/{can-*,steal-stache,react-view-model}/**/*.{js,md}",
          "ignore": [
            "node_modules/can-wait/examples/**/*",
            "node_modules/can-*/dist/**/*",
            "node_modules/*/node_modules/**/*"
          ]
        },
        "altVersions": {
          "2.3.33": "https://v2.canjs.com"
        },
        "parent": "canjs",
        "minifyBuild": true
      }
    },
    "templateRender": [
      "<%",
      "%>"
    ],
    "subchildren": true,
    "comment": " "
  },
  "guides/experiment": {
    "name": "guides/experiment",
    "title": "experiment",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 2
  },
  "guides/getting-started": {
    "name": "guides/getting-started",
    "title": "getting started",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 3
  },
  "guides/contribute": {
    "name": "guides/contribute",
    "title": "Contributing",
    "type": "page",
    "parent": "canjs",
    "description": "Learn how to contribute to CanJS! \n",
    "order": 4,
    "src": {
      "path": "docs/can-guides/contribute/contribute.md"
    },
    "body": "\n## Overview\n\nThank you for your interest in contributing to CanJS! CanJS is maintained by\n[the DoneJS core team](https://donejs.com/About.html#core-team) but depends on\ncontributors like you! Whether you’re interested in [guides/contributing/finding-ways-to-contribute#Findingopenissues fixing issues],\n[guides/contributing/finding-ways-to-contribute#Gettinginvolvedinthecommunity answering questions],\nor [guides/contributing/evangelism spreading the word], we welcome you to our community!\n\nContributing to an open source project can be an intimidating experience. All\ncontributions from all types of contributors are welcome. We’re committed to\nmaking it as pleasant and rewarding as possible. We’re happy to set up a pairing\nsession to show you how to fix a bug or write a feature.\n\nIf you have any questions, you can always reach us on [Gitter chat](https://gitter.im/canjs/canjs).\n\n## Code of Conduct\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to make participation in our project and\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, gender identity and expression, level of experience,\nnationality, personal appearance, race, religion, or sexual identity and orientation.\n\n[Please read our Code of Conduct in its entirety before participating in our community.](https://github.com/donejs/donejs/blob/master/CODE_OF_CONDUCT.md)\n\n## Getting Help\n\n[Our forums](https://forums.donejs.com/c/canjs) and [Gitter chat](https://gitter.im/canjs/canjs)\nare the best places to ask questions. The core team regularly checks both and\nthere are other users who generously help others.\n\nIf you’re interested in contributing to CanJS, the core team is happy to pair\nwith you to fix a bug or write a new feature! Please either message us on Gitter\nor the forums, or leave a comment on the GitHub issue you’re interested in\nhelping with. We will happily walk you through setting up your development\nenvironment, creating a test and/or writing documentation, and submitting a pull\nrequest.\n\n",
    "comment": " "
  },
  "guides/upgrade": {
    "name": "guides/upgrade",
    "title": "upgrade",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 6
  },
  "guides": {
    "src": {
      "path": "docs/can-guides/Guides.md"
    },
    "body": "\n## Experimenting\n\nSo now you’ve decided to give CanJS a try.\nThe best place to start is the [guides/chat].\nIt’s only an hour and shows off CanJS’s best features while you build\na real-time chat application.  You build the whole thing in a JS&nbsp;Bin.\n\nNext, you’ll want to try the [guides/todomvc].  This takes about 1.5 hours and touches on\nevery core part of CanJS.  You can also follow the whole guide in a JS&nbsp;Bin.\n\nAfter that, check out the [guides/atm].  It takes about 2 hours and shows how to build and __test__\nan ATM. It also shows how to composite state.  The whole guide is done in a JS&nbsp;Bin.\n\nYou might also want to to go through DoneJS’s [Place My Order Guide](https://donejs.com/place-my-order.html).  This is an in-depth\nlook at how CanJS works within the context of a wide variety of other tools.  This guide takes\nabout 8 hours.\n\nFinally, when you’re just about to commit, read [guides/setup] to learn how to set up\nCanJS for your particular environment.\n\n## Commitment\n\nOnce you’ve committed to CanJS, it’s important that you keep liking it and\nget better at using it.  \n\nCanJS’s community has lots of people who can offer advice and tips on\nhow to build an application the right way. Instead of struggling,\nplease ask for advice on [Gitter chat](https://gitter.im/canjs/canjs) or the [forums](https://forums.donejs.com/c/canjs).  Share a screenshot of what you’re building\nand we’ll tell you what needs to be done.\n\nTo stay up on CanJS’s latest news, we suggest:\n\n - Following [@CanJS](https://twitter.com/canjs) on twitter.\n - Subscribing to Bitovi’s [development blog](https://www.bitovi.com/blog/topic/development).\n\nTo get hands-on instruction, sign up for a DoneJS meetup in your area:\n\n- [Boston](https://www.meetup.com/DoneJS-Boston/)\n- [Chicago](https://www.meetup.com/DoneJS-Chicago/)\n- [Ft. Lauderdale](https://www.meetup.com/DoneJS-Fort-Lauderdale/)\n- [Los Angeles](https://www.meetup.com/DoneJS-LA/)\n- [New York](https://www.meetup.com/DoneJS-NYC/)\n- [Phoenix](https://www.meetup.com/DoneJS-Phoenix/)\n- [Raleigh-Durham](https://www.meetup.com/DoneJS-raleigh-durham/)\n- [San Francisco](https://www.meetup.com/DoneJS-San-Francisco/)\n- [Seattle](https://www.meetup.com/DoneJS-Seattle/)\n- [Silicon Valley](https://www.meetup.com/DoneJS-Silicon-Valley/)\n\nIf you’ve already committed to CanJS and are looking to move to 3.0, read [migrate-3].\n\n## Contributing\n\nOnce you’ve settled down with CanJS, it’s time to think about adding extensions and improvements to the framework of your own. There are many ways to contribute to\nCanJS, including:\n\n - [guides/contributing/bug-report Report a bug]\n - [guides/contributing/feature-suggestion Suggest a feature]\n - [guides/contributing/code Code changes]\n - [guides/contributing/documentation Documentation improvements]\n - [Create a plugin](https://donejs.com/plugin.html)\n - [guides/contributing/evangelism Evangelism - Blog, meetup and conference talks]\n - [guides/contributing/releases Releases - Maintaining CanJS]\n\nCanJS is managed by the [DoneJS Contributors Team](https://donejs.com/About.html#team).\nAll contributions from all types of contributors are welcome. Contributing\nto an Open Source project can be an intimidating experience.  We’re\ncommitted to making the experience as pleasant and rewarding as possible.  We’re happy to set up a\npairing session to show you how to fix a bug or write a feature.  \n\nIf you have any questions, you can always reach us on [Gitter chat](https://gitter.im/canjs/canjs).\n\nIf you want to become a CanJS contributor, you simply have to:\n\n - [Email](mailto:contact@bitovi.com) the core team expressing your interest.\n - Attend the weekly DoneJS Contributors meeting twice a month. [DoneJS Calendar](https://www.google.com/calendar/embed?src=jupiterjs.com_g27vck36nifbnqrgkctkoanqb4%40group.calendar.google.com&ctz=America/Chicago).\n - Make one small contribution, even a spelling correction, a month.\n\nIssues that should be easy for a new contributor to pick up have an “easy” label. [This GitHub search](https://github.com/search?utf8=%E2%9C%93&q=user%3Acanjs+is%3Aopen+is%3Aissue+label%3AEasy&type=Issues) makes it easy to find easy issues across all the CanJS repositories.\n\n",
    "description": "Welcome to CanJS! These guides are here to help you develop and improve your relationship with CanJS. After all, picking a JavaScript framework is a commitment.  We want CanJS to be the framework you marry.  This page helps you know how to advance through the different stages of this relationship: \n",
    "name": "guides",
    "title": "Guides",
    "type": "page",
    "parent": "canjs",
    "order": 1,
    "subchildren": true,
    "comment": " "
  },
  "can-ajax": {
    "name": "can-ajax",
    "type": "module",
    "parent": "can-js-utilities",
    "src": {
      "line": 8,
      "codeLine": 66,
      "path": "node_modules/can-ajax/can-ajax.js"
    },
    "body": "\n",
    "description": "\nMake an asynchronous HTTP (AJAX) request.\n",
    "title": "can-ajax",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "collection": "can-infrastructure",
    "signatures": [
      {
        "code": "ajax( ajaxOptions )",
        "description": "\n\n   Is used to make an asynchronous HTTP (AJAX) request similar to [http://api.jquery.com/jQuery.ajax/jQuery.ajax].\n\n   ```\n   var ajax = require(\"can-ajax\");\n\n   ajax({\n     url: \"http://query.yahooapis.com/v1/public/yql\",\n     data: {\n       format: \"json\",\n       q: 'select * from geo.places where text=\"sunnyvale, ca\"'\n     }\n   }).then(function(response){\n     console.log( response.query.count ); // => 2\n   });\n   ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "ajaxOptions",
            "description": "Configuration options for the AJAX request.\n  - __url__ `{String}` The requested url.\n  - __type__ `{String}` The method of the request. Ex: `GET`, `PUT`, `POST`, etc. Capitalization is ignored. _Default is `GET`_.\n  - __data__ `{Object}` The data of the request. If data needs to be urlencoded (e.g. for GET requests or for CORS) it is serialized with [can-param].\n  - __dataType__ `{String}` Type of data. _Default is `json`_.\n  - __crossDomain__ `{Boolean}` If you wish to force a crossDomain request (such as JSONP) on the same domain, set the value of crossDomain to true. This allows, for example, server-side redirection to another domain. Default: `false` for same-domain requests, `true` for cross-domain requests.\n  - __xhrFields__ `{Object}` Any fields to be set directly on the xhr request, [https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest] such as the withCredentials attribute that indicates whether or not cross-site Access-Control requests should be made using credentials such as cookies or authorization headers.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that resolves to the data. The Promise instance is abortable and exposes an `abort` method. Invoking abort on the Promise instance indirectly rejects it.\n\n"
        }
      },
      {
        "code": "ajaxSetup( ajaxOptions )",
        "description": "\n\n   Is used to persist ajaxOptions across all ajax requests and they can be over-written in the ajaxOptions of the actual request.\n   [https://api.jquery.com/jquery.ajaxsetup/]\n\n   ```\n   var ajax = require(\"can-ajax\");\n\n   ajax.ajaxSetup({xhrFields: {withCredentials: true}});\n\n   ajax({\n     url: \"http://query.yahooapis.com/v1/public/yql\",\n     data: {\n       format: \"json\",\n       q: 'select * from geo.places where text=\"sunnyvale, ca\"'\n     }\n   }).then(function(response){\n     console.log( response.query.count ); // => 2\n   });\n   ```\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that resolves to the data. The Promise instance is abortable and exposes an `abort` method. Invoking abort on the Promise instance indirectly rejects it.\n\n"
    }
  },
  "can-cid": {
    "name": "can-cid",
    "type": "module",
    "parent": "can-typed-data",
    "src": {
      "line": 1,
      "codeLine": 29,
      "path": "node_modules/can-cid/can-cid.js"
    },
    "body": "",
    "description": "Utility for getting a unique identifier for an object. ",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-cid/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "1.0.0"
      },
      "deprecated": false,
      "description": "Utility for getting a unique identifier for an object",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "documentjs": "^0.4.2",
        "http-server": "^0.10.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "test-saucelabs": "0.0.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs",
        "plugin",
        "donejs"
      ],
      "main": "can-cid",
      "name": "can-cid",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-cid.git"
      },
      "scripts": {
        "build": "node build.js",
        "ci": "npm run build && npm run test && node test-saucelabs.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "http-server": "http-server -p 3000 --silent",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "1.1.2"
    },
    "signatures": [
      {
        "code": "cid(object, optionalObjectType)",
        "description": "\n\nGet a unique identifier for the object, optionally prefixed by a type name.\n\nOnce set, the unique identifier does not change, even if the type name\nchanges on subsequent calls.\n\n```js\nvar cid = require(\"can-cid\");\nvar x = {};\nvar y = {};\n\nconsole.log(cid(x, \"demo\")); // -> \"demo1\"\nconsole.log(cid(x, \"prod\")); // -> \"demo1\"\nconsole.log(cid(y));         // -> \"2\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "The object to uniquely identify."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "An optional type name with which to prefix the identifier\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the unique identifier\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "name",
      "description": "An optional type name with which to prefix the identifier\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the unique identifier\n"
    }
  },
  "can-assign": {
    "type": "module",
    "name": "can-assign",
    "parent": "can-infrastructure",
    "src": {
      "line": 0,
      "codeLine": 25,
      "path": "node_modules/can-assign/can-assign.js"
    },
    "body": "",
    "description": "",
    "title": "can-assign",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "assign(target, source)",
        "description": "\n\nA simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.\n\n```js\nvar assign = require(\"can-assign\");\n\nvar obj = {};\n\nassign(obj, {\n  foo: \"bar\"\n});\n\nconsole.log(obj.foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The destination object. This object's properties will be mutated based on the object provided as `source`."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "The source object whose own properties will be applied to `target`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the `target` argument.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "The source object whose own properties will be applied to `target`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the `target` argument.\n"
    }
  },
  "can-attribute-encoder": {
    "type": "module",
    "name": "can-attribute-encoder",
    "params": [
      {
        "name": "items",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "callback",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-dom-utilities",
    "src": {
      "line": 3,
      "codeLine": 17,
      "path": "node_modules/can-attribute-encoder/can-attribute-encoder.js"
    },
    "body": "\n",
    "description": "\nEncode and decode attribute names.\n",
    "title": "can-attribute-encoder",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "An",
            "description": "object with the methods:\n[can-attribute-encoder.encode] and [can-attribute-encoder.decode].\n\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-attribute-encoder/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-log": "^0.1.0",
        "can-namespace": "^1.0.0"
      },
      "deprecated": false,
      "description": "Encode / decode attributes for DOM elements",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.5",
        "steal": "^1.5.6",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.7.0",
        "testee": "^0.7.0"
      },
      "homepage": "https://canjs.com/",
      "keywords": [
        "canjs"
      ],
      "license": "MIT",
      "main": "can-attribute-encoder",
      "name": "can-attribute-encoder",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-attribute-encoder.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update version number\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-attribute-encoder",
        "npmIgnore": [
          "testee",
          "steal-tools"
        ]
      },
      "version": "0.3.2"
    }
  },
  "can-attribute-encoder.encode": {
    "type": "function",
    "name": "can-attribute-encoder.encode",
    "parent": "can-attribute-encoder",
    "src": {
      "line": 76,
      "codeLine": 97,
      "path": "node_modules/can-attribute-encoder/can-attribute-encoder.js"
    },
    "body": "\n```js\nvar encodedAttributeName = encoder.encode(\"{(^$foo/bar baz)}\");\ndiv.setAttribute(encodedAttributeName, \"attribute value\");\n```\n\n",
    "description": "Encode an attribute name \n",
    "title": "encode",
    "signatures": [
      {
        "code": "encoder.encode(attributeName)",
        "description": "\n\nNote: specific encoding may change, but encoded attributes\ncan always be decoded using [can-attribute-encoder.decode].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attributeName",
            "description": "The attribute name."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The encoded attribute name.\n\n"
        }
      }
    ],
    "comment": " ",
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attributeName",
      "description": "The attribute name."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The encoded attribute name.\n\n"
    }
  },
  "can-attribute-encoder.decode": {
    "type": "function",
    "name": "can-attribute-encoder.decode",
    "parent": "can-attribute-encoder",
    "src": {
      "line": 142,
      "codeLine": 159,
      "path": "node_modules/can-attribute-encoder/can-attribute-encoder.js"
    },
    "body": "\n```js\nencoder.decode(attributeName); // -> \"{(^$foo/bar baz)}\"\n\n```\n\n",
    "description": "Decode an attribute name encoded by [can-attribute-encoder.encode] ",
    "title": "decode",
    "signatures": [
      {
        "code": "encoder.decode(attributeName)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attributeName",
            "description": "The encoded attribute name."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The decoded attribute name.\n\n"
        }
      }
    ],
    "comment": " ",
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attributeName",
      "description": "The encoded attribute name."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The decoded attribute name.\n\n"
    }
  },
  "can-component": {
    "src": {
      "path": "node_modules/can-component/docs/component.md"
    },
    "body": "\n\n## Use\n\nTo create a Component, you must first [can-component.extend extend] `Component`\nwith the methods and properties of how your component behaves:\n\n```js\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\nvar HelloWorldVM = DefineMap.extend({\n    visible: {value: false},\n    message: {value: \"Hello There!\"}\n});\n\nComponent.extend({\n  tag: \"hello-world\",\n  view: stache(\"{{#if visible}}{{message}}{{else}}Click me{{/if}}\"),\n  ViewModel: HelloWorldVM,\n  events: {\n    click: function(){\n    \tthis.viewModel.visible = !this.viewModel.visible;\n    }\n  }\n});\n```\n\nThis element says “Click me” until a user clicks it and then\nsays “Hello There!”.  To create an instance of this component on the page,\nadd `<hello-world/>` to a [can-stache] view, render\nthe view, and insert the result in the page like:\n\n    var renderer = stache(\"<hello-world/>\");\n    document.body.appendChild(renderer({ }));\n\nCheck this out here:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/click_me.html'></div>\n\n\nTypically, you do not append a single component at a time.  Instead,\nyou'll render a view with many custom tags like:\n\n    <srchr-app>\n      <srchr-search models:from=\"models\">\n        <input name=\"search\"/>\n      </srchr-search>\n      <ui-panel>\n        <srchr-history/>\n        <srchr-results {models}=\"models\"/>\n      </ui-panel>\n    </srchr-app>\n\n### Defining a Component\n\nUse [can-component.extend] to define a `Component` constructor function\nthat automatically gets initialized whenever the component’s tag is\nfound.\n\nNote that inheriting from components works differently than other CanJS APIs. You\ncan’t call `.extend` on a particular component to create a “subclass” of that component.\n\nInstead, components work more like HTML elements. To reuse functionality from a base component, build on top of it with parent\ncomponents that wrap other components in their view and pass any needed viewModel properties via attributes.\n\n### Tag\n\nA component’s [can-component::tag tag] is the element node name that\nthe component will be created on.\n\n\nThe following matches `<hello-world>` elements.\n\n    Component.extend({\n      tag: \"hello-world\"\n    });\n\n### View\n\nA component’s [can-component::view view] is a template that is rendered as\nthe element’s innerHTML.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>Hello World</h1>\")\n    });\n\nChanges `<hello-world/>` elements into:\n\n    <hello-world><h1>Hello World</h1></hello-world>\n\nUse the [can-component/content] tag to position the custom element’s source HTML.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1><content/></h1>\")\n    });\n\nChanges `<hello-world>Hi There</hello-world>` into:\n\n    <hello-world><h1>Hi There</h1></hello-world>\n\n### ViewModel\n\nA component’s [can-component::ViewModel ViewModel] defines a constructor that creates\ninstances used to render the component’s view. The instance’s properties\nare typically set by attribute [can-stache-bindings data bindings] on the custom element.\nBy default, every data binding’s value is looked up in the parent [can-view-scope]\nof the custom element and added to the viewModel object.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\")\n    });\n\nChanges the following rendered view:\n\n    var renderer = stache(\"<hello-world message:from='greeting'/>\");\n    renderer({\n      greeting: \"Salutations\"\n    })\n\nInto:\n\n    <hello-world><h1>Salutations</h1></hello-world>\n\nDefault values can be provided. The following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\"),\n      viewModel: {\n        message: \"Hi\"\n      }\n    });\n\nChanges the following rendered view:\n\n    var renderer = stache(\"<hello-world/>\");\n    renderer({})\n\nInto:\n\n    <hello-world><h1>Hi</h1></hello-world>\n\nIf you want to set the string value of the attribute on the ViewModel,\nset an attribute without any binding syntax.\n\nThe following view, with the previous `hello-world` component:\n\n    var renderer = stache(\"<hello-world message='Howdy'/>\");\n    renderer({})\n\nRenders:\n\n    <hello-world><h1>Howdy</h1></hello-world>\n\n### Events\n\nA component’s [can-component::events events] object is used to listen to events (that are not\nlistened to with [can-stache-bindings view bindings]). The following component\nadds “!” to the message every time `<hello-world>` is clicked:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\"),\n      events: {\n        \"click\" : function(){\n          var currentMessage = this.viewModel.message;\n          this.viewModel.message = currentMessage+ \"!\";\n        }\n      }\n    });\n\nComponents have the ability to bind to special [can-util/dom/events/inserted/inserted],\n[can-component/beforeremove] and [can-util/dom/events/removed/removed] events\nthat are called when a component’s tag has been inserted into,\nis about to removed, or was removed from the page.\n\n### Helpers\n\nA component’s [can-component::helpers helpers] object provides [can-stache.helper stache helper] functions\nthat are available within the component’s view.  The following component\nonly renders friendly messages:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"{{#isFriendly message}}\"+\n                  \"<h1>{{message}}</h1>\"+\n                \"{{/isFriendly}}\"),\n      helpers: {\n        isFriendly: function(message, options){\n          if( /hi|hello|howdy/.test(message) ) {\n            return options.fn();\n          } else {\n            return options.inverse();\n          }\n        }\n      }\n    });\n\nGenerally speaking, helpers should only be used for view related functionality, like\nformatting a date.  Data related methods should be in the view model or models.\n\n## Examples\n\nCheck out the following examples built with `Component`.\n\n### Tabs\n\nThe following demos a tabs widget.  Click “Add Vegetables”\nto add a new tab.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/tabs.html'></div>\n\nAn instance of the tabs widget is created by creating `<my-tabs>` and `<my-panel>`\nelements like:\n\n    <my-tabs>\n      {{#each foodTypes}}\n        <my-panel title='title'>{{content}}</my-panel>\n      {{/each}}\n    </my-tabs>\n\nTo add another panel, all we have to do is add data to `foodTypes` like:\n\n    foodTypes.push({\n      title: \"Vegetables\",\n      content: \"Carrots, peas, kale\"\n    })\n\nThe secret is that the `<my-panel>` element listens to when it is inserted\nand adds its data to the tabs' list of panels with:\n\n    var vm = this.parentViewModel = canViewModel(this.element.parentNode);\n    vm.addPanel(this.viewModel);\n\n\n### TreeCombo\n\nThe following tree combo lets people walk through a hierarchy and select locations.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/treecombo.html'></div>\n\nThe secret to this widget is the viewModel’s `breadcrumb` property, which is an array\nof items the user has navigated through, and `selectableItems`, which represents the children of the\nlast item in the breadcrub.  These are defined on the viewModel like:\n\n\n    breadcrumb: [],\n    selectableItems: function(){\n      var breadcrumb = this.attr(\"breadcrumb\");\n\n      // if there’s an item in the breadcrumb\n      if(breadcrumb.attr('length')){\n\n        // return the last item’s children\n        return breadcrumb.attr(\"\"+(breadcrumb.length-1)+'.children');\n      } else{\n\n        // return the top list of items\n        return this.attr('items');\n      }\n    }\n\nWhen the “+” icon is clicked next to each item, the viewModel’s `showChildren` method is called, which\nadds that item to the breadcrumb like:\n\n    showChildren: function(item, ev) {\n      ev.stopPropagation();\n      this.attr('breadcrumb').push(item)\n    },\n\n### Paginate\n\nThe following example shows 3\nwidget-like components: a grid, next / prev buttons, and a page count indicator. And, it shows an application component that puts them all together.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate.html'></div>\n\nThis demo uses a `Paginate` [can-define/map/map] to assist with maintaining a paginated state:\n\n    var Paginate = DefineMap.extend({\n    ...\n    });\n\nThe `app` component, using [can-define/map/map], creates an instance of the `Paginate` model\nand a `websitesPromise` that represents a request for the Websites\nthat should be displayed.  Notice how the paginate’s `count` value is tied to the\nvalue of the `websitesPromise`’s resolved `value`’s `count`.\n\n```js\nvar AppViewModel = DefineMap.extend({\n\tpaginate: {\n\t\tvalue: function() {\n\t\t\treturn new Paginate({\n\t\t\t\tlimit: 5,\n\t\t\t\tcount: compute(this, \"websitesPromise.value.count\")\n\t\t\t});\n\t\t}\n\t},\n\twebsitesPromise: {\n\t\tget: function() {\n\t\t\tvar params = {\n\t\t\t\t\tlimit: this.paginate.limit,\n\t\t\t\t\toffset: this.paginate.offset\n\t\t\t\t},\n\t\t\t\twebsitesPromise = Website.getList(params),\n\t\t\t\tself = this;\n\n\t\t\twebsitesPromise.then(function(websites) {\n\t\t\t\tself.paginate.count = websites.length;\n\t\t\t});\n\n\t\t\treturn websitesPromise;\n\t\t}\n\t}\n});\n```\n\nThe `my-app` component passes paginate, paginate’s values, and websitesPromise to\nits sub-components:\n\n    <my-app>\n      <my-grid promiseData:from='websitesPromise'>\n        {{#each items}}\n          <tr>\n            <td width='40%'>{{name}}</td>\n            <td width='70%'>{{url}}</td>\n          </tr>\n        {{/each}}\n      </my-grid>\n      <next-prev paginate:from='paginate'></next-prev>\n      <page-count page:from='paginate.page' count:from='paginate.pageCount'/>\n    </my-app>\n\n",
    "description": "Create a custom element that can be used to manage widgets or application logic.\n\n",
    "name": "can-component",
    "type": "module",
    "title": "can-component",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "download": "can/component",
    "test": "can/component/test.html",
    "parent": "can-views",
    "collection": "can-core",
    "release": "2.0",
    "link": "../docco/component/component.html docco",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-component/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.3.1",
        "can-construct": "^3.2.0",
        "can-control": "^3.2.0",
        "can-globals": "^0.2.3",
        "can-namespace": "1.0.0",
        "can-observation": "^3.3.1",
        "can-reflect": "^1.2.1",
        "can-simple-map": "^3.3.0",
        "can-stache-bindings": "^3.4.0",
        "can-stache-key": "0.1.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.5",
        "can-view-callbacks": "^3.2.0",
        "can-view-model": "^3.4.0",
        "can-view-nodelist": "^3.1.0",
        "can-view-scope": "^3.3.1"
      },
      "deprecated": false,
      "description": "Custom elements for CanJS",
      "devDependencies": {
        "can-define": "^1.3.0",
        "can-event": "^3.5.0",
        "can-list": "^3.2.0",
        "can-map": "^3.3.1",
        "can-stache": "^3.3.0",
        "can-vdom": "^3.1.0",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.3.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-component",
      "name": "can-component",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-component.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.3.6"
    },
    "signatures": [
      {
        "code": "<TAG BINDINGS...>[TEMPLATES][LIGHT_DOM]</TAG>",
        "description": "\n\nCreate an instance of a component on a particular tag in a [can-stache] view.\nIn 2.3, use the [can-stache-bindings bindings] syntaxes to set up bindings.\n\nThe following creates a `my-autocomplete` element and passes the `my-autocomplete`'s\n[can-component.prototype.ViewModel] the `Search` model as its `source` property and\na [can-component/can-template] that is used to render the search results:\n\n```html\n<my-autocomplete source:from=\"Search\">\n  <can-template name=\"search-results\">\n    <li>{{name}}</li>\n  </can-template>\n</my-autocomplete>\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "TAG",
            "description": "An HTML tag name that matches the [can-component::tag tag]\nproperty of the component. Tag names should include a hypen (`-`) or a colon (`:`) like:\n`acme-tabs` or `acme:tabs`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache-bindings"
              }
            ],
            "optional": true,
            "name": "BINDINGS",
            "description": "Use the following binding syntaxes\nto connect the component’s [can-component::ViewModel] to the view's [can-view-scope scope]:\n\n - [can-stache-bindings.toChild]=[can-stache.expressions expression] — one-way data binding to child\n - [can-stache-bindings.toParent]=[can-stache.expressions expression] — one-way data binding to parent\n - [can-stache-bindings.twoWay]=[can-stache.expressions expression] — two-way data binding child to parent\n - [can-stache-bindings.event]=[can-stache/expressions/call expression] — event binding on the view model\n\n Note that because DOM attribute names are case-insensitive, use hypens (`-`) to\n in the attribute name to setup for `camelCase` properties.\n\n Example:\n\n ```\n <my-tag getChild:from=\"expression\"\n         setParent:to=\"expression\"\n         twoWay:bind=\"expression\"\n         on:event=\"callExpression()\"></my-tag>\n ```\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "TEMPLATES",
            "description": "Between the starting and ending tag\ncan exist one or many [can-component/can-template] elements.  Use to [can-component/can-template] elements\nto pass custom templates to child components.  Each `<can-template>`\nis given a `name` attribute and can be rendered by a corresponding [can-component/can-slot]\nin the component's [can-component.prototype.view].\n\nFor example, the following passes how each search result should look and an error message if\nthe source is unable to request data:\n\n```html\n<my-autocomplete source:from=\"Search\">\n  <can-template name=\"search-results\">\n    <li>{{name}}</li>\n  </can-template>\n  <can-template name=\"search-error\">\n    <div class='error'>{{message}}</div>\n  </can-template>\n</my-autocomplete>\n```\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "LIGHT_DOM",
            "description": "The content between the starting and ending\ntag. For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `LIGHT_DOM` can be positioned with a component’s [can-component.prototype.view] with\nthe [can-component/content] element.  The data accessible to the `LIGHT_DOM` can be controlled\nwith [can-component.prototype.leakScope].\n\n"
          }
        ],
        "release": "2.3"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "LIGHT_DOM",
      "description": "The content between the starting and ending\ntag. For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `LIGHT_DOM` can be positioned with a component’s [can-component.prototype.view] with\nthe [can-component/content] element.  The data accessible to the `LIGHT_DOM` can be controlled\nwith [can-component.prototype.leakScope].\n\n"
    },
    "comment": " "
  },
  "can-compute": {
    "src": {
      "path": "node_modules/can-compute/docs/compute.md"
    },
    "body": "\n## Use\n\n`can-compute` exports a function that lets you make an observable value.  The following\nmakes an observable `age` compute whose value changes from `33` to `34`:\n\n```js\nvar compute = require(\"can-compute\");\n\nvar age = compute(33);\nage(); // 33\n\nage.on(\"change\",function(ev, newVal, oldVal){\n\tnewVal //-> 34\n\toldVal //-> 33\n})\n\nage(34);\nage(); // 33\n```\n\nComputes are similar\nto observable maps like [can-define/map/map], but they represent a single value rather than a collection of values.\n\nComputes can derive their value from other computes, maps and lists.\nWhen the derived values change, the compute's value will be automatically updated.  This\nis `can-compute`'s best feature.  For example, the following combines the age\ncompute in the previous example, and a `name` compute into an `info` compute:\n\n```js\nvar age = compute(33),\n\tname = compute(\"Justin\"),\n\tinfo = compute(function(){\n\t\treturn name() +\" is \"+age()+\".\"\n\t});\n\ninfo() //-> \"Justin is 33.\"\n```\n\nIf we listen to [can-compute.computed.ChangeEvent] on `info`, if either `age` or `name`\nchanges, `info` will be updated automatically:\n\n```js\ninfo.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Justin is 34.\"\n});\n\nage(34)\n```\n\nComputes are similar to event streams like `Bacon.js` or `RXJS`.  However, computes\nare easier to compose values because:\n\n - you can just read other observables and computes and return a value.  \n - you don't have to manage subscribing and merging streams yourself.\n\nAlso, computes can also have [can-event/batch/batch batched updates] to prevent unnecessary\nupdates. For example, if both `age` and `name` were changed at the same time, we\ncould prevent `info` from updating twice with:\n\n```js\nvar canBatch = require(\"can-event/batch/batch\");\n\ncanBatch.start();\nage(35)\nname(\"Justin Meyer\")\ncanBatch.stop();\n```\n\nThere are a wide variety of ways to create computes. Read on to understand the basics.\n\n## Observing a value\n\nThe simplest way to use a compute is to have it store a single value, and to set it when\nthat value needs to change:\n\n```\nvar tally = compute(12);\ntally(); // 12\n\ntally.on(\"change\",function(ev, newVal, oldVal){\n    console.log(newVal,oldVal)\n})\n\ntally(13);\ntally(); // 13\n```\n\nAny value can be observed.  The following creates a compute\nthat holds an object and then changes it to an array.\n\n```js\nvar data = compute({name: \"Justin\"})\ndata([{description: \"Learn Computes\"}])\n```\n\n\n## Derived computes\n\nIf you use a compute that derives its\nvalue from properties of an observable map or other [can-compute]s, the compute will listen for changes in those\nproperties and automatically recalculate itself, emitting a _change_ event if its value\nchanges.\n\nThe following example shows creating a `fullName` compute\nthat derives its value from two properties on the `person` observe:\n\n```js\nvar person = new Person({\n\tfirstName: 'Alice',\n\tlastName: 'Liddell'\n});\n\nvar fullName = compute(function() {\n\treturn person.firstName + ' ' + person.lastName;\n});\n\nfullName.on('change', function(ev, newVal, oldVal) {\n\t\tconsole.log(\"This person's full name is now \" + newVal + '.');\n});\n\nperson.firstName = 'Allison'; // The log reads:\n//-> \"This person's full name is now Allison Liddell.\"\n```\n\nBecause Person is an observable [can-define/map/map] can-compute knows to listen for changes because the map's firstName and lastName properties are read.\n\n## Translator computes - computes that update their derived values\n\nSometimes you need a compute to be able to translate one value to another. For example,\nconsider a widget that displays and allows you to update the progress in percent\nof a task. It accepts a compute with values between 0 and 100. But,\nour task observe has progress values between 0 and 1 like:\n\n```js\nvar task = new DefineMap({\n\tprogress: 0.75\n});\n```\n\nUse `compute( getterSetter )` to create a compute that updates itself\nwhen task's `progress` changes, but can also update progress when\nthe compute function is called with a value.  For example:\n\n```js\nvar progressPercent = compute(function(percent){\n\tif(arguments.length){\n\t\ttask.progress = percent / 100;\n\t} else {\n\t\treturn task.progress * 100;\n\t}\n})\n\nprogressPercent() // -> 75\n\nprogressPercent(100)\n\ntask.progress; // -> 1\n```\n\n\nThe following is a similar example that shows converting feet into meters and back:\n\n```js\nvar wall = new DefineMap({\n    material: 'brick',\n    length: 10 // in feet\n});\n\nvar wallLengthInMeters = compute(function(lengthInM) {\n\tif(arguments.length) {\n\t\twall.length = lengthInM / 3.28084;\n\t} else {\n\t\treturn wall.length * 3.28084;\n\t}\n});\n\nwallLengthInMeters(); // 3.048\n\n// When you set the compute...\nwallLengthInMeters(5);\nwallLengthInMeters(); // 5\n\n// ...the original map changes too.\nwall.length;          // 16.4042\n```\n\n## Events\n\nWhen a compute's value is changed, it emits a [can-compute.computed.ChangeEvent] event. You can listen for this change\nevent by using `on` to bind an event handler to the compute:\n\n```js\nvar tally = compute(0);\ntally.on('change', function(ev, newVal, oldVal) {\n    console.log('The tally is now at ' + newVal + '.');\n});\n\ntally(tally() + 5); // The log reads:\n                    // 'The tally is now at 5.'\n```\n\n## Caching values\n\nA compute that has an event listener will cache its value and only update when one of its source observables change.\n\nFor example:\n\n```js\nvar foo = {\n\tfirst: \"Wonder\"\n};\nvar last = compute(\"Woman\");\nvar hero = {\n\tfullName: compute(function() {\n\t\treturn foo.first + ' ' + last();\n\t})\n}\nhero.fullName.on('change', function() {}); // bind to compute\nconsole.log(hero.fullName()); // console.logs \"Wonder Woman\"\nfoo.first = \"Super\";\nconsole.log(hero.fullName()); // console.logs \"Wonder Woman\" because the source observable (last) hasn't changed\nlast(\"Man\");\nconsole.log(hero.fullName()); // console.logs \"Super Man\" because fullName updates its value now after hearing the change on \"last\"\n```\nIn contrast, if we didn't bind to the compute:\n\n```js\nvar foo = {\n\tfirst: \"Wonder\"\n};\nvar last = compute(\"Woman\");\nvar hero = {\n\tfullName: compute(function() {\n\t\treturn foo.first + ' ' + last();\n\t})\n}\nconsole.log(hero.fullName()); // console.logs \"Wonder Woman\"\nfoo.first = \"Super\";\nconsole.log(hero.fullName()); // console.logs \"Super Woman\" because fullName did not cache its previous value\nlast(\"Man\");\nconsole.log(hero.fullName()); // console.logs \"Super Man\"\n```\n\n",
    "description": "Create an observable value. \n",
    "name": "can-compute",
    "type": "module",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-observables",
    "collection": "can-infrastructure",
    "release": "1.1",
    "link": "../docco/compute/compute.html docco",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-compute/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.1.1",
        "can-event": "^3.7.0",
        "can-namespace": "1.0.0",
        "can-observation": "^3.3.1",
        "can-reflect": "^1.2.1",
        "can-stache-key": "0.1.0",
        "can-symbol": "^1.0.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "compose observables",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-compute",
      "name": "can-compute",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-compute.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.3.9"
    },
    "signatures": [
      {
        "code": "compute(getterSetter[, context])",
        "description": "\n\nCreate a compute that derives its value from other observables. Uses [can-observation] to call the `getterSetter` and track observables.\n\n```js\nvar age = compute(32);\n\nvar nameAndAge = compute(function(){\n\treturn \"Matthew - \" + age();\n});\n\nconsole.log(nameAndAge()); // -> Matthew - 32\n\nage(33);\n\nconsole.log(nameAndAge()); // -> Matthew - 33\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*+"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*+"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "name": "getterSetter",
            "description": "A function that gets, and optionally sets, the value of the compute. When called with no arguments, _getterSetter_ should return the current value of the compute. When called with a single argument, _getterSetter_ should arrange things so that the next read of the compute produces that value. This compute will automatically update its value when any observables values are read.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "The `this` to use when calling the `getterSetter` function.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n\n"
        }
      },
      {
        "code": "compute(initialValue [, settings])",
        "description": "\n\nCreates a compute from a value and optionally specifies how to read, update, and\nlisten to changes in dependent values. This form of compute can be used to\ncreate a compute that derives its value from any source.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "initialValue",
            "description": "The initial value of the compute. If `settings` is\nnot provided, the compute simply updates its value to whatever the first argument\nto the compute is.\n\n    var age = compute(30);\n    age() //-> 30\n    age(31) //-> fires a \"change\" event\n"
          },
          {
            "types": [
              {
                "type": "can-compute.computeSettings"
              }
            ],
            "optional": true,
            "name": "settings",
            "description": "\n\nConfigures all behaviors of the [can-compute.computed]. The following cross\nbinds an input element to a compute:\n\n```js\nvar input = document.getElementById(\"age\")\nvar value = compute(\"\",{\n\tget: function(){\n\t\treturn input.value;\n\t},\n\tset: function(newVal){\n\t\tinput.value = newVal;\n\t},\n\ton: function(updated){\n\t\tinput.addEventListener(\"change\", updated, false);\n\t},\n\toff: function(updated){\n\t\tinput.removeEventListener(\"change\", updated, false);\n\t}\n})\n```\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The new compute.\n\n"
        }
      },
      {
        "code": "compute(initialValue, setter(newVal,oldVal))",
        "description": "\n\nCreate a compute that has a setter that can adjust incoming new values.\n\n```js\nvar age = compute(6,function(newVal, oldVal){\n\tif(!isNaN(+newVal)){\n\t\treturn +newVal;\n\t} else {\n\t\treturn oldVal;\n\t}\n});\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "initialValue",
            "description": "\n\nThe initial value of the compute.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "name": "setter",
            "description": "\n\nA function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can-compute.computed] and the current value. If\n`set` returns a value, it is used to compare to the current value of the compute. Otherwise,\n`get` is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n"
        }
      },
      {
        "code": "compute(object, propertyName [, eventName])",
        "description": "\n\nCreate a compute from an object's property value. This short-cut\nsignature lets you create a compute on objects that have events\nthat can be listened to with [can-compute.computed.on].\n\n```js\nvar input = document.getElementById('age')\nvar age = compute(input,\"value\",\"change\");\n\nvar me = new DefineMap({name: \"Justin\"});\nvar name = compute(me,\"name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "An object that has an `addEventListener` method and events dispatched on it.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The property value to read on `object`.  The\nproperty will be read via `object.attr(propertyName)` or `object[propertyName]`.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "eventName",
            "defaultValue": "propertyName",
            "description": "Specifies the event name to listen\nto on `object` for `propertyName` updates.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A new compute.\n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "eventName",
      "defaultValue": "propertyName",
      "description": "Specifies the event name to listen\nto on `object` for `propertyName` updates.\n"
    },
    "comment": " "
  },
  "connect": {
    "type": "function",
    "name": "connect",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "String"
                  }
                ]
              },
              {
                "types": [
                  {
                    "type": "Behavior"
                  }
                ]
              },
              {
                "types": [
                  {
                    "type": "function",
                    "returns": {
                      "types": [
                        {
                          "type": "undefined"
                        }
                      ]
                    },
                    "params": []
                  }
                ]
              }
            ]
          }
        ],
        "name": "behaviors",
        "description": "- An array of behavior names or custom behaviors.\nThe order of named execution gets run in order."
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "options",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect/connect.js",
    "src": {
      "line": 1,
      "codeLine": 8,
      "path": "node_modules/can-connect/connect.js"
    },
    "body": "",
    "description": "\n",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": ""
    },
    "hide": true
  },
  "can-connect.behaviors": {
    "name": "can-connect.behaviors",
    "title": "behaviors",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 1
  },
  "can-connect.modules": {
    "name": "can-connect.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 2
  },
  "can-connect.types": {
    "name": "can-connect.types",
    "title": "data types",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 3
  },
  "can-connect": {
    "src": {
      "path": "node_modules/can-connect/can-connect.md"
    },
    "body": "\n`can-connect` includes behaviors that:\n\nLoad data:\n\n - [can-connect/data/url/url data/url] — \n    Persist data to RESTful or other types of HTTP services.\n    \n - [can-connect/data/parse/parse data/parse] — \n    Convert response data into a format needed for other extensions.\n\nConvert data into special types:\n\n - [can-connect/constructor/constructor constructor/] —\n    Create instances of a provided constructor function or list type.\n    \n - [can-connect/constructor/store/store constructor/store] — \n    Prevent multiple instances of a given id or multiple lists of a given set from being created.\n\nKeep lists updated with the most current data:\n\n - [can-connect/real-time/real-time real-time] — \n    Lists updated when instances are created or deleted.\n\nImplement caching strategies:\n\n - [can-connect/fall-through-cache/fall-through-cache fall-through-cache] — \n    Use [connection.cacheConnection cache] data if possible when creating instances, \n    then update the instance with server data upon completion of a background request.\n    \n - [can-connect/cache-requests/cache-requests cache-requests] — \n    Cache response data and use it for future requests.\n    \n - [can-connect/data/combine-requests/combine-requests data/combine-requests] — \n    Combine overlapping or redundant requests.\n\nProvide caching storage (as a [connection.cacheConnection cacheConnection]):\n\n - [can-connect/data/localstorage-cache/localstorage-cache data/localstorage-cache] — \n    LocalStorage caching connection.\n    \n - [can-connect/data/memory-cache/memory-cache data/memory-cache] — \n    In-memory caching connection.\n\nGlue certain behaviors together:\n\n - [can-connect/data/callbacks/callbacks data/callbacks] — \n    Add callback hooks are passed the results of the DataInterface methods (CRUD operations).\n    \n - [can-connect/data/callbacks-cache/callbacks-cache data/callbacks-cache] — \n    Handle [can-connect/data/callbacks/callbacks data/callbacks] and update the [connection.cacheConnection cache] \n    when CRUD operations complete.\n\nProvide convenient integration with CanJS:\n\n - [can-connect/can/map/map can/map] — \n    Create [can-define/map/map] or [can-define/list/list] instances from responses. Adds connection-aware \n    methods to configured types.\n    \n - [can-connect/can/ref/ref can/ref] - Handle references to other instances in the raw data responses.  \n \n - [can-connect/can/merge/merge can/merge] - Minimize updates to deeply nested instance data when new data is \n    returned from the server.\n    \n - [can-connect/can/constructor-hydrate/constructor-hydrate can/constructor-hydrate] - Always check the \n    instanceStore when creating new instances of the connection Map type.\n \n`can-connect` also provides several other non-behavior utilities for connection ease of use in CanJS:\n - [can-connect/can/super-map/super-map] — Create a connection for [can-define/map/map can-define/map] or \n    [can-define/list/list can-define/list] types using nearly all behaviors.\n    \n - [can-connect/can/model/model] — Create [can-map] types that emulate the interface of \n    [can.Model](http://v2.canjs.com/docs/can.Model.html). Used for CanJS 2.x migrations.\n     \n - [can-connect/can/tag/tag] — Create a custom element that can load data into a template.\n\n\n## Overview\n\nThe `can-connect` module exports a `connect` function that is used to assemble different behaviors (plugins)\nand some configuration options into a `connection`.  For example, the following uses `connect` and the \n[can-connect/constructor/constructor constructor/constructor] and [can-connect/data/url/url data/url] behaviors \nto create a `todoConnection` connection:\n\n```js\nvar connect = require(\"can-connect\");\nvar constructor = require(\"can-connect/constructor/\");\nvar dataUrl = require(\"can-connect/data/url/\");\n\nvar todoConnection = connect(\n  [constructor, dataUrl],\n  { url: \"/services/todos\" }\n);\n```\n\nA typical connection provides the ability to create, read, update, or delete (CRUD) data hosted by some data \nsource. Those operations are usually performed via the connection [can-connect/InstanceInterface InstanceInterface]\nmethods:\n\n - [can-connect/connection.get]\n - [can-connect/connection.getList]\n - [can-connect/connection.save]\n - [can-connect/connection.destroy]\n\nFor example, to get all todos from \"GET /services/todos\", we could write the following:\n\n```js\ntodoConnection.getList({}).then(function(todos){ ... });\n```\n\n__Behaviors__, like [can-connect/constructor/constructor constructor/constructor] and [can-connect/data/url/url data/url] \nimplement, extend, or require some set of [interfaces](#Interfaces).  For example, [can-connect/data/url/url data/url] \nimplements the [can-connect/DataInterface DataInterface] methods, and [can-connect/constructor/constructor constructor/constructor] implements \nthe [can-connect/InstanceInterface InstanceInterface] methods.\n\nThe `connect` method arranges these behaviors in the right order to create a connection. For instance, the \n[can-connect/cache-requests/cache-requests cache-requests] behavior must be applied after the [can-connect/data/url/url data/url]\nconnection.  This is because [can-connect/cache-requests/cache-requests cache-requests], overwrites [can-connect/data/url/url data/url]’s\n[can-connect/connection.getListData connection.getListData] method to first check the cache for the data.  Only if the \ndata is not found, does it call [can-connect/data/url/url data/urls]’s [can-connect/connection.getListData]. \n\nThis behavior arranging makes it so even if we write:\n\n```js\nvar dataUrl = require(\"can-connect/data/url/\");\nvar cacheRequests = require(\"can-connect/cache-requests/\");\nconnect([cacheRequests, dataUrl])\n```\n\nor\n\n```\nconnect([dataUrl, cacheRequests])\n```\n\n... the connection will be built in the right order!\n\nA __connection__ is just an object with each specified behavior on its prototype chain and the passed options object \nat the end of the prototype chain.\n\n\n### Basic Use\n\nWhen starting out with `can-connect`, it’s advisable to start out with the most basic behaviors: \n[can-connect/data/url/url data/url] and [can-connect/constructor/constructor constructor/constructor]. \n[can-connect/data/url/url data/url] adds an implementation of the [can-connect/DataInterface DataInterface] that connects to a RESTful data source. \n[can-connect/constructor/constructor constructor/constructor] adds an implementation of the [can-connect/InstanceInterface InstanceInterface] \nthat can create, read, update and delete typed data via the lower-level [can-connect/DataInterface DataInterface].\n\nBy \"typed\" data we mean data that is more than just plain JavaScript objects.  For example, we want might to create \n`Todo` objects that implement an `isComplete` method:\n\n```js\nvar Todo = function(props){\n  Object.assign(this, props);\n};\n\nTodo.prototype.isComplete = function(){\n  return this.status === \"complete\";\n};\n```\n\nAnd, we might want a special `TodoList` type with implementations of `completed` and `active` methods:\n\n```js\nvar TodoList = function(todos){\n  [].push.apply(this, todos);\n};\nTodoList.prototype = Object.create(Array.prototype);\n\nTodoList.prototype.completed = function(){\n  return this.filter(function(todo){\n    return todo.status === \"complete\";\n  });\n};\n\nTodoList.prototype.active = function(){\n  return this.filter(function(todo){\n    return todo.status !== \"complete\";\n  });\n};\n```\n\nWe can create a connection that connects a RESTful \"/api/todos\" endpoint to `Todo` instances and `TodoList` lists like:\n\n```js\nvar todoConnection = connect(\n  [constructor, dataUrl],\n  {\n    url: \"/api/todos\",\n    list: function(listData, setInfo){\n  \t  return new TodoList(listData.data);\n    },\n    instance: function(data) {\n  \t  return new Todo(data);\n    }\n  }\n);\n```\n\nand then use that connection to get a `TodoList` of `Todo`s and render some markup:\n\n```js\ntodoConnection.getList({}).then(function(todos){\n\tvar todosEl = document.getElementById(\"todos-list\");\n\t\n\ttodosEl.innerHTML = \n\t    \"<h2>Active</h2>\" + render(todos.active()) +\n\t\t\"<h2>Complete</h2>\" + render(todos.completed());\n});\n\nvar render = function(todos) {\n    var todoListItems = todos.map(function(todo){\n        return \"<li>\" +\n            todo.name + \"<input type='checkbox' \" + (todo.isComplete() ? \"checked\" : \"\") + \"/>\" + \n        \"</li>\";\n    }); \n\n\treturn \"<ul>\"+todoListItems.join(\"\")+\"</ul>\";\n};\n```\n\nThe following demo shows the result:\n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/basics.html'></div>\n\nThis connection also lets you create, update, and destroy a Todo instance as follows:\n\n```js\nvar todo = new Todo({\n  name: \"take out trash\"\n})\n\n// POSTs to /api/todos with JSON request body {name:\"take out trash\"}\n// server returns {id: 5}\ntodoConnection.save( todo ).then(function(todo){\n  todo.id //-> 5\n  todo.name = 'take out garbage'\n\n  // PUTs to /api/todos/5 with JSON request body {name:\"take out garbage\"}\n  // server returns {id: 5, name:\"take out garbage\"}\n  todoConnection.save( todo ).then( function(todo){\n\n    // DELETEs to /api/todos/5\n    // server returns {}\n    todoConnection.destroy( todo ).then( function(todo){\n\n    });\n  });\n});\n```\n\n### Behavior Configuration\n\nWhenever `connect` creates a connection, it always adds the [can-connect/base/base base] behavior. \nThis behavior is where the configuration options passed to `connect` are stored and it also defines \nseveral configurable options that are used by most other behaviors.  For example, if your backend\nuses a property named `_id` to uniquely identify todos, you can specify this with \n[can-connect/base/base.idProp idProp] like:\n\n```js\nvar constructor = require(\"can-connect/constructor/\"); \nvar dataUrl = require(\"can-connect/data/url/\");\nvar todoConnection = connect(\n  [constructor, dataUrl],\n  {\n    url: \"/api/todos\",\n    idProp: \"_id\"\n  }\n);\n```\n\nBehaviors list their configurable options in their own documentation pages.  \n\n### Behavior Overwriting\n\nIf the configuration options available for a behavior are not enough, it's possible to overwrite any \nbehavior with your own behavior.\n\nFor example, [can-connect/constructor/constructor constructor/constructor]’s \n[can-connect/constructor/constructor.updatedInstance updatedInstance] method sets the instance’s \nproperties to match the result of [can-connect/connection.updateData updateData]. But if the \n`PUT /api/todos/5 {name:\"take out garbage\"\"}` request returns `{}`, the following example would \nresult in a todo with only an `id` property:\n\n```js\nvar todo = new Todo({id: 5, name: \"take out garbage\"});\n\n// PUTs to /api/todos/5 with JSON request body {name:\"take out garbage\"}\n// server returns {}\ntodoConnection.save( todo ).then( function(todo){\n  todo.id //-> 5\n  todo.name //-> undefined\n});\n```\n\nThe following overwrites [can-connect/constructor/constructor constructor/constructor]’s \nimplementation of `updateData`:\n\n```js\nvar constructor = require(\"can-connect/constructor/\"); \nvar dataUrl = require(\"can-connect/data/url/\");\nvar mergeDataBehavior = {\n  updateData: function(instance, data){\n    Object.assign(instance, data);\n  }\n};\n\nvar todoConnection = connect([\n    constructor,\n    dataUrl\n    mergeDataBehavior\n  ],{\n    url: \"/api/todos\"\n});\n```\n\nYou can add your own behavior that can overwrite any underlying behaviors by adding it to the end \nof the behaviors list.\n\n\n### CanJS use\n\nIf you are using CanJS, you can either:\n\n- use the [can-connect/can/map/map can/map] behavior which provides many connection methods and \n  settings to integrate closely with [can-define/map/map can-define/map] and \n  [can-define/list/list can-define/list] types.\n  \n- use the [can-connect/can/super-map/super-map can/super-map] helper to create a connection that \n  bundles [can-connect/can/map/map can/map] and many of the other behaviors.\n\nUsing [can-connect/can/map/map can/map] to create a connection looks like:\n\n```js\nvar DefineMap = require(\"can-define/map/\");\nvar DefineList = require(\"can-define/list/\");\nvar dataUrl = require(\"can-connect/data/url/\");\nvar constructor = require(\"can-connect/constructor/\"); \nvar constructorStore = require(\"can-connect/constructor/store/\"); \nvar canMap = require(\"can-connect/can/map/\");\n\nvar Todo = DefineMap.extend({ ... });\nTodo.List = DefineList.extend({\n    \"#\": Todo\n});\n\nvar todoConnection = connect(\n  [dataUrl, constructor, constructorStore, canMap],\n  {\n    Map: Todo,\n    url: \"/todos\"\n  }\n);\n```\n\nUsing [can-connect/can/super-map/super-map] to create a connection looks like:\n\n```js\nvar DefineMap = require(\"can-define/map/\");\nvar DefineList = require(\"can-define/list/\");\nvar superMap = require(\"can-connect/can/super-map/\");\n\nvar Todo = DefineMap.extend({ ... });\nTodo.List = DefineList.extend({\n    \"#\": Todo\n});\n\nvar todoConnection = superMap({\n    Map: Todo,\n    url: \"/todos\"\n});\n```\n\n<!--- todo: move this explanation of constructor/store somewhere better --->\n\nBoth the above connections contain the [can-connect/constructor/store/store constructor/store] behavior.\nThis means when you create a binding to a `Todo` or `Todo.List` instance, they will automatically \ncall [can-connect/constructor/store/store.addInstanceReference constructor/store.addInstanceReference] \nor [can-connect/constructor/store/store.addListReference constructor/store.addListReference]. \n[can-connect/constructor/store/store constructor/store] then retains the instance for the life \nof the binding and ensures only single shared instance of a particular piece of data exists. This \nprevents a common programming problem where multiple copies of an instance are held by parts of \nan application that loaded the same data.\n\n### Other use\n\nIntegrating `can-connect` with another framework is typically pretty easy.  In general, the pattern involves creating\na behavior that integrates with your framework’s observable instances. The [can-connect/can/map/map can/map] behavior \ncan serve as a good guide. You’ll typically want to implement the following methods in your behavior:\n\n`.instance` - Creates the appropriate observable object type.\n`.list` - Creates the appropriate observable array type.\n`.serializeInstance` - Return a plain object out of the observable object type.\n`.serializeList` - Return a plain array out of the observable array type.  \n\n`.createdInstance` - Update an instance with data returned from `createData`.\n`.updatedInstance` - Update an instance with data returned from `updateData`.\n`.destroyedInstance` -  Update an instance with data returned from `destroyData`.\n`.updatedList` - Update a list with raw data.\n\nAnd, in most frameworks you know when a particular observable is being used, typically\nobserved, and when it can be discarded.  In those places, you should call:\n\n- [can-connect/constructor/store/store.addInstanceReference] — when an instance is being used.\n- [can-connect/constructor/store/store.deleteInstanceReference] — when an instance is no longer being used.\n- [can-connect/constructor/store/store.addListReference] — when a list is being used.\n- [can-connect/constructor/store/store.deleteListReference] — when a list is no longer being used.\n\n\n## Interfaces\n\nThe following is a list of the primary interface methods and properties implemented or consumed by the core behaviors.\n\n### Identifiers\n\n`.id( props | instance ) -> String` - Returns a unique identifier for the instance or raw data.  \n`.idProp -> String=\"id\"` - The name of the unique identifier property.  \n`.listSet(list) -> set` - Returns the set a list represents.  \n`.listSetProp -> String=\"__listSet\"` - The property on a List that contains its set.  \n\nImplemented by the [can-connect/base/base base] behavior.\n\n### Instance Interface\n\nThe following methods operate on instances and lists.\n\n#### CRUD Methods\n\n`.getList(set) -> Promise<List>` - Retrieve a list of instances.  \n`.getData(set) -> Promise<Instance>` - Retrieve a single instance.   \n`.save(instance) -> Promise<Instance>` - Create or update an instance.  \n`.destroy(instance) -> Promise<Instance>` - Destroy an instance.  \n\nImplemented by [can-connect/constructor/constructor constructor/constructor] behavior. \n\nOverwritten by [can-connect/constructor/store/store constructor/store] and [can-connect/can/map/map can/map] behaviors.\n\n#### Instance Callbacks\n\n`.createdInstance(instance, props)` - Called whenever an instance is created.  \n`.updatedInstance(instance, props)` - Called whenever an instance is updated.  \n`.destroyedInstance(instance, props)` - Called whenever an instance is destroyed.  \n`.updatedList(list, updatedListData, set)` - Called whenever a list has been updated.  \n\nImplemented by [can-connect/constructor/constructor constructor/constructor] behavior. \n\nOverwritten by [can-connect/real-time/real-time real-time] and \n[can-connect/constructor/callbacks-once/callbacks-once constructor/callbacks-once] behaviors.\n\n#### Hydrators and Serializers\n\n`.instance(props) -> Instance` - Create an instance given raw data.  \n`.list({data: Array<Instance>}) -> List` - Create a list given an array of instances.  \n`.hydrateInstance(props) -> Instance` - Provide an instance given raw data.  \n`.hydrateList({ListData}, set) -> List` - Provide a list given raw data.  \n`.hydratedInstance(instance)` - Called whenever an instance is created in memory.  \n`.hydratedList(list, set)` - Called whenever a list is created in memory.  \n`.serializeInstance(instance) -> Object` - Return the serialized form of an instance.  \n`.serializeList(list) -> Array<Object>` - Return the serialized form of a list and its instances.  \n\nImplemented by [can-connect/constructor/constructor constructor/constructor] behavior. \n\nOverwritten by [can-connect/constructor/store/store] and [can-connect/fall-through-cache/fall-through-cache] behaviors.\n\n### Data Interface\n\nThe raw-data connection methods.  \n\n#### CRUD Methods\n\n`.getListData(set) -> Promise<ListData>` - Retrieve list data.  \n`.updateListData(listData[, set]) -> Promise<ListData>` - Update a list’s data.\n`.getSets() -> Promise<Array<Set>>` - Return the sets available to the connection, typically those stored in a [connection.cacheConnection cache connection].  \n`.getData(params) -> Promise<Object>` - Retrieve data for a particular item.  \n`.createData(props, cid) -> Promise<props>` - Create a data store record given the serialized form of the data. A \n  client ID is passed of the instance that is being created.  \n`.updateData(props) -> Promise<props>` - Update a data store record given the serialized form of the data.  \n`.destroyData(props) -> Promise<props>` - Delete a data store record given the serialized form of the data.  \n`.clear() -> Promise` - Clear all data in the connection. Typically used to remove all data from a [connection.cacheConnection cache connection].\n\nImplemented by [can-connect/data/url/url data/url], \n[can-connect/data/localstorage-cache/localstorage-cache data/localstorage-cache] and \n[can-connect/data/memory-cache/memory-cache data/memory-cache] behaviors.\n\nOverwritten by [can-connect/cache-requests/cache-requests cache-requests], \n[can-connect/data/combine-requests/combine-requests combine-requests] and \n[can-connect/fall-through-cache/fall-through-cache fall-through-cache] behaviors.\n\nConsumed by [can-connect/constructor/constructor constructor/constructor] behavior.  \n\n#### Data Callbacks\n\n`.gotListData(listData, set) -> ListaData` - Called whenever a list of data records are retrieved.  \n`.gotData( props, params) -> props` - Called whenever an individual data record is retrieved.  \n`.createdData( props, params, cid) -> props` - Called whenever an individual data record data is created.  \n`.updatedData( props, params) -> props` - Called whenever an individual data record is updated.  \n`.destroyedData( props, params) -> props` - Called whenever an individual data record is deleted.    \n\nImplemented by the [can-connect/data/callbacks/callbacks data/callbacks] behavior. \n\nOverwritten by [can-connect/data/callbacks-cache/callbacks-cache data/callbacks-cache] and\n[can-connect/real-time/real-time real-time] behaviors.\n\n#### Response Parsers\n\n`.parseListData(*) -> ListData` - Given the response of getListData, return required object format.  \n`.parseInstanceData(*) -> props` - Given the response of getData, createData, updateData, and destroyData,\nreturn the required object format.\n\nImplemented by the [can-connect/data/parse/parse data/parse] behavior.\n\n#### Store Interface\n\n`.addInstanceReference(instance)` - Add a reference to an instance so that multiple copies can be avoided.  \n`.deleteInstanceReference(instance)` - Remove a reference to an instance, freeing memory when an instance is no longer bound to.\n`.addListReference(list)` - Add a reference to a list so that multiple copies can be avoided.  \n`.deleteListReference(list)` - Remove a reference to an list, freeing memory when a list is no longer bound to.\n\nImplemented by the [can-connect/constructor/store/store constructor/store] behavior.\n\n#### Real-time Methods\n\n`createInstance( props ) -> Promise<instance>` - Inform the connection a new data record has been created.  \n`updateInstance( props ) -> Promise<instance>` - Inform the connection a data record has been updated.  \n`destroyInstance( props ) -> Promise<instance>` - Inform the connection a data record has been destroyed.  \n\nImplemented by the [can-connect/real-time/real-time real-time] behavior.\n\n## Creating Behaviors\n\nTo create your own behavior, call `connect.behavior` with the name of your behavior and a function that returns an \nobject that defines the hooks you want to overwrite or provide:\n\n```js\nconnect.behavior(\"my-behavior\", function(baseConnection){\n  return {\n    // Hooks here\n  };\n})\n```\n\nFor example, creating a basic localStorage behavior might look like:\n\n```js\nconnect.behavior(\"localstorage\", function(baseConnection){\n  return {\n    getData: function(params){\n      var id = this.id(params);\n      return new Promise(function(resolve){\n        var data = localStorage.getItem(baseConnection.name+\"/\"+id);\n        resolve( JSON.parse(data) )\n      });\n    },\n    createData: function(props){\n      var id = localStorage.getItem(baseConnection.name+\"-ID\") || \"0\";\n\n      var nextId = ++JSON.parse( id );\n      localStorage.setItem(baseConnection.name+\"-ID\", nextId);\n      var id = this.idProp;\n      return new Promise(function(resolve){\n        props[id] = nextId;\n        localStorage.setItem(baseConnection.name+\"/\"+nextId, props);\n        resolve( props )\n      });\n    },\n    updateData: function(){ ... },\n    destroyData: function(){ ...}\n  };\n})\n```\n\n",
    "description": "`can-connect` provides persisted data middleware. Assemble powerful model layers for any JavaScript  project from fully modularized behaviors (i.e plugins). \n\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect",
    "parent": "can-data-modeling",
    "collection": "can-core",
    "outline": "2",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-connect/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-ajax": "^1.0.6",
        "can-compute": "^3.3.1",
        "can-construct": "^3.2.0",
        "can-define": "^1.2.0",
        "can-event": "^3.6.0",
        "can-list": "^3.1.0",
        "can-make-rest": "0.1.1",
        "can-map": "^3.3.1",
        "can-namespace": "1.0.0",
        "can-observation": "^3.3.1",
        "can-reflect": "^1.2.1",
        "can-set": "^1.3.0",
        "can-stache": "^3.3.0",
        "can-stache-bindings": "^3.2.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.5",
        "can-validate-interface": "0.1.0",
        "can-view-callbacks": "^3.1.0",
        "can-view-nodelist": "^3.1.0",
        "steal-stache": "^3.1.0"
      },
      "deprecated": false,
      "description": "Data connection middleware and utilities",
      "devDependencies": {
        "can-fixture": "^1.1.0",
        "jquery": "2.x - 3.x",
        "jshint": "^2.9.4",
        "steal": "^1.0.1",
        "steal-css": "^1.0.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.7.0"
      },
      "engines": {
        "npm": "^3.0.0"
      },
      "homepage": "https://github.com/canjs/can-connect#readme",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "can-connect.js",
      "name": "can-connect",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-connect.git"
      },
      "scripts": {
        "build": "node build.js",
        "jshint": "jshint --config .jshintrc",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run jshint && testee --browsers firefox test/test.html",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "plugins": [
          "steal-stache",
          "steal-css"
        ]
      },
      "version": "1.5.9",
      "warnings": [
        {
          "code": "ENOTSUP",
          "required": {
            "npm": "^3.0.0"
          },
          "pkgid": "can-connect@1.5.9"
        }
      ]
    },
    "signatures": [
      {
        "code": "connect(behaviors, options)",
        "description": "\n\nIterate through passed behaviors and assemble them into a connection.\n\n```js\nvar connect = require(\"can-connect\");\nvar dataUrl = require(\"can-connect/data/url/\");\nvar constructor = require(\"can-connect/constructor/\"); \nvar todosConnection = connect([dataUrl, constructor],{\n    url: \"/api/todos\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-connect/Behavior"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "behaviors",
            "description": "\nAn array of behaviors that will be used to compose the final connection.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "options",
            "description": "\nAn object of configuration parameters for the behaviors in the connection.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "\nAn object of configuration parameters for the behaviors in the connection.\n\n"
    },
    "comment": " "
  },
  "can-construct": {
    "name": "can-construct",
    "type": "module",
    "description": " \nProvides a way to easily use the power of prototypal inheritance\nwithout worrying about hooking up all the particulars yourself. Use\n[can-construct.extend can-construct.extend] to create an inheritable\nconstructor function of your own.\n\n",
    "src": {
      "path": "node_modules/can-construct/docs/construct.md"
    },
    "body": "\n## Use\n\nIn the example below, `Animal` is a constructor function returned by [can-construct.extend can-construct.extend]. All instances of `Animal` will have a `speak`\nmethod, and the `Animal` constructor has a `legs` property.\n\n```js\nvar Construct = require(\"can-construct\");\nvar Animal = Construct.extend({\n\tlegs: 4\n},\n{\n  speak: function() {\n  \tconsole.log(this.sound);\n  }\n});\n```\n\nAn optional [can-construct::setup setup] function can be specified to handle the instantiation of the constructor function.\n```js\nvar Animal = Construct.extend({\n\tlegs: 4,\n\tsetup: function(sound) {\n\t\treturn [sound]\n\t}\n},\n{\n  speak: function() {\n  \tconsole.log(this.sound);\n  }\n});\n```\n[can-construct::setup setup] returns {Array|undefined} If an array is returned, the array's items are passed as arguments to [can-construct::init init].\n\nIn addition [can-construct::init init] can be specified which is a method that gets called with each new instance.\n```js\nvar Animal = Construct.extend({\n\tlegs: 4,\n\tinit: function(sound) {\n\t\tthis.sound = sound;\n\t}\n},\n{\n  speak: function() {\n  \tconsole.log(this.sound);\n  }\n});\n```\n\nFor more information on deciding when to use [can-construct::setup setup] or [can-construct::init init]\nsee the bottom of the [can-construct::setup setup] documentation.\n\nYou can make instances of your object by calling your constructor function with the `new` keyword. When an object is created, the [can-construct::init init]\nmethod gets called (if you supplied one):\n\n```js\nvar panther = new Animal('growl');\npanther.speak(); // \"growl\"\npanther instanceof Animal; // true\n```\n\n## Plugins\n\nThere are plugins available to help make using `can-construct` even simpler.\n\n-   [can-construct-super] allows you to easily call base methods by making `this._super` available in inherited methods.\n\n",
    "title": "can-construct",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-typed-data",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-construct/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "1.0.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "easy constructor functions",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-construct",
      "name": "can-construct",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-construct.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.2.2"
    },
    "signatures": [
      {
        "code": "new Construct( ...args )",
        "description": "\n\nCreates a new instance using Construct's constructor functions.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "args",
            "description": "The arguments passed to the constructor."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The instantiated object.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "args",
      "description": "The arguments passed to the constructor."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The instantiated object.\n"
    },
    "comment": " "
  },
  "can-construct.static": {
    "src": {
      "line": 135,
      "codeLine": 138,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "can-construct.static",
    "parent": "can-construct",
    "title": "static"
  },
  "can-construct.constructorExtends": {
    "name": "can-construct.constructorExtends",
    "type": "property",
    "parent": "can-construct.static",
    "src": {
      "line": 139,
      "codeLine": 206,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n If `constructorExtends` is:\n\n  - `true` - the constructor extends\n  - `false` - a new instance of the constructor is created\n\n This property defaults to false.\n\n Example of constructExtends as `true`:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: true // the constructor extends\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var Pony = Animal({\n   gallop: function () {\n      console.log(\"Galloping!!\");\n   }\n }); // Pony is now a constructor function extended from Animal\n\n var frank = new Animal(); // frank is a new instance of Animal\n\n var gertrude = new Pony(); // gertrude is a new instance of Pony\n gertrude.sayHi(); // \"hai!\" - sayHi is \"inherited\" from Animal\n gertrude.gallop(); // \"Galloping!!\" - gallop is unique to instances of Pony\n```\n\n The default behavior is shown in the example below:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: false // the constructor does NOT extend\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var pony = Animal(); // pony is a new instance of Animal\n var frank = new Animal(); // frank is a new instance of Animal\n\n pony.sayHi() // \"hai!\"\n frank.sayHi() // \"hai!\"\n```\n By default to extend a constructor, you must use [can-construct.extend extend].\n\t \n",
    "description": "  Toggles the behavior of a constructor function called\n without the `new` keyword to extend the constructor function or\n create a new instance.\n\n ```js\n var animal = Animal();\n // vs\n var animal = new Animal();\n ```\n\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "constructorExtends",
    "comment": " "
  },
  "can-construct.newInstance": {
    "type": "function",
    "name": "can-construct.newInstance",
    "parent": "can-construct.static",
    "src": {
      "line": 207,
      "codeLine": 272,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "Creates a new instance of the constructor function. This method is useful for creating new instances\nwith arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n__new__ operator.\n\n## Example\n\nThe following creates a `Person` Construct and overrides `newInstance` to cache all\ninstances of Person to prevent duplication. If the properties of a new Person match an existing one it\nwill return a reference to the previously created object, otherwise it returns a new object entirely.\n\n```js\n// define and create the Person constructor\nvar Person = Construct.extend({\n  init : function(first, middle, last) {\n    this.first = first;\n    this.middle = middle;\n    this.last = last;\n  }\n});\n\n// store a reference to the original newInstance function\nvar _newInstance = Person.newInstance;\n\n// override Person's newInstance function\nPerson.newInstance = function() {\n  // if cache does not exist make it an new object\n  this.__cache = this.__cache || {};\n  // id is a stingified version of the passed arguments\n  var id = JSON.stringify(arguments);\n\n  // look in the cache to see if the object already exists\n  var cachedInst = this.__cache[id];\n  if(cachedInst) {\n    return cachedInst;\n  }\n\n  //otherwise call the original newInstance function and return a new instance of Person.\n  var newInst = _newInstance.apply(this, arguments);\n  this.__cache[id] = newInst;\n  return newInst;\n};\n\n// create two instances with the same arguments\nvar justin = new Person('Justin', 'Barry', 'Meyer'),\n\tbrian = new Person('Justin', 'Barry', 'Meyer');\n\nconsole.log(justin === brian); // true - both are references to the same instance\n```\n\n \n",
    "description": "Returns an instance of `Construct`. This method can be overridden to return a cached instance.\n\n",
    "title": "newInstance",
    "signatures": [
      {
        "code": "Construct.newInstance([...args])",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "args",
            "description": "arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\nthat if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\ninstead."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "class"
            }
          ],
          "description": "instance of the class\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "args",
      "description": "arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\nthat if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\ninstead."
    },
    "_curReturn": {
      "types": [
        {
          "type": "class"
        }
      ],
      "description": "instance of the class\n"
    },
    "comment": " "
  },
  "can-construct.setup": {
    "type": "function",
    "name": "can-construct.setup",
    "parent": "can-construct.static",
    "src": {
      "line": 318,
      "codeLine": 379,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "The static `setup` method is called immediately after a constructor\nfunction is created and\nset to inherit from its base constructor. It is useful for setting up\nadditional inheritance work.\nDo not confuse this with the prototype `[can-construct::setup]` method.\n\n## Example\n\nThis `Parent` class adds a reference to its base class to itself, and\nso do all the classes that inherit from it.\n\n```js\nParent = Construct.extend({\n  setup : function(base, fullName, staticProps, protoProps){\n    this.base = base;\n\n    // call base functionality\n    Construct.setup.apply(this, arguments)\n  }\n},{});\n\nParent.base; // Construct\n\nChild = Parent({});\n\nChild.base; // Parent\n```\n \n",
    "description": "Perform initialization logic for a constructor function. \n",
    "title": "setup",
    "signatures": [
      {
        "code": "Construct.setup(base, fullName, staticProps, protoProps)",
        "description": "\n\nA static `setup` method provides inheritable setup functionality\nfor a Constructor function. The following example\ncreates a Group constructor function.  Any constructor\nfunctions that inherit from Group will be added to\n`Group.childGroups`.\n\n\n    Group = Construct.extend({\n      setup: function(Construct, fullName, staticProps, protoProps){\n        this.childGroups = [];\n        if(Construct !== Construct){\n          this.childGroups.push(Construct)\n        }\n        Construct.setup.apply(this, arguments)\n      }\n    },{})\n    var Flock = Group.extend(...)\n    Group.childGroups[0] //-> Flock\n",
        "params": [
          {
            "types": [
              {
                "type": "constructor"
              }
            ],
            "name": "base",
            "description": "The base constructor that is being inherited from."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "fullName",
            "description": "The name of the new constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "staticProps",
            "description": "The static properties of the new constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "protoProps",
            "description": "The prototype properties of the new constructor.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "protoProps",
      "description": "The prototype properties of the new constructor.\n"
    },
    "comment": " "
  },
  "can-construct.extend": {
    "type": "function",
    "name": "can-construct.extend",
    "parent": "can-construct.static",
    "src": {
      "line": 393,
      "codeLine": 571,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "## Inheritance\nCreating \"subclasses\" with `Construct` is simple. All you need to do is call the base constructor\nwith the new function's static and instance properties. For example, we want our `Snake` to\nbe an `Animal`, but there are some differences:\n\n\n    var Snake = Animal.extend({\n        legs: 0\n    }, {\n        init: function() {\n            Animal.prototype.init.call(this, 'ssssss');\n        },\n        slither: function() {\n            console.log('slithering...');\n        }\n    });\n\n    var baslisk = new Snake();\n    baslisk.speak();   // \"ssssss\"\n    baslisk.slither(); // \"slithering...\"\n    baslisk instanceof Snake;  // true\n    baslisk instanceof Animal; // true\n\n\n## Static properties and inheritance\n\nIf you pass all three arguments to Construct, the second one will be attached directy to the\nconstructor, allowing you to imitate static properties and functions. You can access these\nproperties through the `[can-construct::constructor this.constructor]` property.\n\nStatic properties can get overridden through inheritance just like instance properties. In the example below,\nwe override both the legs static property as well as the the init function for each instance:\n\n```js\nvar Animal = Construct.extend({\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    },\n    speak: function() {\n        console.log(this.sound);\n    }\n});\n\nvar Snake = Animal.extend({\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nAnimal.legs; // 4\nSnake.legs; // 0\nvar dog = new Animal('woof');\nvar blackMamba = new Snake();\ndog.speak(); // 'woof'\nblackMamba.speak(); // 'ssssss'\n```\n\n## Alternative value for a new instance\n\nSometimes you may want to return some custom value instead of a new object when creating an instance of your class.\nFor example, you want your class to act as a singleton, or check whether an item with the given id was already\ncreated and return an existing one from your cache store (e.g. using [can-connect/constructor/store/store]).\n\nTo achieve this you can return [can-construct.ReturnValue] from `setup` method of your class.\n\nLets say you have `myStore` to cache all newly created instances. And if an item already exists you want to merge\nthe new data into the existing instance and return the updated instance.\n\n```\nvar myStore = {};\n\nvar Item = Construct.extend({\n    setup: function(params){\n        if (myStore[params.id]){\n            var item = myStore[params.id];\n            \n            // Merge new data to the existing instance:\n            Object.assign(item, params);\n            \n            // Return the updated item:\n            return new Construct.ReturnValue( item );\n        } else {\n            // Save to cache store:\n            myStore[this.id] = this;\n            \n            return [params];\n        }\n    },\n    init: function(params){\n        Object.assign(this, params);\n    }\n});\n\nvar item_1  = new Item( {id: 1, name: \"One\"} );\nvar item_1a = new Item( {id: 1, name: \"OnePlus\"} )\n```\n \n",
    "description": "\n",
    "title": "extend",
    "signatures": [
      {
        "code": "Construct.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nExtends `Construct`, or constructor functions derived from `Construct`,\nto create a new constructor function. Example:\n\n```js\nvar Animal = Construct.extend({\n  sayHi: function(){\n    console.log(\"hi\")\n  }\n});\n\nvar animal = new Animal()\nanimal.sayHi();\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Adds a name to the constructor function so\nit is nicely labeled in the developer tools. The following:\n\n    Construct.extend(\"ConstructorName\",{})\n\nreturns a constructur function that will show up as `ConstructorName`\nin the developer tools.\nIt also sets \"ConstructorName\" as [can-construct.shortName shortName].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties that are added the constructor\nfunction directly. For example:\n\n```js\nvar Animal = Construct.extend({\n  findAll: function(){\n    return can.ajax({url: \"/animals\"})\n  }\n},{}); // need to pass an empty instanceProperties object\n\nAnimal.findAll().then(function(json){ ... })\n```\n\nThe [can-construct.setup static setup] method can be used to\nspecify inheritable behavior when a Constructor function is created.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [can-construct::init init] and [can-construct::setup setup] properties\nare used for initialization.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceProperties",
      "description": "Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [can-construct::init init] and [can-construct::setup setup] properties\nare used for initialization.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"
    },
    "comment": " "
  },
  "can-construct.shortName": {
    "src": {
      "line": 652,
      "codeLine": 666,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "property",
    "body": "\n```js\nvar MyConstructor = Construct.extend(\"MyConstructor\",{},{});\nMyConstructor.shortName // \"MyConstructor\"\n```\n\t\t \n",
    "description": "\nIf you pass a name when creating a Construct, the `shortName` property will be set to the\nname.\n",
    "types": [
      {
        "type": "String"
      }
    ],
    "title": "shortName",
    "name": "can-construct.shortName",
    "parent": "can-construct.static"
  },
  "can-construct.prototype": {
    "src": {
      "line": 677,
      "codeLine": 680,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "can-construct.prototype",
    "parent": "can-construct",
    "title": "prototype"
  },
  "can-construct.prototype.constructor": {
    "src": {
      "line": 681,
      "codeLine": 709,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "property",
    "body": "\n## Example\n\nThis Construct has a static counter that counts how many instances have been created:\n\n```js\nvar Counter = Construct.extend({\n    count: 0\n}, {\n    init: function() {\n        this.constructor.count++;\n    }\n});\n\nvar childCounter = new Counter();\nconsole.log(childCounter.constructor.count); // 1\nconsole.log(Counter.count); // 1\n```\n\t \n",
    "description": "\nA reference to the constructor function that created the instance. This allows you to access\nthe constructor's static properties from an instance.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "constructor",
    "name": "can-construct.prototype.constructor",
    "parent": "can-construct.prototype",
    "comment": " "
  },
  "can-construct.ReturnValue": {
    "type": "function",
    "name": "can-construct.ReturnValue",
    "parent": "can-construct.static",
    "src": {
      "line": 709,
      "codeLine": 743,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n",
    "description": "\nUse to overwrite the return value of new Construct(...).\n",
    "title": "ReturnValue",
    "signatures": [
      {
        "code": "new Construct.ReturnValue( value )",
        "description": "\n\n  This constructor function can be used for creating a return value of the `setup` method.\n  [can-construct] will check if the return value is an instance of `Construct.ReturnValue`.\n  If it is then its `value` will be used as the new instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "value",
            "description": "A value to be used for a new instance instead of a new object.\n\n```\nvar Student = function( name, school ){\n    this.name = name;\n    this.school = school;\n} \n\nvar Person = Construct.extend({\n    setup: function( options ){\n        if (options.school){\n            return new Constructor.ReturnValue( new Student( options.name, options.school ) );\n        } else {\n            return [options];\n        }\n    }\n});\n\nvar myPerson = new Person( {name: \"Ilya\", school: \"PetrSU\"} );\n\nmyPerson instanceof Student // => true\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "value",
      "description": "A value to be used for a new instance instead of a new object.\n\n```\nvar Student = function( name, school ){\n    this.name = name;\n    this.school = school;\n} \n\nvar Person = Construct.extend({\n    setup: function( options ){\n        if (options.school){\n            return new Constructor.ReturnValue( new Student( options.name, options.school ) );\n        } else {\n            return [options];\n        }\n    }\n});\n\nvar myPerson = new Person( {name: \"Ilya\", school: \"PetrSU\"} );\n\nmyPerson instanceof Student // => true\n```\n"
    }
  },
  "can-construct.prototype.setup": {
    "type": "function",
    "name": "can-construct.prototype.setup",
    "parent": "can-construct.prototype",
    "src": {
      "line": 747,
      "codeLine": 794,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n## Deciding between `setup` and `init`\n\n\nUsually, you should use [can-construct::init init] to do your constructor function's initialization.\nYou should, instead, use `setup` when:\n\n  - there is initialization code that you want to run before the inheriting constructor's\n    `init` method is called.\n  - there is initialization code that should run whether or not inheriting constructors\n    call their base's `init` methods.\n  - you want to modify the arguments that will get passed to `init`.\n\n\n",
    "description": "\n",
    "title": "setup",
    "signatures": [
      {
        "code": "construct.setup(...args)",
        "description": "\n\nA setup function for the instantiation of a constructor function.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "The arguments passed to the constructor.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array"
            },
            {
              "type": "undefined"
            },
            {
              "type": "can-construct.ReturnValue"
            }
          ],
          "description": "If an array is returned, the array's items are passed as\narguments to [can-construct::init init]. If a [can-construct.ReturnValue] instance is returned, the ReturnValue\ninstance's value will be returned as the result of calling new Construct(). The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n```js\n\tWidgetFactory = Construct.extend({\n\t\t\tsetup: function(element){\n\t\t\t\t\treturn [$(element)]\n\t\t\t}\n\t});\n\n\tMyWidget = WidgetFactory.extend({\n\t\t\tinit: function($el){\n\t\t\t\t\t$el.html(\"My Widget!!\")\n\t\t\t}\n\t});\n ```\n\nOtherwise, the arguments to the\nconstructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "The arguments passed to the constructor.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "undefined"
        },
        {
          "type": "can-construct.ReturnValue"
        }
      ],
      "description": "If an array is returned, the array's items are passed as\narguments to [can-construct::init init]. If a [can-construct.ReturnValue] instance is returned, the ReturnValue\ninstance's value will be returned as the result of calling new Construct(). The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n```js\n\tWidgetFactory = Construct.extend({\n\t\t\tsetup: function(element){\n\t\t\t\t\treturn [$(element)]\n\t\t\t}\n\t});\n\n\tMyWidget = WidgetFactory.extend({\n\t\t\tinit: function($el){\n\t\t\t\t\t$el.html(\"My Widget!!\")\n\t\t\t}\n\t});\n ```\n\nOtherwise, the arguments to the\nconstructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n"
    },
    "comment": " "
  },
  "can-construct.prototype.init": {
    "type": "function",
    "name": "can-construct.prototype.init",
    "parent": "can-construct.prototype",
    "src": {
      "line": 795,
      "codeLine": 854,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "If a prototype `init` method is provided, `init` is called when a new Construct is created---\nafter [can-construct::setup]. The `init` method is where the bulk of your initialization code\nshould go. A common thing to do in `init` is save the arguments passed into the constructor.\n\n## Examples\n\nFirst, we'll make a Person constructor that has a first and last name:\n\n```js\nvar Person = Construct.extend({\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar justin = new Person(\"Justin\", \"Meyer\");\njustin.first; // \"Justin\"\njustin.last; // \"Meyer\"\n```\n\nThen, we'll extend Person into Programmer, and add a favorite language:\n\n```js\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n\nvar brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\nbrian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n```\n\n## Modified Arguments\n\n[can-construct::setup] is able to modify the arguments passed to `init`.\nIf you aren't receiving the arguments you passed to `new Construct(args)`,\ncheck that they aren't being changed by `setup` along\nthe inheritance chain.\n\n",
    "description": "Called when a new instance of a Construct is created. \n",
    "title": "init",
    "signatures": [
      {
        "code": "construct.init(...args)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n"
    },
    "comment": " "
  },
  "can-construct-super": {
    "src": {
      "path": "node_modules/can-construct-super/can-construct-super.md"
    },
    "body": "\nWith this plugin, functions that are inheriting from base functions\nare provided with a specialized `this._super` reference to the base\nfunction from which they inherit.\n\nThis is especially useful for calling base classes' `[can-construct::init init]` and `[can-construct::setup setup]`, but it can be used in any inheriting function.\n\nThe `Person` and `Programmer` examples from `[can-construct::init init]` demonstrate `_super`'s use.\nHere's how those classes look without can.Construct.super:\n\n```\nvar Person = Construct.extend({\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\nAnd here's how `Programmer` works using `_super`:\n\n```\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        this._super(first, last);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\nIf you want to pass an array of arguments (or an arguments object) to `_super`, use [apply](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply):\n\n```\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        this._super.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\n## `_super` on constructors\n\ncan.Construct.super also adds `super` to the constructor, so you\ncan use it in static functions.\n\nHere is a base class that has a method that squares numbers and an inherited class that has a method that cubes numbers:\n\n```\nvar Squarer = can.Construct.extend({\n    raise: function(n) {\n        return n*n;\n    }\n}, {});\n\nvar Cuber = Squarer.extend({\n    raise: function(n) {\n        return n * this._super(n);\n    }\n}, {});\n```\n\n",
    "description": "\ncan.Construct.super is a plugin that makes it easier to call base\nfunctions from inside inheriting functions.\n",
    "type": "module",
    "title": "",
    "name": "can-construct-super",
    "parent": "can-typed-data",
    "collection": "can-ecosystem",
    "plugin": "can-construct-super",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-construct-super/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-construct": "^3.2.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Provides a reference to the prototypal parent using this._super in can-construct objects",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.3",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-construct-super#readme",
      "keywords": [
        "canjs",
        "donejs"
      ],
      "license": "MIT",
      "main": "can-construct-super",
      "name": "can-construct-super",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-construct-super.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-construct-super",
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.1.2"
    },
    "signatures": [
      {
        "code": "construct._super([...args])",
        "description": "\n\nCalls the base constructor function's method.\n",
        "params": [
          {
            "types": [
              {
                "type": "Any"
              }
            ],
            "variable": true,
            "name": "args",
            "description": "parameters to pass to the base function\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Any"
        }
      ],
      "variable": true,
      "name": "args",
      "description": "parameters to pass to the base function\n"
    },
    "comment": " "
  },
  "camelCase": {
    "type": "function",
    "name": "camelCase",
    "params": [
      {
        "name": "str",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect-signalr/can-connect-signalr.js",
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-connect-signalr/can-connect-signalr.js"
    },
    "body": "",
    "description": "\n",
    "hide": true,
    "desc": "Converts a string in TitleCase to camelCase",
    "_curParam": {
      "name": "str",
      "description": ""
    },
    "returns": "{string}"
  },
  "init": {
    "type": "function",
    "name": "init",
    "params": [],
    "parent": "can-connect/can/ref/ref.methods",
    "src": {
      "line": 416,
      "codeLine": 427,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "    \n",
    "description": "\n",
    "desc": [
      "Initializes the SignalR Hub Proxy",
      "and sets up the RPC listeners for the standard"
    ],
    "can": "-connect/can/ref/ref.init init",
    "signatures": [
      {
        "code": "connection.init()",
        "description": "\n\nInitializes the base connection and then creates and sets [can-connect/can/ref/ref.Map.Ref].\nTypically called by the `connect` helper after the connection behaviors have been assembled.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ],
          "description": "no return value\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        }
      ],
      "description": "no return value\n\t "
    }
  },
  "createData": {
    "type": "function",
    "name": "createData",
    "params": [
      {
        "name": "props",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect-signalr/can-connect-signalr.js",
    "src": {
      "line": 62,
      "codeLine": 68,
      "path": "node_modules/can-connect-signalr/can-connect-signalr.js"
    },
    "body": "",
    "description": "    \n",
    "desc": "Creates an instance on the Hub",
    "_curParam": {
      "name": "props",
      "description": ""
    },
    "returns": "{Promise}",
    "hide": true
  },
  "updateData": {
    "type": "function",
    "name": "updateData",
    "params": [
      {
        "name": "props",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect-signalr/can-connect-signalr.js",
    "src": {
      "line": 73,
      "codeLine": 79,
      "path": "node_modules/can-connect-signalr/can-connect-signalr.js"
    },
    "body": "",
    "description": "    \n",
    "desc": "Updates an instance on the Hub",
    "_curParam": {
      "name": "props",
      "description": ""
    },
    "returns": "{Promise}",
    "hide": true
  },
  "destroyData": {
    "type": "function",
    "name": "destroyData",
    "params": [
      {
        "name": "props",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect-signalr/can-connect-signalr.js",
    "src": {
      "line": 84,
      "codeLine": 90,
      "path": "node_modules/can-connect-signalr/can-connect-signalr.js"
    },
    "body": "",
    "description": "    \n",
    "desc": "Destroys an instance on the Hub",
    "_curParam": {
      "name": "props",
      "description": ""
    },
    "returns": "{Promise}",
    "hide": true
  },
  "getListData": {
    "type": "property",
    "name": "getListData",
    "params": [
      {
        "name": "data",
        "description": ""
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 102,
      "codeLine": 109,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "  - fixture.store.getListData: {count, limit, offset, data}\n  - feathers.find:             {total, limit, skip, data}\n\n",
    "description": "Transforms getListData from fixture to feathers format.\n",
    "desc": "Gets a collection of data instances from the Hub",
    "_curParam": {
      "name": "data",
      "description": ""
    },
    "returns": [
      "{{total: number",
      "limit: number",
      "skip: number",
      "data: *}}"
    ],
    "hide": true,
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    }
  },
  "get": {
    "type": "function",
    "name": "get",
    "params": [
      {
        "name": "set",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect-signalr/can-connect-signalr.js",
    "src": {
      "line": 106,
      "codeLine": 112,
      "path": "node_modules/can-connect-signalr/can-connect-signalr.js"
    },
    "body": "",
    "description": "    \n",
    "desc": "Gets a single instance of data from the Hub",
    "_curParam": {
      "name": "set",
      "description": ""
    },
    "returns": "{Promise}",
    "hide": true
  },
  "testData": {
    "name": "testData",
    "type": "property",
    "parent": "node_modules/can-connect-signalr/test.js",
    "src": {
      "line": 73,
      "codeLine": 78,
      "path": "node_modules/can-connect-signalr/test.js"
    },
    "body": "",
    "description": "\n",
    "hide": true,
    "desc": "A piece of sample data for use in the tests",
    "types": []
  },
  "can-define-lazy-value": {
    "type": "module",
    "name": "can-define-lazy-value",
    "parent": "can-js-utilities",
    "src": {
      "line": 0,
      "codeLine": 41,
      "path": "node_modules/can-define-lazy-value/define-lazy-value.js"
    },
    "body": "",
    "description": "",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "https://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-define-lazy-value/issues"
      },
      "bundleDependencies": false,
      "dependencies": {},
      "deprecated": false,
      "description": "Define properties with lazy values using Object.defineProperty",
      "devDependencies": {
        "jshint": "^2.9.1",
        "steal": "^1.3.1",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.2.0",
        "testee": "^0.3.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs",
        "donejs-plugin"
      ],
      "license": "MIT",
      "main": "define-lazy-value",
      "name": "can-define-lazy-value",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-define-lazy-value.git"
      },
      "scripts": {
        "build": "node build.js",
        "jshint": "jshint ./*.js --config",
        "postpublish": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update version number\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "npmIgnore": [
          "testee",
          "steal-tools"
        ]
      },
      "version": "1.0.0"
    },
    "signatures": [
      {
        "code": "defineLazyValue(obj, prop, fn, writable)",
        "description": "\n\nUse Object.defineProperty to define properties whose values will be created lazily when they are first read.\n\n```js\nvar _id = 1;\nfunction getId() {\n    return _id++;\n}\n\nfunction MyObj(name) {\n    this.name = name;\n}\n\ndefineLazyValue(MyObj.prototype, 'id', getId);\n\nvar obj1 = new MyObj('obj1');\nvar obj2 = new MyObj('obj2');\n\nconsole.log( obj2 ); // -> { name: \"obj2\" }\nconsole.log( obj1 ); // -> { name: \"obj1\" }\n\n// the first `id` read will get id `1`\nconsole( obj2.id ); // -> 1\nconsole( obj1.id ); // -> 2\n\nconsole.log( obj2 ); // -> { name: \"obj2\", id: 1 }\nconsole.log( obj1 ); // -> { name: \"obj1\", id: 2 }\n\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "The object to add the property to."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "The name of the property."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "A function to get the value the property should be set to."
          },
          {
            "types": [
              {
                "type": "boolean"
              }
            ],
            "name": "writable",
            "description": "Whether the field should be writable (false by default).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "name": "writable",
      "description": "Whether the field should be writable (false by default).\n"
    }
  },
  "static": {
    "src": {
      "line": 349,
      "codeLine": 352,
      "path": "node_modules/can-route/can-route.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "static",
    "parent": null,
    "title": "static"
  },
  "prototype": {
    "src": {
      "line": 146,
      "codeLine": 149,
      "path": "node_modules/can-map/can-map.js"
    },
    "type": "prototype",
    "body": "",
    "description": " \n",
    "name": "prototype",
    "parent": null,
    "title": "prototype"
  },
  "can.Control.processor": {
    "src": {
      "path": "node_modules/can-control/control.processor.md"
    },
    "body": "",
    "description": "A function that handles the binding and unbinding of a [can.Control]'s declarative event method. \n\n",
    "type": "typedef",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A callback function that unbinds any event handlers bound within this processor.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "the control's element or the object \nspecified by the templated event handler (`\"{object}\"`).\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "The event type.\n"
          },
          {
            "types": [
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "selector",
            "description": "The selector preceding the event in the binding used on the Control.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ],
                    "name": "element",
                    "description": "foo"
                  },
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event",
                    "description": "bar\n"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "can.Control"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The callback function being bound.\n"
          },
          {
            "types": [
              {
                "type": "can.Control"
              }
            ],
            "name": "control",
            "description": "The Control the event is bound on.\n"
          }
        ]
      }
    ],
    "name": "can.Control.processor",
    "_curParam": {
      "types": [
        {
          "type": "can.Control"
        }
      ],
      "name": "control",
      "description": "The Control the event is bound on.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A callback function that unbinds any event handlers bound within this processor.\n"
    },
    "hide": true
  },
  "'htmlbool'": {
    "type": "function",
    "name": "'htmlbool'",
    "params": [
      {
        "name": "val",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-define/can-define.js",
    "src": {
      "line": 961,
      "codeLine": 965,
      "path": "node_modules/can-define/can-define.js"
    },
    "body": " \n",
    "description": "Implements HTML-style boolean logic for attribute strings, where\nany string, including \"\", is truthy.\n"
  },
  "can-deparam": {
    "name": "can-deparam",
    "type": "module",
    "parent": "can-routing",
    "src": {
      "line": 2,
      "codeLine": 31,
      "path": "node_modules/can-deparam/can-deparam.js"
    },
    "body": "\n## Try it\n\nUse this JS Bin to play around with this package:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/mobimok/3/embed?js,console\">can-deparam on jsbin.com</a>\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "Deserialize a query string into an array or object. ",
    "title": "can-deparam",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "https://www.bitovi.com/"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-deparam/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "1.0.0"
      },
      "deprecated": false,
      "description": "Deserialize a query string into an array or object.",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.0.0",
        "donejs-cli": "^1.0.0",
        "generator-donejs": "^1.0.0",
        "jshint": "^2.9.1",
        "steal": "^1.3.1",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.2.0",
        "testee": "^0.3.0"
      },
      "homepage": "https://canjs.com/",
      "keywords": [
        "canjs",
        "query string"
      ],
      "main": "dist/cjs/can-deparam",
      "name": "can-deparam",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-deparam.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postpublish": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update version number\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-deparam",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "1.0.1"
    },
    "signatures": [
      {
        "code": "deparam(params)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "params",
            "description": "a form-urlencoded string of key-value pairs"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The params formatted into an object\n\nTakes a string of name value pairs and returns a Object literal that represents those params.\n\n```js\nvar deparam = require(\"can-deparam\");\n\nconsole.log(JSON.stringify(deparam(\"?foo=bar&number=1234\"))); // -> '{\"foo\" : \"bar\", \"number\": 1234}'\nconsole.log(JSON.stringify(deparam(\"#foo[]=bar&foo[]=baz\"))); // -> '{\"foo\" : [\"bar\", \"baz\"]}'\nconsole.log(JSON.stringify(deparam(\"foo=bar%20%26%20baz\"))); // -> '{\"foo\" : \"bar & baz\"}'\n```"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "params",
      "description": "a form-urlencoded string of key-value pairs"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The params formatted into an object\n\nTakes a string of name value pairs and returns a Object literal that represents those params.\n\n```js\nvar deparam = require(\"can-deparam\");\n\nconsole.log(JSON.stringify(deparam(\"?foo=bar&number=1234\"))); // -> '{\"foo\" : \"bar\", \"number\": 1234}'\nconsole.log(JSON.stringify(deparam(\"#foo[]=bar&foo[]=baz\"))); // -> '{\"foo\" : [\"bar\", \"baz\"]}'\nconsole.log(JSON.stringify(deparam(\"foo=bar%20%26%20baz\"))); // -> '{\"foo\" : \"bar & baz\"}'\n```"
    },
    "comment": " "
  },
  "can-dom-events.static": {
    "name": "can-dom-events.static",
    "title": "static",
    "type": "group",
    "parent": "can-dom-events",
    "description": "",
    "order": 0
  },
  "can-dom-events.helpers": {
    "name": "can-dom-events.helpers",
    "title": "helpers",
    "type": "group",
    "parent": "can-dom-events",
    "description": "",
    "order": 1
  },
  "can-dom-events.types": {
    "name": "can-dom-events.types",
    "title": "types",
    "type": "group",
    "parent": "can-dom-events",
    "description": "",
    "order": 2
  },
  "can-dom-events": {
    "name": "can-dom-events",
    "type": "module",
    "parent": "can-infrastructure",
    "src": {
      "line": 6,
      "codeLine": 33,
      "path": "node_modules/can-dom-events/can-dom-events.js"
    },
    "body": "\n```js\nvar domEvents = require(\"can-dom-events\");\nvar input = document.createElement('input');\n\nfunction onChange(event) {\n\tconsole.log('Input value changed to:', event.target.value);\n}\n\ndomEvents.addEventListener(input, 'change', onChange);\n\ndomEvents.dispatch(input, 'change'); // calls onChange\n\ndomEvents.removeEventListener(input, 'change', onChange);\n```\n\n",
    "description": "Dispatch and listen to DOM Events. ",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "package": {
      "author": {
        "name": "Chris Andrejewski",
        "email": "core@donejs.com",
        "url": "https://www.bitovi.com/"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-dom-events/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-globals": "^0.2.2",
        "can-namespace": "^1.0.0"
      },
      "deprecated": false,
      "description": "Listen for native and custom DOM events",
      "devDependencies": {
        "fixpack": "^2.3.1",
        "jquery": "^3.2.1",
        "jshint": "^2.9.1",
        "steal": "^1.3.1",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.2.0",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-dom-events",
      "keywords": [
        "canjs",
        "custom",
        "dom",
        "events",
        "listener"
      ],
      "license": "MIT",
      "main": "can-dom-events",
      "name": "can-dom-events",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-dom-events.git"
      },
      "scripts": {
        "build": "node build.js",
        "install-canary": "npm install --no-shrinkwrap",
        "install-locked": "npm install",
        "jshint": "jshint ./*.js ./helpers/*.js --config",
        "lint": "fixpack && npm run jshint",
        "preversion": "npm test && npm run build",
        "test": "npm run lint && npm run testee",
        "testee": "testee test.html --browsers firefox"
      },
      "version": "1.0.4"
    },
    "signatures": [
      {
        "code": "domEvents",
        "description": "\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-dom-events.addEvent": {
    "type": "function",
    "name": "can-dom-events.addEvent",
    "parent": "can-dom-events.static",
    "src": {
      "line": 36,
      "codeLine": 47,
      "path": "node_modules/can-dom-events/can-dom-events.js"
    },
    "body": "\n",
    "description": "\nAdd a custom event to the global event registry.\n",
    "title": "addEvent",
    "signatures": [
      {
        "code": "addEvent( event [, eventType ] )",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "EventDefinition"
              }
            ],
            "name": "event",
            "description": "The custom event definition."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The event type to associated with the custom event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "The callback to remove the custom event from the registry.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "eventType",
      "description": "The event type to associated with the custom event."
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "The callback to remove the custom event from the registry.\n"
    }
  },
  "can-dom-events.addEventListener": {
    "type": "function",
    "name": "can-dom-events.addEventListener",
    "parent": "can-dom-events.static",
    "src": {
      "line": 51,
      "codeLine": 62,
      "path": "node_modules/can-dom-events/can-dom-events.js"
    },
    "body": "\n",
    "description": "\nAdd an event listener for eventType to the target.\n",
    "title": "addEventListener",
    "signatures": [
      {
        "code": "addEventListener( target, eventType, ...eventArgs )",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "DomEventTarget"
              }
            ],
            "name": "target",
            "description": "The object to which to add the listener."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The event type with which to register."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "eventArgs",
            "description": "The arguments which configure the associated event's behavior.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "eventArgs",
      "description": "The arguments which configure the associated event's behavior.\n"
    }
  },
  "can-dom-events.removeEventListener": {
    "type": "function",
    "name": "can-dom-events.removeEventListener",
    "parent": "can-dom-events.static",
    "src": {
      "line": 73,
      "codeLine": 84,
      "path": "node_modules/can-dom-events/can-dom-events.js"
    },
    "body": "\n",
    "description": "\nRemove an event listener for eventType to the target.\n",
    "title": "removeEventListener",
    "signatures": [
      {
        "code": "removeEventListener( target, eventType, ...eventArgs )",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "DomEventTarget"
              }
            ],
            "name": "target",
            "description": "The object to which to add the listener."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The event type with which to unregister."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "eventArgs",
            "description": "The arguments which configure the associated event's behavior.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "eventArgs",
      "description": "The arguments which configure the associated event's behavior.\n"
    }
  },
  "can-dom-events.dispatch": {
    "type": "function",
    "name": "can-dom-events.dispatch",
    "parent": "can-dom-events.static",
    "src": {
      "line": 95,
      "codeLine": 108,
      "path": "node_modules/can-dom-events/can-dom-events.js"
    },
    "body": "\n",
    "description": "\nCreate and dispatch a configured event on the target.\n",
    "title": "dispatch",
    "signatures": [
      {
        "code": "dispatch( target, eventData [, bubbles ][, cancelable ] )",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "DomEventTarget"
              }
            ],
            "name": "target",
            "description": "The object to which to add the listener."
          },
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "String"
              }
            ],
            "name": "eventData",
            "description": "The data to be assigned to the event. If it is a string, that will be the event type."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "bubbles",
            "description": "Whether the event should bubble; defaults to true."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "cancelable",
            "description": "Whether the event can be cancelled; defaults to false."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "notCancelled Whether the event dispatched without being cancelled.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "cancelable",
      "description": "Whether the event can be cancelled; defaults to false."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "notCancelled Whether the event dispatched without being cancelled.\n"
    }
  },
  "can-dom-events.EventDefinition": {
    "body": "",
    "description": "Definition of a custom event that may be added to an event registry. ",
    "type": "typedef",
    "title": "EventDefinition",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "defaultEventType",
            "description": "\nThe default event type of the event.\n",
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true
          },
          {
            "name": "addEventListener",
            "description": "\nThe function to add the listener to the target.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "DomEventTarget"
                      }
                    ],
                    "name": "target",
                    "description": "The target to which to add the listener."
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "eventType",
                    "description": "The event type which should be used to register the listener."
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "eventArgs",
                    "description": "The arguments should to configure the listener behavior.\n"
                  }
                ]
              }
            ],
            "optional": true
          },
          {
            "name": "removeEventListener",
            "description": "\nThe function to remove the listener from the target.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "DomEventTarget"
                      }
                    ],
                    "name": "target",
                    "description": "The target to which to add the listener."
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "eventType",
                    "description": "The event type which should be used to register the listener."
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "eventArgs",
                    "description": "The arguments should to configure the listener behavior.\n"
                  }
                ]
              }
            ],
            "optional": true
          }
        ],
        "description": ""
      }
    ],
    "name": "can-dom-events.EventDefinition",
    "parent": "can-dom-events.types"
  },
  "can-dom-events.DomEventTarget": {
    "name": "can-dom-events.DomEventTarget",
    "type": "typedef",
    "parent": "can-dom-events.types",
    "src": {
      "line": 145,
      "codeLine": 157,
      "path": "node_modules/can-dom-events/can-dom-events.js"
    },
    "body": "",
    "description": " An object which can have DOM Events registered on it.\nThis is a Window, Document, or HTMLElement.\n\n",
    "title": "DomEventTarget",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "signatures": [
      {
        "code": "Window|Document|HTMLElement",
        "description": "",
        "params": []
      }
    ]
  },
  "can-event-dom-radiochange": {
    "name": "can-event-dom-radiochange",
    "type": "module",
    "parent": "can-infrastructure",
    "src": {
      "line": 108,
      "codeLine": 135,
      "path": "node_modules/can-event-dom-radiochange/can-event-dom-radiochange.js"
    },
    "body": "\n```js\nvar domEvents = require('can-dom-events');\nvar radioChange = require('can-event-dom-radiochange');\ndomEvents.addEvent(radioChange);\n\nvar target = document.createElement('input');\n\nfunction handler () {\n\tconsole.log('radiochange event fired');\n}\n\ndomEvents.addEventListener(target, 'radiochange', handler);\ndomEvents.removeEventListener(target, 'radiochange', handler);\n```\n\n",
    "description": "\nA custom event for listening to changes of inputs with type \"radio\",\nwhich fires when a conflicting radio input changes. A \"conflicting\"\nradio button has the same \"name\" attribute and exists within in the\nsame form, or lack thereof. This event coordinates state bound to\nwhether a radio is checked. The \"change\" event does not fire for deselected\nradios. By using this event instead, deselected radios receive notification.\n",
    "title": "",
    "types": [
      {
        "type": "events"
      }
    ],
    "package": {
      "author": {
        "name": "Chris Andrejewski",
        "email": "core@donejs.com",
        "url": "https://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-event-dom-radiochange/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.1.0",
        "can-dom-data-state": "^0.1.1",
        "can-dom-events": "^1.0.2",
        "can-globals": "^0.2.2"
      },
      "deprecated": false,
      "description": "Custom radiochange event",
      "devDependencies": {
        "fixpack": "^2.3.1",
        "jshint": "^2.9.1",
        "steal": "^1.3.1",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.2.0",
        "testee": "^0.6.0"
      },
      "homepage": "https://canjs.com/doc/can-event-dom-radiochange.html",
      "keywords": [
        "canjs",
        "change",
        "event",
        "radio"
      ],
      "license": "MIT",
      "main": "can-event-dom-radiochange",
      "name": "can-event-dom-radiochange",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-event-dom-radiochange.git"
      },
      "scripts": {
        "build": "node build.js",
        "install-canary": "npm install --no-shrinkwrap",
        "install-locked": "npm install",
        "jshint": "jshint ./*.js --config",
        "lint": "fixpack && npm run jshint",
        "preversion": "npm test && npm run build",
        "test": "npm run lint && npm run testee",
        "testee": "testee test.html --browsers firefox"
      },
      "steal": {
        "main": "can-event-dom-radiochange",
        "npmIgnore": [
          "testee",
          "steal-tools"
        ]
      },
      "version": "1.0.2"
    }
  },
  "can-event.addEventListener": {
    "type": "function",
    "name": "can-event.addEventListener",
    "parent": "can-event.static",
    "src": {
      "line": 53,
      "codeLine": 77,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "addEventListener",
    "signatures": [
      {
        "code": "obj.addEventListener(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\n```js\nvar canEvent = require(\"can-event\");\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.addEventListener.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the `canEvent` mixin.\n ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.removeEventListener": {
    "type": "function",
    "name": "can-event.removeEventListener",
    "parent": "can-event.static",
    "src": {
      "line": 91,
      "codeLine": 106,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "removeEventListener",
    "signatures": [
      {
        "code": "obj.removeEventListener(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object. Don't pass arguments to remove all event listeners.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to remove. If not specified, all events are removed."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be removed from the event. If not specified, all handlers for the event are removed."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.removeEventListener.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.dispatch": {
    "type": "function",
    "name": "can-event.dispatch",
    "parent": "can-event.static",
    "src": {
      "line": 143,
      "codeLine": 171,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "dispatch",
    "signatures": [
      {
        "code": "obj.dispatch(event, [args])",
        "description": "\n\nDispatches/triggers a basic event on an object.\n\n```js\nvar canEvent = require(\"can-event\");\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){\n  console.log(\"FOO BAR!\");\n});\n\nobj.dispatch(\"foo\"); // Causes it to log FOO BAR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "event",
            "description": "The event to dispatch"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Additional arguments to pass to event handlers"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "event The resulting event object\n"
        }
      },
      {
        "code": "canEvent.dispatch.call(obj, event, args)",
        "description": "\n\nThis syntax can be used for objects that don't include the `can.event` mixin.\n ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "event The resulting event object\n"
    }
  },
  "can-event.on": {
    "type": "function",
    "name": "can-event.on",
    "parent": "can-event.static",
    "src": {
      "line": 187,
      "codeLine": 200,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "on",
    "signatures": [
      {
        "code": "obj.on(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\nThis is an alias of [can-event.addEventListener addEventListener].\n",
        "params": []
      },
      {
        "code": "can-event.on.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n ",
        "params": []
      }
    ]
  },
  "can-event.off": {
    "type": "function",
    "name": "can-event.off",
    "parent": "can-event.static",
    "src": {
      "line": 209,
      "codeLine": 222,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "off",
    "signatures": [
      {
        "code": "obj.off(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n\nThis is an alias of [can-event.removeEventListener removeEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.off.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n ",
        "params": []
      }
    ]
  },
  "can-event.trigger": {
    "type": "function",
    "name": "can-event.trigger",
    "parent": "can-event.static",
    "src": {
      "line": 230,
      "codeLine": 242,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "trigger",
    "signatures": [
      {
        "code": "obj.trigger(event, args)",
        "description": "\n\nDispatches/triggers a basic event on an object.\nThis is an alias of [can-event.dispatch dispatch].\n",
        "params": []
      },
      {
        "code": "canEvent.trigger.call(obj, event, args)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n ",
        "params": []
      }
    ]
  },
  "can-event.one": {
    "type": "function",
    "name": "can-event.one",
    "parent": "can-event.static",
    "src": {
      "line": 252,
      "codeLine": 263,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "one",
    "signatures": [
      {
        "code": "obj.one(event, handler)",
        "description": "\n\nAdds a basic event listener that listens to an event once and only once.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "The handler that will be executed to handle the event."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n "
    }
  },
  "can-event.listenTo": {
    "type": "function",
    "name": "can-event.listenTo",
    "parent": "can-event.static",
    "src": {
      "line": 283,
      "codeLine": 301,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "listenTo",
    "signatures": [
      {
        "code": "obj.listenTo(other, event, handler)",
        "description": "\n\nListens for an event on another object.\nThis is similar to concepts like event namespacing, except that the namespace\nis the scope of the calling object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "other",
            "description": "The object to listen for events on."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.listenTo.call(obj, other, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.stopListening": {
    "type": "function",
    "name": "can-event.stopListening",
    "parent": "can-event.static",
    "src": {
      "line": 331,
      "codeLine": 347,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "stopListening",
    "signatures": [
      {
        "code": "obj.stopListening(other, event, handler)",
        "description": "\n\nStops listening for an event on another object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "other",
            "description": "The object to listen for events on."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.stopListening.call(obj, other, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.bind": {
    "type": "function",
    "name": "can-event.bind",
    "parent": "can-event.static",
    "src": {
      "line": 403,
      "codeLine": 416,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "bind",
    "signatures": [
      {
        "code": "obj.bind(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\nThis is an alias of [can-event.addEventListener addEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.bind.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ]
  },
  "can-event.unbind": {
    "type": "function",
    "name": "can-event.unbind",
    "parent": "can-event.static",
    "src": {
      "line": 420,
      "codeLine": 433,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "unbind",
    "signatures": [
      {
        "code": "obj.unbind(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n\nThis is an alias of [can-event.removeEventListener removeEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.unbind.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ]
  },
  "can-event.delegate": {
    "name": "can-event.delegate",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 436,
      "codeLine": 456,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "delegate",
    "signatures": [
      {
        "code": "obj.delegate(selector, event, handler)",
        "description": "\n\nProvides a compatibility layer for adding delegate event listeners.\nThis doesn't actually implement delegates, but rather allows\nlogic that assumes a delegate to still function.\n\nTherefore, this is essentially an alias of [can-event.addEventListener addEventListener] with the selector ignored.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "The **ignored** selector to use for the delegate."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.delegate.call(obj, selector, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can.event] mixin.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.undelegate": {
    "name": "can-event.undelegate",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 458,
      "codeLine": 478,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "undelegate",
    "signatures": [
      {
        "code": "obj.undelegate(selector, event, handler)",
        "description": "\n\nProvides a compatibility layer for removing delegate event listeners.\nThis doesn't actually implement delegates, but rather allows\nlogic that assumes a delegate to still function.\n\nTherefore, this is essentially an alias of [can-event.removeEventListener removeEventListener] with the selector ignored.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "The **ignored** selector to use for the delegate."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.undelegate.call(obj, selector, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.static": {
    "name": "can-event.static",
    "title": "static",
    "type": "group",
    "parent": "can-event",
    "description": "",
    "order": 0
  },
  "can-event": {
    "src": {
      "path": "node_modules/can-event/can-event.md"
    },
    "body": "\n## Using as a mixin\n\nThe easiest way to add events to your classes and objects is by mixing [can-event] into your object or prototype.\n\n```\nvar SomeClass = Construct(\"SomeClass\", {\n\tinit: function() {\n\t\tthis.value = 0;\n\t},\n\tincrement: function() {\n\t\tthis.value++;\n\t\tthis.dispatch(\"change\", [this.value]);\n\t}\n});\nObject.assign(SomeClass.prototype, canEvent);\n```\n\nNow that `canEvent` is included in the prototype, we can add/remove/dispatch events on the object instances.\n\n```\nvar instance = new SomeClass();\ninstance.on(\"change\", function(ev, value) {\n\talert(\"The instance changed to \" + value);\n});\n\n// This will dispatch the \"change\" event and show the alert\ninstance.increment();\n```\n\n## Using without mixing in\n\nThe same event functionality from `canEvent` can be used, even if the given object doesn't include `canEvent`. Every method within `canEvent` supports being called with an alternate scope.\n\n```\nvar obj = {};\n\ncanEvent.addEventListener.call(obj, \"change\", function() {\n\talert(\"object change!\");\n});\n\n// This will dispatch the \"change\" event and show the alert\ncanEvent.dispatch.call(obj, \"change\");\n```\n\n",
    "description": " \nAdd event functionality into your objects.\n\nThe `canEvent` object provides a number of methods for handling events in objects. This functionality is best used by mixing the `canEvent` object into an object or prototype. However, event listeners can still be used even on objects that don't include `canEvent`.\n\nAll methods provided by `canEvent` assume that they are mixed into an object -- `this` should be the object dispatching the events.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event",
    "parent": "can-observables",
    "collection": "can-infrastructure",
    "test": "can/event/test.html",
    "link": "../docco/event.html docco",
    "release": "2.1",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-event/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-namespace": "1.0.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Event handling utilities",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-event",
      "name": "can-event",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-event.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run detect-cycle &&  npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.7.5"
    },
    "signatures": [
      {
        "code": "assign(YourClass.prototype, canEvent)",
        "description": "\n\nAdds event functionality to `YourClass` objects. This can also be applied to normal objects: `assign(someObject, canEvent)`.\n\nThe `assign` function can be any function that assigns additional properties on an object such as [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) or lodash's [_.assign](https://lodash.com/docs#assign) or [can-util/js/assign/assign].\n\n```js\nvar assign = require(\"can-util/js/assign/assign\");\nvar canEvent = require(\"can-event\");\n\nfunction Thing(){\n\n}\n\nassign(Thing.prototype, canEvent);\n\nvar thing = new Thing();\nthing.addEventListener(\"prop\", function(){ ... });\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "define": {
    "type": "function",
    "name": "define",
    "parent": "can-globals/methods",
    "src": {
      "line": 20,
      "codeLine": 74,
      "path": "node_modules/can-globals/can-globals-proto.js"
    },
    "body": "\n",
    "description": "\nCreate a new global environment variable.\n",
    "title": "",
    "signatures": [
      {
        "code": "globals.define(key, value[, cache])",
        "description": "\n\nDefines a new global called `key`, who's value defaults to `value`.\n\nThe following example defines the `global` key's default value to the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window) object:\n```javascript\nglobals.define('global', window);\nglobals.getKeyValue('window') //-> window\n```\n\nIf a function is provided and `cache` is falsy, that function is run every time the key value is read:\n```javascript\nglobals.define('isBrowserWindow', function() {\n  console.log('EVALUATING')\n  return typeof window !== 'undefined' &&\n    typeof document !== 'undefined' && typeof SimpleDOM === 'undefined'\n}, false);\nglobals.get('isBrowserWindow') // logs 'EVALUATING'\n                               // -> true\nglobals.get('isBrowserWindow') // logs 'EVALUATING' again\n                               // -> true\n```\n\nIf a function is provided and `cache` is truthy, that function is run only the first time the value is read:\n```javascript\nglobals.define('isWebkit', function() {\n  console.log('EVALUATING')\n  var div = document.createElement('div')\n  return 'WebkitTransition' in div.style\n})\nglobals.getKeyValue('isWebkit') // logs 'EVALUATING'\n\t\t\t\t\t\t\t\t   // -> true\nglobals.getKeyValue('isWebkit') // Does NOT log again!\n\t\t\t\t\t\t\t\t   // -> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "\nThe key value to create.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "\nThe default value. If this is a function, its return value will be used.\n"
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "cache",
            "defaultValue": "true",
            "description": "\nEnable cache. If false the `value` function is run every time the key value is read.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-globals"
            }
          ],
          "description": "\nReturns the instance of `can-globals` for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "cache",
      "defaultValue": "true",
      "description": "\nEnable cache. If false the `value` function is run every time the key value is read.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-globals"
        }
      ],
      "description": "\nReturns the instance of `can-globals` for chaining.\n"
    }
  },
  "getKeyValue": {
    "type": "function",
    "name": "getKeyValue",
    "parent": "can-globals/methods",
    "src": {
      "line": 88,
      "codeLine": 109,
      "path": "node_modules/can-globals/can-globals-proto.js"
    },
    "body": "\n",
    "description": "\nGet a global environment variable by name.\n",
    "title": "",
    "signatures": [
      {
        "code": "globals.getKeyValue(key)",
        "description": "\n\nReturns the current value at `key`. If no value has been set, it will return the default value (if it is not a function). If the default value is a function, it will return the output of the function. This execution is cached if the cache flag was set on initialization.\n\n```javascript\nglobals.define('foo', 'bar');\nglobals.getKeyValue('foo'); //-> 'bar'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "\nThe key value to access.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "\nReturns the value of a given key.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "\nThe key value to access.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "\nReturns the value of a given key.\n"
    }
  },
  "offKeyValue": {
    "type": "function",
    "name": "offKeyValue",
    "parent": "can-globals/methods",
    "src": {
      "line": 148,
      "codeLine": 178,
      "path": "node_modules/can-globals/can-globals-proto.js"
    },
    "body": "\n",
    "description": "\nRemove handler from event queue.\n",
    "title": "",
    "signatures": [
      {
        "code": "globals.offKeyValue(key, handler)",
        "description": "\n\nRemoves `handler` from future change events for `key`.\n\n\n```javascript\nvar handler = (value) => {\n  value === 'baz' //-> true\n};\nglobals.define('foo', 'bar');\nglobals.onKeyValue('foo', handler);\nglobals.setKeyValue('foo', 'baz');\nglobals.offKeyValue('foo', handler);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "\nThe key value to observe.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "optional": true,
                    "name": "value"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "\nThe observer callback.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-globals"
            }
          ],
          "description": "\nReturns the instance of `can-globals` for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "optional": true,
              "name": "value"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "\nThe observer callback.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-globals"
        }
      ],
      "description": "\nReturns the instance of `can-globals` for chaining.\n"
    }
  },
  "onKeyValue": {
    "type": "function",
    "name": "onKeyValue",
    "parent": "can-globals/methods",
    "src": {
      "line": 189,
      "codeLine": 216,
      "path": "node_modules/can-globals/can-globals-proto.js"
    },
    "body": "\n",
    "description": "\nAdd handler to event queue.\n",
    "title": "",
    "signatures": [
      {
        "code": "globals.onKeyValue(key, handler)",
        "description": "\n\nCalls `handler` each time the value of `key` is set or reset.\n\n```javascript\nglobals.define('foo', 'bar');\nglobals.onKeyValue('foo', (value) => {\n  value === 'baz' //-> true\n});\nglobals.setKeyValue('foo', 'baz');\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "\nThe key value to observe.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "optional": true,
                    "name": "value"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "\nThe observer callback.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-globals"
            }
          ],
          "description": "\nReturns the instance of `can-globals` for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "optional": true,
              "name": "value"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "\nThe observer callback.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-globals"
        }
      ],
      "description": "\nReturns the instance of `can-globals` for chaining.\n"
    }
  },
  "deleteKeyValue": {
    "type": "function",
    "name": "deleteKeyValue",
    "parent": "can-globals/methods",
    "src": {
      "line": 226,
      "codeLine": 249,
      "path": "node_modules/can-globals/can-globals-proto.js"
    },
    "body": "\n",
    "description": "\nReset global environment variable.\n",
    "title": "",
    "signatures": [
      {
        "code": "globals.deleteKeyValue(key)",
        "description": "\n\nDeletes the current value at `key`. Future `get`s will use the default value.\n\n```javascript\nglobals.define('global', window);\nglobals.setKeyValue('global', {});\nglobals.deleteKeyValue('global');\nglobals.getKeyValue('global') === window; //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "\nThe key value to access.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-globals"
            }
          ],
          "description": "\nReturns the instance of `can-globals` for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "\nThe key value to access.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-globals"
        }
      ],
      "description": "\nReturns the instance of `can-globals` for chaining.\n"
    }
  },
  "setKeyValue": {
    "type": "function",
    "name": "setKeyValue",
    "parent": "can-globals/methods",
    "src": {
      "line": 259,
      "codeLine": 286,
      "path": "node_modules/can-globals/can-globals-proto.js"
    },
    "body": "\n",
    "description": "\nOverwrite an existing global environment variable.\n",
    "title": "",
    "signatures": [
      {
        "code": "globals.setKeyValue(key, value)",
        "description": "\n\n```javascript\nglobals.define('foo', 'bar');\nglobals.setKeyValue('foo', 'baz');\nglobals.getKeyValue('foo'); //-> 'baz'\n```\n\nSets the new value at `key`. Will override previously set values, but preserves the default (see `deleteKeyValue`).\n\nSetting a key which was not previously defined will call `define` with the key and value.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "\nThe key value to access.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "\nThe new value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-globals"
            }
          ],
          "description": "\nReturns the instance of `can-globals` for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "\nThe new value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-globals"
        }
      ],
      "description": "\nReturns the instance of `can-globals` for chaining.\n"
    }
  },
  "reset": {
    "type": "function",
    "name": "reset",
    "parent": "can-globals/methods",
    "src": {
      "line": 297,
      "codeLine": 316,
      "path": "node_modules/can-globals/can-globals-proto.js"
    },
    "body": "\n",
    "description": "\nReset all keys to their default value and clear their caches.\n",
    "title": "",
    "signatures": [
      {
        "code": "globals.setKeyValue(key, value)",
        "description": "\n\n```javascript\nglobals.define('foo', 'bar');\nglobals.setKeyValue('foo', 'baz');\nglobals.getKeyValue('foo'); //-> 'baz'\nglobals.reset();\nglobals.getKeyValue('foo'); //-> 'bar'\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-globals"
            }
          ],
          "description": "\nReturns the instance of `can-globals` for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-globals"
        }
      ],
      "description": "\nReturns the instance of `can-globals` for chaining.\n"
    }
  },
  "can-event-dom-enter": {
    "name": "can-event-dom-enter",
    "type": "module",
    "parent": "can-infrastructure",
    "src": {
      "line": 31,
      "codeLine": 56,
      "path": "node_modules/can-event-dom-enter/can-event-dom-enter.js"
    },
    "body": "\n```js\nvar domEvents = require('can-dom-events');\nvar enterEvent = require('can-event-dom-enter');\n\ndomEvents.addEvent(enterEvent);\n\nvar input = document.createElement('input');\nfunction enterEventHandler() {\n\tconsole.log('enter key pressed');\n}\n\ndomEvents.addEventHandler(input, 'enter', enterEventHandler);\ndomEvents.dispatch(input, {\n  type: 'keyup',\n  keyCode: keyCode\n});\n```\n\n",
    "description": "\nWatch for when enter keys are pressed on a DomEventTarget.\n",
    "title": "",
    "types": [
      {
        "type": "events"
      }
    ],
    "package": {
      "author": {
        "name": "Chris Andrejewski",
        "email": "core@donejs.com",
        "url": "https://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-event-dom-enter/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.1.0",
        "can-dom-data-state": "^0.1.0",
        "can-dom-events": "^1.0.2"
      },
      "deprecated": false,
      "description": "Custom enter event",
      "devDependencies": {
        "fixpack": "^2.3.1",
        "jshint": "^2.9.1",
        "steal": "^1.3.1",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.2.0",
        "testee": "^0.6.0"
      },
      "homepage": "https://canjs.com/doc/can-event-dom-enter.html",
      "keywords": [
        "canjs",
        "change",
        "event",
        "radio"
      ],
      "license": "MIT",
      "main": "can-event-dom-enter",
      "name": "can-event-dom-enter",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-event-dom-enter.git"
      },
      "scripts": {
        "build": "node build.js",
        "install-canary": "npm install --no-shrinkwrap",
        "install-locked": "npm install",
        "jshint": "jshint ./*.js --config",
        "lint": "fixpack && npm run jshint",
        "preversion": "npm test && npm run build",
        "test": "npm run lint && npm run testee",
        "testee": "testee test.html --browsers firefox"
      },
      "steal": {
        "main": "can-event-dom-enter",
        "npmIgnore": [
          "testee",
          "steal-tools"
        ]
      },
      "version": "1.0.2"
    }
  },
  "can-fixture-socket.properties": {
    "name": "can-fixture-socket.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-fixture-socket",
    "description": "",
    "order": 0
  },
  "can-fixture-socket.types": {
    "name": "can-fixture-socket.types",
    "title": "types",
    "type": "group",
    "parent": "can-fixture-socket",
    "description": "",
    "order": 0
  },
  "can-fixture-socket": {
    "src": {
      "path": "node_modules/can-fixture-socket/can-fixture-socket.md"
    },
    "body": "\n## Use basics\n\nLets say we wanted to test a simple app that connects to `socket.io`, and\nonce connected, creates a message, and logs when the message is created.\n\nThat app could look like the following:\n\n```js\nvar socket = io();\nsocket.on(\"connect\", function(){\n  socket.emit(\"messages create\", {text: \"A new message\"});\n});\nsocket.on(\"message created\", function(data){\n  // data.text === \"A new message\"\n  console.log(\"Server sent out a new message we just created\", data);\n});\n```\n\nTo test this, we'll first use [can-fixture-socket.Server can-fixture-socket.Server] to intercept the socket connection:\n\n```js\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n\nNow we can mock the socket server by creating socket event listeners and emitting socket events:\n\n```js\nmockServer.on(\"messages create\", function(data){\n  console.log(\"New message received\", data);\n  mockServer.emit(\"message created\", data);\n});\n```\n\nTo see this in action:\n\n<div class='demo_wrapper' data-demo-src='demos/can-fixture-socket/basic-app.html'></div>\n\n\n### Acknowledgement callbacks\n\nWe also can use socket.io [acknowledgement callbacks](http://socket.io/docs/#sending-and-getting-data-(acknowledgements)):\n```js\nmockServer.on(\"users create\", function(user, ackCb){\n    console.log(\"Simulating saving a new user to DB and return the new user id\", user);\n\n    ackCB({\n        id: Math.random()\n    });\n});\n```\n\nClient code:\n\n```js\nvar socket = io();\nsocket.on(\"connect\", function(){\n    socket.emit(\"users create\", {name: \"Ilya\", likes: \"skiing\"}, function (data) {\n        // data is what server calls the acknowledgement callback\n        // with (e.g. data.id is the new user id).\n        console.log(data.id);\n    });\n});\n```\n\n## Use with can-fixture.Store\n\nWith can-fixture [can-fixture.store] we can create a store of items and emulate a fully working CRUD service. Optionally, we can use [can-set.Algebra] to power our store filtering, pagination, and sorting abilities.\n\n```js\n// Import can-fixture that provides `store` method for creating a store:\nvar fixture = require(\"can-fixture\");\nvar canSet = require(\"can-set\");\n\n// Create a fixture store:\nvar messagesStore = fixture.store([\n    {id: 1, title: \"One\"},\n    {id: 2, title: \"Two\"},\n    {id: 3, title: \"Three\"}\n], new canSet.Algebra({}));\n```\n\nWe can mock the socket.io connection with the rich behavior of _fixture stores_ using the [can-fixture-socket.requestHandlerToListener] helper.  `requestHandlerToListener`\nconverts a _fixture store request handler_ to a _socket.io event listener_.\n\n```js\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar io = require(\"socket.io-client\");\nvar mockServer = new fixtureSocket.Server(io);\n\nmockServer.on(\"messages get\", fixtureSocket.requestHandlerToListener( messagesStore.getData ));\n```\n\nOr we can use [can-fixture-socket.storeToListeners] helper to convert all CRUD _fixture store request handlers_ into _socket.io event listeners_:\n\n```js\nvar listeners = fixtureSocket.storeToListeners( messagesStore );\nmockServer.on({\n    \"messages remove\": listeners.destroyData,\n    \"messages create\": listeners.createData,\n    \"messages update\": listeners.updateData\n});\n```\n\n## Use with FeathersJS\n\n[Feathers](http://feathersjs.com/) is a minimalist, service-oriented, real-time web framework for modern applications. It is a NodeJS framework built on top of Express. It allows you to build REST-ful services and works with three [providers](https://docs.feathersjs.com/providers/): standard HTTP communication, WebSockets and Primus.\n\nThe mocked server exposes [can-fixture-socket.Server.prototype.onFeathers] method to simulate [FeathersJS](http://feathersjs.com/) CRUD services.\n\nFor example, given the following FeathersJS client app:\n\n```js\nvar socket = io(\"http://api.my-feathers-server.com\");\nvar app = feathers()\n\t.configure(hooks())\n\t.configure(feathersSocketio(socket));\n\n// Create FeathersJS CRUD service for \"messages\" resource:\nvar messagesService = app.service(\"messages\");\n```\n\nWe can simulate it with a [can-fixture.store] as follows:\n\n```js\nvar messagesStore = fixture.store([\n    {id: 1, title: \"One\"},\n    {id: 2, title: \"Two\"},\n    {id: 3, title: \"Three\"}\n], new canSet.Algebra({}));\n\nmockServer.onFeathersService(\"messages\", fixtureStore);\n```\n\nNow you can test your FeathersJS app:\n\n```js\nmessagesService.find({}).then(function(data){\n    assert.equal(data.total, 3, \"find should receive 3 items\");\n});\nmessagesService.get(1).then(function(data){\n    assert.deepEqual(data, {id: 1, title: \"One\"}, \"get should receive an item\");\n});\nmessagesService.create({title: \"Four\"}).then(function(data){\n    assert.equal(data.title, \"Four\", \"create should add an new item\");\n});\n```\n\n",
    "description": "Simulate socket.io services. \n\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n`can-fixture-socket` intercepts socket.io messages and simulates socket.io server responses.\n\nThe `can-fixture-socket` module exports an object with:\n\n- [can-fixture-socket.Server], a constructor function which instance intercepts the socket.io connection;\n- [can-fixture-socket.requestHandlerToListener], a helper to convert XHR request handler into [can-fixture-socket.socket-event-listener];\n- [can-fixture-socket.storeToListeners], a helper to convert all [can-fixture/StoreType] request handlers into [can-fixture-socket.socket-event-listener].\n\nWith three simple steps you can test your real-time application that uses socket.io:\n\n 1. create a mock server that intercepts socket.io;\n 2. mock server behavior;\n 3. test your application.\n\n```js\nvar fixtureSocket = require(\"can-fixture-socket\");\n\n// Import socket-io client:\nvar io = require(\"socket.io-client\");\n\n// Create a mock server that intercepts socket.io:\nvar mockServer = new fixtureSocket.Server(io);\n\n// Mock server behavior\nmockServer.on(\"connection\", function(){\n  mockServer.emit(\"notifications\", {test: \"OK\"})\n});\n\n// Client. Create socket.io connection:\nvar socket = io(\"http://localhost:8080/api\");\n\n// Test your application:\nsocket.on(\"connect\", function(){\n  assert.ok(true, \"socket connected\");\n});\n\nsocket.on(\"notifications\", function(data){\n  assert.deepEqual(data, {test: \"OK\"}, \"received notifications message\");\n});\n```\n"
      }
    ],
    "name": "can-fixture-socket",
    "parent": "can-data-modeling",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "bitovi",
        "email": "contact@bitovi.com",
        "url": "bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-fixture-socket/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-fixture": "^1.1.0",
        "can-util": "^3.9.5"
      },
      "deprecated": false,
      "description": "Simulate socket connections",
      "devDependencies": {
        "can-set": "^1.3.0",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.2.0",
        "donejs-cli": "^1.0.1",
        "es6-promise-polyfill": "^1.2.0",
        "feathers": "^2.0.2",
        "feathers-hooks": "^2.0.1",
        "feathers-socketio": "^1.4.1",
        "generator-donejs": "^1.0.5",
        "jshint": "^2.9.1",
        "object-assign": "^4.1.0",
        "socket.io-client": "^1.5.0",
        "steal": "^1.5.6",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-fixture-socket",
      "keywords": [
        "Done",
        "JS",
        "Can",
        "JS"
      ],
      "main": "can-fixture-socket",
      "name": "can-fixture-socket",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-fixture-socket.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-fixture-socket",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "0.7.1"
    },
    "comment": " "
  },
  "serialize": {
    "type": "function",
    "name": "serialize",
    "params": [],
    "parent": "node_modules/can-list/can-list.js",
    "src": {
      "line": 152,
      "codeLine": 156,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "\t \n",
    "description": "Returns the serialized form of this list.\n",
    "hide": true
  },
  "can-list.prototype.push": {
    "name": "can-list.prototype.push",
    "type": "function",
    "parent": "can-list.prototype",
    "src": {
      "line": 222,
      "codeLine": 264,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`push` adds elements onto the end of a List here is an example:\n\n```\nvar list = new List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\nIf you have an array you want to concatenate to the end\nof the List, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\n## Events\n\n`push` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`push` has a counterpart in [can-list.prototype.pop], or you may be\nlooking for [can-list.prototype.unshift] and its counterpart [can-list.prototype.shift].\n\t \n",
    "description": "Add elements to the end of a list. ",
    "title": "push",
    "signatures": [
      {
        "code": "list.push(...elements)",
        "description": "\n\n`push` adds elements onto the end of a List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the List\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the List\n"
    },
    "comment": " "
  },
  "can-list.prototype.unshift": {
    "name": "can-list.prototype.unshift",
    "type": "function",
    "parent": "can-list.prototype",
    "src": {
      "line": 265,
      "codeLine": 307,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`unshift` adds elements to the front of the list in bulk in the order specified:\n\n```\nvar list = new List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\nIf you have an array you want to concatenate to the beginning\nof the List, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new List(['Alice']);\n\nlist.unshift.apply(list, names);\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\n## Events\n\n`unshift` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`unshift` has a counterpart in [can-list.prototype.shift], or you may be\nlooking for [can-list.prototype.push] and its counterpart [can-list.prototype.pop].\n\t \n",
    "description": "Add elements to the beginning of a List. ",
    "title": "unshift",
    "signatures": [
      {
        "code": "list.unshift(...elements)",
        "description": "\n\n`unshift` adds elements onto the beginning of a List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the List\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the List\n"
    },
    "comment": " "
  },
  "can-list.prototype.pop": {
    "name": "can-list.prototype.pop",
    "type": "function",
    "parent": "can-list.prototype",
    "src": {
      "line": 341,
      "codeLine": 374,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`pop` is the opposite action from [can-list.prototype.push]:\n\n```\nvar list = new List(['Alice', 'Bob', 'Eve']);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\nwhen it is called.\n\n## See also\n\n`pop` has its counterpart in [can-list.prototype.push], or you may be\nlooking for [can-list.prototype.unshift] and its counterpart [can-list.prototype.shift].\n\t \n",
    "description": "Remove an element from the end of a List. ",
    "title": "pop",
    "signatures": [
      {
        "code": "list.pop()",
        "description": "\n\n`pop` removes an element from the end of a List.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just popped off the List, or `undefined` if the List was empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just popped off the List, or `undefined` if the List was empty\n"
    },
    "comment": " "
  },
  "can-list.prototype.shift": {
    "name": "can-list.prototype.shift",
    "type": "function",
    "parent": "can-list.prototype",
    "src": {
      "line": 375,
      "codeLine": 410,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`shift` is the opposite action from `[can-list.prototype.unshift]`:\n\n```\nvar list = new List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n\nlist.shift(); // 'Bob'\nlist.shift(); // 'Eve'\nlist.shift(); // 'Alice'\nlist.shift(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\nwhen it is called.\n\n## See also\n\n`shift` has a counterpart in [can-list.prototype.unshift], or you may be\nlooking for [can-list.prototype.push] and its counterpart [can-list.prototype.pop].\n\t \n",
    "description": "Remove en element from the front of a list. ",
    "title": "shift",
    "signatures": [
      {
        "code": "list.shift()",
        "description": "\n\n`shift` removes an element from the beginning of a List.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just shifted off the List, or `undefined` if the List is empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just shifted off the List, or `undefined` if the List is empty\n"
    },
    "comment": " "
  },
  "can-list.prototype.indexOf": {
    "type": "function",
    "name": "can-list.prototype.indexOf",
    "parent": "can-list.prototype",
    "src": {
      "line": 442,
      "codeLine": 469,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new List(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1\n```\n\nIt is trivial to make a `contains`-type function using `indexOf`:\n\n```\nfunction(list, item) {\n    return list.indexOf(item) >= 0;\n}\n```\n \n",
    "description": "Look for an item in a List. ",
    "title": "indexOf",
    "signatures": [
      {
        "code": "list.indexOf(item)",
        "description": "\n\n`indexOf` finds the position of a given item in the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "the item to find\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the position of the item in the List, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "the item to find\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the position of the item in the List, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can-list.prototype.join": {
    "type": "function",
    "name": "can-list.prototype.join",
    "parent": "can-list.prototype",
    "src": {
      "line": 479,
      "codeLine": 501,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new List(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n\nvar beatles = new List(['John', 'Paul', 'Ringo', 'George']);\nbeatles.join('&'); // 'John&Paul&Ringo&George'\n```\n \n",
    "description": "Join a List's elements into a string. ",
    "title": "join",
    "signatures": [
      {
        "code": "list.join(separator)",
        "description": "\n\n`join` turns a List into a string by inserting _separator_ between the string representations\nof all the elements of the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "separator",
            "description": "the string to seperate elements with\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the joined string\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "separator",
      "description": "the string to seperate elements with\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the joined string\n"
    },
    "comment": " "
  },
  "can-list.prototype.reverse": {
    "type": "function",
    "name": "can-list.prototype.reverse",
    "parent": "can-list.prototype",
    "src": {
      "path": "node_modules/can-list/docs/prototype.reverse.md"
    },
    "body": "```\nvar list = new List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n\n`reverse` calls `replace` internally and triggers corresponding `add`, `remove`, `change` and `length` events respectively.\n\n## Demo\n\n<div class='iframe_wrapper' data-iframe-src='can/list/doc/reverse.html' data-iframe-height='350'></div>\n",
    "description": "Reverse the order of a List. ",
    "title": "reverse",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\n`reverse` reverses the elements of the List in place.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "the List, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-list"
        }
      ],
      "description": "the List, for chaining\n"
    },
    "comment": " "
  },
  "can-list.prototype.slice": {
    "type": "function",
    "name": "can-list.prototype.slice",
    "parent": "can-list.prototype",
    "src": {
      "line": 530,
      "codeLine": 562,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList.attr(); // ['Bob', 'Charlie', 'Daniel']\n```\n\n`slice` is the simplest way to copy a List:\n\n```\nvar list = new List(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy.attr();   // ['Alice', 'Bob', 'Eve']\nlist === copy; // false\n```\n \n",
    "description": "Make a copy of a part of a List. ",
    "title": "slice",
    "signatures": [
      {
        "code": "list.slice([start[, end]])",
        "description": "\n\n`slice` creates a copy of a portion of the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "start",
            "defaultValue": "0",
            "description": "the index to start copying from\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "end",
            "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "a new `can-list` with the extracted elements\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "end",
      "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-list"
        }
      ],
      "description": "a new `can-list` with the extracted elements\n"
    },
    "comment": " "
  },
  "can-list.prototype.concat": {
    "type": "function",
    "name": "can-list.prototype.concat",
    "parent": "can-list.prototype",
    "src": {
      "line": 569,
      "codeLine": 592,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`concat` makes a new List with the elements of the List followed by the elements of the parameters.\n\n```\nvar list = new List();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new List(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n```\n \n",
    "description": "Merge many collections together into a List. ",
    "title": "concat",
    "signatures": [
      {
        "code": "list.concat(...args)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can-list"
              },
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can-list"
        },
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.\n"
    },
    "comment": " "
  },
  "can-list.prototype.forEach": {
    "type": "function",
    "name": "can-list.prototype.forEach",
    "parent": "can-list.prototype",
    "src": {
      "line": 620,
      "codeLine": 642,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`forEach` calls a callback for each element in the List.\n\n```\nvar list = new List([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.attr(index, element * element);\n});\nlist.attr(); // [1, 4, 9]\n```\n \n",
    "description": "Call a function for each element of a List. ",
    "title": "forEach",
    "signatures": [
      {
        "code": "list.forEach(callback[, thisArg])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "element"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "a function to call with each element of the List\nThe three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the\ncurrent element of the list, and _list_ the List the elements are coming from. _callback_ is\nnot invoked for List elements that were never initialized."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "the object to use as `this` inside the callback\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "the object to use as `this` inside the callback\n"
    },
    "comment": " "
  },
  "can-list.prototype.replace": {
    "type": "function",
    "name": "can-list.prototype.replace",
    "parent": "can-list.prototype",
    "src": {
      "line": 653,
      "codeLine": 716,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`replace` replaces all the elements of this List with new ones.\n\n`replace` is especially useful when `can-list`s are live-bound into `[can-control]`s,\nand you intend to populate them with the results of a `[can-model]` call:\n\n```\ncan.Control({\n    init: function() {\n        this.list = new Todo.List();\n        // live-bind the list into the DOM\n        this.element.html(can.view('list.stache', this.list));\n        // when this AJAX call returns, the live-bound DOM will be updated\n        this.list.replace(Todo.findAll());\n    }\n});\n```\n\nLearn more about [can.Model.List making Lists of models].\n\n## Events\n\nA major difference between `replace` and `attr(newElements, true)` is that `replace` always emits\nan _add_ event and a _remove_ event, whereas `attr` will cause _set_ events along with an _add_ or _remove_\nevent if needed. Corresponding _change_ and _length_ events will be fired as well.\n\nThe differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:\n```\nvar attrList = new List(['Alexis', 'Bill']);\nattrList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nvar replaceList = new List(['Alexis', 'Bill']);\nreplaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nattrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n                                              // 1, set, Ben, Bill\nreplaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n                                              // 0, add, ['Adam', 'Ben'], ['Alexis', 'Bill']\n\nattrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n                                              // 1, remove, undefined, Ben\nreplaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n                                              // 0, add, Amber, ['Adam', 'Ben']\n\nattrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n                                              // 1, add, ['Bob', 'Eve'], undefined\nreplaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n                                              // 0, add, ['Alice', 'Bob', 'Eve'], Amber\n```\n \n",
    "description": "Replace all the elements of a List. ",
    "title": "replace",
    "signatures": [
      {
        "code": "list.replace(collection)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can-list"
              },
              {
                "type": "can.Deferred"
              }
            ],
            "name": "collection",
            "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can-list`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can-list"
        },
        {
          "type": "can.Deferred"
        }
      ],
      "name": "collection",
      "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can-list`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
    },
    "comment": " "
  },
  "can-list": {
    "src": {
      "path": "node_modules/can-list/docs/list.md"
    },
    "body": "\n\nUse for observable array-like objects.\n\n\n## Use\n\n`List` is used to observe changes to an Array.  `List` extends `[can-map]`, so all the\nways that you're used to working with Maps also work here.\n\nUse [can-list::attr attr] to read and write properties of a list:\n\n    var hobbies = new List([\"JS\",\"Party Rocking\"])\n    hobbies.attr(0)        //-> \"JS\"\n    hobbies.attr(\"length\") //-> 2\n\n    hobbies.attr(0,\"JavaScript\")\n\n    hobbies.attr()         //-> [\"JavaScript\",\"Party Rocking\"]\n\nJust as you shouldn't set properties of an Map directly, you shouldn't change elements\nof a List directly. Always use `attr` to set the elements of a List, or use [can-list::push push],\n[can-list::pop pop], [can-list::shift shift], [can-list::unshift unshift], or [can-list::splice splice].\n\nHere is a tour through the forms of `List`'s `attr` that parallels the one found under [can-map.prototype.attr attr]:\n\n```\nvar people = new List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\npeople[0] = 'Adam'; // don't do this!\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']\n```\n\n## Listening to changes\n\nAs with `Map`s, the real power of observable arrays comes from being able to\nreact to changes in the member elements of the array. Lists emit five types of events:\n\n- the _change_ event fires on every change to a List.\n- the _set_ event is fired when an element is set.\n- the _add_ event is fired when an element is added to the List.\n- the _remove_ event is fired when an element is removed from the List.\n- the _length_ event is fired when the length of the List changes.\n\nThis example presents a brief concrete survey of the times these events are fired:\n\n```\nvar list = new List(['Alice', 'Bob', 'Eve']);\n\nlist.bind('change', function() { console.log('An element changed.'); });\nlist.bind('set', function() { console.log('An element was set.'); });\nlist.bind('add', function() { console.log('An element was added.'); });\nlist.bind('remove', function() {\n  console.log('An element was removed.');\n});\nlist.bind('length', function() {\n  console.log('The length of the list changed.');\n});\n\nlist.attr(0, 'Alexis'); // 'An element changed.'\n                        // 'An element was set.'\n\nlist.attr(3, 'Xerxes'); // 'An element changed.'\n                        // 'An element was added.'\n                        // 'The length of the list was changed.'\n\nlist.attr(['Adam', 'Bill']); // 'An element changed.'\n                             // 'An element was set.'\n                             // 'An element was changed.'\n                             // 'An element was set.'\n\nlist.pop(); // 'An element changed.'\n            // 'An element was removed.'\n            // 'The length of the list was changed.'\n```\n\nMore information about binding to these events can be found under [can-list::attr attr].\n\n",
    "description": "\n",
    "name": "can-list",
    "type": "module",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "inherits": "can",
    "download": "can/list",
    "test": "can/list/test.html",
    "parent": "can-observables",
    "collection": "can-legacy",
    "release": "2.0",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-list/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-compute": "^3.3.1",
        "can-construct": "^3.2.0",
        "can-event": "^3.6.0",
        "can-map": "^3.3.1",
        "can-namespace": "1.0.0",
        "can-observation": "^3.3.1",
        "can-reflect": "^1.2.1",
        "can-symbol": "^1.0.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Observable lists",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-list",
      "name": "can-list",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-list.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.2.1"
    },
    "link": "../docco/list/list.html docco",
    "signatures": [
      {
        "code": "new List([array])",
        "description": "\n\nCreate an observable array-like object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "array",
            "description": "Items to seed the List with.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "An instance of `List` with the elements from _array_.\n"
        }
      },
      {
        "code": "new List(deferred)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can.Deferred"
              }
            ],
            "name": "deferred",
            "description": "A deferred that resolves to an\narray.  When the deferred resolves, its values will be added to the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "An initially empty `List`.  \n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-list"
        }
      ],
      "description": "An initially empty `List`.  \n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can.Deferred"
        }
      ],
      "name": "deferred",
      "description": "A deferred that resolves to an\narray.  When the deferred resolves, its values will be added to the list.\n"
    },
    "comment": " "
  },
  "can-make-rest": {
    "src": {
      "path": "node_modules/can-make-rest/can-make-rest.md"
    },
    "body": "\nMake restful urls and methods from a resource\n\n",
    "description": "\n# can-make-rest\n",
    "name": "can-make-rest",
    "type": "page"
  },
  "can-map": {
    "src": {
      "path": "node_modules/can-map/docs/map.md"
    },
    "body": "\n## Use\n\nWatch this video to see an example of creating an ATM machine using can.Map:\n\n<iframe width=\"662\" height=\"372\" src=\"https://www.youtube.com/embed/QP9mHyxZNiI\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n`Map` provides a way for you to listen for and keep track of changes\nto objects. When you use the getters and setters provided by `Map`,\nevents are fired that you can react to. `Map` also has support for\nworking with deep properties. Observable arrays are also available with\n`[can-list]`, which is based on `Map`.\n\n## Working with Observes\n\nTo create an Observe, use `new Map([props])`. This will return a\ncopy of `props` that emits events when its properties are changed with\n`[can-map.prototype.attr attr]`.\n\nYou can read the values of properties on Observes directly, but you should\nnever set them directly. You can also read property values using `attr`.\n\n\n    var aName = {a: 'Alexis'},\n        map = new can.Map(aName);\n\n    // Observes are copies of data:\n    aName === map; // false\n\n    // reading from an Observe:\n    map.attr();    // {a: 'Alexis'}\n    map.a;         // 'Alexis'\n    map.attr('a'); // 'Alexis'\n\n    // setting an Observe's property:\n    map.attr('a', 'Alice');\n    map.a; // Alice\n\n    // removing an Observe's property;\n    map.removeAttr('a');\n    map.attr(); // {}\n\n    // Don't do this!\n    map.a = 'Adam'; // wrong!\n\n\nFind out more about manipulating properties of a map under\n[can.Map.prototype.attr attr] and [can.Map.prototype.removeAttr removeAttr].\n\n## Listening to changes\n\nThe real power of maps comes from being able to react to\nproperties being added, set, and removed. Maps emit events when\nproperties are changed that you can bind to.\n\n`Map` has two types of events that fire due to changes on a map:\n- the _change_ event fires on every change to a map.\n- an event named after the property name fires on every change to that property.\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('Something on o changed.');\n    });\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log('a was changed.');\n    });\n\n    o.attr('a', 'Alexis'); // 'Something on o changed.'\n                           // 'a was changed.'\n    o.attr({\n        'a': 'Alice',      // 'Something on o changed.' (for a's change)\n        'b': 'Bob'         // 'Something on o changed.' (for b's change)\n    });                    // 'a was changed.'\n\n    o.removeAttr('a');     // 'Something on o changed.'\n                           // 'a was changed.'\n\n\nFor more detail on how to use these events, see [can.Map.prototype.bind bind] and\n[can.Map.prototype.unbind unbind]. There is also a plugin called [can.Map.delegate]\nthat makes binding to specific types of events easier:\n\n\n    var o = new Map({});\n    o.delegate('a', 'add', function(ev, newVal, oldVal) {\n        console.log('a was added.');\n    });\n    o.delegate('a', 'set', function(ev, newVal, oldVal) {\n        console.log('a was set.');\n    });\n    o.delegate('a', 'remove', function(ev, newVal, oldVal) {\n        console.log('a was removed.');\n    });\n    o.delegate('a', 'change', function(ev, newVal, oldVal) {\n        console.log('a was changed.');\n    });\n\n    o.attr('a', 'Alexis'); // 'a was added.'\n                           // 'a was changed.'\n\n    o.attr('a', 'Alice'); // 'a was set.'\n                          // 'a was changed.'\n\n    o.removeAttr('a'); // 'a was removed.'\n                       // 'a was changed.'\n\n## Object.prototype.watch\n\nDue to a method available on the base Object prototype called \"watch\", refrain from\nusing properties with the same name on Gecko based browsers as there will be a\ncollision. [Source](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/watch)\n\n",
    "description": "Create observable objects. \n",
    "name": "can-map",
    "type": "module",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "inherits": "can",
    "parent": "can-observables",
    "collection": "can-legacy",
    "test": "can/map/test.html",
    "plugin": "can/map",
    "release": "2.0",
    "link": "../docco/map/map.html docco",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-map/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-compute": "^3.3.0",
        "can-construct": "^3.2.0",
        "can-event": "^3.5.0",
        "can-namespace": "^1.0.0",
        "can-observation": "^3.3.0",
        "can-reflect": "^1.2.0",
        "can-stache-key": "0.1.0",
        "can-symbol": "^1.0.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.4"
      },
      "deprecated": false,
      "description": "Observable Objects",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-map",
      "name": "can-map",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-map.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.4.0"
    },
    "signatures": [
      {
        "code": "new Map([props])",
        "description": "\n\nCreates a new instance of can.Map.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the Observe with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "An instance of `can.Map` with the properties from _props_.\n"
        }
      },
      {
        "code": "Map.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function.\n\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "An instance of `can.Map` with the properties from _props_.\n"
    },
    "comment": " "
  },
  "can-log": {
    "body": "\n",
    "description": "\nUtilities for logging to the console.\n",
    "type": "module",
    "title": "log",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-log",
    "parent": "can-infrastructure",
    "hide": true
  },
  "can-log.warn": {
    "type": "function",
    "name": "can-log.warn",
    "parent": "can-log",
    "src": {
      "line": 13,
      "codeLine": 29,
      "path": "node_modules/can-log/can-log.js"
    },
    "body": "",
    "description": " \nAdds a warning message to the console.\n\n```\nvar canLog = require(\"can-log\");\n\ncanLog.warn(\"something evil\");\n```\n\n",
    "title": "warn",
    "signatures": [
      {
        "code": "canLog.warn(msg)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "msg",
            "description": "the message to be logged.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "msg",
      "description": "the message to be logged.\n"
    }
  },
  "can-log.log": {
    "type": "function",
    "name": "can-log.log",
    "parent": "can-log",
    "src": {
      "line": 43,
      "codeLine": 59,
      "path": "node_modules/can-log/can-log.js"
    },
    "body": "",
    "description": " Adds a message to the console.\n\n```\nvar canLog = require(\"can-log\");\n\ncanLog.log(\"hi\");\n```\n\n",
    "title": "log",
    "hide": true,
    "signatures": [
      {
        "code": "canLog.log(msg)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "msg",
            "description": "the message\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "msg",
      "description": "the message\n"
    }
  },
  "can-log.error": {
    "type": "function",
    "name": "can-log.error",
    "parent": "can-log",
    "src": {
      "line": 71,
      "codeLine": 87,
      "path": "node_modules/can-log/can-log.js"
    },
    "body": "",
    "description": " Adds an error message to the console.\n\n```\nvar canLog = require(\"can-log\");\n\ncanLog.error(new Error(\"Oh no!\"));\n```\n\n",
    "title": "error",
    "hide": true,
    "signatures": [
      {
        "code": "canLog.error(err)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Error"
              }
            ],
            "name": "err",
            "description": "The error to be logged.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Error"
        }
      ],
      "name": "err",
      "description": "The error to be logged.\n"
    }
  },
  "can-make-map": {
    "type": "module",
    "name": "can-make-map",
    "parent": "can-js-utilities",
    "src": {
      "line": 0,
      "codeLine": 11,
      "path": "node_modules/can-make-map/can-make-map.js"
    },
    "body": "",
    "description": "Convert a comma-separated string into a plain JavaScript object. ",
    "title": "can-make-map",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "collection": "can-infrastructure",
    "signatures": [
      {
        "code": "makeMap( string )",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "string",
            "description": "A comma separated list of values"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A JavaScript object with the same keys as the passed-in comma-separated values\n\nmakeMap takes a comma-separated string (can-list, NodeList, etc.) and converts it to a JavaScript object\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "string",
      "description": "A comma separated list of values"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A JavaScript object with the same keys as the passed-in comma-separated values\n\nmakeMap takes a comma-separated string (can-list, NodeList, etc.) and converts it to a JavaScript object\n"
    }
  },
  "can-namespace": {
    "src": {
      "path": "node_modules/can-namespace/can-namespace.md"
    },
    "body": "\n## Use\n\n`can-namespace` exports an object that can be used to ensure only one version of a module is loaded in an app.\n\nFor example, if you have a module `can-unicorn` that you want to make sure is only loaded a single time, you can use `can-namespace`:\n\n```js\nvar namespace = require('can-namespace');\n\nvar unicorn = {\n\t// ...\n};\n\nif (namespace.unicorn) {\n\tthrow new Error(\"You can't have two versions of can-unicorn, check your dependencies\");\n} else {\n\tmodule.exports = namespace.unicorn = unicorn;\n}\n```\n\nAny module requiring `can-namespace` will receive the same module because only one version of `can-namespace` will ever be published.\n\n",
    "description": "Namespace where can-* packages are registered \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "object"
      }
    ],
    "name": "can-namespace",
    "parent": "can-infrastructure",
    "release": "1.0",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-namespace/issues"
      },
      "bundleDependencies": false,
      "dependencies": {},
      "deprecated": false,
      "description": "Namespace where can-* packages are registered",
      "devDependencies": {},
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-namespace",
      "name": "can-namespace",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-namespace.git"
      },
      "scripts": {},
      "system": {
        "npmAlgorithm": "flat"
      },
      "version": "1.0.0"
    },
    "comment": " "
  },
  "can-observation.prototype": {
    "name": "can-observation.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation.static": {
    "name": "can-observation.static",
    "title": "static",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation.types": {
    "name": "can-observation.types",
    "title": "types",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation": {
    "type": "module",
    "name": "can-observation",
    "parent": "can-observables",
    "src": {
      "line": 28,
      "codeLine": 104,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "\n\n## Use\n\nInstances of `Observation` are rarely created directly.  Instead, use [can-compute]'s more friendly API to\nobserve when a function's value changes. [can-compute] uses `can-observation` internally.\n\n`Observation`'s static methods like: [can-observation.add], [can-observation.ignore], and [can-observation.trap]\nare used more commonly to control which observable events a compute will listen to.\n\nTo use `can-observation` directly, create something observable (supports `addEventListener`) and\ncalls [can-observation.add] like:\n\n```js\nvar Observation = require(\"can-observation\");\nvar assign = require(\"can-util/js/assign/assign\");\nvar canEvent = require(\"can-event\");\n\nvar me = assign({}, canEvent);\n\nvar name = \"Justin\";\nObject.defineProperty(me,\"name\",{\n  get: function(){\n    Observation.add(this,\"name\");\n    return name;\n  },\n  set: function(newVal) {\n    var oldVal = name;\n    name = newVal;\n    this.dispatch(\"name\", newVal, oldVal);\n  }\n})\n```\n\nNext, create an observation instance with a function that reads the observable value:\n\n```js\nvar observation = new Observation(function(){\n  return \"Hello \"+me.name;\n}, null, function(newVal, oldVal, batchNum){\n  console.log(newVal);\n})\n```\n\nFinally, call `observation.start()` to start listening and be notified of changes:\n\n```js\nobservation.start();\nobservation.value   //-> \"Hello Justin\";\nme.name = \"Ramiya\"; // console.logs -> \"Hello Ramiya\"\n```\n\n",
    "description": "\nProvides a mechanism to notify when an observable has been read and a\nway to observe those reads called within a given function.\n",
    "title": "",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-observation/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-event": "^3.6.0",
        "can-namespace": "1.0.0",
        "can-reflect": "^1.0.0",
        "can-symbol": "^1.0.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Core observable indicators",
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.2.0",
        "donejs-cli": "^1.0.1",
        "generator-donejs": "^1.0.5",
        "jshint": "^2.9.1",
        "steal": "^1.2.3",
        "steal-benchmark": "0.0.1",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-observation",
      "name": "can-observation",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-observation.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.3.5"
    },
    "signatures": [
      {
        "code": "new Observation(func, context, compute)",
        "description": "\n\nCreates an observation of a given function called with `this` as\na given context. Calls back `compute` when the return value of `func` changes.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "func",
            "description": "The function whose value is being observed."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "What `this` should be when `func` is called."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "can-compute"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldValue"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "batchNum"
                  }
                ]
              }
            ],
            "name": "updated",
            "description": "A function to call when `func`'s return value changes.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "can-compute"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "oldValue"
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ],
              "name": "batchNum"
            }
          ]
        }
      ],
      "name": "updated",
      "description": "A function to call when `func`'s return value changes.\n"
    },
    "comment": " "
  },
  "can-observation.prototype.start": {
    "type": "function",
    "name": "can-observation.prototype.start",
    "parent": "can-observation.prototype",
    "src": {
      "line": 244,
      "codeLine": 254,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "start",
    "signatures": [
      {
        "code": "observation.start()",
        "description": "\n\nStarts observing changes and adds event listeners. [can-observation.prototype.value] will\nbe available.\n\n ",
        "params": []
      }
    ]
  },
  "can-observation.prototype.stop": {
    "type": "function",
    "name": "can-observation.prototype.stop",
    "parent": "can-observation.prototype",
    "src": {
      "line": 295,
      "codeLine": 304,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "stop",
    "signatures": [
      {
        "code": "observation.stop()",
        "description": "\n\nStops observing changes and removes all event listeners.\n\n ",
        "params": []
      }
    ]
  },
  "can-observation.prototype.value": {
    "src": {
      "line": 313,
      "codeLine": 323,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "type": "property",
    "body": "\n \n",
    "description": "\nThe return value of the function once [can-observation.prototype.start] is called.\n",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "",
    "name": "can-observation.prototype.value",
    "hide": true
  },
  "can-observation.observed": {
    "name": "can-observation.observed",
    "type": "typedef",
    "parent": "can-observation.types",
    "src": {
      "line": 323,
      "codeLine": 339,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": " \nAn object representing an observation.\n\n```js\n{ \"obj\": map, \"event\": \"prop1\" }\n```\n\n",
    "title": "Observed",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "obj",
            "description": "The observable object",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "event",
            "description": "The event, or more likely property, that is being observed.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ]
  },
  "can-observation.add": {
    "type": "function",
    "name": "can-observation.add",
    "parent": "can-observation.static",
    "src": {
      "line": 479,
      "codeLine": 499,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "\n",
    "description": "\nSignals that an object's property is being observed, so that any functions\nthat are recording observations will see that this object is a dependency.\n",
    "title": "add",
    "signatures": [
      {
        "code": "Observation.add(obj, event)",
        "description": "\n\nSignals that an event should be observed. Adds the observable being read to\nthe top of the stack.\n\n```js\nObservation.add(obj, \"prop1\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An observable object which is being observed."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event (or property) that is being observed.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "event",
      "description": "The name of the event (or property) that is being observed.\n\n"
    }
  },
  "can-observation.addAll": {
    "type": "function",
    "name": "can-observation.addAll",
    "parent": "can-observation.static",
    "src": {
      "line": 517,
      "codeLine": 536,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "addAll",
    "signatures": [
      {
        "code": "Observation.addAll(observes)",
        "description": "\n\nThe same as `Observation.add` but takes an array of [can-observation.observed] objects.\nThis will most often by used in coordination with [can-observation.trap]:\n\n```js\nvar untrap = Observation.trap();\n\nObservation.add(obj, \"prop3\");\n\nvar traps = untrap();\nOservation.addAll(traps);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-observation.observed"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "observes",
            "description": "An array of [can-observation.observed]s.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-observation.observed"
                }
              ]
            }
          ]
        }
      ],
      "name": "observes",
      "description": "An array of [can-observation.observed]s.\n"
    }
  },
  "can-observation.ignore": {
    "type": "function",
    "name": "can-observation.ignore",
    "parent": "can-observation.static",
    "src": {
      "line": 557,
      "codeLine": 580,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "ignore",
    "signatures": [
      {
        "code": "Observation.ignore(fn)",
        "description": "\n\nCreates a function that, when called, will prevent observations from\nbeing applied.\n\n```js\nvar fn = Observation.ignore(function(){\n  // This will be ignored\n  Observation.add(obj, \"prop1\");\n});\n\nfn();\nObservation.trapCount(); // -> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "Any function that contains potential calls to\n[Observation.add].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function that is free of observation side-effects.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "Any function that contains potential calls to\n[Observation.add].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function that is free of observation side-effects.\n"
    }
  },
  "can-observation.trap": {
    "type": "function",
    "name": "can-observation.trap",
    "parent": "can-observation.static",
    "src": {
      "line": 595,
      "codeLine": 614,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "trap",
    "signatures": [
      {
        "code": "Observation.trap()",
        "description": "\n\nTrap all observations until the `untrap` function is called. The state of\ntraps prior to `Observation.trap()` will be restored when `untrap()` is called.\n\n```js\nvar untrap = Observation.trap();\n\nObservation.add(obj, \"prop1\");\n\nvar traps = untrap();\nconsole.log(traps[0].obj === obj); // -> true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-observation.getTrapped"
            }
          ],
          "description": "A function to get the trapped observations.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-observation.getTrapped"
        }
      ],
      "description": "A function to get the trapped observations.\n"
    }
  },
  "can-observation.getTrapped": {
    "type": "typedef",
    "name": "can-observation.getTrapped",
    "parent": "can-observation.types",
    "src": {
      "line": 627,
      "codeLine": 638,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "getTrapped",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "getTrapped()",
        "description": "\n\n  Returns the trapped observables captured by [can-observation.trap].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-observation.observed"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-observation.observed"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    }
  },
  "can-observation.isRecording": {
    "type": "function",
    "name": "can-observation.isRecording",
    "parent": "can-observation.static",
    "src": {
      "line": 648,
      "codeLine": 657,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "isRecording",
    "signatures": [
      {
        "code": "Observation.isRecording()",
        "description": "\n\nReturns if some function is in the process of recording observes.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if a function is in the process of recording observes.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if a function is in the process of recording observes.\n"
    }
  },
  "can-param": {
    "src": {
      "path": "node_modules/can-param/can-param.md"
    },
    "body": "\n## Try it\n\nUse this JS Bin to play around with this package:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/zezamig/embed?js,console\">can-param on jsbin.com</a>\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "Serialize an object or array into a query string. \n",
    "type": "module",
    "title": "can-param",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-param",
    "parent": "can-routing",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "https://www.bitovi.com/"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-param/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "1.0.0"
      },
      "deprecated": false,
      "description": "Serialize an array or object into a query string.",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.0.0",
        "donejs-cli": "^1.0.0",
        "generator-donejs": "^1.0.0",
        "jshint": "^2.9.1",
        "steal": "^1.3.1",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.2.0",
        "testee": "^0.3.0"
      },
      "homepage": "https://github.com/canjs/can-param#readme",
      "keywords": [
        "canjs",
        "parameter",
        "query string"
      ],
      "main": "dist/cjs/can-param",
      "name": "can-param",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-param.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postpublish": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update version number\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-param",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "1.0.1"
    },
    "signatures": [
      {
        "code": "param(object)",
        "description": "\n\nSerializes an object or array into a query string useful for making Ajax requests. `param` handles nested objects and arrays.  It uses `encodeURIComponent` to\nescape values and keys.\n\n```js\nvar param = require(\"can-param\");\n\nparam({foo: \"bar\"})          //-> \"foo=bar\"\nparam({foo: [\"bar\", \"baz\"]}) //-> \"foo[]=bar&foo[]=baz\"\nparam({foo: {bar: \"baz\"}})    //-> \"foo[bar]=baz\"\nparam({foo: \"bar & baz\"})    //-> \"foo=bar+%26+baz\"\n```\n\nThis is exported as `param` on [can-namespace].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "An object or array."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The params formatted into a form-encoded string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "object",
      "description": "An object or array."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The params formatted into a form-encoded string.\n"
    },
    "comment": " "
  },
  "can-parse-uri": {
    "type": "module",
    "name": "can-parse-uri",
    "parent": "can-infrastructure",
    "src": {
      "line": 0,
      "codeLine": 12,
      "path": "node_modules/can-parse-uri/can-parse-uri.js"
    },
    "body": "",
    "description": "",
    "title": "can-parse-uri",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "parseURI(url)",
        "description": "\n\nParse a URI into its components.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "url",
            "description": "The URL you want to parse.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns an object with properties for each part of the URL.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "url",
      "description": "The URL you want to parse.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns an object with properties for each part of the URL.\n"
    }
  },
  "can-route.param": {
    "type": "function",
    "name": "can-route.param",
    "parent": "can-route.static",
    "src": {
      "line": 354,
      "codeLine": 382,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Parameterizes the raw JS object representation provided in data.\n\n```js\nroute.param({ type: \"video\", id: 5 });\n  // -> \"type=video&id=5\"\n```\n\nIf a route matching the provided data is found, that URL is built\nfrom the data. Any remaining data is added at the end of the\nURL as &amp; separated key/value parameters.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.param({ type: \"video\", id: 5 }) // -> \"video/5\"\nroute.param({ type: \"video\", id: 5, isNew: false })\n  // -> \"video/5&isNew=false\"\n```\n \n",
    "description": "Get a route path from given data. ",
    "title": "param",
    "signatures": [
      {
        "code": "route.param(data)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "data"
              }
            ],
            "name": "object",
            "description": "The data to populate the route with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The route, with the data populated in it.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "data"
        }
      ],
      "name": "object",
      "description": "The data to populate the route with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The route, with the data populated in it.\n"
    },
    "comment": " "
  },
  "can-route.deparam": {
    "type": "function",
    "name": "can-route.deparam",
    "parent": "can-route.static",
    "src": {
      "line": 450,
      "codeLine": 502,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\nCreates a data object based on the query string passed into it. This is\nuseful to create an object based on the `location.hash`.\n\n```js\nroute.deparam(\"id=5&type=videos\");\n  // -> { id: 5, type: \"videos\" }\n```\n\n\nIt's important to make sure the hash or exclamation point is not passed\nto `route.deparam` otherwise it will be included in the first property's\nname.\n\n```js\nroute.data.id = 5 // location.hash -> #!id=5\nroute.data.type = \"videos\"\n  // location.hash -> #!id=5&type=videos\nroute.deparam(location.hash);\n  // -> { #!id: 5, type: \"videos\" }\n```\n\n`route.deparam` will try and find a matching route and, if it does,\nwill deconstruct the URL and parse out the key/value parameters into the\ndata object.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.deparam(\"videos/5\");\n  // -> { id: 5, route: \"{type}/{id}\", type: \"videos\" }\n```\n \n",
    "description": "Extract data from a route path. ",
    "title": "deparam",
    "signatures": [
      {
        "code": "route.deparam(url)",
        "description": "\n\nExtract data from a url, creating an object representing its values.\n\n```js\nroute(\"{page}\");\n\nvar result = route.deparam(\"page=home\");\nconsole.log(result.page); // -> \"home\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "url",
            "description": "A route fragment to extract data from."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object containing the extracted data.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "url",
      "description": "A route fragment to extract data from."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object containing the extracted data.\n"
    },
    "comment": " "
  },
  "static.routes": {
    "name": "static.routes",
    "type": "property",
    "parent": "static",
    "src": {
      "line": 561,
      "codeLine": 580,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n - test - A regular expression that will match the route when variable values\n   are present; i.e. for {page}/{type} the `RegExp` is /([\\w\\.]*)/([\\w\\.]*)/ which\n   will match for any value of {page} and {type} (word chars or period).\n\n - route - The original URL, same as the index for this entry in routes.\n\n - names - An array of all the variable names in this route\n\n - defaults - Default values provided for the variables or an empty object.\n\n - length - The number of parts in the URL separated by '/'.\n \n",
    "description": "\nA list of routes recognized by the router indixed by the url used to add it.\nEach route is an object with these members:\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "",
    "hide": true
  },
  "can-route.ready": {
    "type": "function",
    "name": "can-route.ready",
    "parent": "can-route.static",
    "src": {
      "line": 581,
      "codeLine": 613,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n\n## Use\n\nAfter setting all your routes, call `route.ready()`.\n\n```js\nroute(\"overview/{dateStart}-{dateEnd}\");\nroute(\"{type}/{id}\");\nroute.ready();\n```\n \n",
    "description": "\nInitializes can-route.\n",
    "title": "ready",
    "signatures": [
      {
        "code": "route.ready()",
        "description": "\n\nSets up the two-way binding between the hash and the can-route observable\nmap and sets the route map to its initial values.\n\n```js\nroute(\"{page}\", { page: \"home\" }));\n\nroute.ready();\nroute.data.page; // -> \"home\"\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-route"
            }
          ],
          "description": "The can-route object.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-route"
        }
      ],
      "description": "The can-route object.\n"
    },
    "comment": " "
  },
  "can-route.url": {
    "type": "function",
    "name": "can-route.url",
    "parent": "can-route.static",
    "src": {
      "line": 622,
      "codeLine": 662,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Similar to [can-route.link], but instead of creating an anchor tag,\n`route.url` creates only the URL based on the route options passed into it.\n\n```js\nroute.url( { type: \"videos\", id: 5 } );\n  // -> \"#!type=videos&id=5\"\n```\n\nIf a route matching the provided data is found the URL is built from the\ndata. Any remaining data is added at the end of the URL as & separated\nkey/value parameters.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.url( { type: \"videos\", id: 5 } ) // -> \"#!videos/5\"\nroute.url( { type: \"video\", id: 5, isNew: false } )\n  // -> \"#!video/5&isNew=false\"\n```\n \n",
    "description": "Creates a URL fragment based on registered routes given a set of data. ",
    "title": "url",
    "signatures": [
      {
        "code": "route.url(data [, merge])",
        "description": "\n\nMake a URL fragment that when set to window.location.hash will update can-route's properties\nto match those in `data`.\n\n```js\nroute.url({ page: \"home\" });\n// -> \"#!page=home\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The data to populate the route with."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Whether the given options should be merged into\nthe current state of the route."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The route URL and query string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "merge",
      "description": "Whether the given options should be merged into\nthe current state of the route."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The route URL and query string.\n"
    },
    "comment": " "
  },
  "can-route.link": {
    "type": "function",
    "name": "can-route.link",
    "parent": "can-route.static",
    "src": {
      "line": 671,
      "codeLine": 721,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Creates and returns an anchor tag with an href of the route\nattributes passed into it, as well as any properties desired\nfor the tag.\n\n```js\nroute.link( \"My videos\", { type: \"videos\" }, {}, false )\n  // -> <a href=\"#!type=videos\">My videos</a>\n```\n\nOther attributes besides href can be added to the anchor tag\nby passing in a data object with the attributes desired.\n\n```js\nroute.link( \"My videos\", { type: \"videos\" },\n  { className: \"new\" }, false )\n    // -> <a href=\"#!type=videos\" class=\"new\">My Videos</a>\n```\n\nIt is possible to utilize the current route options when making anchor\ntags in order to make your code more reusable. If merge is set to true,\nthe route options passed into `canRoute.link` will be passed into the\ncurrent ones.\n\n```js\nlocation.hash = \"#!type=videos\"\nroute.link( \"The zoo\", { id: 5 }, true )\n  // -> <a href=\"#!type=videos&id=5\">The zoo</true>\n\nlocation.hash = \"#!type=pictures\"\nroute.link( \"The zoo\", { id: 5 }, true )\n  // -> <a href=\"#!type=pictures&id=5\">The zoo</true>\n```\n \n",
    "description": "Creates a string representation of an anchor link using data and the registered routes.\n",
    "title": "link",
    "signatures": [
      {
        "code": "route.link(innerText, data, props [, merge])",
        "description": "\n\nMake an anchor tag (`<A>`) that when clicked on will update can-route's\nproperties to match those in `data`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "innerText",
            "description": "The text inside the link."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The data to populate the route with."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "Properties for the anchor other than `href`."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Whether the given options should be merged into the current state of the route."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A string with an anchor tag that points to the populated route.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "merge",
      "description": "Whether the given options should be merged into the current state of the route."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A string with an anchor tag that points to the populated route.\n"
    },
    "comment": " "
  },
  "can-route.current": {
    "type": "function",
    "name": "can-route.current",
    "parent": "can-route.static",
    "src": {
      "line": 727,
      "codeLine": 771,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n\n## Use\n\nChecks the page's current URL to see if the route represents the options\npassed into the function.\n\nReturns true if the options represent the current URL.\n\n```js\nroute.data.id = 5; // location.hash -> \"#!id=5\"\nroute.current({ id: 5 }); // -> true\nroute.current({ id: 5, type: 'videos' }); // -> false\n\nroute.data.type = 'videos';\n  // location.hash -> #!id=5&type=videos\nroute.current({ id: 5, type: 'videos' }); // -> true\n```\n \n",
    "description": "\nCheck if data represents the current route.\n",
    "title": "current",
    "signatures": [
      {
        "code": "route.current(data [,subsetMatch] )",
        "description": "\n\nCompares `data` to the current route. Used to verify if an object is\nrepresentative of the current route.\n\n```\nroute.data.set({page: \"recipes\", id: '5'});\n\nroute.current({page: \"recipes\"});       //-> false\nroute.current({page: \"recipes\"}, true); //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "Data to check agains the current route."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If true, `route.current` will return true\nif every value in `data` matches the current route data, even if\nthe route data has additional properties that are not matched.  Defaults to `false`\nwhere every property needs to be present."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Whether the data matches the current URL.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "subsetMatch",
      "description": "If true, `route.current` will return true\nif every value in `data` matches the current route data, even if\nthe route data has additional properties that are not matched.  Defaults to `false`\nwhere every property needs to be present."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Whether the data matches the current URL.\n"
    },
    "comment": " "
  },
  "can-route.matched": {
    "name": "can-route.matched",
    "type": "function",
    "parent": "can-route.static",
    "src": {
      "line": 853,
      "codeLine": 874,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Use `route.matched()` to find the currently matched route.\n\n```js\nroute(\"{type}\", { type: \"foo\" });\nroute(\"{type}/{subtype}\");\n\nroute.matched(); // \"{type}\"\n\nroute.data.subtype = \"foo\";\n\nroute.matched(); // \"{type}/{subtype}\"\n```\n \n",
    "description": "A compute representing the currently matched route. ",
    "title": "matched",
    "signatures": [
      {
        "code": "route.matched()",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The currently matched route.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The currently matched route.\n"
    },
    "comment": " "
  },
  "can-route.static": {
    "name": "can-route.static",
    "title": "static",
    "type": "group",
    "parent": "can-route",
    "description": "",
    "order": 0
  },
  "can-route": {
    "src": {
      "path": "node_modules/can-route/can-route.md"
    },
    "body": "\n## Use\n\n## Background information\n\nTo support the browser's back button and bookmarking in a JavaScript\n application, most applications use\nthe `window.location.hash`.  By\nchanging the hash (via a link or JavaScript),\none is able to add to the browser's history\nwithout changing the page.\n\nThis provides the basics needed to\ncreate history enabled single-page apps.  However,\n`route` addresses several other needs such as:\n\n  - Pretty urls.\n  - Keeping routes independent of application code.\n  - Listening to specific parts of the history changing.\n  - Setup / Teardown of widgets.\n\n## How it works\n\ncan-route is a map that represents the\n`window.location.hash` as an\nobject.  For example, if the hash looks like:\n\n    #!type=videos&id=5\n\nthe data in can-route looks like:\n\n    { type: 'videos', id: 5 }\n\ncan-route keeps the state of the hash in-sync with the `data` contained within it.\n\n## data\n\nUnderlying `can-route` is an observable map: `route.data`. Depending on what type of map your application uses this could be a [can-map], a [can-define/map/map], or maybe even a [can-simple-map].\n\nHere’s an example using [can-define/map/map DefineMap] to back `can-route`:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar route = require(\"can-route\");\n\nvar AppViewModel = DefineMap.extend({\n    page: \"string\"\n});\n\nvar appState = new AppViewModel();\nroute.data = appState;\nroute('{page}', {page: 'home'});\nroute.ready();\n```\n\nUnderstanding how maps work is essential to understanding `can-route`.\n\nYou can listen to changes in a map with `on(eventName, handler(ev, args...))` and change `can-route`’s properties by modifying `route.data`.\n\n### Listening to changes in can-route\n\nListen to changes in history by [can-event.addEventListener listening] to\nchanges of can-route's `matched` compute:\n\n```js\nroute.matched.on('change', function(ev, attr, how, newVal, oldVal) {\n\t// attr changed from oldVal -> newVal\n});\n```\n\n - `attr` - the name of the changed attribute\n - `how` - the type of Observe change event (add, set or remove)\n - `newVal`/`oldVal` - the new and old values of the attribute\n\n### Updating can-route\n\nWhen using a [can-define/map/map DefineMap] to back can-route, create changes in the route data by modifying it directly:\n\n```js\nroute.data.type = 'image';\n```\n\nOr change multiple properties at once like:\n\n```js\nroute.data.set({type: 'page', id: 5}, true);\n```\n\nWhen you make changes to can-route, they will automatically\nchange the <code>hash</code>.\n\nIf using [can-map] or [can-simple-map] to back your route, update `route.data` using `attr`.\n\n### Encoded `/`\n\nIf the change in your route data includes a `/`, the `/` will be encoded into `%2F`.\nYou will see this result in the URL and `location.hash`.\n\n```js\nroute.data.type = 'image/bar';\n// OR\nroute.attr('type', 'image/bar');\n```\n\nThe URL will look like this:\n\n    https://example.com/#!type=image%2Fbar\n\nThe location hash will look like this:\n\n    #!type=image%2Fbar\n\n## Creating a route\n\nUse `route(url, defaults)` to create a\nroute. A route is a mapping from a url to\nan object (that is the route's state).\nIn order to map to a specific properties in the url,\nprepend a colon to the name of the property like:\n\n```js\nroute(\"#!content/{type}\");\n```\n\nIf no routes are added, or no route is matched,\ncan-route's data is updated with the [can-route.deparam deparamed]\nhash.\n\n```js\nlocation.hash = \"#!type=videos\";\n// route -> {type : \"videos\"}\n```\n\nOnce routes are added and the hash changes,\ncan-route looks for matching routes and uses them\nto update can-route's data.\n\n```js\nroute(\"#!content/{type}\");\nlocation.hash = \"#!content/images\";\n// route -> {type : \"images\"}\nroute.data.type = \"songs\";\n// location.hash -> \"#!content/songs\"\n```\n\nDefault values can be added to a route:\n\n```js\nroute(\"content/{type}\",{type: \"videos\" });\nlocation.hash = \"#!content/\"\n// route -> {type : \"videos\"}\n// location.hash -> \"#!content/\"\n```\n\nDefaults can also be set on the root page of your app:\n\n```js\nroute(\"\", { page: \"index\" });\nlocation.hash = \"#!\";\n// route -> {page : \"index\"}\n// location.hash -> \"#!\"\n```\n\n## Initializing can-route\n\nAfter your application has created all of its routes, call [can-route.ready]\nto set can-route's data to match the current hash:\n\n```js\nroute.ready();\n```\n\n## Changing the route\n\nTypically, you don't set `location.hash`\ndirectly. Instead, you can change properties on can-route\nlike:\n\n```js\nroute.data.type = 'videos';\n```\n\nThis will automatically look up the appropriate\nroute and update the hash.\n\nOften, you want to create links. can-route provides\nthe [can-route.link] and [can-route.url] helpers to make this\neasy:\n\n```js\nroute.link(\"Videos\", {type: 'videos'});\n```\n\n## Finding the matched route\n\nThe matched route is stored in the compute `route.matched` and is used to set the `window.location.hash`. The process can-route uses to find the matched route is:\n  - Find all routes with all of their map properties set\n  - If multiple routes are matched, find the route with the highest number of set properties\n  - If multiple routes are still matched, use the route that was registered first\n\n### Find all routes with all of their map properties set\n\nIn order for a route to be matched, all of the map properties it uses must be set. For example, in the following route, `page` and `section` must be set in order for this route to be matched:\n\n```js\nroute('{page}/{section}');\nroute.ready();\n\nroute.data.page = 'contact';\nroute.data.section = 'email';\n\nroute.matched(); // \"{page}/{section}\"\n```\n\nIf a route contains default values, these map properties must also be set to match the default value in order for the route to be matched:\n\n```js\nroute('{page}', { section: 'email' });\nroute.ready();\n\nroute.data.page = 'contact';\nroute.data.section = 'email';\n\nroute.matched(); // \"{page}\"\n```\n\n### Find the route with the highest number of set properties\n\nIf multiple routes have all of their properties set, the route with the highest number of set properties will be used:\n\n```js\nroute('{page}');\nroute('{page}/{section}');\nroute.ready();\n\nroute.data.page = 'two';\nroute.data.section = 'a';\n\nroute.matched(); // \"{page}/{section}\"\n```\n\n### Find the route that was registered first\n\nIf multiple routes are still matched, the route that was registered first will be matched:\n\n```js\nroute('', { page: 'home' });\nroute('{section}');\nroute.ready();\n\nroute.data.page = 'home';\nroute.data.section = 'a';\n\nroute.matched(); // \"\"\n```\n\n",
    "description": "Manage browser history and client state by synchronizing the `window.location.hash` with a map. \n",
    "title": "can-route",
    "name": "can-route",
    "parent": "can-routing",
    "type": "function",
    "download": "can/route",
    "test": "can-route/test.html",
    "collection": "can-core",
    "link": "../docco/route/route.html docco",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-route/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.3.1",
        "can-deparam": "^1.0.1",
        "can-event": "^3.6.0",
        "can-namespace": "1.0.0",
        "can-observation": "^3.3.1",
        "can-param": "^1.0.1",
        "can-reflect": "^1.2.1",
        "can-simple-map": "^3.3.0",
        "can-symbol": "^1.0.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "[![Join the chat at https://gitter.im/canjs/canjs](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/canjs/canjs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [![License: MIT](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/canjs/can-route/blob/master/LICENSE.md) [![npm version](https://badge.fury.io/js/can-route.svg)](https://www.npmjs.com/package/can-route) [![Travis build status](https://travis-ci.org/canjs/can-route.svg?branch=master)](https://travis-ci.org/canjs/can-route) [![Greenkeeper badge](https://badges.greenkeeper.io/canjs/can-route.svg)](https://greenkeeper.io/)",
      "devDependencies": {
        "can-define": "^1.3.3",
        "can-list": "^3.2.0",
        "can-map": "^3.3.1",
        "can-stache-key": "^0.1.0",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^0.2.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-route#readme",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "license": "MIT",
      "main": "can-route",
      "name": "can-route",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-route.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.2.3"
    },
    "signatures": [
      {
        "code": "route(template [, defaults])",
        "description": "\n\nCreate a route matching rule. Optionally provide defaults that will be applied to the underlying map when the route matches.\n\n```js\nroute(\"{page}\", { page: \"home\" });\n```\n\nWill apply **cart** when the url is `#cart` and **home** when the url is `#`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "the fragment identifier to match.  The fragment identifier should contain characters (a-Z), optionally wrapped in braces ( { } ). Identifiers wrapped in braces are interpreted as being properties on can-route's map. Examples:\n\n```js\nroute(\"{foo}\")\nroute(\"foo/{bar}\")\n```\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "defaults",
            "description": "An object of default values. These defaults are applied to can-route's map when the route is matched.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-route"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "defaults",
      "description": "An object of default values. These defaults are applied to can-route's map when the route is matched.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-route"
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-route.data": {
    "src": {
      "path": "node_modules/can-route/route_data.md"
    },
    "body": "\n\n## Background\n\nOne of the biggest challenges in a complex application is getting all the different parts of the app to talk to each other simply, cleanly, and reliably. \n\nAn elegant way to solve this problem is using the [Observer Pattern](http://en.wikipedia.org/wiki/Observer_pattern). A single object, which can be called [Application ViewModel](https://www.youtube.com/watch?v=LrzK4exG5Ss), holds the high level state of the application.\n\n## Use\n\nSetting `route.data` is an easy way to cross-bind your Application ViewModel object to `route`. This will serialize your Application ViewModel into the hash (or pushstate URLs).\n\n```js\nvar ViewModel = DefineMap.extend({\n\tpetType: \"string\",\n\tstoreId: \"number\"\n});\n\nvar viewModel = new ViewModel({\n\tpetType: \"string\",\n\tstoreId: \"number\"\n});\n\nroute.data = viewModel;\n```\n\n`route.data` can also be set to a constructor function. A new instance will be created and bound to:\n\n```js\nvar ViewModel = DefineMap.extend({\n    page: {\n        type: \"string\",\n        set: function(page){\n            if(page === \"user\") {\n                this.verifyLoggedIn();\n            }\n            return page;\n        }\n    }\n});\n\nroute.data = ViewModel;\n```\n\n## When to set it\n\nSet `route.data` at the  start of the application lifecycle, before any calls to `route.addEventListener`. This will allow events to correctly bind on this new object.\n\n## Demo\n\nThe following shows creating an Application ViewModel that loads data at page load, has a virtual property 'locationIds' which serializes an array, and synchronizes the viewModel to can-route:\n\n<div class='demo_wrapper' data-demo-src='demos/can-route/data.html'></div>\n\n## Complete example\n\nThe following example shows loading some metadata on page load, which must be loaded as part of the Application ViewModel before the components can be initialized\n\nIt also shows an example of a \"virtual\" property on the AppViewModel, locationIds, which is the serialized version of a non-serializeable can.List, locations.  A setter is defined on locationIds, which will translate changes in locationIds back to the locations can.List.\n\n```js\nvar Location = DefineMap.extend({\n\tselected: \"boolean\",\n\tid: \"any\"\n});\n\nvar LocationList = DefineList.extend({\n\t\"*\": Location\n});\n\nvar AppViewModel = DefineMap.extend({\n\tlocations: {\n\t\ttype: \"any\",\n\t\t// don't serialize this property at all in the route\n\t\tserialize: false\n\t},\n\t// virtual property that contains a comma separated list of ids\n\t// based on locations that are selected\n\tlocationIds: {\n\n\t\t// comma separated list of ids\n\t\tserialize: function(){\n\t\t\tvar selected = thislocations.filter(\n\t\t\t\tfunction(location){\n\t\t\t\t\treturn location.selected;\n\t\t\t\t});\n\t\t\tvar ids = [];\n\t\t\tselected.each(function(item){\n\t\t\t\tids.push(item.id);\n\t\t\t})\n\t\t\treturn selected.join(',');\n\t\t},\n\t\t\n\t\t// toggle selected from a comma separated list of ids\n\t\tset: function(val){\n\t\t\tvar arr = val;\n\t\t\tif(typeof val === \"string\"){\n\t\t\t\tarr = val.split(',')\n\t\t\t}\n\t\t\t// for each id, toggle any matched location\n\t\t\tthis.locations.forEach(function(location){\n\t\t\t\tif(arr.indexOf(location.id) !== -1){\n\t\t\t\t\tlocation.selected = true;\n\t\t\t\t} else {\n\t\t\t\t\tlocation.selected = false;\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n});\n\n// initialize and set route.data first, so anything binding to can-route\n// will work correctly\nvar viewModel = new AppViewModel();\nroute.data = appViewModel;\n\n// GET /locations\nvar locations = new Location.List({});\n\n// when the data is ready, set the locations property\nlocations.done(function(){\n\tviewModel.locations = locations;\n\n\t// call ready after the AppViewModel is fully initialized\n\troute.ready();\n});\n```\n\n## Why\n\nThe Application ViewModel object, which is cross-bound to the can-route via `route.data` and represents the overall state of the application, has several obvious uses:\n\n* It is passed into the various components and used to communicate their own internal state.\n* It provides deep linking and back button support. As the URL changes, Application ViewModel changes cause changes in application components.\n* It provides the ability to \"save\" the current state of the page, by serializing the Application ViewModel object and saving it on the backend, then restoring with that object to load this saved state.\n\n",
    "description": "\nThis is the internal map underlying can-route. It can be set in order to cross-bind a top level state object (Application ViewModel) to can-route.\n",
    "title": "data",
    "name": "can-route.data",
    "type": "function",
    "parent": "can-route.static",
    "comment": " "
  },
  "can-reflect/call": {
    "name": "can-reflect/call",
    "title": "Call reflections",
    "type": "group",
    "parent": "can-reflect",
    "description": "",
    "order": 3
  },
  "can-reflect/get-set": {
    "name": "can-reflect/get-set",
    "title": "Get/Set reflections",
    "type": "group",
    "parent": "can-reflect",
    "description": "",
    "order": 2
  },
  "can-reflect/observe": {
    "name": "can-reflect/observe",
    "title": "Observable reflections",
    "type": "group",
    "parent": "can-reflect",
    "description": "",
    "order": 5
  },
  "can-reflect/shape": {
    "name": "can-reflect/shape",
    "title": "Shape reflections",
    "type": "group",
    "parent": "can-reflect",
    "description": "",
    "order": 4
  },
  "can-reflect/type": {
    "name": "can-reflect/type",
    "title": "Type reflections",
    "type": "group",
    "parent": "can-reflect",
    "description": "",
    "order": 1
  },
  "can-reflect": {
    "src": {
      "path": "node_modules/can-reflect/can-reflect.md"
    },
    "body": "",
    "description": "Perform operations and read information on unknown data types. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "The `can-reflect` package exports an object with\nmethods used to perform operations and read information on unknown data\ntypes. For example the sets the `name` property on some type of map:\n\n```js\nconst canReflect = require(\"can-reflect\");\n\nconst map = CREATE_MAP_SOMEHOW();\n\ncanReflect.setKeyValue(map,\"name\", \"my map\");\n```\n\nAny object can interact with the reflect APIs by having the right\n[can-symbol] symbols.  The following creates an object that informs how\n[can-reflect.getKeyValue] and [can-reflect.setKeyValue] behave:\n\n```js\nconst canSymbol = require(\"can-symbol\");\n\nconst obj = {\n\t_data: new Map()\n};\nobj[canSymbol.for(\"can.getKeyValue\")] = function(key){\n\treturn this._data.get(key);\n};\nobj[canSymbol.for(\"can.setKeyValue\")] = function(key, value){\n\treturn this._data.set(key, value);\n};\n```\n\n`can-reflect` organizes it's methods into the following groups:\n\n- __Type Reflections__ - Determine if an object matches a familiar type to CanJS.\n- __Get/Set Reflections__ - Read and write to objects.\n- __Call Reflections__ - Call functions and function-like objects.\n- __Shape Reflections__ - Perform operations based on multiple values within an object.\n- __Observable Reflections__ - Listen to changes in observable objects.\n"
      }
    ],
    "name": "can-reflect",
    "parent": "can-typed-data",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "DoneJS core team",
        "email": "core@donejs.com",
        "url": "http://donejs.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-reflect/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "^1.0.0",
        "can-symbol": "^1.3.0"
      },
      "deprecated": false,
      "description": "reflection on unknown data types",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "http-server": "^0.10.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.5",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "test-saucelabs": "0.0.2",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "donejs"
      ],
      "main": "can-reflect",
      "name": "can-reflect",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-reflect.git"
      },
      "scripts": {
        "build": "node build.js",
        "ci": "npm run build && npm run test && node test-saucelabs.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "http-server": "http-server -p 3000 --silent",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "1.7.2"
    }
  },
  "can-reflect-promise": {
    "src": {
      "path": "node_modules/can-reflect-promise/can-reflect-promise.md"
    },
    "body": "",
    "description": "Expose an observable, Map-like API on Promise types. \n",
    "title": "",
    "name": "can-reflect-promise",
    "parent": "can-typed-data",
    "type": "function",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-reflect-promise/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.0.3",
        "can-event": "^3.5.0",
        "can-observation": "^3.3.0",
        "can-reflect": "^1.1.0",
        "can-symbol": "^1.0.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Reflection support for Promise types",
      "devDependencies": {
        "can-jquery": "^3.2.0",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.5.4",
        "steal-benchmark": "0.0.1",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.5.0"
      },
      "directories": {
        "test": "test"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "license": "MIT",
      "main": "can-reflect-promise",
      "name": "can-reflect-promise",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-reflect-promise.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push origin master",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "1.1.4"
    },
    "signatures": [
      {
        "code": "canReflectPromise(promise)",
        "description": "\n\nIf `promise` is an instance of a Promise type (either provided natively by the platform or by a polyfill library), the prototype\nof the Promise type is decorated with [can-symbol] symbols for `@@can.onKeyValue`, `@@can.offKeyValue`,\n`@@can.getKeyValue`, `@@can.onValue`, and `@@can.offValue`, which allow it to be used like an observable Map-like in \nreflection.\n\nThen `promise` and all future instances of `promise.constructor` will be initialized on first access to have the following keys\navailable through [can-symbol/symbols/getKeyValue @@can.getKeyValue]:\n\n* \"state\" -- one of \"pending\", \"resolved\", or \"rejected\"\n* \"isPending\" -- true if the promise neither resolved nor rejected, false otherwise.\n* \"isResolved\" -- true if the promise is resolved, false otherwise.\n* \"isRejected\" -- true if the promise is rejected, false otherwise.\n* \"value\" -- the resolved value of the promise if resolved, otherwise undefined.\n* \"reason\" -- the rejected value of the promise if rejected, otherwise undefined.\n\n> Note that, due to native Promises' lack of inspection, it is impossible to tell whether a Promise is resolved or rejected \nwithout using `.then()`. If the Promise is Promises/A+ compliant, then at the time the Promise is initialized by \n`can-reflect-promise`, `isPending` will always be true, even if \nthe Promise has already resolved, and will remain so during synchronous execution.  On the next tick, the state will update to \n`resolved`/`rejected` if the Promise has already updated its state.  The best strategy for ensuring a proper read of a resolved\nvalue or rejected reason is to listen for the change in state or \nvalue with [can-symbol/symbols/onKeyValue @@can.onKeyValue] immediately after creating a Promise.\n\nIn the cases where `promise` is a plain object (e.g. if it is a `jQuery.Deferred`), the symbols will be applied to `promise`\nitself, not to the proto.\n\n```\nvar p = new Promise(function(resolve) {\n\tsetTimeout(resolve.bind(null, \"a\"), 10);\n});\n\ncanReflectPromise(p);\n\ncanReflect.getKeyValue(p, \"isPending\"); // -> true\n\nsetTimeout(function() {\n\tcanReflect.getKeyValue(p, \"isResolved\"); // -> true\n\tcanReflect.getKeyValue(p, \"value\"); // -> \"a\"\n}, 20);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Promise"
              }
            ],
            "name": "promise",
            "description": "any Promise, Promise-like, or thenable.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "name": "promise",
      "description": "any Promise, Promise-like, or thenable.\n"
    }
  },
  "can-simple-observable": {
    "type": "module",
    "name": "can-simple-observable",
    "parent": "can-observables",
    "src": {
      "line": 6,
      "codeLine": 42,
      "path": "node_modules/can-simple-observable/can-simple-observable.js"
    },
    "body": "\n## Use\n\n```js\n var obs = observable('one');\n\n canReflect.getValue(obs); // -> \"one\"\n\n canReflect.setValue(obs, 'two');\n canReflect.getValue(obs); // -> \"two\"\n\n function handler(newValue) {\n   // -> \"three\"\n };\n canReflect.onValue(obs, handler);\n canReflect.setValue(obs, 'three');\n\n canReflect.offValue(obs, handler);\n```\n\n",
    "description": "Create an observable value. \n",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "https://www.bitovi.com/"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-simple-observable/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.0.3",
        "can-event": "^3.7.4",
        "can-namespace": "1.0.0",
        "can-observation": "^3.3.5",
        "can-reflect": "^1.4.1"
      },
      "deprecated": false,
      "description": "Create an observable value.",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.3.1",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.2.0",
        "testee": "^0.3.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs",
        "donejs-plugin"
      ],
      "license": "MIT",
      "main": "can-simple-observable",
      "name": "can-simple-observable",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-simple-observable.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint ./*.js --config",
        "postpublish": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update version number\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "npmIgnore": [
          "testee",
          "steal-tools"
        ]
      },
      "version": "1.0.1"
    },
    "signatures": [
      {
        "code": "observable(initialValue)",
        "description": "\n\nCreates an observable value that can be read, written, and observed using [can-reflect].\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "initialValue",
            "description": "The initial value of the observable.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-simple-observable"
            }
          ],
          "description": "The observable.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "initialValue",
      "description": "The initial value of the observable.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-simple-observable"
        }
      ],
      "description": "The observable.\n"
    },
    "comment": " "
  },
  "can-route-pushstate.root": {
    "src": {
      "line": 32,
      "codeLine": 67,
      "path": "node_modules/can-route-pushstate/can-route-pushstate.js"
    },
    "type": "property",
    "body": "\n## Use\n\nBy default, a route like:\n\n    route(\":type/:id\")\n\nMatches urls like:\n\n    http://domain.com/contact/5\n\nBut sometimes, you only want to match pages within a certain directory.  For\nexample, an application that is a filemanager.  You might want to\nspecify root and routes like:\n\n    route.pushstate.root = \"/filemanager/\"\n    route(\"file-:fileId\");\n    route(\"folder-:fileId\")\n\nWhich matches urls like:\n\n    http://domain.com/filemanager/file-34234\n\n\t \n",
    "description": "Configure the base url that will not be modified. \n",
    "types": [
      {
        "type": "String",
        "description": "Represents the base url that pushstate will prepend to all\nroutes.  `root` defaults to: `\"/\"`.\n"
      }
    ],
    "title": "root",
    "name": "can-route-pushstate.root",
    "parent": "can-route-pushstate.static",
    "comment": " "
  },
  "can-route-pushstate.static": {
    "name": "can-route-pushstate.static",
    "title": "static",
    "type": "group",
    "parent": "can-route-pushstate",
    "description": "",
    "order": 0
  },
  "can-route-pushstate": {
    "src": {
      "path": "node_modules/can-route-pushstate/can-route-pushstate.md"
    },
    "body": "\n## Use\n\ncan-route-pushstate uses the same API as [can-route]. To start using can-route-pushstate all you need is to import `can-route-pushstate`, it will set itself as default binding on [can-route].\n\nYou can check current binding by inspecting `route.currentBinding`; the default value is `\"hashchange\"`.\n\n### Creating and changing routes\n\nTo create routes use `route(url, defaults)` like:\n\n```js\nroute(\"{page}\", {page: 'homepage'});\nroute(\"contacts/{username}\");\nroute(\"books/{genre}/{author}\");\n\nroute.ready(); // Initializes can-route\n```\n\nDo not forget to [can-route.ready initialize] can-route after creating all routes, do it by calling `route.ready()`.\n\nList of defined routes is contained in `route.routes`, you can examine current route state by calling:\n\n```js\nroute.attr(); //-> {page: \"homepage\", route: \"{page}\"}\n```\n\nAfter creating routes and initializing can-route you can update current route by calling `route.attr(attr, newVal)`:\n\n```js\nroute.attr('page', 'about');\nroute.attr(); //-> {page: \"about\", route: \"{page}\"}\n\n// without cleaning current route state\nroute.attr('username', 'veljko');\nroute.attr(); //-> {page: \"about\", route: \"{page}\", username: 'veljko'}\n\n// with cleaning current can-route state\nroute.attr({username: 'veljko'}, true);\nroute.attr(); //-> {username: \"veljko\", route: \"contacts/{username}\"}\n```\n\nTo update multiple attributes at once pass hash of attributes to `route.attr(hashOfAttrs, true)`. Pass `true` as second argument to clean up current state.\n\n```js\nroute.attr({genre: 'sf', author: 'adams'}, true);\nroute.attr(); //-> {genre: \"sf\", author: \"adams\", route: \"books/{genre}/{author}\"}\n```\n\n`window.location` acts as expected:\n\n```js\nwindow.location.pathname; //-> \"/books/sf/adams\"\nwindow.location.hash; //-> \"\", hash remains unchanged\n```\n\nTo generate urls use `route.url({attrs})`:\n\n```js\nroute.url({username: 'justinbmeyer'}); //-> '/contacts/justinbmeyer'\n```\n\n### Listening changes on matched route\n\nAs can-route contains a map that represents `window.location.pathname`, you can bind on it.\n\nTo bind to specific attributes on can-route:\n\n```js\nroute.bind('username', function(ev, newVal, oldVal) {\n\t//-> ev:     {EventObject}\n\t//-> newVal: 'nikica'\n\t//-> oldVal: 'veljko'\n});\n\nroute.attr({username: nikica}, true);\n```\n\n### Using different pathname root\n\ncan-route-pushstate has one additional property, `route.bindings.pushstate.root`, which specifies the part of that pathname that should not change. For example, if we only want to have pathnames within `http://example.com/contacts/`, we can specify a root like:\n\n```js\nroute.bindings.pushstate.root = \"/contacts/\"\nroute(\"{page}\");\nroute.url({page: \"list\"}) //-> \"/contacts/list\"\nroute.url({foo: \"bar\"})   //-> \"/contacts/?foo=bar\"\n```\n\nNow, all routes will start with `\"/contacts/\"`, the default `route.bindings.pushstate.root` value is `\"/\"`.\n\n### Updating the current route\n\ncan-route-pushstate also allows changes to the current route state without creating a new history entry. This behavior can be controlled using the `replaceStateOn`, `replaceStateOff`, and `replaceStateOnce` methods.\n\nEnable the behavior by calling `replaceStateOn` with specified route property keys like:\n\n```js\nroute.replaceStateOn('page', 'action');\nroute.attr('page', 'dashboard'); // Route changes, no new history record\n```\n\nTo return the `attr` call back to normal the `pushstate` behavior, call `replaceStateOff` with the specified route property keys like:\n\n```js\nroute.replaceStateOff('action');\nroute.attr('action', 'remove'); // Route changes, new history record is created\n```\n\nThe behavior can be configured to occur only once for a specific property using `replaceStateOnce` like:\n\n```js\nroute.replaceStateOnce('page');\nroute.attr('page', 'dashboard'); // No new history record\nroute.attr('page', 'search'); // New history record is created\n```\n\n\n## Planning route structure\n\nComplications can arise if your route structure mimics the folder structure inside your app's public directory.  For example, if you have a folder structure like the one in this url for your admin app...\n\n`/admin/users/list.js`\n\n... using a route of /admin/users on the same page that uses the list.js file will require the use of a trailing slash on all routes and links.  The browser already learned that '/admin/users' is folder.  Because folders were originally denoted by a trailing slash in a url, the browser will correct the url to be '/admin/users/'.  While it is possible to add the trailing slash in routes and listen for them, any link to the page that omits the trailing slash will not trigger the route handler.\n\n",
    "description": "Changes [can-route] to use [pushstate](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history)\nto change the window's [pathname](https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.pathname) instead\nof the [hash](https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.hash).\n\n```js\nvar route = require(\"can-route-pushstate\");\n\nroute(\"{page}\", { page: \"home\" });\nroute.ready();\n\nroute.attr(\"page\", \"user\");\n\nlocation.pathname; // -> \"/user\"\n```\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "The",
            "description": "pushstate object comprises several properties that configure the behavior of [can-route] to work with `history.pushstate`.\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can-route-pushstate",
    "parent": "can-routing",
    "collection": "can-core",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-route-pushstate/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-event": "^3.5.0",
        "can-globals": "^0.2.3",
        "can-route": "^3.1.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Pushstate for can-route",
      "devDependencies": {
        "bit-docs": "0.0.8-0",
        "can-define": "^1.2.0",
        "can-map": "^3.1.0",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.7.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-route-pushstate",
      "name": "can-route-pushstate",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-route-pushstate.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.1.2"
    },
    "comment": " "
  },
  "can-stache-key": {
    "src": {
      "path": "node_modules/can-stache-key/can-stache-key.md"
    },
    "body": "\nRead and write keys on a value\n\n",
    "description": "\n# can-stache-key\n",
    "name": "can-stache-key",
    "type": "page",
    "hide": true
  },
  "can-symbol.for": {
    "type": "function",
    "name": "can-symbol.for",
    "parent": "can-symbol",
    "src": {
      "line": 27,
      "codeLine": 37,
      "path": "node_modules/can-symbol/can-symbol.js"
    },
    "body": "",
    "description": "Get a symbol based on a known string identifier, or create it if it doesn't exist. \n",
    "title": "for",
    "signatures": [
      {
        "code": "canSymbol.for(String)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "description",
            "description": "The string value of the symbol"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "CanSymbol"
            }
          ],
          "description": "The globally unique and consistent symbol with the given string value.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "description",
      "description": "The string value of the symbol"
    },
    "_curReturn": {
      "types": [
        {
          "type": "CanSymbol"
        }
      ],
      "description": "The globally unique and consistent symbol with the given string value.\n "
    }
  },
  "can-symbol.keyFor": {
    "type": "function",
    "name": "can-symbol.keyFor",
    "parent": "can-symbol",
    "src": {
      "line": 45,
      "codeLine": 55,
      "path": "node_modules/can-symbol/can-symbol.js"
    },
    "body": "",
    "description": "Get the description for a symbol. \n",
    "title": "keyFor",
    "signatures": [
      {
        "code": "canSymbol.keyFor(CanSymbol)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "description",
            "description": "The string value of the symbol"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "CanSymbol"
            }
          ],
          "description": "The globally unique and consistent symbol with the given string value.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "description",
      "description": "The string value of the symbol"
    },
    "_curReturn": {
      "types": [
        {
          "type": "CanSymbol"
        }
      ],
      "description": "The globally unique and consistent symbol with the given string value.\n "
    }
  },
  "can-symbol/symbols/type": {
    "name": "can-symbol/symbols/type",
    "title": "Type Symbols",
    "type": "group",
    "parent": "can-symbol",
    "description": "",
    "order": 0
  },
  "can-symbol/symbols/shape": {
    "name": "can-symbol/symbols/shape",
    "title": "Shape Symbols",
    "type": "group",
    "parent": "can-symbol",
    "description": "",
    "order": 0
  },
  "can-symbol/symbols/get-set": {
    "name": "can-symbol/symbols/get-set",
    "title": "Get/Set Symbols",
    "type": "group",
    "parent": "can-symbol",
    "description": "",
    "order": 0
  },
  "can-symbol/symbols/call": {
    "name": "can-symbol/symbols/call",
    "title": "Call Symbols",
    "type": "group",
    "parent": "can-symbol",
    "description": "",
    "order": 0
  },
  "can-symbol/symbols/observe": {
    "name": "can-symbol/symbols/observe",
    "title": "Observe Symbols",
    "type": "group",
    "parent": "can-symbol",
    "description": "",
    "order": 0
  },
  "can-symbol": {
    "src": {
      "path": "node_modules/can-symbol/can-symbol.md"
    },
    "body": "\n```\n\tvar MyIDSymbol = CanSymbol(\"my_ID\");\n\n\t// ES5\n\tvar obj = {};\n\tobj[MyIDSymbol] = 1;\n\n\t// ES6 and above\n\tconst obj = {\n\t\t[myIDSymbol]: 1\n\t};\n```\n\n",
    "description": "Symbols used to detail how CanJS may operate on different objects \nCanJS has a consistent internal interface for objects to interact with each other, and this is also important for interop\nwith external libraries.  CanJS uses symbols to identify object types, property access methods, and for event\nhandling.\n\n`can-symbol` also has a polyfill function that will fake symbols on unsupported platforms.\n\n",
    "name": "can-symbol",
    "type": "page",
    "parent": "can-polyfills",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "core@donejs.com",
        "url": "http://donejs.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-symbol/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "^1.0.0"
      },
      "deprecated": false,
      "description": "Well known symbols used to detail how to operate on different objects",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.0.0-alpha.0",
        "donejs-cli": "^1.0.0-alpha.2",
        "generator-donejs": "^1.0.0-alpha.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.5",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "Done",
        "JS"
      ],
      "main": "can-symbol",
      "name": "can-symbol",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-symbol.git"
      },
      "scripts": {
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postpublish": "git push --tags && git push",
        "preversion": "npm test",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox"
      },
      "system": {
        "main": "can-symbol",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "1.4.1"
    },
    "signatures": [
      {
        "code": "canSymbol(String)",
        "description": "\n\nCreate or reuse symbols based on an optional string description\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-simple-dom": {
    "src": {
      "path": "node_modules/can-simple-dom/can-simple-dom.md"
    },
    "body": "\nImplements a small subset of the WHATWG DOM specification.\n\n",
    "description": "\n# can-simple-dom\n",
    "name": "can-simple-dom",
    "type": "page",
    "hide": true
  },
  "changelog": {
    "src": {
      "path": "node_modules/can-validate/changelog.md"
    },
    "body": "\nSee the [latest releases on GitHub](https://github.com/canjs/can-validate/releases).\n\n## [1.0.0.pre]\n\n### Removed\n\n- No longer ships with validate.js shims\n- No longer ships with can.Map plugin\n- `validate`, `one`, and `isValid` methods\n\n### Added\n\n- `test` method, behaves similarly as `isValid` but also sets errors\n- `errors` method to retrieve errors\n- Register validator and library methods\n- Extend method for plugins using can-construct\n\n## [0.9.2] - 2015-06-02\n\n### Changed\n\n- Cleaning up code after incorrect merge.\n\n## [0.9.1] - 2015-06-02\n\n### Changed\n\n- Fixed Validate all bug where some properties would not get properly validate when undefined in map instance.\n- Fixed overloading of validate list on validate all method.\n\n## [0.9.0] - 2015-06-01\n\n### Changed\n\n- [#26](https://github.com/canjs/can-validate/issues/26) Fixed bug that overwrote validate properties for all instances of a Map or Model. Computes are now cached to a dunder property versus overwriting the main `validate` property.\n- [#27](https://github.com/canjs/can-validate/issues/27) Fixed the `validate` method so it resolves computes. Computes are created from functions passed as validate options so validation can be triggered when compute change is triggered.\n- Improved validate init. Using a better method for detecting when Map is initing.\n\n## [0.8.4] - 2016-06-01\n\n### Added\n\n- Added tests for issue [#26](https://github.com/canjs/can-validate/issues/26)\n- Added tests for issue [#27](https://github.com/canjs/can-validate/issues/27)\n\n### Changed\n\n- Updated dependencies\n- Switched to Mocha\n- Improved tests\n\n## [0.8.3] - 2016-04-21\n\n### Changed\n\n- Fixed bug when errors was blank would cause console error\n\n## [0.8.2] - 2016-03-02\n\n### Changed\n\n- Improved handling of validation strings, passes strings through to Validate.JS.\n\n## [0.8.1] - 2016-02-03\n\n### Added\n\n- This change log\n- Contributing guide\n\n### Changed\n\n- Changed documentation root to `can-validate-plugin`, changed from `can-validate-library`.\n- Improved readme.\n- Improved overall documentation.\n\n### Removed\n\n- Removed CanJS Validations library documentation since it is still a WIP.\n\n## [0.8.0] - 2015-12-03\n\n### Changed\n- Fixed memory leaks.\n- Improved validate object compute handling.\n- Updated to work with CanJS 2.3.x.\n\n## [0.7.1] - 2015-11-23\n\n### Changed\n- Improved build.\n\n## [0.7.0] - 2015-10-19\n\n### Added\n- Added XO for linting.\n\n### Changed\n- Cleaned up lint errors in repo.\n\n## [0.6.0] - 2015-10-19\n\n### Added\n- Improved ability to pass functions to validation properties.\n\n### Changed\n- Fixed map init bug.\n\n## [0.5.2] - 2015-10-18\n\n### Changed\n- Fixed tests.\n- Fixed merge conflicts/errors.\n\n## [0.5.1] - 2015-10-01\n\n### Changed\n- Fixed require bug.\n\n## [0.5.0] - 2015-07-16\n\n### Added\n- Added \"validate all\" method to can.Map plugin\n\n## [0.4.2] - 2015-07-13\n\n### Added\n- Published to NPM\n\n## [0.4.1] - 2015-07-13\n\n### Added\n- Inline docs.\n- Added DocumentJS dependency.\n\n## [0.4.0] - 2015-07-10\n\n### Changed\n- Restructured repository.\n\n## [0.3.0] - 2015-07-10\n\n### Added\n- Browserify build.\n\n### Changed\n- Overall build improvements.\n\n## [0.2.0] - 2015-07-09\n\n### Changed\n- Made buildable. Using `import` over Steal syntax.\n\n## [0.1.0] - 2015-07-08\n\n### Added\n- Created can-validate entry point.\n- Created can.Map plugin.\n- Created ValidateJS shim\n\n\n[0.8.0]: https://github.com/canjs/can-validate/commit/0b98de198af17980174531146e43fb8c4b5e11a6\n[0.7.1]: https://github.com/canjs/can-validate/commit/2a58bf9ef280c2bb378221c6c18e85c7fed6daa3\n[0.7.0]: https://github.com/canjs/can-validate/commit/6be268da2a02e2985f71fa1f7196bfad94c84ca5\n[0.6.0]: https://github.com/canjs/can-validate/commit/0383d482353319a6eec3cf218daaa99b8ce62585\n[0.5.2]: https://github.com/canjs/can-validate/commit/17f46a11fb3f788e029359476bca83a67dca2b94\n[0.5.1]: https://github.com/canjs/can-validate/commit/5280c965df668b3eb1b95d10847f20676a3c5820\n[0.5.0]: https://github.com/canjs/can-validate/commit/53d965869263f39ea03dca97822fd5173cf62cdc\n[0.4.2]: https://github.com/canjs/can-validate/commit/608ee0cefdc161ecdf186980738952c86c937981\n[0.4.1]: https://github.com/canjs/can-validate/commit/c15d0b72bcc3e7343615d41baccbf3cf10242898\n[0.4.0]: https://github.com/canjs/can-validate/commit/a1d581aa31c304b04a7bdb4dc40106cf5c48771d\n[0.3.0]: https://github.com/canjs/can-validate/commit/4a7de30a12c27e7db992ac2bfcdb55e94e61c17a\n[0.2.0]: https://github.com/canjs/can-validate/commit/7ba46b1ea42315f68532f4246031d9bf074b785d\n[0.1.0]: https://github.com/canjs/can-validate/commit/b9a9aa2c43d672d9c238a506d788bafb3f89ee70\n\n",
    "description": "\n# Change log\n",
    "name": "changelog",
    "title": "Changelog",
    "type": "page",
    "parent": "can-validate-plugin",
    "hide": true
  },
  "can-types": {
    "name": "can-types",
    "type": "module",
    "parent": "can-typed-data",
    "src": {
      "line": 5,
      "codeLine": 26,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "\n## Use\n\n`can-types` exports an object with placeholder functions that\ncan be used to provide default types or test if something is of a certain type.\n\nFor example, `can-define/map/map` might overwrite `DefeaultMap` to return DefineMap\n\n```js\ntypes.DefaultMap = DefineMap;\n```\n\n",
    "description": "A stateful container for CanJS type information. \n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-types/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-globals": "^0.2.2",
        "can-log": "^0.1.0",
        "can-namespace": "1.0.0",
        "can-reflect": "^1.0.0",
        "can-symbol": "^1.0.0"
      },
      "deprecated": false,
      "description": "A stateful container for CanJS type information",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-types",
      "name": "can-types",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-types.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "1.1.3"
    },
    "comment": " "
  },
  "can-types.DefaultMap": {
    "name": "can-types.DefaultMap",
    "type": "property",
    "parent": "can-types",
    "src": {
      "line": 75,
      "codeLine": 83,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Map",
        "description": "\n\n  The default map type to create if a map is needed.  If both [can-map] and [can-define/map/map]\n  are imported, the default type will be [can-define/map/map].\n "
      }
    ],
    "title": "DefaultMap"
  },
  "can-types.DefaultList": {
    "name": "can-types.DefaultList",
    "type": "property",
    "parent": "can-types",
    "src": {
      "line": 84,
      "codeLine": 92,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "can-connect.List",
        "description": "\n\n  The default list type to create if a list is needed. If both [can-list] and [can-define/list/list]\n  are imported, the default type will be [can-define/list/list].\n "
      }
    ],
    "title": "DefaultList"
  },
  "can-types.queueTask": {
    "type": "function",
    "name": "can-types.queueTask",
    "parent": "can-types",
    "src": {
      "line": 93,
      "codeLine": 99,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "title": "queueTask",
    "signatures": [
      {
        "code": "types.queueTask(task)",
        "description": "\n  Run code that will be queued at the end of the current batch.",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "task",
            "description": "\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "task",
      "description": "\n "
    }
  },
  "can-types.wrapElement": {
    "type": "function",
    "name": "can-types.wrapElement",
    "parent": "can-types",
    "src": {
      "line": 103,
      "codeLine": 111,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "title": "wrapElement",
    "signatures": [
      {
        "code": "types.wrapElement(element)",
        "description": "\n  Wraps an element into an object useful by DOM libraries ala jQuery.\n",
        "params": [
          {
            "types": [
              {
                "type": "Node"
              }
            ],
            "name": "element",
            "description": "Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A wrapped object.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Node"
        }
      ],
      "name": "element",
      "description": "Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A wrapped object.\n "
    }
  },
  "can-types.unwrapElement": {
    "type": "function",
    "name": "can-types.unwrapElement",
    "parent": "can-types",
    "src": {
      "line": 114,
      "codeLine": 122,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "title": "unwrapElement",
    "signatures": [
      {
        "code": "types.unwrapElement(object)",
        "description": "\n  Unwraps an object that contains an element within.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "Any object that can be unwrapped into a Node."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Node"
            }
          ],
          "description": "A Node.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "object",
      "description": "Any object that can be unwrapped into a Node."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Node"
        }
      ],
      "description": "A Node.\n "
    }
  },
  "can-validate-interface": {
    "src": {
      "path": "node_modules/can-validate-interface/can-validate-interface.md"
    },
    "body": "",
    "description": "`can-validate-interface` provides simple property existence validation. Use to prevent errors resulting from missing properties on input objects.\n\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-validate-interface",
    "parent": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-validate-interface/issues"
      },
      "bundleDependencies": false,
      "dependencies": {},
      "deprecated": false,
      "description": "Utility to validate property existence. Test for missing properties before they cause errors later.",
      "devDependencies": {
        "can-connect": "^1.3.11",
        "chai": "^3.5.0",
        "mocha": "^3.3.0",
        "sinon": "^2.2.0",
        "steal-tools": "^1.3.5"
      },
      "homepage": "https://github.com/canjs/can-validate-interface#readme",
      "keywords": [
        "interface",
        "canjs",
        "can",
        "can-validate"
      ],
      "license": "MIT",
      "main": "index.js",
      "name": "can-validate-interface",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-validate-interface.git"
      },
      "scripts": {
        "build": "node build.js",
        "postpublish": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "test": "mocha",
        "version": "git commit -am \"Update version number\" && git checkout -b release && git add -f dist/"
      },
      "version": "0.1.0"
    },
    "signatures": [
      {
        "code": "makeInterfaceValidator(propertyArrays)",
        "description": "\n\nGet a function that validates a given object for the provided properties:\n\n```js\nvar makeInterfaceValidator = require(\"can-validate-interface\");\nvar dataMethods = [\"create\",\"read\",\"update\",\"delete\"];\nvar daoValidator = makeInterfaceValidator([dataMethods, \"id\"]);\n\nvar dao = {\n    create: function() {},\n    read: function() {},\n    update: function() {},\n    delete: function() {}\n};\n\nvar errors = daoValidator(dao);\n// errors == {message:\"missing expected properties\", related: [\"id\"]}\n\ndao.id = 10;\n\nerrors = daoValidator(dao);\n// errors == undefined\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Array",
                        "template": [
                          {
                            "types": [
                              {
                                "type": "String"
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "propertyArrays",
            "description": "Property names and arrays of property names to validate existence of\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "Object",
                    "options": [
                      {
                        "name": "{"
                      }
                    ]
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": [
                        {
                          "name": "*"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Function that validates an object for properties in propertyArrays and returns an error record or undefined if no properties are missing."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "String"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "name": "propertyArrays",
      "description": "Property names and arrays of property names to validate existence of\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "Object",
                "options": [
                  {
                    "name": "{"
                  }
                ]
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": [
                    {
                      "name": "*"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "Function that validates an object for properties in propertyArrays and returns an error record or undefined if no properties are missing."
    }
  },
  "validator": {
    "type": "function",
    "name": "validator",
    "params": [
      {
        "types": [
          {
            "type": "string"
          }
        ],
        "name": "id",
        "description": "The key name of the validator library."
      },
      {
        "types": [
          {
            "type": "object"
          },
          {
            "type": "function",
            "returns": {
              "types": [
                {
                  "type": "undefined"
                }
              ]
            },
            "params": []
          }
        ],
        "name": "validator",
        "description": "The validator libarary. Only pass instances."
      }
    ],
    "parent": "node_modules/can-validate-legacy/can-validate.js",
    "src": {
      "line": 16,
      "codeLine": 26,
      "path": "node_modules/can-validate-legacy/can-validate.js"
    },
    "body": "\n",
    "description": "Registers a library with can.validate. The last one registered is the default library.\nOverride the default by changing `_validatorId` to the key of the desired registered library.\n```js\nValidate.register('validatejs',validatejs);\n```\n",
    "_curParam": {
      "types": [
        {
          "type": "object"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "validator",
      "description": "The validator libarary. Only pass instances."
    },
    "hide": true
  },
  "register": {
    "type": "function",
    "name": "register",
    "params": [
      {
        "types": [
          {
            "type": "string"
          }
        ],
        "name": "id",
        "description": "The key name of the validator library."
      },
      {
        "types": [
          {
            "type": "object"
          },
          {
            "type": "function",
            "returns": {
              "types": [
                {
                  "type": "undefined"
                }
              ]
            },
            "params": []
          }
        ],
        "name": "validator",
        "description": "The validator libarary. Only pass instances."
      }
    ],
    "parent": "node_modules/can-validate-legacy/can-validate.js",
    "src": {
      "line": 30,
      "codeLine": 40,
      "path": "node_modules/can-validate-legacy/can-validate.js"
    },
    "body": "\n",
    "description": "Registers a library with can.validate. The last one registered is the default library.\nOverride the default by changing `_validatorId` to the key of the desired registered library.\n```js\nValidate.register('validatejs',validatejs);\n```\n",
    "_curParam": {
      "types": [
        {
          "type": "object"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "validator",
      "description": "The validator libarary. Only pass instances."
    },
    "hide": true
  },
  "isValid": {
    "type": "function",
    "name": "isValid",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "value",
        "description": "Some value to validate against."
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "options",
        "description": "Raw validation options. They will be processed since\nnot all options are valid for ValidateJS."
      }
    ],
    "parent": "node_modules/can-validate-legacy/shims/validatejs.js",
    "src": {
      "line": 62,
      "codeLine": 72,
      "path": "node_modules/can-validate-legacy/shims/validatejs.js"
    },
    "body": "\n",
    "description": "Simply checks if the property value will validate or not, this method will not set errors, it is meant to check validity *before* a property\nis set.\n",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "Raw validation options. They will be processed since\nnot all options are valid for ValidateJS."
    },
    "hide": true,
    "title": "Is Valid",
    "returns": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "True if valid, otherwise returns false\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "True if valid, otherwise returns false\n"
    }
  },
  "once": {
    "type": "function",
    "name": "once",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "value",
        "description": "Some value to validate against."
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "options",
        "description": "Raw validation options. They will be processed since\nnot all options are valid for ValidateJS."
      },
      {
        "types": [
          {
            "type": "string"
          }
        ],
        "name": "name",
        "description": "The key name of the value to validate. Used to prepend to\nerror messages, if any."
      }
    ],
    "parent": "node_modules/can-validate-legacy/shims/validatejs.js",
    "src": {
      "line": 23,
      "codeLine": 34,
      "path": "node_modules/can-validate-legacy/shims/validatejs.js"
    },
    "body": "\n",
    "description": "Validates a single property using provided validation options ",
    "_curParam": {
      "types": [
        {
          "type": "string"
        }
      ],
      "name": "name",
      "description": "The key name of the value to validate. Used to prepend to\nerror messages, if any."
    },
    "hide": true,
    "title": "Once",
    "returns": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "array"
        }
      ],
      "description": "Returns undefined if no errors, otherwise returns\na list of errors.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "array"
        }
      ],
      "description": "Returns undefined if no errors, otherwise returns\na list of errors.\n"
    }
  },
  "validate": {
    "type": "function",
    "name": "validate",
    "params": [],
    "parent": "node_modules/can-validate-legacy/map/validate/validate.js",
    "src": {
      "line": 139,
      "codeLine": 147,
      "path": "node_modules/can-validate-legacy/map/validate/validate.js"
    },
    "body": "\n",
    "description": "Runs validation on the entire map instance. Actual behavior of \"validate all\" is defined by the registered shim.\n\n",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "Raw validation options. They will be processed since\nnot all options are valid for ValidateJS. It should be a map of property keys\nwhich contain the respective validation properties."
    },
    "hide": true,
    "title": "Validate",
    "returns": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "array"
        }
      ],
      "description": "Returns undefined if no errors, otherwise returns\na list of errors.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "array"
        }
      ],
      "description": "Returns undefined if no errors, otherwise returns\na list of errors.\n"
    },
    "deprecated": [
      {
        "version": "1.0",
        "description": "`validate` is deprecated and will be removed in version 1.0.\nUse `_validate` instead.\n"
      }
    ]
  },
  "can/view/autorender": {
    "src": {
      "path": "node_modules/can-view-autorender/autorender.md"
    },
    "body": "\n\n## Use\n\nAs long is this module is part of your CanJS build or imported with RequireJS, StealJS, or SystemJS,\n[can/view/autorender.can-autorender] will automatically look for `can-autorender` tags and render them.  Once\nall templates have finished rendering, it will call any callbacks passed to `can.autorender()`.\n\n\nFor example, you might have a page like:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'\n\t\tmessage=\"Hello World\">\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\n\t<script src='jquery.js'></script>\n\t<!-- A CanJS build that includes this plugin -->\n\t<script src='can.custom.js'></script>\n\t<!-- All your app's code and components -->\n\t<script src='app.js'></script>\n\t<script>\n\t\t// Wait until everything has rendered.\n\t\tcan.autorender(function(){\n\n\t\t\t// Update the viewModel the template was rendred with:\n\t\t\t$(\"#main\").viewModel().attr(\"message\",\"Rendered!\");\n\n\t\t})\n\t</script>\n</body>\n```\n\n## Rendered placement\n\nIf the template source is a `<script>` tag within the `<body>`, the rendered template is placed\nimmediately following the template.\n\nFor example:\n\n```\n<body>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n\t<div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n\tHi!\n\t<div>...</div>\n</body>\n```\n\nIf the `<script>` tag is outside the body, for example in the `<head>`\ntag, the rendered result will be placed just before the closing `</body>` tag.\n\nFor example:\n\n```\n<head>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n</head>\n<body>\n\t<div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<head>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n</head>\n<body>\n\t<div>...</div>\n\tHi!\n</body>\n```\n\nIf the template source is any other element, the element's contents will be replaced with the rendered result.  For example:\n\n```\n<body>\n\t<div type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n\t<div type='text/stache' can-autorender message=\"Hi\">\n\t\tHi!\n\t</div>\n</body>\n```\n\n## Scope\n\nThe template is rendered with a [can.Map] made from the attributes of the\ntemplate source element.  That `map` is available on the\ntemplate source element via [can.viewModel].  You can\nchange the map at any time:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'>\n\t\t{{message}}!\n\t</script>\n\t<script>\n\t\tvar viewModel = can.viewModel(document.getElementById(\"main\"));\n\t\tviewModel.attr(\"message\",\"Hello There!\");\n\t</script>\n</body>\n```\n\nYou can change attributes on the element and it will update the\nviewModel too:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'>\n\t\t{{message}}!\n\t</script>\n\t<script>\n\t\tvar main = document.getElementById(\"main\");\n\t\tmain.setAttribute(\"message\",\"Hello There!\");\n\t</script>\n</body>\n```\n\n\n\n## StealJS Use\n\nFor demo pages that require very little setup:\n\n```\n<body>\n\t<script type='text/stache'>\n\t\t<can-import from=\"components/my-component\"/>\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\t<script src='../node_modules/steal/steal.js'\n\t\t\t\t\tmain='can/view/autorender/'>\n\t</script>\n</body>\n```\n\nFor demo pages that require a little custom setup:\n\n```\n<body>\n\t<script type='text/stache' can-autorender>\n\t\t<can-import from=\"components/my-component\"/>\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\t<script src='../node_modules/steal/steal.js'\n\t\t\t\t\tmain='@empty'>\n\t\tvar can = require('can');\n\t\tvar $ = reqire('jquery');\n\t\trequire('can/view/autorender/autorender');\n\n\t\t$(\"my-component\").viewModel().attr(\"message\", \"Hi\");\n\t</script>\n</body>\n```\n\n\n\n\n\n## Errors\n\nError callbacks will be called if a template has a parsing error or\na [can/view/stache/system.import] fails.\n\n",
    "description": "\nA module that automatically renders script and other elements with\nthe [can/view/autorender.can-autorender] attribute. This function is useful to know when\nthe templates have finished rendering.\n",
    "type": "module",
    "title": "can.autorender",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can/view/autorender",
    "parent": "can.view.plugins",
    "hide": true,
    "signatures": [
      {
        "code": "can.autorender(succcess, error)",
        "description": "\n\n\tRegisters functions to callback when all templates successfully render or an error in rendering happens.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "success",
            "description": "A function to callback when all autorendered templates have been rendered\nsuccessfully.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function to callback if a template was not rendered successfully.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function to callback if a template was not rendered successfully.\n"
    },
    "comment": " "
  },
  "can-view-autorender": {
    "src": {
      "path": "node_modules/can-view-autorender/can-view-autorender.md"
    },
    "body": "\n\n## Use\n\nAs long is this module is part of your CanJS build or imported with RequireJS, StealJS, or SystemJS,\n[can-view-autorender] will automatically look for `can-autorender` tags and render them.  Once\nall templates have finished rendering, it will call any callbacks passed to `can.autorender()`.\n\n\nFor example, you might have a page like:\n\n```\n<body>\n  <script type='text/stache' can-autorender id='main'\n    message=\"Hello World\">\n    <my-component>\n      {{message}}\n    </my-component>\n  </script>\n\n  <script src='jquery.js'></script>\n  <!-- A CanJS build that includes this plugin -->\n  <script src='can.all.js'></script>\n  <!-- All your app's code and components -->\n  <script src='app.js'></script>\n  <script>\n    // Wait until everything has rendered.\n    can.autorender(function(){\n\n      // Update the viewModel the template was rendred with:\n      $(\"#main\").viewModel().attr(\"message\",\"Rendered!\");\n\n    })\n  </script>\n</body>\n```\n\n## Rendered placement\n\nIf the template source is a `<script>` tag within the `<body>`, the rendered template is placed\nimmediately following the template.\n\nFor example:\n\n```\n<body>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n  <div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n  Hi!\n  <div>...</div>\n</body>\n```\n\nIf the `<script>` tag is outside the body, for example in the `<head>`\ntag, the rendered result will be placed just before the closing `</body>` tag.\n\nFor example:\n\n```\n<head>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n</head>\n<body>\n  <div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<head>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n</head>\n<body>\n  <div>...</div>\n  Hi!\n</body>\n```\n\nIf the template source is any other element, the element's contents will be replaced with the rendered result.  For example:\n\n```\n<body>\n  <div type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n  <div type='text/stache' can-autorender message=\"Hi\">\n    Hi!\n  </div>\n</body>\n```\n\n## Scope\n\nThe template is rendered with a [can.Map] made from the attributes of the\ntemplate source element.  That `map` is available on the\ntemplate source element via [can.viewModel].  You can\nchange the map at any time:\n\n```\n<body>\n  <script type='text/stache' can-autorender id='main'>\n    {{message}}!\n  </script>\n  <script>\n    var viewModel = can.viewModel(document.getElementById(\"main\"));\n    viewModel.attr(\"message\",\"Hello There!\");\n  </script>\n</body>\n```\n\nYou can change attributes on the element and it will update the\nviewModel too:\n\n```\n<body>\n  <script type='text/stache' can-autorender id='main'>\n    {{message}}!\n  </script>\n  <script>\n    var main = document.getElementById(\"main\");\n    main.setAttribute(\"message\",\"Hello There!\");\n  </script>\n</body>\n```\n\n\n\n## StealJS Use\n\nFor demo pages that require very little setup:\n\n```\n<body>\n  <script type='text/stache'>\n    <can-import from=\"components/my-component\"/>\n    <my-component>\n      {{message}}\n    </my-component>\n  </script>\n  <script src='../node_modules/steal/steal.js'\n          main='can/view/autorender/'>\n  </script>\n</body>\n```\n\nFor demo pages that require a little custom setup:\n\n```\n<body>\n  <script type='text/stache' can-autorender>\n    <can-import from=\"components/my-component\"/>\n    <my-component>\n      {{message}}\n    </my-component>\n  </script>\n  <script src='../node_modules/steal/steal.js'\n          main='@empty'>\n  </script>\n  <script>\n    steal('can','jquery','can/view/autorender/', function(can, $){\n      $(\"my-component\").viewModel().attr(\"message\", \"Hi\");\n    });\n  </script>\n</body>\n```\n\n\n\n\n\n## Errors\n\nError callbacks will be called if a template has a parsing error or\na [can/view/stache/system.import] fails.\n\n",
    "description": "\nA module that automatically renders script and other elements with\nthe `can-autorender` attribute. This function is useful to know when the templates have finished rendering.\n",
    "type": "module",
    "title": "can-view-autorender",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-autorender",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-autorender/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-event": "^3.6.0",
        "can-util": "^3.9.5",
        "can-view-model": "^3.3.0"
      },
      "deprecated": false,
      "description": "Automatically render templates found in the document",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-component": "^3.2.2",
        "can-define": "^1.3.2",
        "can-stache": "^3.3.0",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-autorender",
      "name": "can-view-autorender",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-autorender.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tags=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.1.1"
    },
    "parent": "can-views",
    "collection": "can-ecosystem",
    "signatures": [
      {
        "code": "autorender(success, error)",
        "description": "\n\n  Registers functions to callback when all templates successfully render or an error in rendering happens.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "success",
            "description": "A function to callback when all autorendered templates have been rendered\nsuccessfully.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function to callback if a template was not rendered successfully.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function to callback if a template was not rendered successfully.\n"
    },
    "comment": " "
  },
  "can-vdom.modules": {
    "name": "can-vdom.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-vdom",
    "description": "",
    "order": 0
  },
  "can-vdom.types": {
    "name": "can-vdom.types",
    "title": "types",
    "type": "group",
    "parent": "can-vdom",
    "description": "",
    "order": 0
  },
  "can-vdom": {
    "src": {
      "path": "node_modules/can-vdom/can-vdom.md"
    },
    "body": "\n\n\n## Shiming a browser environment\n\nImporting `can-vdom` will shim a browser-like environment into Node's globals. Use this approach to run code that expects a global `window` and/or `document` object.\n\n```js\nrequire(\"can-vdom\");\n\ntypeof window; // \"object\"\n\ntypeof window.addEventListener; // \"function\"\n\ndocument.getElementById(\"foo\"); // undefined\n```\n\n## Loading as a module\n\nIf you want to prevent setting globals you can load `can-vdom/make-window/make-window` directly:\n\n```js\nvar makeWindow = require(\"can-vdom/make-window/make-window\");\n\nvar myWindow = makeWindow(global);\n```\n\n",
    "description": "A browser-lite environment for Node.js or a worker thread. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "undefined",
        "description": "\n\nThe `can-vdom` module does not export anything, but it changes the current\nenvironment to have the limited subset of browser environment behavior and\nfunctionality needed to support CanJS templates and other behavior without\na native DOM.\n\n```js\nrequire(\"can-vdom\");\n\nwindow === global; // true\n\ndocument.getElementsByTagName(\"body\"); // [HTMLBodyElement]\n```\n\n`can-vdom` decorates the environment `global` to include:\n\n - a non-functional `navigator`, `location`, and `history` object.\n - a limitedly functional `document` with basic `Node` behavior, event binding and dispatching.\n\n\n"
      }
    ],
    "name": "can-vdom",
    "parent": "can-polyfills",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-vdom/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-assign": "^1.0.0",
        "can-globals": "^0.2.2",
        "can-simple-dom": "^1.1.0",
        "can-view-parser": "^3.5.1"
      },
      "deprecated": false,
      "description": "A browser-lite environment for nodejs",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-util": "^3.9.0",
        "chai": "^4.1.2",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.2.0",
        "donejs-cli": "^1.0.1",
        "generator-donejs": "^1.0.5",
        "jshint": "^2.9.1",
        "mocha": "^4.0.0",
        "steal": "^1.2.10",
        "steal-mocha": "^1.0.0",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "donejs",
        "canjs"
      ],
      "main": "can-vdom.js",
      "name": "can-vdom",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-vdom.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run test:node && npm run test:browser",
        "test:browser": "testee test/test.html --browsers firefox --reporter Spec",
        "test:node": "mocha test/test.js",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-vdom",
        "map": {
          "./assert": "chai/chai"
        },
        "meta": {
          "chai/chai": {
            "format": "global",
            "exports": "chai.assert"
          }
        },
        "plugins": [
          "chai"
        ]
      },
      "version": "3.2.3"
    },
    "comment": " "
  },
  "can-view-href": {
    "src": {
      "path": "node_modules/can-view-href/can-view-href.md"
    },
    "body": "\n## Use\n\nWith no pretty routing rules, the following:\n\n```html\n<li><a can-href='{page=\"recipe\" id=5}'>{{recipe.name}}</a></li>\n```\n\nproduces:\n\n```html\n<li><a href='#!&page=5&id=5'>{{recipe.name}}</a></li>\n```\n\nIf pretty route is defined like:\n\n```js\ncan.route(\":page/:id\")\n```\n\nThe previous use of `can-href` will instead produce:\n\n```html\n<li><a href='#!page/5'>{{recipe.name}}</a></li>\n```\n\nYou can use values from stache's scope like:\n\n```html\n<li><a can-href='{page=\"recipe\" id=recipeId}'>{{recipe.name}}</a></li>\n```\n\nIf `recipeId` was 6:\n\n```html\n<li><a href='#!page/6'>{{recipe.name}}</a></li>\n```\n\nIf `recipeId` is observable and changes to 7:\n\n```html\n<li><a href='#!page/7'>{{recipe.name}}</a></li>\n```\n\n",
    "description": "Sets an element’s `href` attribute so that its url will set the specified attribute values on [can-route]. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "undefined"
      }
    ],
    "name": "can-view-href",
    "parent": "can-views",
    "collection": "can-legacy",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.3.1",
        "can-route": "^3.1.0",
        "can-stache": "^3.1.0",
        "can-util": "^3.9.5",
        "can-view-callbacks": "^3.1.0",
        "can-view-scope": "^3.2.0"
      },
      "deprecated": false,
      "description": "Make flexible route links",
      "devDependencies": {
        "can-map": "^3.3.1",
        "can-ssr": "^0.11.6",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs",
        "donejs",
        "canjs-plugin"
      ],
      "main": "can-view-href",
      "name": "can-view-href",
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint *.js test/*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-view-href",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.1.0"
    },
    "deprecated": [
      {
        "version": "2.3",
        "description": "Use the [can-stache.helpers.routeUrl routeUrl helper] instead like:\n`href=\"{{routeUrl prop=value}}\"`.\n"
      }
    ],
    "signatures": [
      {
        "code": "can-href='{[attrName=attrValue...]}'",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": ""
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              }
            ],
            "name": "attrValue",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        }
      ],
      "name": "attrValue",
      "description": "\n"
    },
    "comment": " "
  },
  "can-view-model": {
    "src": {
      "path": "node_modules/can-view-model/can-view-model.md"
    },
    "body": "\n## Use\n\n**can-view-model** is used to get and set properties on an element’s ViewModel. Each element in the DOM can have an associated ViewModel. An example of this is a [can-component] and its associated [can-component.prototype.ViewModel].\n\nThis shows a Component and getting its ViewModel:\n\n```html\n<my-tabs>\n ...\n</my-tabs>\n```\n\n```js\nvar canViewModel = require(\"can-view-model\");\n\nvar element = document.querySelector(\"my-tabs\");\nvar vm = canViewModel(element);\n```\n\nThe other signatures provide the ability to get and set properties on the ViewModel. For example, this sets the `foo` property on a component’s viewModel:\n\n```js\nvar canViewModel = require(\"can-view-model\");\n\nvar element = document.querySelector(\"my-tabs\");\nvar vm = canViewModel(element);\n\ncanViewModel(element, \"foo\", \"bar\");\n\nconsole.log(vm.foo, \"bar\");\n```\n\n## Setting an element’s ViewModel\n\nOne thing that can-view-model does ***not*** do is provide a way to set what an element’s ViewModel should be. To do that, use [can-util/dom/data/data] instead like so:\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar element = document.querySelector(\"#my-id\");\n\nvar myVm = new DefineMap();\n\ndomData.set.call(element, \"viewModel\", myVm);\n```\n\n",
    "description": "Gets the ViewModel of an [element](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement). \n",
    "type": "module",
    "title": "can-view-model",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-model",
    "parent": "can-views",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-globals": "^0.2.3",
        "can-namespace": "1.0.0",
        "can-reflect": "^1.2.1",
        "can-simple-map": "^3.3.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.5"
      },
      "deprecated": false,
      "description": "gets or sets the view model of an element",
      "devDependencies": {
        "can-define": "^1.3.3",
        "can-map": "^3.3.1",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "donejs"
      ],
      "main": "can-view-model",
      "name": "can-view-model",
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.5.0"
    },
    "signatures": [
      {
        "code": "canViewModel(element)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-types.DefaultMap] if it doesn’t already exist, and returns the map.\n\n```js\nvar vm = canViewModel(element);\n\nvar vm2 = canViewModel(\"#element2id\");\n\nvar vm3 = canViewModel($([element3]));\n\nvar vm4 = canViewModel(document.querySelectorAll(\".element4class\"));\n```",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "String"
              },
              {
                "type": "ArrayLike"
              }
            ],
            "name": "element",
            "description": "Any element in the DOM, represented by a reference to the element itself, a query selector string, or an Array-like holding the element in its zero index.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            },
            {
              "type": "can-define/map/map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The ViewModel associated with this element.\n"
        }
      },
      {
        "code": "canViewModel(element, property)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-types.DefaultMap] if it doesn’t already exist. Then, gets the **property** inside of the ViewModel and returns that.\n\n```\nvar foo = canViewModel(element, \"foo\");\n\nconsole.log(foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "String"
              },
              {
                "type": "ArrayLike"
              }
            ],
            "name": "element",
            "description": "Any element in the DOM, represented by a reference to the element itself, a query selector string, or an Array-like holding the element in its zero index."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The property to get from the ViewModel.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property on the ViewModel or undefined if the property doesn’t exist.\n"
        }
      },
      {
        "code": "canViewModel(element, property, value)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-types.DefaultMap] if it doesn’t already exist. Sets the **property** on that map to **value**.\n\n```js\ncanViewModel(element, \"foo\", \"bar\");\n\nvar foo = canViewModel(element, \"foo\");\n\nconsole.log(foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "String"
              },
              {
                "type": "ArrayLike"
              }
            ],
            "name": "element",
            "description": "Any element in the DOM, represented by a reference to the element itself, a query selector string, or an Array-like holding the element in its zero index."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The property that is being set on the ViewModel."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value being set on the property.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The element.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The element.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value being set on the property.\n"
    },
    "comment": " "
  },
  "can-view-nodelist.update": {
    "type": "function",
    "name": "can-view-nodelist.update",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 124,
      "codeLine": 137,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "\n",
    "title": "update",
    "signatures": [
      {
        "code": "nodeLists.update(nodeList, newNodes)",
        "description": "\n\nUpdates a nodeList with new items, i.e. when values for the template have changed.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "The list to update with the new nodes."
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "newNodes",
            "description": "The new nodes to update with.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Node"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The nodes that were removed from `nodeList`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "newNodes",
      "description": "The new nodes to update with.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "description": "The nodes that were removed from `nodeList`.\n"
    }
  },
  "can-view-nodelist.nestReplacements": {
    "type": "function",
    "name": "can-view-nodelist.nestReplacements",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 163,
      "codeLine": 177,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "nestReplacements",
    "signatures": [
      {
        "code": "nodeLists.nestReplacements(list)",
        "description": "\n\nGoes through each node in the list. `[el1, el2, el3, ...]`\nFinds the nodeList for that node in replacements.  el1's nodeList might look like `[el1, [el2]]`.\nReplaces that element and any other elements in the node list with the\nnodelist itself. resulting in `[ [el1, [el2]], el3, ...]`\nIf a replacement is not found, it was improperly added, so we add it as a deepChild.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "list",
            "description": "The nodeList of nodes to go over\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "list",
      "description": "The nodeList of nodes to go over\n\n"
    }
  },
  "can-view-nodelist.nestList": {
    "type": "function",
    "name": "can-view-nodelist.nestList",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 200,
      "codeLine": 213,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "nestList",
    "signatures": [
      {
        "code": "nodeLists.nestList(list)",
        "description": "\n\nIf a given list does not exist in the nodeMap then create an lookup\nid for it in the nodeMap and assign the list to it.\nIf the the provided does happen to exist in the nodeMap update the\nelements in the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "list",
            "description": "The nodeList being nested.\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "list",
      "description": "The nodeList being nested.\n\n "
    }
  },
  "can-view-nodelist.last": {
    "type": "function",
    "name": "can-view-nodelist.last",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 234,
      "codeLine": 247,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "last",
    "signatures": [
      {
        "code": "nodeLists.last(nodeList)",
        "description": "\n\nReturn the last HTMLElement in a nodeList; if the last\nelement is a nodeList, returns the last HTMLElement of\nthe child list, etc.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The last element of the last list nested in this list.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "A nodeList."
    },
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The last element of the last list nested in this list.\n\n "
    }
  },
  "can-view-nodelist.first": {
    "type": "function",
    "name": "can-view-nodelist.first",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 258,
      "codeLine": 272,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "first",
    "signatures": [
      {
        "code": "nodeLists.first(nodeList)",
        "description": "\n\nReturn the first HTMLElement in a nodeList; if the first\nelement is a nodeList, returns the first HTMLElement of\nthe child list, etc.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The first element of the first list nested in this list.\n\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "A nodeList."
    },
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The first element of the first list nested in this list.\n\n\n "
    }
  },
  "can-view-nodelist.register": {
    "type": "function",
    "name": "can-view-nodelist.register",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 294,
      "codeLine": 309,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "\n",
    "title": "register",
    "signatures": [
      {
        "code": "nodeLists.register(nodeList, unregistered, parent, directlyNested)",
        "description": "\n\nRegisters a nodeList and returns the nodeList passed to register.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "unregistered",
            "description": "A callback to call when the nodeList is unregistered."
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "parent",
            "description": "The parent nodeList of this nodeList."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "directlyNested",
            "description": "`true` if nodes in the nodeList are direct children of the parent."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-view-nodelist/types/NodeList"
            }
          ],
          "description": "The passed in nodeList.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "directlyNested",
      "description": "`true` if nodes in the nodeList are direct children of the parent."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "description": "The passed in nodeList.\n\n "
    }
  },
  "can-view-nodelist.unregisterChildren": {
    "type": "function",
    "name": "can-view-nodelist.unregisterChildren",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 337,
      "codeLine": 348,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "unregisterChildren",
    "signatures": [
      {
        "code": "nodeLists.unregisterChildren(nodeList)",
        "description": "\n\nUnregister all childen within the provided list and return the\nunregistred nodes.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "The nodeList of child nodes to unregister."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "The list of all nodes that were unregistered.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "The nodeList of child nodes to unregister."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "The list of all nodes that were unregistered.\n "
    }
  },
  "can-view-nodelist.unregister": {
    "type": "function",
    "name": "can-view-nodelist.unregister",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 375,
      "codeLine": 387,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "unregister",
    "signatures": [
      {
        "code": "nodeLists.unregister(nodeList, isChild)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "nodeList",
            "description": "a nodeList to unregister from its parent"
          },
          {
            "types": [
              {
                "type": "isChild"
              }
            ],
            "name": "true",
            "description": "if the nodeList is a direct child, false if a deep child"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a list of all nodes that were unregistered\n\nUnregister's a nodeList and returns the unregistered nodes.\nCall if the nodeList is no longer being updated. This will\nalso unregister all child nodeLists.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "isChild"
        }
      ],
      "name": "true",
      "description": "if the nodeList is a direct child, false if a deep child"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a list of all nodes that were unregistered\n\nUnregister's a nodeList and returns the unregistered nodes.\nCall if the nodeList is no longer being updated. This will\nalso unregister all child nodeLists.\n"
    }
  },
  "can-view-nodelist.after": {
    "type": "function",
    "name": "can-view-nodelist.after",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 408,
      "codeLine": 420,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "after",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.after(oldElements, newFrag)",
        "description": "\n\n  Inserts `newFrag` after `oldElements`.\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "The elements to use as reference."
          },
          {
            "types": [
              {
                "type": "DocumentFragment"
              }
            ],
            "name": "newFrag",
            "description": "The fragment to insert.\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "newFrag",
      "description": "The fragment to insert.\n\n "
    }
  },
  "can-view-nodelist.replace": {
    "type": "function",
    "name": "can-view-nodelist.replace",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 429,
      "codeLine": 441,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "replace",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.replace(oldElements, newFrag)",
        "description": "\n\nReplaces `oldElements` with `newFrag`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "the list elements to remove"
          },
          {
            "types": [
              {
                "type": "DocumentFragment"
              }
            ],
            "name": "newFrag",
            "description": "the fragment to replace the old elements\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "newFrag",
      "description": "the fragment to replace the old elements\n\n "
    }
  },
  "can-view-nodelist.remove": {
    "type": "function",
    "name": "can-view-nodelist.remove",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 462,
      "codeLine": 473,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "remove",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.remove(elementsToBeRemoved)",
        "description": "\n\nRemove all Nodes in `oldElements` from the DOM.\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "the list of Elements to remove (must have a common parent)\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ArrayLike",
          "template": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "name": "oldElements",
      "description": "the list of Elements to remove (must have a common parent)\n\n "
    }
  },
  "can-view-nodelist/methods": {
    "name": "can-view-nodelist/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-view-nodelist",
    "description": "",
    "order": 0
  },
  "can-view-nodelist/types": {
    "name": "can-view-nodelist/types",
    "title": "types",
    "type": "group",
    "parent": "can-view-nodelist",
    "description": "",
    "order": 0
  },
  "can-view-nodelist": {
    "src": {
      "path": "node_modules/can-view-nodelist/can-view-nodelist.md"
    },
    "body": "",
    "description": "Adds nesting of text nodes \n`can.view.nodeLists` are used to make sure \"directly nested\" live-binding\nsections update content correctly.\n\nConsider the following template:\n\n```html\n<div>\n{{#if items.length}}\n    Items:\n        {{#items}}\n            <label></label>\n        {{/items}}\n{{/if}}\n</div>\n```\n\nThe `{{#if}}` and `{{#items}}` seconds are \"directly nested\" because\nthey share the same `<div>` parent element.\n\nIf `{{#items}}` changes the DOM by adding more `<labels>`,\n`{{#if}}` needs to know about the `<labels>` to remove them\nif `{{#if}}` is re-rendered.  `{{#if}}` would be re-rendered, for example, if\nall items were removed.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-nodelist",
    "parent": "can-views",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-nodelist/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "1.0.0",
        "can-util": "^3.9.5"
      },
      "deprecated": false,
      "description": "Adds nesting of text nodes",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^1.0.7",
        "jshint": "^2.9.1",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-nodelist",
      "name": "can-view-nodelist",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-nodelist.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.1.0"
    }
  },
  "can-view-target": {
    "src": {
      "path": "node_modules/can-view-target/can-view-target.md"
    },
    "body": "",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-target",
    "parent": "can-views",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-target/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-globals": "^0.2.2",
        "can-namespace": "1.0.0",
        "can-util": "^3.10.9"
      },
      "deprecated": false,
      "description": "Fast cloning micro templates",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-simple-dom": "^1.0.2",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^1.0.7",
        "jshint": "^2.9.1",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-target",
      "name": "can-view-target",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-target.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.1.4"
    },
    "signatures": [
      {
        "code": "target(nodes)",
        "description": "\n\nCreate a document fragment that can be cloned but have callbacks be\ncalled quickly on elements within the cloned fragment.\n\n```js\nvar viewTarget = require(\"can-view-target\");\n\nvar target = viewTarget([\n\t{\n\t\ttag: \"h1\",\n\t\tcallbacks: [function(data){\n\t\t\tthis.className = data.className\n\t\t}],\n\t\tchildren: [\n\t\t\t\"Hello \",\n\t\t\tfunction(data){\n\t\t\t\tthis.nodeValue = data.message\n\t\t\t}\n\t\t]\n\t},\n]);\n\n// target.clone -> <h1>|Hello||</h1>\n// target.paths -> path: [0], callbacks: [], children: {paths: [1], callbacks:[function(){}]}\n\nvar frag = target.hydrate({className: \"title\", message: \"World\"});\n\nfrag //-> <h1 class='title'>Hello World</h1>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "nodes",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "nodes",
      "description": "\n"
    }
  },
  "cloneNode": {
    "name": "cloneNode",
    "type": "function",
    "parent": "node_modules/can-view-target/can-view-target.js",
    "src": {
      "line": 77,
      "codeLine": 88,
      "path": "node_modules/can-view-target/can-view-target.js"
    },
    "body": "\n",
    "description": "\nA custom cloneNode function to be used in browsers that properly support cloning\nof custom tags (IE8 for example). Fixes it by doing some manual cloning that\nuses innerHTML instead, which has been shimmed.\n",
    "title": "",
    "hide": true,
    "params": [
      {
        "types": [
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "frag",
        "description": "A document fragment to clone"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "frag",
      "description": "A document fragment to clone"
    },
    "returns": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "a new fragment that is a clone of the provided argument\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "a new fragment that is a clone of the provided argument\n"
    }
  },
  "read": {
    "type": "function",
    "name": "read",
    "params": [
      {
        "types": [
          {
            "type": "can.stache.key"
          }
        ],
        "name": "attr",
        "description": "A dot seperated path.  Use `\".\"` if you have a property name that includes a dot."
      },
      {
        "types": [
          {
            "type": "can.view.Scope.readOptions"
          }
        ],
        "name": "options",
        "description": "that configure how this gets read."
      }
    ],
    "parent": "node_modules/can-view-scope/can-view-scope.js",
    "src": {
      "line": 91,
      "codeLine": 101,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "body": "",
    "description": "",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "can.view.Scope.readOptions"
        }
      ],
      "name": "options",
      "description": "that configure how this gets read."
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "parent",
              "description": "the value's immediate parent",
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            },
            {
              "name": "rootObserve",
              "description": "the first observable to read from.",
              "types": [
                {
                  "type": "can.Map"
                },
                {
                  "type": "can.compute"
                }
              ]
            },
            {
              "name": "reads",
              "description": "An array of properties that can be used to read from the rootObserve to get the value.",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "String"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "value",
              "description": "the found value\n ",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "parent",
              "description": "the value's immediate parent",
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            },
            {
              "name": "rootObserve",
              "description": "the first observable to read from.",
              "types": [
                {
                  "type": "can.Map"
                },
                {
                  "type": "can.compute"
                }
              ]
            },
            {
              "name": "reads",
              "description": "An array of properties that can be used to read from the rootObserve to get the value.",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "String"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "value",
              "description": "the found value\n ",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    }
  },
  "react-view-model/component.view-model": {
    "src": {
      "path": "node_modules/react-view-model/docs/component-view-model.md"
    },
    "body": "\n## Use\n\n```jsx\nimport React from 'react';\nimport { Component } from 'react-view-model';\nimport DefineMap from 'can-define/map/map';\n\nexport default class AppComponent extends Component {\n  render() {\n    return <div>{this.viewModel.name}</div>;\n  }\n}\n\nAppComponent.ViewModel = DefineMap.extend('AppVM', {\n  first: {\n    type: 'string',\n    value: 'Christopher'\n  },\n  last: {\n    type: 'string',\n    value: 'Baker'\n  },\n  name: {\n    get() {\n      return this.first + ' ' + this.last;\n    },\n  },\n});\n```\n\n",
    "description": "Provide a constructor function that provides values and methods to the component. The constructor function is initialized with the props, and updated as the props change. \n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A new instance of the ViewModel.\n\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The initial props that are passed to the component.\n"
          }
        ],
        "description": "A constructor function usually defined by [can-define/map/map.extend DefineMap.extend] or\n[can-map Map.extend] that will be used to create a new observable instance accessible by\nthe component.\n\n```javascript\nimport { Component } from 'react-view-model';\n\nexport default class AppComponent extends Component {\n  ...\n}\n\nAppComponent.ViewModel = DefineMap.extend({\n  ...\n});\n```\n"
      }
    ],
    "title": "ViewModel",
    "name": "react-view-model/component.view-model",
    "type": "property",
    "parent": "react-view-model/component.static",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The initial props that are passed to the component.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A new instance of the ViewModel.\n\n"
    },
    "comment": " "
  },
  "react-view-model/component.static": {
    "name": "react-view-model/component.static",
    "title": "static",
    "type": "group",
    "parent": "react-view-model/component",
    "description": "",
    "order": 0
  },
  "react-view-model/component": {
    "src": {
      "path": "node_modules/react-view-model/docs/component.md"
    },
    "body": "\n## Use\n\nAn example application using the ViewModel to create an extra prop, whose value is derived from other props.\n\n<div class='demo_wrapper' data-demo-src='demos/react-view-model/component.name.html'></div>\n\nAn example application which includes viewModel mutation and demonstrates auto-rendering.\n\n<div class='demo_wrapper' data-demo-src='demos/react-view-model/component.counter.html'></div>\n\nYou can also play with the above example on JS Bin:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/lunajov/1/embed?js,output\">react-view-model/component demo on jsbin.com</a>\n\nYou can also use this module with [Preact](https://preactjs.com):\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/fuxerik/2/embed?js,output\">react-view-model/component demo with Preact on jsbin.com</a>\n\nHere’s a recreation of the clock example from [React’s State and Lifecycle docs](https://facebook.github.io/react/docs/state-and-lifecycle.html):\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/zikaxuy/4/embed?js,output\">react-view-model/component clock demo on jsbin.com</a>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "Create an auto-rendering container component with an observable view-model. \n",
    "title": "react-view-model/component",
    "name": "react-view-model/component",
    "type": "function",
    "parent": "can-views",
    "collection": "can-ecosystem",
    "signatures": [
      {
        "code": "class App extends Component",
        "description": "\n\nCreate an auto-rendering [container component](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.v9i90qbq8) by connecting an observable [can-define/map/map] view-model to a React [presentational component](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.v9i90qbq8).\n\n```javascript\nimport { Component } from 'react-view-model';\n\nexport default class AppComponent extends Component {\n  ...\n}\n\nAppComponent.ViewModel = DefineMap.extend({\n  ...\n});\n```\n\nEvery instance of the component will generate an instance of the ViewModel, initialized with the props, and provide it as `this.viewModel`. Whenever the container component receives new props, the new values are passed to the viewModel’s `.set()` method, which may in turn cause an observable change event, which will re-run the observed render process.\n\n_Note: If you extend any of the [React lifecycle methods](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle), you must call `super` so as not to break the view-model binding. This includes: `componentWillReceiveProps`, `componentWillMount`, `componentDidMount`, `componentWillUpdate`, `componentDidUpdate`, and `componentWillUnmount`._\n\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "react-view-model": {
    "src": {
      "path": "node_modules/react-view-model/docs/react-view-model.md"
    },
    "body": "\n## Use\n\nAn example application using the ViewModel to create an extra prop, whose value is derived from other props.\n\n<div class='demo_wrapper' data-demo-src='demos/react-view-model/function.name.html'></div>\n\nAn example application which includes viewModel mutation and demonstrates auto-rendering.\n\n<div class='demo_wrapper' data-demo-src='demos/react-view-model/function.counter.html'></div>\n\nYou can also play with the above example on JS Bin:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/cudobut/2/embed?js,output\">react-view-model demo on jsbin.com</a>\n\nYou can also use this module with [Preact](https://preactjs.com):\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/muqeqec/5/embed?js,output\">react-view-model demo with Preact on jsbin.com</a>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "Create an auto-rendering container component with an observable view-model by providing a ViewModel and a React render function. \n",
    "title": "react-view-model",
    "name": "react-view-model",
    "parent": "can-views",
    "type": "function",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "pattern": "docs/**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/react-view-model/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-define": "^1.5.0",
        "can-namespace": "^1.0.0",
        "can-observation": "^3.0.1",
        "can-stache-key": "^0.1.0",
        "can-util": "^3.7.0"
      },
      "deprecated": false,
      "description": "Add Observable View-Models to React Components",
      "devDependencies": {
        "babel-eslint": "^8.0.1",
        "bit-docs": "0.0.7",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.3.0",
        "eslint": "^4.1.0",
        "eslint-plugin-react": "^7.1.0",
        "react": "^16.0.0",
        "react-dom": "^16.0.0",
        "steal": "^1.5.3",
        "steal-builtins": "^1.0.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.3.5",
        "testee": "0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs",
        "react",
        "viewmodel"
      ],
      "main": "react-view-model",
      "name": "react-view-model",
      "peerDependencies": {
        "react": "15.x - 16.x"
      },
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/react-view-model.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "eslint": "eslint \"**/*.js\" --ignore-pattern \"dist\" --ignore-pattern \"node_modules\"",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "prepublishOnly": "npm run build",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run detect-cycle && npm run eslint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "0.5.11"
    },
    "signatures": [
      {
        "code": "reactViewModel( [displayName], [ViewModel], renderFunction )",
        "description": "\n\nCreate an auto-rendering [container component](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.v9i90qbq8) by connecting an observable view-model to a React [presentational render function](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.v9i90qbq8).\n\nEvery instance of the component will generate an instance of the ViewModel, initialized with the props, and provide it to the render function. Whenever the container component receives new props or a value on the viewModel changes, it will trigger an update.\n\nIf `displayName` is omitted, it will default based on the `renderFunction`'s name, or \"ReactVMComponentWrapper.\" This is really only significant when debugging.\n\nIf `ViewModel` is omitted, it will default to [can-define/map/map]. This will still provide the benefits of auto-rendering, though you cannot add smart properties like you can with a custom `ViewModel`.\n\n```jsx\nexport default reactViewModel( 'AppComponent', ViewModel, (viewModel) => (<div>{viewModel.name}</div>) );\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "displayName",
            "description": "The name of the created [container component](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.v9i90qbq8) (optional)"
          },
          {
            "types": [
              {
                "type": "can-define/map/map"
              }
            ],
            "name": "ViewModel",
            "description": "A [can-define/map/map] constructor function (optional)"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "renderFunction",
            "description": "A React render function\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "ReactComponent"
            }
          ],
          "description": "An auto-rendering React Component\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "renderFunction",
      "description": "A React render function\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "ReactComponent"
        }
      ],
      "description": "An auto-rendering React Component\n"
    },
    "comment": " "
  },
  "roadmap": {
    "src": {
      "path": "docs/can-guides/commitment/Roadmap.md"
    },
    "body": "\n## How our roadmap is decided\n\nCanJS’s direction is shaped by its community creating [guides/contributing/feature-suggestion feature suggestions] and [guides/contributing/bug-report bug reports],\nand giving them a `+1`.\n\nThen, the [DoneJS core team members](https://donejs.com/About.html#team) prioritize\nissues with a `P0` to `P4` tag indicating their priority:\n\n- `P0` - An issue that will preempt any other issues currently being worked on.\n- `P1` - A critical feature or bug that needs to be fixed to keep CanJS’s high degree of quality.\n- `P2` - A feature or bug that is less likely to be encountered, but something we intend to get to.\n- `P3` - A nice to have. The OS team might get to it, but it’s helpful if the community assists.\n- `P4` - A nice to have that the OS team will accept, but will be unlikely to prioritize any effort towards.\n\n\n\n\n## Current Roadmap\n\nCanJS’s roadmap is constantly changing, so showing a schedule would be impossible.\nThe following links to CanJS’s feature issues grouped by priorities:\n\n - [P1 ](https://github.com/search?q=org%3Acanjs+label%3Aenhancement+label%3AP1&ref=searchresults&state=open&type=Issues)\n - [P2 ](https://github.com/search?q=org%3Acanjs+label%3Aenhancement+label%3AP2&ref=searchresults&state=open&type=Issues)\n - [P3 ](https://github.com/search?q=org%3Acanjs+label%3Aenhancement+label%3AP3&ref=searchresults&state=open&type=Issues)\n\n\n## How to influence the roadmap\n\n\nThese priorities can change.  The best ways to influence the priority of an issue is to:\n\n - Add test or implement the feature or fix\n - Come to a contributors meeting and let us know why it’s important to you\n - Make your case clearly and concisely in the issue\n - `+1` the issue to show your support\n\n",
    "description": "Learn about CanJS’s future plans, how we make them, and how you can influence them. \n",
    "name": "roadmap",
    "title": "Roadmap",
    "type": "page",
    "parent": "about",
    "order": 3,
    "comment": " "
  },
  "guides/api": {
    "src": {
      "path": "docs/can-guides/commitment/api-guide.md"
    },
    "body": "\n\n## Documentation Structure\n\nCanJS’s documentation is broken down by pages for:\n\n - library collections\n - packages and modules and their exports\n - functions, properties, and type definitions (typedefs) related to module exports\n\nFor example, [can-define/map/map.prototype.on can-define/map/map.prototype.on] is a\nmethod that listens to changes on an observable map as follows:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar map = new DefineMap({name: \"Justin\"});\n\nmap.on(\"name\", function(ev, newVal, oldValue){ ... })\n```\n\n`.on` is a function the `prototype` of the `DefineMap` export of the `can-define/map/map`\nmodule.  The `can-define/map/map` is part of CanJS’s [can-core] collection.\n\nSo understanding CanJS’s API pages are about understanding the relationships between:\n\n- library collections\n- packages and modules and their exports\n- functions, properties, and type definitions (typedefs) related to module exports\n\n... and what’s documented on those pages.  \n\n### Library Collection pages\n\nThe API docs are divided in 4 collection pages:\n\n- [can-core]\n- [can-ecosystem]\n- [can-infrastructure]\n- [can-legacy]\n\nEach collection page acts as an overview and cheat sheet for the modules and functionality\ncontained within the collection.\n\nThe [can-core] collection contains the documentation for the libraries that\nare use most commonly and directly within a CanJS application.  This is where the Model-View-ViewModel\nlibraries of CanJS are documented.\n\nThe [can-ecosystem] collection contains less commonly used libraries or libraries that aren’t quite core ready yet.  The most commonly used libraries here are [can-fixture], [can-stache-converters], and [can-jquery].\n\nThe [can-infrastructure] collection contains the utility libraries that power the core and ecosystem\ncollection.  Often, this functionality is used indirectly.  For example, the [can-event] mixin\nis used to add `on`, `off`, and `dispatch` methods to [can-define] and [can-compute].  And, [can-util] contains a wide variety of low-level DOM and JavaScript utilities.\n\nSometimes [can-infrastructure] is used directly.  The most important examples are:\n\n - [can-event/batch/batch] is used to batch changes for faster performance.\n - [can-util/dom/attr/attr] provides special [can-util/dom/attr/attr.special.focused] and [can-util/dom/attr/attr.special.values] attributes that [can-stache-bindings] can be bound to.\n - [can-util/dom/events/events] provides special [can-util/dom/events/attributes/attributes],\n   [can-util/dom/events/inserted/inserted], and [can-util/dom/events/removed/removed] events.\n - [can-view-callbacks] lets you register behavior for custom elements and attributes.\n\nFinally, the [can-legacy] collection.  This is for libraries that are no longer under active\ndevelopment.  Hopefully, you aren’t there very often.\n\n> Look to library collection pages for a high level cheat and explanation of every module within\n> the collection.  \n\n## Package and Module Pages\n\nA package or module documents the \"direct\" functionality of the export and provides an overview of\nall functionality contained within the module or package.\n\nFor example, [can-define/list/list] documents the \"direct\" functionality of the export, namely\nthe `DefineList` function that is exported.  While  [can-define/list/list.extend DefineList.extend] is the most common starting place when using `DefineList`, the `DefineList` export method can only be used like `new DefineList()` directly.  This is why `new DefineList()` is documented\non [can-define/list/list].  \n\nHowever, after the `new DefineList()` signature is detailed, [can-define/list/list] has a __#Use__\nsection that provides an overview of all functionality contained within the `can-define/list/list`\nmodule.\n\n> Look to Package and module pages for details of what is specifically exported and an overview\n> of what the module does, why it’s useful, and how to use it.\n\n## Functions, Properties, and Typedef pages\n\nWithin a module, there might be a variety of functions, properties and types a\nmodule might provide.\n\nThese values are generally organized by groupings.  The most common groupings are:\n\n - _prototype_ - A property or function is on the prototype of a parent function.\n - _static_ - A property or method is a direct value on the parent function or object.\n - _events_ - Events dispatched on the parent object or instances of the parent function.\n - _types_ - Type definitions.\n\nLet’s see a few examples and then give an overview of how their content is structured.\n\n#### prototype\n\n[can-define/list/list.prototype.concat can-define/list/list.prototype.concat] is in\nthe _prototype_ group on [can-define/list/list] because `concat` is on\nthe `can-define/list/list` export’s `prototype`:\n\n```js\nvar DefineList = require(\"can-define/list/list\");\nDefineList.prototype.concat //-> function\n```\n\nBecause of how JavaScript works, this means that you can call `.concat` directly on any instance\nof `DefineList`:\n\n```js\nvar hobbies = new DefineList([\"learning\"]);\nhobbies.concat([\"programming\"]);\n```\n\n#### static\n\n[can-define/map/map.extend] s in\nthe _static_ group on [can-define/map/map] because `extend` is a direct property on the `can-define/map/map` export:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nDefineMap.prototype.map //-> function\n```\n\n#### types\n\nSometimes a method might expect data passed to it in a certain format, or returns\ndata in another format.  These formats are often described separate from the\nmethod.\n\nFor example, the [can-fixture.store can-fixture.store] method returns an object\nof the [can-fixture/StoreType Store type].\n\n```js\nvar fixture = require(\"can-fixture\");\n\nvar todoStore = fixture.store([{id: 1, name: \"trash\"}]);\n\ntodoStore.createData  //-> function\ntodoStore.destroyData //-> function\ntodoStore.get         //-> function\n```\n\nAs you can see above, a `Store` can have lots of methods\nitself: `createData`, `destroyData`, etc.  So this type that isn’t directly\naccessible is documented under `can-fixture`’s _types_.  It’s also\nspecified as the return value of [can-fixture.store can-fixture.store].\n\n### Functions, Properties, and Typedef content\n\nEach function, property, and typedef page will have one or more signature’s describing\nwhat is being documented.\n\nSignatures are the __what__ and the __how__.  They should be precise on the\nbehavior of what is being documented.\n\nSome function, property, and typedef pages have __#Use__ sections that give\nmore information and examples on what is being documented.\n\n> Look to Functions, Properties, and Typedef pages to provide low-level details on\n> a specific piece of CanJS’s API.\n\n\n## How to find what you’re looking for ...\n\n1. Get a good understand of the purpose behind each module.  \n2. Start with core modules.\n3. Then checkout infrastructure modules.\n\nIf you don’t find what you want on the lowest level, walk up to the parent module, it\nmight be in its __#Use__ section.  \n\nIf not, let us know!\n\n",
    "description": "This page walks through how to use and understand CanJS’s API documentation.   \n",
    "name": "guides/api",
    "title": "Reading the Docs (API Guide)",
    "type": "page",
    "parent": "guides/getting-started",
    "order": 1,
    "comment": " "
  },
  "guides/setup": {
    "src": {
      "path": "docs/can-guides/experiment/setting-up-canjs.md"
    },
    "body": "\nYou can download CanJS from npm or a CDN. We recommend using npm. If you don’t already have Node.js and npm, [learn how to install both on npm’s website](https://docs.npmjs.com/getting-started/installing-node).\n\nOnce downloaded or installed, you can load CanJS in a variety of ways:\n\n - StealJS\n - Browserify\n - `<script>` tags\n\nThis guide shows how to setup common combinations.  If you don’t see yours, please\nask on the [forums](https://forums.donejs.com/c/canjs) or [Gitter chat](https://gitter.im/canjs/canjs).\n\n## JS Bin\n\nUse this JS Bin to play around with CanJS:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/safigic/7/embed?html,js,output\">CanJS on jsbin.com</a>\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\nIt uses `can.all.js` so you have the [can-core core], [can-ecosystem ecosystem], and [can-infrastructure infrastructure] modules available to you.\n\n## StealJS and npm\n\nInstall [can-core CanJS’s core modules] and StealJS with npm:\n\n```\nnpm install can-component can-compute can-connect can-define can-route can-route-pushstate can-set can-stache can-stache-bindings --save\nnpm install steal steal-stache --save\n```\n\nNext, add the following [configuration](https://stealjs.com/docs/StealJS.configuration.html) to your `package.json`:\n\n```\n{\n    ...\n    \"steal\": {\n    ...\n        \"plugins\": [\n            \"steal-stache\"\n        ]\n    }\n}\n```\n\nNext, create a `main.stache` template for your app:\n\n```\n<!-- main.stache -->\n<h1>{{message}}</h1>\n```\n\nNext, create a `main` module for your application. Import [can-define/map/map] and your template to say “Hello World”:\n\n```\n// main.js\nimport DefineMap from \"can-define/map/map\";\nimport template from \"./main.stache!\";\n\nvar data = new DefineMap({message: \"Hello World\"});\n\ndocument.body.appendChild(template(data));\n```\n\nFinally, create a page that loads `steal.js` and specifies `main` as the main module:\n\n```\n<html>\n  <body>\n    <script src=\"./node_modules/steal/steal.js\" data-main=\"main\"></script>\n  </body>\n</html>\n```\n\nStealJS supports “modlet” module names that end with `/`.  This means that the above could\nalso be written like:\n\n```\n// main.js\nimport DefineMap from \"can-define/map/\";\nimport template from \"./main.stache!\";\n\nvar data = new DefineMap({message: \"Hello World\"});\n\ndocument.body.appendChild(template(data));\n```\n<span line-highlight='2-2'></span>\nBesides ES6 modules, StealJS supports AMD and CommonJS.  You could also write `main.js` like:\n\n```\n// main.js\nvar DefineMap = require(\"can-define/map/map\");\nvar template = require(\"./main.stache!\");\n\nvar data = new DefineMap({message: \"Hello World\"});\n\ndocument.body.appendChild(template(data));\n```\n<span line-highlight='2-3'></span>\n__Note:__ if you see dozens of errors in your console, you may need to set `system.npmAlgorithm` to `flat` in your `package.json` (see the [Steal docs](https://stealjs.com/docs/StealJS.quick-start.html#section_Setup) for more info).\n\n### Building for production\n\nStealJS’s [Moving to Production](https://stealjs.com/docs/StealJS.moving-to-prod.html)\nguide has instructions for how to create a production build.\n\n## webpack and npm\n\nInstall [can-core CanJS’s core modules] and webpack (with `raw-loader`) with npm:\n\n```\nnpm install can-component can-compute can-connect can-define can-route can-route-pushstate can-set can-stache can-stache-bindings --save\nnpm install webpack raw-loader --save-dev\n```\n\nNext, create a `main.stache` template for your app:\n\n```\n<!-- main.stache -->\n<h1>{{message}}</h1>\n```\n\nNext, create a `main` module for your application. Import [can-define/map/map], [can-stache], and your template to say “Hello World”:\n\n```\n// main.js\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\nvar data = new DefineMap({message: \"Hello World\"});\nvar template = stache(require('raw-loader!./main.stache'));\n\ndocument.body.appendChild(template(data));\n```\n\nNext, run webpack from the command line:\n\n```\n./node_modules/webpack/bin/webpack.js main.js bundle.js\n```\n\nFinally, create a page that loads `bundle.js`:\n\n```\n<html>\n  <body>\n    <script src=\"./bundle.js\" type=\"text/javascript\"></script>\n  </body>\n</html>\n```\n\n## Browserify and npm\n\nCanJS works with Browserify. Install [can-core CanJS’s core modules] and Browserify (with `stringify`) with npm:\n\n```\nnpm install can-component can-compute can-connect can-define can-route can-route-pushstate can-set can-stache can-stache-bindings --save\nnpm install browserify stringify --save-dev\n```\n\nNext, create a `main.stache` template for your app:\n\n```\n<!-- main.stache -->\n<h1>{{message}}</h1>\n```\n\nNext, create a `main.js` file for your application. Import [can-define/map/map], [can-stache], and your template to say “Hello World”:\n\n```\n// main.js\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\nvar data = new DefineMap({message: \"Hello World\"});\nvar template = stache(require(\"./main.stache\"));\n\ndocument.body.appendChild(template(data));\n```\n\nNext, change your `package.json` to include the required `stringify` configuration:\n\n```\n{\n  ...\n  \"devDependencies\": {\n    \"browserify\": \"^13.1.1\",\n    \"stringify\": \"^5.1.0\"\n  },\n  \"stringify\": {\n    \"appliesTo\": { \"includeExtensions\": [\".stache\"] }\n  }\n}\n```\n<span line-highlight='7-9'></span>\nNext, run Browserify from the command line:\n\n```\n./node_modules/browserify/bin/cmd.js -t stringify main.js > bundle.js\n```\n\nFinally, create a page that loads `bundle.js`:\n\n```\n<html>\n  <body>\n    <script src=\"./bundle.js\" type=\"text/javascript\"></script>\n  </body>\n</html>\n```\n\n## RequireJS\n\nRequireJS is no longer supported. If you would like to [guides/contributing/code contribute] the code required for AMD, please look at [this issue](https://github.com/canjs/canjs/issues/2646).\n\n## Script tags\n\n### npm\n\nYou can install CanJS with npm:\n\n```\nnpm install can --save\n```\n\nThe `node_modules/can/dist/global/` directory will include two files:\n- `can.all.js`: includes the [can-core core], [can-ecosystem ecosystem], and [can-infrastructure infrastructure] modules\n- `can.js`: includes the [can-core core] and [can-infrastructure infrastructure] modules\n\nWith `can` installed, you can use it in an HTML page with a `<script>` tag:\n\n    <html>\n    <head>\n        <title>CanJS</title>\n    </head>\n    <body>\n        <script src=\"./node_modules/can/dist/global/can.all.js\"></script>\n        <script type='text/stache' id='app'>\n        \t<hello-world/>\n        </script>\n\n        <script type=\"text/javascript\">\n            can.Component.extend({\n\t            tag: 'hello-world',\n\t            view: can.stache(\"<h1>{{message}}</h1>\"),\n\t            ViewModel: can.DefineMap.extend({\n\t\t            message: {\n\t\t                type: 'string',\n\t\t                value: 'Hello world'\n\t                }\n\t            })\n            });\n            document.body.appendChild(\n\t            can.stache.from(\"app\")()\n            );\n        </script>\n    </body>\n    </html>\n<span line-highlight='6-6'></span>\n### CDN\n\nAnother quick way to start locally is by loading CanJS from a CDN:\n\n    <html>\n    <head>\n        <title>CanJS</title>\n    </head>\n    <body>\n        <script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n        <script type='text/stache' id='app'>\n        \t<hello-world/>\n        </script>\n\n        <script type=\"text/javascript\">\n            can.Component.extend({\n\t            tag: 'hello-world',\n\t            view: can.stache(\"<h1>{{message}}</h1>\"),\n\t            ViewModel: can.DefineMap.extend({\n\t\t            message: {\n\t\t                type: 'string',\n\t\t                value: 'Hello world'\n\t                }\n\t            })\n            });\n            document.body.appendChild(\n\t            can.stache.from(\"app\")()\n            );\n        </script>\n    </body>\n    </html>\n<span line-highlight='6-6'></span>\n## A note on Promises\n\nCanJS uses native [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), which means you might see the following error in Internet Explorer 9 or later:\n\n```\n'Promise' is undefined\n```\n\nYou must include a Promise polyfill if you’re targeting browsers that do not have [native support](https://caniuse.com/#feat=promises). If you’re using [StealJS](https://stealjs.com/), [a Promise polyfill](https://github.com/stefanpenner/es6-promise) is included for you.\n\n",
    "description": "Get started with CanJS by installing it with [npm](https://www.npmjs.com/), using a [JS&nbsp;Bin](https://jsbin.com/about), or just adding it to an HTML page with a `<script>` tag. \n",
    "name": "guides/setup",
    "title": "Setting up CanJS",
    "type": "page",
    "parent": "guides/getting-started",
    "order": 0,
    "outline": "2",
    "comment": " "
  },
  "guides/contributing/code": {
    "src": {
      "path": "docs/can-guides/contribute/changing-the-code.md"
    },
    "body": "\nNow that your computer is set up to [guides/contributing/developing-locally develop CanJS locally], you can make changes in your local repository.\n\nThe CanJS projects generally follow the [GitHub flow](https://help.github.com/articles/github-flow/). This section will briefly explain how you can make changes on your computer and submit a pull request to have those changes merged into the main project.\n\n## Creating a new branch\n\nStarting in the CanJS repository you have cloned to your computer, you can create a new branch:\n\n```shell\ngit checkout -b your-branch-name\n```\n\nReplace `your-branch-name` with the name of your feature branch, e.g. `git checkout -b html5-fix` to create a `html5-fix` branch.\n\n## Style guide\n\nWhere possible, our code generally follows [jQuery’s coding conventions](https://contribute.jquery.org/style-guide/js/).\n\nWhere possible, CanJS code uses:\n\n- Tabs not spaces\n- JSHint\n- CommonJS not ES6\n- jQuery’s [coding conventions](https://contribute.jquery.org/style-guide/js/)\n\n## Updating tests\n\nThe [`test` directory](https://github.com/canjs/canjs/tree/master/test) contains files related to testing the code in the repository. When fixing bugs or writing new features, you should update the existing tests or create new tests to cover your changes.\n\nAfter updating the tests, run `npm test` to make sure the tests pass.\n\n## Updating the documentation\n\nThe [`docs`](https://github.com/canjs/canjs/tree/master/docs) and [`guides`](https://github.com/canjs/canjs/tree/master/guides) directories contain the files used to generate [CanJS.com](https://canjs.com/).\n\n## Submitting a pull request\n\nOnce you’ve made your changes and run the tests, you can push your branch to GitHub:\n\n```shell\ngit push origin your-branch-name\n```\n\nMake sure you replace `your-branch-name` with the name of your branch. For example, `git push origin html5-fix`.\n\nNext, submit a pull request! On GitHub, navigate to Pull Requests and click the\n“New Pull Request” button. Give your PR a meaningful title and provide details\nabout the change in the description, including a link to the issue(s) your PR\naddresses. If applicable, please include a screenshot or gif to demonstrate your\nchange. This makes it easier for reviewers to verify that it works for them.\n[LICEcap](http://www.cockos.com/licecap/) is a great tool for making gifs.\n\nWhen finished, press “Send pull request”. The core team will be notified of your\nsubmission and will let you know of any problems or a targeted release date.\n\nGitHub has additional documentation on [creating a pull request from a fork](https://help.github.com/articles/creating-a-pull-request-from-a-fork/) that you might find useful.\n\nIf you enjoy making these kinds of fixes and want to directly influence CanJS’s direction,\nconsider joining our [Core team](https://donejs.com/About.html#core-team).\n\n",
    "description": "Learn how to contribute a code change to CanJS. Read the [guides/contributing/adding-ecosystem-modules] guide on how to make a plugin to CanJS.\n\n",
    "name": "guides/contributing/code",
    "title": "Changing the Code",
    "type": "page",
    "parent": "guides/contribute",
    "order": 5,
    "comment": " "
  },
  "guides/contributing/api-design-guidelines": {
    "src": {
      "path": "docs/can-guides/contribute/api-design-guidelines.md"
    },
    "body": "\n## Overview\n\nCanJS has many goals, one of which is providing a consistent interface and experience for developers using similar functionality or usage patterns across projects. Ideally, a developer should have a rough understanding of how to use something new based on what they have already used in CanJS.\n\nThis document is geared towards contributors who are designing new APIs for CanJS and developers of libraries meant to work alongside CanJS projects. Below are useful conventions for designing APIs, which have been adopted by CanJS projects or will be aligned with in future releases.\n\n## Conventions\n\n### Variable casing\n\nAll methods and properties should be camelCase. Class and constructor function names are exclusively PascalCase.\n\n### Methods are verbs, properties are nouns\n\nA developer should be able to tell by looking at an identifier whether it is a function that can be called or an object/property that has a value. In JavaScript, functions can be values so be careful to make the distinction between a *method* (verb) and a function being passed around as data (noun). For example, `handleEvent` is a method, but if that method were being passed around `eventHandler` is more appropriate.\n\nMethods which are only verbs such as `jump()` are discouraged when it is not clear what should be passed to it. A better name `jumpOverPerson()` provides a hint as to what the method expects.\n\n### Private methods and variables\n\nAny method or variable beginning with one or more underscores (`_`) is private to the project and should not be used externally. Ideally these cases are minimized.\n\nNote: there is a temporary convention for Symbols which is an exception to the above. **Documented** variables with two leading underscores, for example `__keys`, are safe to use as they are intentionally exposed for environments where symbols are not supported.\n\n### Private modules\n\nAny module file which is prefixed with one or more dashes (`-`) is private to the project and should not be used externally. Ideally these cases are minimized.\n\n### Creating new things\n\nIn CanJS, new \"things\" are created by either calling a constructor or class with the `new` keyword or calling functions which begin with `make`. For example, to create a Promise from an existing Promise-like object, `can-util` provides `makePromise`. Use of `make` is more explicit than, for example, `getPromise` because the underlying implementation is *creating a value*, not retrieving a value.\n\n### Registries\n\nThroughout CanJS we use a registry pattern. A registry, in abstract terms, is an object where *named* items are added, retrieved, and removed dynamically over the course of a program's life. For example, a component registry is where named components are added, retrieved, and removed. Registries can be implemented with the following interface:\n\n```js\ninterface Registry<RegistryKey, RegistryItem> {\n    add(identifier: RegistryKey, item: RegistryItem): function\n    has(identifier: RegistryKey): boolean\n    get(identifier: RegistryKey): RegistryItem | undefined\n}\n```\n\nNotice that there is no method to remove an item for a given identifier. Instead the `add()` method returns a function which will remove the added item. The reason we do this is to provide better system analysis and guarantees. Only one item should be associated with any identifier at any point in time. Suppose two independent programs were using the same registry and both added the \"foo\" item. There is a race condition there, where one would override the other which would lead to breakage or unexpected behavior. If we counter that by exposing a `remove()` method, someone may remove the existing item and then add their own. This is also a problem because the previous item will have no way of knowing to clean itself up. Thus for registries, we make the guarantees that addition to the registry is first come first serve, throwing if an attempt is made to add an item to existing identifier, and the only way to remove an added item is via the callback returned by the `add()`.\n\n",
    "description": "Learn how to design APIs which are consistent with CanJS. \n",
    "name": "guides/contributing/api-design-guidelines",
    "title": "API Design Guidelines",
    "type": "page",
    "parent": "guides/contribute",
    "order": 8,
    "comment": " "
  },
  "guides/contributing/developing-locally": {
    "src": {
      "path": "docs/can-guides/contribute/developing-locally.md"
    },
    "body": "\nThis page will walk you through setting up the [main CanJS repository](https://github.com/canjs/canjs) on your computer. Remember that CanJS is [guides/contributing/project-organization split into multiple repositories], but you can apply the same general steps to set up any of the other repos.\n\nWe’ll cover the following details in this guide:\n\n- Setting up your development environment.\n- Getting the repository’s code and verify it’s working.\n\nThe following video walks through most of the following steps:\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/PRuueWqnpIw\" frameborder=\"0\" allowfullscreen></iframe>\n\n## Setting up your development environment\n\nDeveloping CanJS requires:\n\n - A [GitHub](https://github.com/) account and git client.\n - Node.js version 5 or later.\n - Firefox for running automated tests.\n\n### Sign up for GitHub and set up Git\n\nIf you don’t already have a GitHub account, you’ll need to [create a new one](https://help.github.com/articles/signing-up-for-a-new-github-account/).\n\nThere are a variety of ways to get a git command line client\nconnected to your GitHub account. GitHub has\ngreat documentation on how to [set up Git](https://help.github.com/articles/set-up-git/).\n\nIf you already have `git` installed, make sure you’ve\n[set up your ssh keys](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/).\n\n### Install Node.js\n\nDownload Node.js version 5 or later at [NodeJS.org](https://nodejs.org).  You can\nverify Node’s version with:\n\n```\nnode -v\n```\n\n### Install Firefox\n\nFirefox is used to run the repository’s tests.\n\nIf you don’t already have it, [download Firefox](https://www.mozilla.org/en-US/firefox/new/).\nMozilla has guides for installing it on [Linux](https://support.mozilla.org/t5/Install-and-Update/Install-Firefox-on-Linux/ta-p/2516),\n[Mac](https://support.mozilla.org/t5/Install-and-Update/How-to-download-and-install-Firefox-on-Mac/ta-p/3453),\nand [Windows](https://support.mozilla.org/t5/Install-and-Update/How-to-download-and-install-Firefox-on-Windows/ta-p/2210).\nMake sure it gets installed into the default location for your operating system.\n\n## Getting the code and verifying that it’s working\n\nOnce your environment is set up, you should be able to clone the repository you\nwant to change, install its dependencies, and verify you’ve set up your\ndevelopment environment correctly.\n\n### Forking and cloning the repository\n\nA “fork” is a copy of a repository in your personal GitHub account. “Cloning” is the process of getting the repository’s source code on your computer.\n\nGitHub has a [forking guide](https://help.github.com/articles/fork-a-repo/) and a [cloning guide](https://help.github.com/articles/cloning-a-repository/) that explains how to clone a repo on Linux, Mac, or Windows.\n\nTo start, click the __Fork__ button to fork the repository from which you will be working.\nFor example, you can fork [can-compute] by pressing its __Fork__ button on GitHub:\n\n<img src=\"../../../docs/can-guides/contribute/fork.png\" width=\"600px\"/>\n\nNext, you’ll want to clone your forked version of the repository. GitHub’s guide will [instruct you](https://help.github.com/articles/fork-a-repo/#step-2-create-a-local-clone-of-your-fork) to clone it with a command like:\n\n```shell\ngit clone git@github.com:<your username>/<repository-name>.git\n```\n\nFor example, if your username is `justinbmeyer` and you forked `can-compute`:\n\n```shell\ngit clone git@github.com:justinbmeyer/can-compute.git\n```\n\nBefore continuing, move into your project’s directory. For example:\n\n```shell\ncd can-compute\n```\n\n### Installing the dependencies\n\nNow install the project’s dependencies with npm:\n\n```shell\nnpm install\n```\n\n### Running the tests\n\nMake sure Firefox is closed and run the test suite with:\n\n```shell\nnpm test\n```\n\n> NOTE: When adding tests, make sure you checkout [can-test-helpers](https://github.com/canjs/can-test-helpers) as it provides some useful helpers for some tests.\n\nIf every test passed, __congrats__! You have everything you need to\nchange code and have the core team review it.\n\n### Building the documentation\n\nThe [main CanJS repo](https://github.com/canjs/canjs) contains [CanJS.com](https://canjs.com/).\n\nTo build the site, run:\n\n```shell\nnpm run document\n```\n\nThis should produce a static site in your `canjs` folder.\n[`npm run`](https://docs.npmjs.com/cli/run-script) will look for the `document`\nscript in the repository’s [`package.json`](https://github.com/canjs/canjs/blob/master/package.json)\nand run it.\n\n### Viewing the site\n\nAfter you build the site, your `canjs` repository will now also contain the website.\n\nTo view the site, we recommend you install [http-server](https://www.npmjs.com/package/http-server).\n\n```shell\nnpm install http-server -g\n```\n\nAfter it’s installed, you can start a server in the current directory:\n\n```shell\nhttp-server\n```\n\n`http-server` will tell you where you can go in your browser to see the site. It will be something like [http://127.0.0.1:8080].\n\n## Making your changes\n\nNext, learn about [guides/contributing/code making changes and submitting a pull request].\n\n",
    "description": "Learn how to set up your development environment, get the code, and verify that it’s working. \n",
    "name": "guides/contributing/developing-locally",
    "title": "Developing Locally",
    "type": "page",
    "parent": "guides/contribute",
    "order": 4,
    "outline": "2",
    "comment": " "
  },
  "guides/contributing/evangelism": {
    "src": {
      "path": "docs/can-guides/contribute/evangelism.md"
    },
    "body": "\n## Overview\n\nHopefully you love CanJS as much as we do and you want to share your\nknowledge about it.  Fantastic!  We can help you.\n\nThere’s lots of ways to spread the word about CanJS such as:\n\n - Giving a presentation at a conference or meetup\n - Organizing or speaking at a CanJS or DoneJS meetup\n - Writing a blog article\n\nWhatever you do, please let us know so we can promote you and what you’re doing.\n\n## Speaking at a conference or meetup\n\nThe [Presentations Google Drive Folder](https://drive.google.com/drive/u/1/folders/0Bx-kNqf-wxZeaWc2ay1ZSzZZQXc)\ncontains all of the DoneJS teams talks organized by project.  It contains\na CanJS folder with CanJS presentations.  \n\nSome of the presentations are out dated, but it’s a good place to check for\nexisting content.\n\n## Organizing a CanJS meetup\n\nThere are several CanJS meetup groups already created:\n\n- [Boston](https://www.meetup.com/DoneJS-Boston/)\n- [Chicago](https://www.meetup.com/DoneJS-Chicago/)\n- [Ft. Lauderdale](https://www.meetup.com/DoneJS-Fort-Lauderdale/)\n- [Los Angeles](https://www.meetup.com/DoneJS-LA/)\n- [New York](https://www.meetup.com/DoneJS-NYC/)\n- [Phoenix](https://www.meetup.com/DoneJS-Phoenix/)\n- [Raleigh-Durham](https://www.meetup.com/DoneJS-raleigh-durham/)\n- [San Francisco](https://www.meetup.com/DoneJS-San-Francisco/)\n- [Seattle](https://www.meetup.com/DoneJS-Seattle/)\n- [Silicon Valley](https://www.meetup.com/DoneJS-Silicon-Valley/)\n\nWe’re always looking for people to speak at one of these meetups, become an organizer,\nor start their own meetup.  If you are interested in any of these things,\nplease let Justin Meyer know (`justin@bitovi.com`).\n\n## Writing a blog article\n\nIf you’re writing something about CanJS and would like us to review it,\nwe’re happy to help.  Once it’s published, let us know so we can promote it.  \n\n",
    "description": "Learn about resources that can help you spread the word about CanJS. \n",
    "name": "guides/contributing/evangelism",
    "title": "Evangelism",
    "type": "page",
    "parent": "guides/contribute",
    "order": 11,
    "comment": " "
  },
  "guides/contributing/documentation": {
    "src": {
      "path": "docs/can-guides/contribute/improving-the-docs-and-site.md"
    },
    "body": "\n## Overview\n\nThe CanJS site is generated with [bit-docs](https://github.com/bit-docs/bit-docs),\na modified version of [DocumentJS](https://documentjs.com).  Its\ncontent is hosted using GitHub pages publishing the [canjs/canjs#gh-pages](https://github.com/canjs/canjs/tree/gh-pages) repo.\n\n`bit-docs` reads JavaScript comments and markdown files within the `canjs` repo as well as\nthe individual repositories within `node_modules` to produce a static site.\n\nThe high level content (Ex: homepage) and the guides content for the site is within the\n`canjs/docs` folder.  Individual repositories contain their own markdown and commented\nJavaScript files used to produce their API pages.\n\n## Generate the documentation locally\n\nFirst, follow the steps listed under [guides/contributing/developing-locally] to\nfork & clone the repository, install the dependencies, build the documentation,\nand view the site locally.\n\n## Improve the theme’s design and styles\n\nThe CanJS theme is in\n[bit-docs-html-canjs](https://github.com/canjs/bit-docs-html-canjs). Its\n[README](https://github.com/canjs/bit-docs-html-canjs/blob/master/readme.md)\nhas instructions on how to test out the theme.  Once the theme is updated and published,\n\n1. Open `canjs/package.json`. Update `bit-docs-html-canjs`’s version to the new theme version.\n2. Run `npm run document:force` to make sure the theme is correctly applied.\n\nThe [CanJS design folder](https://drive.google.com/open?id=0B9uYesPecByGZGkzc2YxRHA4ZEE)\nhas logos, stickers, and other design resources.\n\n## Test out content from other repos\n\nAs noted above, the API docs from each package come from that package.  So if you’re\nimproving the docs for say `can-compute`, you want to see what `can-compute`’s docs look like,\ninstall your local `can-compute` and re-run bit-docs like:\n\n```shell\nnpm install ../can-compute && npm run document:force\n```\n\n\n## Publish the documentation\n\nOnce the docs look right locally, commit your changes, then run:\n\n```shell\nmake\n```\n\nThe make script will generate the documentation again and push out the `gh-pages` branch.\n\n\n## Writing API documentation\n\nOur documentation is modeled off of jQuery’s.  Please read\ntheir [guidelines](https://github.com/jquery/api.jquery.com/blob/master/README.md). Also read our\n[guides/api].\n\nGenerally speaking there are three parts to every documentation page:\n\n - Its description\n - Its signatures\n - The body (typically \"Use\" section)\n\n### Description\n\nThe description section should be a one or two sentence explanation of what this\npiece of documentation does from a _user_-centric view.  Descriptions are a quick summary\nof the __why__ and the __what__. It should take on an\nactive voice.  For example, [can-component]’s description:\n\n> Create a custom element that can be used to manage widgets or application logic.\n\nNotice that it uses \"Create\" not \"Creates\".\n\n### Signatures\n\nSignatures are the __what__ and the __how__.  They should include all or most of the following:\n\n - __What the signature does__, if different from the description, especially if there are\n   multiple signatures.\n - High level details on __how the code works__.\n - A simple example showing __how to use the code__.\n\n[can-compute]’s first signature is a good example of this. First, it explains\n__what that signature does__:\n\n> Create a compute that derives its value from other observables.\n\nThen it briefly explains __how the code works__:\n\n> Uses can-observation to call the getterSetter and track observables.\n\nFinally, it provides minimal sample code:\n\n```js\nvar age = compute(32);\n\nvar nameAndAge = compute(function(){\n    return \"Matthew - \" + age();\n});\n\nnameAndAge() // -> \"Matthew - 32\"\n\nage(33);\n\nnameAndAge() // -> \"Matthew - 33\"\n```\n\nNot all signatures need to hit all three points.  For example [can-event/batch/batch]’s\nsignature simply adds a bit more depth to the purpose of [can-event/batch/batch]\nand then details __how the code works__.  __How to use the code__ is\nleft for the `body` section as importing the module is not necessary to show.\n\n\n\nSignature titles should follow jQuery’s conventions:\n\n - Static methods like: `TypeAlias.method()`\n - Prototype methods like: `typeAlias.method()`\n - Spaces in between arguments: `typeAlias.method( arg1, arg2 )`\n - Brackets around optional args: `typeAlias.method( arg1 [, arg2 ], arg3 )` or\n   `typeAlias.method( arg1 [, arg2 ][, arg3 ] )`\n\nMake sure to fully document the a signature’s parameters and return\nvalue.  There’s a lot of flexibility in documenting the [type expression](https://documentjs.com/docs/documentjs.typeExpression.html) of\na return value or parameters and the [name expression](https://documentjs.com/docs/documentjs.nameExpression.html) of\nparameters.\n\n - Parameter and descriptions should start with a `Capital` and end with a period like:\n   `@param {Type} name Indicates that something should happen.`\n\n\n\n### Body\n\nMost body sections start with a `## Use` subsection.  This is a mini guide on\nhow to use that piece of code.  Modules should have long bodies that span\nmultiple topics.  For example [can-component]’s body has examples and\ninformation about nearly all of its sub-functions.  However\n[can-component.prototype.tag can-component.prototype.tag] doesn’t have a\nuse section because it’s covered in [can-component].\n\n\n### Structuring documentation\n\n- Group names (like `prototype`) should be lower case.\n- Types should be capitalized `{String}` except when they are describing a function [can-fixture.requestHandler].\n\n",
    "description": "Learn how to improve CanJS’s site and documentation. \n",
    "name": "guides/contributing/documentation",
    "title": "Improving the Docs & Site",
    "type": "page",
    "parent": "guides/contribute",
    "order": 6,
    "comment": " "
  },
  "guides/contributing/finding-ways-to-contribute": {
    "src": {
      "path": "docs/can-guides/contribute/finding-ways-to-contribute.md"
    },
    "body": "\n## Finding open issues\n\nCanJS uses [GitHub Issues](https://github.com/canjs/canjs/issues) to track improvements we want to make to the project, whether that’s bug fixes, new features, design improvements, etc.\n\nWe use a few labels to organize issues across all of the repositories:\n\n- [help wanted](https://github.com/search?q=org%3Acanjs+label%3A%22help+wanted%22&state=open) for any issues with which the core team would like help\n- [easy](https://github.com/search?q=org%3Acanjs+label%3Aeasy&state=open) for issues the core team thinks are good for someone who’s new to contributing\n- [documentation](https://github.com/search?q=org%3Acanjs+label%3Adocumentation&state=open) for issues related to documenting the APIs\n- [design](https://github.com/search?q=org%3Acanjs+label%3Adesign&state=open) for issues that could use a designer’s expertise\n- [p0](https://github.com/search?q=org%3Acanjs+label%3Ap0&state=open), [p1](https://github.com/search?q=org%3Acanjs+label%3Ap1&state=open), [p2](https://github.com/search?q=org%3Acanjs+label%3Ap2&state=open), [p3](https://github.com/search?q=org%3Acanjs+label%3Ap3&state=open), & [p4](https://github.com/search?q=org%3Acanjs+label%3Ap4&state=open) for prioritizing issues (see [guides/contributing/project-organization#Priority_Tags_andComplexity Priority, Tags, and Complexity] for more info)\n\nTriaging [issues that have no labels](https://github.com/search?q=org%3Acanjs+is%3Aissue+no%3Alabel&state=open) is also really helpful!\n\n## Getting involved in the community\n\nYou can also get involved in our community by posting in our forums, chatting with us on Gitter, and answering questions on Stack Overflow.\n\n- [Forums](https://forums.donejs.com/c/canjs)\n- [Gitter](https://gitter.im/canjs/canjs)\n- [Stack Overflow](http://stackoverflow.com/search?tab=newest&q=canjs+answers:0)\n\n## Spreading the word\n\nWe also always need help spreading the word about the CanJS projects. Check out [guides/contributing/evangelism] for info on how you can [guides/contributing/evangelism#Writingablogarticle write a blog post], [guides/contributing/evangelism#Speakingataconferenceormeetup speak at a conference], or [guides/contributing/evangelism#OrganizingaCanJSmeetup organize a meetup].\n\n",
    "description": "There are many ways to contribute to CanJS, whether you’re a developer who wants to code, a designer who can help improve the design and usability of our\nprojects, or someone who’s interested in helping other members of the community.\n\n",
    "name": "guides/contributing/finding-ways-to-contribute",
    "title": "Finding Ways to Contribute",
    "type": "page",
    "parent": "guides/contribute",
    "order": 3,
    "comment": " "
  },
  "guides/contributing/adding-ecosystem-modules": {
    "src": {
      "path": "docs/can-guides/contribute/making-a-new-package.md"
    },
    "body": "\nOn a high-level, to create a new package, you'll need to:\n\n1. Create a new project, with its own tests, build, releases, etc.\n2. Integrate that project's tests and documentation into `canjs/canjs`.\n\nAn __official__ package is:\n\n - In a repository under the [https://github.com/canjs CanJS organization].\n - Listed and documented under the [can-ecosystem Ecosystem Collection].\n - Tested in the [`canjs/canjs` integration suite](https://github.com/canjs/canjs/blob/master/test/test.js).\n - Published on npm as `can-<name>` (with a few exceptions).\n\n__Unofficial__ packages can be maintained however you choose, but to maximize your project’s:\n\n- Compatibility — useful in as many development environments as possible (Browserify, StealJS, Webpack, etc.)\n- Discoverability — other developers can find it\n- Contribute-ability — other developers can contribute to it\n\n…we suggest following the documentation on this page.\n\nWe’ve broken this down into the following sections:\n\n- [Create a new project](#Createanewproject)\n- [Set up Continuous Integration](#SetupContinuousIntegration)\n- [Write documentation](#Writedocumentation)\n- [Integrate build with CanJS](#IntegratebuildwithCanJS)\n- [Integrate tests with CanJS](#IntegratetestswithCanJS)\n- [Integrate documentation with CanJS](#IntegratedocumentationwithCanJS)\n\n## Create a new project\n\nFollow the [DoneJS plugin guide](https://donejs.com/plugin.html) with the following changes:\n\n__1.__ Pick a package name that has `can` in the name.  \n\n__2.__ When the `donejs add plugin` generator asks for “Project main folder”, use `.`\n\n__3.__ List `canjs` in your `package.json`’s `keywords`.\n\n__4.__ Update the code to match the [guides/contributing/project-organization#Fileorganizationandresponsibilities File organization and responsibilities] section.  There are a few changes to make:\n\n- Change everything to CommonJS.  Use `require('module-name')` instead of `import 'module-name'`.\n- Use _tabs_ instead of _spaces_.\n- Use dashes instead of underscores in generated filenames.\n\n## Set up Continuous Integration\n\n### Adding Greenkeeper\n\n### Adding Travis\n\nMake sure to activate CI on the source package by including a `.tavis.yml` file in the project root.  \n\n```yml\n# An example configuration\nlanguage: node_js\n# Load nodejs 6.x\nnode_js:\n  - \"6\"\n# Allow ability to run Firefox headless for Testee\nbefore_install:\n  - \"export DISPLAY=:99.0\"\n  - \"sh -e /etc/init.d/xvfb start\"\n```\n\n## Write documentation\n\nIn this guide, `project repo` refers to the repository that will be added to the CanJS.com site.\n\n### Source Repo Documentation\n\nCreate a markdown file in the `docs` folder of project repo and name it after the project.\n\n```bash\ncd can-fixture\nmkdir ./docs\ntouch ./docs/can-fixture.md\n```\n\n> Note: The location of the document files is discussed here as a common use case. Keep in mind that `bit-docs` does not expect documents in any folder. Only that documents use the correct [tag syntax](https://documentjs.com/docs/documentjs.tags.html).\n\n### Source Repo Documentation Tags\n\nIn order to include the source project's documentation on the CanJS site, the main document file requires some tags.\n\n```javadocs\n@module {*} <PACKAGE_NAME>\n@parent <CANJS_PARENT_TARGET>\n@package <PATH_TO_PACKAGE.JSON>\n```\n\n- `PACKAGE_NAME`: is the project name, which should match the `name` property in the source project's `package.json`.\n- `CANJS_PARENT_TARGET`: is the name of the target area in CanJS. For example, if the module is a part of the \"Ecosystem\", then the value for `@parent` would be `can-ecosystem`. If the target is \"Legacy\" then the value is `can-legacy`.\n- `PATH_TO_PACKAGE.JSON`: is a relative path from the main document file for the project repo. Considering the following structure...\n\n```\n- docs\n - can-fixture.md\n- src\n- package.json\n```\n\nIf `can-fixture.md` is the main document, then the relative path to the `package.json` is `../package.json`.\n\nThis would result in a main document file that looked [something like this](https://github.com/canjs/can-fixture/blob/40a4b03f0858a7a24182c12ef7b0ebe37c821e24/docs/can-fixture.md)\n\n```md\n@module {function} can-fixture\n@parent can-ecosystem\n@package ../package.json\n\n> Documentation goes here\n```\n\n## Integrate build with CanJS\n\nThe project repo needs to be added to the CanJS project.\n\n```bash\nnpm install <PACKAGE_NAME> --save\n```\n\nOnce the project is added as a dependency, the source project's main file needs to be included in the CanJS project.\n\nIn the root directory of the project, locate the appropriate JavaScript file.\n\n```md\n- /canjs\n - can.js\n - ecosystem.js\n - legacy.js\n```\n\nOpen the desired file and require the source project. For infrastructure and core packages, use the `can.js` file.\n\n```javascript\nrequire('<SOURCE_PACKAGE_NAME>');\n```\n\nFor example, in [CanJS](https://github.com/canjs/canjs/blob/e3301daad996df01463a623d50b38bd5091c9b35/ecosystem.js#L4), we have included the [can-fixture] project.\n\nRun `node build.js` to build CanJS.  You should be able to to use `dist/global/can.all.js`\nto show examples with your code.  \n\nIf you can't you might need to:\n\n- Add your pacakge's export to [can-namespace] like:\n\n  ```js\n  var namespace = require(\"can-namespace\");\n\n  var myCoolThing = {};\n  module.exports = can.myCoolThing = myCoolThing\n  ```\n\n- Make sure to exclude any 3rd-party projects from `canjs/build.js` like:\n\n  ```js\n  var ignoreModuleNamesStartingWith = [\n  \t\"jquery\",\n\t\"SOME_OTHER_LIBRARY\"\n  \t...\n  ]\n  ```\n\n  And train them to be loaded globally on the `window` like:\n\n  ```js\n  var exportsMap = {\n      \"jquery\": \"jQuery\",\n      \"SOME_OTHER_LIBRARY\": \"SomeOtherLibrary\"\n\t  ...\n  };\n  ```\n\n  And make sure your package's modules are able to run without\n  the library:\n\n  ```js\n  var namespace = require(\"can-namespace\");\n  var SomeOtherLibrary = require(\"SOME_OTHER_LIBRARY\");\n\n  var myCoolThing;\n  if(SomeOtherLibrary) {\n\t  myCoolThing = SomeOtherLibrary({});\n  }\n\n  module.exports = can.myCoolThing = myCoolThing\n  ```\n\n\n## Integrate tests with CanJS\n\nOpen the main test file in the CanJS repo, located at `canjs/test/test.js`.\n\n> Note: The tests in this file will run in dev mode and production mode. If your tests should only run in dev mode, add them to `canjs/test/test-dev-only.js`.\n\nRequire the project repo's test main test file in the appropriate area. For example, if the project repo will go in \"Legacy\" area of the site, then add it to the \"Legacy\" section of the test file.\n\nFor example, we have added the [can-fixture tests](https://github.com/canjs/canjs/blob/e3301daad996df01463a623d50b38bd5091c9b35/test/test.js#L56) to the test file.\n\nRun `npm run test` to run tests, verify the project does not adversely affect the test suite.\n\n## Integrate documentation with CanJS\n\nOpen the `can-api.md` doc file, located at `./docs/can-canjs/can-api.md`.\n\nAgain, add any necessary markup to the correct section (related to the target parent; legacy for legacy, etc).\n\nFollow this helpful markdown template:\n\n```md\n- **[<PACKAGE_NAME>]** <small><%<PACKAGE_NAME>.package.version%></small> <PACKAGE_DESCRIPTION>\n  - `npm install <PACKAGE_NAME> --save`\n  - <a class=\"github-button\" href=\"<PROJECT_GITHUB_URL>\">Star</a>\n```\n\n- `PACKAGE_NAME`: The project name, which should match the `name` property in the source project's `package.json`.\n- `PACKAGE_DESCRIPTION`: short description of project, can match the `description` property in source project's `package.json`.\n- `PROJECT_GITHUB_URL`: The Github url. Not the `git` path but the path to the html site.\n\nFor example, we have added the [markup for can-fixtures](https://github.com/canjs/canjs/blob/e3301daad996df01463a623d50b38bd5091c9b35/docs/can-canjs/canjs.md#the-can-package).\n\nRun `npm run document` to build the documentation site. Read more on the [guides/contributing/documentation] page.\n\n",
    "description": "Learn how to add a new package to the CanJS toolkit. \n",
    "name": "guides/contributing/adding-ecosystem-modules",
    "title": "Making a New Package",
    "type": "page",
    "parent": "guides/contribute",
    "order": 7,
    "outline": "0",
    "comment": " "
  },
  "guides/contributing/releases": {
    "src": {
      "path": "docs/can-guides/contribute/releasing-canjs.md"
    },
    "body": "\nFor maintainers of CanJS and its submodules this guide describes\n\n- How continuous integration is set up\n- How dependencies are kept up to date\n- How to make a releases of CanJS subprojects and the main package\n\n## Continuous Integration\n\n### Travis CI\n\nAll repositories automatically run their tests in [Travis CI](https://travis-ci.org/) using the `npm test` command (browser tests use Firefox as their target browser). If `npm test` is passing locally but not on Travis CI\n\n- Try setting the `DEBUG=testee*` environment variable in `travis-ci.org/canjs/<repository>/settings` to get more information.\n- Run the tests on an Ubuntu VM (e.g. [Ubuntu for Virtualbox](https://www.virtualbox.org/wiki/Linux_Downloads))\n\n### Saucelabs\n\n[canjs/canjs](https://github.com/canjs/canjs) also runs the tests of all dependencies in the supported browsers on [Saucelabs](https://saucelabs.com):\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/canjs.svg)](https://saucelabs.com/u/canjs)\n\nTo view Saucelabs test runs and results, request an invite from a Saucelabs user that has access to the `canjs` Saucelabs project (existing users can send invites under [my account](https://saucelabs.com/beta/users/canjs)). Saucelabs tests can be run locally via\n\n```\nnpm run ci\n```\n\n\n## Updating dependencies with Greenkeeper\n\nAll CanJS repositories are set up with [Greenkeeper](https://greenkeeper.io/). Greenkeeper tracks dependencies and creates a branch for every new version coming in. This will trigger Travis CI to run the tests and if a dependency update breaks the tests or a breaking (major) version was released, it will create a pull request.\n\nGreenkeeper is free for open source projects and works on the CanJS organization level. To add a new project or change the status of an existing project:\n\n- Install the command line via `npm install greenkeeper -g`\n- Run `greenkeeper login` to log in via GitHub\n- For more information run `greenkeeper` or `greenkeeper start`\n- To enable a project, in the project folder run `greenkeeper enable`\n\n\n## Making releases\n\nWith the exception of the `can` package, __ALL subprojects__ MUST follow the [Semantic Versioning](http://semver.org/) guidelines in the form of `MAJOR.MINOR.PATCH` for\n\n- `MAJOR` version when you make incompatible API changes,\n- `MINOR` version when you add functionality in a backwards-compatible manner, and\n- `PATCH` version when you make backwards-compatible bug fixes.\n\nBefore making any release please make sure that\n\n- You have write access to the GitHub repository you want to publish.\n- Have an [npm](https://www.npmjs.com) account and are logged in on the CLI tool (`npm whoami`).\n- Your user is a collaborator on npm. You can ask an existing collaborator to add you. Existing collaborators can be listed via `npm owner ls <packagename>` or on the npm module page (e.g. [can-route](https://www.npmjs.com/package/can-route)).\n\n\n### Releasing CanJS subprojects\n\nAll CanJS subprojects modules have the same structure which allows making releases through npm scripts.\n\nTo make a release:\n\n1. Move to the `master` branch\n2. Fetch all latest changes from the repository\n3. Reinstall all Node modules in their latest version\n\n   ```\n   git checkout master\n   git fetch --all && git rebase\n   npm cache clean\n   rm -rf node_modules\n   npm install\n   ```\n\n4. Then run `npm run release:<versiontype>`. For example, to make a `PATCH` release:\n\n   ```\n   npm run release:patch\n   ```\n\nThis will run the tests, build, bump the version number accordingly and publish the module to [npm](https://www.npmjs.com/).\n\n\n### Releasing the CanJS main project\n\nThe CanJS main project repository is at\n[canjs/canjs](https://github.com/canjs/canjs) and published as the `can` package. We\npublish a `can` module so there is a specified version of the library packages that are\n__integration tested__ to work together. A single `can` release can include multiple\nreleases of library packages.\n\nThe `can` package does __not__ follow strict [semantic versioning](http://semver.org/)\nguidelines. It still follows a `MAJOR.MINOR.PATCH` release names, but where:\n\n - `MAJOR` - Incompatible API changes in a library in the [can-core] or [can-infrastructure] collection.\n - `MINOR` - Either:\n    - New features added [can-core] and [can-infrastructure] but still backwards-compatible.\n    - New [can-ecosystem] or [can-legacy] library added or removed to their respective collection.\n - `PATCH` - Either:\n    - Bug fixes in [can-core] and [can-infrastructure].\n    - A new release of a [can-ecosystem] or [can-legacy] library.\n\nThe `can` package __does__ follow strict [semantic versioning](http://semver.org/) guidelines\nwith respect to the [can-core] and [can-infrastructure] collections. If a\nnew [can-ecosystem] or [can-legacy] package is added to `can`, it’s treated as a `MINOR` changes to `can`,\nany subsequent releases of those packages are treated as `PATCH` changes to `can`.\n\nWhen making a release, review the the version number changes and collection of all packages that have changed within the release.  Then run `npm run release:<versiontype>`.\n\nFor example, the following would be a `PATCH` release:\n\n```\ncan-core-a       3.0.1 -> 3.0.2\ncan-core-b       3.0.1 -> 3.0.10\ncan-ecosystem-a  1.0.0 -> 2.0.0\n```\n\nThe following would be a `MINOR` release:\n\n```\ncan-core-a       3.0.1 -> 3.0.2\ncan-core-b       3.0.1 -> 3.0.10\n// this means can-ecosystem-b was added to the ecosystem collection\n+ can-ecosystem-b 0.0.1  \n```\n\nThe following would be a `MINOR` release:\n\n```\ncan-core-a       3.0.1 -> 3.0.2\ncan-core-b       3.0.1 -> 3.1.0\ncan-ecosystem-a  1.0.0 -> 1.0.1\n```\n\nThe following would be a `MAJOR` release:\n\n```\ncan-core-a           3.0.1 -> 3.0.2\ncan-core-b           3.0.1 -> 3.1.0\ncan-infrastructure-a 3.0.1 -> 4.0.0\n```\n\n",
    "description": "Release and hosting information for CanJS maintainers. \n",
    "name": "guides/contributing/releases",
    "title": "Releasing CanJS",
    "type": "page",
    "parent": "guides/contribute",
    "order": 9,
    "outline": "2",
    "comment": " "
  },
  "guides/contributing/project-organization": {
    "src": {
      "path": "docs/can-guides/contribute/project-organization.md"
    },
    "body": "\nThe first thing to know about `CanJS` is that its code is split across dozens of different\nrepositories.  All but one of these are __library__ repositories like\n[canjs/can-event](https://github.com/canjs/can-event) and [canjs/can-define](https://github.com/canjs/can-define).  These all work the same way.\nThe [canjs/canjs](https://github.com/canjs/canjs) __framework__ repository works slightly\ndifferently.  The vast majority of code changes happen in one of the __library__\nrepositories.\n\nIf you don’t know which repository you need to work on, ask us in [Gitter chat](https://gitter.im/canjs/canjs).\n\n## File organization and responsibilities\n\nMost __library__ repositories share a similar structure.  Understanding it can help\nyou figure out what code needs to be changed.  The following outline shows the\ndirectory structure of a nonexistent `can-example` repository:\n\n```\n├── .editorconfig           — Configures editors for this project\n├── .gitignore              — Tells git to ignore certain files\n├── .jshintrc               — Configures JSHint\n├── .npmignore              — Tells npm publish to ignore certain files\n├── .travis.yml             — Travis CI configuration\n├── build.js                — Build script to export code in other formats\n├── can-example.js          — Main module code\n├── package.json            — Configuration of package and dev scripts\n├── readme.md               — Automatically generated readme\n├── docs/                   — Documentation source\n|   ├── can-example.md      — Package or module documentation\n├── node_modules/           — Node dependency installation folder\n├── test/                   — Test files\n|   ├── can-example-test.js — Main test file\n|   ├── test.html           — Main test page\n```\n\nGenerally speaking, the most important files are:\n\n - the main module —  `can-example.js`\n - the main test module — `test/can-example-test.js`\n - the test page — `test/test.html`\n\nTo fix a bug or make a new feature, add a test in the main test module, update code in the main module, and then verify the tests are passing by running\nthe test page.\n\nSome modules have multiple modules, test modules, and test pages.  These modules are\ncommonly organized as __modlets__ where each folder will have its own main module, test module,\nand test page:\n\n```\n├── a-module/            — Module’s modlet folder\n|   ├── a-module.js      — The module\n|   ├── a-module-test.js — The module’s tests\n|   ├── test.html        — A test page that runs just the module’s tests\n```\n\n## Priority, Tags, and Complexity\n\nThe [core team](https://donejs.com/About.html#team) reviews issues\nand assigns them a _p0_ to _p4_ label corresponding to the following priorities:\n\n- [p0](https://github.com/search?q=org%3Acanjs+label%3Ap0+is%3Aopen+sort%3Areactions-%2B1-desc) - An issue that will preempt any other issues currently being worked on.\n- [p1](https://github.com/search?q=org%3Acanjs+label%3Ap1+is%3Aopen+sort%3Areactions-%2B1-desc) - A critical feature or bug that needs to be fixed to keep CanJS’s high degree of quality.\n- [p2](https://github.com/search?q=org%3Acanjs+label%3Ap2+is%3Aopen+sort%3Areactions-%2B1-desc) - A feature or bug that is less likely to be encountered, but something we intend to get to.\n- [p3](https://github.com/search?q=org%3Acanjs+label%3Ap3+is%3Aopen+sort%3Areactions-%2B1-desc) - A nice to have. The OS team might get to it, but it’s helpful if the community assists.\n- [p4](https://github.com/search?q=org%3Acanjs+label%3Ap4+is%3Aopen+sort%3Areactions-%2B1-desc) - A nice to have that the OS team will accept, but will be unlikely to prioritize any effort towards.\n\nThere are several ways to influence these priorities:\n\n - Offer to pair with a contributor on a solution.\n - Write a good test.\n - Come to a DoneJS Contributors meeting and make your case.\n - Get others from other organizations to 👍 the issue.\n - Make your case on Gitter with a contributor or in the issue.\n - You can always hire [Bitovi](https://www.bitovi.com) or a contributor to make the change.\n\n",
    "description": "Learn about how CanJS is organized. \n",
    "name": "guides/contributing/project-organization",
    "title": "Project Organization",
    "type": "page",
    "parent": "guides/contribute",
    "order": 0,
    "comment": " "
  },
  "guides/contributing/feature-suggestion": {
    "src": {
      "path": "docs/can-guides/contribute/suggesting-features.md"
    },
    "body": "\nCanJS uses [GitHub Issues](https://github.com/canjs/canjs/issues/new) to track feature requests. However,\nCanJS is made up of many individual GitHub repositories. Ideally, features are created within the\nrepository whose code needs to be modified.  For example, features with\n[can-define] can be created at [canjs/can-define/issues/new](https://github.com/canjs/can-define/issues/new).\n\nIf you do not know which repository your feature belongs to, that’s totally ok!  Please\ncreate your issue in the main\n[canjs/canjs issues page](https://github.com/canjs/canjs/issues/new).  The core team will\nmove the issue to the correct repository if necessary.\n\nWhen creating an feature issue, it’s very helpful to include:\n\n - Examples of what using the feature will look like.\n - Benefits and drawbacks of the feature.\n - Why the feature is important.\n - Any implementation details around the feature.\n\nHere’s some example well-written feature requests:\n\n - [Make events fire asynchronously and dispatched during request animation frame or setImmediate](https://github.com/canjs/can-event/issues/11)\n - [Modify key -> argument behavior in stache](https://github.com/canjs/canjs/issues/1699)\n\nAlso, please search for previous feature requests.  If there’s something similar, add to that, or\ngive it a 👍.\n\nFinally, if there are any questions, reach out to\nus on the [CanJS forums](https://forums.donejs.com/c/canjs) or talk to us on\nthe [Gitter canjs/canjs channel](https://gitter.im/canjs/canjs).\n\n",
    "description": "Learn how to suggest a feature. \n",
    "name": "guides/contributing/feature-suggestion",
    "title": "Suggesting Features",
    "type": "page",
    "parent": "guides/contribute",
    "order": 2,
    "comment": " "
  },
  "guides/contributing/updating-the-site": {
    "src": {
      "path": "docs/can-guides/contribute/updating-the-site.md"
    },
    "body": "\ncanjs.com is hosted on [GitHub pages](https://pages.github.com/) from the [canjs/canjs#gh-pages](https://github.com/canjs/canjs/tree/gh-pages) branch. To generate and push a new version of the website, verify you have push access to that branch. Then get all latest changes via:\n\n```\ngit checkout master\ngit fetch --all && git rebase\nnpm cache clean\nrm -rf node_modules\n```\n\nWe also have to delete the local `gh-pages` branch:\n\n```\ngit branch -D gh-pages\n```\n\nThen run\n\n```\nmake\n```\n\nThis will generate and publish a new version of the website.\n\n",
    "description": "How to update the CanJS website. \n",
    "name": "guides/contributing/updating-the-site",
    "title": "Updating the Site",
    "type": "page",
    "parent": "guides/contribute",
    "order": 10,
    "outline": "2",
    "comment": " "
  },
  "guides/contributing/bug-report": {
    "src": {
      "path": "docs/can-guides/contribute/reporting-bugs.md"
    },
    "body": "\nCanJS uses [GitHub Issues](https://github.com/canjs/canjs/issues/new) to track bugs. However,\nCanJS is made up of many individual GitHub repositories. Ideally, bugs are created within the\nrepository whose code is causing the issue.  For example, issues with\n[can-define] can be created at [canjs/can-define/issues/new](https://github.com/canjs/can-define/issues/new).\n\nIf you do not know which repository your issue belongs to, that’s totally ok!  Please\ncreate your issue in the main\n[canjs/canjs issues page](https://github.com/canjs/canjs/issues/new).  The core team will\nmove the issue to the correct repository if necessary.\n\nWhen creating an issue, it’s very helpful to include:\n\n - Small examples using tools like JS&nbsp;Bin. You can clone the following [CanJS bin](https://jsbin.com/losoceranu/1/edit?html,js,output) that includes everything in CanJS. Make\n   sure it’s pointing at the same version of CanJS you are using.  \n - Breaking unit tests (optional). See [guides/contributing/code].\n - Proposed fix solutions (optional)\n\nAlso, please search for previous tickets.  If there’s something similar, add to that, or\ngive it a 👍.\n\nFinally, if there are any questions, reach out to\nus on the [CanJS forums](https://forums.donejs.com/c/canjs) or talk to us on\nthe [Gitter canjs/canjs channel](https://gitter.im/canjs/canjs).\n\n",
    "description": "Learn how to submit a bug report. \n",
    "name": "guides/contributing/bug-report",
    "title": "Reporting Bugs",
    "type": "page",
    "parent": "guides/contribute",
    "order": 1,
    "comment": " "
  },
  "guides/comparison": {
    "src": {
      "path": "docs/can-guides/introduction/comparison.md"
    },
    "body": "\n**CanJS** is a full **MVVM** library for creating fantastic web applications, but let’s face it, there are a lot of other frameworks that solve the same problem. These days, most of the **MV*** frameworks and libraries have some mechanism for creating **Custom Elements** for the browser and binding those elements to some sort of **observable state or data-store**, along with features like **routing** and connecting data to a **web service API**. The modern **MV*** frameworks are starting to look more and more similar, as concepts and features are shared between them, and the general needs of developers start to converge.\n\nYou should evaluate if a framework fits your mental model of how applications should be built, and to do that you’ll need to know the subtle but important differences that may not seem obvious at first glance.\n\nTwo of the most popular frameworks/libraries for building web applications are **[React](#React)** and **[Angular 2](#Angular2)**. So here are some comparisons you should consider when evaluating which framework to use to build your non-trivial application.\n\n## React\n\n**React** is really just the \"V in MVC\", while **CanJS** is a full **MVVM** library, so it may feel like we’re comparing apples to bananas, but there are certain tradeoffs that can be explored when comparing **CanJS** to **React**\n\nBecause **React** is only a view layer, there has been a deluge of competing libraries, each trying to establish itself as the de facto state management library for your **React** app. Some of the more popular libraries right now include **Redux**, **MobX**, **Alt**, **Reflux** and, of course, Facebook’s own **Flux** library (an implementation of their Flux architecture). Even frameworks like **Angular 2** and **CanJS** are joining in and making \"React friendly\" implementations.\n\nBut with all these choices and change, who is to say the state management library you pick for your **React** app will be around next year? The year after that? Things are moving so fast around the **React** ecosystem, it’s hard to see what it will look like in the coming years.\n\n**CanJS** has a historical track record providing a stable platform in a way **React** cannot, because **React** is too new and has a small focus, inviting an unstable ecosystem of tooling to form around it. Read more about our approach balancing stability and innovation [here](business-advantages.html).\n\nTo make a fair comparison, at times we will be referencing and comparing **CanJS** to **React-Redux**, arguably the most popular **Flux** implementation and state management library for **React** at this time\n\n### Observables\n\n**CanJS** has **observable** constructs that are powerful but still very easy to use.\n\n**React** has no real equivalent of observable state, and manages state changes through explicit calls to `render()` or `setState()`.\n\n**React-Redux** has a pattern for updating application state that is synchronous and uses pure functions, but it can be difficult to work with.\n\nThe synchronous data flow provided by the **Redux** store is generally insufficient for real web apps. The web is very async by nature, with it’s ajax calls, web-workers, web-sockets and all sorts of common APIs resolving asynchronously using events and callbacks. So you find yourself either writing a whole lot of code to manage your asynchronous action creation, or more likely you pull in asynchronous middleware like **redux-thunk**, **redux-promise** or **redux-rx**.\n\nSuddenly, the strict unidirectional data flow, is no longer that easy to follow, and you end up having to write a non-trivial amount of code to support the Redux pattern of dispatch -> action -> reducer -> state.\n\n```javascript\nconst ViewModel = DefineMap.extend({\n  subreddit: 'string',\n  posts: {\n    get(lastSetValue, resolve) {\n      this.postPromise\n        .then(response => resolve( response.json() ));\n    }\n  },\n  postsPromise() {\n    get() {\n      return fetch(`https://www.reddit.com/r/${this.subreddit}.json`)\n    }\n  }\n});\n```\n\nVS\n\n```javascript\nfunction requestPosts(subreddit) {\n  return {\n    type: REQUEST_POSTS,\n    subreddit\n  }\n}\n\nexport const RECEIVE_POSTS = 'RECEIVE_POSTS'\nfunction receivePosts(subreddit, json) {\n  return {\n    type: RECEIVE_POSTS,\n    subreddit,\n    posts: json.data.children.map(child => child.data),\n    receivedAt: Date.now()\n  }\n}\n\n// assumes thunkMiddleware is in use\nexport function fetchPosts(subreddit) {\n  return function (dispatch) {\n    dispatch(requestPosts(subreddit))\n    return fetch(`https://www.reddit.com/r/${subreddit}.json`)\n      .then(response => response.json())\n      .then(json =>\n        dispatch(receivePosts(subreddit, json))\n      );\n  }\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    posts: state.posts,\n    subredit: state.subredit\n  }\n}\n\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  return {\n    onTodoClick: (id) => {\n      this.props.dispatch(fetchPosts(ownProps.subreddit))\n    }\n  }\n}\n\nconst VisiblePostsList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(PostsList)\n\nexport default VisiblePostsList\n```\n\nThe functional aspects of **Redux** do have benefits to simplicity but there is obviously a trade-off, and you have to decide which way you prefer to attack simplifying the asynchronous and stateful demands of client side web UIs.\n\nUsing **MobX** observables with **React** is fairly popular, though not as popular as **Redux**, and could just as easily be compared to using **CanJS** observables with **React**, which is very possible and easy to do, because of **CanJS**’ modularity.\n\n### Data Fetching and Real-time Data\n\n**[Can-Connect](../../can-connect.html)** allows for **CanJS** **observables** to be connected to a data source such as an RESTful API or a real-time data stream, with advanced features like fall-through caching and batched minimal requests, so that your components can just request the data they need while can-connect figures out how to fetch that data in the most efficient way possible.\n\n**React**, being just a view layer, has no concept of this.\n\n**Relay**, a JavaScript framework for building data-driven **React** applications, has some very promising features, similar to can-connect, but requires you to implement a GraphQL server while **Can-Connect** can work with whatever data source or API you have.\n\nBeing tied directly to one particular type of back end service may end up with **Relay** being slightly easier to use, but **Can-Connect**’s flexibility, and it’s configurable integration points, will be valuable if you have different types of back-end services, like traditional REST APIs or you need to work with unique kinds of data stores.\n\n### One-Way Data Flow\n\nOne-Way data flow is touted as a benefit, that it simplifies the complexity of your UI state management. But if your problem is that state is changing unexpectedly or not changing when you think it should, maybe the solution is is to simplify your structure, not limit your tools.\n\nOne-Way data flow may be simpler to follow, but you end up writing a lot more code as a trade off. The reason 2-way binding became popular was that it removed a lot of boilerplate code: binding to a change, updating the state, updating any other dependants with the new state…etc.\n\n**CanJS** supports many types of data-bindings in our views, including one-directional, two-way binding, sibling-to-sibling value binding, and binding directly to DOM events. **CanJS** makes it easy to save writing a lot of code and keep your app simple to follow at the same time.\n\n```javascript\n// Binding to a Todo models completed property\nconst Todo = DefineMap.extend({\n  name: 'string',\n  completed: 'boolean'\n});\n\n// In stache\n{{#each todos}}\n<label><input type=\"checkbox\" checked:bind=\"completed\" />{{ name }}</label>\n{{/each}}\n```\n\n**React** has a dedication to the one-way data flow. This leads to a lot of boilerplate, hooking up event handlers just to change the state, over and over everywhere. **Flux** and **React-Redux** follow this same principle and ends up with even more code: `actions`, which get sent to a `dispatcher`, which pass the `action` to a `store`, to finally set the `state`. More code to write, more places for bugs to hide.\n\n```javascript\n// minimal reducer\nconst todo = ( state, action ) => {\n  switch (action.type) {\n    case 'TOGGLE_TODO':\n      return Object.assign({}, state, {\n        completed: !state.completed\n      });\n    default:\n      return state;\n  }\n}\n\n// minimal mapStateToProps and mapDispatchToProps functions for container\nconst mapStateToProps = ( state ) => {\n  return {\n    todos: state.todos\n  };\n};\nconst mapDispatchToProps = ( dispatch, ownProps ) => {\n  return {\n    onChange(id) {\n      dispatch({\n        type: 'TOGGLE_TODO',\n        id\n      });\n    }\n  };\n};\n\nconst TodoListContainer = connect( mapStateToProps, mapDispatchToProps )( TodoList ) );\n\n// in JSX\nTodo = (props) => {\n  checkboxProps = {\n    checked: props.completed,\n    name = props.name,\n    onChange(event) {\n      props.onChange(props.name)\n    }\n  }\n  return <label><input type=\"checkbox\" ...checkboxProps />{ props.name }}</label>\n}\n```\n\nIf the problem is losing track of what is changing the state, is the problem solved by adding more code, or is it better solved with a simpler abstraction and more succinct code?\n\n### DOM Libraries and Memory Leaks\nSometimes you are not starting a brand new project, and you’d rather incrementally add your new framework to your existing app, rather than do a whole re-write. Maybe you are using [Bootstrap](https://getbootstrap.com/javascript/), or [jQuery](https://jquery.com/) plugins, and you’d rather not re-implement everything you have at once.\n\n**CanJS** makes working with other libraries seamless. You can just use [can-stache](../../can-stache.html) to add [can-components](../../can-components.html) custom elements into your page as needed, and since **CanJS** works with real DOM events and attributes, everything just works as expected.\n\nIf you are using [jQuery](https://jquery.com/), [jQuery plugins](https://plugins.jquery.com/) or [Bootstrap](https://getbootstrap.com/javascript/), CanJS has a library, [can-jquery](../../can-jquery.html), which was specifically created for apps using CanJS with jQuery, and allows all jQuery events or DOM manipulations to “just work” without any special code needed.\n\n```handlebars\n<!-- A Bootstrap Modal -->\n<div id=\"my-modal\" class=\"modal fade\">\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-body\">\n\n        <script type=\"text/stache\" can-autorender>\n          <!-- A CanJS user-form component -->\n          <user-form />\n        </script>\n\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">Close</button>\n        <button type=\"button\" class=\"btn btn-primary save\">Save changes</button>\n      </div>\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal-dialog -->\n</div><!-- /.modal -->\n\n<button class=\"btn btn-primary newuser\">New User</button>\n\n<script>\n$('.newuser').on('click', ev => { $(\"#my-modal\").modal('show'); });\n\n$(\"#my-modal\").on('show.bs.modal', ev => {\n  let modal = $(ev.currentTarget);\n  modal.find('button.save').on('click', ev => {\n    modal.find(\"user-form\").trigger('submit');\n    modal.modal('hide');\n  });\n});\n</script>\n```\n\n**React** replaces certain core aspects of the DOM, namely the event system and attributes, with its own “React version” of events and props. Because of this, **React** can have some frustrating “gotchas” when you try and integrate it with jQuery plugins or any other library that queries or manipulates the DOM.\n\nUsing `ReactDOM.render()` to insert **React** components in to your app, may even cause a [memory leak](https://www.ibm.com/developerworks/web/library/wa-memleak/). To prevent memory leaks when using **ReactDOM** this way, you need to be aware of and use `ReactDOM.unmountComponentAtNode()` every time a **React** node get’s deleted. This is important and often forgotten. Forgetting to call `unmountComponentAtNode` will cause your app to leak memory, so you’ll have to hook up this call, into your current app lifecycle.\n\n```handlebars\n// DO NOT DO THIS, THIS CAUSES A MEMORY LEAK\n<div id=\"dialog-form\" title=\"Create new user\">\n  <div class=\"react-user-form-component\"></div>\n</div>\n<button id=\"create-user\">Create new user</button>\n\n<script>\n// This will leak memory\nReactDOM.render( $('.react-user-form-component').get(0), UserFormComponent );\ndialog = $( \"#dialog-form\" ).dialog({\n  autoOpen: false,\n  modal: true,\n  buttons: {\n    \"Create an account\": dialog.find( \"user-form\" ).submit(),\n    Cancel: () => {\n      dialog.dialog( \"close\" );\n    }\n  }\n});\n$( \"#create-user\" ).button().on( \"click\", function() {\n  dialog.dialog( \"open\" );\n});\n</script>\n```\n\nConversely **CanJS** is aware of its own DOM removal, and will clean up any event handlers or bindings *automatically*.\n\nIf you have existing legacy code, you’ll probably want integrate your new framework progressively, a piece at a time, and it’s important that things “just work”, without any surprises or frustrations.\n\n### Encapsulation of Components\n\nThere is a trend in JavaScript these days towards small reusable modules, tiny components, and little composable functions. But as with everything in programming there are tradeoffs, and if your modules are all too small, too isolated, the effort of wiring them together to become useful becomes greater than the benefit of reusability.\n\nEncapsulation is one way to simplify your applications. By encapsulating modules and only exposing an api for input and output, your app becomes easier to reason as you can think about it in larger chunks that have their input and output defined. Having well encapsulated modules or components means you don’t have to hold all the details of the implementation in your head, just the parts that matter at the level you are using that module.\n\n**React-Redux** has chosen to model their encapsulation in layers.\n\n* There is the **View** layer which holds all the **React** components, action creators and the dispatcher\n\n* There is the **Store** layer which holds all the reducers and redux middleware.\n\nThese layers have a simple and inverse API, the Store layer takes actions and returns state, the View layer takes in state and returns actions (as the user takes action on the UI).\n\n<img src=\"../../docs/can-guides/images/introduction/redux-flow.png\" style=\"width:100%;max-width:750px\"/>\n\n...and there are layers *within those layers*, like **action creators** and **redux-middleware**.\n\nThis architecture is nice and simple, with discrete lines of interaction and well-defined purpose and interface. The **tradeoff** however, is that to add a feature you need to add **_all_** the individual pieces to each of these layers.\n\nTo illustrate the idea with an example you wanted to to add a \"live video chat\" feature to your app. Let’s pretend you have already implemented this sort of thing in some other app, so you are just going to reuse the shared portions of it for this app.\n\nLet’s say the video chat feature assumes there is a users model that hold the URL to the video stream for each user. Features of the Video-Chat include:\n\n* Adding and removing users to your video chat\n\n* Muting the microphone\n\n* Turning the camera on and off\n\nSo in your **React-Redux** app, you would at minimum need to import:\n\n* A video chat component\n\n* 8 action creators\n\n* 9 reducers\n\n<img src=\"../../docs/can-guides/images/introduction/video-chat-react.png\" style=\"width:100%;max-width:750px\"/>\n\n...and wire them all together with code. The wiring up is not free, and though simple, may produce bugs and there is no guarantee the individual bits will work well together.\n\n**CanJS** has a more cross-cutting encapsulation strategy. A can-component knows what data it accepts through **attrs**, and can fetch its own data with models as dependencies, and also handles the user interaction, state-changes and display all within the component.\n\nThe individual parts of a component follow the MVVM pattern, and so are decoupled and easily testable themselves, but act as a cohesive unit of functionality for sharing and reuse across the app.\n\nCan-Components can then be used in parent can-component’s views, who can pass the child components attrs through the template bindings, and the whole app can be composed as a tree of components and HTML elements, each acting as little apps themselves.\n\n<img src=\"../../docs/can-guides/images/introduction/canjs-flow.png\" style=\"width:100%;max-width:750px\"/>\n\nTo continue with the **Video-Chat** example above, sharing a video-chat component from one **CanJS** app to another would be far more straightforward. You would only have to import the 1 video chat component, and the only wiring necessary would be to pass in a list of Users to the video-component attrs.\n\n<img src=\"../../docs/can-guides/images/introduction/video-chat-canjs.png\" style=\"width:100%;max-width:750px\"/>\n\nEncapsulated modules, like **can-components**, have many advantages over monolithic layers, like the layers provided by **react-redux**.\n\nThe encapsulated components are easier to test. In the **react-redux** example, to run some black-box functional tests, you would have to pull in all the individual pieces and assemble them like a mini version of the app. The can-component on the other hand could just be imported and placed on the page, and have the tests run, because it encompasses all the behaviour it needs in one uni\n\nUsing encapsulated components makes it easier to find and fix bugs. Working across layers means understanding the different parts and how they work together, if something is broken you’ll have to check in several spots to see where the problem is coming from. When you fix bugs in layered code, you end up having to touch the code in many places, as opposed to the encapsulated module where all the related code is in one place. And touching different places in code increases the chances of having some unintended effect on downstream code, making it more fragile.\n\nWhen you are working in a team, the layered approach can be more risky, as you’ll all be working in the same code a lot, since layer fixes and features will always span multiple layers, and you’ll have a lot more opportunity for overlap, or having a negative effect on another person’s feature, leading to merge conflicts and potential bugs.\n\n**CanJS** chooses a pattern of encapsulated models over a layered architecture because they are easier to share, easier to test, easier to find and fix bugs in and easier to work together  on as a team.\n\n### Summary\n\n**React** is not really a full solution for building apps with web technology, and the **React** ecosystem is still the wild west when it comes to state management and supporting technologies.\n\n**CanJS** simplifies your code with it’s observables and component architecture.\n\n**CanJS** let’s you integrate with your existing project easier and lets you be confident you won’t be re-writing your app in a new JavaScript framework next year.\n\n## Angular 2\n\n**Angular 2 (ng2)** is actually very similar to **CanJS**, if you look at these two \"Hello-World\" components, you see just how aligned the concepts behind **Angular 2** and **CanJS** really are.\n\n```js\nimport Component from 'can-component';\nimport stache from 'can-stache';\n\nexport default Component.extend({\n  tag: \"hello-world\",\n  template: stache(`<h1 on:click=\"emphasize()\">{{ message }}</h1>`),\n  viewModel: {\n    message: \"Hello world!\",\n    emphasize() {\n      this.message += '!';\n    }\n  }\n});\n```\n\n\nAND\n\n```javascript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'hello-world',\n  template: '<h1 (click)=\"emphasize()\">{{ message }}</h1>'\n})\nexport class HelloWorld {\n  message = 'Hello World!';\n  emphasize() {\n    this.message += '!';\n  }\n};\n```\n\nBecause it’s backed by Google, **Angular** is sometimes the \"go-to\" choice for teams developing web apps or web pages, but often it’s way more than what the project requires.\n\nThe steep learning curve, esoteric terminology, tricky syntax and concepts can end up slowing a team down far more than any benefit it provides. So it’s worth the effort to evaluate the framework and see if **Angular 2** is really what your team needs.\n\nThat being said, **Angular 2** also encompasses a lot more than just the **MV*** portion of the library: things like code generators, a dev-server, an SSR solution, and a system for script loading and dependency management. This makes **Angular 2** a lot more comparable to **CanJS**’s parent project [DoneJS](https://donejs.com/), but we can still evaluate the parts that *do* line up, to find the notable differences you need to make a proper comparison.\n\n### Longevity and Stability\n\nWhen evaluating **Angular 2** as an option, it is unwise not to consider the proverbial elephant in the room: \"Is this version going to stick around this time\"?\n\nGoogle and the Angular team released **Angular 2** as a complete re-write with no backwards compatibility, and no real plan for upgrading your application beyond running both Angular 1 and 2 on the same page until you can get all your directives and services migrated over to the new one. Google has a [history of abandoning projects](https://www.wordstream.com/articles/google-failures-google-flops), so you’ve got to ask: How long will it be until you’re rebuilding your app in the new, incompatible **ng3**?\n\nWith **CanJS** we have a guiding principle: You shouldn’t have to rewrite your application to keep pace with technology. We’re in it for the long haul, and dedicating to providing you stability and easy upgrades balanced with new features and progressive techniques in web development.\n\n### Modularity\n\nSometimes, you’re not building the next Gmail, you only have a few interactive forms on your site that could use some pizzaz. Sometimes, you already have a working app, and you want to move progressively into a new framework, not do a whole re-write of what is already working.\n\nThe key in these times, is to pick something you can use a piece at a time, as you need it, and pick the parts you need, without bringing in the kitchen sink. You’ll want modularity,\n\n**CanJS** is very modular. In **CanJS 3.0**, a lot of time was spent breaking out the useful parts of the system into modules and packages that can be used independently of each other but still work harmoniously together.\n\nFor example you could:\n\n* just use **can-compute** to quickly bind HTML inputs to observable values, giving you a nicer abstraction without a lot of event listeners and callback coordination\n\n* use **can-fixture** by itself to to mock out ajax and websocket requests for your tests\n\n* use only **can-connect** and **can-define** to create awesome observable models that are connected in realtime to your existing API\n\n* use just **can-route** to take advantage of state-based observable routes, for the easy url updating and decoupling the pattern provides\n\nAny individual or combination of modules will provide you a great tools for streamlining your web development, and together they become our own little \"Megazord” **CanJS**, greater than the sum of it’s parts\n\n**Angular 2** is more of an \"everything out of the box\" framework, where you get everything up front, and it all works together to help you develop more efficiently. The pieces and modules of Angular’s libraries are not really meant to be used on their own, and it would be hard to just extract the tiny bits you need without buying into the whole Angular framework.\n\nThere’s a [funny story](https://news.ycombinator.com/item?id=12692595) on Hacker News about JavaScript Expert whose performance improvements involved removing almost all the JavaScript on the site. The point is, you should know what you need, and include only the tools needed to get the job done, everything else is bloat.\n\n### Typescript\n\n**TypeScript** is a typed superset of JavaScript that compiles to plain JavaScript that offers optional static typing and type inference. But if you are not already using TypeScript, should your choice of framework decide that for you? Do you even want it?\n\n**CanJS** was created before ES6 and transpiling were prevalent in front-end JavaScript, so you don’t need TypeScript, though of course it would still would work with TypeScript if that was your preference.\n\nThough the **Angular 2** people have been assuring the general masses that \"you don’t **need** typescript to write **Angular 2** apps\", the fact is the framework was designed around embracing the syntactic allowances, like decorators and class fields, and if the framework to be presented without them it would look clunky and pretty verbose.\n\n```javascript\nconst HelloWorldComponent = ng.core.Component({\n  selector: 'hello-world',\n  template: '<h1>Hello {{name}}!</h1>' + '<input [(ngModel)]=\"name\">',\n  viewProviders: [GreetingService]\n}).Class({\n  constructor: [GreetingService, function(greetingService) {\n    this.greetingService = greetingService;\n    this.name = \"world\";\n  }\n});\n\nvar AppComponent = ng.core.Component({\n  selector: 'app',\n  template: '<hello-world></hello-world>',\n  directives: [HelloWorldComponent]\n}).Class({\n  constructor: function() {}\n});\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  ng.platform.browser.bootstrap(AppComponent);\n});\n```\n\nTypeScript may offer all sort of benefits, especially for large apps with multiple teams working on them, but it’s more unnecessary baggage if you weren’t using typescript already.\n\n### Dependency Injection\n\nDependency Injection (**DI**) *as a pattern* can provide decoupling from your dependencies, and allow a flexibility of configuration for your modules, but **DI** *as a framework* adds additional verbosity and configuration all over your application. In JavaScript, a **DI framework** is useful in only rare cases, due to the flexibility of the language so, in the end, is it really worth it to have all the extra code and complexity?\n\n**CanJS** chooses not to include a Dependency Injection framework, opting instead for the developer to decide if they need any more DI than JavaScript can already provide. JavaScript’s prototypal inheritance and mutable runtime instances can serve 90% of the uses for Dependency Injection, and if the developer decided they need a DI library they are free to add their own.\n\n**Angular 2** has doubled down on Dependency Injection, making every part of it’s design incorporate providers, services, and an injection syntax. This creates an odd pattern in **Angular 2** where not only do you have to import a component or service and use it, you also have to declare the provider for it, often just passing the class as a shorthand.\n\nNote in the example below `FriendService` is imported, used *and also* needs to be declared in the `providers` metadata:\n\n```javascript\nimport { Component } from '@angular/core';\nimport { FriendService } from 'app/friend.service';\n\n@Component({\n    selector: 'my-friends',\n    providers : [FriendService],\n    template: `\n        <div *ngFor=\"#f of friends\">\n          <h4> Name : {{f.name}} </h4> <h4>Age: {{f.age}}</h4>\n        </div>\n    `\n})\nexport class FriendComponent {\n    constructor(_friendService: FriendService) {\n        this.friends = _friendService.getFriends();\n    }\n}\n```\n\nA Dependency Injection system may have a place in other languages, like Java, but JavaScript can handle the pattern easily already. The DI System just ends up being extra syntax, and a there is a confusing loss of clarity when the classes and types imported into the class definition may not actually be the classes used to produce the dependency instance.\n\n*See the above code example, and realize that `FriendService`, may in some instances not actually be used in the `FriendComponent`, if some parent module defines a different provider for `FriendComponent`*\n\n### Steep Learning curve\nAngular is known for it’s steep learning curve, and Angular 2 doesn’t really break that reputation.\n\nThere are a whole lot of new things a developer must learn to become effective with\nAngular 2. You have to learn the TypeScript syntax, all the examples are written\nin it so you’re going to have trouble if you skip this step. The Dependency Injection\nsystem is so ingrained, you must learn early how it works, and the syntax involved\njust to get going. There is the templating system, the decorators/annotations, a\n[wealth of APIs and modules](https://angular.io/docs/js/latest/api/), and the kicker\nof it all is, because of the “all-or-nothing” nature of Angular 2, you have to learn a\nwhole lot of it, just to get started.\n\nCanJS also has many different modules and APIs to learn, but because of CanJS’s modular and individually packaged libraries, you only have to learn what you need, when you need it. There is no new \"transpile-to-js\" language to learn and no Dependency Injection framework to understand before you can start creating your components and composing your apps.\n\nIf your team needs to get started quickly, and hit the ground running, Angular 2 may not be the best choice, but CanJS just might be the right fit for your team.\n\n### Data Fetching and Real-time Data\n\n**[Can-Connect](../../can-connect.html)** allows for **CanJS** **observables** to be connected to a data source such as an RESTful API or a real-time data stream, with advanced features like fall-through caching and batched minimal requests, so that your components can just request the data they need while can-connect figures out how to fetch that data in the most efficient way possible.\n\n**Angular 2**’s HTTP Service doesn’t have the advanced features like minimal requests and fall-through caches, and any real-time data-source would require you to write a custom service.\n\n### Summary\n\n**Angular 2** is not the safe bet you may be hoping it is. Google wouldn’t hesitate to drop it entirely when it no longer serves their purpose, it’s got a steep learning curve, and lot of features that you may not want or need.\n\n**CanJS** has a mission to be the stable platform for you to develop your web apps on for years to come. It’s modular enough to take only the parts you need as you need them. It has all the features you need and doesn’t force you into patterns or technologies you don’t.\n\n## Non-technical comparison\n\nIf none of the technical arguments convince you to give CanJS a try, consider this: all the modern frameworks have more or less converged in 2016. You can build a very similar application, with routing, observables, models, and server side rendering (with some exceptions) with Angular 2, several of the React frameworks, Ember, or CanJS. Therefore, the MOST important factor, even beyond small technical differences, is the stability and stability of the framework. You want to bet on a horse that you can ride into the future, not the horse that looks prettiest today.\n\nCanJS’s mission is to __minimize the cost of building and maintaining\nJavaScript applications by balancing innovation and stability, helping developers transcend a changing technology landscape__. We’ve spent the past 9 years focused on balancing these two oppoising goals, and have the track record to prove it. Read in more detail on our [mission page](mission.html).\n\nThere’s no advantage to choosing projects maintained by a big company, since big companies often kill platforms that many developers have invested in.\n\n<img src=\"../../docs/can-guides/images/introduction/framework-death.png\" style=\"width:100%;max-width:650px\"/>\n\nThere’s no advantage to choosing a framework with a large community, since communities are fickle and change yearly.\n\nThere’s no advantage to choosing a framework based on ability to hire devs that list X on their resume, since any competent JavaScript developer can be equally effective in any modern framework with a couple days of learning.\n\nThis is why CanJS has a stellar reputation with [enterprise companies](who-uses.html). Stability and longevity are critical factors to your application’s success.\n\n",
    "description": "\n",
    "name": "guides/comparison",
    "title": "Comparison to Other Frameworks",
    "type": "page",
    "parent": "guides/introduction",
    "order": 5,
    "hide": true,
    "comment": " "
  },
  "guides/mission": {
    "src": {
      "path": "docs/can-guides/introduction/mission.md"
    },
    "body": "\nCanJS’s mission is to __minimize the cost of building and maintaining\nJavaScript applications by balancing innovation and stability, helping developers transcend a changing technology landscape__.\n\nYou shouldn’t have to rewrite your application to keep pace with technology.\nWe constantly integrate new ideas and evolving best practices into CanJS libraries,\nbut in a responsible way that makes it possible to\nupgrade gracefully. We aim to provide a stable\nand innovative platform, so you can block out noise and stay focused your app, not the tools.\n\n<img\n    srcset=\"../../docs/images/home/Home-Tortoise-color.png 1x, ../../docs/images/home/Home-Tortoise-color-x2.png 2x\"\n    src=\"../../docs/images/home/Home-Tortoise-color.png\"\n    style=\"float:right; padding-right: 40px;\"/>\n<img\n    srcset=\"../../docs/images/home/Home-Hare-color.png 1x, ../../docs/images/home/Home-Hare-color-x2.png 2x\"\n    src=\"../../docs/images/home/Home-Tortoise-color.png\" style=\"padding-left: 40px;\"/>\n\n[//]: # (ANIMATION: Smooth ride, looking out the window, while hurricane of JavaScript logos and terminology passes by outside the window. Vehicle has an arrow pointing forward towards progress.)\n\nKeep reading to learn why our mission is important\nand how we’ve fared in realizing it:\n\n- [Stability and innovation matter](#Stabilityandinnovationmatter) — Why stability and innovation are the two most important factors in minimizing the cost of building and maintaining JavaScript applications.\n- [Stability is difficult in the JavaScript community](#StabilityisdifficultintheJavaScriptcommunity) — Why the JavaScript community sees a never-ending stream of frameworks and suffers from _JavaScript Framework Fatigue_.\n- [Our history of stability and innovation](#Ourhistoryofstabilityandinnovation) — How we’ve managed to\n keep innovating for 10 years (while still providing a viable upgrade path) and what we’re doing now to make CanJS even more stable moving forward.\n\n## Stability and innovation matter\n\nStability and innovation are often conflicting goals, but they are both critical\nfactors to application success.  Application development lifecycles\ncan last years, so it’s important that code written today will be relevant\ntomorrow. Yet technology changes quickly, especially in JavaScript.\nNew technology brings better techniques and is critical for developer happiness\nand retention.\n\nWhen starting a new application, it’s easy to forget that the majority of development happens after\nthe application is released. Many frameworks, after a short period of popularity, either:\n\n - End up getting replaced by a _hot new_ framework.\n - Release a major version that not even _remotely_ backwards-compatible with the previous version.\n\nProductivity-wise, over the life of your application, that ends up looking like this:\n\n<img src=\"../../docs/can-guides/images/introduction/betting-bomb-2.png\" style=\"width:100%;max-width:650px\"/>\n\nOr like this:\n\n<img src=\"../../docs/can-guides/images/introduction/betting-bomb.png\" style=\"width:100%;max-width:650px\"/>\n\n\nWhat is needed is a balance of innovation and stability, where developer productivity\nincreases over time, but doesn’t take large steps backward.  That looks something like this:\n\n<img src=\"../../docs/can-guides/images/introduction/good-bet.png\" style=\"width:100%;max-width:650px\"/>\n\nThis is our mission.\n\n## Stability is difficult in the JavaScript community\n\nYou may be familiar with the\n[never-ending stream](https://medium.freecodecamp.com/javascript-fatigue-fatigue-66ffb619f6ce#.n5tt0jqhf) of [hot new JavaScript frameworks](https://www.allenpike.com/2015/javascript-framework-fatigue/)\nthat take our community by storm every one or two years.\n\n> SproutCore -> Knockout -> Backbone -> Angular -> React -> ?\n\nThis isn’t surprising.  Consider how many different programming languages you can use\non the server-side: Java, Ruby, Python, C#, Haskell, etc.  There is only one JavaScript. Innovation\nis going to move at a blistering pace.  We should embrace it.\n\nBut, the blistering pace of innovation also means that most frameworks will emerge with one\nrevolutionary feature and then fade as the\nnext revolutionary framework emerges.  Instead of the old framework adopting new ideas, the community and its attention move onto the next _hot_ framework.\n\nThis makes it difficult to avoid stagnation in any community-driven tool over a long period of time.\n\n## Our history of stability and innovation\n\nCanJS has been helping developers transcend the [constantly changing technology landscape](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.lrntx9nby)\nfor over 10 years.  Read on to learn about:\n\n - Our history of stability.\n - Our history of innovation.\n - How 3.0 improves stability and innovation.\n\n### Our history of stability\n\nCanJS has been around since 2007. CanJS was originally called [JavaScriptMVC](http://javascriptmvc.com).  In 2012, JavaScriptMVC was split up into several pieces, including CanJS. Every year, we have improved CanJS by incorporating new best practices and ideas from the larger JavaScript community, while not leaving behind our existing users. The result has been a viable upgrade path for over 10 years!\n\n<img src=\"../../docs/can-guides/images/introduction/best-bet.png\" style=\"width:100%;max-width:650px\"/>\n\nMajor releases are not fully backwards-compatible, but it was possible to transition with\nlimited effort.\n\nLet’s see how one piece of CanJS, [can-control], evolved over this time.\n\n__In 2007__, using JavaScriptMVC 1.0, to listen to when any element\nthat matches the selector `.todos li.complete` is clicked, you might have written something like the following:\n\n```js\nnew MVC.Controller('todos',{\n    \"li.complete click\": function(el, ev){\n        // DO STUFF\n    }\n});\n```\n\nJavaScriptMVC was one of the first libraries to support event delegation,\nbut these old controls weren’t extensible and couldn’t work in an isolated\ncontext.\n\n__In 2009__, [jQuery](https://jquery.com) began to dominate JavaScript development.\nWe helped add event delegation to jQuery and integrated it into JavaScriptMVC 2.0.\nThe previous code became:\n\n```js\n$.Controller.extend(\"TodosController\",{\n    \"li.complete click\": function(el, ev){\n        // DO STUFF\n    }\n});\n\n$(\".todos\").todos_controller();\n```\n<span line-highlight='1,7'></span>\n__In 2012__, using CanJS 1.0, this became:\n\n```js\nTodosController = can.Control.extend({\n    \"li.complete click\": function(el, ev){\n        // DO STUFF\n    }\n});\n\nnew TodosController(\".todos\");\n```\n<span line-highlight='1,7'></span>\n__In 2013__, we released CanJS 2.0, and transitioned to\n[can-component]s instead of [can-control]s.  But even now, almost 10 years later,\nto make that `MVC.Controller` work in CanJS 3.0,\nyou could update it to the following:\n\n```js\nvar Control = require(\"can-control\");\n\nvar TodosController = Control.extend({\n    \"li.complete click\": function(el, ev){\n        // DO STUFF\n    }\n});\n\nnew TodosController(document.querySelector(\".todos\"));\n```\n<span line-highlight='1,3,9'></span>\nThis is one of many examples of CanJS’s code undergoing significant\nimprovements and changes, while still keeping it possible to upgrade your application.\n\nFor teams upgrading to `3.0`, we created multiple [migrate-3 migration paths]\nso upgrading can be done incrementally.  \n\n\n### Our history of innovation\n\nOver the past 9 years of CanJS, the web has evolved, and the best practices in JavaScript application development have changed. As these changes have occurred, CanJS has filtered out the very best ideas and practices, and implemented them in evolving APIs.\n\nTo name a few:\n- Event delegation became a best practice for managing events around 2009. CanJS added support for event delegation in 2008, before jQuery landed support.  Later, when jQuery became ubiquitous, we\n integrated jQuery into CanJS.\n- RESTful APIs eventually became the best practice for designing a backend interface. [can-model](//v2.canjs.com/docs/can.Model.html) in 2010 provided ActiveRecord style abstractions around this pattern.\n- Data bindings hit the mainstream in 2013 when Angular rose in popularity. CanJS landed support for this feature in 2011 with [can-ejs].\n- Building UI widgets as HTML custom elements, similar to web components, has become a best practice. [can-component] landed in 2013 to support this architecture.\n- In 2015, CanJS landed support for using a Virtual DOM and simple server-side rendering with [can-vdom].\n- In early 2016, CanJS added real-time support and advanced caching technology with [can-connect].\n- In late 2016, CanJS added a more powerful [can-define observable type] and enabled it to use\n  [can-define-stream functional reactive programming techniques].\n\nThis timeline shows more examples:\n\n<iframe src=\"https://cdn.knightlab.com/libs/timeline/latest/embed/index.html?source=1lBdurIQbbJkTZ8_kCQaXZtFaD06ulMFAlkqyEmXH4k0&amp;font=Bevan-PotanoSans&amp;maptype=toner&amp;lang=en&amp;start_at_slide=3&amp;height=650&amp;start_zoom_adjust=-2\" width=\"100%\" height=\"650\" style=\"max-width:800px\" frameborder=\"0\"></iframe>\n\n\n### How 3.0 improves stability and innovation\n\nCanJS 3.0 has been reorganized into several different dozen independent repositories,\neach with its own npm package and version number using [Semantic Versioning](http://semver.org/).\nOrganizing CanJS into individual repositories will improve\nCanJS’s stability and innovation going forward.\n\n#### Stability\n\nIndependent repositories improve stability because they make it easier to upgrade\nmore frequently. For example,\ncompare upgrading a 2.3 app to upgrading a 3.0 app.\n\nDespite making relatively few breaking changes, and\nproviding a [migrate-3 migration guide], upgrading from CanJS 2.3 to 3.0 looks like\na big step:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-3-upgrade.png\" style=\"width:100%;max-width:450px\"/>\n\nBut if you break that step down, CanJS 2.3 is mostly CanJS 3.0 with a bunch of bug\nfixes, a heap of new features, and a few breaking changes.  Most of the difficulties\nupgrading are the breaking changes, which account for the majority of the upgrade step size:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-upgrade-breakdown.png\" style=\"width:100%;max-width:450px\"/>\n\nCurrently, to get all of those bug fixes and new features, you have to\ntake on those breaking changes all at once.  Depending on your company culture,\nand scale of your application, this might not be easy.\n\nGoing forward in CanJS 3.0, packages are released independently of\neach other.  You can upgrade to bug fixes and new features\nimmediately and delay breaking changes (example: `can-route 4.0.0`) until later. You can upgrade breaking changes in steps too.  For example,\nyou might upgrade to `can-route 4.0.0` one month and `can-component 4.0.0`\nthe following month.  CanJS 3.0’s upgrade path might look like:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-upgrade-new.png\" style=\"width:100%;max-width:450px\"/>\n\nIndependent repositories also mean that [can-legacy legacy] libraries (like [can-ejs]) can continue\nliving through community-driven fixes and releases.  Legacy libraries don’t die simply because\nthey’re no longer included in the core CanJS build.\n\n#### Innovation\n\nIndependent repositories enable CanJS to innovate faster for several reasons:\n\n- Supporting [can-legacy legacy] libraries, like [can-ejs], will not slow down the\n  development of other libraries.\n- Experiments like [can-stream-kefir], where a lot of innovation happens, can be\n  released and have breaking changes without having to “get in” breaking changes\n  in the core and infrastructure libraries.\n- CanJS doesn’t feel as monolithic, appealing to developers using\n  just one part.  More users means more contributors.\n\nThe shift to independent repositories was CanJS 3.0’s biggest undertaking and\narguably biggest feature. This fact underscores how important our goal\nof balancing innovation and stability is to us. For more nuts-and-bolts features of CanJS,\nplease read [guides/technical CanJS’s Technical Highlights].\n\n",
    "description": "Learn about CanJS’s mission, why it matters, and how we’ve worked (and will keep working) to accomplish it.\n\n\n",
    "name": "guides/mission",
    "title": "Mission",
    "type": "page",
    "parent": "about",
    "order": 0,
    "comment": " "
  },
  "guides/who-uses-canjs": {
    "src": {
      "path": "docs/can-guides/introduction/who-uses.md"
    },
    "body": "\n<div class=\"screenshots\">\n\n## Apple Store\n\nDiscovered via [Reddit](https://www.reddit.com/r/javascript/comments/1kffau/apple_store_use_canjs_javascript_framework_not/)\n\n<a href=\"http://www.apple.com/shop/buy-iphone/iphone-7\"><span>http://www.apple.com/shop/buy-iphone/iphone-7</span><img src=\"../../docs/can-guides/images/apps/screenshots-aos.jpg\"></a>\n\n## Chase\n\n<a href=\"http://payments.chase.com\"><span>http://payments.chase.com</span><img src=\"../../docs/can-guides/images/apps/screenshots-chase.jpg\">\n\n## HP\n\n<a href=\"http://store.hp.com\"><span>http://store.hp.com</span><img src=\"../../docs/can-guides/images/apps/screenshots-hp.jpg\"></a>\n\n## USGA\n\n<a href=\"http://www.usga.org/\"><span>http://www.usga.org</span><img src=\"../../docs/can-guides/images/apps/screenshots-usga.jpg\"></a>\n\n## Yahoo\n\nYahoo uses CanJS in its [Brightroll Console](https://www.bitovi.com/blog/canjs-case-study-brightroll), a tool used to purchase ads and explore analytics.\n\n<img src=\"../../docs/can-guides/images/apps/screenshots-brightroll.jpg\">\n\n## PlutoTV\n\n<a href=\"http://pluto.tv/watch\"><span>http://pluto.tv/watch</span><img src=\"../../docs/can-guides/images/apps/screenshots-plutotv.jpg\"></a>\n\n## FedEx\n\nFedEx uses CanJS in its package tracker.\n\n<a href=\"https://www.fedex.com/apps/fedextrack/?action=track&cntry_code=us\"><span>https://www.fedex.com/apps/fedextrack</span><img src=\"../../docs/can-guides/images/apps/screenshots-fedex.jpg\"></a>\n\n## Sam’s Club\n\n<a href=\"https://m.samsclub.com/locator?xid=hdr_locator\"><span>https://m.samsclub.com</span><img src=\"../../docs/can-guides/images/apps/screenshots-sams.jpg\"></a>\n\n\n## Delta SkyMiles\n\nDelta uses CanJS in its rewards program, SkyMiles.\n\n<a href=\"http://www.skymilesshopping.com/\"><span>http://www.skymilesshopping.com</span><img src=\"../../docs/can-guides/images/apps/screenshots-skymiles.jpg\"></a>\n\n\n## Fidelity\n\nFidelity uses JavaScriptMVC (the previous name for CanJS) in its Mutual Fund comparison tool.\n\n<a href=\"https://www.fidelity.com/fund-screener/research.shtml\"><span>https://www.fidelity.com/fund-screener/research.shtml</span><img src=\"../../docs/can-guides/images/apps/screenshots-fidelity.jpg\"></a>\n\n\n## Cars.com\n\n<a href=\"http://www.cars.com\"><span>http://www.cars.com</span><img src=\"../../docs/can-guides/images/apps/screenshots-cars.jpg\"></a>\n\n\n</div>\n\n## Submit other apps\n\nDid you work on an app that uses CanJS? Please add it to the list [here](https://github.com/canjs/canjs/blob/master/docs/can-guides/introduction/who-uses.md) and create a PR, or email it [here](mailto:contact@bitovi.com) and we’d be happy to submit it for you!\n\n\n[//]: # (Volkswagon)\n\n[//]: # (Wells Fargo)\n\n[//]: # (Walmart)\n\n[//]: # (T-Mobile)\n\n",
    "description": "\n",
    "name": "guides/who-uses-canjs",
    "title": "Who Uses CanJS?",
    "type": "page",
    "parent": "about",
    "order": 2,
    "comment": " "
  },
  "guides/what-is-canjs": {
    "src": {
      "path": "docs/can-guides/introduction/what-is-canjs.md"
    },
    "body": "\nCanJS is an evolving and improving set of client side JavaScript architectural\nlibraries that balances innovation and stability.\n\nCanJS includes everything you need to build a modern, well architected\nJavaScript application:\n\n- Observable objects\n- Computed properties\n- Live binding templates\n- Custom elements\n- Service modeling and intelligent data caching\n- Routing\n\nThe CanJS libraries are divided into four categories:\n\n1. __The Core Collection__ - the core, most useful parts of the library.\n2. __The Ecosystem Collection__ - extensions to the core collection, which may\nbe useful for some applications, like mocked AJAX requests, helpers for\nimporting modules, virtual DOM libraries, and two-way data bindings\n3. __The Infrastructure Collection__ - Lower-level utilities that power the\ncore collection, generally not things that application developers will use\noften, like low-level JS and DOM utilities, the core parts of the template and\nobservable systems.\n4. __The Legacy Collection__ - Supported former libraries that are no longer\nactively developed, such as previous template engines and observable APIs.\n\n## Part of a stack\n\nCanJS is one piece of the larger DoneJS framework, which provides a full stack\nof tooling for building high performance, real-time web and mobile\napplications.\n\nCanJS, and each of its libraries, can be used in isolation, and are\nindividually useful, but are even more useful when combined together.\n\n[//]: # (GRAPHIC: show CanJS as a piece of DoneJS, and it’s modules as pieces themselves)\n\n## The Team\n\nCanJS is built by 100s of contributors.\n\n### Core Team\n\n#### Prashant Sharma\n\nPrashant is based in Bangalore, India. He likes the understated elegance of CanJS. I also believe DoneJS is a great framework in the making, since it makes technology selection a no brainer by uniquely offering developers an all-in-one technology stack.\ngithub\n\n#### Julian Kern\n\nA 29 old guy from Germany, Julian started coding at the age of 16. Now he freelances with CanJS. He likes the clean structure of Model, Views, and ViewModels.\n\n[https://twitter.com/@22_Solutions @22_Solutions]\n\n#### Mohamed Cherif Bouchelaghem\n\nMohamed Cherif BOUCHELAGHEM from Algiers, Algeria, almost a server side developer in day work, JavaScript developer after work hours specially using DoneJS/CanJS. He likes to help people to learn and find solutions to issues with DoneJS framework and build applications and code samples that help to show the best from DoneJS/Canjs and learn it faster.\n\n[https://twitter.com/Cherif_b @Cherif_b]\n\n### Full-time Team\n\n#### Kevin Phillips\n\nKevin is based in Chicago (well, close enough). He wants to make it easy for anyone to get started with DoneJS and will work on features that help solve complex problems.\n\n[https://twitter.com/kdotphil @kdotphil]\n\n\n#### Justin Meyer\n\nJustin dances and plays basketball in Chicago. He created JavaScriptMVC and manages the DoneJS project, and shouldn’t code on it as much as he does.\n\n[https://twitter.com/justinbmeyer @justinbmeyer]\n\n#### David Luecke\n\nDavid is a Canadian by way of Germany. His focus is on CanJS and DoneJS’s testing stack.\n\n[https://twitter.com/daffl @daffl]\n\n#### Matthew Phillips\n\nMatthew, keeper of beards, is the lead maintainer of StealJS and its related tools.\n\n[https://twitter.com/matthewcp @matthewcp]\n\nTo become a contributor to DoneJS or its sub-projects, you simply have to:\n\n * Email the core team expressing your interest.\n * Attend the weekly DoneJS Contributors meeting twice a month. [Meeting Calendar](https://www.google.com/calendar/embed?src=jupiterjs.com_g27vck36nifbnqrgkctkoanqb4%40group.calendar.google.com&ctz=America/Chicago)\n * Make one small contribution, even a spelling correction, per month.\n\n",
    "description": "\n",
    "name": "guides/what-is-canjs",
    "title": "What is CanJS?",
    "type": "page",
    "parent": "guides/introduction",
    "order": 1,
    "hide": true,
    "comment": " "
  },
  "guides/technical": {
    "src": {
      "path": "docs/can-guides/introduction/technical.md"
    },
    "body": "\n\n## Browser and Environment Support\n\nCanJS supports:\n\n - Latest Chrome, Firefox, Edge, Safari\n - IE9+\n - iOS Safari 10+\n - NodeJS 6+ with [can-vdom] as a document.\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/canjs.svg)](https://saucelabs.com/u/canjs)\n\n## Phenomenal Features, Small Size\n\nThe [can-core core] of CanJS is under 50KB (gzipped). While there may be smaller architectural libraries, there are not other frameworks that provide comparable functionality. For custom elements, observables, live binding, routing, a model layer with intelligent caching and real-time support, 50KB is very small.\n\njQuery 3.1 is 30KB minified and gzipped, and that is only providing DOM utilities. CanJS implements its own DOM utilities, in addition to much more.\n\nEmber 2.9 is 108KB minified and gzipped, providing a comparable feature set.\n\nReact 15.3 is 44KB minified and gzipped, yet React is, on its own, simply a View layer.\n\nThe Angular 2’s Hello World app, provided by the angular-cli, is ~100KB minified and gzipped.\n\n## Independent Repositories and Packages\n\nCanJS 3.0 is maintained in independent repositories,\neach with its own npm package and [semantic version](http://semver.org/) number.\nOrganizing CanJS into individual repositories and packages has many benefits.  \n\nThe obvious advantage is that pieces can be used without the whole. You can choose to use CanJS’s observables or [can-fixture] without the rest of the framework. You could even mix and match CanJS libraries with other libraries like React quite easily.\n\nHowever, the main benefit is that independent repositories\nimprove CanJS’s stability — one half of CanJS’s [guides/mission mission]. This is\nbecause independent repositories make it easier to upgrade more frequently. For example,\ncompare:\n\n- Upgrading a 2.3 app, which was not organized in individual repositories, to\n- Upgrading a 3.0 app.\n\nDespite making relatively few breaking changes, and\nproviding a [migrate-3 migration guide], upgrading from CanJS 2.3 to 3.0 looks like\na big step:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-3-upgrade.png\" style=\"width:100%;max-width:450px\"/>\n\nBut if you break that step down, CanJS 2.3 is mostly CanJS 3.0 with a bunch of bug\nfixes, a heap of new features, and a few breaking changes.  Most of the difficulties\nupgrading are the breaking changes, which account for the majority of the upgrade step size:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-upgrade-breakdown.png\" style=\"width:100%;max-width:450px\"/>\n\nTo get all of those bug fixes and new features in 3.0, you have to\ntake on those breaking changes from 2.3 all at once.  Depending on your company culture,\nand scale of your application, this might not be easy.\n\nGoing forward in CanJS 3.0, packages are released independently of\neach other.  You can upgrade to bug fixes and new features\nimmediately and delay breaking changes (example: `can-route 4.0.0`) until later. You can upgrade breaking changes in steps too.  For example,\nyou might upgrade to `can-route 4.0.0` one month and `can-component 4.0.0`\nthe following month.  CanJS 3.0’s upgrade path might look like:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-upgrade-new.png\" style=\"width:100%;max-width:450px\"/>\n\nIndependent repositories also mean that [can-legacy legacy] libraries, like [can-ejs] can continue\nliving through community-driven fixes and releases.  They don’t die simply because\nthey are no longer included in the core CanJS build.\n\n## Flexible Features\n\nNo framework can perfectly satisfy every application\nrequirement.  Often, a framework can’t even satisfy all the requirements\nfor a single application. When this happens, it’s nice to have a framework that can\nflexibly adapt to the challenge.  The sections below have\nmany examples of this flexibility:\n\n- CanJS can be both [object-oriented and functional](#Objectorientedandfunctional),\n  imperative and declarative.\n- CanJS’s MVVM [observables are useful outside the framework](#Flexible).\n- CanJS [integrates with jQuery](#jQueryintegration), making DOM-centric development easier.\n\nThere are a bunch of other ways that CanJS makes it easy to develop outside the box:\n\n - [can-control] can handle when DOM-centric programming is necessary.\n - [can-compute] can be wired up to anything.\n - The [can-infrastructure] collection has a number of utility libraries that\n   can help jump-start development.\n\n## Cool Computes\n\nCanJS has two powerful observable systems that are the foundation for many of the other\ncore libraries:\n\n - [can-compute] - Observable values and derived observable values.\n - [can-define] - Observable objects.\n\nThis section is about the technical highlights of [can-compute].  However,\nas [can-define] uses computes internally for [computed getter properties](#Computedgetterproperties)\nand [asynchronous computed getter properties](##Asynccomputedgetterproperties), the benefits\nof computes extend to [can-define]. In a few examples cases, we’ll use [computed getter properties](#Computedgetterproperties) to\nshow the advantages of computes.\n\n[can-compute] is used in similar situations as event streams libraries like RXJS and Bacon.js. Computes\nare used to transform a set of observable values into another observable value.  While event stream libraries are able to set up more complex transformations, computes can set up simple but common transformations more easily.\n\nFor example, the following compute keeps the completed count of todos in a list:\n\n```js\nvar DefineList = require(\"can-define/list/list\");\nvar DefineMap = require(\"can-define/map/map\");\nvar compute = require(\"can-compute\");\n\nvar todoList = new DefineList([\n    {name: \"dishes\",  complete: true},\n    {name: \"laundry\", complete: false}\n]);\n\nvar completedCount = compute(function(){\n    return todoList.filter(function(todo){\n        return todo.complete;\n    });\n})\n```\n\n`completedCount` is updated when any todo’s `complete` property changes like:\n\n```js\ntodoList[0].complete = false;\n```\n\nOr a todo is added to or removed from the list like:\n\n```js\ntodoList.push({name: \"learn about computes\", complete: true})\n```\n\n`completedCount` automatically listens to all of these changes because\n[can-compute] infers dependencies.  Computes also:\n\n - [Cache their value](#Cachedvalues) for faster reads.\n - [Dispatch events synchronously](#Synchronous) for easier testing and debugging.\n - [Update only once for batched changes](#Batchedevents) for faster updates.\n\n### Inferred dependencies\n\nIn event stream libraries or other computed libraries, you must declare your\ndependencies like:\n\n```js\nvar fullNameStream = Kefir.combine(firstNameStream, lastNameStream, function(firstName, lastName){\n    return firstName + \" \" + lastName;\n});\n```\n\nor like:\n\n```js\nfullName: Ember.computed('firstName', 'lastName', function() {\n\treturn this.get('firstName')+\" \"+this.get('lastName');\n});\n```\n\n[can-compute] infers its own dependencies without needing to explicitly declare them, therefore requiring less boilerplate code. This means you can write `fullName` like:\n\n```js\nvar fullName = compute(function(){\n    return firstName() + \" \" + lastName();\n});\n```\n\nor like:\n\n```js\nPerson = DefineMap.extend({\n    firstName: \"string\",\n    lastName: \"string\",\n    get fullName() {\n        return this.firstName + \" \" +this.lastName;\n    }\n});\n```\n\nThis ability is especially useful when the dependencies are dynamic as in the\nfollowing `completedCount` example:\n\n\n```js\nvar todoList = new DefineList([\n    {name: \"dishes\",  complete: true},\n    {name: \"laundry\", complete: false}\n]);\n\nvar completedCount = compute(function(){\n    return todoList.filter(function(todo){\n        return todo.complete;\n    });\n})\n```\n\nWhen todos are added to and removed from `todoList`, `completedCount`\nwill update its bindings automatically.\n\n\n### Cached values\n\nOnce a compute is bound (using [can-compute.computed.on] or [can-compute.computed.addEventListener]), it immediately calculates its\nvalue and caches it so any future reads will use the cached value.\n\nIn the following example, before `fullName` is bound,\n`fullName`’s value is recalculated every time it is read.  After `fullName` is bound,\nits value is recalculated only when a dependent value changes.\n\n```js\nvar compute = require(\"can-compute\");\nvar firstName = compute(\"Payal\");\nvar lastName = compute(\"Meyer\");\n\nvar fullName = compute(function(){\n    console.log(\"Calculating fullName.\");\n    return firstName()+\" \"+lastName();\n});\n\nfullName() // console.logs \"Calculating fullName.\"\n           //-> \"Payal Meyer\"\n\nfullName() // console.logs \"Calculating fullName.\"\n           //-> \"Payal Meyer\"\n\nfullName.on(\"change\", function(){}) // console.logs \"Calculating fullName.\"\n\nfullName() //-> \"Payal Meyer\"\nfullName() //-> \"Payal Meyer\"\n\nfirstName(\"Ramiya\") // console.logs \"Calculating fullName.\"\n\nfullName() //-> \"Ramiya Meyer\"\n```\n\nUsing cached values improves performance in situations where a computed value is frequently read by multiple parts of the application.  \n\n### Synchronous\n\nCanJS observables synchronously notify any event listeners. This makes testing\nand debugging quite easier.\n\nThe following example shows how you can\nchange the `firstName` value and immediately check the consequences of that change:\n\n```js\nvar stache = require(\"can-stache\");\nvar compute = require(\"can-compute\");\n\nvar template = stache(\"<h1>Welcome {{fullName}}</h1>\");\n\nvar firstName = compute(\"Justin\");\nvar lastName = compute(\"Meyer\");\n\nvar fullName = compute(function(){\n    return firstName()+\" \"+lastName();\n});\n\nvar frag = template({fullName: fullName});\n\nassert.equal(frag.firstChild.innerHTML, \"Welcome Payal Meyer\");\n\nfirstName(\"Ramiya\");\n\nassert.equal(frag.firstChild.innerHTML, \"Welcome Ramiya Meyer\");\n```\n\n### Batched events\n\nThe previous section highlighted that synchronous event\n[can-event/batch/batch.dispatch dispatching] and DOM updates are ideal for many scenarios. But, there are times where this can cause performance problems. To prevent unnecessary updates, events can be batched using [can-event/batch/batch.start batch.start] and [can-event/batch/batch.stop batch.stop]. Computes and the DOM will only be updated once for all changes within the batch.\n\nIn the previous example, `{{fullName}}` would be updated twice\nif `firstName` and `lastName` are changed:\n\n```js\nfirstName(\"Payal\");\nlastName(\"Shah\");\n```\n\nWrapping this in a batch makes `{{fullName}}` update only once:\n\n\n```js\nvar batch = require(\"can-event/batch/batch\");\n\nbatch.start();\nfirstName(\"Payal\");\nlastName(\"Shah\");\nbatch.stop();\n```\n\nUsing [can-event/batch/batch.start batch.start] and [can-event/batch/batch.stop batch.stop]\ncan even make quadratic updates (`O(n^2)`) become linear (`O(n)`).\n\nConsider the performance of a `completeAll` method that completes every todo in a list\nand a `completeCount` compute that calculates the number of complete todos:\n\n```js\nvar todoList = new DefineList([\n    {name: \"dishes\",  complete: false},\n    {name: \"laundry\", complete: false}\n]);\n\nvar completeAll = function(){\n    todoList.forEach(function(todo){\n        console.log(\"completing\", todo.name)\n        todo.complete = true;\n    });\n};\n\nvar completedCount = compute(function(){\n    return todoList.filter(function(todo){\n        console.log(\"  checking\", todo.name);\n        return todo.complete;\n    });\n});\n\ncompletedCount.on(\"change\", function(ev, newVal){\n    console.log(\"completedCount is\", newVal);\n});\n```\n\nIf `completeAll` is called, the following will be logged:\n\n```js\ncompleteAll();\n// console.logs \"completing dishes\"\n// console.logs \"  checking dishes\"\n// console.logs \"  checking laundry\"\n// console.logs \"completedCount is 1\"\n// console.logs \"completing laundry\"\n// console.logs \"  checking dishes\"\n// console.logs \"  checking laundry\"\n// console.logs \"completedCount is 2\"\n```\n\nThis means that every time a todo is marked as complete, `completedCount` loops\nthrough every todo.\n\nHowever, changing `completeAll` to use `batch.start` and `batch.stop` like:\n\n```js\nvar completeAll = function(){\n    batch.start();\n    todoList.forEach(function(todo){\n        console.log(\"completing\", todo.name)\n        todo.complete = true;\n    });\n    batch.stop()\n};\n```\n\nmeans `completeAll` will log the following:\n\n```js\ncompleteAll();\n// console.logs \"completing dishes\"\n// console.logs \"completing laundry\"\n// console.logs \"  checking dishes\"\n// console.logs \"  checking laundry\"\n// console.logs \"completedCount is 2\"\n```\n\n[can-event/batch/batch.start batch.start] and [can-event/batch/batch.stop batch.stop]\ncan improve performance by preventing compute recalculations.\n\n## Outstanding Observable Objects\n\n[can-define] is used to create observable [Models](#MalleableModels) and [ViewModels](#VeraciousViewModels) like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Person = DefineMap.extend({\n    first: \"string\",\n    last: \"string\",\n    get fullName(){\n        return this.first + \" \" + this.last;\n    }\n})\n```\n\n[can-define] uses [can-compute] internally to support [computed getter properties](##Computedgetterproperties) like the previous example’s `fullName`, so make sure to read about the benefits of [cool computes](#CoolComputes).\n\nAs [can-define] powers almost everything in a CanJS application, it has grown to be\nquite powerful, performant and flexible.  Read on to explore some of its best characteristics.\n\n### Expressive property definition syntax\n\n[can-define] supports an expressive, powerful syntax for defining properties on observable objects and lists. It supports [can-define.types.get getter], [can-define.types.set setter],\ninitial [can-define.types.value], and [can-define.types.type] conversion, [can-define.types.serialize]\nand [can-define-stream.stream] behaviors.\n\nThe following illustrates the signatures of these behaviors:\n\n```js\nDefineMap.extend({\n    propertyName: {\n        get: function(lastSetValue, resolve){ ... },\n        set: function(newValue, resolve){ ... },\n        type: function(newValue, propertyName){ ... },\n        Type: Constructor,\n        value: function(){ ... },\n        Value: Constructor,\n        serialize: function(){ ... },\n        stream: function(setStream){ ... }\n    }\n})\n```\n\n[can-define] also supports a wide variety of short hands for setting up these\nbehaviors. The following illustrates some of these behaviors:\n\n```js\nDefineMap.extend({\n    propertyA: Object      -> PropertyDefinition\n    propertyB: String      -> {type: String}\n    propertyC: Constructor -> {Type: Constructor}\n    propertyD: [PropDefs]  -> {Type: DefineList.extend({\"#\": PropDefs})>}\n    get propertyE(){...}   -> {get: propertyE(){...}}\n    set propertyF(){...}   -> {get: propertyF(){...}}\n    method: Function\n})\n```\n\nPutting it together, the following defines an `Address` and `Person` type with some nifty features:\n\n```js\n// Address has a street, city, and state property\nvar Address = DefineMap.extend({\n    street: \"string\",\n    city: \"string\",\n    state: \"string\"\n})\n\nvar Person = DefineMap.extend({\n    // first is a string\n    first: {type: \"string\"},\n    // last is a string\n    last: \"string\",\n    // fullName is the combination of first and last\n    get fullName(){\n        return this.first+\" \"+this.last;\n    },\n    // age is a number that defaults to `0`\n    age: {value: 0, type: \"number\"},\n    // addresses is a DefineList of Address types\n    addresses: [Address]\n});\n```\n\n### Object-oriented and functional\n\nCanJS’s observables produce data types that are easy for others to consume,\nbut can be implemented with the rigor of declarative programming.  This is\naccomplished by combining the benefits of object-oriented programming,\nfunctional programming, and functional reactive programming.\n\n[Functional programming](https://en.wikipedia.org/wiki/Functional_programming), which is a\nform of [declarative programming](https://en.wikipedia.org/wiki/Declarative_programming), avoids\nchanging state and mutable data.  It treats programming as math.  This eliminates side effects,\nmaking it easier to predict the behavior of an application.\n\n> Programming is, at its best, a branch of formal mathematics and applied logic.   \n> __Edsger Dijkstra__ - _1 March 1999 at the ACM Symposium on Applied Computing at San Antonio, TX_\n\nHowever, [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming) APIs often feel more natural.\n\n> Object-oriented programming leverages the fact that humans have millions of years of evolution invested in conceiving of the world in terms of things, which have properties, and associated methods of doing things with them. A salt shaker has a property of the amount of salt in it, and can be shaken.  \n> [Tim Boudreau, Oracle Labs](https://www.quora.com/Why-did-Dijkstra-say-that-%E2%80%9CObject-oriented-programming-is-an-exceptionally-bad-idea-which-could-only-have-originated-in-California-%E2%80%9D)\n\nWe agree with both of these ideas! The following object-oriented `SaltShaker` API feels intuitive - any\ndeveloper can immediately understand it.\n\n```js\nvar saltShaker = new SaltShaker();\n\nsaltShaker.fill();  \n\nsaltShaker.shake() //-> \"salt\"\nsaltShaker.shake() //-> \"salt\"  \nsaltShaker.shake() //-> null   \n\nsaltShaker.empty   //-> true\n```\n\nTo satisfy this API, `SaltShaker` could be implemented as follows:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nSaltShaker = DefineMap.extend({\n    saltCount: {type: \"number\", value: 0},\n    fill: function(){\n        this.saltCount = 2;\n    },\n    shake: function(){\n        var hasSalt = this.saltCount;\n        this.saltCount = hasSalt ? this.saltCount - 1 : 0;\n        return hasSalt ? \"salt\" : null;\n    },\n    get empty() {\n        return ! this.saltCount;\n    }\n});\n```\n\nWhile `empty` is implemented [declaratively](https://en.wikipedia.org/wiki/Declarative_programming),\nnotice how both `fill` and `shake` mutate the state of `saltCount`.  In a more complex type,\nthis can easily lead to bugs.  Instead, the following uses [can-define-stream] and\n[functional reactive programming](https://en.wikipedia.org/wiki/Functional_reactive_programming)\nto make `saltCount` a function of the calls to `fill` and `shake`:\n\n```js\nvar SaltShaker = DefineMap.extend({\n    saltCount: {\n        stream: function() {\n            return this.stream(\"fill\")\n\t\t\t\t\t.merge(this.stream(\"shake\"))\n\t\t\t\t\t.scan(function(prev, event){\n\t\t\t\tif(event.type === \"fill\") {\n\t\t\t\t\treturn 2;\n\t\t\t\t} else {\n\t\t\t\t\treturn prev > 0 ? prev - 1 :  0;\n\t\t\t\t}\n\t\t\t},0);\n        }\n    },\n    fill: function() {\n        this.dispatch(\"fill\");\n    },\n    shake: function() {\n\t\tvar hadSalt = this.saltCount;\n        this.dispatch(\"shake\");\n        return hadSalt ? \"salt\" : null;\n    },\n    get empty() {\n        return !this.saltCount;\n    }\n});\n```\n\nCanJS provides three powerful functional helpers on [can-define/map/map] and [can-define/list/list] that will explore in the following sections:\n\n - [can-define.types.get computed getter properties]\n - [can-define.types.get async computed getter properties]\n - [can-define-stream.stream streamed properties]\n\n### Computed getter properties\n\n[can-define.types.get Computed getters] are the easiest way to declaratively transform\nstateful values into derived values.  For example, the following defines a `completedCount`\nproperty on instances of the `TodoList` type:\n\n```js\nvar TodoList = DefineList.extend({\n    \"#\": Todo,\n    get completedCount(){\n        return this.filter({complete: true}).length\n    }\n});\n\nvar todos = new TodoList([{complete: true}, {complete:false}]);\ntodos.completedCount //-> 1\n```\n\nThese [can-define.types.get getters] are made with [can-compute], so they\n[infer dependencies](#Inferreddependencies), [cache their values](#Cachedvalues), and are [synchronous](#Synchronous).\n\n### Async computed getter properties\n\nIt’s common to load data asynchronously given some state. For example, given\na `todoId`, you might need to load a `todo` from the server.  This `todo` property\ncan be described using [can-define.types.get asynchronous computed getters] as follows:\n\n```js\nvar EditTodoVM = DefineMap.extend({\n    todoId: \"number\",\n    todo: {\n        get: function(lastSetValue, resolve){\n            Todo.get(this.todoId).then(resolve);\n        }\n    }    \n});\n```\n\n### Streamed properties\n\nWhen the behavior of properties can’t be described with computes,\nthe [can-define-stream] module adds the ability to work with event\nstreams.  For example, `lastValidName` keeps track of `Person`’s\nlast `name` property that includes a space.\n\n```js\nvar Person = DefineMap.extend({\n  name: \"string\",\n  lastValidName: {\n    stream: function(){\n      return this.stream(\".name\").filter(function(name){\n        return name.indexOf(\" \") >= 0;\n      })\n    }\n  }\n});\n\nvar me = new Person({name: \"James\"});\n\nme.on(\"lastValidName\", function(lastValid) {\n  console.log(lastValid)\n});\n\nme.name = \"JamesAtherton\"; // No change\n\nme.name = \"James Atherton\";\n//-> console.logs \"James Atherton\";\n\nme.name = \"JustinMeyer\"; // No change\n\nme.name = \"Justin Meyer\";\n//-> console.logs \"Justin Meyer\";\n```\n\n## Maintainable MVVM\n\n\nCanJS applications are Model-View-ViewModel (MVVM) architecture with\ncustom elements providing orchestration.\n\n<img src=\"../../docs/can-guides/images/introduction/mvvm.png\" style=\"width:100%;max-width:750px\" alt=\"Model-View-ViewModel Diagram\"/>\n\nIt’s a [straightforward](#Straightforward), but [flexible](#Flexible) architecture that\nproduces [easily testable](#Easily_testable), [compose-able](#Compose_able) modules and components.\n\n### Straightforward\n\nOn the highest level, CanJS applications are broken down into 2 parts:\n\n- **Custom Elements** that manage a particular part of the application.  \n- [Models](#MalleableModels) that handle data requests to and from the server.\n\nFor example, consider the following order page from [place-my-order](http://place-my-order.com):\n\n<img src=\"../../docs/can-guides/images/introduction/tech-component-map.png\" style=\"width:100%;max-width:750px\" />\n\nThis page might be broken down into the following\ncustom elements:\n\n - `<pmo-nav>`\n - `<pmo-order-new>` which is further broken down into:\n   - `<bit-tabs>`\n   - `<pmo-order-menu>`\n\nThese _Custom Elements_ use the `Restaurant` model\nto get a restaurant’s menu by making a `GET` request to `/api/restaurants`;\nand they use the `Order` model to create an order by making a `POST` request to\n`POST /api/orders`.\n\n_Custom Elements_ are broken down themselves into two layers:\n\n- [ViewModels](#VeraciousViewModels) that manage the logic of a custom element.\n- [Views](#VivaciousViews) that convert the data and values of the\n _ViewModel_ into HTML elements. Views update their HTML\n elements when the _ViewModel_ changes and are able to\n call methods on the _ViewModel_ when a user interacts\n with their HTML.\n\nAll of these parts, _Custom Elements_, _Models_,\n_View Models_, and _Views_, are __mostly__ written using just\na couple APIs:\n\n- [can-define] observables for _ViewModels_ and _Models_.\n- [can-stache] templates with [can-stache-bindings] for _Views_.\n\nThe rest of the core APIs are just decorators, used\nto turn [can-define] observables and [can-stache] templates\ninto something more:\n\n - [can-component] combines a [can-define] observable\n   and [can-stache] template into a _Custom Element_.\n - [can-route] two-way binds a [can-define] observable\n   with the browser’s URL.\n - [can-connect] adds methods to a [can-define] observable,\n   enabling it to create, read, update, and delete data on\n   a RESTful URL.\n\nCanJS is straightforward because it’s just about building\ncustom elements and models with just a small set of tools -  [can-define]\nand [can-stache].\n\n### Independent\n\nCanJS’s Models, Views, and ViewModels are all independent, individually\nuseful layers.  This independence is the source for the benefits of\nMVVM architecture discussed in the following sections:\n\n - [Flexible](#Flexible) - change tools and patterns when the need arises.\n - [Testable](#Testable) - easily unit test parts of the application.\n - [Compose-able](#Compose_able) - combine smaller units of functionality into a large whole.\n\nFor now, we’ll just demonstrate that these things actually are independent using\ncode in the [guides/todomvc].  We’ll organize code related to the `<todo-list>` component\ninto individual and independent modules and files that look like:\n\n```\n├── models/\n|   ├── todo.js\n├── components/\n|   ├── todo-list/\n|   |   ├── view-model.js\n|   |   ├── view.stache\n|   |   ├── todo-list.js\n```\n\nThe __Model__, in _models/todo.js_, looks like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\"),\n    DefineList = require(\"can-define/list/list\"),\n    set = require(\"can-set\"),\n    superMap = require(\"can-connect/can/super-map/super-map\");\n\n// Defines the type of data we get back from the server.\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\n// Defines methods or properties on lists\n// we get back from the server.\nTodo.List = DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\n// Defines the behavior of the \"get list\"\n// API endpoint.\nTodo.algebra = new set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\n// Connects the types above to a RESTful url.\nTodo.connection = superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: Todo.algebra\n});\n\nmodule.exports = Todo;\n```\n\nThis model can independently make requests to a RESTful service layer.\n\n- [can-connect/can/map/map.getList Get a list] of Todos\n  ```js\n  Todo.getList({complete: true}).then(function(todos){})\n  ```\n- [can-connect/can/map/map.get Get] a single Todo\n  ```js\n  Todo.get({_id: 6}).then(function(todo){})\n  ```\n- [can-connect/can/map/map.prototype.save Create] a Todo\n  ```js\n  var todo = new Todo({name: \"do dishes\", complete: false})\n  todo.save().then(function(todo){})\n  ```\n- [can-connect/can/map/map.prototype.save Update] an [can-connect/can/map/map.prototype.isNew already created] Todo\n  ```js\n  todo.complete = true;\n  todo.save().then(function(todo){})\n  ```\n- [can-connect/can/map/map.prototype.destroy Delete] a Todo\n  ```js\n  todo.destroy().then(function(todo){})\n  ```\n\nThe __ViewModel__, in _components/todo-list/view-model.js_, looks like:\n\n```js\nvar DefineMap = \"can-define/map/map\";\nvar Todo = \"../models/todo\";\n\nmodule.exports = DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n\n  // Returns true if the current todo is being edited.\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n\n  // Marks a todo as being edited.\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n\n  // Cancels that todo as being edited.\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n\n  // Updates the todo being edited on\n  // the server.\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n```\n\nThis _ViewModel_ will be tested independent of the view in the\n[testable](#Testable) section.  \n\nThe __View__, in _components/todo-list/view.stache_, looks like:\n\n```html\n<ul id=\"todo-list\">\n  <!-- Loop through every todo -->\n  {{#each todos}}\n\n    <!-- Create an li with the right class names -->\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n\n      <div class=\"view\">\n        <!-- Connect this checkbox to the `complete` property\n             of the current todo -->\n        <input class=\"toggle\" type=\"checkbox\"\n               checked:bind=\"complete\"\n               on:change=\"save()\">\n\n        <!-- Edit this todo on double click -->\n        <label on:dblclick=\"edit(this)\">{{name}}</label>\n\n        <!-- Delete this todo on the server when clicked -->\n        <button class=\"destroy\" on:click=\"destroy()\"></button>\n      </div>\n\n      <!-- Handle editing this todo with this input element -->\n      <input class=\"edit\" type=\"text\"\n        value:bind=\"name\"\n        on:enter=\"updateName()\"\n        focused:from=\"isEditing(this)\"\n        on:blur=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n```\n\nThis _View_ lives in its own file, so a designer can modify it\nwithout touching any JavaScript directly.\n\nFinally, the component file in _components/todo-list/todo-list.js_ puts\neverything together:\n\n```js\nvar Component = require('can-component');\nvar ViewModel = require(\"./view-model\");\nvar view = require('./view.stache!');\n\nComponent.extend({\n    tag: 'todo-list',\n    ViewModel: ViewModel,\n    view: view\n});\n```\n\nRead on to see how CanJS’s independence results in easily testable, flexible,\nand compose-able code.\n\n\n### Testable\n\nCanJS’s MVVM architecture results in testable code. In the previous\nsection, we created the [guides/todomvc]’s `<todo-list>`’s Model, ViewModel, and View code.\nThe following shows examples of testing each part.\n\nTesting the __Model__’s `active` and `complete` properties:\n\n```js\ntest(\"Todo active and complete\", function(){\n    var list = new Todo.List([\n        {name: \"dishes\", complete: false},\n        {name: \"lawn\", complete: true}\n    ]);\n    assert.deepEqual(list.active.get(), [{name: \"dishes\", complete: false}], \"one active\");\n    assert.deepEqual(list.complete.get(), [{name: \"lawn\", complete: true}], \"one complete\")\n});\n```\n\nTesting the __ViewModel__’s `edit` and `cancelEdit` methods:\n\n```js\ntest(\"TodoListVM cancelEdit\", function(){\n    var todos = new Todo.List([\n        {name: \"mow lawn\", complete: false},\n        {name: \"dishes\", complete: true},\n    ]);\n\n    var todoListVM = new TodoListVM({\n        todos: todos\n    });\n\n    todoListVM.edit(todos[0]);\n    todos[0].name = \"mow yard\";\n\n    todoListVM.cancelEdit();\n\n    assert.equal(todos[0].name, \"mow lawn\");\n});\n```\n\nTo test the __View__, we typically recommend testing the component. The\nfollowing, using [can-fixture], tests that the component can edit a\ntodo’s name.\n\n```js\ntest(\"<todo-list> can update todo name\", function(done){\n\n    fixture(\"PUT /api/todos/{id}\", function(request){\n        assert.equal(request.data.name, \"MOW YARD\", \"update\");\n        done();\n    });\n\n    var todos = new Todo.List([\n        {name: \"mow lawn\", complete: false, id: 22},\n        {name: \"dishes\", complete: true, id: 23},\n    ]);\n\n    var template = stache(\"<todo-list todos:from='todos'/>\");\n    var todoListElement = template({todos: todos}).firstChild;\n\n    // double click todo\n    todosListElement.querySelector(\".todo label\").dispatch( new MouseEvent('dblclick') );\n\n    // change its value to MOW YARD by hitting enter (which causes a change first)\n    var input = todoListElement.querySelector(\".todo input.edit\");\n    input.value = \"MOW YARD\";\n\n    input.dispatchEvent( new Event('change') );\n\n    input.dispatchEvent( new KeyboardEvent(\"keyup\",{code: \"Enter\", keyCode: 13}) );\n});\n```\n\nCheck out these tests running in [this JS&nbsp;Bin](https://jsbin.com/lulucuboni/1/edit?html,js,output).\n\n### Flexible\n\nCanJS’s architecture produces observables that stand on their\nown, useful outside of the framework.  CanJS’s observables aren’t dependent on a diffing engine to identify changes.  Instead, any other tool or library can be an observer or call methods\non the observable.\n\n[This JS Bin](https://jsbin.com/vivowu/7/edit?html,js,output) shows an analog clock that uses the [Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The `Analog`\nclock listens to a `timer` observable and updates the position of the second, hour, and minute\nhands when the time changes.\n\n```js\nAnalog = function(element, timer) {\n    ...\n    timer.on(\"time\", this.drawClock.bind(this) );\n};\n\nvar timer = new Timer();\nnew Analog(document.getElementById(\"analog\"), timer);\n```\n\nAlso, with the ideas discussed in [Object-oriented and functional](#Objectorientedandfunctional),\nCanJS applications can closely approximate a stateless, redux-like,\narchitecture.  While we think this architecture creates more work than necessary for\ndevelopers, it’s possible by:\n\n - Having a single, ApplicationViewModel that contains all state, derived using\n   [can-define-stream] from events dispatched on the ApplicationViewModel.\n - Enforcing that parent-to-child communication only uses one-way\n   [can-stache-bindings.toChild] bindings like:\n   ```html\n   <child-component prop:from=\"parentValue\"/>\n   ```\n - Enforcing that child-to-parent communication is [can-stache-bindings.event] based:\n   ```html\n   <child-component on:event=\"parentMethod()\"/>\n   ```\n\n\n### Compose-able\n\nWe believe that application state should be federated:\n\n> [Federated](https://en.oxforddictionaries.com/definition/federate) - form or be formed into a single centralized unit, within which each state or organization keeps some internal autonomy.\n\nCanJS applications are composed from hierarchical [can-component]s, each containing their own independent state (their own ViewModel). This architecture is at the core of CanJS’s approach to building large applications.\n\n> The secret to building large apps is never build large apps. Break your applications into small pieces. Then, assemble those testable, bite-sized pieces into your big application.\n\nCanJS applications can be represented by [Hierarchical State Machines](https://en.wikipedia.org/wiki/UML_state_machine#Hierarchically_nested_states). The [guides/atm]\nwalks through an example of this concept where a `Card`, `Deposit`, and `Withdrawal`’s states\nare composed into the `ATM`’s state.\n\n<img height=\"693\" src=\"../../docs/can-guides/experiment/atm/1-pages-template/state-diagram.png\" width=\"808\">\n\nThis dispersed (federated) state means that a `Card` is still useful without the\n`ATM`.  A `Card` can make AJAX requests and maintains its state of being\n`verified` or `unverified`.\n\nFederated state stands in contrast to architectures that have a\n_one-way_ data flow. Architectures with a _one-way_ data flow usually flow to\na central and global _state mechanism_. That _state mechanism_\nbecomes an implicit dependency of every component in the application. This creates additional downstream problems:\n\n* It becomes harder to work independently and verify the behavior of component of the project. Thus, scaling the team and parallelizing the effort becomes trickier, as several developers might have to touch the same central state mechanism.\n\n* Individual components become less reusable in other contexts because of their dependency on this external state layer.\n\n* Individual components become harder to test in isolation, since testing them requires importing or mocking large external dependencies.\n\n## Veracious ViewModels\n\nCanJS’s ViewModels are [can-define] observables that manage the state of a [can-component].\nAs ViewModels are observables, CanJS’s ViewModels have all the benefits of\nCanJS’s outstanding observable objects, namely:\n\n - [Expressive property definition syntax](#Expressivepropertydefinitionsyntax)\n - [Object-oriented and functional](#Objectorientedandfunctional)\n - [Computed getter properties](#Computedgetterproperties)\n - [Async computed getter properties](#Asynccomputedgetterproperties)\n - [Streamed properties](#Streamedproperties)\n\nIn CanJS, the ViewModel is its own layer, completely independent from the\ntemplate and the component. This is why ViewModels are largely responsible for\nmany of the benefits of CanJS’s maintainable MVVM architecture:\n\n - [Independence](#Independent)\n - [Flexible](#Independent)\n - [Testable](#Testable)\n - [Compose-able](#Compose_able)\n\nThe introduction of a strong ViewModel provides key advantages for maintaining large applications:\n\n* Decouples the presentation from its business logic - A ViewModel is essentially an object and methods representing the state of a View. This separation of concerns enables simple, HTML-based Views containing minimal logic, while the ViewModel manages the complexities of application logic.\n\n* Enables designer/developer cooperation - Because the view is stripped of code and application logic, designers can safely and comfortably change the View without fear of breaking things.\n\n* Enables easier testing - ViewModels can be unit tested easily. Because they represent the view’s state without any knowledge of the DOM, they provide a simple interface for testing.\n\n## Vivacious Views\n\nCanJS views are [can-stache] templates, that implement a syntax similar to\n[Mustache](https://mustache.github.io/mustache.5.html) and [Handlebars](http://handlebarsjs.com/),\nand include special features like event bindings, custom elements, and performance optimizations.\n\n[can-stache] templates look like HTML, but with _magic_ tags like [can-stache.tags.escaped]\nand view bindings like [can-stache-bindings.twoWay] in the template. For example, the following is the application template in the [guides/todomvc]:\n\n```html\n<header id=\"header\">\n\t<h1>todos</h1>\n\t<todo-create/>\n</header>\n\n<ul id=\"todo-list\">\n\t{{#each todos}}\n\t\t<li class=\"todo {{#if complete}}completed{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" checked:bind=\"complete\">\n\t\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t\t<button class=\"destroy\" on:click=\"destroy()\"></button>\n\t\t\t\t</div>\n\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t</li>\n\t{{/each}}\n</ul>\n```\n\nThe following sections cover:\n\n - [The powerful syntaxes](#MustacheandHandlebarsextendedsyntax) that support the transformation of any ViewModel into HTML.\n - How [custom elements and attributes](#Customelementsandattributes) make\n   applications easer to assemble and debug.\n - The [binding syntaxes](#DataandEventBindings) that allow HTML to\n   call methods back on the ViewModel.\n - The strategies used to keep [DOM updates to a minimum](#MinimalDOMupdates).\n - How Views can fit in your larger ecosystem with [template minification](#Templateminification),\n   [dependency declarations](#In_templatedependencydeclarations), and [progressive loading](#ProgressiveLoading).\n\n### Mustache and Handlebars extended syntax\n\n[can-stache] templates implement the mustache syntax\n[Mustache](https://mustache.github.io/mustache.5.html), adopt many of\nthe [Handlebars](http://handlebarsjs.com/) extensions, and provide a few extensions of\ntheir own.  The result is a simple syntax that covers the most common things needed in a template,\nbut is capable of translating any ViewModel into HTML.\n\n\n[can-stache] is built on the Mustache spec because Mustache simplifies the most common needs of templates into\na very limited subset of syntax.  Most of Mustache is just:\n\n - [can-stache.tags.escaped] - to insert content into the page.\n - [can-stache.tags.section]...[can-stache.tags.close] - to do conditionals, looping, or change context.\n\nA simple template might look like:\n\n```html\n<p>Hello {{name}}</p>\n<p>You have just won {{value}} dollars!</p>\n{{#in_ca}}\n<p>Well, {{taxed.ca.value}} dollars, after taxes.</p>\n{{/in_ca}}\n```\n\nThis is not enough to translate every ViewModel into HTML, so [can-stache] supports\nHandlebars helpers like [can-stache.helpers.each] and\nthe ability to [can-stache/expressions/call call methods].\n\nA template that uses those features looks like:\n\n```html\n{{#players}}\n    <h2>{{name}}</h2>\n    {{#each stats.forPlayerId(id) }}\n\t\t<span>\n\t\t\t{{type}}\n\t\t</span>\n\t{{/each}}\n{{/players}}\n```\n\n\n\n\n\n### Custom elements and attributes\n\nCanJS supports defining custom elements and\nattributes.  You can make it so adding a `<ui-datepicker>`\nelement to the page creates a date picker widget; or, you can make it so\na `my-tooltip=\"your message\"` attribute adds a tooltip.\n\nCustom elements are created for widgets like `<ui-datepicker>` and for\nhigher-order components like `<acme-message-editor>`.  Higher-order components\noften assemble the behavior of multiple widget components.  Custom elements are created with [can-view-callbacks.tag] or [can-component].\n\nCustom attributes are typically used for mixins that can be\nadded to any element. Custom attributes are created with [can-view-callbacks.attr].\n\nThe main advantages of building applications based on custom HTML elements and attributes are:\n\n1. Ease of use - Designers can do it! Non-developers can express complex behavior with little to no JavaScript required. All you need to build a new page or feature is HTML.\n2. Application assembly clarity - Applications assembled with custom elements are easier to debug and\n   and understand the relationship between the user interface and the code powering it.\n\nLet’s explore these benefits more in the following sections:\n\n__Ease of use__\n\nBefore custom HTML elements existed, to add a date picker to your page, you would:\n\n1. Add a placeholder HTML element\n\n   ```html\n   <div class='datepicker' />\n   ```\n\n2. Add JavaScript code to instantiate your datepicker:\n\n   ```js\n   $('.datepicker').datepicker(task.dueDate)\n   ```\n\n3. Wire up the datepicker to update the rest of your application and vice-versa:\n\n   ```js\n   task.on(\"dueDate\", function(ev, dueDate){\n       $('.datepicker').datepicker(dueDate)\n   })\n\n   $('.datepicker').on(\"datechange\", function(ev, dueDate){\n       task.dueDate = dueDate;\n   });\n   ```\n\n\n\nWith custom HTML elements, to add the same datepicker, you would\nsimply add the datepicker to your HTML or template:\n\n```html\n<ui-datepicker value:bind=\"task.dueDate\"/>\n```\n\nThat might seem like a subtle difference, but it is actually a major step forward. The custom HTML element syntax allows for instantiation, configuration, and location, all happening at the same time.\n\nCustom HTML elements are one aspect of [Web Components](https://www.webcomponents.org/), a collection of browser specs that have [yet to be implemented](https://caniuse.com/#search=components) across browsers.\n\n__Application assembly clarity__\n\nCustom elements make it easier to tell how an application was assembled. This is because you\ncan inspect the DOM and see the custom elements and their bindings.  \n\nThe\nfollowing shows inspecting the [guides/todomvc]’s _“What needs to be done?”_ input element.  Notice how it’s easy to tell that its behavior is provided by the\n`<todo-create>` element.\n\n\n<img src=\"../../docs/can-guides/images/introduction/inspect.png\" style=\"width:100%;max-width:750px\" />\n\n\n### Data and Event Bindings\n\n[can-stache] includes Mustache data bindings that update the DOM when data changes.  For example,\nif the data passed to the following template changes, the DOM is automatically updated.\n\n```html\n<h1 class=\"{{#if user.admin}}admin{{/if}}\">Hello {{user.name}}</h1>\n```\n\nIn addition to the default Mustache data bindings, the [can-stache-bindings] module\nadds more powerful data and event bindings. These event bindings provide full control over how\ndata and control flows between the DOM, ViewModels, and the [can-view-scope]. Bindings look like:\n\n - `on:event=\"key()\"` for [can-stache-bindings.event event binding].\n - `prop:from=\"key\"` for [can-stache-bindings.toChild one-way binding to a child].\n - `prop:to=\"key\"` for [can-stache-bindings.toParent one-way binding to a parent].\n - `prop:bind=\"key\"` for [can-stache-bindings.twoWay two-way binding].\n\nTo two-way bind an `<input>` element’s `value` to a `todo.name` looks like:\n\n```html\n<input value:bind=\"todo.name\"/>\n```\n\nTo two-way bind a custom `<ui-datepicker>`’s `date` to a `todo.dueDate` looks like:\n\n```html\n<ui-datepicker date:bind=\"todo.dueDate\"/>\n```\n\nBy mixing and matching `$` and the different syntaxes, you have complete control over how\ndata flows.\n\n### Minimal DOM updates\n\nEveryone knows that updating the DOM is traditionally the slowest part of JavaScript\napplications.  CanJS uses two strategies for keeping DOM updates to a minimum:\nobservation and data diffing.\n\nTo understand how these strategies are used, consider a template like:\n\n```html\n<ul>\n{{#each completeTodos() }}\n\t<div>{{name}}</div>\n{{/each}}\n</ul>\n```\n\nAnd rendered with `viewModel` like:\n\n```js\nvar ViewModel = DefineMap.extend({\n    tasks: Todo.List,\n    completeTodos: function(){\n        return this.tasks.filter({complete: false});\n    }\n});\n\nvar viewModel = new ViewModel({\n    tasks: new Todo.List([\n        {name: \"dishes\", complete: true},\n        {name: \"lawn\", complete: false}\n    ])\n})\n```\n\n__Observation__\n\nCanJS directly observes what’s happening in each magic tag\nlike `{{name}}` so it can localize changes as much as possible. This means\nthat when the first todo’s name is changed like:\n\n```js\nviewModel.tasks[0].name = \"Do the dishes\"\n```\n\nThis change will be observed, and a textNode in the div will simply\nbe updated with the new `name`.  There’s no diffing on the whole template.  A\nchange happens and we know directly what is impacted.\n\n__Data diffing__\n\nThe [can-stache.helpers.each {{#each}} helper] provides data diffing.  It is able\nto do a difference between two arrays and calculate a minimal set of mutations to\nmake one array match another.  This means that if a new task is added to the\nlist of `tasks` like:\n\n```js\nviewModel.tasks.push({name: \"Understand diffing\", complete: true})\n```\n\nThis change will be observed, and a new array will be returned from\n`completeTodos()`.  The `#each` helper will [can-util/js/diff/diff] this new array to the\noriginal array, and only create a single new `<div>` for the new todo.  \n\n\n### Template minification\n\nWhile templates provide obvious benefits to application maintainability, they can be a\nchore to correctly integrate into the build tool chain. The [steal-stache] library provides an easy hook to load [can-stache] templates using [StealJS](https://stealjs.com) and include the compiled templates into the minified result of the build.\n\n[steal-stache] returns a renderer function that will render the template into a document fragment.\n\n```js\nimport todosStache from \"todos.stache\"\ntodosStache([{name: \"dishes\"}]) //-> <documentFragment>\n```\n\nWhen the build is run, this import statement will tell StealJS that \"todos.stache\" is a dependency, and will include an already parsed representation in the build result.\n\n### In-template dependency declarations\n\n[can-view-import](../../can-view-import.html) allows templates to import their dependencies like\nother modules. You can import custom elements, helpers, and other modules straight from a template module like:\n\n```html\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\n### Progressive Loading\n\nA template may load or conditionally load a module after the initial page load. `<can-import>` allows progressive loading by using an end tag.\n\nThis feature, when used with [steal-stache](../../steal-stache.html), signals to the build that the enclosed section’s dependencies should be dynamically loaded at runtime.\n\n```html\n{{#eq location 'home'}}\n<can-import from=\"components/home\">\n  <my-home/>\n</can-import>\n{{/eq}}\n{{#eq location 'away'}}\n<can-import from=\"components/chat\">\n  <my-chat/>\n</can-import>\n{{/eq}}\n```\n\n## Malleable Models\n\nCanJS’s models are primarily responsible for defining your data’s schema and communicating with a server to read and write data.\n\nIn addition to CRUD and real-time capabilities, [can-set] and [can-connect] provide lots of great features out-of-the-box:\n\n- [Memory-safe instance store](#Memory_safeinstancestore)\n- [Real-time list updates](#Real_timelistupdates)\n- [Parameter awareness](#Parameterawareness)\n- [Caching and minimal data requests](#Cachingandminimaldatarequests)\n- [Related-data features](#Related_datafeatures)\n\nWe’ll cover each of these in the sections below.\n\n### Separation of concerns\n\nCanJS separates your model layer into two parts:\n\n1) Communicating with a server.\n2) Managing your data’s schema.\n\nSeparating these two concerns means your model data isn’t tied to how you communicate with your API. Your project may start with a RESTful API for CRUD operations but end up with a real-time WebSocket API, and with CanJS, that change doesn’t affect how your data is modeled.\n\nAdditionally, with our mixin-based approach, you can easily add behaviors to both parts separately. Want to add [can-connect/data/localstorage-cache/localstorage-cache Local Storage] caching? It’s a one-line add-on. How about a behavior to [can-connect/data/combine-requests/combine-requests efficiently combine network requests]? One line too! Need something not provided by [can-connect]? Write and mix in your own custom behaviors.\n\nThis separation of concerns and powerful mixin behavior is accomplished by encapsulating the code required to connect to a service and encouraging typed definitions of your model data. For every “type” of data object in your project, you can create a model to represent the properties and methods attached to it. With this model in hand, you can structure how you communicate with your server. Different API calls can return the same type of data and have those represented as the same model objects.\n\nLet’s look at an example of how we would define a `Todo` type and a list of todos:\n\n```js\nvar DefineList = require(\"can-define/list/list\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Todo = DefineMap.extend({\n\tcomplete: \"boolean\",\n\tname: \"string\"\n});\n\nTodo.List = DefineList.extend({\n\t\"#\": Todo,\n\tcompleteCount: function(){\n\t\treturn this.filter({complete: true}).length;\n\t}\n})\n```\n\nThis example uses [can-define/map/map] to create a type definition for a `Todo`; each instance of `Todo` has a boolean `complete` property and a string `name` property.\n\nThis example also uses [can-define/list/list] to define a type for an array of `Todo` instances; the list has a `completeCount` method for easily determining how many todos in the list have been completed.\n\nUsing [can-connect], we’ll create a connection between a RESTful `/api/todos` service and our `Todo` instances and `TodoList` lists:\n\n```js\nvar connect = require(\"can-connect\");\nTodo.connection = connect([\n\trequire(\"can-connect/can/map/map\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/data/url/url\")\n], {\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList\n});\n```\n\nThat connection can be used to get a `Todo.List` of `Todo`s:\n\n```js\nTodo.getList({}).then(function(todos) {\n\t// Do what you’d like with the `todos`\n});\n```\n\n### Memory-safe instance store\n\nLet’s continue with our todo app example and imagine that we want to show two lists on a page: incomplete and urgent todos.\n\nFirst, let’s fetch the incomplete todos:\n\n```js\nTodo.getList({completed: false}).then(function(incompleteTodos) {});\n```\n\n`incompleteTodos` might look like this:\n\n    [\n      {id: 2, completed: false, name: \"Finish docs\", priority: \"high\"},\n      {id: 3, completed: false, name: \"Publish release\", priority: \"medium\"}\n    ]\n\nNext, let’s fetch a list of high-priority todos:\n\n```js\nTodo.getList({priority: \"high\"}).then(function(urgentTodos) {});\n```\n\n`urgentTodos` might look like this:\n\n    [\n      {id: 1, completed: true, name: \"Finish code\", priority: \"high\"},\n      {id: 2, completed: false, name: \"Finish docs\", priority: \"high\"}\n    ]\n\nNote that the “Finish docs” todo appears in both lists. If we make a change to the todo (e.g. changing its name), we want that change to appear in both lists.\n\n[can-connect]’s [can-connect/constructor/store/store.instanceStore instance store] keeps a reference to every model object by `id` (but you can [can-set.props.id change] which property is used). It does two things:\n\n1. Prevents duplicate instances of a model object from being created.\n2. Cleans up unused instances to release memory when they’re no longer referenced.\n\nLet’s look at both of these points in more detail.\n\n#### Duplicate instances\n\nThe instance store prevents duplicate instances from being created by storing each model object by its [can-set.props.id id]. When a model object is fetched from the server, CanJS checks its `id` to see if it’s already in the instance store; if it is, then CanJS will reuse the same object.\n\nIn our example, CanJS puts the “Finish docs” todo in the instance store when `incompleteTodos` is fetched. When `urgentTodos` is retrieved, CanJS sees the “Finish docs” todo with the same `id`, so it reuses the instance of “Finish docs” that is already in the instance store.\n\nIf these todos are displayed in separate lists on the page, and a user marks “Finish docs” as completed in one of the lists (causing the `completed` property to be set to `true`), then the other list will reflect this change.\n\n#### Prevent memory leaks\n\nA global instance store _sounds_ great until you consider the memory implications: if every model object instance is tracked, then won’t the application’s memory usage only grow over time?\n\nCanJS solves this potential problem by keeping track of which objects are observing changes to your model object instances.\n\nThe reference count for each object increases in two ways:\n\n- __Explicitly:__ if you use [can-connect/constructor/store/store.addInstanceReference] or call `.on()` on an instance (e.g. `todo.on('name', function(){})`)\n\n- __Implicitly:__ if properties of the instance are bound to via live-binding in a view, e.g. `Name: {{name}}` in a [can-stache] template\n\nSimilarly, the reference count is decreased in two ways:\n\n- __Explicitly:__ if you use [can-connect/constructor/store/store.deleteInstanceReference] or call `.off()` on an instance\n\n- __Implicitly:__ if part of the DOM connected to a live-binding gets removed\n\nWhen the reference count for a model object instance gets back down to 0 (no more references), the instance is removed from the store so its memory can be garbage collected.\n\nThe result is that in long-running applications that stream large amounts of data, this store will not cause memory to increase unnecessarily over time.\n\nYou can read more about the benefits of the instance store in our [“Avoid the Zombie Apocalypse” blog post](https://www.bitovi.com/blog/avoid-the-zombie-apocalypse).\n\n### Real-time list updates\n\nCanJS also automatically inserts, removes, and replaces objects within lists.\n\nLet’s continue with our incomplete and urgent todo example from the previous section.\n\n`incompleteTodos` looks like this:\n\n    [\n      {id: 2, completed: false, name: \"Finish docs\", priority: \"high\"},\n      {id: 3, completed: false, name: \"Publish release\", priority: \"medium\"}\n    ]\n\n`urgentTodos` looks like this:\n\n    [\n      {id: 1, completed: true, name: \"Finish code\", priority: \"high\"},\n      {id: 2, completed: false, name: \"Finish docs\", priority: \"high\"}\n    ]\n\nIn the UI, there’s a checkbox next to each urgent todo that toggles the `completed` property:\n\n```js\ntodo.completed = !todo.completed;\ntodo.save();\n```\n\nWhen the user clicks the checkbox for the “Finish docs” todo, its `completed` property is set to `true` and it disappears from the `incompleteTodos` list when [can-connect/can/map/map.prototype.save .save()] is called.\n\nThis is made possible by two things:\n\n- The [can-connect/constructor/store/store.listStore list store] contains all of the lists loaded from the server. It’s memory safe so it won’t leak.\n\n- [can-set] understands what your parameters mean so it can insert, remove, and replace objects within your lists. This is discussed in the following _\"Parameter awareness\"_ section.\n\nCanJS’s real-time list updates work great with \"push notification\" systems like [socket.io](https://socket.io/) and SignalR.  To add realtime behavior to a CanJS app, you\njust have to call the [can-connect/real-time/real-time.createInstance],\n[can-connect/real-time/real-time.updateInstance] and [can-connect/real-time/real-time.destroyInstance]\nwhen updates happen similar to the following:\n\n```js\nvar socket = io('https://example.com');\n\nsocket.on('todo created', function(todo){\n    Todo.connection.createInstance(todo)\n});\nsocket.on('todo updated', function(todo){\n    Todo.connection.updateInstance(todo)\n});\nsocket.on('todo removed', function(todo){\n    Todo.connection.destroyInstance(todo)\n});\n```\n\n### Parameter awareness\n\nWhen you make a request for `incompleteTodos` like the one below:\n\n```js\nTodo.getList({completed: false}).then(function(incompleteTodos) {});\n```\n\nThe `{completed: false}` object is passed to the server as parameters and represents all incomplete todos. You can configure a connection with [can-set.Algebra] that understands these parameters.\n\nHere’s an example of [can-connect/base/base.algebra setting up the algebra] for the `Todo.connection`:\n\n```js\nvar connect = require(\"can-connect\");\nvar set = require(\"can-set\");\n\nTodo.algebra = new set.Algebra(\n\tset.props.boolean(\"completed\")\n);\n\nTodo.connection = connect([\n\trequire(\"can-connect/can/map/map\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/data/url/url\")\n], {\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: Todo.List,\n\talgebra: Todo.algebra\n});\n```\n<span line-highlight='4-6,16-16'></span>\nThe `{completed: false}` parameters are associated with `incompleteTodos` so `can-connect` knows that `incompleteTodos` should contain _any_ todo with a `false` `completed` property. By understanding what\nthe parameters used to request data mean, all sorts of interesting behaviors and performance optimizations\ncan happen, including:\n\n - Real-time updates as described in the previous section.\n - Fall-through caching, request caching, and combining requests behaviors as described in the\n following sections.\n\nParameter awareness is provided by [can-set].  Read more about the magic of `can-set` in its [can-set API docs].\n\n### Caching and minimal data requests\n\nUndoubtedly, the slowest part of any web application is communicating with the server. CanJS uses the following strategies to improve performance:\n\n* [can-connect/fall-through-cache/fall-through-cache Fall-through caching]: improve perceived performance by showing cached data first (while still fetching the latest data)\n* [can-connect/cache-requests/cache-requests Request caching]: reduce the number and size of server requests by intelligently using cached datasets\n* [can-connect/data/combine-requests/combine-requests Combining requests]: combine multiple requests to the same API into one request\n\n#### Fall-through caching\n\nTo increase perceived performance, `can-connect` includes a [can-connect/fall-through-cache/fall-through-cache fall-through cache] that first serves cached data from `localStorage` while simultaneously making the API request to get the latest data.\n\nThe major benefit of this technique is improved perceived performance: users will see content faster because it’s returned immediately from the cache. When the data hasn’t changed, the user doesn’t notice anything, but when it has, the magic of live-bindings automatically updates the data as soon as the API request finishes.\n\n#### Request caching\n\nIn some scenarios, an even more aggressive caching strategy is favorable. One example is fetching data that doesn’t change very often, or cached data that you can invalidate yourself. The [can-connect/cache-requests/cache-requests] behavior can reduce both the number of requests that are made and the size of those requests in these cases.\n\nIn the first scenario, where the data doesn’t change very often (and thus shouldn’t be fetched again during the lifetime of the application), no more requests to the API will be made for that same set of data. In the second scenario, you can choose to invalidate the cache yourself, so after the first API request the data is always cached until you clear it manually.\n\nAdditionally, the request logic is more aggressive in its attempts to find subsets of the data within the cache and to only make an API request for the subset NOT found in the cache. In other words, partial cache hits are supported.\n\n#### Combining requests\n\nCanJS collects requests that are made within [can-connect/data/combine-requests.time a millisecond] of each other and tries to combine them into a single request if they are for the same API.\n\nFor example, let’s say we’re loading a page that has two parts: a section with incomplete todos and a section that’s an archive of completed todos. The incomplete section is just a list of todos, while the archive section is broken up by month, so you want to split these sections into two different components.\n\nIn most other frameworks, you would probably decide to have some parent component fetch the list of all todos so you could pass different subsets to each component. This decreases the reusability and maintainability of the components, but it would result in just one network request instead of two.\n\nWith CanJS, you don’t have to choose between maintainability and performance. You can decide to have each component fetch its data independently and [can-connect] will intelligently combine the two requests into one.\n\nThis is made possible by the [can-set] algebra we discussed earlier. [can-connect] sees the outgoing requests, can determine that requests for `Todo.getList({completed: true, sort: 'completedDate'})` and `Todo.getList({completed: false, sort: 'priority'})` are equivalent to just one `Todo.getList({})` request, then make that single request and return the correct sorted data to each call.\n\nThis [can-connect/data/combine-requests/combine-requests configurable behavior] is extremely powerful because it abstracts network request complexity away from how you create and compose your application.\n\n### Related-data features\n\nCanJS makes dealing with document-based APIs easier by handling situations where the server might return either a reference to a value or the value itself.\n\nFor example, in a MongoDB setup, a request like `GET /api/todos/2` might return:\n\n```\n{\n  id: 2,\n  name: \"Finish docs\",\n  projectRef: 1\n}\n```\n\nBut a request like `GET /api/todos/2?$populate=projectRef` might return:\n\n```\n{\n  id: 2,\n  name: \"Finish docs\",\n  projectRef: {\n\tid: 1,\n\tname: \"Release\"\n  }\n}\n```\n\n[can-connect/can/ref/ref] handles this ambiguity by creating a [can-connect/can/ref/ref.Map.Ref Ref type] that is always populated by the `id` and can contain the full value if it’s been fetched.\n\nFor example, without populating the project data:\n\n```js\nTodo.get({id: 2}).then(function(todo){\n  todo.projectRef.id //-> 2\n});\n```\n\nWith populating the project data:\n\n```js\nTodo.get({id: 2, populate: \"projectRef\"}).then(function(todo){\n  todo.projectRef.id //-> 2\n});\n```\n\nThe values of other properties and methods on the [can-connect/can/ref/ref.Map.Ref Ref type] are determined by whether the reference was populated or the referenced item already exists in the [can-connect/constructor/store/store.instanceStore].\n\nFor example, `value`, which points to the referenced instance, will be populated if the reference was populated:\n\n```js\nTodo.get({id: 2, populate: \"projectRef\"}).then(function(todo){\n  todo.projectRef.value.name //-> “Release”\n});\n```\n\nOr, it can be lazy loaded if it’s used in a template. For example, with this template:\n\n```html\n{{#each todos as todo}}\n  Name: {{todo.name}}\n  Project: {{todo.projectRef.value.name}}\n{{/each}}\n```\n\nIf `todo.projectRef.value` hasn’t been loaded by some other means, CanJS will fetch it from the server so it can be displayed in the template. This is handled automatically without you having to write any additional code to fetch the project data.\n\nAdditionally, if multiple todos have the same project, only one request will be made to the server (if the data isn’t already cached), thanks to the [can-connect/data/combine-requests/combine-requests] behavior.\n\n## jQuery integration\n\nBy default, CanJS’s [can-core] works without jQuery.  However, the [can-jquery]\nmodule integrates jQuery’s and CanJS’s event system.  This allows you to listen to\njQuery custom events like `draginit` directly in [can-stache-bindings.event can-stache event bindings]\nor using [can-control].\n\n[This JS Bin](https://jsbin.com/yifopus/3/edit?html,css,js,output) lets a user drag an item\ninto a trashcan using custom jQuery drag/drop events.\n\n## Server Side Rendering\n\nCanJS applications can be rendered on the server by running the same code. This is known as [Isomorphic JavaScript](http://isomorphic.net/javascript) or [Universal JavaScript](https://medium.com/@mjackson/universal-javascript-4761051b7ae9).\n\nServer-side rendering (SSR) provides two main benefits over traditional single page apps: better page load performance and SEO support.\n\nCanJS makes it possible to load your application on the server. This is because CanJS works in a NodeJS context, on top of a virtual DOM.\n\nUsing [can-vdom](../can-vdom.html) and [can-zone](../can-zone.html), you can set up your own server side rendering system, such as [the one used in DoneJS](https://donejs.com/Apis.html#server-side-rendering-apis). For information on using SSR without setting anything up yourself, please check out the DoneJS [quick start](https://donejs.com/Guide.html) and [in depth](https://donejs.com/place-my-order.html) guides.\n\n",
    "description": "Learn about CanJS’s technical accomplishments. \n",
    "name": "guides/technical",
    "title": "Technical Highlights",
    "type": "page",
    "parent": "about",
    "order": 1,
    "outline": "2",
    "comment": " "
  },
  "migrate-3": {
    "src": {
      "path": "docs/can-guides/upgrade/migrating-to-canjs-3.md"
    },
    "body": "\nCanJS 3 introduces an even more modular project structure and several new features, while having a minimal number of deprecations and removals from the [2.3 API](//v2.canjs.com/docs/).\n\nUse this guide alone or with the [guides/upgrade/using-codemods] guide, which shows you how to use the [can-migrate](https://github.com/canjs/can-migrate) CLI code refactoring tool to automate parts of the migration process.\n\nThis guide goes over:\n\n* [*Pre-migration preparation*](#Pre_migrationpreparation) you can do in your current 2.x project to more easily move to 3.x in the future.\n* [The *minimal migration path*](#Minimalmigrationpath), which includes the fewest changes required to upgrade from 2.x to 3.x.\n* [The *modernized migration path*](#Modernizedmigrationpath), which includes upgrading your code to match more modern conventions (such as using the new npm packages).\n* [The *latest & greatest migration path*](#Latest_greatestmigrationpath), which uses all of the modern libraries we are most excited about (such as [can-define]).\n* [How to *avoid future deprecations & removals*](#Avoidfuturedeprecations_removals) in releases after 3.x\n\n## Pre-migration preparation\n\nBefore upgrading your project from 2.x to 3.x, make sure your project builds successfully and all the tests pass.\n\nAdditionally, you can take the following steps in your CanJS 2.x app to prepare it for migrating to CanJS 3.\n\n### Use the module folders\n\nYou can start importing CanJS code in a modular way before moving to CanJS 3.\n\nFor example, you might be using [can-component] like this:\n\n```js\nvar can = require(\"can\");\n\ncan.Component.extend({ ... });\n```\n\nUpdate your code to instead look like this:\n\n```js\nvar Component = require(\"can/component/component\");\n\nComponent.extend({ ... });\n```\n\nUse the same pattern for the other modules you are using. Be careful when declaring names for imported modules that share a similar name to native objects like Map.\n\nInstead of:\n\n```js\nimport Map from 'can/map/map'; // this local declaration of Map will collide with ECMAScript2015 [Map](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Map)\n```\n\nWrite:\n\n```js\nimport CanMap from 'can/map/map';\n```\n\nHere’s a list of all the `can.` properties in CanJS 2.3 that can be replaced with modular paths:\n\n- `can.autorender` — `can/view/autorender/autorender`\n- `can.batch` — `can/event/batch/batch`\n- `can.bindings` — `can/view/bindings/bindings`\n- `can.Component` — `can/component/component`\n- `can.compute` — `can/compute/compute`\n- `can.Construct` — `can/construct/construct`\n- `can.Control` — `can/control/control`\n- `can.Deferred` — `can/util/deferred`\n- `can.define` — `can/map/define`\n- `can.deparam` — `can/util/string/deparam/deparam`\n- `can.ejs` — `can/view/ejs/ejs`\n- `can.event` — `can/event/event`\n- `can.fixture` — `can/util/fixture`\n- `can.isFunction` — `can/util/js/is-function/is-function`\n- `can.LazyMap` — `can/map/lazy/lazy`\n- `can.List` — `can/list/list`\n- `can.Map` — `can/map/map`\n- `can.Model` — `can/model/model`\n- `can.Model.Cached` — `can/model/cached/cached`\n- `can.mustache` — `can/view/mustache/mustache`\n- `can.Object` — `can/util/object/object`\n- `can.route` — `can/route/route`\n- `can.stache` — `can/view/stache/stache`\n- `can.util` — `can/util/util`\n- `can.view.callbacks` — `can/view/callbacks/callbacks`\n\n### Replace uses of `can.$`\n\n[`can.$`](//v2.canjs.com/docs/can.$.html) allows you to access the underlying DOM library bundled with CanJS; for example, jQuery in `can.jquery.js`.\n\nYou might be using it in your code to easily reference the library:\n\n```js\nvar can = require(\"can\");\nvar body = can.$('body');\n```\n\nUpdate your code to explicitly require the library on which you depend. For example:\n\n```js\nvar $ = require(\"jquery\");\nvar body = $('body');\n```\n\n### Set `leakScope` in components\n\nCanJS 2.2 introduced [can-component.prototype.leakScope leakScope: false] as a property on a [can-component]. This prevents values in parent templates from leaking into your component’s template. In CanJS 3, **leakScope** is now `false` by default.\n\nIf you have a template like:\n\n```html\n<some-component></some-component>\n```\n\nThat you render with a [can-map map] containing a `page` property like so:\n\n```js\nrender(new Map({\n\tpage: \"home\"\n}));\n```\n\nThis `page` property is not available within `some-component`’s own template.\n\nIf the component’s template looks like:\n\n```html\n<h1>Hello {{page}}</h1>\n```\n\nIt can only lookup the `page` property on `some-component`’s own [can-component.prototype.ViewModel]. To restore the behavior in 2.x, simply set [can-component.prototype.leakScope] to be `true` on the component:\n\n```js\nComponent.extend({\n\ttag: \"some-component\",\n\tViewModel: ...,\n\tleakScope: true\n});\n```\n<span line-highlight='4'></span>\n## Minimal migration path\n\nIf you are already using `can` through npm, simply run the following command to install the latest version:\n\n```\nnpm install can@3 --save\n```\n\nThis will update your `package.json` to look something like this:\n\n```js\n{\n  ...\n  \"dependencies\": {\n    \"can\": \"^<%canjs.package.version%>\"\n  }\n}\n```\n\nThe `^` ensures you get minor and patch releases as those are released.\n\nAt a minimum, to upgrade your code for CanJS 3, you must make all of the following changes to your code:\n\n### Use `can/legacy`\n\nIn your code where you normally would import `can`, instead import `can/legacy`:\n\n```js\nvar can = require(\"can/legacy\");\n```\n\nThis will give you a `can` object with *most* of the same APIs as in 2.3, with a few exceptions:\n\n* [can.mustache](v2.canjs.com/docs/can.mustache.html) is not included with `can/legacy`, but it can still be installed as a [separate package](https://www.npmjs.com/package/can-mustache).\n* The former `can.view` functionality no longer exists; see below for more details.\n\n### Asynchronous `inserted` & `removed` events\n\nIn your [can-component]s, the [can-util/dom/events/inserted/inserted inserted] and [can-util/dom/events/removed/removed] events were previously fired synchronously as the element was inserted or removed from the DOM. To improve performance, these events are now fired asynchronously.\n\nThere is now a [can-component/beforeremove] event that fires synchronously in case you need to perform memory cleanup. For example, you might need to access the parent’s viewModel:\n\n```js\nComponent.extend({\n\ttag: \"my-panel\",\n\n\tevents: {\n\t\t\"{element} beforeremove\": function(){\n\t\t\tcanViewModel(this.element.parentNode).removePanel(this.viewModel);\n\t\t}\n\t}\n}\n```\n\n### Replace uses of `can.view`\n\nThe `can.view` methods have been removed in CanJS 3. The most common use was to create a template renderer from a script element within the page.\n\nInstead of:\n\n```js\nvar render = can.view('some-id');\n```\n\nJust use the DOM APIs and pass the string directly into [can-stache]:\n\n```js\nvar templateString = document.getElementById('some-id').innerHTML;\nvar render = stache(templateString);\n```\n\nIf you were using `can.view` to load a template from a URL like so:\n\n```js\nvar render = can.view('./template.stache');\n```\n\nWe encourage you to use [StealJS](https://stealjs.com/) with [steal-stache](#Usingsteal_stachefortemplates):\n\n```js\nimport render from \"./template.stache\";\n```\n\nAlternatively, use the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API):\n\n```js\nfetch(\"./todos.stache\")\n\t.then((resp) => stache(resp.text()))\n\t.then((render) => /* use render */);\n```\n\nIf you’re using another module loader (such as Browserify or webpack), check out [guides/setup] for instructions on how to load templates.\n\n#### `can.view.preload`\n\nIf you were using `can.view.preload` then use [can-stache.registerPartial] instead.\n\n```js\nstache.registerPartial(\"some-id\", renderer);\n```\n\n### Replace uses of `can.Construct.proxy`\n\n The `can.Construct.proxy` method has been removed in favor of [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n\n Instead of:\n\n ```js\n this.proxy(randFunc)\n ```\n\n You should now do this:\n\n ```js\n randFunc.bind(this)\n ```\n\n ### Replace uses of `can.batch`\n\n `can.batch` has been moved to the `can-event` module.\n\n Instead of:\n\n ```js\n can.batch.method();\n ```\n\nYou should now do this:\n\n```js\nimport canBatch from 'can-event/batch/batch';\ncanBatch.method();\n```\n\nThe `trigger` method has also been renamed to `dispatch`.\n\n ```js\n can.batch.trigger(myObj, 'myEvent');\n ```\n\n Becomes:\n\n ```js\n canBatch.dispatch(myObj, 'myEvent');\n ```\n\n ### Replace uses of `can.isFunction`\n\n `can.isFunction` has been moved to the `can-util` module.\n\n Instead of:\n\n ```js\n can.isFunction(func);\n ```\n\n You should now do this:\n\n ```js\n import isFunction from 'can/util/js/is-function/is-function';\n isFunction(func);\n ```\n\n### `can.event`\n\nSome methods have been renamed in `can.event`.\n\n```js\ncan.event.addEvent.call(el, 'click', function() {});\ncan.event.removeEvent.call(el, 'click', function() {});\n```\n\nBecomes:\n\n```js\ncan.event.addEventListener.call(el, 'click', function() {});\ncan.event.removeEventListener.call(el, 'click', function() {});\n```\n\n### `can.extend`\n\nThis method has been split into two: a shallow and deep merge. Previously, passing `true` as the first parameter would do a deep merge. Now, you explicitly invoke the deep merge or shallow merge function.\n\n```js\ncan.extend({}, { answer: 42 }); // shallow\ncan.extend(true, {}, { answer: 42 }); // deep\n```\n\nBecomes:\n\n```js\nimport assign from 'can-util/js/assign/assign';\nimport deepAssign from 'can-util/js/deepAssign/deepAssign';\nassign({}, { answer: 42 }); // shallow\ndeepAssign({}, { answer: 42 }); // deep\n```\n\n### `can.addClass`\n\nThis method now requires the DOM element to be the context of function.\n\nReplace this:\n\n```js\ncan.addClass(el, 'myClass');\n```\n\nWith this:\n\n```js\nimport className from 'can-util/dom/class-name/class-name';\nclassName.add.call(el, 'myClass');\n```\n\n### `can.append`\n\nThis method now require the DOM element to be the context of function.\n\nReplace this:\n\n```js\ncan.append(el, '<p></p>');\n```\n\nWith this:\n\n```js\nimport mutate from 'can-util/dom/mutate/mutate';\nmutate.append.call(el, '<p></p>');\n```\n\n### `can.data`\n\nThis method now requires the DOM element to be the context of function. It also has a separate method for getting and setting data.\n\nReplace this:\n\n```js\ncan.data(el, 'something', 'secret'); // set\ncan.data(el, 'something'); // get\n```\n\nWith this:\n\n```js\nimport domData from 'can-util/dom/data/data';\ndomData.set.call(el, 'something', 'secret');\ndomData.get.call(el, 'something');\n```\n\n### String methods\n\nAll string methods are grouped together now, so you only have to import the string utilities once.\n\n```js\ncan.camelize('first-name');\ncan.hyphenate('firstName');\n```\n\nBecomes:\n\n```js\nimport string from 'can-util/js/string/string';\n\nstring.camelize('first-name');\nstring.hyphenate('firstName');\n```\n\n### Use native Promises\n\nNative [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) are used instead of jQuery promises which means you need to:\n\n* Include a Promise polyfill if targeting browsers that do not have native support. [Steal](https://stealjs.com/) includes a polyfill for you.\n* Use `.catch()` instead of `.fail()`.\n* Use `.then()` instead of `.done()`.\n\nNote that only a single value is returned from a native Promise.\n\n### Passing the `this` value to a helper\n\n[can-stache] now passes a [can-compute] to [can-stache.Helpers helpers].\n\nIf you were passing the `this` value to a helper like so:\n\n```html\n{{helper .}}\n```\n\nYou can fix this either by having your helpers handle computes, or by using [can-stache/expressions/call call expressions] instead:\n\n```html\n{{helper(.)}}\n```\n\n### No more global scope names\n\nMost recently-built applications do not depend on adding to the global namespace, but in case you have code that does:\n\n```js\nConstruct.extend(\"foo.bar\", ...)\n```\n\nWhich sets `window.foo.bar`, this argument is no longer accepted by [can-construct]. If you *really* need to set a global, you can do so yourself using the return value of [can-construct.extend].\n\nInstead, the first argument to [can-construct.extend] is the name of the constructor function. This is nice for development as you’ll get named objects in your dev tools.\n\n<a id=\"Usingsteal_stachefortemplates\"></a>\n\n### Using `steal-stache` for templates\n\nIf you use StealJS, you’ll need to install [steal-stache] to load your templates:\n\n```\nnpm install steal-stache@3 --save\n```\n\nIf you’re using StealJS 0.16, you don’t need to do anything else to make your templates load correctly.\n\nIf you’re using StealJS 1, you also need to add `steal-stache` to the `plugins` configuration in your `package.json`:\n\n```json\n{\n  ...\n  \"steal\": {\n    ...\n    \"plugins\": [\"steal-stache\"]\n  }\n}\n```\n\n### Replace `template` with `view` in components\n\nThe `template` property name has been deprecated in favor of `view`.\n\nInstead of:\n\n```js\nimport template from \"./todo.stache\";\nComponent.extend({\n\ttag: \"some-component\",\n\ttemplate: template\n});\n```\n<span line-highlight='4'></span>\nYou should write:\n\n```js\nimport view from \"./todo.stache\";\nComponent.extend({\n\ttag: \"some-component\",\n\tview: view\n});\n```\n<span line-highlight='4'></span>\n## Modernized migration path\n\nCanJS 3 is divided into separate npm packages. This allows us to more quickly update parts of CanJS without affecting other functionality.\n\nIn addition to the above, take advantage of the individual packages by installing and using them directly to set your project up for easier upgrades in the future.\n\nFor example, you might be using [can-component] like either:\n\n```js\nvar can = require(\"can\");\n\ncan.Component.extend({ ... });\n```\n\nor\n\n```js\nvar Component = require(\"can/component/component\");\n\nComponent.extend({ ... });\n```\n\nRegardless of which you are using, update your code to instead look like:\n\n```js\nvar Component = require(\"can-component\");\n\nComponent.extend({ ... });\n```\n\nUse the same pattern for the other `can` modules you are using. In general, you should not be using the `can.` properties any more, but rather importing (through your module loader / bundler) only the packages and modules that you are using.\n\nHere’s a list of all the paths in CanJS 2.3 that now have separate modules in CanJS 3:\n\n- `can/component/component` — [can-component]\n- `can/compute/compute` — [can-compute]\n- `can/construct/construct` — [can-construct]\n- `can/construct/super` — [can-construct-super]\n- `can/control/control` — [can-control]\n- `can/event/event` — [can-event]\n- `can/list/list` — [can-list]\n- `can/map/backup` — [can-map-backup]\n- `can/map/define` — [can-map-define]\n- `can/map/map` — [can-map]\n- `can/model/model` — [can-model](https://github.com/canjs/can-model)\n- `can/route/pushstate/pushstate` — [can-route-pushstate]\n- `can/route/route` — [can-route]\n- `can/util/fixture` — [can-fixture]\n- `can/util/string/deparam/deparam` — [can-deparam]\n- `can/util/util` — [can-util]\n- `can/view/autorender/autorender` — [can-view-autorender]\n- `can/view/callbacks/callbacks` — [can-view-callbacks]\n- `can/view/ejs/ejs` — [can-ejs]\n- `can/view/href/href` — [can-view-href]\n- `can/view/import/import` — [can-view-import]\n- `can/view/live/live` — [can-view-live]\n- `can/view/mustache/mustache` — [can-mustache](https://github.com/canjs/can-mustache)\n- `can/view/node_lists/node_lists` — [can-view-nodelist]\n- `can/view/parser/parser` — [can-view-parser]\n- `can/view/scope/scope` — [can-view-scope]\n- `can/view/stache/stache` — [can-stache]\n- `can/view/target/target` — [can-view-target]\n\n<a id=\"Future_proofmigrationpath\"></a>\n## Latest & greatest migration path\n\nIn addition to the steps taken in the two sections above, make the following changes to your application if you *really* want to stay ahead of the curve.\n\n### Move from `can-map` to `can-define`\n\nIf you’ve used [can-map-define] in the past, then using [can-define] should be familiar to you. Using [can-define/map/map] is the easiest migration path and is what we show in all of the examples in CanJS 3’s docs.\n\nA typical map looks like:\n\n```js\nvar Map = require(\"can-map\");\nrequire(\"can-map-define\");\n\nvar CarOwner = Map.extend({\n\tdefine: {\n\t\tcars: {\n\t\t\tType: Car.List\n\t\t},\n\t\tfavorite: {\n\t\t\tType: Car\n\t\t},\n\t\tcolor: {\n\t\t\ttype: \"string\"\n\t\t},\n\t\tage: {\n\t\t\tvalue: 18\n\t\t}\n\t}\n});\n```\n\nWhich can be replaced by flattening it into a [can-define/map/map] like so:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar CarOwner = DefineMap.extend({\n\tcars: Car.List,\n\tfavorite: Car,\n\tcolor: \"string\",\n\tage: {\n\t\ttype: \"number\",\n\t\tvalue: 18\n\t}\n});\n```\n\nUsing [can-define] allows you to use maps without the [can-map.prototype.attr .attr()] method that’s needed in [can-map] and [can-list]. To use this with `DefineMap`, just use the `.` (dot) operator instead:\n\n```js\nvar carOwner = new CarOwner();\n\n// This is observable!\ncarOwner.favorite = new Car({ make: \"Toyota\" });\n```\n\n**Note:** With `can-map` you are able to assign initial values to a property while defining a `Map` like so:\n\n```js\nvar CanMap = require(\"can-map\");\n\nvar Person = CanMap.extend({\n  name: \"Justin\"\n});\n```\n\nThis shorthand in `can-define/map/map` defines the [can-define.types type], not the initial value.\n\nHere’s the example above updated for `can-define/map/map`:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Person = DefineMap.extend({\n  name: {value: \"Justin\"}\n});\n```\n\n#### Remove use of `change` events\n\nWhen you upgrade to use [can-define], you’ll no longer receive `change` events on maps. If you had any code that binded to a map’s `change` event, you’ll want to instead bind to the properties that you are interested in.\n\nFor example:\n\n```js\nroute.bind(\"change\", function(){\n\t// The route changed\n});\n```\n\nCan be modified to instead use a compute that calls `serialize` on the route’s map:\n\n```js\nvar routeMap = compute(function(){\n\treturn route.map.serialize();\n});\n\nrouteMap.bind(\"change\", function(){\n\t// A property on the route’s map changed.\n});\n```\n\nAs you might notice, [can-event.on on()] is preferable to `bind()`, although `bind()` still works the same.\n\n### Use `can-connect` directly\n\nWhen using the easy migration path, you were secretly using [can-connect/can/model/model], a constructor that is mostly backwards-compatible with [can-model](//v2.canjs.com/docs/can.Model.html).\n\nMost new projects should use [can-connect] directly. [can-connect/can/super-map/super-map] is the easiest way to create models with `can-connect`’s features. Using `can-connect` directly allows you to use [can-define/map/map]s as your models like so:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\nvar superMap = require(\"can-connect/can/super-map/super-map\");\n\nvar Message = DefineMap.extend({\n\tid: \"*\"\n});\n\nMessage.List = DefineList.extend({\n\t\"#\": Message\n});\n\nvar messageConnection = superMap({\n\turl: 'https://chat.donejs.com/api/messages',\n\tidProp: 'id',\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n```\n\n## Avoid future deprecations & removals\n\n### Wrap elements in jQuery objects\n\nIf you are using [can-jquery/legacy] to automatically get jQuery-wrapped elements in [can-control] event handlers, you’ll want to remove the usage of [can-jquery/legacy] as it doesn’t play well with [can-component]s that do not expect elements to be jQuery-wrapped.\n\nInstead, use [can-jquery] directly and handle the wrapping yourself. For example:\n\n```js\nvar Component = require(\"can-component\");\nvar $ = require(\"can-jquery\");\n\nComponent.extend({\n\ttag: \"some-component\",\n\n\tevents: {\n\t\tinserted: function(){\n\t\t\tthis.element = $(this.element);\n\t\t},\n\t\t\"li click\": function(li){\n\t\t\tvar $li = $(li);\n\t\t}\n\t}\n});\n```\n\n[can-jquery] will continue to be supported indefinitely but [can-jquery/legacy] will be dropped in a future major version.\n\n### Use the new binding syntax\n\nCanJS 2.3 introduced new binding syntaxes. They’re available in CanJS 3 with [can-stache-bindings]. Although the old binding syntaxes still work, they will likely be dropped in 4.0. View [can-stache-bindings]’s documentation to learn how to use the new binding syntax.\n\nAn example is changing a `can-value` binding from:\n\n```html\n<input type=\"text\" can-value=\"{someProp}\" />\n```\n\nTo:\n\n```html\n<input type=\"text\" value:bind=\"someProp\" />\n```\n\nCanJS 3 also introduces new [can-stache.registerConverter stache converters], which are special two-way [can-stache.Helpers helpers] that update an element when an observable value changes and update the observable value when the form element’s value changes (from user input).\n\nAn example is the [can-stache-converters.string-to-any] converter, which converts a primitive value to a string to set a `<select>`’s value, and then converts the `<select>` value when a user selects an `<option>` back to the primitive value to update the scope value:\n\n```html\n<select value:bind=\"string-to-any(~favePlayer)\">\n\t<option value=\"23\">Michael Jordan</option>\n\t<option value=\"32\">Magic Johnson</option>\n</select>\n```\n\n",
    "description": "This guide walks you through the step-by-step process to upgrade a 2.x app to CanJS 3. \n",
    "name": "migrate-3",
    "title": "Migrating to CanJS 3",
    "type": "page",
    "parent": "guides/upgrade",
    "order": 0,
    "templateRender": [
      "<%",
      "%>"
    ],
    "outline": "0",
    "comment": " "
  },
  "guides/upgrade/using-codemods": {
    "src": {
      "path": "docs/can-guides/upgrade/using-codemods.md"
    },
    "body": "\n## Overview\n\nA codemod is a transformation script that parses the [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree)\nof source code in order to do a code-aware find-and-replace refactor across\nmultiple files. [can-migrate](https://www.npmjs.com/package/can-migrate)\nis a CLI utility for running codemods that can help migrate your app to CanJS 3.\n\nFor example, the following CanJS 2.3 code:\n\n```js\nimport can from \"can\";\nimport \"can/map/define/define\";\n\nexport default can.Map.extend({\n  define: {}\n});\n```\n\n…can be transformed to this:\n\n```js\nimport CanMap from \"can-map\";\nimport can from \"can\";\nimport \"can-map-define\";\n\nexport default CanMap.extend({\n  define: {}\n});\n```\n<span line-highlight='1,3,5'></span>\nUsing this CLI will get you about 85% of the way to having your codebase\nmigrated; it’s not a complete solution for a seamless migration, but it will get\nyou significantly closer than doing the migration by hand.\n\n## Install\n\nInstall `can-migrate` from npm:\n\n```shell\nnpm install -g can-migrate\n```\n\nThis will make the `can-migrate` command available globally.\n\n## Usage\n\nThe CLI provides the following options:\n\n```\ncan-migrate [<files> OPTIONS...]\n\nUpdates files according to the CanJS 3 migration paths (minimal, modern, latest & greatest)\n\nOptions\n--apply     -a    Apply transforms (instead of a dry run)\n--force           Apply transforms regardless of git status\n--silent    -s    Silence output\n--config    -c    Path to custom config file\n--transform -t    Specify a transform\n```\n\n### Example\n\nRuns all the default `can-migrate` transforms on the files that match the `**/*.js` glob:\n\n```bash\ncan-migrate --apply **/*.js\n```\n\nRuns the `can-component-rename` transform on the files that match the `**/*.js` glob:\n\n```bash\ncan-migrate --apply **/*.js --transform can-component-rename/can-component-rename.js\n```\n\nYou can find a [complete list of transforms on GitHub](https://github.com/canjs/can-migrate/tree/master/src/transforms).\n\n## Recommended Migration Process\n\nUse the following steps as a guide for using this tool:\n\n1. Make a new branch for the migration:\n    ```shell\n    git checkout -b migration\n    ```\n2. Ensure all tests are passing and your git state is clean.\n  As with any migration, if your code is not tested, the amount of time it takes for a successful migration is exponentially greater.\n3. Run the transforms on each [modlet](https://www.bitovi.com/blog/modlet-workflows) or standalone testable component:\n    ```bash\n    can-migrate [<modlet/*.js>] --apply\n    ```\n    Alternatively, you can run one transform at a time for a more incremental approach:\n    ```bash\n    can-migrate [<modlet/*.js>] --transforms <transform path> --apply\n    ```\n4. Install the [api#ThecanPackage can-* modules] used in that modlet or component. Here are the modules in the [can-core] collection:\n    ```shell\n    npm i can-component --save\n    npm i can-compute --save\n    npm i can-connect --save\n    npm i can-define --save\n    npm i can-route --save\n    npm i can-route-pushstate --save\n    npm i can-set --save\n    npm i can-stache --save\n    npm i can-stache-bindings --save\n    ```\n\n5. Run the tests again and fix the bugs as they come up.\n  Review [migrate-3] to understand what changes to expect\n6. Commit the module once all tests are passing again.\n7. Repeat 2-6 until all modlet or components are migrated and tests are passing.\n\n**Note:** If you are using [StealJS](https://stealjs.com/), ensure you are running StealJS 0.16 or greater.\n\n## Introduction to the Transform Scripts\n\nRead this section to understand how the transforms (also called codemods) are organized,\nthe different types of transformations that are included with `can-migrate`,\nand what to expect from each one.\n\nThere are 3 main types of transforms included in the `can-migrate` tool:\nreplace, import, and require. There are also three module-specific transforms\nthat handle more complex transformations: `can-component-rename`, `can-data`,\nand `can-extend`.\n\nEach can-module that has a transform script has a folder in the\n[src/transforms directory](https://github.com/canjs/can-migrate/tree/master/src/transforms).\nMost of these folders have the following structure:\n\n`can-moduleName/`\n- `import.js`\n- `replace.js`\n- `require.js`\n\nYou can run a specific transform by passing `can-moduleName/replace.js` or you can pass the entire `can-moduleName/` directory to the CLI tool with the `--transform` flag.\n\nRun all the transforms in the directory:\n\n```bash\ncan-migrate */*.js --apply --transform can-moduleName/\n```\n\nRun a specific transform script:\n\n```bash\ncan-migrate */*.js --apply --transform can-moduleName/replace.js\n```\n\n### “Import” Transforms\n\nThese transforms change the way a module is imported if it using the `import` syntax.\n\nFor example, it will transform any of the following:\n\n```js\nimport Component from \"can/component/\";\nimport Component from \"can/component/component\";\nimport Component from \"can/component/component.js\";\n```\n\n…to this:\n\n```js\nimport Component from \"can-component\";\n```\n<span line-highlight='1'></span>\n### “Replace” Transforms\n\nThese transforms replace how a module is imported and used, which may vary by\nmodule. You can learn how each module is transformed by a particular script in\nthe specific transformation section below.\n\nFor example, it can transform code like this:\n\n```js\nimport can from \"can\";\ncan.addClass(el, \"myClass\");\n```\n\n…to this:\n\n```js\nimport className from \"can-util/dom/class-name/class-name\";\nimport can from \"can\";\nclassName.addClass.call(el, \"myClass\");\n```\n<span line-highlight='1,3'></span>\n### “Require” Transforms\n\nThese transforms handle the cases where a module is loaded using `require`.\n\nFor example, it will transform any of the following:\n\n```js\nconst Component = require(\"can/component/\");\nconst Component = require(\"can/component/component\");\nconst Component = require(\"can/component/component.js\");\n```\n\n…to this:\n\n```js\nconst Component = require(\"can-component\");\n```\n<span line-highlight='1'></span>\n### Custom Transforms\n\nWhile the replace, import, and require transforms handle most cases, there are\nsome more specific scripts for `can-component-rename`, `can-data`, `can-extend`.\nRead about them in the section below.\n\n## Complete List of Transform Scripts\n\nThis section details all the transformation scripts with examples of before and after.\n\n### can-stache-bindings/colon-bindings\n\nRunning [the colon-bindings transform](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-stache-bindings):\n\n```bash\ncan-migrate -a src/**/*.{js,md,html,stache,component} -t can-stache-bindings/colon-bindings\n```\n\n…will transform this:\n\n```html\n<input {^$value}=\"H1\" {$value}=\"H2\" {($value)}=\"H3\" ($value)=\"H4\"\n  {^value}=\"H1\" {value}=\"H2\" {(value)}=\"H3\" (value)=\"H4\">\n```\n\n…to this:\n\n```html\n<input el:value:to=\"H1\" el:value:from=\"H2\" el:value:bind=\"H3\" on:el:value=\"H4\"\n  vm:value:to=\"H1\" vm:value:from=\"H2\" vm:value:bind=\"H3\" on:vm:value=\"H4\">\n```\n\n…or this:\n\n```js\nComponent.extend({\n  tag: 'my-tag',\n  template: stache(\n    '<input {^$value}=\"H1\" {$value}=\"H2\" {($value)}=\"H3\" ($value)=\"H4\" ' +\n\t\t'{^value}=\"H1\" {value}=\"H2\" {(value)}=\"H3\" (value)=\"H4\">'\n  )\n});\n```\n\n…to this:\n\n```js\nComponent.extend({\n  tag: 'my-tag',\n  template: stache(\n    '<input el:value:to=\"H1\" el:value:from=\"H2\" el:value:bind=\"H3\" on:el:value=\"H4\" ' +\n\t\t'vm:value:to=\"H1\" vm:value:from=\"H2\" vm:value:bind=\"H3\" on:vm:value=\"H4\">'\n  )\n});\n```\n<span line-highlight='4,5'></span>\nIt will also transform stache bindings inside:\n\n* ```` ```html ```` and ```` ```js ```` blocks in `.md` files\n* `<view>`, `<template>`, `<view-model>`, and `<script type=\"view-model\">` blocks in `.component` files\n* `<script type=\"text/stache\">` and `<script src=\"...steal/steal.js\">` blocks in `.html` files\n\nWith the `--implicit` flag, the transform will intuitively determine whether to bind to the ViewModel or Element without the explicit `vm:` or `el:` specifiers. For example, running this:\n\n```bash\ncan-migrate -a src/**/*.{js,md,html,stache,component} -t can-stache-bindings/colon-bindings --implicit\n```\n\n…will transform this:\n\n```html\n<input {^$value}=\"H1\" {$value}=\"H2\" {($value)}=\"H3\" ($value)=\"H4\"\n  {^value}=\"H1\" {value}=\"H2\" {(value)}=\"H3\" (value)=\"H4\">\n```\n\n…to this:\n\n```html\n<input value:to=\"H1\" value:from=\"H2\" value:bind=\"H3\" on:value=\"H4\"\n  value:to=\"H1\" value:from=\"H2\" value:bind=\"H3\" on:value=\"H4\">\n```\n<span line-highlight='1,2'></span>\n### can-component-rename\n\nRunning [all of the can-component-rename transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-component-rename):\n\n```bash\ncan-migrate -a **/*.js -t can-component-rename/\n```\n\n…will transform this:\n\n```js\nComponent.extend({\n  tag: \"my-tag\",\n  template: \"Hi\",\n  events: {\n    removed: function(){}\n  }\n});\n```\n<span line-highlight='3,5'></span>\n…to this:\n\n```js\nComponent.extend({\n  tag: \"my-tag\",\n  view: \"Hi\",\n  events: {\n    \"{element} beforeremove\": function(){}\n  }\n});\n```\n<span line-highlight='3,5'></span>\n…or this:\n\n```js\ncan.Component.extend({\n  tag: \"my-tag\",\n  template: \"Hi\",\n  events: {\n    removed(){}\n  }\n});\n```\n<span line-highlight='3,5'></span>\n…to this:\n\n```js\ncan.Component.extend({\n  tag: \"my-tag\",\n  view: \"Hi\",\n  events: {\n    \"{element} beforeremove\"(){}\n  }\n});\n```\n<span line-highlight='3,5'></span>\n…or this:\n\n```js\nComponent.extend({\n  tag: \"my-tag\",\n  events: {\n    \"removed\": () => {}\n  }\n});\n```\n<span line-highlight='4'></span>\n…to this:\n\n```js\nComponent.extend({\n  tag: \"my-tag\",\n  events: {\n    \"{element} beforeremove\": () => {}\n  }\n});\n```\n<span line-highlight='4'></span>\n### can-data\n\nRunning [all of the can-data transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-data):\n\n```bash\ncan-migrate -a **/*.js -t can-data/\n```\n\n…will transform this:\n\n```js\nimport can from \"can\";\n\ncan.data(el, \"name\", \"Luke\");\ncan.data(el, \"name\");\n```\n<span line-highlight='3,4'></span>\n…to this:\n\n```js\nimport domData from \"can-util/dom/data/data\";\nimport can from \"can\";\n\ndomData.set.call(el, \"name\", \"Luke\");\ndomData.get.call(el, \"name\");\n```\n<span line-highlight='1,4,5'></span>\n…or this:\n\n```js\nconst can = require(\"can\");\n\ncan.data(el, \"name\", \"Luke\");\ncan.data(el, \"name\");\n```\n<span line-highlight='3,4'></span>\n…to this:\n\n```js\nconst domData = require(\"can-util/dom/data/data\");\nconst can = require(\"can\");\n\ndomData.set.call(el, \"name\", \"Luke\");\ndomData.get.call(el, \"name\");\n```\n<span line-highlight='1,4,5'></span>\n### can-extend\n\nRunning [all of the can-extend transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-extend):\n\n```bash\ncan-migrate -a **/*.js -t can-extend/\n```\n\n…will transform this:\n\n```js\nimport can from \"can\";\n\ncan.extend(true, {}, {}, {}, {});\ncan.extend(false, {}, {});\ncan.extend({}, {});\n```\n<span line-highlight='3-5'></span>\n…to this:\n\n```js\nimport deepAssign from \"can-util/js/deep-assign/deep-assign\";\nimport assign from \"can-util/js/assign/assign\";\nimport can from \"can\";\n\ndeepAssign({}, {}, {}, {});\nassign({}, {});\nassign({}, {});\n```\n<span line-highlight='1,2,5,6,7'></span>\n…or this:\n\n```js\nconst can = require(\"can\");\n\ncan.extend(true, {}, {}, {}, {});\ncan.extend(false, {}, {});\ncan.extend({}, {});\n```\n<span line-highlight='3-5'></span>\n…to this:\n\n```js\nconst deepAssign = require(\"can-util/js/deep-assign/deep-assign\");\nconst assign = require(\"can-util/js/assign/assign\");\nconst can = require(\"can\");\n\ndeepAssign({}, {}, {}, {});\nassign({}, {});\nassign({}, {});\n```\n<span line-highlight='1,2,5,6,7'></span>\n### can-addClass\n\nTo run [all of the can-addClass transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-addClass) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-addClass/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-addClass/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.addClass(el, \"myClass\");\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport className from \"can-util/dom/class-name/class-name\";\nimport can from \"can\";\nclassName.addClass.call(el, \"myClass\");\n```\n<span line-highlight='1,3'></span>\n\n### can-addEvent\n\nTo run [all of the can-addEvent transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-addEvent) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-addEvent/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-addEvent/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.addEvent.call(obj, \"change\", function() { alert(\"object change!\"); });\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canEvent from \"can-event\";\nimport can from \"can\";\ncanEvent.addEventListener.call(obj, \"change\", function() { alert(\"object change!\"); });\n```\n<span line-highlight='1,3'></span>\n\n### can-ajax\n\nTo run [all of the can-ajax transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-ajax) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-ajax/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-ajax/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.ajax();\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport ajax from \"can-ajax\";\nimport can from \"can\";\najax();\n```\n<span line-highlight='1,3'></span>\n\n### can-append\n\nTo run [all of the can-append transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-append) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-append/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-append/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.append(el, \"<p></p>\");\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport mutate from \"can-util/dom/mutate/mutate\";\nimport can from \"can\";\nmutate.appendChild.call(el, \"<p></p>\");\n```\n<span line-highlight='1,3'></span>\n\n### can-batch\n\nTo run [all of the can-batch transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-batch) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-batch/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-batch/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.batch.start();\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canBatch from \"can-batch\";\nimport can from \"can\";\ncanBatch.start();\n```\n<span line-highlight='1,3'></span>\n\n### can-buildFragment\n\nTo run [all of the can-buildFragment transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-buildFragment) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-buildFragment/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-buildFragment/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.buildFragment(\"<div><input/></div>\");\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport buildFragment from \"can-util/dom/fragment/fragment\";\nimport can from \"can\";\nbuildFragment(\"<div><input/></div>\");\n```\n<span line-highlight='1,3'></span>\n\n### can-camelize\n\nTo run [all of the can-camelize transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-camelize) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-camelize/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-camelize/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.camelize(\"str\");\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport string from \"can-util/js/string/string\";\nimport can from \"can\";\nstring.camelize(\"str\");\n```\n<span line-highlight='1,3'></span>\n\n### can-capitilize\n\nTo run [all of the can-capitilize transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-capitilize) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-capitilize/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-capitilize/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.capitalize(\"str\");\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport string from \"can-util/js/string/string\";\nimport can from \"can\";\nstring.capitalize(\"str\");\n```\n<span line-highlight='1,3'></span>\n\n### can-component\n\nTo run [all of the can-component transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-component) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-component/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-component/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport Component from \"can/component/\";\nimport Component from \"can/component/component\";\nimport Component from \"can/component/component.js\";\n```\n\n…to this:\n\n```js\nimport Component from \"can-component\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-component/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.Component.extend();\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport Component from \"can-component\";\nimport can from \"can\";\nComponent.extend();\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-component/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst Component = require(\"can/component/\");\nconst Component = require(\"can/component/component\");\nconst Component = require(\"can/component/component.js\");\n```\n\n…to this:\n\n```js\nconst Component = require(\"can-component\");\n```\n\n### can-compute\n\nTo run [all of the can-compute transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-compute) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-compute/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-compute/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport compute from \"can/compute/\";\nimport compute from \"can/compute/compute\";\nimport compute from \"can/compute/compute.js\";\n```\n\n…to this:\n\n```js\nimport compute from \"can-compute\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-compute/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.compute();\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport compute from \"can-compute\";\nimport can from \"can\";\ncompute();\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-compute/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst compute = require(\"can/compute/\");\nconst compute = require(\"can/compute/compute\");\nconst compute = require(\"can/compute/compute.js\");\n```\n\n…to this:\n\n```js\nconst compute = require(\"can-compute\");\n```\n\n### can-construct-super\n\nTo run [all of the can-construct-super transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-construct-super) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-construct-super/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-construct-super/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport constructSuper from \"can/construct/super/\";\nimport constructSuper from \"can/construct/super/super\";\nimport constructSuper from \"can/construct/super/super.js\";\n```\n\n…to this:\n\n```js\nimport constructSuper from \"can-construct-super\";\n```\n\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-construct-super/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst constructSuper = require(\"can/construct/super/\");\nconst constructSuper = require(\"can/construct/super/super\");\nconst constructSuper = require(\"can/construct/super/super.js\");\n```\n\n…to this:\n\n```js\nconst constructSuper = require(\"can-construct-super\");\n```\n\n### can-construct\n\nTo run [all of the can-construct transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-construct) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-construct/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-construct/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport construct from \"can/construct/\";\nimport construct from \"can/construct/construct\";\nimport construct from \"can/construct/construct.js\";\n```\n\n…to this:\n\n```js\nimport Construct from \"can-construct\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-construct/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.Construct.extend();\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport Construct from \"can-construct\";\nimport can from \"can\";\nConstruct.extend();\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-construct/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst construct = require(\"can/construct/\");\nconst construct = require(\"can/construct/construct\");\nconst construct = require(\"can/construct/construct.js\");\n```\n\n…to this:\n\n```js\nconst Construct = require(\"can-construct\");\n```\n\n### can-control\n\nTo run [all of the can-control transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-control) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-control/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-control/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport Control from \"can/control/\";\nimport Control from \"can/control/control\";\nimport Control from \"can/control/control.js\";\n```\n\n…to this:\n\n```js\nimport Control from \"can-control\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-control/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.Control( staticProperties, instanceProperties );\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport Control from \"can-control\";\nimport can from \"can\";\nControl( staticProperties, instanceProperties );\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-control/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst Control = require(\"can/control/\");\nconst Control = require(\"can/control/control\");\nconst Control = require(\"can/control/control.js\");\n```\n\n…to this:\n\n```js\nconst Control = require(\"can-control\");\n```\n\n### can-deparam\n\nTo run [all of the can-deparam transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-deparam) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-deparam/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-deparam/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.deparam(\"#foo[]=bar&foo[]=baz\");\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport deparam from \"can-deparam\";\nimport can from \"can\";\ndeparam(\"#foo[]=bar&foo[]=baz\");\n```\n<span line-highlight='1,3'></span>\n\n### can-dispatch\n\nTo run [all of the can-dispatch transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-dispatch) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-dispatch/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-dispatch/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.dispatch( obj, event, args );\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canEvent from \"can-event\";\nimport can from \"can\";\ncanEvent( obj, event, args );\n```\n<span line-highlight='1,3'></span>\n\n### can-each\n\nTo run [all of the can-each transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-each) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-each/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-each/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.each();\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport each from \"can-each\";\nimport can from \"can\";\neach();\n```\n<span line-highlight='1,3'></span>\n\n### can-esc\n\nTo run [all of the can-esc transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-esc) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-esc/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-esc/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.esc(\"<div>&nbsp</div>\");\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport string from \"can-util/js/string/string\";\nimport can from \"can\";\nstring.esc(\"<div>&nbsp</div>\");\n```\n<span line-highlight='1,3'></span>\n\n### can-event\n\nTo run [all of the can-event transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-event) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-event/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-event/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport event from \"can/event/\";\nimport event from \"can/event/event\";\nimport event from \"can/event/event.js\";\n```\n\n…to this:\n\n```js\nimport canEvent from \"can-event\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-event/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.event.dispatch.call(obj, \"change\");\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canEvent from \"can-event\";\nimport can from \"can\";\ncanEvent.dispatch.call(obj, \"change\");\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-event/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst event = require(\"can/event/\");\nconst event = require(\"can/event/event\");\nconst event = require(\"can/event/event.js\");\n```\n\n…to this:\n\n```js\nconst canEvent = require(\"can-event\");\n```\n\n### can-fixture\n\nTo run [all of the can-fixture transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-fixture) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-fixture/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-fixture/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport fixture from \"can/util/fixture/\";\nimport fixture from \"can/util/fixture/fixture\";\nimport fixture from \"can/util/fixture/fixture.js\";\n```\n\n…to this:\n\n```js\nimport fixture from \"can-fixture\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-fixture/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.fixture( \"/foobar.json\", function(){});\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport fixture from \"can-fixture\";\nimport can from \"can\";\nfixture( \"/foobar.json\", function(){});\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-fixture/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst fixture = require(\"can/util/fixture/\");\nconst fixture = require(\"can/util/fixture/fixture\");\nconst fixture = require(\"can/util/fixture/fixture.js\");\n```\n\n…to this:\n\n```js\nconst fixture = require(\"can-fixture\");\n```\n\n### can-frag\n\nTo run [all of the can-frag transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-frag) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-frag/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-frag/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.frag();\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport frag from \"can-frag\";\nimport can from \"can\";\nfrag();\n```\n<span line-highlight='1,3'></span>\n\n### can-getObject\n\nTo run [all of the can-getObject transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-getObject) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-getObject/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-getObject/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.getObject(name, roots);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport string from \"can-util/js/string/string\";\nimport can from \"can\";\nstring.getObject(name, roots);\n```\n<span line-highlight='1,3'></span>\n\n### can-hyphenate\n\nTo run [all of the can-hyphenate transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-hyphenate) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-hyphenate/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-hyphenate/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.hyphenate(\"str\");\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport string from \"can-util/js/string/string\";\nimport can from \"can\";\nstring.hyphenate(\"str\");\n```\n<span line-highlight='1,3'></span>\n\n### can-isArray\n\nTo run [all of the can-isArray transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-isArray) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-isArray/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-isArray/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.isArray([1,2,3]);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport isArrayLike from \"can-util/js/is-array-like/is-array-like\";\nimport can from \"can\";\nisArrayLike([1,2,3]);\n```\n<span line-highlight='1,3'></span>\n\n### can-isDeferred\n\nTo run [all of the can-isDeferred transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-isDeferred) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-isDeferred/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-isDeferred/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.isDeferred(obj);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport isPromiseLike from \"can-util/js/is-promise-like/is-promise-like\";\nimport can from \"can\";\nisPromiseLike(obj);\n```\n<span line-highlight='1,3'></span>\n\n### can-isEmptyObject\n\nTo run [all of the can-isEmptyObject transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-isEmptyObject) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-isEmptyObject/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-isEmptyObject/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.isEmptyObject(obj);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport isEmptyObject from \"can-util/js/is-empty-object/is-empty-object\";\nimport can from \"can\";\nisEmptyObject(obj);\n```\n<span line-highlight='1,3'></span>\n\n### can-isFunction\n\nTo run [all of the can-isFunction transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-isFunction) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-isFunction/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-isFunction/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.isFunction(func);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport isFunction from \"can-util/js/is-function/is-function\";\nimport can from \"can\";\nisFunction(func);\n```\n<span line-highlight='1,3'></span>\n\n### can-list\n\nTo run [all of the can-list transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-list) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-list/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-list/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport List from \"can/list/\";\nimport List from \"can/list/list\";\nimport List from \"can/list/list.js\";\n```\n\n…to this:\n\n```js\nimport CanList from \"can-list\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-list/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\nvar people = new can.List([\"Alex\", \"Bill\"]);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport CanList from \"can-list\";\nimport can from \"can\";\nvar people = new CanList([\"Alex\", \"Bill\"]);\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-list/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst List = require(\"can/list/\");\nconst List = require(\"can/list/list\");\nconst List = require(\"can/list/list.js\");\n```\n\n…to this:\n\n```js\nconst CanList = require(\"can-list\");\n```\n\n### can-listenTo\n\nTo run [all of the can-listenTo transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-listenTo) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-listenTo/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-listenTo/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.listenTo.call(obj, other, event, handler);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canEvent from \"can-event\";\nimport can from \"can\";\ncanEvent.call(obj, other, event, handler);\n```\n<span line-highlight='1,3,5'></span>\n\n### can-makeArray\n\nTo run [all of the can-makeArray transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-makeArray) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-makeArray/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-makeArray/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.makeArray({0: \"a\", length: 1});\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport makeArray from \"can-util/js/make-array/make-array\";\nimport can from \"can\";\nmakeArray({0: \"a\", length: 1});\n```\n<span line-highlight='1,3'></span>\n\n### can-map-backup\n\nTo run [all of the can-map-backup transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-map-backup) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-map-backup/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-map-backup/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport mapBackup from \"can/map/backup/\";\nimport mapBackup from \"can/map/backup/backup\";\nimport mapBackup from \"can/map/backup/backup.js\";\n```\n\n…to this:\n\n```js\nimport mapBackup from \"can-map-backup\";\n```\n\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-map-backup/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst mapBackup = require(\"can/map/backup/\");\nconst mapBackup = require(\"can/map/backup/backup\");\nconst mapBackup = require(\"can/map/backup/backup.js\");\n```\n\n…to this:\n\n```js\nconst mapBackup = require(\"can-map-backup\");\n```\n\n### can-map-define\n\nTo run [all of the can-map-define transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-map-define) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-map-define/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-map-define/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport mapDefine from \"can/map/define/\";\nimport mapDefine from \"can/map/define/define\";\nimport mapDefine from \"can/map/define/define.js\";\n```\n\n…to this:\n\n```js\nimport mapDefine from \"can-map-define\";\n```\n\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-map-define/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst mapDefine = require(\"can/map/define/\");\nconst mapDefine = require(\"can/map/define/define\");\nconst mapDefine = require(\"can/map/define/define.js\");\n```\n\n…to this:\n\n```js\nconst mapDefine = require(\"can-map-define\");\n```\n\n### can-map\n\nTo run [all of the can-map transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-map) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-map/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-map/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport map from \"can/map/\";\nimport map from \"can/map/map\";\nimport map from \"can/map/map.js\";\n```\n\n…to this:\n\n```js\nimport CanMap from \"can-map\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-map/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\nconst map = new can.Map(aName);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport CanMap from \"can-map\";\nimport can from \"can\";\nconst map = new CanMap(aName);\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-map/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst map = require(\"can/map/\");\nconst map = require(\"can/map/map\");\nconst map = require(\"can/map/map.js\");\n```\n\n…to this:\n\n```js\nconst CanMap = require(\"can-map\");\n```\n\n### can-model\n\nTo run [all of the can-model transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-model) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-model/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-model/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport model from \"can/model/\";\nimport model from \"can/model/model\";\nimport model from \"can/model/model.js\";\n```\n\n…to this:\n\n```js\nimport Model from \"can-model\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-model/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.Model(name, staticProperties, instanceProperties);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport Model from \"can-model\";\nimport can from \"can\";\nModel(name, staticProperties, instanceProperties);\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-model/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst model = require(\"can/model/\");\nconst model = require(\"can/model/model\");\nconst model = require(\"can/model/model.js\");\n```\n\n…to this:\n\n```js\nconst Model = require(\"can-model\");\n```\n\n### can-mustache\n\nTo run [all of the can-mustache transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-mustache) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-mustache/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-mustache/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.mustache( id, template );\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport mustache from \"can-mustache\";\nimport can from \"can\";\nmustache( id, template );\n```\n<span line-highlight='1,3'></span>\n\n### can-one\n\nTo run [all of the can-one transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-one) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-one/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-one/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.event.dispatch.call(obj, \"change\");\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canEvent from \"can-event\";\nimport can from \"can\";\ncanEvent.dispatch.call(obj, \"change\");\n```\n<span line-highlight='1,3'></span>\n\n### can-param\n\nTo run [all of the can-param transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-param) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-param/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-param/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.param({foo: \"bar\"});\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport param from \"can-param\";\nimport can from \"can\";\nparam({foo: \"bar\"});\n```\n<span line-highlight='1,3'></span>\n\n### can-remove\n\nTo run [all of the can-remove transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-remove) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-remove/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-remove/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.remove.call(el, child);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport mutate from \"can-util/dom/mutate/mutate\";\nimport can from \"can\";\nmutate.removeChild.call.call(el, child);\n```\n<span line-highlight='1,3'></span>\n\n### can-removeEvent\n\nTo run [all of the can-removeEvent transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-removeEvent) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-removeEvent/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-removeEvent/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.event.removeEvent.call(el, \"click\", function() {});\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canEvent from \"can-event\";\nimport can from \"can\";\ncanEvent.removeEvent.call(el, \"click\", function() {});\n```\n<span line-highlight='1,3'></span>\n\n### can-route-pushstate\n\nTo run [all of the can-route-pushstate transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-route-pushstate) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-route-pushstate/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-route-pushstate/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport routePushState from \"can/route/pushstate/\";\nimport routePushState from \"can/route/pushstate/pushstate\";\nimport routePushState from \"can/route/pushstate/pushstate.js\";\n```\n\n…to this:\n\n```js\nimport routePushState from \"can-route-pushstate\";\n```\n\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-route-pushstate/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst routePushState = require(\"can/route/pushstate/\");\nconst routePushState = require(\"can/route/pushstate/pushstate\");\nconst routePushState = require(\"can/route/pushstate/pushstate.js\");\n```\n\n…to this:\n\n```js\nconst routePushState = require(\"can-route-pushstate\");\n```\n\n### can-route\n\nTo run [all of the can-route transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-route) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-route/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-route/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport route from \"can/route/\";\nimport route from \"can/route/route\";\nimport route from \"can/route/route.js\";\n```\n\n…to this:\n\n```js\nimport route from \"can-route\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-route/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.route(\"{page}\", {page: \"homepage\"});\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport route from \"can-route\";\nimport can from \"can\";\nroute(\"{page}\", {page: \"homepage\"});\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-route/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst route = require(\"can/route/\");\nconst route = require(\"can/route/route\");\nconst route = require(\"can/route/route.js\");\n```\n\n…to this:\n\n```js\nconst route = require(\"can-route\");\n```\n\n### can-stache\n\nTo run [all of the can-stache transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-stache) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-stache/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-stache/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport stache from \"can/view/stache/\";\nimport stache from \"can/view/stache/stache\";\nimport stache from \"can/view/stache/stache.js\";\n```\n\n…to this:\n\n```js\nimport stache from \"can-stache\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-stache/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.stache(template);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport stache from \"can-stache\";\nimport can from \"can\";\nstache(template);\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-stache/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst stache = require(\"can/view/stache/\");\nconst stache = require(\"can/view/stache/stache\");\nconst stache = require(\"can/view/stache/stache.js\");\n```\n\n…to this:\n\n```js\nconst stache = require(\"can-stache\");\n```\n\n### can-stopListening\n\nTo run [all of the can-stopListening transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-stopListening) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-stopListening/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-stopListening/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.event.stopListening.call(obj, other, event, handler);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canEvent from \"can-event\";\nimport can from \"can\";\ncanEvent.stopListening.call(obj, other, event, handler);\n```\n<span line-highlight='1,3'></span>\n\n### can-sub\n\nTo run [all of the can-sub transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-sub) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-sub/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-sub/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.sub(str, data, remove);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport string from \"can-util/js/string/string\";\nimport can from \"can\";\nstring.sub(str, data, remove);\n```\n<span line-highlight='1,3'></span>\n\n### can-underscore\n\nTo run [all of the can-underscore transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-underscore) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-underscore/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-underscore/replace.js\n```\n<span line-highlight='2'></span>\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.underscore(\"str\");\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport string from \"can-util/js/string/string\";\nimport can from \"can\";\nstring.underscore(\"str\");\n```\n<span line-highlight='1,3'></span>\n\n### can-view-attr\n\nTo run [all of the can-view-attr transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-view-attr) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-view-attr/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-attr/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.view.attr(attributeName, attrHandler(el, attrData));\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canViewCallbacks from \"can-view-callbacks\";\nimport can from \"can\";\ncanViewCallbacks.attr(attributeName, attrHandler(el, attrData));\n```\n<span line-highlight='1,3'></span>\n\n### can-view-autorender\n\nTo run [all of the can-view-autorender transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-view-autorender) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-view-autorender/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-autorender/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport autorender from \"can/view/autorender/\";\nimport autorender from \"can/view/autorender/autorender\";\nimport autorender from \"can/view/autorender/autorender.js\";\n```\n\n…to this:\n\n```js\nimport canAutorender from \"can-view-autorender\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-autorender/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.autorender(success, error);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canAutorender from \"can-view-autorender\";\nimport can from \"can\";\ncanAutorender(success, error);\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-autorender/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst autorender = require(\"can/view/autorender/\");\nconst autorender = require(\"can/view/autorender/autorender\");\nconst autorender = require(\"can/view/autorender/autorender.js\");\n```\n\n…to this:\n\n```js\nconst canAutorender = require(\"can-view-autorender\");\n```\n\n### can-view-callbacks\n\nTo run [all of the can-view-callbacks transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-view-callbacks) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-view-callbacks/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-callbacks/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport viewCallbacks from \"can/view/callbacks/\";\nimport viewCallbacks from \"can/view/callbacks/callbacks\";\nimport viewCallbacks from \"can/view/callbacks/callbacks.js\";\n```\n\n…to this:\n\n```js\nimport canViewCallbacks from \"can-view-callbacks\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-callbacks/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.view.callbacks();\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canViewCallbacks from \"can-view-callbacks\";\nimport can from \"can\";\ncanViewCallbacks();\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-callbacks/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst viewCallbacks = require(\"can/view/callbacks/\");\nconst viewCallbacks = require(\"can/view/callbacks/callbacks\");\nconst viewCallbacks = require(\"can/view/callbacks/callbacks.js\");\n```\n\n…to this:\n\n```js\nconst canViewCallbacks = require(\"can-view-callbacks\");\n```\n\n### can-view-href\n\nTo run [all of the can-view-href transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-view-href) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-view-href/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-href/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport viewHref from \"can/view/href/\";\nimport viewHref from \"can/view/href/href\";\nimport viewHref from \"can/view/href/href.js\";\n```\n\n…to this:\n\n```js\nimport canViewHref from \"can-view-href\";\n```\n\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-href/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst viewHref = require(\"can/view/href/\");\nconst viewHref = require(\"can/view/href/href\");\nconst viewHref = require(\"can/view/href/href.js\");\n```\n\n…to this:\n\n```js\nconst canViewHref = require(\"can-view-href\");\n```\n\n### can-view-import\n\nTo run [all of the can-view-import transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-view-import) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-view-import/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-import/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport viewImport from \"can/view/import/\";\nimport viewImport from \"can/view/import/import\";\nimport viewImport from \"can/view/import/import.js\";\n```\n\n…to this:\n\n```js\nimport canViewImport from \"can-view-import\";\n```\n\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-import/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst viewImport = require(\"can/view/import/\");\nconst viewImport = require(\"can/view/import/import\");\nconst viewImport = require(\"can/view/import/import.js\");\n```\n\n…to this:\n\n```js\nconst canViewImport = require(\"can-view-import\");\n```\n\n### can-view-live\n\nTo run [all of the can-view-live transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-view-live) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-view-live/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-live/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.view.live.text(textNode, text);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canViewLive from \"can-view-live\";\nimport can from \"can\";\ncanViewLive.text(textNode, text);\n```\n<span line-highlight='1,3'></span>\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-live/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport viewLive from \"can/view/live/\";\nimport viewLive from \"can/view/live/live\";\nimport viewLive from \"can/view/live/live.js\";\n```\n\n…to this:\n\n```js\nimport canViewLive from \"can-view-live\";\n```\n\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-live/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst viewLive = require(\"can/view/live/\");\nconst viewLive = require(\"can/view/live/live\");\nconst viewLive = require(\"can/view/live/live.js\");\n```\n\n…to this:\n\n```js\nconst canViewLive = require(\"can-view-live\");\n```\n\n### can-view-parser\n\nTo run [all of the can-view-parser transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-view-parser) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-view-parser/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-parser/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport viewParser from \"can/view/parser/\";\nimport viewParser from \"can/view/parser/parser\";\nimport viewParser from \"can/view/parser/parser.js\";\n```\n\n…to this:\n\n```js\nimport canViewParser from \"can-view-parser\";\n```\n\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-parser/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst viewParser = require(\"can/view/parser/\");\nconst viewParser = require(\"can/view/parser/parser\");\nconst viewParser = require(\"can/view/parser/parser.js\");\n```\n\n…to this:\n\n```js\nconst canViewParser = require(\"can-view-parser\");\n```\n\n### can-view-scope\n\nTo run [all of the can-view-scope transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-view-scope) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-view-scope/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-scope/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\nconst scope = new can.view.Scope(data);\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canViewScope from \"can-view-scope\";\nimport can from \"can\";\nconst scope = new canViewScope(data);\n```\n<span line-highlight='1,3'></span>\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-scope/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport viewScope from \"can/view/scope/\";\nimport viewScope from \"can/view/scope/scope\";\nimport viewScope from \"can/view/scope/scope.js\";\n```\n\n…to this:\n\n```js\nimport canViewScope from \"can-view-scope\";\n```\n\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-scope/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst viewScope = require(\"can/view/scope/\");\nconst viewScope = require(\"can/view/scope/scope\");\nconst viewScope = require(\"can/view/scope/scope.js\");\n```\n\n…to this:\n\n```js\nconst canViewScope = require(\"can-view-scope\");\n```\n\n### can-view-tag\n\nTo run [all of the can-view-tag transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-view-tag) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-view-tag/\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-tag/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.view.tag(tagName, tagHandler(el, tagData));\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canViewCallbacks from \"can-view-callbacks\";\nimport can from \"can\";\ncanViewCallbacks.tag(tagName, tagHandler(el, tagData));\n```\n<span line-highlight='1,3'></span>\n\n### can-view-target\n\nTo run [all of the can-view-target transforms](https://github.com/canjs/can-migrate/tree/master/src/transforms/can-view-target) listed below:\n\n```bash\ncan-migrate -a **/*.js -t can-view-target/\n```\n\n#### import\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-target/import.js\n```\n\n…will transform any of the following:\n\n```js\nimport viewTarget from \"can/view/target/\";\nimport viewTarget from \"can/view/target/target\";\nimport viewTarget from \"can/view/target/target.js\";\n```\n\n…to this:\n\n```js\nimport canViewTarget from \"can-view-target\";\n```\n\n#### replace\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-target/replace.js\n```\n\n…will transform code like this:\n\n```js\nimport can from \"can\";\ncan.view.target();\n```\n<span line-highlight='2'></span>\n…to this:\n\n```js\nimport canViewTarget from \"can-view-target\";\nimport can from \"can\";\ncanViewTarget();\n```\n<span line-highlight='1,3'></span>\n#### require\n\nRunning this transform:\n\n```bash\ncan-migrate -a **/*.js -t can-view-target/require.js\n```\n\n…will transform any of the following:\n\n```js\nconst viewTarget = require(\"can/view/target/\");\nconst viewTarget = require(\"can/view/target/target\");\nconst viewTarget = require(\"can/view/target/target.js\");\n```\n\n…to this:\n\n```js\nconst canViewTarget = require(\"can-view-target\");\n```\n\n",
    "description": "Learn how to migrate your app to CanJS 3 using [can-migrate](https://www.npmjs.com/package/can-migrate). \n",
    "name": "guides/upgrade/using-codemods",
    "title": "Using Codemods",
    "type": "page",
    "parent": "guides/upgrade",
    "order": 1,
    "comment": " "
  },
  "can-cid/map/map": {
    "src": {
      "path": "node_modules/can-cid/map/map.md"
    },
    "body": "\n\n## Use\n\nThis module exports the native [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\nobject if `Map` is present.  If not, a `Map`-like constructor function is exported that supports `O(1)` insertion and\ndeletion by adding a [can-cid] property to objects passed to `.set`.\n\n```js\nvar Map = require(\"can-util/js/cid-map/cid-map\");\n\nvar map = new Map();\n\nvar obj = {};\n\nmap.set(obj, \"value\");\nmap.get(obj) //-> \"value\";\n```\n\nThe following methods and properties are supported by the polyfill:\n\n- `clear()`\n- `delete(key)`\n- `forEach(callback[,thisArg])`\n- `get(key)`\n- `has(key)`\n- `set(key, value)`\n- `size`\n\n",
    "description": "\nExports the native [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\nor a polyfill.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Map"
      }
    ],
    "name": "can-cid/map/map",
    "parent": "can-cid",
    "comment": " "
  },
  "can-cid/set/set": {
    "src": {
      "path": "node_modules/can-cid/set/set.md"
    },
    "body": "\n\n## Use\n\nThis module exports the native [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\nobject if `Set` is present.  If not, a `Set`-like constructor function is exported that supports `O(1)` insertion and\ndeletion by adding a [can-cid] property to objects passed to `.set`.\n\n```js\nvar Set = require(\"can-util/js/cid-set/cid-set\");\n\nvar map = new set();\n\nvar obj = {};\n\nmap.add(obj);\nmap.has(obj) //-> true;\n```\n\nThe following methods and properties are supported by the polyfill:\n\n- `clear()`\n- `delete(value)`\n- `forEach(callback[,thisArg])`\n- `get(value)`\n- `has(value)`\n- `add(value)`\n- `size`\n\n",
    "description": "\nExports the native [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\nor a polyfill.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Map"
      }
    ],
    "name": "can-cid/set/set",
    "parent": "can-cid",
    "comment": " "
  },
  "can-component.prototype.ViewModel": {
    "src": {
      "path": "node_modules/can-component/docs/ViewModel.md"
    },
    "body": "\n## Use\n\n[can-component]’s ViewModel property is used to create an __object__, typically an instance\nof a [can-define/map/map], that will be used to render the component’s\nview. This is most easily understood with an example.  The following\ncomponent shows the current page number based off a `limit` and `offset` value:\n\n```js\nvar MyPaginateViewModel = DefineMap.extend({\n  offset: {value: 0},\n  limit: {value: 20},\n\tget page() {\n\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t}\n});\n\nComponent.extend({\n  tag: \"my-paginate\",\n  ViewModel: MyPaginateViewModel,\n  view: stache(\"Page {{page}}.\")\n})\n```\n\nIf this component HTML was inserted into the page like:\n```js\nvar renderer = stache(\"<my-paginate/>\");\nvar frag = renderer();\ndocument.body.appendChild(frag);\n```\nIt would result in:\n\n    <my-paginate>Page 1</my-paginate>\n\nThis is because the provided ViewModel object is used to create an instance of [can-define/map/map] like:\n```js\nvar viewModel = new MyPaginateViewModel();\n```\n\nThe [can-define.types.value] property definition makes offset default to 0 and limit default to 20.\n\nNext, the values are passed into `viewModel` from the [can-stache-bindings data bindings] within `<my-paginate>`\n(in this case there is none).\n\nAnd finally, that data is used to render the component’s view and inserted into the element using [can-view-scope] and [can-stache]:\n```js\nvar newViewModel = new Scope(viewModel),\n\tresult = stache(\"Page {{page}}.\")(newViewModel);\nelement.innerHTML = result;\n```\n\nThere is a short-hand for the prototype methods and properties used to extend the\n[can-types.DefaultMap default Map type] (typically [can-define/map/map])\nby setting the Component’s ViewModel to an object and using\nthat anonymous type as the view model.\n\nThe following does the same as above:\n```js\nComponent.extend({\n\ttag: \"my-paginate\",\n\tViewModel: {\n\t\toffset: {value: 0},\n\t\tlimit: {value: 20},\n\t\tget page() {\n\t\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t\t}\n\t},\n\tview: stache(\"Page {{page}}.\")\n})\n```\n\n## Values passed from attributes\n\nValues can be \"passed\" into the viewModel instance of a component, similar to passing arguments into a function. Using\n[can-stache-bindings], the following binding types can be setup:\n\n- [can-stache-bindings.toChild] — Update the component’s viewModel instance when the parent scope value changes.\n- [can-stache-bindings.toParent] — Update the parent scope when the component’s viewModel instance changes.\n- [can-stache-bindings.twoWay] — Update the parent scope or the component’s viewModel instance when the other changes.\n\nUsing [can-stache], values are passed into components like this:\n\n    <my-paginate {offset}='index' {limit}='size' />\n\nThe above creates an offset and limit property on the component that are initialized to whatever index and size are.\n\nThe following component requires an `offset` and `limit`:\n```js\nComponent.extend({\n\ttag: \"my-paginate\",\n\tViewModel: {\n\t\toffset: {value: 0},\n\t\tlimit: {value: 20},\n\t\tget page() {\n\t\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t\t}\n\t},\n\tview: stache(\"Page {{page}}.\")\n});\n```\nIf `<my-paginate>` is used like:\n```js\nvar renderer = stache(\"<my-paginate {offset}='index' {limit}='size' />\");\n\nvar pageInfo = new DefineMap({index: 0, size: 20});\n\ndocument.body.appendChild(renderer(pageInfo));\n```\n... `pageInfo`’s index and size are set as the component’s offset and\nlimit attributes. If we were to change the value of `pageInfo`’s\nindex like:\n```js\npageInfo.index = 20;\n```\n... the component’s offset value will change and its view will update to:\n\n    <my-paginate>Page 2</my-paginate>\n\n### Using attribute values\n\nYou can also pass a literal string value of the attribute. To do this in [can-stache],\nsimply pass any value not wrapped in single brackets, and the viewModel instance property will\nbe initialized to this string value:\n\n    <my-tag title=\"hello\" />\n\nThe above will set the title property on the component’s viewModel instance to the string `hello`.\n\nIf the tag’s `title` attribute is changed, it updates the viewModel instance property\nautomatically.  This can be seen in the following example:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/accordion.html'></div>\n\nClicking the __Change title__ button sets a `<panel>` element’s `title` attribute like:\n\n```js\nout.addEventListener(\"click\", function(ev){\n\tvar el = ev.target;\n\tvar parent = el.parentNode;\n\tif(el.nodeName === \"BUTTON\") {\n\t\tparent.setAttribute(\"title\", \"Users\");\n\t\tparent.removeChild(el);\n\t}\n});\n```\n\n## Calling methods on ViewModel from events within the view\n\nUsing html attributes like `can-EVENT-METHOD`, you can directly call a ViewModel method\nfrom a view. For example, we can make `<my-paginate>` elements include a next\nbutton that calls the ViewModel’s `next` method like:\n\n```js\nvar ViewModel = DefineMap.extend({\n\toffset: {value: 0},\n\tlimit: {value: 20},\n\tnext: function(){\n\t\tthis.offset = this.offset + this.limit;\n\t},\n\tget page() {\n\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t}\n});\n\nComponent.extend({\n\ttag: \"my-paginate\",\n\tViewModel: ViewModel,\n\tview: stache(\"Page {{page}} <button ($click)='next()'>Next</button>\")\n});\n```\n\nViewModel methods get called back with the current context, the element that you are listening to and the event that triggered the callback.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next.html'></div>\n\n## Publishing events on ViewModels\n\nDefineMaps can publish events on themselves. For instance, the following `<player-edit>` component,\ndispatches a `\"close\"` event when its close method is called:\n\n```js\nComponent.extend({\n\ttag: \"player-edit\",\n\tview: stache.from('player-edit-stache'),\n\tViewModel: DefineMap.extend({\n\t\tplayer: Player,\n\t\tclose: function(){\n\t\t\tthis.dispatch(\"close\");\n\t\t}\n\t}),\n\tleakScope: true\n});\n```\n\nThese can be listened to with [can-stache-bindings.event] bindings like:\n\n```js\n<player-edit\n  \t(close)=\"removeEdit()\"\n  \t{player}=\"editingPlayer\" />\n```\n\nThe following demo uses this ability to create a close button that\nhides the player editor:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next_event.html'></div>\n\n",
    "description": " \nProvides or describes a constructor function that provides values and methods\nto the component’s [can-component::view view]. The constructor function\nis initialized with values specified by the component element’s [can-stache-bindings data bindings].\n\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A new instance of the corresponding constructor function. This instance is\nadded to the top of the [can-view-scope] the component’s [can-component::view] is rendered with.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "properties",
            "description": "The initial properties that are passed by the [can-stache-bindings data bindings].\n\nThe view bindings on a tag control the properties and values used to instantiate the `ViewModel`. For example, calling `<my-tag>` as follows invokes `MyTagViewModel` as shown in the following example:\n\n```\n<my-tag/> <!-- new MyTagViewModel({}) -->\n\n<my-tag\n\t{message}=\"'Hi There'\"/> <!-- new MyTagViewModel({message: \"Hi There\"}) -->\n```\n"
          }
        ],
        "description": "A constructor function usually defined by [can-define/map/map.extend DefineMap.extend] or\n[can-map Map.extend] that will be used to create a new observable instance accessible by\nthe component’s [can-component::view].\n\nFor example, every time `<my-tag>` is found, a new instance of `MyTagViewModel` will\nbe created:\n\n```js\nvar MyTagViewModel = DefineMap.extend(\"MyTagViewModel\",{\n\tmessage: \"string\"\n});\n\nComponent.extend({\n\ttag: \"my-tag\",\n\tViewModel: MyTagViewModel,\n\tview: stache(\"<h1>{{message}}</h1>\")\n})\n```\n\nUse [can-view-model] to read a component’s view model instance.\n"
      }
    ],
    "title": "ViewModel",
    "name": "can-component.prototype.ViewModel",
    "type": "property",
    "parent": "can-component.prototype",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "properties",
      "description": "The initial properties that are passed by the [can-stache-bindings data bindings].\n\nThe view bindings on a tag control the properties and values used to instantiate the `ViewModel`. For example, calling `<my-tag>` as follows invokes `MyTagViewModel` as shown in the following example:\n\n```\n<my-tag/> <!-- new MyTagViewModel({}) -->\n\n<my-tag\n\t{message}=\"'Hi There'\"/> <!-- new MyTagViewModel({message: \"Hi There\"}) -->\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A new instance of the corresponding constructor function. This instance is\nadded to the top of the [can-view-scope] the component’s [can-component::view] is rendered with.\n"
    },
    "comment": " "
  },
  "can-component/can-template": {
    "src": {
      "path": "node_modules/can-component/docs/can-template.md"
    },
    "body": "\n## Use\n\nTo use `<can-template>` elements we can create a Component that has `<can-slot>` elements in it's view\nand render that component with `<can-template>` elements in the `LIGHT_DOM`.\n\nAny `<can-template>` that has a name attribute matching the name attribute of a `<can-slot>` will\nhave it's inner contents rendered and replace the `<can-slot>`.\n\n```js\nComponent.extend({\n\ttag : 'my-email',\n\tview : stache(\n\t\t'<can-slot name=\"subject\" />' +\n\t\t'<p>My Email</p>' +\n\t\t'<can-slot name=\"body\" />'\n\t)\n});\n\nvar renderer = stache(\n\t'<my-email>' +\n\t\t'<can-template name=\"subject\">' +\n\t\t\t'<h1>{{subject}}</h1>' +\n\t\t'</can-template>' +\n\t\t'<can-template name=\"body\">' +\n\t\t\t'<span>{{body}}</span>' +\n\t\t'</can-template>' +\n\t'</my-email>'\n);\n\nrenderer({\n\tsubject: 'Hello World',\n\tbody: 'The email body'\n});\n\n/*\n<my-email>\n\t<h1>Hello World</h1>\n\t<p>My Email</p>\n\t<span>The email body</span>\n</my-email>\n*/\n```\n\n",
    "description": "Pass templates declaratively to components. \n",
    "type": "typedef",
    "title": "<can-template>",
    "types": [
      {
        "type": "can-stache.sectionRenderer"
      }
    ],
    "name": "can-component/can-template",
    "parent": "can-component.elements",
    "signatures": [
      {
        "code": "<can-template name='NAME'/>",
        "description": "\n\nWhen building widget-like components, it's often useful to allow the consumer of the\ncomponent to customize parts of the widget's layout.  These components can accept\ntemplates passed to them using `<can-template>` and render these templates with\n[can-component/can-slot].  The `name` attribute of a `<can-template>`\ncorresponds to the `name` attribute of a `<can-slot>`.\n\nFor example, the following passes a `<my-modal>` component a `<can-template>`\nof the modal content:\n\n```js\nComponent.extend({\n\ttag : 'my-modal',\n\tview : stache(\n\t\t'<div class=\"wrapper\"><can-slot name=\"modal-content\" /></div>'\n\t)\n});\n\nvar renderer = stache(\n\t'<my-modal>' +\n\t\t'<can-template name=\"modal-content\">' +\n\t\t\t'Hello World!' +\n\t\t'</can-template>' +\n\t'</my-modal>'\n);\n\nrenderer() //-> <my-modal><div class=\"wrapper\">Hello World!</div></my-modal>\n```\n\nBy default, `<can-template>` is rendered with the surrounding scope\nlike `<content>`. A different context ([can-stache/keys/this]) can be added\nto that scope with bindings.  Read [can-component/can-slot] for more information.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "NAME",
            "description": "The name of the template that will be rendered by a corresponding\n[can-component/can-slot].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "NAME",
      "description": "The name of the template that will be rendered by a corresponding\n[can-component/can-slot].\n"
    },
    "comment": " "
  },
  "can-component/can-slot": {
    "src": {
      "path": "node_modules/can-component/docs/can-slot.md"
    },
    "body": "\n## Use\n\nTo use `<can-slot>` we can create a Component that has `<can-slot>` elements in it's view\nand render that component with <can-template> elements in the `LIGHT_DOM`.\n\nAny `<can-slot>` that has a name attribute matching the name attribute of a `<can-template>` will be\nreplaced by the rendered inner contents of the <can-template>.\n\n```js\nComponent.extend({\n\ttag : 'my-email',\n\tview : stache(\n\t\t'<can-slot name=\"subject\" />' +\n\t\t'<p>My Email</p>' +\n\t\t'<can-slot name=\"body\" />'\n\t)\n});\n\nvar renderer = stache(\n\t'<my-email>' +\n\t\t'<can-template name=\"subject\">' +\n\t\t\t'<h1>{{subject}}</h1>' +\n\t\t'</can-template>' +\n\t\t'<can-template name=\"body\">' +\n\t\t\t'<span>{{body}}</span>' +\n\t\t'</can-template>' +\n\t'</my-email>'\n);\n\nrenderer({\n\tsubject: 'Hello World',\n\tbody: 'The email body'\n});\n\n/*\n<my-email>\n\t<h1>Hello World</h1>\n\t<p>My Email</p>\n\t<span>The email body</span>\n</my-email>\n*/\n```\n\n### Passing context\n\nContext ([can-stache/keys/this]) can be bound to and passed to a template. The following\npasses `<my-email>`'s `subject` and `body` to the `subject` and `body` templates.  Notice\nhow `subject` and `body` are read by `{{this}}`.\n\n```js\nvar ViewModel = DefineMap.extend({\n\tsubject: {\n\t\tvalue:\"Hello World\"\n\t},\n\tbody: {\n\t\tvalue: \"Later Gator\"\n\t}\n});\n\nComponent.extend({\n\ttag : 'my-email',\n\tview : stache(\n\t\t'<can-slot name=\"subject\" {this}=\"subject\"/>' +\n\t\t'<can-slot name=\"body\" {this}=\"body\"/>'\n\t),\n\tViewModel\n});\n\nvar renderer = stache(\n\t'<my-email>' +\n\t\t'<can-template name=\"subject\">' +\n\t\t\t'<h1>{{this}}</h1>' +\n\t\t'</can-template>' +\n\t\t'<can-template name=\"body\">' +\n\t\t\t'<p>{{this}}</p>' +\n\t\t'</can-template>' +\n\t'</my-email>'\n);\n\nvar testView = renderer({\n\tsubject: 'Hello World',\n\tbody: 'This is a greeting.'\n});\n\n/*\n<my-email>\n\t<h1>Hello World</h1>\n\t<p>This is a greeting.</p>\n</my-email>\n*/\n```\n\n### Default content\n\nDefault content can be specified to be used if there is no matching `<can-template>`\nor the matching `<can-template>` has no inner content.\n\n```js\n\nComponent.extend({\n\ttag : 'my-email',\n\tview : stache(\n\t\t'<can-slot name=\"subject\">' +\n\t\t\t'<p>This is the default {{subject}}</p>' +\n\t\t'</can-slot>'\n\t)\n});\n\nvar renderer = stache(\n\t'<my-email>' +\n\t\t'<can-template name=\"subject\" />' +\n\t'</my-email>'\n);\n\nvar testView = renderer({\n\tsubject: 'content'\n});\n\n/*\n<my-email>\n\t<p>This is the default content</p>\n</my-email>\n*/\n```\n\n",
    "description": "Position the content of [can-component/can-template] elements. \n",
    "type": "typedef",
    "title": "<can-slot>",
    "types": [
      {
        "type": "can-stache.sectionRenderer"
      }
    ],
    "name": "can-component/can-slot",
    "parent": "can-component.elements",
    "signatures": [
      {
        "code": "<can-slot name='NAME' BINDING>DEFAULT_CONTENT</can-slot>",
        "description": "\n\nReplaces any `<can-slot name='NAME' />` element found in a component's view with the rendered contents\nof the `<can-template />` element from the `LIGHT_DOM` that has a matching [TEMPLATE_NAME] attribute. Uses the scope of\nthe `LIGHT_DOM` by default.\n\n```js\nComponent.extend({\n\ttag : 'my-email',\n\tview : stache(\n\t\t'<can-slot name=\"subject\" />'\n\t)\n});\n\nvar renderer = stache(\n\t'<my-email>' +\n\t\t'<can-template name=\"subject\">' +\n\t\t\t'{{subject}}' +\n\t\t'</can-template>' +\n\t'</my-email>'\n);\n\nrenderer({\n\tsubject: 'Hello World'\n});\n//-> <my-email>Hello World</my-email>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "NAME",
            "description": "The name of the [can-component/can-template] to render in place of the `<can-slot>`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache-bindings"
              }
            ],
            "name": "BINDING",
            "description": "You can bind to the context (also known as [can-stache/keys/this])\nof of the corresponding [can-component/can-template].  This lets you pass data to the\ntemplate. The following passes `user` as `this` to the corresponding `<can-template name=\"user-details\">`:\n\n```html\n<can-slot name=\"user-details\" {this}=\"user\">\n```\n\n[can-stache-bindings.toChild], [can-stache-bindings.toParent] and [can-stache-bindings.twoWay] with `this`\nall work.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "DEFAULT_CONTENT",
            "description": "The content that should be\nused if there is no content in the matching `<can-template>`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "DEFAULT_CONTENT",
      "description": "The content that should be\nused if there is no content in the matching `<can-template>`.\n"
    },
    "comment": " "
  },
  "can-component/beforeremove": {
    "src": {
      "path": "node_modules/can-component/docs/beforeremove.md"
    },
    "body": "\n",
    "description": "\nAn event called only on component’s elements before they are removed from the\ndocument if live binding is performing the removal. It can be listened to\nwithin a component’s [can-component.prototype.events] object or on a component\nelement with [can-stache-bindings.event] bindings.  This is an additional\nspecial event only on component elements.  [can-util/dom/events/inserted/inserted]\nand [can-util/dom/events/removed/removed] events are available on all elements.\n",
    "type": "typedef",
    "title": "beforeremove",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-component/beforeremove",
    "parent": "can-component.events",
    "signatures": [
      {
        "code": "\"{element} beforeremove\": function(element, event)",
        "description": "\n\nListens to when the component element is removed.  \nThis is commonly used for cleaning up and tearing down a component.\n\nFor example, the following might remove the component’s ViewModel\nfrom a parent component’s ViewModel:\n\n```js\nevents: {\n\t\"{element} beforeremove\": function(){\n\t\tcanViewModel(this.element.parentNode)\n\t\t\t.removePanel(this.viewModel);\n\t}\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "The component element."
          },
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "The `beforeremove` event object.\n"
          }
        ]
      },
      {
        "code": "($beforeremove)=\"CALL_EXRESSION\"",
        "description": "\n\nUses [can-stache-bindings.event] bindings to listen for a component’s\n`beforeremove` event.\n\n```\n<my-panel ($beforeremove)=\"removePanel(%viewModel)\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXRESSION",
            "description": "A call expression that calls some method when the event happens.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "CALL_EXRESSION",
      "description": "A call expression that calls some method when the event happens.\n"
    }
  },
  "can-component.static": {
    "name": "can-component.static",
    "title": "static",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 0
  },
  "can-component.prototype": {
    "name": "can-component.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 1
  },
  "can-component.elements": {
    "name": "can-component.elements",
    "title": "elements",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 2
  },
  "can-component.events": {
    "name": "can-component.events",
    "title": "special events",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 3
  },
  "can-component/content": {
    "src": {
      "path": "node_modules/can-component/docs/content.md"
    },
    "body": "\n",
    "description": "\nPositions the `LIGHT_DOM` within a component’s [can-component.prototype.view].\n",
    "type": "typedef",
    "title": "<content>",
    "types": [
      {
        "type": "can-stache.sectionRenderer"
      }
    ],
    "name": "can-component/content",
    "parent": "can-component.elements",
    "signatures": [
      {
        "code": "<content>DEFAULT_CONTENT</content>",
        "description": "\n\nWhen a user creates a new component in a view, the content between the tags is the\n`LIGHT_DOM`.  For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `<content>` tag can be used within `my-tag` to position the `LIGHT_DOM`.  For\nexample, to position the `LIGHT_DOM` within an `<h1>`, `<my-tag>` could be defined like:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content/></h1>\")\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "DEFAULT_CONTENT",
            "description": "The content that should be\nused if there is no `LIGHT_DOM` passed to the component.\n\nThe following, makes `my-tag` show `Hi There!` if no `LIGHT_DOM` is passed:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content>Hi There!</content></h1>\")\n});\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "DEFAULT_CONTENT",
      "description": "The content that should be\nused if there is no `LIGHT_DOM` passed to the component.\n\nThe following, makes `my-tag` show `Hi There!` if no `LIGHT_DOM` is passed:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content>Hi There!</content></h1>\")\n});\n```\n"
    }
  },
  "can-component.prototype.helpers": {
    "src": {
      "path": "node_modules/can-component/docs/helpers.md"
    },
    "body": "\n\n## Use\n\n[can-component]’s helper object lets you provide helper functions that are localized to\nthe component’s [can-component::view view].  The following example\nuses an `isSelected` helper to render content for selected items. Click\none of the following libraries to toggle them within the `selected` array.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/selected.html'></div>\n\n",
    "description": "\nHelper functions used with the component’s view.\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-stache.helper"
              }
            ]
          }
        ],
        "description": "\n\nAn object of [can-stache] helper names and methods. The helpers are only\navailable within the component’s view and source html. Helpers\nare always called back with `this` as the [can-component::ViewModel] instance.\n"
      }
    ],
    "title": "helpers",
    "name": "can-component.prototype.helpers",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.events": {
    "src": {
      "path": "node_modules/can-component/docs/events.md"
    },
    "body": "\n\n## Use\n\n[can-component]’s events object allows you to provide low-level [can-control]-like abilities to a `Component`\nwhile still accessing the `Component`’s [can-component::ViewModel].  The following\nexample listens to clicks on elements with `className=\"next\"` and calls `.next()` on the component’s viewModel.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_events_next.html'></div>\n\nThe events object can also listen to objects or properties on the component’s [can-component::ViewModel] instance. For instance, instead\nof using live-binding, we could listen to when offset changes and update the page manually:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_events_next_update_page.html'></div>\n\nComponents have the ability to bind to special inserted and removed events that are called when a component’s tag has been inserted into or removed from the page:\n\n      events: {\n        \"inserted\": function(){\n          // called when the component’s tag is inserted into the DOM\n        },\n        \"removed\": function(){\n          // called when the component’s tag is removed from the DOM\n        }\n      }\n\n## High performance view rendering\n\nWhile [can-stache-bindings] conveniently allows you to call a [can-component::ViewModel] method from a view like:\n\n    <input ($change)=\"doSomething()\"/>\n\nThis has the effect of binding an event handler directly to this element. Every element that has a `($click)` or similar attribute has an event handler bound to it. For a large grid or list, this could have a performance penalty.\n\nBy contrast, events bound using [can-component]’s events object use event delegation, which is useful for high performance view rendering. In a large grid or list, event delegation only binds a single event handler rather than one per row.\n\n",
    "description": "\nListen to events on elements and observables.\n",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "An object of event names and methods\nthat handle the event. For example:\n\n    Component.extend({\n\t  ViewModel: {\n\t\tlimit: \"number\",\n\t\toffset: \"number\",\n\t    next: function(){\n\t      this.offset = this.offset + this.limit;\n\t    }\n\t  },\n      events: {\n        \".next click\": function(){\n          this.viewModel.next()\n        },\n\t\t\"{viewModel} limit\": function(viewModel, ev, newValue){\n\t\t  console.log(\"limit is now\", newValue);\n\t\t}\n      }\n    })\n\n\nA component’s events object is used as the prototype of a [can-control]. The control gets created on the component’s\nelement.\n\nThe component’s [can-component.prototype.ViewModel] instance is available within event handlers as `this.viewModel`.\n\nThe component element is available as `this.element`.\n\n",
        "template": [
          {
            "types": [
              {
                "type": "can-control.eventDescription"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-control.eventHandler"
              }
            ]
          }
        ]
      }
    ],
    "title": "events",
    "name": "can-component.prototype.events",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.extend": {
    "src": {
      "path": "node_modules/can-component/docs/extend.md"
    },
    "body": "\n\n\n## Use\n\nNote that inheriting from components works differently than other CanJS APIs. You can’t call `.extend` on a particular component to create a “subclass” of that component.\n\nInstead, components work more like HTML elements. To reuse functionality from a base component, build on top of it with parent components that wrap other components in their view and pass any needed viewModel properties via attributes.\n\n",
    "description": "\nDefine the behavior of a custom element.\n",
    "title": "extend",
    "name": "can-component.extend",
    "type": "function",
    "parent": "can-component.static",
    "signatures": [
      {
        "code": "Component.extend(prototype)",
        "description": "\n\nExtends the [can-component] [can-construct constructor function] with prototype\nproperties and methods.  Registers the component by its [can-component::tag] with\n[can-view-callbacks.tag can-view-callbacks.tag].\n\n```js\nvar Component = require(\"can-component\");\nvar stache = require(\"can-stache\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar VM = DefineMap.extend({ ... });\n\nComponent.extend({\n  tag: \"tag-name\",\n  ViewModel: VM,\n  view: stache(\" .... \")\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "prototype",
            "description": "An object set as the prototype of the\nconstructor function. You will typically provide the following values\non the prototype object:\n\n  - __tag__ {[can-component.prototype.tag]} - Defines the\n  tag on which instances of the component constructor function will be\n  created.\n\n  - __ViewModel__ {[can-component.prototype.ViewModel]} - Specifies an object\n  that is used to render the component’s view.\n\n  - __view__ {[can-component.prototype.view]} - Specifies the view\n  rendered within the custom element.\n\nAnd sometimes the following values are provided:\n\n  - __events__ {[can-component.prototype.events]} - Defines events on\n  dom elements or observable objects the component listens to.\n\n  - __helpers__ {[can-component.prototype.helpers]} - Specifies mustache helpers\n  used to render the component’s view.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "prototype",
      "description": "An object set as the prototype of the\nconstructor function. You will typically provide the following values\non the prototype object:\n\n  - __tag__ {[can-component.prototype.tag]} - Defines the\n  tag on which instances of the component constructor function will be\n  created.\n\n  - __ViewModel__ {[can-component.prototype.ViewModel]} - Specifies an object\n  that is used to render the component’s view.\n\n  - __view__ {[can-component.prototype.view]} - Specifies the view\n  rendered within the custom element.\n\nAnd sometimes the following values are provided:\n\n  - __events__ {[can-component.prototype.events]} - Defines events on\n  dom elements or observable objects the component listens to.\n\n  - __helpers__ {[can-component.prototype.helpers]} - Specifies mustache helpers\n  used to render the component’s view.\n\n\n"
    },
    "comment": " "
  },
  "can-component.prototype.leakScope": {
    "src": {
      "path": "node_modules/can-component/docs/leakscope.md"
    },
    "body": "\n## Use\n\nA component’s [can-component::leakScope leakScope] option controls if a\ncomponent’s view can access the component’s outer scope and the\nuser content can read the component’s view model.\n\nLet’s define what __outer scope__, __component’s view__ and __user content__ mean.\n\nIf I have a `<hello-world>` component in a view like:\n\n```\n{{#data}}\n\t<hello-world>{{subject}}</hello-world>\n{{/data}}\n```\n\nThe __outer scope__ of `<hello-world>` has `data` as its context.  The __user content__ of\n`<hello-world>` is the view between its tags.  In this case, the __user content__\nis `{{subject}}`.\n\nFinally, if `<hello-world>` is defined like:\n\n```\nComponent.extend({\n  tag: \"hello-world\",\n  view: stache(\"{{greeting}} <content/>{{exclamation}}\")\n})\n```\n\n`{{greeting}} <content/>{{exclamation}}` represents the __component’s view__.\n\n## Using outer scope in component view\n\nIf `leakScope` is `true`, the __component’s view__ can read the data in the outer scope and will\nsee `name: \"John\"` overwriting `name: \"World\"` in the component’s viewModel instance in the following example.\n\nIf the following component is defined:\n```js\nComponent.extend({\n\ttag: 'hello-world',\n\tleakScope: true, // changed to true instead of the default value\n\tViewModel: {name: \"World\"},\n\tview: stache(\"Hello {{name}}\")\n});\n```\nWith this data in the outer scope:\n```js\n{ name: \"John\" }\n```\nAnd used like so:\n\n    <hello-world />\n\nIf `leakScope` is `true` it will render:\n\n    <hello-world>Hello John</hello-world>\n\nIf `leakScope` is `false` it will render:\n\n    <hello-world>Hello World</hello-world>\n\n## Using viewModel in user content\n\nif `leakScope` is `true`, the __user content__ is able to see the name property on the component’s\nviewModel instance in the following example. Else, name won't be seen.\n\nIf the following component is defined:\n```js\nComponent.extend({\n\ttag: 'hello-world',\n\tleakScope: true, // changed to true instead of the default value\n\tViewModel: {name: \"World\"},\n\tview: stache(\"Hello <content />\")\n});\n```\nAnd used like so:\n\n    <hello-world>{{name}}</hello-world>\n\nIf `leakScope` is `true` it will render:\n\n    <hello-world>Hello World</hello-world>\n\nIf `leakScope` is `false` it will render:\n\n    <hello-world>Hello </hello-world>\n\n",
    "description": "Allow reading the outer scope values from a component’s view and a component’s viewModel values in the user content.\n\n",
    "types": [
      {
        "type": "Boolean",
        "description": "`false` limits reading to:\n\n- the component’s viewModel from the component’s view, and\n- the outer scope values from the user content.\n\n`true` adds the ability to read:\n\n- the outer [can-view-scope scope] values from the component’s view, and\n- the component’s [can-component.prototype.ViewModel] values from the user content.\n\nThe default value is `false`.\n\nTo change leakScope from the default\n```js\nComponent.extend({\n\ttag: \"my-component\",\n\tleakScope: true,\n\tViewModel: { message: \"Hello World!\" },\n\tview: stache(\"{{message}}\")\n})\n```\n\nLeaving `leakScope` as the default `false` is useful for hiding and protecting\ninternal details of `Component`, potentially preventing accidental\nclashes. It can be helpful to set it to `true` if you, for example, wanted to customize __user content__\nbased on some value in the component’s ViewModel.\n"
      }
    ],
    "title": "leakScope",
    "name": "can-component.prototype.leakScope",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.tag": {
    "src": {
      "path": "node_modules/can-component/docs/tag.md"
    },
    "body": "\n",
    "description": "\nSpecifies the HTML tag (or node-name) the [can-component] will be created on.\n",
    "types": [
      {
        "type": "String",
        "description": "The tag name the [can-component]\nwill be created on.  Tag names are typically lower cased and\nhyphenated like: `foo-bar`.  Components register their\ntag with [can-view-callbacks.tag tag].\n\n\n"
      }
    ],
    "title": "tag",
    "name": "can-component.prototype.tag",
    "type": "property",
    "parent": "can-component.prototype"
  },
  "can-component.prototype.view": {
    "src": {
      "path": "node_modules/can-component/docs/view.md"
    },
    "body": "\n\n\n## Use\n\nThe view specified by the `view` property works similar to\nthe [http://www.w3.org/TR/shadow-dom/ W3C Shadow DOM proposal]. It represents the contents\nof a custom element, while being able to reposition the user provided __source__ elements\nwith the [can-component/content] tag.\n\nThere are three things to understand about a [can-component]’s view:\n\n - It is inserted into the component’s tag.\n - It is rendered with access to the component instance’s viewModel.\n - Any [can-component/content `<content>`] tags within the view act as insertion points for the source elements.\n\nThe following example demonstrates all three features:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/my_greeting_full.html'></div>\n\nThe following explains how each part works:\n\n__Component:__\n\n```js\nComponent({\n\ttag: \"my-greeting\",\n\tview: stache(\"<h1><content/> - {{title}}</h1>\"),\n\tViewModel: DefineMap.extend({\n\t\ttitle: {\n\t\t\tvalue: \"can-component\"\n\t\t}\n\t})\n});\n```\n\nThis registers a component for elements like `<my-greeting>`. Its view\nwill place an `<h1>` element directly within `<my-greeting>` and put\nthe original contents of `<my-greeting>` within the beginning of `<h1>`. The component’s\n[can-component::ViewModel] adds a title value.\n\n__Source view:__\n\n```html\n<header>\n  <my-greeting>\n     {{site}}\n  </my-greeting>\n</header>\n```\n\nThe source view is the view that\nuses `<my-greeting>`.  In the demo, this is defined within a `<script>`\ntag.\n\nNotice:\n\n - There is content within `<my-greeting>`.  This is called the __light__ or __user__ content.\n - The content looks for a `site` value.\n\n__Source data:__\n\n\t\tstache(\"...\")({\n\t\t\tsite: \"CanJS\"\n\t\t})\n\nThis is how we render the source view that uses `<my-greeting>`. The view is rendered with `site` in its [can-component::ViewModel].\n\n__HTML Result:__\n\n    <header>\n      <my-greeting>\n        <h1>CanJS - can-component</h1>\n      </my-greeting>\n    </header>\n\nThis is the result of the view transformations. The\n__user__ content within the original `<my-greeting>` is placed within the start of the `<h1>`\ntag.  Also, notice that the __user__ content is able to access data from\nthe source data.\n\nThe following sections break this down more.\n\n\n## View insertion\n\nThe view specified by `view` is rendered directly within the custom tag.\n\nFor example the following component:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1>Hello There</h1>\")\n    });\n\nWith the following source html:\n\n    <header>\n      <my-greeting></my-greeting>\n    </header>\n\nProduces the following html:\n\n    <header>\n      <my-greeting><h1>Hello There</h1></my-greeting>\n    </header>\n\nHowever, if there was existing content within the source html, like:\n\n    <header>\n      <my-greeting>DO REMOVE ME!!!</my-greeting>\n    </header>\n\nthat content is removed, and replaced by the component’s view:\n\n    <header>\n      <my-greeting><h1>Hello There</h1></my-greeting>\n    </header>\n\n### The `<content>` element\n\nUse the `<content>` element to place the source content in the\ncomponent’s element within the component’s\nview. For example, if we change the component to look like:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1><content/></h1>\")\n    });\n\nand rendered with source html, like:\n\n    <my-greeting>Hello World</my-greeting>\n\nit produces:\n\n    <my-greeting><h1>Hello World</h1></my-greeting>\n\n### `<content>` element default content\n\nIf the user does not provide source content, the html\nbetween the `<content>` tags will be used. For example, if we\nchange the component to look like:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1><content>Hello World</content></h1>\")\n    });\n\nand rendered with source html like:\n\n    <my-greeting></my-greeting>\n\nit produces:\n\n    <my-greeting><h1>Hello World</h1></my-greeting>\n\n",
    "description": "\nProvides a view to render directly within the component’s element. The view is rendered with the\ncomponent’s [can-component::ViewModel] instance.  `<content/>` elements within the view are replaced by the source elements within the component’s tag.\n",
    "types": [
      {
        "type": "can-stache.renderer",
        "description": "A [can-stache.renderer] returned by [can-stache]. For example:\n\n    Component({\n      tag: \"my-tabs\",\n      view: stache(\"<ul>{{#panels}}<li>{{title}}</li> ...\")\n    });\n\n"
      }
    ],
    "title": "view",
    "name": "can-component.prototype.view",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.view-model": {
    "src": {
      "path": "node_modules/can-component/docs/view-model.md"
    },
    "body": "\n",
    "description": "\nReturn the view model instance or type with which the component’s [can-component.prototype.view]\nis rendered.  This is used when more fine grained control is needed over [can-component::ViewModel].\n",
    "title": "viewModel",
    "name": "can-component.prototype.view-model",
    "type": "function",
    "parent": "can-component.prototype",
    "signatures": [
      {
        "code": "function(properties, parentScope, element)",
        "description": "\n\nThe `viewModel` function takes the `properties` and values that are used to\ntypically initialize a [can-component.prototype.ViewModel], the\n[can-view-scope] the component is rendered within, and the component’s element\nand returns either the view-model instance or ViewModel type that the component’s [can-component.prototype.view]\nis rendered with.\n\nThis is typically used only for special situations where a custom scope or custom bindings\nneed to be setup.\n\n```\nvar Component = require(\"can-component\");\nvar Scope = require(\"can-view-scope\");\n\nComponent.extend({\n\ttag: \"my-element\",\n\tviewModel: function(properties, scope, element){\n\t\tvar vm =  new DefineMap(properties);\n\t\t// do special stuff ...\n\t\treturn vm;\n\t}\n});\n\nstache(\"<my-element {first}='firstName' last='Meyer'/>\")({\n  firstName: \"Justin\",\n  middleName: \"Barry\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "properties",
            "description": "An object of values specified by the custom element’s attributes. For example, a view rendered like:\n\n    stache(\"<my-element title='name'></my-element>\")({\n      name: \"Justin\"\n    })\n\nCreates an instance of following control:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties){\n    \t  properties.title //-> \"Justin\";\n    \t}\n    })\n\nAnd calls the viewModel function with `properties` like `{title: \"Justin\"}`.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope"
              }
            ],
            "name": "parentScope",
            "description": "\n\nThe viewModel the custom tag was found within.  By default, any attribute’s values will\nbe looked up within the current viewModel, but if you want to add values without needing\nthe user to provide an attribute, you can set this up here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope){\n    \t  parentScope.get('middleName') //-> \"Barry\"\n    \t}\n    });\n\nNotice how the `middleName` value is looked up in `my-element`’s parent scope.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope, el){\n\t\t  var vm = new DefineMap({clicks: 0});\n    \t  domEvent.addEventListener.call(el, \"click\", function(){\n\t\t    vm.clicks++;\n\t\t  });\n\t\t  return vm;\n    \t}\n    });\n\nThis example should be done with the [can-component::events] object instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns one of the following.\n\n   - An observable map or list type.\n   - The prototype of an observable map or list type that will be used to render the component’s view.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "name": "element",
      "description": "The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope, el){\n\t\t  var vm = new DefineMap({clicks: 0});\n    \t  domEvent.addEventListener.call(el, \"click\", function(){\n\t\t    vm.clicks++;\n\t\t  });\n\t\t  return vm;\n    \t}\n    });\n\nThis example should be done with the [can-component::events] object instead.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Map"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns one of the following.\n\n   - An observable map or list type.\n   - The prototype of an observable map or list type that will be used to render the component’s view.\n"
    }
  },
  "can-compute.async": {
    "src": {
      "path": "node_modules/can-compute/docs/async.md"
    },
    "body": "\n\n## Use\n\nThe following compute is a live list of todos for a given \nuserId. `todos` value would alternate between `null` and a Todo.List as `userId` changes.\n\n\n    var userId = compute(5)\n    \n    var todos = compute.async(null, function(oldTodoList, setValue){\n      Todo.findAll({ userId: userId() }, function(todos){\n        setValue(todos)\n      });\n      return null;\n    });\n\n\nThe following replaces the list in place:\n\n    var userId = compute(5)\n    \n    var todos = compute.async(new Todo.List(), function(todoList, setValue){\n      todoList.replace( Todo.findAll({ userId: userId() })\n      return todoList;\n    });\n\n",
    "description": "\nCreate a compute that can set its value after the computed function has been called.\n",
    "title": "async",
    "name": "can-compute.async",
    "type": "function",
    "parent": "can-compute",
    "release": "2.1",
    "hide": true,
    "signatures": [
      {
        "code": "compute.async(initialValue, computed(currentValue, setValue(newValue) )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "The",
            "description": "initial value of the compute.\n"
          },
          {
            "types": [
              {
                "type": "can-compute.asyncComputer"
              }
            ],
            "name": "computed",
            "description": "A function \nthat returns the current value of the compute and can optionally later call \nits `setValue` callback to update the value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "Returns a compute, but a compute that will \npossibly not have the correct value unless it is bound to.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute.asyncComputer"
        }
      ],
      "name": "computed",
      "description": "A function \nthat returns the current value of the compute and can optionally later call \nits `setValue` callback to update the value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "Returns a compute, but a compute that will \npossibly not have the correct value unless it is bound to.\n"
    },
    "comment": " "
  },
  "can-compute.computed.addEventListener": {
    "src": {
      "path": "node_modules/can-compute/docs/addEventListener.md"
    },
    "body": "\n",
    "description": "\nListen to when a compute changes value.\n",
    "title": "addEventListener",
    "name": "can-compute.computed.addEventListener",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.addEventListener(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nage.addEventListener('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-compute.computed.ChangeEvent": {
    "src": {
      "path": "node_modules/can-compute/docs/change.md"
    },
    "body": "\n",
    "description": "\nEvent fired when the value of the [can-compute.computed] changes.\n",
    "type": "typedef",
    "title": "change",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-compute.computed.ChangeEvent",
    "parent": "can-compute/computed/events",
    "signatures": [
      {
        "description": "handler(event, newValue, oldValue)\n\nHandlers registered on `\"change\"` events will be called back as follows:\n\n```js\nvar age = compute(33);\n\nage.on('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newVal",
            "description": "The new value of the compute."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "oldVal",
            "description": "The old value of the compute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "oldVal",
      "description": "The old value of the compute.\n"
    }
  },
  "can-compute.asyncComputer": {
    "src": {
      "path": "node_modules/can-compute/docs/async_computer.md"
    },
    "body": "\n",
    "description": "\nA function that determines a value for an [can-compute.async async compute].\n",
    "type": "typedef",
    "title": "asyncComputer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "If a `setVal` argument is not provided, the return value\nis set as the current value of the compute.  If `setVal` is provided and\nundefined is returned, the current value remains until `setVal` is called.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The last set value of the compute.  This should be returned\nif you are doing an in-place compute. \n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "setVal",
            "description": "Called to update the value \nof the compute at a later time. \n"
          }
        ],
        "description": "The function callback to [can-compute.async] that determines\nthe value of the compute.\n"
      }
    ],
    "name": "can-compute.asyncComputer",
    "parent": "can-compute",
    "release": "2.1",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newVal"
            }
          ]
        }
      ],
      "optional": true,
      "name": "setVal",
      "description": "Called to update the value \nof the compute at a later time. \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "If a `setVal` argument is not provided, the return value\nis set as the current value of the compute.  If `setVal` is provided and\nundefined is returned, the current value remains until `setVal` is called.\n"
    }
  },
  "can-compute.computeSettings": {
    "src": {
      "path": "node_modules/can-compute/docs/compute_settings.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "computeSettings",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "description": "A function that retrieves and returns the current value of the compute."
          },
          {
            "name": "set",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "description": "A function that is used when setting a new value of the compute.\n\nA function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can-computed] and the current value. If\n`set` returns a value, it is used to compare to the current value of the compute. Otherwise,\n`get` is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.\n\n`newVal` is the value being set, while `oldVal` is the previous value in the compute.\n"
          },
          {
            "name": "on",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ],
                    "name": "updated"
                  }
                ]
              }
            ],
            "description": "Called to setup binding to dependency events. Call `updated` when the compute's value needs to be updated.\n"
          },
          {
            "name": "off",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "Called to teardown binding.\n"
          }
        ]
      }
    ],
    "name": "can-compute.computeSettings",
    "release": "2.1",
    "parent": "can-compute"
  },
  "can-compute.computed.off": {
    "src": {
      "path": "node_modules/can-compute/docs/off.md"
    },
    "body": "\n",
    "description": "\nRemove an event listener.\n",
    "title": "off",
    "name": "can-compute.computed.off",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.off(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nvar handler = function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n}\n\nage.on('change', handler);\n\nage(34);\n\nage.off('change', handler)\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be removed.  This has to be the same function that was passed to [can-compute.computed.on].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be removed.  This has to be the same function that was passed to [can-compute.computed.on].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-compute.computed.on": {
    "src": {
      "path": "node_modules/can-compute/docs/on.md"
    },
    "body": "\n",
    "description": "\nListen to when a compute changes value.\n",
    "title": "on",
    "name": "can-compute.computed.on",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.on(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nage.on('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-compute.computed.removeEventListener": {
    "src": {
      "path": "node_modules/can-compute/docs/removeEventListene.md"
    },
    "body": "\n",
    "description": "\nListen to when a compute changes value.\n",
    "title": "removeEventListener",
    "name": "can-compute.computed.removeEventListener",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.removeEventListener(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nage.removeEventListener('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-compute/computed/events": {
    "name": "can-compute/computed/events",
    "title": "events",
    "type": "group",
    "parent": "can-compute.computed",
    "description": "",
    "order": 0
  },
  "can-compute/computed/methods": {
    "name": "can-compute/computed/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-compute.computed",
    "description": "",
    "order": 0
  },
  "can-compute.computed": {
    "src": {
      "path": "node_modules/can-compute/docs/computed.md"
    },
    "body": "\n## Use\n\nA compute instance is created with [can-compute] and used as an observable value. Computes are useful to provide a value representative of multiple other observables:\n\n```js\nvar person = new Person({\n\tfirst: \"Matthew\",\n\tlast: \"Phillips\"\n});\n\nvar fullName = compute(function(){\n\treturn person.first + \" \" + person.last;\n});\n\nconsole.log(fullName()); // -> \"Matthew Phillips\".\n```\n\nCalling the compute with a value will cause it to run as a setter function:\n\n```js\nvar count = compute(0);\n\nconsole.log(count()); // -> 0\n\ncount(5);\n\nconsole.log(count()); // -> 5\n```\n\nThis depends on how the [can-compute getterSetter] is defined, and can adjust how it handles setters:\n\n```js\nvar plusOne = compute(function(val){\n\tif(val) {\n\t\treturn val + 1;\n\t} else {\n\t\treturn 1;\n\t}\n});\n\nconsole.log(plusOne()); // -> 1\n\nplusOne(5);\n\nconsole.log(plusOne()); // -> 6\n```\n\n",
    "description": "A derived value from other computes and observable maps. \n",
    "title": "compute",
    "name": "can-compute.computed",
    "type": "function",
    "parent": "can-compute",
    "signatures": [
      {
        "code": "compute([newVal])",
        "description": "\n\nGets the compute's value if no arguments are provided, otherwise calls the compute's setter with the value passed as the first argument.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "If the compute is called with an argument, the first argument is used\nto set the compute to a new value. This may trigger a\n`\"change\"` event that can be listened for with [can-computed.bind].\n\nIf the compute is called without any arguments (`compute()`), it simply returns\nthe current value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The current value of the compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "newVal",
      "description": "If the compute is called with an argument, the first argument is used\nto set the compute to a new value. This may trigger a\n`\"change\"` event that can be listened for with [can-computed.bind].\n\nIf the compute is called without any arguments (`compute()`), it simply returns\nthe current value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The current value of the compute.\n"
    },
    "comment": " "
  },
  "can-connect-cloneable": {
    "src": {
      "path": "node_modules/can-connect-cloneable/docs/can-connect-cloneable.md"
    },
    "body": "\n## Use\n\n`can-connect-cloneable` can be used with `[can-define/map/map DefineMaps]` or legacy `[can-map CanMaps]`. To make `Map` instances clonable, include `can-connect-cloneable` and call it with the `Map` constructor as the parameter. This adds a `clone` method to future instances of `Map`.\n\nAn instance and its clone have a special relationship:\n\n1. Changes to the original instance propogate automatically to the clone.\n2. Changes to the cloned instance do *not* propogate to the original until you call the clone’s `save` method.\n\n### Using DefineMap (`[can-define/map/map]`)\n\nApply the mixin:\n\n```javascript\nvar makeCloneable = require(\"can-connect-cloneable\");\nvar DefineMap = require(\"can-define/map/map\");\nvar connect = require(\"can-connect\");\n\n// Extend DefineMap\nvar MyDefineMap = DefineMap.extend({ name: \"string\" });\n\n// create the connection\nvar connection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/can/map/map\")\n],{\n    Map: MyDefineMap,\n    url: \"/api/endpoint\"\n});\n\n// apply the mixin\nmakeCloneable(MyDefineMap);\n```\n\nUse the clone method:\n\n```javascript\nvar original = new MyDefineMap({ name: \"Kyle\" });\nvar clone = original.clone();\n```\n\nMake changes to the clone and save, updating the original:\n\n```javascript\n// Change name on the clone instance\nclone.name = \"Justin\";\n\n// The value on the clone changes, but not the original value\noriginal.name; // -> \"Kyle\"\nclone.name; // -> \"Justin\"\n\n// Once the clone is saved, the clone values propogate to the original\nclone.save();\noriginal.name; // -> \"Justin\"\nclone.name; // -> \"Justin\"\n\n```\n\nMake changes to the original, updating the clone:\n\n```javascript\noriginal.name; // -> \"Justin\"\nclone.name; // -> \"Justin\"\n\n// Change name on the original instance\noriginal.name = \"Kyle\";\n\n// The value on the clone changes automatically\noriginal.name; // -> \"Kyle\"\nclone.name; // -> \"Kyle\"\n\n```\n\n### Using CanMap (`[can-map]`)\n\nApply the mixin:\n\n```javascript\nvar makeCloneable = require(\"can-connect-cloneable\");\nvar CanMap = require(\"can-map\");\nrequire(\"can-map-define\");\nvar connect = require(\"can-connect\");\n\n// Extend CanMap\nvar MyCanMap = CanMap.extend({\n  define: {\n    name: {\n      type: \"string\"\n    }\n  }\n});\n\n// create the connection\nvar connection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/can/map/map\")\n],{\n    Map: MyCanMap,\n    url: \"/api/endpoint\"\n});\n\n// apply the mixin\nmakeCloneable(MyCanMap);\n```\n\nUse the clone method:\n\n```javascript\nvar original = new MyCanMap({ name: \"Kyle\" });\nvar clone = original.clone();\n```\n\nMake changes to the clone and save, updating the original:\n\n```javascript\n// Change name on the clone instance\nclone.attr(\"name\", \"Justin\");\n\n// The value on the clone changes, but not the original value\noriginal.attr(\"name\"); // -> \"Kyle\"\nclone.attr(\"name\"); // -> \"Justin\"\n\n// Once the clone is saved, the clone values propogate to the original\nclone.save();\noriginal.attr(\"name\"); // -> \"Justin\"\nclone.attr(\"name\"); // -> \"Justin\"\n\n```\n\nMake changes to the original, updating the clone:\n\n```javascript\noriginal.attr(\"name\"); // -> \"Justin\"\nclone.attr(\"name\"); // -> \"Justin\"\n\n// Change name on the original instance\noriginal.attr(\"name\", \"Kyle\");\n\n// The value on the clone changes automatically\noriginal.attr(\"name\"); // -> \"Kyle\"\nclone.attr(\"name\"); // -> \"Kyle\"\n```\n\n",
    "description": "Makes mutable clones of [can-connect]’d maps. Changes to the clone save back to the original; likewise, changes to the original propagate to the clone. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect-cloneable",
    "parent": "can-data-modeling",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-connect-cloneable/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-connect": "^1.5.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Allows you to make mutable clones of can-connected maps and save changes back to the original",
      "devDependencies": {
        "can-define": "^1.2.0",
        "can-fixture": "^1.1.0",
        "can-list": "^3.1.0",
        "can-map": "^3.1.0",
        "can-map-define": "^3.1.0",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.3.0",
        "donejs-cli": "^1.0.1",
        "jshint": "^2.9.1",
        "steal": "^1.2.4",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.1.2",
        "testee": "^0.6.0"
      },
      "directories": {
        "doc": "docs",
        "test": "test"
      },
      "homepage": "https://github.com/canjs/can-connect-cloneable",
      "keywords": [
        "clone",
        "plugin",
        "canjs"
      ],
      "license": "MIT",
      "main": "can-connect-cloneable",
      "name": "can-connect-cloneable",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-connect-cloneable.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm run build && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "0.2.2"
    },
    "signatures": [
      {
        "code": "makeCloneable(Type)",
        "description": "\n\nMakes `Type` cloneable by giving its instances a `clone` method.\n\n```javascript\nvar DefineMap = require(\"can-define/map/map\");\nvar makeCloneable = require(\"can-connect-cloneable\");\n\nvar MyDefineMap = DefineMap.extend({ name: \"string\" });\nmakeCloneable(MyDefineMap);\n\nvar original = new MyDefineMap({ name: \"Kyle\" });\nvar clone = original.clone();\nclone.name; // -> \"Kyle\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-map"
              },
              {
                "type": "can-define/map/map"
              }
            ],
            "name": "Type",
            "description": "The DefineMap or CanMap you want to make clonable\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-map"
        },
        {
          "type": "can-define/map/map"
        }
      ],
      "name": "Type",
      "description": "The DefineMap or CanMap you want to make clonable\n\n"
    },
    "comment": " "
  },
  "can-connect-feathers.behaviors": {
    "name": "can-connect-feathers.behaviors",
    "title": "behaviors",
    "type": "group",
    "parent": "can-connect-feathers",
    "description": "",
    "order": 0
  },
  "can-connect-feathers": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/can-connect-feathers.md"
    },
    "body": "\nBoth of the included behaviors require a Feathers Client instance.  Here is a basic setup: \n\n```js\n// models/feathers.js\nvar feathers = require('feathers/client');\nvar socketio = require('feathers-socketio/client');\nvar io = require('socket.io-client/dist/socket.io');\nvar hooks = require('feathers-hooks');\nvar auth = require('feathers-authentication-client');\nvar socket = io('');\n\nvar feathersClient = feathers()\n  .configure(hooks())\n  .configure(socketio(socket))\n  .configure(auth());\n\nmodule.exports = feathersClient;\n```\n\n> Pro tip: If you are planning on using Done-SSR, exchange the `socket.io-client/dist/socket.io` module for `steal-socket.io` in the above example.\n",
    "description": "Integrate can-connect with the FeathersJS Client \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n`can-connect-feathers` is a set of behaviors for integrating [can-connect] with [Feathers Client](https://docs.feathersjs.com/clients/feathers.html).\n\n - The [can-connect-feathers/service/service service] behavior connects to a Feathers service.\n - The [can-connect-feathers/session/session session] behavior connects to the [feathers-authentication-client](https://docs.feathersjs.com/authentication/client.html) methods on a Feathers Client instance.\n"
      }
    ],
    "name": "can-connect-feathers",
    "parent": "can-data-modeling",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Marshall Thompson",
        "email": "marshall@creativeideal.net",
        "url": "https://github.com/icanjs"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-connect-feathers/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-observation": "^3.2.0",
        "can-util": "^3.9.0",
        "can-zone-storage": "^1.0.0",
        "feathers-authentication-popups": "^0.1.2",
        "feathers-errors": "^2.7.0",
        "jwt-decode": "^2.1.0"
      },
      "deprecated": false,
      "description": "Feathers client library for DoneJS and can-connect",
      "devDependencies": {
        "async": "^2.1.5",
        "babel-polyfill": "^6.23.0",
        "can-connect": "^1.5.0",
        "can-define": "^1.2.0",
        "can-fixture": "^1.1.0",
        "can-fixture-socket": "^0.7.0",
        "can-set": "^1.3.0",
        "concurrently": "^3.1.0",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.2.0",
        "donejs-cli": "^1.0.1",
        "feathers": "^2.0.3",
        "feathers-authentication-client": "^0.3.2",
        "feathers-hooks": "^2.0.1",
        "feathers-rest": "^1.5.0",
        "feathers-socketio": "^1.4.2",
        "generator-donejs": "^1.0.5",
        "http-server": "^0.10.0",
        "jquery": "^3.1.0",
        "jshint": "^2.9.4",
        "saucelabs": "^1.4.0",
        "socket.io-client": "^1.7.2",
        "steal": "^1.0.5",
        "steal-qunit": "^1.0.0",
        "steal-socket.io": "^4.0.8",
        "steal-tools": "^1.0.1",
        "test-saucelabs": "0.0.1",
        "testee": "^0.5.0",
        "wd": "^1.1.3"
      },
      "homepage": "https://github.com/canjs/can-connect-feathers",
      "keywords": [
        "canjs",
        "can",
        "plugin",
        "donejs",
        "feathersjs",
        "feathers",
        "client",
        "realtime"
      ],
      "main": "can-connect-feathers.js",
      "name": "can-connect-feathers",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-connect-feathers.git"
      },
      "scripts": {
        "build": "node build.js",
        "ci": "node test/test-sauce-labs.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "http-server": "http-server -p 3000 --silent",
        "install-server-deps": ". ./build-server.sh",
        "jshint": "jshint --config .jshintrc --exclude node_modules/,dist/,.vscode/,_docs/,test/server/ .",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:prerelease": "npm version prerelease && npm publish --tag pre",
        "start": "node ./test/server/src/index.js",
        "start-test": "node ./test/server/src/index.js --timeout",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "test-integration": "npm run jshint && npm run install-server-deps && concurrently 'npm run start-test' 'npm run testee-integration' ",
        "testee": "testee test/test.html --browsers firefox",
        "testee-integration": "testee test/test-integration.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.7.1"
    },
    "comment": " "
  },
  "can-connect-ndjson/DefineList.prototype.isStreaming": {
    "src": {
      "path": "node_modules/can-connect-ndjson/docs/isStreaming.md"
    },
    "body": "",
    "description": "Set to `true` on the list if underlying stream is streaming and `false` when the stream is completed. \n\n",
    "types": [
      {
        "type": "Boolean",
        "description": "\n\nBelow is an example using `isStreaming` with a `DefineList` named `todos`:\n\n```\nvar todos = Todo.getList({}).then(todos => {\n  console.log(todos.value.isStreaming);\n  return todos;\n});\n\n```\n\nHere we are using `isStreaming` in a `can-stache` template to communicate to your users that data is still being recieved from the stream:\n\n```\n  {{#if todos.value.isStreaming}}\n    <li style=\"color:#ccc\">Still loading...</li>\n  {{/if}}\n```"
      }
    ],
    "title": "isStreaming",
    "name": "can-connect-ndjson/DefineList.prototype.isStreaming",
    "type": "property",
    "parent": "can-connect-ndjson/DefineList"
  },
  "can-connect-ndjson/options": {
    "name": "can-connect-ndjson/options",
    "title": "options",
    "type": "group",
    "parent": "can-connect-ndjson",
    "description": "",
    "order": 0
  },
  "can-connect-ndjson/DefineList": {
    "name": "can-connect-ndjson/DefineList",
    "title": "DefineList methods",
    "type": "group",
    "parent": "can-connect-ndjson",
    "description": "",
    "order": 0
  },
  "can-connect-ndjson": {
    "src": {
      "path": "node_modules/can-connect-ndjson/docs/can-connect-ndjson.md"
    },
    "body": "## Use\n\nIn this example, we will connect a [can-define/map/map `DefineMap`] model to an\nNDJSON stream service. If you prefer to use a non-CanJS type, skip step 1 and\n[can-connect#Otheruse modify the behaviors] in step 2 (can/map in particular)\nto suit your data structure.\n\nFollow these steps to get started:\n#### 1. Define a model.\n\n```js\nconst DefineList = require(\"can-define/list/list\");\nconst DefineMap = require(\"can-define/map/map\");\n\n// Define model\nconst Todo = DefineMap.extend(\"Todo\", {id: \"number\", name: \"string\"});\nTodo.List = DefineList.extend(\"TodoList\", {\"#\": Todo});\n```\n\n#### 2. Include the required behaviors.\nThese four behaviors are the minumum required behaviors if you choose to use\n[can-define/map/map `DefineMap`]s and [can-define/list/list `DefineList`]s for\nthe model layer. `can-connect` is flexible and can be used with any array-like\ntype.\n\n```js\n\n//Define required behaviors, including can-connect-ndjson\nconst behaviors = [\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/can/map/map\"),\n    require(\"can-connect-ndjson\") //require NDJSON behavior\n];\n```\n\n#### 3.Create `can-connect` connection.\nLink `can-connect` to the model by attaching a connection object. The connection\nobject is created by calling `connect` with the behaviors and options. You may\nneed to pass an NDJSON-specific endpoint option if the backend serves NDJSON\nfrom a different URL.\n\n```js\nconst connect = require(\"can-connect\");\n// Create connection and pass the optional NDJSON API endpoint\nTodo.connection = connect(behaviors, {\n    Map: Todo,\n    List: Todo.List,\n    url: \"/other/endpoint\",\n    ndjson: \"/api\" //declare the NDJSON API endpoint here\n});\n```\n\n#### 4. Use the `can-connect` methods on the model.\n`getList` now uses a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)\nresponse behind the scenes. NDJSON lines read from the stream will be pushed\ninto the list instance as JavaScript objects.\n\n```js\nlet todoListPromise = Todo.getList({});\n```\n\nThe `todoListPromise` will return the list as soon as the streaming response\nstarts. At that time the list is usually empty since the response has just\nbegun. Afterwards, as JSON lines are streamed from the response, instances are\ncreated from each line and added to the list, one at a time.\n\nIf using the raw data below, each `Todo` instance in the list will contain the\nproperties from a line, eg. `{\"name\":\"first\", \"id\": 1}`\n\n```js\n//NDJSON raw data example\n{\"name\":\"first\", \"id\": 1}\\n\n{\"name\":\"second\", \"id\": 2}\\n\n{\"name\":\"third\", \"id\": 3}\\n\n{\"name\":\"fourth\", \"id\": 4}\\n\n```\n\n#### 5. Use the model with a template.\nUse `can-stache` or your favorite live-binding template language to attach your\ndata to the DOM.\n\n```js\nconst stache = require(\"can-stache\");\n\nconst template = stache(\"<ul>{{#each todos}}<li>{{name}}</li>{{/each}}</ul>\");\n\ntodoListPromise.then(list => {\n    document.body.append(template({todos: list});\n});\n```\n\nThough the list is initially empty, the template will update with new `li` elements\neach time the list is updated with a newly streamed line.\n\n#### All together\n\nWe use our `ndjsonStream` behavior to enable our model to work seamlessly with\na stream of NDJSON, which it will parse into an array of JS objects.\n\n**Note:**\n\n- you must pass the `ndjsonStream` behavior\n- if no `ndjson` option is passed, the endpoint accessed by `getListData`\n  will default to the `url`.\n\n```js\nconst connect = require(\"can-connect\");\nconst DefineList = require(\"can-define/list/list\");\nconst DefineMap = require(\"can-define/map/map\");\nconst stache = require(\"can-stache\");\n\n//Define template\nconst template = stache(\"<ul>{{#each todos}}<li>{{name}}</li>{{/each}}</ul>\");\n\n// Define model\nconst Todo = DefineMap.extend(\"Todo\", {id: \"number\", name: \"string\"});\nTodo.List = DefineList.extend(\"TodoList\", {\"#\": Todo});\n\n//Define required behaviors, including can-connect-ndjson\nconst behaviors = [\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/can/map/map\"),\n    require(\"can-connect-ndjson\") //require NDJSON behavior\n];\n\n// Create connection and pass the NDJSON API endpoint\nTodo.connection = connect(behaviors, {\n    Map: Todo,\n    List: Todo.List,\n    url: \"/other/endpoint\",\n    ndjson: \"/api\" //declare the NDJSON API endpoint here\n});\n\nlet todoListPromise = Todo.getList({});\n\ntodoListPromise.then(list => {\n    document.body.append(template({todos: list});\n});\n```\n## Fallback for browsers without `fetch` and `stream` support\nIn browsers that don't support `fetch` and `streams`, this module will fall back to the `baseConnection` configuration. The `baseConnection` and will do a `GET` request to the `url` endpoint and expects to receive JSON data. \n\nNote: the stream state properties such as `streamError` or `isStreaming` are not available when falling back.\n\nTry out [the demo](https://github.com/canjs/can-connect-ndjson) to see how to works.\n\n## Using `fetch` with NDJSON and `ReadableStreams`\nLearn more about using the [`fetch API`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)\nwith NDJSON and `ReadableStreams` [here]().\n\n## Parsing a stream of NDJSON to a stream of JS Objects\nLearn about how we parse the NDJSON stream into a ReadableStream of JS objects using [can-ndjson-stream `can-ndjson-stream`].\n\n## Creating an NDJSON service using Express\nCheckout [this tutorial]() or the [can-ndjson-stream#CreatinganNDJSONstreamservicewithNodeJS_ `can-ndjson-stream`]\nmodule documentation.\n\n",
    "description": "Get a list of data from an NDJSON service endpoint. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect-ndjson",
    "parent": "can-data-modeling",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-connect-ndjson/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-connect": "^1.3.6",
        "can-define": "^1.0.16",
        "can-namespace": "^1.0.0",
        "can-ndjson-stream": "^0.1.0",
        "can-reflect": "^1.2.2",
        "can-util": "^3.3.0",
        "mocha": "^3.4.2",
        "natives": "^1.1.0",
        "request": "^2.81.0"
      },
      "deprecated": false,
      "description": "[![Join the chat at https://gitter.im/canjs/canjs](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/canjs/canjs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://github.com/canjs/can-connect-ndjson/blob/master/license.md) [![npm version](https://badge.fury.io/js/can-connect-ndjson.svg)](https://www.npmjs.com/package/can-connect-ndjson) [![Travis build status](https://travis-ci.org/canjs/can-connect-ndjson.svg?branch=master)](https://travis-ci.org/canjs/can-connect-ndjson) [![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/canjs/can-connect-ndjson?branch=master&svg=true)](https://ci.appveyor.com/project/matthewp/can-connect-ndjson) [![Coverage status](https://coveralls.io/repos/github/canjs/can-connect-ndjson/badge.svg?branch=master)](https://coveralls.io/github/canjs/can-connect-ndjson?branch=master) [![Greenkeeper badge](https://badges.greenkeeper.io/canjs/can-connect-ndjson.svg)](https://greenkeeper.io/)",
      "devDependencies": {
        "can-stache": "^3.0.19",
        "detect-cyclic-packages": "^1.1.0",
        "http-server": "^0.10.0",
        "jshint": "^2.9.5",
        "saucelabs": "^1.4.0",
        "steal": "^1.0.5",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "test-saucelabs": "0.0.1",
        "testee": "^0.3.2"
      },
      "homepage": "https://github.com/canjs/can-connect-ndjson#readme",
      "keywords": [],
      "licenses": [
        {
          "type": "MIT",
          "url": "http://opensource.org/licenses/mit-license.php"
        }
      ],
      "main": "can-connect-ndjson",
      "name": "can-connect-ndjson",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-connect-ndjson.git"
      },
      "scripts": {
        "build": "node build.js",
        "ci": "npm run build && npm run test && node ./test/test-sauce-labs.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "http-server": "http-server -p 3000 --silent",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "test": "npm run detect-cycle && npm run jshint && node test/test.js",
        "testee": "testee ./test/test.html --browsers chrome",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-connect-ndjson",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "0.1.1"
    },
    "signatures": [
      {
        "code": "ndjsonStream( baseConnection )",
        "description": "\n\nOverwrites the [can-connect/connection.getListData] and\n[can-connect/constructor.hydrateList] methods on the [can-connect] base connection to enable [NDJSON](http://www.ndjson.org/) streaming using\n[`Fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) with\n[`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)s. Falls back to default `baseConnection` in browsers that do not support `Fetch` and `ReadableStream`.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect-ndjson/DefineList.prototype.streamError": {
    "src": {
      "path": "node_modules/can-connect-ndjson/docs/streamError.md"
    },
    "body": "",
    "description": "Set on the list if the underlying stream has an error. \n\n",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nBelow is an example using `streamError` with a `DefineList` named `todos`:\n\n```\nconst todos = Todo.getList({}).then(todos => {\n  return todos;\n}).then(todos => {\n  if (todos.value.streamError) {\n    console.error(todos.value.streamError)\n  }\n  return todos;\n});\n\n```\n\nHere we are using `streamError` in a `can-stache` template to communicate to your users that data is still being recieved from the stream:\n\n```\n{{#if todos.value.streamError}}\n  <li style=\"color:red\">NDJSON Stream Error: {{todos.value.streamError.message}}</li>\n{{/if}}\n```"
      }
    ],
    "title": "streamError",
    "name": "can-connect-ndjson/DefineList.prototype.streamError",
    "type": "property",
    "parent": "can-connect-ndjson/DefineList"
  },
  "can-connect-ndjson.ndjson": {
    "src": {
      "path": "node_modules/can-connect-ndjson/docs/ndjson.md"
    },
    "body": "",
    "description": "Specify the URL of an NDJSON service endpoint. If not specified or not supported in the browser, it falls back to the `url` endpoint. \n\n",
    "types": [
      {
        "type": "String",
        "description": "\n\nBelow is an example of how to pass the `ndjson` option into your connection:\n\n```\nconnect(behaviors, {\n    url: \"/other/endpoint\", //fallback endpoint\n    ndjson: \"/api\" //NDJSON endpoint\n});\n```\n"
      }
    ],
    "title": "ndjson",
    "name": "can-connect-ndjson.ndjson",
    "type": "property",
    "parent": "can-connect-ndjson/options"
  },
  "can-connect/cache-requests/cache-requests.data": {
    "name": "can-connect/cache-requests/cache-requests.data",
    "title": "data interface",
    "type": "group",
    "parent": "can-connect/cache-requests/cache-requests",
    "description": "",
    "order": 0
  },
  "can-connect/cache-requests/cache-requests.algebra": {
    "name": "can-connect/cache-requests/cache-requests.algebra",
    "title": "algebra",
    "type": "group",
    "parent": "can-connect/cache-requests/cache-requests",
    "description": "",
    "order": 0
  },
  "can-connect/cache-requests/cache-requests": {
    "type": "module",
    "name": "can-connect/cache-requests/cache-requests",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 6,
      "codeLine": 99,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n\n## Use\n\nUse `cache-requests` in combination with a cache like [can-connect/data/memory-cache/memory-cache] or\n[can-connect/data/localstorage-cache/localstorage-cache].  For example, to make it so response data is cached\nin memory:\n\n```\nvar memoryCache = require(\"can-connect/data/memory-cache/\");\nvar dataUrl = require(\"can-connect/data/url/\");\nvar cacheRequests = require(\"can-connect/cache-requests/\");\n\nvar cacheConnection = connect([memoryCache], {});\nvar todoConnection = connect([dataUrl, cacheRequests],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\"\n});\n```\n\nNow if today's todos are loaded:\n\n```\ntodoConnection.getListData({due: \"today\"});\n```\n\nAnd later, a subset of those todos are loaded:\n\n```\ntodoConnection.getListData({due: \"today\", status: \"critical\"});\n```\n\nThe subset will be created from the original request's data.\n\n## Algebra Usage\n\n`cache-requests` can also \"fill in\" the data the cache is missing if you provide it the necessary [can-set set algebra].\n\nFor example, if you requested paginated data like:\n\n```\ntodoConnection.getListData({start: 1, end: 10})\n```\n\nAnd then later requested:\n\n```\ntodoConnection.getListData({start: 1, end: 20})\n```\n\n... with the appropriate algebra configuration, `cache-requests` will only request `{start: 11, end: 20}`, merging\nthat response with the data already present in the cache.\n\nThat configuration looks like:\n\n```\nvar algebra = new set.Algebra( set.props.rangeInclusive(\"start\",\"end\") );\n\nvar cacheConnection = connect([memoryCache], {algebra: algebra});\nvar todoConnection = connect([dataUrl, cacheRequests], {\n  cacheConnection: cacheConnection,\n  url: \"/todos\",\n  algebra: algebra\n})\n```\n\n**Note:** `cacheConnection` shares the same algebra configuration as the primary connection.\n\n",
    "description": "\nCache response data and use it to prevent unnecessary future requests or make future requests smaller.\n",
    "title": "cache-requests",
    "signatures": [
      {
        "code": "cacheRequests( baseConnection )",
        "description": "\n\n  Provide an implementation of [can-connect/cache-requests/cache-requests.getListData] that uses set logic to\n  determine what data is already in the [can-connect/base/base.cacheConnection cache] and what data needs to be\n  loaded from the base connection.\n\n  It then gets data from the cache and the base connection (if needed), merges it, and returns it. Any data returned\n  from the base connection is added to the cache.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "`can-connect` connection object that is having the `cache-requests` behavior added\non to it. Should already contain the behaviors that provide the [can-connect/DataInterface]\n(e.g [can-connect/data/url/url]). If the `connect` helper is used to build the connection, the behaviors will\nautomatically be ordered as required.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A `can-connect` connection containing the methods provided by `cache-requests`.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "`can-connect` connection object that is having the `cache-requests` behavior added\non to it. Should already contain the behaviors that provide the [can-connect/DataInterface]\n(e.g [can-connect/data/url/url]). If the `connect` helper is used to build the connection, the behaviors will\nautomatically be ordered as required.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A `can-connect` connection containing the methods provided by `cache-requests`.\n\n"
    },
    "comment": " "
  },
  "can-connect/cache-requests/cache-requests.getDiff": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getDiff",
    "parent": "can-connect/cache-requests/cache-requests.algebra",
    "src": {
      "line": 103,
      "codeLine": 137,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nCompares the cached sets to the requested set and returns a description of what subset can be loaded from the\ncache and what subset must be loaded from the base connection.\n",
    "title": "getDiff",
    "signatures": [
      {
        "code": "connection.getDiff( set, availableSets )",
        "description": "\n\n  This determines the minimal amount of data that must be loaded from the base connection by going through each\n  cached set (`availableSets`) and doing a [can-set.Algebra.prototype.subset subset] check and a\n  [can-set.Algebra.prototype.difference set difference] with the requested set (`set`).\n\n  If `set` is a subset of an `availableSet`, `{cached: set}` will be returned.\n\n  If `set` is neither a subset of, nor intersects with any `availableSets`, `{needed: set}` is returned.\n\n  If `set` has an intersection with one or more `availableSets`, a description of the difference that has the fewest\n  missing elements will be returned. An example diff description looks like:\n\n  ```\n  {\n    needed: {start: 50, end: 99}, // the difference, the set that is not cached\n    cached: {start: 0, end: 49}, // the intersection, the set that is cached\n    count: 49 // the size of the needed set\n  }\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set that is being requested."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-set/Set"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "availableSets",
            "description": "An array of [can-connect/connection.getSets available sets] in the\n  [can-connect/base/base.cacheConnection cache]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": [
                        {
                          "name": "needed",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        },
                        {
                          "name": "cached",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        },
                        {
                          "name": "count",
                          "types": [
                            {
                              "type": "Integer"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "a difference description object. Described above.\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-set/Set"
                }
              ]
            }
          ]
        }
      ],
      "name": "availableSets",
      "description": "An array of [can-connect/connection.getSets available sets] in the\n  [can-connect/base/base.cacheConnection cache]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": [
                    {
                      "name": "needed",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    },
                    {
                      "name": "cached",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    },
                    {
                      "name": "count",
                      "types": [
                        {
                          "type": "Integer"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "a difference description object. Described above.\n\n\t "
    }
  },
  "can-connect/cache-requests/cache-requests.getUnion": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getUnion",
    "parent": "can-connect/cache-requests/cache-requests.algebra",
    "src": {
      "line": 176,
      "codeLine": 193,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nCreate the requested data set, a union of the cached and un-cached data.\n",
    "title": "getUnion",
    "signatures": [
      {
        "code": "connection.getUnion(set, diff, neededData, cachedData)",
        "description": "\n\n  Uses [can-set.Algebra.prototype.getUnion] to merge the two sets of data (`neededData` & `cachedData`).\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The parameters of the data set requested."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "diff",
            "description": "The result of [can-connect/cache-requests/cache-requests.getDiff]."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "neededData",
            "description": "The data loaded from the base connection."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "cachedData",
            "description": "The data loaded from the [can-connect/base/base.cacheConnection].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "A merged [can-connect.listData] representation of the the cached and requested data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "name": "cachedData",
      "description": "The data loaded from the [can-connect/base/base.cacheConnection].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "A merged [can-connect.listData] representation of the the cached and requested data.\n\t "
    }
  },
  "can-connect/cache-requests/cache-requests.getListData": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getListData",
    "parent": "can-connect/cache-requests/cache-requests.data",
    "src": {
      "line": 198,
      "codeLine": 218,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nOnly request data that isn't already present in the [can-connect/base/base.cacheConnection cache].\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Overwrites a base connection's `getListData` to use data in the [can-connect/base/base.cacheConnection cache]\n  whenever possible.  This works by [can-connect/connection.getSets getting the stored sets]\n  from the [can-connect/base/base.cacheConnection cache] and\n  doing a [can-connect/cache-requests/cache-requests.getDiff diff] to see what needs to be loaded from the base\n  connection and what can be loaded from the [can-connect/base/base.cacheConnection cache].\n\n  With that information, this `getListData` requests data from the cache or the base connection as needed.\n  Data loaded from different sources is combined via [can-connect/cache-requests/cache-requests.getUnion].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "the parameters of the list that is being requested."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "a promise that returns an object conforming to the [can-connect.listData] format.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "the parameters of the list that is being requested."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "a promise that returns an object conforming to the [can-connect.listData] format.\n\t "
    }
  },
  "can-connect/base/base.options": {
    "name": "can-connect/base/base.options",
    "title": "behavior options",
    "type": "group",
    "parent": "can-connect/base/base",
    "description": "",
    "order": 0
  },
  "can-connect/base/base.identifiers": {
    "name": "can-connect/base/base.identifiers",
    "title": "identifiers",
    "type": "group",
    "parent": "can-connect/base/base",
    "description": "",
    "order": 1
  },
  "can-connect/base/base": {
    "type": "module",
    "name": "can-connect/base/base",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 1,
      "codeLine": 38,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n",
    "description": "\nThe first behavior added to every `can-connect` connection. Provides methods to uniquely identify instances and\nlists.\n",
    "title": "base",
    "signatures": [
      {
        "code": "base(connectionOptions)",
        "description": "\n\nProvides instance and list identifiers. Added automatically to every connection created by the `connect` helper.\nSo even if we do:\n\n```\nvar connection = connect([],{});\n```\n\nThe connection still has the identification functionality provided by `base`:\n\n```\nconnection.id({id: 1, ...}) //-> 1\n```\n\n`can-connect` connections are typically created by the `connect` helper rather than by calling the behaviors directly.\nThis ensures the behaviors are called in the required order and is more elegant than requiring the user to chain\ntogether the calls to all the behaviors.\n\nSee the [can-connect/base/base.id id] and [can-connect/base/base.listSet listSet] methods for more specifics on\nhow ids are determined.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "connectionOptions",
            "description": "Object containing the configuration for the behaviors of the connection. Added to the\nprototype of the returned connection object. `base` is almost always configured with an [can-connect/base/base.algebra] option since it\n[can-connect/base/base.id defines the id property] and the majority of behaviors also require the algebra.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A `can-connect` connection containing the methods provided by `base`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "connectionOptions",
      "description": "Object containing the configuration for the behaviors of the connection. Added to the\nprototype of the returned connection object. `base` is almost always configured with an [can-connect/base/base.algebra] option since it\n[can-connect/base/base.id defines the id property] and the majority of behaviors also require the algebra.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A `can-connect` connection containing the methods provided by `base`.\n"
    }
  },
  "can-connect/base/base.id": {
    "type": "function",
    "name": "can-connect/base/base.id",
    "parent": "can-connect/base/base.identifiers",
    "src": {
      "line": 40,
      "codeLine": 99,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\nMany behaviors, such as the [can-connect/constructor/store/store], need to have a unique identifier for an\ninstance or instance data.  This `connection.id` method should return that.\n\nTypically, an item's id is a simply property value on the object. For example, \"Todo\" data might look like:\n\n```js\n{_id: 5, name: \"do the dishes\"}\n```\n\nIn this case, [can-connect/base/base.algebra]'s `id` property should be set to \"_id\":\n\n```js\nvar algebra = new set.Algebra({\n  set.props.id(\"_id\")\n});\n\nconnect([...],{algebra: algebra});\n```\n\nHowever, some data records may have compound ids.  For example, \"Class Assignment\" data may be uniquely\nidentified by a combination of two properties, the `studentId` and the `classId`. For this kind of setup, you\ncan provide your own id function as follows:\n\n```js\nvar customIdBehavior = {\n  id: function(assignment){\n    return assignment.studentId + \"-\" + assignment.classId;\n  }\n}\n\nvar classAssignmentConnection = connect(\n  [...behaviors..., customIdBehavior],\n  {\n    url: \"/class_assignments\"\n  }\n);\n```\n\t \n",
    "description": "\nUniquely identify an instance or raw instance data.\n",
    "title": "id",
    "signatures": [
      {
        "code": "connection.id(instance)",
        "description": "\n\n  Returns the instance id as determined by [can-connect/base/base.algebra]'s id values if they exist, else return\n  the instance value indicated by [can-connect/base/base.idProp] if it exists, otherwise the return the value of\n  `instance.id`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "An instance or raw properties for an instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "Number"
            }
          ],
          "description": "A string or number uniquely representing `instance`.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "An instance or raw properties for an instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Number"
        }
      ],
      "description": "A string or number uniquely representing `instance`.\n\n"
    },
    "comment": " "
  },
  "can-connect/base/base.idProp": {
    "name": "can-connect/base/base.idProp",
    "type": "property",
    "parent": "can-connect/base/base.identifiers",
    "src": {
      "line": 122,
      "codeLine": 150,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\n```\nvar todoConnect = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  idProp: \"_id\"\n});\n\ntodoConnect.id({_id: 5}) // -> 5\n```\n\n\t \n",
    "description": "\nSpecifies the property that uniquely identifies an instance.\n",
    "types": [
      {
        "type": "String",
        "description": "The name of the property that uniquely identifies an instance.  Defaults to `\"id\"`.\n"
      }
    ],
    "title": "idProp",
    "hide": true,
    "deprecated": [
      {
        "version": "0.5.3",
        "description": "Instead of specifying idProp users should set an [can-set.props.id id property] on the\n[can-connect/base/base.algebra] included in the connection configuration options.\n\n"
      }
    ],
    "comment": " "
  },
  "can-connect/base/base.listSet": {
    "type": "function",
    "name": "can-connect/base/base.listSet",
    "parent": "can-connect/base/base.identifiers",
    "src": {
      "line": 152,
      "codeLine": 186,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\nMany behaviors, such as the [can-connect/constructor/store/store], need to have a unique identifier for a list.\nThis `connection.listSet` method should return that.\n\nTypically, a list's set identifier is a property on the list object.  As example, a list of Todos might look like\nthe following:\n\n```\nvar dueTodos = todoConnection.getList({due: \"today\"});\ndueTodos; // [{_id: 5, name: \"do dishes\", due:\"today\"}, {_id: 6, name: \"walk dog\", due:\"today\"}, ...]\ndueTodos.__listSet; // {due: \"today\"}\ntodoConnection.listSet(dueTodos); // {due: \"today\"}\n```\n\nIn the above example the [can-connect/base/base.listSetProp] would be the default `\"__listSet\"`.\n\t \n",
    "description": "\nUniquely identify the set of data a list contains.\n",
    "title": "listSet",
    "signatures": [
      {
        "code": "connection.listSet(list)",
        "description": "\n\n  Returns the value of the property referenced by [can-connect/base/base.listSetProp] if it exists.\n  By default, this will return `list.__listSet`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "A list instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object that can be passed to `JSON.stringify` to represent the list.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "A list instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object that can be passed to `JSON.stringify` to represent the list.\n"
    },
    "comment": " "
  },
  "can-connect/base/base.listSetProp": {
    "name": "can-connect/base/base.listSetProp",
    "type": "property",
    "parent": "can-connect/base/base.identifiers",
    "src": {
      "line": 190,
      "codeLine": 212,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n",
    "description": "\nSpecifies the property that uniquely identifies a list.\n",
    "types": [
      {
        "type": "String",
        "description": "The name of the property that uniquely identifies the list.\nDefaults to `\"__listSet\"`.\n\n```\nvar dataUrl = require(\"can-connect/data/url/\");\nvar connection = connect([dataUrl], {\n  listSetProp: \"set\"\n});\n\nvar list = [{id: 1, ...}, {id: 2, ...}]\nlist.set = {complete: true};\n\nconnection.listSet(list) //-> {complete: true}\n```\n\n\t "
      }
    ],
    "title": "listSetProp"
  },
  "can-connect/base/base.algebra": {
    "body": "\n",
    "description": "\n`can-set` [can-set.Algebra set algebra] used for list comparison, instance identification and membership\ncalculations. A way for the `can-connect` behaviors to understand what the properties of a request mean and act\non them.\n",
    "types": [
      {
        "type": "can-set.Algebra",
        "description": "A [can-set.Algebra set algebra] that is used to perform calculations using set\ndefinition objects passed to [can-connect/connection.getListData] and [can-connect/connection.getList].\nNeeded to enable [can-connect/fall-through-cache/fall-through-cache caching],\n[can-connect/data/combine-requests/combine-requests request combining], [can-connect/real-time/real-time] and other\nbehaviors. By default no algebra is provided.\n\nAn example of the types of calculations behaviors will make using the algebra:\n```\nvar algebra = new set.Algebra(\n  set.props.id('_uid'),\n  set.props.rangeInclusive(\"first\",\"last\")\n);\n\nvar todoConnection = connect([...behaviors...],{\n  algebra: algebra\n});\n\ntodoConnection.algebra.id({_uid: 5, ...}); //-> 5\ntodoConnection.id({_uid: 5, ...}); //-> 5\ntodoConnection.algebra.intersection({first: 0, last: 10}, {first:5, last:20}); //-> {first:5, last:10}\ntodoConnection.algebra.has({first: 0, last:10}, {_uid:5, ...}); //-> true\ntodoConnection.algebra.has({first: 0, last:10}, {_uid:11, ...}); //-> false\n```\n\t "
      }
    ],
    "title": "algebra",
    "name": "can-connect/base/base.algebra",
    "type": "property",
    "parent": "can-connect/base/base.options"
  },
  "can-connect/base/base.cacheConnection": {
    "body": "\n\n## Use\n\n```\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{});\n\nvar todoConnection = connect([...behaviors...],{\n  cacheConnection: cacheConnection\n});\n```\n\t \n",
    "description": "\nAn underlying `can-connect` connection used when fetching data from a cache.\n",
    "types": [
      {
        "type": "can-connect/DataInterface",
        "description": "A connection that provides access to a cache via [can-connect/DataInterface]\nrequests. Several behaviors including [can-connect/fall-through-cache/fall-through-cache] expect this property.\n"
      }
    ],
    "title": "cacheConnection",
    "name": "can-connect/base/base.cacheConnection",
    "type": "property",
    "parent": "can-connect/base/base.options",
    "comment": " "
  },
  "can-connect/constructor/constructor.options": {
    "name": "can-connect/constructor/constructor.options",
    "title": "behavior options",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 1
  },
  "can-connect/constructor/constructor.crud": {
    "name": "can-connect/constructor/constructor.crud",
    "title": "CRUD methods",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 2
  },
  "can-connect/constructor/constructor.callbacks": {
    "name": "can-connect/constructor/constructor.callbacks",
    "title": "CRUD callbacks",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 3
  },
  "can-connect/constructor/constructor.hydrators": {
    "name": "can-connect/constructor/constructor.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 4
  },
  "can-connect/constructor/constructor.serializers": {
    "name": "can-connect/constructor/constructor.serializers",
    "title": "serializers",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 5
  },
  "can-connect/constructor/constructor.helpers": {
    "name": "can-connect/constructor/constructor.helpers",
    "title": "helpers",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 6
  },
  "can-connect/constructor/constructor": {
    "name": "can-connect/constructor/constructor",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 2,
      "codeLine": 116,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nThe `constructor` behavior allows you to instantiate the raw representation of the data source's data into a\ncustom typed representation with additional methods and behaviors.\nAn example might be loading data from a `\"/todos\"` service and being able to call `.timeLeft()`  on the todos that\nyou get back like:\n\n```\ntodoConnection.get({id: 6}).then(function(todo){\n  todo.timeLeft() //-> 60000\n})\n```\n\nThe following creates a `todoConnection` that does exactly that:\n\n```\n// require connection plugins\nvar constructor = require(\"can-connect/constructor/\");\nvar dataUrl = require(\"can-connect/data/url/\");\n\n// define type constructor function\nvar Todo = function(data){\n  // add passed properties to new instance\n  for(var prop in data) {\n   this[prop] = data;\n  }\n};\n\n// add method to get time left before due, in milliseconds\nTodo.prototype.timeLeft = function(){\n  return new Date() - this.dueDate\n};\n\n// create connection, passing function to instantiate new instances\nvar todoConnection = connect([constuctor, dataUrl], {\n  url: \"/todos\",\n  instance: function(data){\n    return new Todo(data);\n  }\n});\n```\n\nThe `constructor` behavior is still useful even if you want to keep your data as untyped objects (which is the\ndefault behavior when no [can-connect/constructor/constructor.instance `instance`] implementation is provided).  The\nbehavior provides an interface to the data held by the client. For example,\n[can-connect/constructor/constructor.updatedInstance] provides an extension point for logic that needs to be executed\nafter an instance held by the client finishes an update request. This is valuable whether that instance is typed or not.\nExtensions like [can-connect/real-time/real-time] or [can-connect/fall-through-cache/fall-through-cache]\nrequire this interface for advanced behavior.\n\n## Interface\n\n`constructor` provides the following categories of methods to interact with typed data:\n\n### <span id=\"CRUDMethods\">CRUD Methods</span>\n\nMethods that create, read, update and delete (CRUD) typed representations of raw connection data:\n\n- [can-connect/constructor/constructor.get] - retrieve a single typed instance from the data source\n- [can-connect/constructor/constructor.getList] - retrieve a typed list of instances from the data source\n- [can-connect/constructor/constructor.save] - save a typed instance's data to the data source\n- [can-connect/constructor/constructor.destroy] - delete a typed instance's data from the data source\n\n### <span id=\"CRUDCallbacks\">CRUD Callbacks</span>\n\n\"CRUD Methods\" call these methods with request response data and a related instance. Their implementation here\nupdates the related instance with that data:\n\n- [can-connect/constructor/constructor.createdInstance] - after [can-connect/constructor/constructor.save saving] new instance to data source, update that instance with response data\n- [can-connect/constructor/constructor.updatedInstance] - after [can-connect/constructor/constructor.save saving] existing instance to data source, update that instance with response data\n- [can-connect/constructor/constructor.destroyedInstance] - after [can-connect/constructor/constructor.destroy deleting] instance from data source, update that instance with response data\n- [can-connect/constructor/constructor.updatedList] - after new data is read from the data source, update an existing list with instances created from that data\n\n### <span id=\"CRUDMethods\">Hydrators</span>\n\nThese methods are used to create a typed instance or typed list given raw data objects:\n- [can-connect/constructor/constructor.hydrateInstance] - create a typed instance given raw instance data\n- [can-connect/constructor/constructor.hydrateList] - create a typed list of typed instances given given raw list data\n\n### <span id=\"Serializers\">Serializers</span>\n\nThese methods convert a typed instance or typed list into a raw object:\n- [can-connect/constructor/constructor.serializeInstance] - return raw data representing the state of the typed instance argument\n- [can-connect/constructor/constructor.serializeList] - return raw data representing the state of the typed list argument\n\n\n",
    "description": "\nAdds an interface to interact with custom types via the connection instead of plain Objects and Arrays.\n",
    "title": "constructor",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructor( baseConnection )",
        "description": "\n\nAdds an interface that allows the connection to operate on custom types. These fall into the categories:\n- [can-connect/constructor/constructor#CRUDMethods CRUD Methods] - create, read, update and delete typed instances via the data source\n- [can-connect/constructor/constructor#CRUDCallbacks CRUD Callbacks] - activities run on typed instances following data source operations\n- [can-connect/constructor/constructor#Hydrator Hydrators] - conversion of raw data to typed data\n- [can-connect/constructor/constructor#Serializers Serializers] - conversion of typed data to raw data\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "`can-connect` connection object that is having the `constructor` behavior added\non to it.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A `can-connect` connection containing the method implementations provided by `constructor`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "`can-connect` connection object that is having the `constructor` behavior added\non to it.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A `can-connect` connection containing the method implementations provided by `constructor`.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.cidStore": {
    "name": "can-connect/constructor/constructor.cidStore",
    "type": "property",
    "parent": "can-connect/constructor/constructor.helpers",
    "src": {
      "line": 128,
      "codeLine": 139,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nTemporarily hold references to new instances via their [can-util/js/cid/cid] while they are undergoing creation.\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "Temporarily holds references to instances by\n[can-util/js/cid/cid] when they are in the process of being created and don't yet have an `id`s. This is typically\naccessed in `createdData` handlers (e.g [can-connect/real-time/real-time.createdData real-time.createdData]) that\nneed to lookup the instance that was being created during a particular request.\n\t "
      }
    ],
    "title": "cidStore"
  },
  "can-connect/constructor/constructor.get": {
    "type": "function",
    "name": "can-connect/constructor/constructor.get",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 142,
      "codeLine": 173,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nRetrieve a single instance from the connection data source.\n",
    "title": "get",
    "signatures": [
      {
        "code": "connection.get(params)",
        "description": "\n\nRetrieves instance data from [can-connect/connection.getData], runs the resulting data through\n[can-connect/constructor/constructor.hydrateInstance], creating a typed instance with the retrieved data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "data specifying the instance to retrieve.  Normally, this is something like like:\n`{id: 5}`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect/Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` resolving to the instance returned by\n[can-connect/constructor/constructor.hydrateInstance].\n\n### Usage\n\nCall `.get()` with the parameters that identify the instance you want to load.  `.get()` will return a promise\nthat resolves to that instance:\n```\ntodoConnection.get({id: 6}).then(function(todo){\n  todo.id; // 6\n  todo.name; // 'Take out the garbage'\n});\n```\n\n`.get()` above will call [can-connect/connection.getData `getData`] on the [can-connect/data/url/url]\nbehavior, which will make an HTTP GET request to `/todos/6`.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "data specifying the instance to retrieve.  Normally, this is something like like:\n`{id: 5}`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` resolving to the instance returned by\n[can-connect/constructor/constructor.hydrateInstance].\n\n### Usage\n\nCall `.get()` with the parameters that identify the instance you want to load.  `.get()` will return a promise\nthat resolves to that instance:\n```\ntodoConnection.get({id: 6}).then(function(todo){\n  todo.id; // 6\n  todo.name; // 'Take out the garbage'\n});\n```\n\n`.get()` above will call [can-connect/connection.getData `getData`] on the [can-connect/data/url/url]\nbehavior, which will make an HTTP GET request to `/todos/6`.\n\t "
    }
  },
  "can-connect/constructor/constructor.getList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.getList",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 180,
      "codeLine": 211,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nRetrieve a list of instances from the connection data source.\n",
    "title": "getList",
    "signatures": [
      {
        "code": "connection.getList(set)",
        "description": "\n\nRetrieves list data from [can-connect/connection.getListData] and runs the resulting data through\n[can-connect/constructor/constructor.hydrateList], creating a typed list of typed instances from  the retrieved\ndata.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "data specifying the range of instances to retrieve. This might look something like:\n```{start: 0, end: 50, due: 'today'}```\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.List",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "can-connect/Instance"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` resolving to the typed list returned by\n[can-connect/constructor/constructor.hydrateList].\n\n### Usage\n\nCall `getList` with the parameters that specify the set of data you want to load.  `.getList()` will return\na promise that resolves to a [can-connect.List] created from that set.\n\n```\ntodoConnection.getList({due: 'today'}).then(function(todos){\n  todos[0].name; // 'Take out the garbage'\n  todos[0].due > startOfDay && todos[0].due < endOfDay; // true\n})\n```\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "data specifying the range of instances to retrieve. This might look something like:\n```{start: 0, end: 50, due: 'today'}```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.List",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can-connect/Instance"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` resolving to the typed list returned by\n[can-connect/constructor/constructor.hydrateList].\n\n### Usage\n\nCall `getList` with the parameters that specify the set of data you want to load.  `.getList()` will return\na promise that resolves to a [can-connect.List] created from that set.\n\n```\ntodoConnection.getList({due: 'today'}).then(function(todos){\n  todos[0].name; // 'Take out the garbage'\n  todos[0].due > startOfDay && todos[0].due < endOfDay; // true\n})\n```\n\n\t "
    }
  },
  "can-connect/constructor/constructor.hydrateList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.hydrateList",
    "parent": "can-connect/constructor/constructor.hydrators",
    "src": {
      "line": 220,
      "codeLine": 238,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nProduce a typed list from the provided raw list data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList(listData, set)",
        "description": "\n\n  Call [can-connect/constructor/constructor.hydrateInstance] for each item in the raw list data, and then call\n  [can-connect/constructor/constructor.list] with an array of the typed instances returned from\n  [can-connect/constructor/constructor.hydrateInstance] .  If [can-connect/constructor/constructor.list] is not\n  provided as an argument or implemented by another behavior, a normal array is created.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "the raw list data returned by the data source, often via [can-connect/connection.getListData]"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "description of the set of data `listData` represents\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "a typed list containing typed instances generated from `listData`\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "description of the set of data `listData` represents\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "a typed list containing typed instances generated from `listData`\n\t "
    }
  },
  "can-connect/constructor/constructor.hydrateInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.hydrateInstance",
    "parent": "can-connect/constructor/constructor.hydrators",
    "src": {
      "line": 258,
      "codeLine": 272,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nProduce a typed object containing the provided raw data.\n",
    "title": "hydrateInstance",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\nIf [can-connect/constructor/constructor.instance] has been passed as an option, or defined by another behavior,\npass `props` to it and return the value. Otherwise, return a clone of `props`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the raw instance data returned by the data source, often via [can-connect/connection.getData]"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "a typed instance containing the data from `props`\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the raw instance data returned by the data source, often via [can-connect/connection.getData]"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "a typed instance containing the data from `props`\n\t "
    }
  },
  "can-connect/constructor/constructor.save": {
    "type": "function",
    "name": "can-connect/constructor/constructor.save",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 279,
      "codeLine": 374,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n## Use\n\nTo use `save` to create an instance, create a connection, then an instance, and call `.save()` on it:\n\n```\n// Create a connection\nvar constructor = require('can-connect/constructor/');\nvar dataUrl = require('can-connect/data/url/');\nvar todoConnection = connect([dataUrl, constructor], {\n  url: \"/todos\"\n});\n\n// Create an instance\nvar todo = {name: \"do dishes\"};\n\n// Call .save()\ntodoConnection.save(todo)\n```\n\n`.save(todo)` above will call [can-connect/data/url/url.createData `createData`] on the [can-connect/data/url/url]\nbehavior, which will make an HTTP POST request to `/todos` with the serialized `todo` data.  The server response\ndata may look something like:\n\n```\n{\n id: 5,\n ownerId: 9\n}\n```\n\nThat data will be passed to [can-connect/constructor/constructor.createdInstance] which by default\nadds those properties to `todo`, resulting in `todo` looking like:\n\n```\n{\n name: \"do dishes\",\n id: 5,\n ownerId: 9\n}\n```\n\nAs an example of updating an instance, change a property on `todo` and call `.save()` again:\n\n```\n// Change a property\ntodo.name = \"Do dishes now!!\";\n\n// Call .save()\ntodoConnection.save(todo)\n```\n\nThe `.save(todo)` above will call [can-connect/data/url/url.updateData `updateData`] on the\n[can-connect/data/url/url] behavior, which will make an HTTP PUT request to `/todos` with the serialized `todo`\ndata.\n\nA successful server response body should look something like:\n\n```\n{\n name: \"Do dishes now!!\",\n id: 5,\n ownerId: 9\n}\n```\n\nThis data will be passed to [can-connect/constructor/constructor.updatedInstance] which by default sets\nall of `todo`'s properties to look like the response data, even removing properties that are missing from the\nresponse data.\n\t \n",
    "description": "Create or update an instance on the connection data source \n",
    "title": "save",
    "signatures": [
      {
        "code": "connection.save( instance )",
        "description": "\n\n  First checks if the instance has an [can-connect/base/base.id] or not.  If it has an id, the instance will be\n  updated; otherwise, it will be created.\n\n  When creating an instance, the instance is added to the [can-connect/constructor/constructor.cidStore], and its\n  [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.createData].  If `createData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor/constructor.createdInstance] is called with that data.\n\n  When updating an instance, its [can-connect/constructor/constructor.serializeInstance serialized data] is\n  passed to [can-connect/connection.updateData]. If `updateData`'s promise resolves to anything other than\n  `undefined`, [can-connect/constructor/constructor.updatedInstance] is called with that data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance to create or save\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect/Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` resolving to the same instance that was passed to `save`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "the instance to create or save\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` resolving to the same instance that was passed to `save`\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.destroy": {
    "src": {
      "line": 405,
      "codeLine": 454,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "type": "function",
    "body": "\n## Use\n\nTo use `destroy`, create a connection, retrieve an instance, and then call `.destroy()` with it.\n\n```\n// create a connection\nvar constructor = require('can-connect/constructor/');\nvar dataUrl = require('can-connect/data/url/');\nvar todoConnection = connect([dataUrl, constructor], {\n  url: \"/todos\"\n})\n\n// retrieve a todo instance\ntodoConnection.get({id: 5}).then(function(todo){\n  // Call .destroy():\n  todoConnection.destroy(todo)\n});\n```\n\n`.destroy()` above will call [can-connect/connection.destroyData `destroyData`] on the [can-connect/data/url/url]\nbehavior, which will make an HTTP DELETE request to `/todos/5` with the serialized `todo` data.  The server\nresponse data may look something like:\n\n```\n{\n  deleted: true\n}\n```\n\nThat response data will be passed to [can-connect/constructor/constructor.destroyedInstance], which by default\nadds those properties to `todo`.\n\t \n",
    "description": "Delete an instance from the connection data source \n",
    "title": "destroy",
    "name": "can-connect/constructor/constructor.destroy",
    "parent": "can-connect/constructor/constructor.crud",
    "signatures": [
      {
        "code": "connection.destroy( instance )",
        "description": "\n\n  To destroy an instance, it's [can-connect/constructor/constructor.serializeInstance serialized data] is passed\n  to [can-connect/connection.destroyData]. If [can-connect/connection.destroyData]'s promise resolves to anything\n  other than `undefined`, [can-connect/constructor/constructor.destroyedInstance] is called.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance being deleted from the data source\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect/Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` resolving to the same instance that was passed to `destroy`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "the instance being deleted from the data source\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` resolving to the same instance that was passed to `destroy`\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.createdInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.createdInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 469,
      "codeLine": 484,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nA method run whenever a new instance has been saved to the data source. Updates the instance with response data.\n",
    "title": "createdInstance",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n`createdInstance` is run whenever a new instance is saved to the data source. This implementation updates the\ninstance with the data returned by [can-connect/connection.createData] which made the request to save the raw\ninstance data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance that was created"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the data returned from [can-connect/connection.createData] that will update the properties of `instance`\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the data returned from [can-connect/connection.createData] that will update the properties of `instance`\n\t "
    }
  },
  "can-connect/constructor/constructor.updatedInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.updatedInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 488,
      "codeLine": 504,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nA method run whenever an existing instance has been saved to the data source. Overwrites the instance with response\ndata.\n",
    "title": "updatedInstance",
    "signatures": [
      {
        "code": "connection.updatedInstance( instance, props )",
        "description": "\n\n`updatedInstance` is run whenever an existing instance is saved to the data source. This implementation overwrites\nthe instance with the data returned bu [can-connect/connection.updatedData] which made the request to save the\nmodified instance data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance that was updated"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the data from [can-connect/connection.updateData] that will overwrite the properties of `instance`\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the data from [can-connect/connection.updateData] that will overwrite the properties of `instance`\n\t "
    }
  },
  "can-connect/constructor/constructor.updatedList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.updatedList",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 508,
      "codeLine": 525,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nA method run whenever new data for an existing list is retrieved from the data source. Updates the list to\ninclude the new data.\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedList( list, listData, set )",
        "description": "\n\n[can-connect/constructor/constructor.hydrateInstance Hydrates instances] from `listData`'s data and attempts to\nmerge them into `list`.  The merge is able to identify simple insertions and removals of elements instead of\nreplacing the entire list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "list",
            "description": "an existing list"
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "raw data that should be included as part of `list` after conversion to typed instances"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "description of the set of data `list` represents\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "description of the set of data `list` represents\n\t "
    }
  },
  "can-connect/constructor/constructor.destroyedInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.destroyedInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 538,
      "codeLine": 554,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nA method run whenever an instance has been deleted from the data source. Overwrites the instance with response data.\n",
    "title": "destroyedInstance",
    "signatures": [
      {
        "code": "connection.destroyedInstance( instance, props )",
        "description": "\n\n`destroyedInstance` is run whenever an existing instance is deleted from the data source. This implementation\noverwrites the instance with the data returned by [can-connect/connection.destroyData] which made the request to\ndelete the raw instance data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance that was deleted"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the data returned from [can-connect/connection.destroyData] that will overwrite the\nproperties of `instance`\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the data returned from [can-connect/connection.destroyData] that will overwrite the\nproperties of `instance`\n\t "
    }
  },
  "can-connect/constructor/constructor.serializeInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.serializeInstance",
    "parent": "can-connect/constructor/constructor.serializers",
    "src": {
      "line": 558,
      "codeLine": 573,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "",
    "description": "Generate the serialized form of a typed instance. \n",
    "title": "serializeInstance",
    "signatures": [
      {
        "code": "connection.serializeInstance( instance )",
        "description": "\n\n  Generate a raw object representation of a typed instance. This default implementation simply clones the\n  `instance` object, copying all the properties of the object (excluding properties of it's prototypes) to a new\n  object. This is equivalent to `Object.assign({}, instance)`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance to serialize"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a serialized representation of the instance\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "the instance to serialize"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a serialized representation of the instance\n\t "
    }
  },
  "can-connect/constructor/constructor.serializeList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.serializeList",
    "parent": "can-connect/constructor/constructor.serializers",
    "src": {
      "line": 577,
      "codeLine": 592,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "",
    "description": "Generate the serialized form of a typed list. \n",
    "title": "serializeList",
    "signatures": [
      {
        "code": "connection.serializeList( list )",
        "description": "\n\n  Generate a raw array representation of a typed list. This default implementation simply returns a plain `Array`\n  containing the result of calling [can-connect/constructor/constructor.serializeInstance] on each item in the\n  typed list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The instance to serialize."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "A serialized representation of the list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "The instance to serialize."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "A serialized representation of the list.\n\t "
    }
  },
  "can-connect/constructor/constructor.isNew": {
    "type": "function",
    "name": "can-connect/constructor/constructor.isNew",
    "parent": "can-connect/constructor/constructor.helpers",
    "src": {
      "line": 599,
      "codeLine": 609,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nReturns if the instance has not been loaded from or saved to the data source.\n",
    "title": "isNew",
    "signatures": [
      {
        "code": "connection.isNew(instance)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "the instance to test"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if [can-connect/base/base.id] is `null` or `undefined`\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "the instance to test"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if [can-connect/base/base.id] is `null` or `undefined`\n\t "
    }
  },
  "can-connect/constructor/constructor.list": {
    "body": "\n",
    "description": "\nBehavior option provided to create a typed list from a raw array.\n",
    "title": "list",
    "name": "can-connect/constructor/constructor.list",
    "type": "property",
    "parent": "can-connect/constructor/constructor.options",
    "signatures": [
      {
        "code": "connection.list( listData, set )",
        "description": "\n\nTakes a `listData` argument with a `data` property, that is an array of typed instances, each produced by\n[can-connect/constructor/constructor.hydrateInstance], and returns a new typed list containing those typed\ninstances.\nThis method is passed as an option to the connection.\nCalled by [can-connect/constructor/constructor.hydrateList].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "an object with a `data` property, which is an array of instances."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "the set description of this list"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "a typed list type containing the typed instances\n\n### Usage\n\nThe following example makes the connection produce `MyList` typed lists including a `completed` method:\n\n```\nvar constructor = require(\"can-connect/constructor/\");\nvar dataUrl = require(\"can-connect/data/url/\");\n\n// define custom list type constructor\nvar MyList = function(items) {\n this.push.apply(this, items);\n}\n// inherit Array functionality\nMyList.prototype = Object.create(Array.prototype);\n// add custom methods to new list type\nMyList.prototype.completed = function(){\n return this.filter(function(){ return this.completed });\n};\n\n// create connection\nvar todosConnection = connect([constructor, dataUrl], {\n  url: \"/todos\",\n  list: function(listData, set){\n    // create custom list instance\n    var collection = new MyList(listData.data);\n    // add set info for use by other behaviors\n    collection.__listSet = set;\n    return collection;\n  }\n});\n\n// use connection to get typed list & use custom method\ntodosConnection.getList({}).then(function(todoList){\n  console.log(\"There are\", todoList.completed().length, \"completed todos\");\n});\n```\n\n**Note:** we added the [can-connect/base/base.listSetProp] property (`__listSet` by default) on the list. This is\nexpected by other behaviors.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "the set description of this list"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "a typed list type containing the typed instances\n\n### Usage\n\nThe following example makes the connection produce `MyList` typed lists including a `completed` method:\n\n```\nvar constructor = require(\"can-connect/constructor/\");\nvar dataUrl = require(\"can-connect/data/url/\");\n\n// define custom list type constructor\nvar MyList = function(items) {\n this.push.apply(this, items);\n}\n// inherit Array functionality\nMyList.prototype = Object.create(Array.prototype);\n// add custom methods to new list type\nMyList.prototype.completed = function(){\n return this.filter(function(){ return this.completed });\n};\n\n// create connection\nvar todosConnection = connect([constructor, dataUrl], {\n  url: \"/todos\",\n  list: function(listData, set){\n    // create custom list instance\n    var collection = new MyList(listData.data);\n    // add set info for use by other behaviors\n    collection.__listSet = set;\n    return collection;\n  }\n});\n\n// use connection to get typed list & use custom method\ntodosConnection.getList({}).then(function(todoList){\n  console.log(\"There are\", todoList.completed().length, \"completed todos\");\n});\n```\n\n**Note:** we added the [can-connect/base/base.listSetProp] property (`__listSet` by default) on the list. This is\nexpected by other behaviors.\n\t "
    }
  },
  "can-connect/constructor/constructor.instance": {
    "src": {
      "line": 673,
      "codeLine": 725,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "type": "property",
    "body": "\n",
    "description": "\nBehavior option provided to create a typed form of passed raw data.\n",
    "title": "instance",
    "name": "can-connect/constructor/constructor.instance",
    "parent": "can-connect/constructor/constructor.options",
    "signatures": [
      {
        "code": "connection.instance( props )",
        "description": "\n\nCreates a typed instance for the passed raw data object. This method is passed as an option to the connection.\nCalled by [can-connect/constructor/constructor.hydrateInstance].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "a raw object containing the properties from the data source"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "the typed instance created from the passed `props` object\n\n### Usage\n\nThe following example makes the connection produce `Todo` typed objects including a `complete` method:\n\n```\nvar constructor = require(\"can-connect/constructor/\");\nvar dataUrl = require(\"can-connect/data/url/\");\n\n// define type constructor\nvar Todo = function(rawData){\n  // add raw data to new instance\n  Object.assign(this, rawData);\n};\n\n// add methods to custom type\nTodo.prototype.complete = function(){\n  this.completed = true;\n}\n\n// create connection\nvar todosConnection = connect([constructor, dataUrl], {\n  url: \"/todos\",\n  instance: function(rawData) {\n    return new Todo(rawData);\n  }\n});\n\n// use connection to get typed instance & use custom method\ntodosConnection.get({id: 5}).then(function(todo){\n  todo.completed; // false\n  todo.complete();\n  todo.completed; // true\n});\n```\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "a raw object containing the properties from the data source"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "the typed instance created from the passed `props` object\n\n### Usage\n\nThe following example makes the connection produce `Todo` typed objects including a `complete` method:\n\n```\nvar constructor = require(\"can-connect/constructor/\");\nvar dataUrl = require(\"can-connect/data/url/\");\n\n// define type constructor\nvar Todo = function(rawData){\n  // add raw data to new instance\n  Object.assign(this, rawData);\n};\n\n// add methods to custom type\nTodo.prototype.complete = function(){\n  this.completed = true;\n}\n\n// create connection\nvar todosConnection = connect([constructor, dataUrl], {\n  url: \"/todos\",\n  instance: function(rawData) {\n    return new Todo(rawData);\n  }\n});\n\n// use connection to get typed instance & use custom method\ntodosConnection.get({id: 5}).then(function(todo){\n  todo.completed; // false\n  todo.complete();\n  todo.completed; // true\n});\n```\n\n\t "
    }
  },
  "getData": {
    "type": "function",
    "name": "getData",
    "params": [
      {
        "name": "params",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 10,
      "codeLine": 15,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": " \n",
    "description": "Get an instance\n",
    "returns": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    },
    "hide": true
  },
  "parseListData": {
    "type": "function",
    "name": "parseListData",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "listData",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 51,
      "codeLine": 58,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "\n \n",
    "description": "Provided by parse-data\n",
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "listData",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An array that represents the data"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An array that represents the data"
    },
    "hide": true
  },
  "parseInstanceData": {
    "type": "function",
    "name": "parseInstanceData",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "instanceData",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 59,
      "codeLine": 66,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "\n \n",
    "description": "Provided by parse-data\n",
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "instanceData",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object of properties on the object"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object of properties on the object"
    },
    "hide": true
  },
  "can-connect/fall-through-cache/fall-through-cache.data": {
    "name": "can-connect/fall-through-cache/fall-through-cache.data",
    "title": "data callbacks",
    "type": "group",
    "parent": "can-connect/fall-through-cache/fall-through-cache",
    "description": "",
    "order": 0
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrators": {
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/fall-through-cache/fall-through-cache",
    "description": "",
    "order": 0
  },
  "can-connect/fall-through-cache/fall-through-cache": {
    "name": "can-connect/fall-through-cache/fall-through-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 71,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n\n## Use\n\nTo use the `fall-through-cache`, create a connection with a\n[can-connect/base/base.cacheConnection] and a behavior that implements\n[can-connect/connection.getData] and [can-connect/connection.getListData].\n\n```\nvar cache = connect([\n  require(\"can-connect/data/localstorage-cache/localstorage-cache\")\n],{\n  name: \"todos\"\n});\n\nvar todoConnection = connect([\n   require(\"can-connect/fall-through-cache/fall-through-cache\"),\n   require(\"can-connect/data/url/url\"),\n   require(\"can-connect/constructor/constructor\"),\n   require(\"can-connect/constructor/store/store\")\n  ], {\n  url: \"/todos\",\n  cacheConnection: cache\n});\n```\n\nThen, make requests.  If the cache has the data,\nit will be returned immediately, and then the item or list updated later\nwith the response from the base connection:\n\n```\ntodoConnection.getList({due: \"today\"}).then(function(todos){\n\n})\n```\n\n## Demo\n\nThe following shows the `fall-through-cache` behavior.\n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/fall-through-cache.html'></div>\n\nClicking\n\"Completed\" or \"Incomplete\" will make one of the following requests and\ndisplay the results in the page:\n\n```\ntodoConnection.getList({completed: true});\ntodoConnection.getList({completed: false});\n```\n\nIf you click back and forth between \"Completed\" and \"Incomplete\" multiple times\nyou'll notice that the old data is displayed immediately and then\nupdated after about a second.\n\n\n",
    "description": "\nA fall through cache that checks another `cacheConnection`.\n",
    "title": "fall-through-cache",
    "signatures": [
      {
        "code": "fallThroughCache( baseConnection )",
        "description": "\n\n  Implements a `getData` and `getListData` that\n  check their [can-connect/base/base.cacheConnection] for data and then\n  in the background update the instance or list with data\n  retrieved using the base connection.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrateList": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrateList",
    "parent": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "src": {
      "line": 78,
      "codeLine": 95,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nReturns a List instance given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList(listData, set)",
        "description": "\n\n  Calls the base `hydrateList` to create a List for `listData`.\n\n  Then, Looks for registered hydrateList callbacks for a given `set` and\n  calls them.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.getListData": {
    "src": {
      "line": 116,
      "codeLine": 143,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nGet raw data from the cache if available, and then update\nthe list later with data from the base connection.\n",
    "title": "getListData",
    "name": "can-connect/fall-through-cache/fall-through-cache.getListData",
    "parent": "can-connect/fall-through-cache/fall-through-cache.data",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Checks the [can-connect/base/base.cacheConnection] for `set`'s data.\n\n  If the cache connection has data, the cached data is returned. Prior to\n  returning the data, the [can-connect/constructor.hydrateList] method\n  is intercepted so we can get a handle on the list that's being created\n  for the returned data. Once the intercepted list is retrieved,\n  we use the base connection to get data and update the intercepted list and\n  the cacheConnection.\n\n  If the cache connection does not have data, the base connection\n  is used to load the data and the cached connection is updated with that\n  data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that returns the\nraw data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that returns the\nraw data.\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrateInstance": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrateInstance",
    "parent": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "src": {
      "line": 184,
      "codeLine": 200,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nReturns an instance given raw data.\n",
    "title": "hydrateInstance",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  Calls the base `hydrateInstance` to create an Instance for `props`.\n\n  Then, Looks for registered hydrateInstance callbacks for a given [can-connect/base/base.id] and\n  calls them.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.getData": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.getData",
    "parent": "can-connect/fall-through-cache/fall-through-cache.data",
    "src": {
      "line": 220,
      "codeLine": 247,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nGet raw data from the cache if available, and then update\nthe instance later with data from the base connection.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Checks the [can-connect/base/base.cacheConnection] for `params`'s data.\n\n  If the cache connection has data, the cached data is returned. Prior to\n  returning the data, the [can-connect/constructor/constructor.hydrateInstance] method\n  is intercepted so we can get a handle on the instance that's being created\n  for the returned data. Once the intercepted instance is retrieved,\n  we use the base connection to get data and update the intercepted instance and\n  the cacheConnection.\n\n  If the cache connection does not have data, the base connection\n  is used to load the data and the cached connection is updated with that\n  data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "The set to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that returns the\nraw data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "The set to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that returns the\nraw data.\n\t "
    }
  },
  "can-connect/helpers/map-deep-merge": {
    "type": "module",
    "name": "can-connect/helpers/map-deep-merge",
    "parent": "can-connect.modules",
    "src": {
      "line": 11,
      "codeLine": 94,
      "path": "node_modules/can-connect/helpers/map-deep-merge.js"
    },
    "body": "\n\n## Use\n\nThis method is often used by mixing in the [can-connect/can/merge/merge] behavior\ninto a connection.\n\nIt can be used directly to update a [can-define/map/map] instance or\n[can-define/list/list] instance with nested data as follows:\n\n```js\nvar mapDeepMerge = require(\"can-connect/helpers/map-deep-merge\");\n\nvar myMonth = new ContributionMonth({\n    id: 1,\n    month: \"Feb\",\n    osProjects: [ { id: 1, title: \"canjs\" }, {id: 2, title: \"jQuery++\"} ],\n    author: {id: 5, name: \"ilya\"}\n});\n\nmapDeepMerge( myMonth, {\n    id: 1,\n    month: \"February\",\n    osProjects: [ { id: 1, title: \"CanJS\" }, {id: 3, title: \"StealJS\"}, {id: 2, title: \"jQuery++\"} ],\n    author: {id: 6, name: \"ilya\"}\n});\n```\n\nThis will create the following changes:\n\n```js\n// 1 - a property update\ncontributionMonth.name = \"February\";\n// 2 - a property update on an item of a list\ncontributionMonth.osProjects[0].name = \"CanJS\";\n// 3 - item insertion\ncontributionMonth.osProjects.splice(1,0, hydrateInstance({id: 3, name: \"StealJS\"}) )\n // 4 - a map replacement (`id` is different)\ncontributionMonth.author = hydrateInstance( {id: 6, name: \"ilya\"} )\n```\n\n",
    "description": "\nPerform a smart merge of deeply nested maps and lists.\n",
    "title": "map-deep-merge",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "mapDeepMerge( instance, data )",
        "description": "\n\nThe `can-connect/helpers/map-deep-merge` module exports a function that\nmerges nested [can-define/map/map] or [can-define/list/list] instances.\n\n\n```\nvar mapDeepMerge = require('can-connect/helpers/map-deep-merge');\n\nvar type = new Type({ ... });\n\nmapDeepMerge(type, { ... });\n\nvar list = new Type.List([ ... ]);\nmapDeepMerge(list, [ ... ]);\n```\n\nTo properly know how to merge [can-define] instances of a [can-define/list/list],\n`mapDeepMerge` needs to know how to:\n\n- uniquely identify the instances\n- create instances from raw data (hydration)\n\n`mapDeepMerge` solves this by first identifying the [can-define.types.TypeConstructor]\nof the [can-define/list/list.prototype.wildcardItems] (index) property definition.\n\nWith the `Type` known of each item in the list, `mapDeepMerge` looks for for a `Type.algebra` to\nspecify the unique [can-set.props.id] of `Type` instances.  If `Type.algebra` does\nnot exist, it looks for an `id` and then `_id` property.\n\nWith the `Type` known of each item in the list, `mapDeepMerge` looks for a `Type.connection.hydrateInstance(props)`\nmethod.  If one does not exist, `new Type(props)` is used instead.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-define/map/map"
              },
              {
                "type": "can-define/map/list"
              }
            ],
            "name": "instance",
            "description": "An instance to apply a merge to."
          },
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "data",
            "description": "An object or array with the updated data.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "data",
      "description": "An object or array with the updated data.\n"
    },
    "comment": " "
  },
  "can-connect/helpers/weak-reference-map": {
    "type": "module",
    "name": "can-connect/helpers/weak-reference-map",
    "parent": "can-connect.modules",
    "src": {
      "line": 2,
      "codeLine": 32,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "\n\n## Use\n\n```\nvar WeakReferenceMap = require(\"can-connect/helpers/weak-reference-map\");\nvar wrm = new WeakReferenceMap();\nvar task1 = {id: 1, name: \"do dishes\"};\n\nwrm.addReference(\"1\", task1);\nwrm.has(\"1\") //-> true\nwrm.addReference(\"1\", task1);\nwrm.has(\"1\") //-> true\nwrm.deleteReference(\"1\");\nwrm.has(\"1\") //-> true\nwrm.deleteReference(\"1\");\nwrm.has(\"1\") //-> false\n```\n\n",
    "description": "\nProvides a map that only contains keys that are referenced.\n",
    "title": "WeakReferenceMap",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "new WeakReferenceMap()",
        "description": "\n\n  Creates a new weak reference map.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/helpers/weak-reference-map.prototype": {
    "src": {
      "line": 40,
      "codeLine": 43,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\n",
    "name": "can-connect/helpers/weak-reference-map.prototype",
    "parent": "can-connect/helpers/weak-reference-map",
    "title": "prototype"
  },
  "can-connect/helpers/weak-reference-map.prototype.has": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.has",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 44,
      "codeLine": 53,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "has",
    "signatures": [
      {
        "code": "weakReferenceMap.has(key)",
        "description": "\n\n  Returns if key is in the set.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A key to look for."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "If the key exists.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A key to look for."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "If the key exists.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.addReference": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.addReference",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 56,
      "codeLine": 65,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "addReference",
    "signatures": [
      {
        "code": "WeakReferenceMap.addReference(key, item)",
        "description": "\n\n  Adds a reference to item as key and increments the reference count. This should be called\n  when a value should be managed by something, typically the [can-connect/constructor/store/store].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.deleteReference": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.deleteReference",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 87,
      "codeLine": 96,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "deleteReference",
    "signatures": [
      {
        "code": "weakReferenceMap.deleteReference(key)",
        "description": "\n\n  Decrements the reference count for key and removes it if the reference count is `0`. This should be called\n  when a value should not be managed by something, typically the [can-connect/constructor/store/store].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.get": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.get",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 105,
      "codeLine": 114,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "get",
    "signatures": [
      {
        "code": "weakReferenceMap.get(key)",
        "description": "\n\n  Returns the value stored at key if it's in the store.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "The item if it's available.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store."
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "The item if it's available.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.forEach": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.forEach",
    "parent": "node_modules/can-connect/helpers/weak-reference-set.js",
    "src": {
      "line": 68,
      "codeLine": 76,
      "path": "node_modules/can-connect/helpers/weak-reference-set.js"
    },
    "body": "",
    "description": "",
    "title": "forEach",
    "signatures": [
      {
        "code": "weakReferenceMap.forEach(callback)",
        "description": "\n\n  Calls `callback` for every value in the store.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "key"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A callback handler.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "item"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "key"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "A callback handler.\n "
    }
  },
  "can-connect/real-time/real-time.methods": {
    "name": "can-connect/real-time/real-time.methods",
    "title": "methods",
    "type": "group",
    "parent": "can-connect/real-time/real-time",
    "description": "",
    "order": 0
  },
  "can-connect/real-time/real-time.callbacks": {
    "name": "can-connect/real-time/real-time.callbacks",
    "title": "data callbacks",
    "type": "group",
    "parent": "can-connect/real-time/real-time",
    "description": "",
    "order": 1
  },
  "can-connect/real-time/real-time": {
    "name": "can-connect/real-time/real-time",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 127,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n\n## Use\n\nTo use `real-time`, create a connection with its dependent\nbehaviors like:\n\n```\nvar todoConnection = connect(\n   [\"real-time\",\n    \"constructor\",\n    \"constructor-store\",\n    \"constructor-callbacks-once\",\n    \"data-url\"],{\n  url: \"/todos\"\n});\n```\n\nNext, use the connection to load lists and save those lists in the\nstore:\n\n```\ntodoConnection.getList({complete: false}).then(function(todos){\n  todoConnection.addListReference(todos);\n})\n```\n\nFinally, use one of the  [can-connect/real-time/real-time.createInstance],\n[can-connect/real-time/real-time.updateInstance], and\n[can-connect/real-time/real-time.destroyInstance] methods to tell the connection\nthat data has changed.  The connection will update (by calling splice)\neach list accordingly.\n\n\n## Example\n\nThe following demo shows two lists that use this connection.  The\n\"Run Code\" button sends the connection data changes which the\nconnection will then update lists accordingly:\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/real-time.html'></div>\n\nThis example creates a `todoList` function and `todoItem` function\nthat manage the behavior of a list of todos and a single todo respectfully.\nIt uses [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe)\nto observe changes in the todo list and individual todo data. Other\nframeworks will typically provide their own observable system.\n\n### todoList\n\nWhen `todoList` is created, it is passed the `set` of data to load.  It uses\nthis to get todos from the `todoConnection` like:\n\n\n```\ntodosConnection.getList(set).then(function(retrievedTodos){\n```\n\nIt then adds those `todos` to the [can-connect/constructor/store/store.listStore] so\nthey can be updated automatically.  And, it listens to changes in `todos` and calls an `update` function:\n\n```\ntodosConnection.addListReference(todos);\nObject.observe(todos, update, [\"add\", \"update\", \"delete\"] );\n```\n\nThe update function is able to inserted new `todoItem`s in the page when items are added\nto or removed from `todos`.  We exploit that by calling `update` as if it just added\neach todo in the list:\n\n```\nupdate(todos.map(function(todo, i){\n  return {\n    type: \"add\",\n    name: \"\"+i\n  };\n}));\n```\n\n### todoItem\n\nThe `todoItem` creates an element that updates with changes\nin its `todo`.  It listens to changes in the `todo` and saves\nthe todo in the [can-connect/constructor/store/store.instanceStore] with the\nfollowing:\n\n```\nObject.observe(todo, update, [\"add\", \"update\", \"delete\"] );\ntodosConnection.addInstanceReference(todo);\n```\n\nA `todoItem` needs to be able to stop listening on the `todo` and remove itself from the\n`instanceStore` if the `todo` is removed from the page.  To provide this teardown\nfunctionality, `todoItem` listens to a `\"removed\"` event on its element and\n`unobserves` the todo and removes it from the `instanceStore`:\n\n```\n$(li).bind(\"removed\", function(){\n  Object.unobserve(todo, update, [\"add\", \"update\", \"delete\"] );\n  todosConnection.deleteInstanceReference(todo);\n});\n```\n\n",
    "description": "\nUpdate lists to include or exclude instances based\non set logic.\n",
    "title": "real-time",
    "signatures": [
      {
        "code": "realTime( baseConnection )",
        "description": "\n\n  Overwrites the \"data callback\" methods and provides\n  [can-connect/real-time/real-time.createInstance],\n  [can-connect/real-time/real-time.updateInstance], and\n  [can-connect/real-time/real-time.destroyInstance] methods\n  that\n  update lists to include or exclude a created,\n  updated, or destroyed instance.\n\n  An instance is put in a list if it is a\n  [set.subset](https://github.com/canjs/can-set#setsubset)\n  of the [can-connect/base/base.listSet].  The item is inserted using [can-set.Algebra.prototype.index].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/real-time/real-time.createInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.createInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 144,
      "codeLine": 181,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n\n## Use\n\nWith a `real-time` connection, call `createInstance` when an instance is created that\nthe connection itself did not make.  For instance, the following might listen to\n[socket.io](http://socket.io/) for when a `todo` is created and update the connection\naccordingly:\n\n```\nsocket.on('todo created', function(todo){\n  todoConnection.createInstance(order);\n});\n```\n\n\t \n",
    "description": "\nProgramatically indicate a new instance has been created.\n",
    "title": "createInstance",
    "signatures": [
      {
        "code": "connection.createInstance(props)",
        "description": "\n\n  If there is no instance in the [can-connect/constructor/store/store.instanceStore]\n  for `props`'s [can-connect/base/base.id], an instance is [can-connect/constructor/constructor.hydrateInstance hydrated],\n  added to the store, and then [can-connect/real-time/real-time.createdData] is called with\n  `props` and the hydrated instance's serialized data. [can-connect/real-time/real-time.createdData]\n  will add this instance to any lists the instance belongs to.\n\n  If this instance has already been created, calls\n  [can-connect/real-time/real-time.updateInstance] with `props`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/real-time/real-time.createdData": {
    "type": "function",
    "name": "can-connect/real-time/real-time.createdData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "src": {
      "line": 212,
      "codeLine": 230,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nCalled whenever instance data is created.\n",
    "title": "createdData",
    "signatures": [
      {
        "code": "connection.createdData(props, params, [cid])",
        "description": "\n\n  Updates lists with the created instance.\n\n  Gets the instance created for this request. Then, updates the instance with\n  the response data `props`.\n\n  Next, it goes through every list in the [can-connect/constructor/store/store.listStore],\n  test if the instance's data belongs in that list.  If it does,\n  adds the instance's data to the serialized list data and\n  [can-connect/constructor/constructor.updatedList updates the list].\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/real-time/real-time.updatedData": {
    "src": {
      "line": 245,
      "codeLine": 259,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nCalled whenever instance data is updated.\n",
    "title": "updatedData",
    "name": "can-connect/real-time/real-time.updatedData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "signatures": [
      {
        "code": "connection.updatedData(props, params)",
        "description": "\n\n  Gets the instance that is updated, updates\n  it with `props` and the adds or removes it to\n  lists it belongs in.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ],
          "description": "Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        }
      ],
      "description": "Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t "
    }
  },
  "can-connect/real-time/real-time.updateInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.updateInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 270,
      "codeLine": 286,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nProgramatically indicate a new instance has been updated.\n",
    "title": "updateInstance",
    "signatures": [
      {
        "code": "connection.updateInstance(props)",
        "description": "\n\n  Calls [can-connect/real-time/real-time.updatedData] in the right way so\n  that the instance is updated and added to or removed from\n  any lists it belongs in.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the instance that\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "the updated instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties of the instance that\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "the updated instance.\n\t "
    }
  },
  "can-connect/real-time/real-time.destroyedData": {
    "type": "function",
    "name": "can-connect/real-time/real-time.destroyedData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "src": {
      "line": 303,
      "codeLine": 316,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "",
    "description": "\n",
    "title": "destroyedData",
    "signatures": [
      {
        "code": "connection.destroyedData(props, params)",
        "description": "\n\nGets the instance for this request.  Then tests if the instance\nis in any list in the [can-connect/constructor/store/store.listStore].  If\nit is, removes the instance from the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the destroyed instance."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "params",
            "description": "The parameters used to destroy the data.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "params",
      "description": "The parameters used to destroy the data.\n\t "
    }
  },
  "can-connect/real-time/real-time.destroyInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.destroyInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 328,
      "codeLine": 343,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nProgramatically indicate a new instance has been destroyed.\n",
    "title": "destroyInstance",
    "signatures": [
      {
        "code": "connection.destroyInstance(props)",
        "description": "\n\n  Gets or creates an instance from `props` and uses\n  it to call [can-connect/real-time/real-time.destroyedData]\n  correctly.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the destroyed instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise with the destroyed instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties of the destroyed instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise with the destroyed instance.\n\t "
    }
  },
  "can-connect/service-worker": {
    "type": "module",
    "name": "can-connect/service-worker",
    "params": [
      {
        "name": "baseConnection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect.behaviors",
    "src": {
      "line": 5,
      "codeLine": 10,
      "path": "node_modules/can-connect/service-worker/service-worker.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "hide": true
  },
  "can-define-stream-kefir.types": {
    "name": "can-define-stream-kefir.types",
    "title": "types",
    "type": "group",
    "parent": "can-define-stream-kefir",
    "description": "",
    "order": 0
  },
  "can-define-stream-kefir.fns": {
    "name": "can-define-stream-kefir.fns",
    "title": "DefineMap methods",
    "type": "group",
    "parent": "can-define-stream-kefir",
    "description": "",
    "order": 0
  },
  "can-define-stream-kefir": {
    "src": {
      "path": "node_modules/can-define-stream-kefir/docs/can-define-stream-kefir.md"
    },
    "body": "\n## Usage\n\nFor example:\n\n__Update map property based on stream value__\n\n```js\nvar DefineMap = require('can-define/map/map');\nvar canDefineStreamKefir = require(\"can-define-stream-kefir\");\n\nvar Person = DefineMap.extend({\n    name: \"string\",\n    lastValidName: {\n        stream: function() {\n            return this.toStream(\".name\").filter(function(name) { // Using prop name\n                return name.indexOf(\" \") >= 0;\n            });\n        }\n    }\n});\n\ncanDefineStreamKefir(Person);\n\nvar me = new Person({name: \"James\"});\n\nme.on(\"lastValidName\", function(lastValid) {});\n\nme.name = \"JamesAtherton\"; //lastValidName -> undefined\nme.name = \"James Atherton\"; //lastValidName -> James Atherton\n\n```\n\n__Stream on DefineList__\n\n```js\nvar DefineList = require('can-define/list/list');\nvar canDefineStreamKefir = require(\"can-define-stream-kefir\");\n\nvar PeopleList = DefineList.extend({});\n\ncanDefineStreamKefir(PeopleList);\n\nvar people = new PeopleList([\n    { first: \"Justin\", last: \"Meyer\" },\n    { first: \"Paula\", last: \"Strozak\" }\n]);\n\nvar stream = people.toStream('length'); // Using event name\n\nstream.onValue(function(val) {\n    val //-> 2, 3\n});\n\npeople.push({\n    first: 'Obaid',\n    last: 'Ahmed'\n}); //-> stream.onValue -> 3\n```\n\n",
    "description": "Export a function that takes a [can-define/map/map] or [can-define/list/list] constructor and uses [can-stream-kefir] to create streamable properties. \n",
    "type": "module",
    "title": "can-define-stream-kefir",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-define-stream-kefir",
    "parent": "can-observables",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-define-stream-kefir/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.2.0",
        "can-define": "^1.2.0",
        "can-define-stream": "^0.2.1",
        "can-observation": "^3.2.0",
        "can-stream-kefir": "^0.3.0",
        "can-util": "^3.9.0",
        "kefir": "^3.5.1"
      },
      "deprecated": false,
      "description": "[![Join the chat at https://gitter.im/canjs/canjs](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/canjs/canjs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://github.com/canjs/can-define-stream-kefir/blob/master/LICENSE) [![npm version](https://badge.fury.io/js/can-define-stream-kefir.svg)](https://www.npmjs.com/package/can-define-stream-kefir) [![Travis build status](https://travis-ci.org/canjs/can-define-stream-kefir.svg?branch=master)](https://travis-ci.org/canjs/can-define-stream-kefir) [![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/canjs/can-define-stream-kefir?branch=master&svg=true)](https://ci.appveyor.com/project/matthewp/can-define-stream-kefir) [![Coverage status](https://coveralls.io/repos/github/canjs/can-define-stream-kefir/badge.svg?branch=master)](https://coveralls.io/github/canjs/can-define-stream-kefir?branch=master) [![Greenkeeper badge](https://badges.greenkeeper.io/canjs/can-define-stream-kefir.svg)](https://greenkeeper.io/)",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.6",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-define-stream-kefir",
      "name": "can-define-stream-kefir",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-define-stream-kefir.git"
      },
      "scripts": {
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git push",
        "preversion": "npm test",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "0.1.2"
    },
    "signatures": [
      {
        "code": "canDefineStreamKefir(DefineMap)",
        "description": "\n\nThe `can-define-stream-kefir` module exports a function that will take a [can-define-stream-kefir.types.DefineMap DefineMap] or [can-define-stream-kefir.types.DefineList DefineList] constructor and add the following methods using the [can-stream-kefir] stream implementation:\n\n- .toStream(observable, propAndOrEvent[,event])\n- .toStreamFromProperty(property)\n- .toStreamFromEvent(property)\n- .toCompute([can-stream.types.makeStream makeStream(setStream)], context):compute\n\n```js\nvar canDefineStreamKefir = require(\"can-define-stream-kefir\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Person = DefineMap.extend({\n    first: \"string\",\n    last: \"string\",\n    fullName: {\n        get: function() {\n            return this.first + \" \" + this.last;\n        }\n    },\n    fullNameChangeCount: {\n        stream: function() {\n            return this.toStream(\".fullName\").scan(function(last) {\n                return last + 1;\n            }, 0);\n        }\n    }\n});\n\ncanDefineStreamKefir(Person);\n\nvar me = new Person({name: \"Justin\", last: \"Meyer\"});\n\nme.on(\"fullNameChangeCount\", function(ev, newVal) {\n    console.log(newVal);\n});\n\nme.fullNameChangeCount //-> 0\n\nme.first = \"Obaid\"; //-> console.logs 1\nme.last = \"Ahmed\"; //-> console.logs 2\n\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define-stream-kefir.toCompute": {
    "src": {
      "path": "node_modules/can-define-stream-kefir/docs/methods.toCompute.md"
    },
    "body": "",
    "description": "Create a compute that gets updated whenever the stream value changes. \n",
    "title": "toCompute",
    "name": "can-define-stream-kefir.toCompute",
    "type": "function",
    "parent": "can-define-stream-kefir.fns",
    "signatures": [
      {
        "code": "DefineMap.toCompute( stream )",
        "description": "\n\nCreates a compute that gets updated whenever the stream value changes.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stream"
              }
            ],
            "name": "stream",
            "description": "A [can-stream] stream\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A [can-compute] compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stream"
        }
      ],
      "name": "stream",
      "description": "A [can-stream] stream\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A [can-compute] compute.\n"
    }
  },
  "can-define-stream-kefir.toStream": {
    "src": {
      "path": "node_modules/can-define-stream-kefir/docs/methods.toStream.md"
    },
    "body": "",
    "description": "Provide a shorthand for creating a stream on properties and/or events. \n",
    "title": "toStream",
    "name": "can-define-stream-kefir.toStream",
    "type": "function",
    "parent": "can-define-stream-kefir.fns",
    "signatures": [
      {
        "code": "DefineMap.toStream( propAndOrEvent[,event] )",
        "description": "\n\nCreates a stream that gets updated whenever the property value changes or event is triggered.\n\n```js\nvar DefineMap = require('can-define/map/map');\nvar canDefineStreamKefir = require(\"can-define-stream-kefir\");\n\nvar Person = DefineMap.extend({\n    name: \"string\",\n    lastValidName: {\n        stream: function() {\n            return this.toStream(\".name\").filter(function(name) { // using propName\n                return name.indexOf(\" \") >= 0;\n            });\n        }\n    }\n});\n\ncanDefineStreamKefir(Person);\n\nvar me = new Person({name: \"James\"});\n\nme.on(\"lastValidName\", function(lastValid) {});\n\nme.name = \"JamesAtherton\"; //lastValidName -> undefined\nme.name = \"James Atherton\"; //lastValidName -> James Atherton\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "A property name prepended by a dot '.prop'\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "An event name 'event'\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propAndEvent",
            "description": "A property name prepended by a dot follow by an event name seperated by a space '.prop event'\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [can-stream] stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "propAndEvent",
      "description": "A property name prepended by a dot follow by an event name seperated by a space '.prop event'\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [can-stream] stream.\n"
    }
  },
  "can-define-stream-kefir.toStreamFromEvent": {
    "src": {
      "path": "node_modules/can-define-stream-kefir/docs/methods.toStreamFromEvent.md"
    },
    "body": "",
    "description": "Create a stream based on an event \n",
    "title": "toStreamFromEvent",
    "name": "can-define-stream-kefir.toStreamFromEvent",
    "type": "function",
    "parent": "can-define-stream-kefir.fns",
    "signatures": [
      {
        "code": "DefineMap.toStreamFromEvent( eventName )",
        "description": "\n\nCreates a stream from an event that gets updated whenever the event is triggered.\n\n```js\nvar DefineList = require('can-define/list/list');\nvar canDefineStreamKefir = require(\"can-define-stream-kefir\");\n\nvar PeopleList = DefineList.extend({});\n\ncanDefineStreamKefir(PeopleList);\n\nvar people = new PeopleList([\n    { first: \"Justin\", last: \"Meyer\" },\n    { first: \"Paula\", last: \"Strozak\" }\n]);\n\nvar stream = people.toStreamFromEvent('length'); // using eventName\n\nstream.onValue(function(val) {\n    val //-> 2, 3\n});\n\npeople.push({\n    first: 'Obaid',\n    last: 'Ahmed'\n}); //-> stream.onValue -> 3\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "An event name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [can-stream] stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "event",
      "description": "An event name\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [can-stream] stream.\n"
    }
  },
  "can-define-stream-kefir.types.DefineList": {
    "src": {
      "path": "node_modules/can-define-stream-kefir/docs/types.DefineList.prototype.md"
    },
    "body": "\n## Use\n\nSee: [can-define/list/list] and the related [can-define/list/list.extend] method.\n\n",
    "description": "A [can-define/list/list] constructor to add stream methods to. \n",
    "type": "typedef",
    "title": "DefineList.prototype",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-stream-kefir.types.DefineList",
    "parent": "can-define-stream-kefir.types",
    "signatures": [
      {
        "code": "new DefineList([items])",
        "description": "\n\nCreates a DefineList constructor\n\n```js\nimport DefineMap from 'can-define/map/map';\nimport DefineList from 'can-define/list/list';\n\nvar People = DefineList.extend([\n\t'#': {\n\t\ttype: {\n\t\t\tfirst: 'string',\n\t\t\tlast: 'string'\n\t\t}\n\t}\n]);\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define-stream-kefir.toStreamFromProperty": {
    "src": {
      "path": "node_modules/can-define-stream-kefir/docs/methods.toStreamFromProperty.md"
    },
    "body": "",
    "description": "Create a stream based on a property \n",
    "title": "toStreamFromProperty",
    "name": "can-define-stream-kefir.toStreamFromProperty",
    "type": "function",
    "parent": "can-define-stream-kefir.fns",
    "signatures": [
      {
        "code": "DefineMap.toStreamFromProperty( property )",
        "description": "\n\nCreates a stream from a property that gets updated whenever the property value changes.\n\n```js\nvar DefineMap = require('can-define/map/map');\nvar canDefineStreamKefir = require(\"can-define-stream-kefir\");\n\nvar Person = DefineMap.extend({\n    name: \"string\",\n    lastValidName: {\n        stream: function() {\n            return this.toStreamFromProperty(\".name\").filter(function(name) { // using propName\n                return name.indexOf(\" \") >= 0;\n            });\n        }\n    }\n});\n\ncanDefineStreamKefir(Person);\n\nvar me = new Person({name: \"James\"});\n\nme.on(\"lastValidName\", function(lastValid) {});\n\nme.name = \"JamesAtherton\"; //lastValidName -> undefined\nme.name = \"James Atherton\"; //lastValidName -> James Atherton\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "A property name prepended by a dot. '.prop'\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [can-stream] stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "property",
      "description": "A property name prepended by a dot. '.prop'\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [can-stream] stream.\n"
    }
  },
  "can-define-stream-kefir.types.DefineMap": {
    "src": {
      "path": "node_modules/can-define-stream-kefir/docs/types.DefineMap.prototype.md"
    },
    "body": "\n## Use\n\nSee: [can-define/map/map] and [can-define/map/map.extend]\n\n",
    "description": "A [can-define/map/map] constructor to add stream methods to. \n",
    "type": "typedef",
    "title": "DefineMap.prototype",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-stream-kefir.types.DefineMap",
    "parent": "can-define-stream-kefir.types",
    "signatures": [
      {
        "code": "new DefineMap({props})",
        "description": "\n\nCreates a DefineMap constructor\n\n```js\nimport DefineMap from 'can-define/map/map';\n\nvar Person = DefineMap.extend({\n\tfirst: 'string',\n\tlast: 'string',\n\tfullName: {\n\t\tget() {\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n});\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define-validate-validatejs.defineMap": {
    "name": "can-define-validate-validatejs.defineMap",
    "title": "DefineMap.prototype",
    "type": "group",
    "parent": "can-define-validate-validatejs",
    "description": "",
    "order": 0
  },
  "can-define-validate-validatejs": {
    "src": {
      "path": "node_modules/can-define-validate-validatejs/docs/can-define-validate-validatejs.md"
    },
    "body": "\n## Usage\n\nAny validation properties must match the structure used by Validate.JS [constraints](https://validatejs.org/#validators).\n\nFor example...\n```js\nvar User = DefineMap.extend({\n    name: {\n        validate: {\n            presence: true\n        }\n    }\n});\n```\n\nInitialize the validators on the Define Map by calling the `defineValidate` function.\n\n```js\ndefineValidate(User);\n```\n\nWhen an instance is created, the instance will have validation properties that can be used in other modules or in templates\n\nIn a module...\n```js\nvar user = new User();\n\nvar onSubmit = function () {\n    if (user.errors()) {\n        alert('Cannot continue, please check form for errors');\n    }\n}\n```\n\nIn a template...\n```html\n<input type=\"submit\" {$disabled}=\"user.errors()\"/>\n```\n\n## Demo\n\n<div class='demo_wrapper' data-demo-src='demos/can-validate/credit-card.html'></div>\n\n",
    "description": "Adds validation methods and observables to a [can-define/map/map] using [validate.js](https://validatejs.org/).\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-validate-validatejs",
    "parent": "can-data-validation",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "browser": {},
      "bugs": {
        "url": "https://github.com/canjs/can-define-validate-validatejs/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-define": "^1.4.7",
        "can-util": "^3.9.0",
        "can-validate": "^1.1.0",
        "can-validate-validatejs": "0.1.0"
      },
      "deprecated": false,
      "description": "Validation helpers for can-define maps and lists.",
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "can-compute": "^3.3.4",
        "detect-cyclic-packages": "^1.1.0",
        "http-server": "^0.10.0",
        "jshint": "^2.9.5",
        "steal": "^1.5.14",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.9.0",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-define-validate-validatejs",
      "keywords": [
        "Validate",
        "plugin",
        "canjs"
      ],
      "license": "MIT",
      "main": "can-define-validate-validatejs.js",
      "name": "can-define-validate-validatejs",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-define-validate-validatejs.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "http-server -c-1",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:pre": "npm version prerelease && npm run build && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "ignoreBrowser": true,
        "npmIgnore": [
          "documentjs",
          "testee",
          "steal-tools"
        ],
        "npmAlgorithm": "flat",
        "npmDependencies": [
          "steal-qunit"
        ],
        "transpiler": "babel"
      },
      "version": "0.1.2"
    },
    "signatures": [
      {
        "code": "defineValidate(Map)",
        "description": "\n\n  Checks for ValidateJS constraints and attaches useful methods.\n\n  ```js\n  var defineValidate = require('can-define-validate-validatejs');\n  var User = DefineMap.extend({\n      name: {\n          validate: {\n              presence: true\n          }\n      }\n  });\n  // Attach methods to any instance created of `User`\n  defineValidate(User);\n  var user = new User();\n  user.errors();//-> [{name: ['is required']}]\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "Map",
            "description": "The [can-define/map/map] constructor. Adds [can-define-validate-validatejs.errors] and [can-define-validate-validatejs.test-set] methods to the prototype of this map.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "Map",
      "description": "The [can-define/map/map] constructor. Adds [can-define-validate-validatejs.errors] and [can-define-validate-validatejs.test-set] methods to the prototype of this map.\n"
    },
    "comment": " "
  },
  "can-define-validate-validatejs.errors": {
    "src": {
      "path": "node_modules/can-define-validate-validatejs/docs/errors.md"
    },
    "body": "\n",
    "description": "\nThe `errors` method retrieves errors from validator.\n",
    "title": "errors",
    "name": "can-define-validate-validatejs.errors",
    "type": "function",
    "parent": "can-define-validate-validatejs.defineMap",
    "signatures": [
      {
        "code": "errors()",
        "description": "\n\n  Returns all errors for the current map instance.\n\n  ```js\n  var Person = new DefineMap({\n      name: {\n          validate: {\n              presence: true\n          }\n      }\n  });\n  var person = new Person();\n  person.errors();\n  //-> [{message: \"is required\", related: \"name\"}]\n  ```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-validate.errors"
            }
          ],
          "description": "Will return `undefined` if map is valid.\nOtherwise, will return an array of [can-validate/types/errors].\n"
        }
      },
      {
        "code": "map.errors(...propName)",
        "description": "\n\n  Returns errors for the specified keys from current map instance.\n\n  ```js\n  var Person = new DefineMap({\n      name: {\n          validate: {\n              presence: true\n          }\n      }\n      age: {\n          validate: {\n              presence: true,\n              numericality: true\n          }\n      }\n  });\n  var person = new Person();\n  person.errors('name');\n  //-> [{message: \"is required\", related: \"name\"}]\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "string"
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "propName",
            "description": "The property key to retrieve errors for.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-validate.errors"
            }
          ],
          "description": "Will return `undefined` if map is valid.\nOtherwise, will return an array of [can-validate/types/errors].\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-validate.errors"
        }
      ],
      "description": "Will return `undefined` if map is valid.\nOtherwise, will return an array of [can-validate/types/errors].\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "string"
                }
              ]
            }
          ]
        }
      ],
      "optional": true,
      "name": "propName",
      "description": "The property key to retrieve errors for.\n"
    }
  },
  "can-define-validate-validatejs.testSet": {
    "src": {
      "path": "node_modules/can-define-validate-validatejs/docs/test-set.md"
    },
    "body": "\n\n## Usage\n\nWith the exception of calling `testSet` with no arguments, `testSet` is called on a copy of the map instance, this is to prevent errors from\nbeing set on the map instance when using `testSet`. This means that errors returned are a result of the values provided through arguments being merged with the existing values.\n\nThis behavior can be controlled when testing multiple values by passing `true` for `useNewInstance`. This will test values with a new instance of the map constructor, allowing better control of what values are tested.\n\n```javascript\nmap.testSet({name: '', age: 100}, true);\n```\n\n",
    "description": "\nTests value changes against constraints. Does not set errors on map instance.\n",
    "title": "testSet",
    "name": "can-define-validate-validatejs.testSet",
    "type": "function",
    "parent": "can-define-validate-validatejs.defineMap",
    "signatures": [
      {
        "code": "testSet()",
        "description": "\n\n  Calls validator on the current values of a [can-define/map/map]. This is essentially the same as\n  calling `errors()`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-validate.errors"
            }
          ],
          "description": "Will return `undefined` if map is valid.\nOtherwise, will return an array of [can-validate/types/errors].\n\n```js\n  var Person = new DefineMap({\n      name: {\n          validate: {\n              presence: true\n          }\n      }\n  });\n  var person = new Person();\n  person.testSet();\n  // returns: [{message: \"is required\", related: \"name\"}]\n```\n"
        }
      },
      {
        "code": "map.testSet(keyName, value)",
        "description": "\n\n  Changes `keyName`'s value in the map instance clone. Then checks if the object is valid.\n  ```js\n  var Person = new DefineMap({\n  name: {\n      validate: {\n          presence: true\n      }\n  }\n  });\n  var person = new Person({name: 'Juan'});\n  person.testSet('name', '');\n  //=> [{message: \"is required\", related: \"name\"}]\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "string"
              }
            ],
            "name": "keyName",
            "description": "The property key to test"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The new value to test for `keyName`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-validate.errors"
            }
          ],
          "description": "Will return `undefined` if test map is valid.\nOtherwise, will return an array of [can-validate.errors].\n"
        }
      },
      {
        "code": "map.testSet(props, useNewInstance)",
        "description": "\n\n  Replaces many values on the map instance clone. Making `useNewInstance` set to\n  `true` will create a new instance of the map and test changes on the clean instance.\n\n  ```js\n  var Person = new DefineMap({\n      name: {\n          validate: {\n              presence: true\n          }\n      },\n      age: {\n          validate: {\n              numericality: true\n          }\n      }\n  });\n  var person = new Person({name: 'Juan', age: 35});\n\n  // this returns [{message: \"is required\", related: \"name\"}]\n  person.testSet({name: ''});\n\n  //this returns [{message: \"is required\", related: \"name\"}]\n  person.testSet({age: 35}, true);\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "object"
              }
            ],
            "name": "props",
            "description": "An object of key/value pairs, where `key` is a property in\nthe map instance that will update to the new `value`.\n"
          },
          {
            "types": [
              {
                "type": "boolean"
              }
            ],
            "optional": true,
            "name": "useNewInstance",
            "defaultValue": "false",
            "description": "If `true`, will use a new instance of the\nmap constructor, then test changes against that new map instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-validate.errors"
            }
          ],
          "description": "Will return `undefined` if test map is valid.\nOtherwise, will return an array of [can-validate.errors].\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-validate.errors"
        }
      ],
      "description": "Will return `undefined` if test map is valid.\nOtherwise, will return an array of [can-validate.errors].\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "optional": true,
      "name": "useNewInstance",
      "defaultValue": "false",
      "description": "If `true`, will use a new instance of the\nmap constructor, then test changes against that new map instance.\n"
    },
    "comment": " "
  },
  "can-connect-signalr/data-interface": {
    "name": "can-connect-signalr/data-interface",
    "title": "data interface",
    "type": "group",
    "parent": "can-connect-signalr",
    "description": "",
    "order": 0
  },
  "can-connect-signalr/options": {
    "name": "can-connect-signalr/options",
    "title": "options",
    "type": "group",
    "parent": "can-connect-signalr",
    "description": "",
    "order": 0
  },
  "can-connect-signalr/methods": {
    "name": "can-connect-signalr/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-connect-signalr",
    "description": "",
    "order": 0
  },
  "can-connect-signalr": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/can-connect-signalr.md"
    },
    "body": "\n## Use\n\n`can-connect-signalr` is a [can-connect] behavior that makes a connection that can communicate with a\n[Hub](https://docs.microsoft.com/en-us/aspnet/signalr/overview/guide-to-the-api/hubs-api-guide-server) on a\n[SignalR](https://docs.microsoft.com/en-us/aspnet/signalr/) server.\n\nThe following walks through an example setup that allows a `Message`\ntype to be created, retrieved, updated and deleted by the client AND\nto be notified when messages are created, updated, or deleted by the\nserver.\n\nSpecifically, we will detail the:\n\n - `can-connect` Client setup\n - Hub Interface Requirements\n\n### `can-connect` Client setup\n\nBelow is a complete example of connecting a `DefineMap` model type to\na SignalR hub:\n\n```js\nvar DefineMap = require('can-define/map/map');\nvar DefineList = require('can-define/list/list');\nvar connect = require(\"can-connect\");\n\n// Defines the Type that will be used on the client.\nvar Message = DefineMap.extend({\n\tbody: 'string',\n\tid: 'number'\n});\n\n// Defines a List type that contains instances of the\n// Type.\nMessage.List = DefineList.extend({\n    '#': Message\n});\n\n// The minimal behaviors used to create the connection\nvar behaviors = [\n\trequire('can-connect/constructor/constructor'),\n\trequire('can-connect/constructor/store/store'),\n\trequire('can-connect/can/map/map'),\n\trequire('can-connect/data/callbacks/callbacks'),\n\trequire('can-connect/real-time/real-time'),\n\trequire('can-connect/constructor/callbacks-once/callbacks-once'),\n\trequire('can-connect-signalr') // Import the signalR Behavior\n];\n\n// Connects the types to the SignalR server\nMessage.connection = connect(behaviors, {\n\tMap: Message,\n\tList: Message.List,\n\tsignalR: {\n\t\turl: 'http://test.com',\n\t\tname: 'MessageHub'\n\t}\n});\n```\n\nThis example creates a `Message` [can-define/map/map] type and\n`Message.List` [can-define/list/list] type and connects them\nto `MessageHub` at `http://test.com`.\n\nThis sets up `Message` so it can retrieve, create, update and delete `Message`s as follows:\n\n<style>\n.table {\n width: 100%;\n border: 1px solid #ccc;\n}\n.table td, .table th {\n border: 1px solid #ccc;\n padding: 5px;\n}\n.table td:nth-child(1), .table th:nth-child(1) {\n max-width: 350px;\n}\n.table td:nth-child(2), .table th:nth-child(2) {\n max-width: 350px;\n min-width: 220px;\n}\n.table td pre {\n border: 0;\n}\n</style>\n\n<table class=\"table\">\n   <thead>\n      <tr>\n         <th>Method</th>\n         <th>\n            Description\n            </th>\n         <th>\n            Details\n         </th>\n      </tr>\n   </thead>\n   <tbody>\n\t<tr>\n\t <td>\n\t    <pre><code>Message.getList({due: \"today\"});</code></pre>\n\t </td>\n\t <td>\n\t    retrieves a list of messages\n\t </td>\n\t <td>\n\t    This calls <code>MessageHub</code>'s <code>public List<MessageModel> messageHubGetListData(MessageQueryParams queryParams)</code> method which is expected to return a list of matched messages.\n\t </td>\n\t</tr>\n\t<tr>\n\t   <td>\n\t      <pre><code>Message.get({id: 5});</code></pre>\n\t   </td>\n\t   <td>\n\t      gets a single message\n\t   </td>\n\t   <td>\n\t      This calls <code>MessageHub</code>'s <code>public MessageModel messageHubGetData( int id )</code> method which is expected to return a single message.\n\t   </td>\n\t</tr>\n\t<tr>\n\t   <td>\n\t      <pre><code>var message = new Message({\n  body: \"Hello World!\"\n}).save();</code></pre>\n\t   </td>\n\t   <td>\n\t      creates messages\n\t   </td>\n\t   <td>\n\t      This calls <code>MessageHub</code>'s <code>public MessageModel messageHubCreate( MessageModel message )</code> method with the [can-define.types.serialize serialized] properties of the client message.  <code>MessageHubCreate</code> is expected to persist the message, add a unique\n            [can-connect/base/base.id] property and value, and return the <code>Message</code>'s new data. It should also notify clients that a message was created.\n\t   </td>\n\t</tr>\n\t<tr>\n\t   <td>\n\t      <pre><code>message.body = \"Hi there.\"; \nmessage.save();</code></pre>\n\t   </td>\n\t   <td>\n\t      updates a message\n\t   </td>\n\t   <td>\n\t      This calls <code>MessageHub</code>'s <code>public MessageModel messageHubUpdate( MessageModel message )</code> method which is expected to update the persisted representation of the message\n            and return the <code>Message</code>'s new data. It should also notify clients that a\n            message was updated.\n\t   </td>\n\t</tr>\t\n\t<tr>\n\t   <td>\n\t      <pre><code>message.destroy();</code></pre>\n\t   </td>\n\t   <td>\n\t      deletes a message\n\t   </td>\n\t   <td>\n\t      This calls <code>MessageHub</code>'s <code>public MessageModel messageHubDestroy( MessageModel message )</code> method which is expected to delete the persisted representation of the message\n            and return the <code>Message</code>'s updated data. It should also notify clients that a\n            message was destroyed.\n\t   </td>\n\t</tr>\t\t\n   </tbody>\n</table>\n\n### Hub Server Setup\n\nThe following code outlines a `MessageHub` that would work with with\nthe above client setup:\n\n```c-sharp\npublic class MessageHub : Hub\n    {\n\n        public MessageHub(MyRepository repository)\n        {\n        }\n\n\t\t// Method should take whatever data is required to create an instance\n        public MessageModel MessageHubCreate( MessageModel message )\n        {\n            PERSIST_TO_DATABASE( message );\n\n            message.id // type must have a unique id property\n\n            // Any RPC calls to the client related to creation go here\n            Clients.All.messageHubCreated(message);\n            return message;\n        }\n\n\t\t// Method should take whatever data is required to update an instance\n        public MessageModel MessageHubUpdate( MessageModel message )\n        {\n            UPDATE_DATABASE( message );\n\n            // Any RPC calls to the client related to update go here\n            Clients.All.messageHubUpdated(message);\n            return message;\n        }\n\n\t\t// Method should take whatever data is required to destroy an instance (usually an id)\n        public MessageModel MessageDestroy( MessageModel model )\n        {\n            DELETE_FROM_DATABASE( model );\n\n            // Any RPC calls to the client related to destroy go here\n            Clients.All.messageDestroyed(model);\n        }\n\n\t\t// Method should take whatever data is required to obtain a list (if any)\n        public List<MessageModel> MessageGetList( MessageQueryParams queryParams )\n        {\n            List<MessageModel> messages = GET_DATA_FROM_DATABASE( queryParams );\n            return messages;\n        }\n\n        // Method should take whatever data is required to obtain a specific item\n        public MessageModel MessageGet( int id )\n        {\n            MessageModel message = GET_RECORD_FROM_DATABASE( id );\n\n            return message;\n        }\n\n        ...\n    }\n```\n\n\n## Configuration\n\nThe name of the Hub is specified by [can-connect-signalr.signalR]`.name`.\nThis is used to create default method and event names.\n\nFor example, if the [can-connect-signalr.signalR]`.name` is `\"TaskHub\"`, it\nwill make RPC calls for the following methods ([can-connect-signalr.signalR] configuration name in parenthesis):\n\n- `taskHubGetData` (`signalR.getListName`)\n- `taskHubGetListData` (`signalR.getListName`)\n- `taskHubCreateData` (`signalR.createName`)\n- `taskHubUpdateData` (`signalR.updateName`)\n- `taskHubDestroyData` (`signalR.destroyName`)\n\nIt will listen to the following events ([can-connect-signalr.signalR] configuration name in parenthesis):\n\n- `taskHubCreatedData` (`signalR.createdData`)\n- `taskHubUpdatedData` (`signalR.updatedData`)\n- `taskHubDestroyedData` (`signalR.destroyedData`)\n\n\nFor example, you can overwrite these defaults like:\n\n```\nconnect(behaviors,{\n    Map: Task,\n    signalR: {\n        url: \"/hubs\",\n        name: \"TaskHub\",\n\n        // Calls TaskHub.getList() instead of TaskHub.taskHubGetListData().\n        getListName: \"getList\",\n    }\n});\n```\n\n",
    "description": "Connect to a [Hub](https://docs.microsoft.com/en-us/aspnet/signalr/overview/guide-to-the-api/hubs-api-guide-server) on a\n[SignalR](https://docs.microsoft.com/en-us/aspnet/signalr/) server.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect-signalr",
    "parent": "can-data-modeling",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-connect-signalr/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-connect": "^1.5.0",
        "jquery": "2.x - 3.x",
        "ms-signalr-client": "^2.2.5"
      },
      "deprecated": false,
      "description": "can-connect-signalr is a set of behaviors for integrating can-connect with Microsoft's signalR",
      "devDependencies": {
        "can-define": "^1.2.0",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.5.2",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.0.0",
        "testee": "^0.6.1"
      },
      "homepage": "https://github.com/canjs/can-connect-signalr#readme",
      "keywords": [],
      "license": "MIT",
      "main": "can-connect-signalr",
      "name": "can-connect-signalr",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-connect-signalr.git"
      },
      "scripts": {
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "preversion": "npm test",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox"
      },
      "system": {
        "transpiler": "babel"
      },
      "version": "0.2.1"
    },
    "signatures": [
      {
        "code": "connectSignalR( baseBehavior )",
        "description": "\n\nEncapsulates connecting to a `SignalR` hub, by:\n\n- implementing the: [can-connect-signalr/createData],  [can-connect-signalr/updateData], [can-connect-signalr/getData], [can-connect-signalr/getListData], and [can-connect-signalr/destroyData] [can-connect/DataInterface] methods to make RPC calls to the server.\n- listening for the following messages pushed from the server to the browser:\n  - [can-connect-signalr.signalR]`.createdName`,\n  - [can-connect-signalr.signalR]`.updatedName`,\n  - [can-connect-signalr.signalR]`.destroyedName`\n\n  and calling: [can-connect/real-time/real-time.createInstance], [can-connect/real-time/real-time.updateInstance], or [can-connect/real-time/real-time.destroyInstance].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect-signalr/createData": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/createData.md"
    },
    "body": "\n## Setup\n\nIf your `SignalR` hub conforms to the required interface (see [can-connect-signalr]), there is nothing you need to\ndo to configure this method on the client. If the method name of the `create` end point on your `SignalR` hub deviates from\nthe standard expected by `can-connect-signalr`, you can override `can-connect-signalr`'s default naming by providing\nthis property with the name expected by your `SignalR` hub.\n\n```js\n    signalR: {\n        url: 'http://test.com', // URL of the SignalR server\n        name: 'MessageHub' // Name of the SignalR hub,\n        createName: 'nameOfMethod'\n    }\n```\n\nYou can call this method directly off of a connection:\n\n```js\nconnection.createData(message);\n```\n\n## CanJS Usage\n\nIf your connection is mixed in to a `DefineMap` (see [can-connect-signalr]), `createData` can be called off of the\n`DefineMap` constructor function. Note that `can-connect-signalr` requires the method signatures\ndefined on your hub to accept only one parameter. You can pass in multiple values by sending the method\nan object:\n\n```js\n// returns a promise that will be resolved once data is received by the Hub.\n// Note: Data returned from the Hub will be received in the proxy listener.\nnew Message({\n\ttext: 'Hi there!'\n}).save();\n```\n\nWhile `createData` returns a `Promise`, that promise does not contain an instance of the created object. That\nwill be made available through the associated RPC listener, `createdData`. This listener takes care of updating\nmodel instances or lists.\n\n",
    "description": "Creates an instance on the server.  This is invoked on a new instance by calling [save]. \n",
    "title": "createData",
    "name": "can-connect-signalr/createData",
    "type": "function",
    "parent": "can-connect-signalr/data-interface",
    "signatures": [
      {
        "code": "createData(instanceData)",
        "description": "\n\nInvokes the method specified by [can-connect-signalr.signalR].createName or\n[can-connect-signalr.signalR].name+\"Create\" and expects the server to respond\nwith the created data and a [can-connect.id] property.\n\n```js\nconnect([\n  ...\n  require(\"can-connect-signalr\"),\n  ...\n], {\n  signalR: {\n    url: 'http://test.com', // URL of the SignalR server\n    name: 'MessageHub', // Name of the SignalR hub,\n    createName: 'createTheMessage'\n  },\n  Map: Message,\n  ...\n});\n\n```\n\nThe following call to `.save()` invokes a `createTheMessage` method on the `MessageHub` hub with the message's serialized data:\n\n```js\nnew Message({\n    name: \"Justin\",\n    message: \"Hello World\"\n}).save()\n// calls MesageHub.createTheMessage({\n//   name: \"Justin\",\n//   message: \"Hello World\"\n// })\n```\n\nThe server should respond with the message data plus it's `id`:\n\n```js\n{\n  \"id\": 1,\n  \"name\": \"Justin\",\n  \"message\": \"Hello World\"\n}\n```\n\nThe following `signalR` connection configurations call their corresponding Hubs and methods:\n\n```\nsignalR: { name: 'MessageHub' } //-> MessageHub.createMessageHub(message)\nsignalR: {\n    name: 'MessageHub',\n    createName: \"createIt\"\n} //-> MessageHub.createIt(message)\nsignalR: {\n    createName: \"createIt\"\n} //-> THROWS AN ERROR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The model to create."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to nothing.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The model to create."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to nothing.\n\n"
    },
    "comment": " "
  },
  "can-connect-signalr/destroyData": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/destroyData.md"
    },
    "body": "\n## Setup\n\nIf your `SignalR` hub conforms to the required interface (see [can-connect-signalr]), there is nothing you need to\ndo to configure this method on the client. If the method name of the `destroy` end point on your `SignalR` hub deviates from\nthe standard expected by `can-connect-signalr`, you can override `can-connect-signalr`'s default naming by providing\nthis property with the name expected by your `SignalR` hub.\n\n```js\nsignalR: {\n  url: 'http://test.com', // URL of the SignalR server\n  name: 'MessageHub' // Name of the SignalR hub,\n  destroyName: 'nameOfMethod'\n}\n```\n\nYou can call this method directly off of a connection:\n\n```js\nconnection.destroyData(message);\n```\n\n## CanJS Usage\n\nIf your connection is mixed in to a `DefineMap` (see [can-connect-signalr]), `destroyData` can be called off of the\n`DefineMap` constructor function. Note that `can-connect-signalr` requires the method signatures\ndefined on your hub to accept only one parameter. You can pass in multiple values by sending the method\nan object:\n\n```js\nmessage.destroy();\n```\n\nThe `messageDestroyed` method takes care of updating model instances or lists on connected clients.\n\n",
    "description": "Destroys an instance on the server.  This is invoked on an instance by calling [destroy]. \n\n\n",
    "title": "destroyData",
    "name": "can-connect-signalr/destroyData",
    "type": "function",
    "parent": "can-connect-signalr/data-interface",
    "signatures": [
      {
        "code": "destroyData(instanceData)",
        "description": "\n\nInvokes the method specified by [can-connect-signalr.signalR].destroyName or\n[can-connect-signalr.signalR].name+\"Destroy\".\n\n```js\nconnect([\n  ...\n  require(\"can-connect-signalr\"),\n  ...\n], {\n  signalR: {\n    url: 'http://test.com', // URL of the SignalR server\n    name: 'MessageHub', // Name of the SignalR hub,\n    destroyName: 'destroyTheMessage'\n  },\n  Map: Message,\n  ...\n});\n\n```\n\nThe following call to `.destroy()` invokes a `destroyTheMessage` method on the `MessageHub` hub with the message model:\n\n```js\nmessage.destroy();\n// calls MesageHub.destroyTheMessage(message)\n```\n\nThe following `signalR` connection configurations call their corresponding Hubs and methods:\n\n```\nsignalR: { name: 'MessageHub' } //-> MessageHub.messageHubDestroy(message)\nsignalR: {\n    name: 'MessageHub',\n    destroyName: \"destroyIt\"\n} //-> MessageHub.destroyIt(message)\nsignalR: {\n    destroyName: \"destroyIt\"\n} //-> THROWS AN ERROR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The model to delete."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The model to delete."
    },
    "comment": " "
  },
  "can-connect-signalr/getData": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/getData.md"
    },
    "body": "\n## Setup\n\nIf your `SignalR` hub conforms to the required interface (see [can-connect-signalr]), there is nothing you need to\ndo to configure this method on the client. If the method name of the `get` end point on your `SignalR` hub deviates from\nthe standard expected by `can-connect-signalr`, you can override `can-connect-signalr`'s default naming by providing\nthis property with the name expected by your `SignalR` hub.\n\n```js\nsignalR: {\n  url: 'http://test.com', // URL of the SignalR server\n  name: 'MessageHub' // Name of the SignalR hub,\n  getData: 'nameOfMethod'\n}\n```\n\nYou can call this method directly off of a connection:\n\n```js\nconnection.getData(1);\n```\n\n## CanJS Usage\n\nIf your connection is mixed in to a `DefineMap` (see [can-connect-signalr]), `getData` can be called off of the\n`DefineMap` constructor function. Note that `can-connect-signalr` requires the method signatures\ndefined on your hub to accept only one parameter. You can pass in multiple values by sending the method\nan object:\n\n```js\nMessage.getData(1);\n```\n\n",
    "description": "Gets an instance from the server. This is invoked on a constructor function by calling [getData]. \n",
    "title": "getData",
    "name": "can-connect-signalr/getData",
    "type": "function",
    "parent": "can-connect-signalr/data-interface",
    "signatures": [
      {
        "code": "getData(id)",
        "description": "\n\nInvokes the method specified by [can-connect-signalr.signalR].getData or\n[can-connect-signalr.signalR].name+\"GetData\" and expects the server to respond\nwith the data.\n\n```js\nconnect([\n  ...\n  require(\"can-connect-signalr\"),\n  ...\n], {\n  signalR: {\n    url: 'http://test.com', // URL of the SignalR server\n    name: 'MessageHub', // Name of the SignalR hub,\n    getData: 'getTheMessage'\n  },\n  Map: Message,\n  ...\n});\n\n```\n\nThe following call to `.getData()` invokes a `getTheMessage` method on the `MessageHub` hub with the provided unique message id:\n\n```js\nMessage.getData(1);\n// calls MesageHub.getTheMessage(1)\n```\n\nIt's expected that the server responds with the message:\n\n```js\n{\n  \"id\": 1,\n  \"name\": \"Justin\",\n  \"message\": \"Hello World\"\n}\n```\n\nThe following `signalR` connection configurations call their corresponding Hubs and methods:\n\n```\nsignalR: { name: 'MessageHub' } //-> MessageHub.messageHubGetData(id)\nsignalR: {\n    name: 'MessageHub',\n    getData: \"getIt\"\n} //-> MessageHub.getIt(id)\nsignalR: {\n    getData: \"getIt\"\n} //-> BREAKS\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "number"
              }
            ],
            "name": "id",
            "description": "A unique id."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to an instance.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "number"
        }
      ],
      "name": "id",
      "description": "A unique id."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to an instance.\n\n"
    },
    "comment": " "
  },
  "can-connect-signalr/getListData": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/getListData.md"
    },
    "body": "\n## Setup\n\nIf your `SignalR` hub conforms to the required interface (see [can-connect-signalr]), there is nothing you need to\ndo to configure this method on the client. If the method name of the `getList` end point on your `SignalR` hub deviates from\nthe standard expected by `can-connect-signalr`, you can override `can-connect-signalr`'s default naming by providing\nthis property with the name expected by your `SignalR` hub.\n\n```js\n    signalR: {\n        url: 'http://test.com', // URL of the SignalR server\n        name: 'MessageHub' // Name of the SignalR hub,\n        getListData: 'nameOfMethod'\n    }\n```\n\nYou can call this method directly off of a connection:\n\n```js\nconnection.getListData(queryParameters);\n```\n\n## CanJS Usage\n\nIf your connection is mixed in to a `DefineMap` (see [can-connect-signalr]), `getListData` can be called off of the\n`DefineMap` constructor function. Note that `can-connect-signalr` requires the method signatures\ndefined on your hub to accept only one parameter. You can pass in multiple values by sending the method\nan object:\n\n```js\nMessage.getListData(queryParameters);\n```\n\n",
    "description": "Gets an list of data from the server. This is invoked on a constructor function by calling [getListData]. \n",
    "title": "getListData",
    "name": "can-connect-signalr/getListData",
    "type": "function",
    "parent": "can-connect-signalr/data-interface",
    "signatures": [
      {
        "code": "getListData(queryParameters)",
        "description": "\n\nInvokes the method specified by [can-connect-signalr.signalR].getListData or\n[can-connect-signalr.signalR].name+\"GetListData\" and expects the server to respond\nwith the data.\n\n```js\nconnect([\n  ...\n  require(\"can-connect-signalr\"),\n  ...\n], {\n  signalR: {\n    url: 'http://test.com', // URL of the SignalR server\n    name: 'MessageHub', // Name of the SignalR hub,\n    getListData: 'getMessages'\n  },\n  Map: Message,\n  ...\n});\n\n```\n\nThe following call to `.getListData()` invokes a `getListOfMessages` method on the `MessageHub` hub with the provided parameters:\n\n```js\nMessage.getListData({\n  name: 'Johnson'\n});\n// calls MesageHub.getListOfMessages({\n//   name: 'Johnson'\n// })\n```\n\nIt's expected that the server responds with the message list:\n\n```js\n[\n {\n   \"id\": 1,\n   \"name\": \"Johnson\",\n   \"message\": \"Hello World\"\n },\n {\n   \"id\": 2,\n   \"name\": \"Johnson\",\n   \"message\": \"Hello again World\"\n }\n]\n```\n\nThe following `signalR` connection configurations call their corresponding Hubs and methods:\n\n```\nsignalR: { name: 'MessageHub' } //-> MessageHub.messageHubGetListData(queryParameters)\nsignalR: {\n    name: 'MessageHub',\n    getListData: \"getThem\"\n} //-> MessageHub.getThem(queryParameters)\nsignalR: {\n    getListData: \"getThem\"\n} //-> THROWS ERROR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "queryParameters",
            "description": "The query parameters."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to a list.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "queryParameters",
      "description": "The query parameters."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to a list.\n\n"
    },
    "comment": " "
  },
  "can-connect-signalr.init": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/init.md"
    },
    "body": "",
    "description": "Establishes a connection to the `SignalR` hub, sets up proxy methods and RPC listeners. \n\nThe `init` method establishes a connection to the `SignalR` hub, and creates a hub proxy. For each CRUD method,\na corresponding RPC listener is registered on the proxy. For example, `can-connect-signalr` implements a `createData`\nmethod. The listener corresponding to that method, by default called `createdData`, is registered on the proxy.\n\nThe `init` method is called automatically.\n",
    "title": "init",
    "name": "can-connect-signalr.init",
    "type": "function",
    "parent": "can-connect-signalr/methods",
    "types": []
  },
  "can-connect-signalr/updateData": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/updateData.md"
    },
    "body": "\n## Setup\n\nIf your `SignalR` hub conforms to the required interface (see [can-connect-signalr]), there is nothing you need to\ndo to configure this method on the client. If the method name of the `update` end point on your `SignalR` hub deviates from\nthe standard expected by `can-connect-signalr`, you can override `can-connect-signalr`'s default naming by providing\nthis property with the name expected by your `SignalR` hub.\n\n```js\nsignalR: {\n  url: 'http://test.com', // URL of the SignalR server\n  name: 'MessageHub' // Name of the SignalR hub,\n  updateName: 'nameOfMethod'\n}\n```\n\nYou can call this method directly off of a connection:\n\n```js\nconnection.updateData(message);\n```\n\n## CanJS Usage\n\nIf your connection is mixed in to a `DefineMap` (see [can-connect-signalr]), `updateData` can be called off of the\n`DefineMap` constructor function. Note that `can-connect-signalr` requires the method signatures\ndefined on your hub to accept only one parameter. You can pass in multiple values by sending the method\nan object:\n\n```js\nmessage.name = 'Brian';\nmessage.save();\n```\n\nWhile `updateData` returns a `Promise`, that promise does not contain an instance of the updated object. That\nwill be made available through the associated RPC listener, `updatedData`. This listener takes care of updating\nmodel instances or lists.\n\n",
    "description": "Updates an instance on the server.  This is invoked on an existing instance by calling [save]. \n",
    "title": "updateData",
    "name": "can-connect-signalr/updateData",
    "type": "function",
    "parent": "can-connect-signalr/data-interface",
    "signatures": [
      {
        "code": "updateData(instanceData)",
        "description": "\n\nInvokes the method specified by [can-connect-signalr.signalR].updateName or\n[can-connect-signalr.signalR].name+\"Update\" and expects the server to respond\nwith the updated data.\n\n```js\nconnect([\n  ...\n  require(\"can-connect-signalr\"),\n  ...\n], {\n  signalR: {\n    url: 'http://test.com', // URL of the SignalR server\n    name: 'MessageHub', // Name of the SignalR hub,\n    updateName: 'updateTheMessage'\n  },\n  Map: Message,\n  ...\n});\n\n```\n\nThe following call to `.save()` invokes an `updateTheMessage` method on the `MessageHub` hub with the message's serialized data:\n\n```js\nmessage.name = 'Brian';\nmessage.save();\n// calls MesageHub.updateTheMessage({\n//   name: \"Brian\"\n// })\n```\n\nIt's expected the server responds with the message:\n\n```js\n{\n  \"id\": 2,\n  \"name\": \"Brian\",\n  \"message\": \"Hello World\"\n}\n```\n\nThe following `signalR` connection configurations call their corresponding Hubs and methods:\n\n```\nsignalR: { name: 'MessageHub' } //-> MessageHub.updateMessageHub(message)\nsignalR: {\n    name: 'MessageHub',\n    updateName: \"updateIt\"\n} //-> MessageHub.updateIt(message)\nsignalR: {\n    updateName: \"updateIt\"\n} //-> THROWS AN ERROR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "object"
              }
            ],
            "name": "instanceData",
            "description": "The model to update."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to nothing.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "object"
        }
      ],
      "name": "instanceData",
      "description": "The model to update."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to nothing.\n\n"
    },
    "comment": " "
  },
  "can-connect-signalr.signalR": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/signalR.md"
    },
    "body": "",
    "description": "The options object passed to the `can-connect` factory function that generates the  `can-connect-signalr` connection.\n\n\n",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "url",
            "description": "\nThe url of your `SignalR` hub.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "name",
            "description": "\nThe name of your `SignalR` hub.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "createName",
            "description": "\nThe name of the method on your `SignalR` hub you will use to create object instances. `can-connect-signalr`\nprovides a default name for this method (hub name + \"Create\"). Use this property to overwrite that name.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "createdName",
            "description": "\nThe name of the RPC listener your `SignalR` proxy you will use to listen for objects created on your hub. \n`can-connect-signalr` provides a default name for this method (hub name + \"Created\"). Use this property \nto overwrite that name.\n    ",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "updateName",
            "description": "\nThe name of the method on your `SignalR` hub you will use to update object instances. `can-connect-signalr`\nprovides a default name for this method (hub name + \"Update\"). Use this property to overwrite that name.\n ",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "updatedName",
            "description": "\nThe name of the RPC listener your `SignalR` proxy you will use to listen for objects updated on your hub. \n`can-connect-signalr` provides a default name for this method (hub name + \"Updated\"). Use this property \nto overwrite that name.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "destroyName",
            "description": "\nThe name of the method on your `SignalR` hub you will use to destroy object instances. `can-connect-signalr`\nprovides a default name for this method (hub name + \"Destroy\"). Use this property to overwrite that name.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "destroyedName",
            "description": "\nThe name of the RPC listener your `SignalR` proxy you will use to listen for objects deleted from your hub. \n`can-connect-signalr` provides a default name for this method (hub name + \"Destroyed\"). Use this property \nto overwrite that name.    \n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "getListName",
            "description": "\nThe name of the method on your `SignalR` hub you will use to get a list of object instances. `can-connect-signalr`\nprovides a default name for this method (hub name + \"GetList\"). Use this property to overwrite that name.\n        ",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "listDataName",
            "description": "\nThe name of the RPC listener your `SignalR` proxy you will use to listen for object lists retrieved from your hub. \n`can-connect-signalr` provides a default name for this method (hub name + \"ListData\"). Use this property \nto overwrite that name.    \n    ",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "getName",
            "description": "\nThe name of the method on your `SignalR` hub you will use to get object instances. `can-connect-signalr`\nprovides a default name for this method (hub name + \"Get\"). Use this property to overwrite that name.\n        ",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "dataName",
            "description": "\nThe name of the RPC listener your `SignalR` proxy you will use to listen for objects retrieved from your hub. \n`can-connect-signalr` provides a default name for this method (hub name + \"Data\"). Use this property \nto overwrite that name.          ",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ],
        "description": "\n\nBelow is an example of a fully configured signalR options object:\n    \n    signalR: {\n        url: 'http://test.com',\n        name: 'MessageHub',\n        createName: 'postMessage', \n        createdName: 'messagePosted',\n        updateName: 'updateThis',\n        updatedName: 'thingUpdated',\n        destroyName: 'obliterateIt',\n        destroyedName: 'itIsGone',\n        getListName: 'gimmeGimme',\n        listDataName: 'gotEmAll',\n        getName: 'wannaWanna',\n        dataName: 'gotIt'\n    }\n"
      }
    ],
    "title": "signalR",
    "name": "can-connect-signalr.signalR",
    "type": "property",
    "parent": "can-connect-signalr/options"
  },
  "can-control.defaults": {
    "src": {
      "path": "node_modules/can-control/docs/defaults.md"
    },
    "body": "\nDefault options provided for when a new control is created without values set in `options`.\n\n`defaults` provides default values for a Control's options.\nOptions passed into the constructor function will be shallowly merged\ninto the values from defaults in [can-control::setup], and\nthe result will be stored in [can-control::options this.options].\n\n\tMessage = Control.extend({\n\t  defaults: {\n\t\tmessage: \"Hello World\"\n\t  }\n\t}, {\n\t  init: function(){\n\t\tthis.element.text( this.options.message );\n\t  }\n\t});\n\n\tnew Message( \"#el1\" ); //writes \"Hello World\"\n\tnew Message( \"#el12\", { message: \"hi\" } ); //writes hi\n\n## Shared Properties\n\nNew instances of a Control will create a shallow copy of the default\noptions. Be aware as shallow copies keep a reference to object types, such as\nobjects, maps and computes.\n\n```\nvar Sample = Control.extend({\n  defaults: {\n    computedProp: can.compute(),\n    primitiveProp: 'sample'\n  }\n}, {});\n\nvar a = new Sample('div');\nvar b = new Sample('li');\n\n//`computedProp` will be shared across instances of the `Sample` control.\n//a.options.computedProp === b.options.computedProp\n```\n\n",
    "description": "Default values for the Control's options. \n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "defaults",
    "name": "can-control.defaults",
    "type": "property",
    "parent": "can-control.static",
    "comment": " "
  },
  "can-control.prototype.destroy": {
    "src": {
      "path": "node_modules/can-control/docs/destroy.md"
    },
    "body": "## Allowing Garbage Collection\n\nDestroy is called whenever a control's element is removed from the page using\nthe library's standard HTML modifier methods. This means that you\ndon't have to call destroy yourself and it\nwill be called automatically when appropriate.\n\nThe following `Clicker` widget listens on the window for clicks and updates\nits element's innerHTML. If we remove the element, the window's event handler\nis removed auto-magically:\n\n\n\tClicker = Control({\n\t\"{window} click\": function() {\n\t\tthis.element.html( this.count ?\n\t\tthis.count++ : this.count = 0 );\n\t}\n\t});\n\n\t// create a clicker on an element\n\tnew Clicker( \"#clickme\" );\n\n\t// remove the element\n\t$( '#clickme' ).remove();\n\nThe methods you can use that will destroy controls automatically by library:\n\n__jQuery and Zepto__\n\n- `$.fn.remove`\n- `$.fn.html`\n- `$.fn.replaceWith`\n- `$.fn.empty`\n\n__Dojo__\n\n- `dojo.destroy`\n- `dojo.empty`\n- `dojo.place (with the replace option)`\n\n__Mootools__\n\n- `Element.prototype.destroy`\n\n__YUI__\n\n- `Y.Node.prototype.remove`\n- `Y.Node.prototype.destroy`\n\n\n## Teardown in Destroy\n\nSometimes, you want to reset a controlled element back to its\noriginal state when the control is destroyed. Overwriting destroy\nlets you write teardown code of this manner.\n\n__NOTE__: When overwriting destroy, make sure you call Control's base functionality.\n\nThe following example changes an element's text when the control is\ncreated and sets it back when the control is removed:\n\n\tChanger = Control.extend({\n\t\tinit: function() {\n\t\t\tthis.oldText = this.element.text();\n\t\t\tthis.element.text( \"Changed!!!\" );\n\t\t},\n\t\tdestroy: function() {\n\t\t\tthis.element.text( this.oldText );\n\t\t\tcan.Control.prototype.destroy.call( this );\n\t\t}\n\t});\n\n\t// create a changer which changes #myel's text\n\tvar changer = new Changer( '#myel' );\n\n\t// destroy changer which will reset it\n\tchanger.destroy();\n\n## Base Functionality\n\nControl prepares the control for garbage collection by:\n\n- unbinding all event handlers\n- clearing references to this.element and this.options\n- clearing the element's reference to the control\n- removing it's `Control.pluginName` from the element's className\n\n",
    "description": "Remove a Control from an element and clean up the Control. ",
    "title": "destroy",
    "name": "can-control.prototype.destroy",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.destroy()",
        "description": "\n\nPrepares a control for garbage collection and is a place to\nreset any changes the control has made.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-control.static": {
    "name": "can-control.static",
    "title": "static",
    "type": "group",
    "parent": "can-control",
    "description": "",
    "order": 0
  },
  "can-control.prototype": {
    "name": "can-control.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-control",
    "description": "",
    "order": 0
  },
  "can-control": {
    "src": {
      "path": "node_modules/can-control/docs/control.md"
    },
    "body": "\n## The Control Lifecycle\n\nThe following walks through a control's lifecycle\nwith an example todo list widget.  It's broken up into the following\nlifecycle events:\n\n - Extending a control\n - Creating a control instance\n - Listening to events\n - Destroying a control\n\n## Extending a control\n\nThe following example builds up a basic todos widget for listing\nand completing todo items. Start by creating a control constructor\nfunction of your own by extending [can-control] and defining an instance init method.\n\n    var Todos = Control.extend({\n      init: function( element, options ) { ... }\n    });\n\n## Creating a control instance\n\nCreate an instance of the Todos control on the `todos` element with:\n\n    var todosControl = new Todos( '#todos', {} );\n\nThe control's associated [can.ejs EJS] template looks like:\n\n    <% todos.each(function( todo ) { %>\n      <li <%= (el) -> el.data( 'todo', todo ) %> >\n        <%= todo.attr( 'name' ) %>\n        <a href=\"javascript://\" class=\"destroy\">\n      </li>\n    <% }) %>\n\n### `init(element, options)`\n\n[can-control.prototype.init] is called with the below arguments when new instances of [can-control] are created:\n\n- __element__ - The wrapped element passed to the\n                control. Control accepts a\n                raw HTMLElement, a CSS selector, or a NodeList. This is\n                set as `this.element` on the control instance.\n- __options__ - The second argument passed to new Control, extended with\n                the can.Control's static __defaults__. This is set as\n                `this.options` on the control instance. Note that static is used\n                formally to indicate that _default values are shared across control instances_.\n\nAny additional arguments provided to the constructor will be passed as normal. Use [can.view] to produce a document fragment\nfrom your template and inject it in the passed element. Note that the `todos` parameter passed to [can.view] below\nis an instance of [can-list]:\n\n    var Todos = Control.extend({\n\n      //defaults are merged into the options arg provided to the constructor\n      defaults : { view: 'todos.ejs' }\n\n    }, {\n      init: function( element , options ) {\n\n        //create a pointer to the control's scope\n        var self = this;\n\n        //run the Todo model's .findAll() method to produce a can.List\n        Todo.findAll( {}, function( todos ) {\n\n            //create a document fragment with can.view\n            //and inject it into the provided element's body\n    \t\tself.element.html( can.view(self.options.view, todos) );\n        });\n      }\n    });\n\n    // create a Todos Control with default options\n    new Todos( document.body.firstElementChild );\n\n    // overwrite the template default\n    new Todos( '#todos', { view: 'specialTodos.ejs' } );\n\n### `this.element`\n\n[can-control::element] is the\nNodeList consisting of the element the control is created on.\n\n    var todosControl = new Todos( document.body.firstElementChild );\n    todosControl.element[0] //-> document.body.firstElementChild\n\nEach library wraps elements differently. If you are using jQuery, for example,\nthe element is wrapped with `jQuery( element )`.\n\n### `this.options`\n\n[can-control::options] is the second argument passed to\n`new Control()`, merged with the control's static __defaults__ property.\n\n## Listening to events\n\nControl automatically binds prototype methods that look\nlike event handlers. Listen to __click__'s on `<li>` elements within [can-control::element this.element] like:\n\n    var Todos = Control.extend({\n      init: function( element , options ) {...},\n\n      '{element} li click': function( li, event ) {\n        console.log( 'You clicked', li.text() );\n\n        // let other controls know what happened\n        li.trigger( 'selected' );\n      }\n    });\n\nWhen an `<li>` is clicked, `\"{element} li click\"` is called with:\n\n- The library-wrapped __element__ that was clicked\n- The __event__ data\n\nControl uses event delegation, so you can add `<li>`s without needing to rebind\nevent handlers.\n\nTo destroy a todo when its `<a href=\"javascript://\" class=\"destroy\">` link\nis clicked:\n\n    var Todos = can.Control.extend({\n      init: function( element, options ) {...},\n\n      '{element} li click': function( li ) {...},\n\n      '{element} li .destroy click': function( el, ev ) {\n        // get the li element that has todo data\n        var li = el.closest( 'li' );\n\n        // get the model\n        var todo = li.data( 'todo' );\n\n        //destroy it\n        todo.destroy();\n      }\n    });\n\nWhen the todo is destroyed, EJS's live binding will remove its LI automatically.\n\n### Templated Event Handlers Part 1 `\"{eventName}\"`\n\nCustomize event handler behavior with `\"{NAME}\"` in\nthe event handler name.  The following allows customization\nof the event that destroys a todo:\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n\n      '{element} li click': function( li ) { ... },\n\n      '{element} li .destroy {destroyEvent}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // create Todos with this.options.destroyEvent\n    new Todos( '#todos', { destroyEvent: 'mouseenter' } );\n\nValues inside `{NAME}` are looked up on the control's `this.options` first,\nand then the `window`. For example, we could customize it instead like:\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n\n      '{element} li click': function( li ) { ... },\n\n      '{element} li .destroy {Events.destroy}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // Events config\n    Events = { destroy: 'click' };\n\n    // Events.destroy is looked up on the window.\n    new Todos( '#todos' );\n\nThe selector can also be templated.\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n\n      '{element} {listElement} click': function( li ) { ... },\n\n      '{element} {listElement} .destroy {destroyEvent}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // create Todos with this.options.destroyEvent\n    new Todos( '#todos',  {\n      destroyEvent: 'mouseenter',\n      listElement: 'li'\n    } );\n\n### Templated Event Handlers Part 2 `\"{objectName}\"`\n\nControl can also bind to objects other than `this.element` with\ntemplated event handlers.  This is _critical_\nfor avoiding memory leaks that are so common among MVC applications.  \n\nIf the value inside `{NAME}` is an object, Control will bind to that\nobject to listen for events. For example, the following tooltip listens to\nclicks on the window:\n\n    var Tooltip = Control.extend({\n      '{window} click': function( el, ev ) {\n        // hide only if we clicked outside the tooltip\n        if ( !this.element.has( ev.target ) ) {\n          this.element.remove();\n        }\n      }\n    });\n\n    // create a Tooltip\n    new Tooltip( $( '<div>INFO</div>' ).appendTo( el ) );\n\nThis is convenient when listening for model changes. If EJS were not\ntaking care of removing `<li>`s after their associated models were destroyed,\nwe could implement it in `Todos` like:\n\n    var Todos = Control.extend({\n      init: function( element, options ) {...},\n\n      '{element} li click': function( li ) {...},\n\n      '{element} li .destroy click': function( el, ev ) {\n        // get the li element that has todo data\n        var li = el.closest( 'li' );\n\n        // get the model\n        var todo = li.data( 'todo' );\n\n        //destroy it\n        todo.destroy();\n      },\n\n      '{Todo} destroyed': function( Todo, ev, todoDestroyed ) {\n        // find where the element\n        var index = this.todosList.indexOf( todoDestroyed );\n        this.element.children( ':nth-child(' + ( index + 1 ) + ')' )\n                    .remove();\n      }\n    });\n\n    new Todos( '#todos' );\n\n### `on()`\n\n[can-control::on] rebinds a control's event handlers. This is useful when you want\nto listen to a specific model and change it:\n\n    var Editor = Control.extend({\n      todo: function( todo ) {\n        this.options.todo = todo;\n        this.on();\n        this.setName();\n      },\n\n      // a helper that sets the value of the input\n      // to the todo's name\n      setName: function() {\n        this.element.val( this.options.todo.name );\n      },\n\n      // listen for changes in the todo\n      // and update the input\n      '{todo} updated': function() {\n        this.setName();\n      },\n\n      // when the input changes\n      // update the todo instance\n      '{element} change': function() {\n        var todo = this.options.todo;\n        todo.attr( 'name', this.element.val() );\n        todo.save();\n      }\n    });\n\n    var todo1 = new Todo({ id: 6, name: 'trash' }),\n        todo2 = new Todo({ id: 6, name: 'dishes' });\n\n    // create the editor;\n    var editor = new Editor( '#editor' );\n\n    // show the first todo\n    editor.todo( todo1 );\n\n    // switch it to the second todo\n    editor.todo( todo2 );\n\n\n## Destroying a control\n\n[can-control::destroy] unbinds a control's\nevent handlers and releases its element, but does not remove\nthe element from the page.\n\n    var todo = new Todos( '#todos' );\n    todo.destroy();\n\nWhen a control's element is removed from the page\n__destroy__ is called automatically.\n\n    new Todos( '#todos' );\n    $( '#todos' ).remove();\n\nAll event handlers bound with Control are unbound when the control\nis destroyed (or its element is removed).\n\n_Brief aside on destroy and templated event binding. Taken\ntogether, templated event binding, and control's automatic\nclean-up make it almost impossible\nto write leaking applications. An application that uses\nonly templated event handlers on controls within the body\ncould free up all\ndata by calling `$(document.body).empty()`._\n\n## Tabs Example\n\nHere is an example of how to build a simple tab widget using Control:\n\n<iframe style=\"width: 100%; height: 300px\"\n        src=\"http://jsfiddle.net/donejs/kXLLt/embedded/result,html,js,css\"\n        allowfullscreen=\"allowfullscreen\"\n        frameborder=\"0\">JSFiddle</iframe>\n\n",
    "description": "Create organized, memory-leak free, rapidly performing, stateful controls with declarative event binding. Use `Control` to create UI\ncontrols like tabs, grids, and context menus,\nand organize them into higher-order business rules with\n[can.route]. It can serve as both a traditional view and a traditional controller.\n\n",
    "type": "module",
    "title": "can-control",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "name": "can-control",
    "parent": "can-dom-utilities",
    "collection": "can-infrastructure",
    "download": "can/route",
    "test": [
      "can/route/test.html",
      "can/control/test.html"
    ],
    "inherits": "can",
    "link": "../docco/control/control.html docco",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-control/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.3.1",
        "can-construct": "^3.2.0",
        "can-event": "^3.5.0",
        "can-namespace": "1.0.0",
        "can-observation": "^3.3.1",
        "can-reflect": "^1.2.1",
        "can-stache-key": "0.1.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Declarative event bindings",
      "devDependencies": {
        "can-define": "^1.3.3",
        "can-map": "^3.3.1",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.2.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "license": "MIT",
      "main": "can-control",
      "name": "can-control",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-control.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint can-control.js can-control_test.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.2.2"
    },
    "signatures": [
      {
        "code": "Control( [staticProperties,] instanceProperties )",
        "description": "\n\nCreate a new, extended, control constructor\nfunction. This functionality is inherited from [can-construct] and is deprecated in favor of using\n[can-control.extend].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "An object of properties and methods that are added the control constructor\nfunction directly. The most common property to add is [can-control.defaults].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "An object of properties and methods that belong to\ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers (see [Listening to events](#section_Listeningtoevents)).\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "constructs": {
                "types": [
                  {
                    "type": "can.Construct"
                  }
                ]
              },
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "element"
                    }
                  ]
                },
                {
                  "types": [
                    {
                      "type": "options"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n\n"
        }
      },
      {
        "code": "new Control( element, options )",
        "description": "\n\nCreate an instance of a control. [can.Control.prototype.setup] processes\nthe arguments and sets up event binding. Write your initialization\ncode in [can.Control.prototype.init]. Note, you never call `new Control()` directly,\ninstead, you call it on constructor functions extended from `Control`.\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "can-view-nodelist"
              },
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "element",
            "description": "Specifies the element the control will be created on.\n"
          },
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "can-map"
              },
              {
                "type": "can-define/map/map"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Option values merged with [can-control.defaults Control.defaults]\nand set as [can-control::options this.options]. If options is an observable ([can-map CanMap] / [can-define/map/map DefineMap]), any values from [can-control.defaults defaults] that do not exist on the observable will be set. The observable will then be set as [can-control::options this.options].\n\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-control"
            }
          ],
          "description": "A new instance of the constructor function extending Control.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-control"
        }
      ],
      "description": "A new instance of the constructor function extending Control.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "can-map"
        },
        {
          "type": "can-define/map/map"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Option values merged with [can-control.defaults Control.defaults]\nand set as [can-control::options this.options]. If options is an observable ([can-map CanMap] / [can-define/map/map DefineMap]), any values from [can-control.defaults defaults] that do not exist on the observable will be set. The observable will then be set as [can-control::options this.options].\n\n"
    },
    "comment": " "
  },
  "can-control.eventHandler": {
    "src": {
      "path": "node_modules/can-control/docs/eventHandler.md"
    },
    "body": "\n",
    "description": "\n",
    "type": "typedef",
    "title": "eventHandler(element, event)",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-control.eventHandler",
    "parent": "can-control.types",
    "signatures": [
      {
        "code": "function(element, event)",
        "description": "\n",
        "params": []
      }
    ],
    "hide": true
  },
  "can-control.eventDescription": {
    "src": {
      "path": "node_modules/can-control/docs/eventDescription.md"
    },
    "body": "\n",
    "description": "\n",
    "type": "typedef",
    "title": "eventDescription",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-control.eventDescription",
    "parent": "can-control.types",
    "signatures": [
      {
        "code": "\"[CONTEXT ][SELECTOR ]EVENTNAME\"",
        "description": "\n",
        "params": []
      }
    ],
    "hide": true
  },
  "can-control.extend": {
    "src": {
      "path": "node_modules/can-control/docs/control.extend.md"
    },
    "body": "\n## Examples\n\n    // Control that writes \"hello world\"\n    HelloWorld = Control.extend({\n      init: function(element){\n        element.text(\"hello world\")  \n      }\n    });\n    new HelloWorld(\"#message\");\n    \n    // Control that shows how many times\n    // the element has been clicked on\n    ClickCounter = Control.extend({\n      init: function(){\n         this.count = 0;\n         this.element.text(\"click me\")\n      },\n      \"{element} click\": function(){\n         this.count++;\n         this.element.text(\"click count = \"+this.count)\n      }\n    })\n    new ClickCounter(\"#counter\");\n \n    // Counter that counts a specified event\n    // type\n    CustomCounter = Control.extend({\n      defaults: {\n        eventType: \"click\"\n      }\n    },{\n      init: function(){\n        this.count = 0;\n        this.element.text(this.options.eventType+\" me\")\n      },\n      \"{element} {eventType}\": function(){\n         this.count++;\n         this.element.text(this.options.eventType+\n           \" count = \"+\n           this.count);\n      }\n    })\n    new CustomCounter(\"#counter\");\n    new CustomCounter(\"#buy\",{\n      eventType: \"mouseenter\"\n    });\n    \n\n",
    "description": "\n",
    "title": "extend",
    "name": "can-control.extend",
    "type": "function",
    "parent": "can-control.static",
    "signatures": [
      {
        "code": "Control.extend([staticProperties,] instanceProperties)",
        "description": "\n\nCreate a new, extended, control constructor \nfunction. \n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "An object of properties and methods that are added the control constructor \nfunction directly. The most common property to add is [can-control.defaults].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "constructs": {
                "types": [
                  {
                    "type": "can-construct"
                  }
                ]
              },
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "element"
                    }
                  ]
                },
                {
                  "types": [
                    {
                      "type": "options"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceProperties",
      "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "constructs": {
            "types": [
              {
                "type": "can-construct"
              }
            ]
          },
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "element"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "options"
                }
              ]
            }
          ]
        }
      ],
      "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n"
    },
    "comment": " "
  },
  "can-control.prototype.element": {
    "src": {
      "path": "node_modules/can-control/docs/element.md"
    },
    "body": "\nThe control instance's HTMLElement (or window) wrapped by the\nutil library for ease of use.\n\nIt is set by the first parameter to `new Construct( element, options )`\nin [can.Control::setup].  By default, a control listens to events on `this.element`.\n\n### Example - NodeList\n\nThe following `HelloWorld` control sets the control`s text to \"Hello World\":\n\n\tHelloWorld = Control({\n\t\tinit: function(){\n\t\t\tthis.element.text( 'Hello World' );\n\t\t}\n\t});\n\n\t// create the controller on the element\n\tnew HelloWorld( document.getElementById( '#helloworld' ) );\n\n## Wrapped NodeList\n\n`this.element` is a wrapped NodeList of one HTMLELement (or window).  This\nis for convenience in libraries like jQuery where all methods operate only on a\nNodeList.  To get the raw HTMLElement, write:\n\n\tthis.element[0] //-> HTMLElement\n\nThe following details the NodeList used by each library with\nan example of updating its text:\n\n__jQuery__ `jQuery( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Zepto__ `Zepto( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Dojo__ `new dojo.NodeList( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Mootools__ `$$( HTMLElement )`\n\n this.element.empty().appendText(\"Hello World\")\n\n__YUI__\n\n this.element.set(\"text\", \"Hello World\")\n\n## Changing `this.element`\n\nSometimes you don't want what's passed to `new Control`\nto be `this.element`.  You can change this by overwriting\nsetup or by unbinding, setting this.element, and rebinding.\n\n### Overwriting Setup\n\nThe following Combobox overwrites setup to wrap a\nselect element with a div.  That div is used\nas `this.element`. Notice how `destroy` sets back the\noriginal element.\n\n\tCombobox = Control({\n\t\tsetup: function( el, options ) {\n\t\t\tthis.oldElement = $( el );\n\t\t\tvar newEl = $( '<div/>' );\n\t\t\tthis.oldElement.wrap( newEl );\n\t\t\tcan.Control.prototype.setup.call( this, newEl, options );\n\t\t},\n\t\tinit: function() {\n\t\t\tthis.element //-> the div\n\t\t},\n\t\t\"{element} .option click\": function() {\n\t\t\t// event handler bound on the div\n\t\t},\n\t\tdestroy: function() {\n\t\t\tvar div = this.element; //save reference\n\t\t\tControl.prototype.destroy.call( this );\n\t\t\tdiv.replaceWith( this.oldElement );\n\t\t}\n\t});\n\n### Unbinding, setting, and rebinding.\n\nYou could also change this.element by calling\n[can.Control::off], setting this.element, and\nthen calling [can.Control::on] like:\n\n\tmove: function( newElement ) {\n\t\tthis.off();\n\t\tthis.element = $( newElement );\n\t\tthis.on();\n\t}\n\n",
    "description": "The element passed to the Control when creating a new instance. \n",
    "types": [
      {
        "type": "can-view-nodeList"
      }
    ],
    "title": "element",
    "name": "can-control.prototype.element",
    "type": "property",
    "parent": "can-control.prototype",
    "comment": " "
  },
  "can-control.prototype.options": {
    "src": {
      "path": "node_modules/can-control/docs/options.md"
    },
    "body": "## Options Object\n\nThe `this.options` property is an Object that contains\nconfiguration data passed to a control when it is\ncreated (`new Control(element, options)`).\n\nIn the following example, an options object with\na message is passed to a `Greeting` control. The\n`Greeting` control changes the text of its [can-control::element element]\nto the options' message value.\n\n\tvar Greeting = Control.extend({\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message )\n\t\t}\n\t});\n\n\tnew Greeting(\"#greeting\",{message: \"I understand this.options\"});\n\nThe options argument passed when creating the control\nis merged with [can-control.defaults defaults] in\n[can-control.prototype.setup setup].\n\nIn the following example, if no message property is provided,\nthe defaults' message property is used.\n\n\tvar Greeting = Control.extend({\n\t\tdefaults: {\n\t\t\tmessage: \"Defaults merged into this.options\"\n\t\t}\n\t},{\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message )\n\t\t}\n\t});\n\n\tnew Greeting(\"#greeting\");\n\n## Options Observable\nAn observable [can-map CanMap] or [can-define/map/map DefineMap] can also be passed instead of an options object.\n\nIn the following example, the defaults' message property is set on the [can-define/map/map DefineMap] options observable, which is then set directly as `this.options`:\n\n```\n\tvar GreetingControl = Control.extend({\n\t\tdefaults: {\n\t\t\tmessage: 'Hello'\n\t\t}\n\t}, {\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message + ' ' + this.options.name )\n\t\t}\n\t});\n\n\tvar GreetingMap = DefineMap.extend({\n\t\tmessage: 'string',\n\t\tname: 'string'\n\t});\n\n\tvar data = new GreetingMap();\n\tdata.name = 'Kevin';\n\n\tnew GreetingControl('#greeting', data);\n```\n\n",
    "description": "Options used to configure a control. \n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "options",
    "name": "can-control.prototype.options",
    "type": "property",
    "parent": "can-control.prototype",
    "comment": " "
  },
  "can-control.processors": {
    "src": {
      "path": "node_modules/can-control/docs/processors.md"
    },
    "body": "\n`processors` is an object that allows you to add new events to bind\nto on a control, or to change how existent events are bound. Each\nkey-value pair of `processors` is a specification that pertains to\nan event where the key is the name of the event, and the value is\na function that processes calls to bind to the event.\n\nThe processor function takes five arguments:\n\n- _el_: The Control's element.\n- _event_: The event type.\n- _selector_: The selector preceding the event in the binding used on the Control.\n- _callback_: The callback function being bound.\n- _control_: The Control the event is bound on.\n\nInside your processor function, you should bind _callback_ to the event, and\nreturn a function for can.Control to call when _callback_ needs to be unbound.\n(If _selector_ is defined, you will likely want to use some form of delegation\nto bind the event.)\n\nHere is a Control with a custom event processor set and two callbacks bound\nto that event:\n\n\tControl.processors.birthday = function(el, ev, selector, callback, control) {\n\tif(selector) {\n\t myFramework.delegate(ev, el, selector, callback);\n\t return function() { myFramework.undelegate(ev, el, selector, callback); };\n\t} else {\n\t myFramework.bind(ev, el, callback);\n\t return function() { myFramework.unbind(ev, el, callback); };\n\t}\n\t};\n\n\tControl(\"EventTarget\", { }, {\n\t'birthday': function(el, ev) {\n\t // do something appropriate for the occasion\n\t},\n\t'.grandchild birthday': function(el, ev) {\n\t // do something appropriate for the occasion\n\t}\n\t});\n\n\tvar target = new EventTarget('#person');\n\nWhen `target` is initialized, can.Control will call `Control.processors.birthday`\ntwice (because there are two event hookups for the _birthday_ event). The first\ntime it's called, the arguments will be:\n\n- _el_: A NodeList that wraps the element with id 'person'.\n- _ev_: `'birthday'`\n- _selector_: `''`\n- _callback_: The function assigned to `' birthday'` in the prototype section of `EventTarget`'s\ndefinition.\n- _control_: `target` itself.\n\nThe second time, the arguments are slightly different:\n\n- _el_: A NodeList that wraps the element with id 'person'.\n- _ev_: `'birthday'`\n- _selector_: `'.grandchild'`\n- _callback_: The function assigned to `'.grandchild birthday'` in the prototype section of `EventTarget`'s\ndefinition.\n- _control_: `target` itself.\n\nControl already has processors for these events:\n\n- change\n- click\n- contextmenu\n- dblclick\n- focusin\n- focusout\n- keydown\n- keyup\n- keypress\n- mousedown\n- mouseenter\n- mouseleave\n- mousemove\n- mouseout\n- mouseover\n- mouseup\n- reset\n- resize\n- scroll\n- select\n- submit\n\n",
    "description": "A collection of hookups for custom events on Controls. ",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "can-control.processor"
              }
            ]
          }
        ]
      }
    ],
    "title": "processors",
    "name": "can-control.processors",
    "type": "property",
    "parent": "can-control.static",
    "comment": " "
  },
  "can-control.prototype.on": {
    "src": {
      "path": "node_modules/can-control/docs/on.md"
    },
    "body": "`this.on()` is used to rebind\nall event handlers when [can-control::options this.options] has changed.  It\ncan also be used to bind or delegate from other elements or objects.\n\n## Rebinding\n\nBy using templated event handlers, a control can listen to objects outside\n`this.element`.  This is extremely common in MVC programming.  For example,\nthe following control might listen to a task model's `completed` property and\ntoggle a strike className like:\n\n\tTaskStriker = Control({\n\t\t\"{task} completed\": function(){\n\t\t\tthis.update();\n\t\t},\n\t\tupdate: function(){\n\t\t\tif ( this.options.task.completed ) {\n\t\t\t\tthis.element.addClass( 'strike' );\n\t\t\t} else {\n\t\t\t\tthis.element.removeClass( 'strike' );\n\t\t\t}\n\t\t}\n\t});\n\n\tvar taskstriker = new TaskStriker({\n\t\ttask: new Task({ completed: 'true' })\n\t});\n\nTo update the `taskstriker`'s task, add a task method that updates\nthis.options and rebinds the event handlers for the new task like:\n\n\tTaskStriker = Control({\n\t\t\"{task} completed\": function(){\n\t\t\tthis.update();\n\t\t},\n\t\tupdate: function() {\n\t\t\tif ( this.options.task.completed ) {\n\t\t\t\tthis.element.addClass( 'strike' );\n\t\t\t} else {\n\t\t\t\tthis.element.removeClass( 'strike' );\n\t\t\t}\n\t\t},\n\t\ttask: function( newTask ) {\n\t\t\t\tthis.options.task = newTask;\n\t\t\t\tthis.on();\n\t\t\t\tthis.update();\n\t\t}\n\t});\n\n\tvar taskstriker = new TaskStriker({\n\t\ttask: new Task({ completed: true })\n\t});\n\n\t// Now, add a new task that is not yet completed\n\ttaskstriker.task(new Task({ completed: false }));\n\n## Adding new events\n\nIf events need to be bound to outside of the control and templated event handlers\nare not sufficient, you can call this.on to bind or delegate programmatically:\n\n\tinit: function() {\n\t\t// calls somethingClicked( el, ev )\n\t\tthis.on( 'click', 'somethingClicked' );\n\n\t\t// calls function when the window is clicked\n\t\tthis.on( window, 'click', function( ev ) {\n\t\t\t// do something\n\t\t});\n\t},\n\t\tsomethingClicked: function( el, ev ) {\n\t\t // ...\n\t}\n\n",
    "description": "Bind an event handler to a Control, or rebind all event handlers on a Control. \n",
    "title": "on",
    "name": "can-control.prototype.on",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.on([el,] selector, eventName, func)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "jQuery"
              },
              {
                "type": "collection"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "el",
            "defaultValue": "this.element",
            "description": "\nThe element to be bound.  If no element is provided, the control's element is used instead."
          },
          {
            "types": [
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "selector",
            "description": "A CSS selector for event delegation."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              },
              {
                "type": "String"
              }
            ],
            "name": "func",
            "description": "A callback function or the String name of a control function.  If a control\nfunction name is given, the control function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The id of the binding in this._bindings.\n\n`on(el, selector, eventName, func)` binds an event handler for an event to a selector under the scope of the given element.\n"
        }
      },
      {
        "code": "control.on()",
        "description": "\n\nRebind all of a control's event handlers.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of handlers bound to this Control.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of handlers bound to this Control.\n"
    },
    "comment": " "
  },
  "can-control.prototype.setup": {
    "src": {
      "path": "node_modules/can-control/docs/setup.md"
    },
    "body": "\n## Lifecycle of `setup`\n\nSetup, when called, does the following:\n\n### Sets this.element\n\nThe first parameter passed to new Control( el, options ) is expected to be\nan element.  This gets converted to a Wrapped NodeList element and set as\n[can-control.prototype.element this.element].\n\n### Adds the control's name to the element's className\n\nControl adds it's plugin name to the element's className for easier\ndebugging.  For example, if your Control is named \"Foo.Bar\", it adds\n\"foo_bar\" to the className.\n\n### Saves the control in $.data\n\nA reference to the control instance is saved in $.data.  You can find\ninstances of \"Foo.Bar\" like:\n\n\t$( '#el' ).data( 'controls' )[ 'foo_bar' ]\n\n### Merges Options\n\nMerges the default options with optional user-supplied ones.\nAdditionally, default values are exposed in the static [can-control.static.defaults defaults]\nso that users can change them.\n\n### Binds event handlers\n\nSetup does the event binding described in [can-control].\n\n",
    "description": "Perform pre-initialization logic for control instances and classes.  \n",
    "title": "setup",
    "name": "can-control.prototype.setup",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.setup(element, options)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "NodeList"
              },
              {
                "type": "String"
              }
            ],
            "name": "element",
            "description": "The element as passed to the constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "options",
            "description": "option values for the control.  These get added to\nthis.options and merged with [can-control.static.defaults defaults]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "undefined"
            },
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "options",
      "description": "option values for the control.  These get added to\nthis.options and merged with [can-control.static.defaults defaults]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.\n"
    },
    "comment": " "
  },
  "can-define.types.ValueConstructor": {
    "src": {
      "path": "node_modules/can-define/docs/ValueConstructor.md"
    },
    "body": "\n\n## Use\n\n```js\nvar Address = DefineMap.extend({\n    street: {type: \"string\", value: \"321 Longbow\"},\n    city: {type: \"string\", value: \"Dallas\"}\n});\n\nvar Direction = DefineMap.extend({\n    from: {Type: Address, Value: Address},\n    to: {Type: Address, Value: Address}\n});\n\nvar direction = new Direction({\n    to: {street: \"2070 N. Stave\"}\n});\n\ndirection.from.street //-> \"321 Longbow\"\ndirection.to.street   //-> \"2070 N. Stave\"\n```\n\n",
    "description": "\nProvides a constructor function to be used to provide a default value for a property.  \n",
    "title": "Value",
    "name": "can-define.types.ValueConstructor",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Value",
        "description": "\n\nA constructor function can be provided that is called to create a default value used for this property.\nThis constructor will be invoked with `new` for each created instance. The default\nvalue is created on demand when the property is read for the first time.\n\nSpecify `Value` like:\n\n```js\nprop: {\n    Value: Array\n},\nperson: {\n\tValue: Person\n}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define.static": {
    "name": "can-define.static",
    "title": "static",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 0
  },
  "can-define.typedefs": {
    "name": "can-define.typedefs",
    "title": "types",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 1
  },
  "can-define.behaviors": {
    "name": "can-define.behaviors",
    "title": "behaviors",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 2
  },
  "can-define": {
    "src": {
      "path": "node_modules/can-define/docs/define.md"
    },
    "body": "\n\n## Use\n\n`can-define` provides a way to create custom types with observable properties.\nWhere [can-define/map/map] and [can-define/list/list] provide more functionality, they also make\nmore assumptions on the type constructor.  `can-define` can be used\nto create completely customized types.\n\n\nThe following creates a\n`Person` constructor function:\n\n```js\nvar define = require(\"can-define\");\n\nvar Person = function(first, last){\n  this.first = first;\n  this.last = last;\n};\ndefine(Person.prototype,{\n  first: { type: \"string\" },\n  last: { type: \"string\" },\n  fullName: {\n    get: function(){\n      return this.first+\" \"+this.last;\n    }\n  }\n});\n```\n\nThis can be used to create `Person` instances with observable properties:\n\n```js\nvar person = new Person(\"Justin\", \"Meyer\");\nperson.first    //-> \"Justin\"\nperson.last     //-> \"Meyer\"\nperson.fullName //-> \"Justin Meyer\"\n\nperson.on(\"fullName\", function(ev, newVal, oldVal){\n    newVal //-> \"Ramiya Meyer\"\n    oldVal //-> \"Justin Meyer\"\n});\n\nperson.first = \"Ramiya\"\n```\n\nThe observable properties call [can-observation.add Observation.add] so they can be observed by\n[can-compute].\n\n",
    "description": "Exports the `define` method that defines observable properties and their behavior on a prototype object.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define",
    "parent": "can-observables",
    "collection": "can-core",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-define/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-compute": "^3.3.1",
        "can-construct": "^3.2.0",
        "can-define-lazy-value": "^1.0.0",
        "can-event": "^3.5.0",
        "can-log": "^0.1.0",
        "can-namespace": "^1.0.0",
        "can-observation": "^3.3.4",
        "can-reflect": "^1.2.1",
        "can-simple-observable": "^1.0.0",
        "can-symbol": "^1.0.0",
        "can-test-helpers": "^1.1.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Create observable objects with JS dot operator compatibility",
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "serve": "^6.0.1",
        "steal": "^1.0.7",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.4.0",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-define",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "can-define.js",
      "name": "can-define",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-define.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint --config .jshintrc --exclude ./node_modules,./dist .",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "start": "serve -p 8080",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "1.5.3"
    },
    "signatures": [
      {
        "code": "define(prototype, propDefinitions)",
        "description": "\n\nDefine observable properties, type conversion, and getter/setter logic on [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain prototype objects].\n\n```js\nvar define = require(\"can-define\");\n\nvar Greeting = function(message){\n    this.message = message;\n};\n\ndefine(Greeting.prototype,{\n    message: {type: \"string\"}\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "prototype",
            "description": "The prototype object of a constructor function or [class](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class). The prototype\nobject will have getter/setters defined on it that carry out the defined behavior.  The prototype will also contain\nall of [can-event]'s methods.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "propDefinitions",
            "description": "An object of\nproperties and their definitions.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "propDefinitions",
      "description": "An object of\nproperties and their definitions.\n\n"
    },
    "comment": " "
  },
  "can-define.types.TypeConstructor": {
    "src": {
      "path": "node_modules/can-define/docs/TypeConstructor.md"
    },
    "body": "\n\n## Use\n\n```js\nvar Address = DefineMap.extend({\n    street: \"string\",\n    city: \"string\"\n});\n\nvar Direction = DefineMap.extend({\n    from: {Type: Address},\n    to: Address\n});\n\nvar direction = new Direction({\n    from: {street: \"2060 N. Stave\", city: \"Chicago\"},\n    to: new Address({street: \"123 Greenview\", city: \"Libertyville\"})\n});\n```\n\n",
    "description": "\nProvides a constructor function to be used to convert any set value into an appropriate\nvalue.\n",
    "type": "typedef",
    "title": "Type",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      },
      {
        "type": "can-define.types.propDefinition"
      },
      {
        "type": "Array",
        "options": []
      }
    ],
    "name": "can-define.types.TypeConstructor",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Type",
        "description": "\n\nA constructor function can be provided that is called to convert incoming values set on this property, like:\n\n```js\nprop: {\n  Type: Person\n}\n```    \n\n`Type` is called before [can-define.types.type] and before [can-define.types.set]. It checks if the incoming value\nis an [instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) `Type`. If it is, or if it is `null` or `undefined`, it passes the original value through.  If not, it passes the original value to `new Type(originalValue)` and returns the\nnew instance to be set.\n",
        "params": []
      },
      {
        "code": "{propDefinition}",
        "description": "\n\nA [can-define.types.propDefinition] that defines an inline [can-define/map/map] type.  For example:\n\n```js\naddress: {\n    Type: {\n        street: \"string\",\n        city: \"string\"\n    }\n}\n```\n",
        "params": []
      },
      {
        "code": "[Type|propDefinition]",
        "description": "\n\nDefines an inline [can-define/list/list] type that's an array of `Type` or inline `propDefinition` [can-define/map/map]\ninstances.  For example:\n\n```js\npeople: {\n    Type: [Person]\n},\naddresses: {\n    Type: [{\n        street: \"string\",\n        city: \"string\"\n    }]\n}\n```\n\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define.types.serialize": {
    "src": {
      "path": "node_modules/can-define/docs/serialize.md"
    },
    "body": "\n\n## Use\n\n[can-define/map/map.prototype.serialize] is useful for serializing an instance into\na more JSON-friendly form.  This can be used for many reasons, including saving a\n[can-connect]ed instance on the server or serializing [can-route.map can-route.map]'s internal\nmap for display in the hash or pushstate URL.\n\nThe serialize property allows an opportunity to define how\neach property will behave when the instance is serialized.  This can be useful for:\n\n- serializing complex types like dates, arrays, or objects into string formats\n- causing certain properties to be ignored when serialize is called\n\nThe following causes a locationIds property to be serialized into\nthe comma separated ID values of the location property on this instance:\n\n```js\nlocationIds: {\n    serialize: function(){\n        return this.locations.map(function(location){\n            ids.push(location.id);\n        }).join(',');\n    }\n}\n```\n\nReturning `undefined` for any property means this property will not be part of the serialized\nobject.  For example, if the property numPages is not greater than zero, the following example\nwon't include it in the serialized object.\n\n```js\nprop: {\n    numPages: {\n        serialize: function( num ){\n            if(num <= 0) {\n            \treturn undefined;\n            }\n            return num;\n        }\n    }\n}\n```\n\n",
    "description": "\nDefines custom serialization behavior for a property.\n",
    "title": "serialize",
    "name": "can-define.types.serialize",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Boolean",
        "description": "\n\nSpecifies if the property should be serialized.  By default, all properties except for\nones with defined [can-define.types.get getters] are serialized. Prevent a property\nfrom being serialized like:\n\n```js\npropertyName: {\n    serialize: false\n}\n```\n\nMake a [can-define.types.get getter] property part of the serialized result like:\n\n```js\npropertyName: {\n    get: function(){ ... },\n    serialize: true\n}\n```\n",
        "params": []
      },
      {
        "code": "serialize( currentValue, propertyName )",
        "description": "\n\nSpecifies the serialized value of a property.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "currentValue",
            "description": "The current value of the attribute.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The name of the property being serialized.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If `undefined` is returned, the value is not serialized.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "propertyName",
      "description": "The name of the property being serialized.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If `undefined` is returned, the value is not serialized.\n"
    },
    "comment": " "
  },
  "can-define.types.type": {
    "src": {
      "path": "node_modules/can-define/docs/type.md"
    },
    "body": "\n\n## Use\n\nThe `type` property specifies the type of the attribute.  The type can be specified\nas either:\n\n- A type function that returns the type coerced value.\n- A named type in [can-define.types].\n- An object that gets converted into an inline `DefineMap`.\n- An array that gets converted to an inline `DefineList`.\n\n### Basic Example\n\nThe following example converts the `count` property to a number and the `items` property to an array:\n\n```js\nDefineMap.extend({\n    count: {type: \"number\"},\n    items: {\n        type: function(newValue){\n            if(typeof newValue === \"string\") {\n                return newValue.split(\",\")\n            } else if( Array.isArray(newValue) ) {\n                return newValue;\n            }\n        }\n    }\n});\n```\n\nWhen a user tries to set those properties like:\n\n    map.set({count: \"4\", items: \"1,2,3\"});\n\nThe number converter will be used to turn count into 4, and the items type converter function will be used to turn items into [1,2,3].\n\n### Preventing Arrays and Objects from Automatic Conversion\n\nWhen an array value is set, it is automatically converted into a DefineList. Likewise, objects are converted into DefineMap instances. This behavior can be prevented like the following:\n\n\n     locations: {type: \"any\"}\n\n\nWhen a user tries to set this property, the resulting value will remain an array.\n\n    map.locations = [1, 2, 3]; // locations is an array, not a DefineList\n\n### Working with the 'compute' type\n\nSetting type as `compute` allows for resolving a computed property with the .attr()\nmethod.\n\n```\nMyMap = DefineMap.extend({\n    value: {\n        type: \"compute\"\n    }\n});\n\nvar myMap = new MyMap();\nvar c = compute(5);\n\nmyMap.value = c;\nmyMap.value //-> 5\n\nc(6);\nmyMap.value //-> 6\n\n//Be sure if setting to pass the new compute\nvar c2 = compute(\"a\");\nmyMap.value = c2;\nmyMap.value //-> \"a\"\n```\n\n",
    "description": "\nConverts a value set on an instance into an appropriate value.\n",
    "type": "typedef",
    "title": "type",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      },
      {
        "type": "string"
      }
    ],
    "name": "can-define.types.type",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "type(newValue, propertyName)",
        "description": "\n\nGiven the set value, transform it into a value appropriate to be set.\n`type` is called before [can-define.types.set].  \n\n```js\nage: {\n    type: function(newValue, propertyName){\n        return +newValue;\n    }\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newValue",
            "description": "The value set on the property."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The property name being set.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
        }
      },
      {
        "code": "\"typeName\"",
        "description": "\n\nSets the type to a named type in [can-define.types].  The default typeName is `\"observable\"`.\n\n```js\nage: {\n    type: \"number\"\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "typeName",
            "description": "A named type in [can-define.types].\n\n"
          }
        ]
      },
      {
        "code": "{propDefinition}",
        "description": "\n\nA [can-define.types.propDefinition] that defines an inline [can-define/map/map] type.  For example:\n\n```js\naddress: {\n    type: {\n        street: \"string\",\n        city: \"string\"\n    }\n}\n```\n",
        "params": []
      },
      {
        "code": "[Type|propDefinition]",
        "description": "\n\nDefines an inline [can-define/list/list] type that's an array of `Type` or inline `propDefinition` [can-define/map/map]\ninstances.  For example:\n\n```js\npeople: {\n    type: [Person]\n},\naddresses: {\n    type: [{\n        street: \"string\",\n        city: \"string\"\n    }]\n}\n```\n\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
    },
    "comment": " "
  },
  "can-define.types": {
    "src": {
      "path": "node_modules/can-define/docs/define.types.md"
    },
    "body": "\n\n## Use\n\nUse any of the type names on a [can-define.types.propDefinition]'s `type` or directly on the prototype of a [can-define/map/map DefineMap] or [can-define/map/map DefineList].\n\n```js\nvar define = require(\"can-define\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Animal = function(name){\n    this.name = name;\n};\ndefine(Animal.prototype,{\n    name: {type: \"string\"}\n});\n\nvar Person = DefineMap.extend({\n    name: \"string\"\n});\n```\n\nYou can also pass these functions in directly:\n\n\n```js\nvar define = require(\"can-define\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Animal = function(name){\n    this.name = name;\n};\ndefine(Animal.prototype,{\n    name: {type: define.type.string}\n});\n\nvar Person = DefineMap.extend({\n    name: define.type.string\n});\n```\n\n",
    "description": "Defines the type, initial value, and get, set, and serialize behavior for an\nobservable property. All type converters leave `null` and `undefined` as is except for\nthe `\"htmlbool\"` type converter.\n",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "observable",
            "description": "The default type behavior. It converts plain Objects to\n[can-define/map/map DefineMaps] and plain Arrays to [can-define/list/list DefineLists]. Everything else is left as is.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "any",
            "description": "Leaves the set value as is, performs no type conversion. Aliased as `*`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "string",
            "description": "Converts to a string with `\"\"+val`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "date",
            "description": "Converts to a JavaScript date using `Date.parse(val)` if a string is given or `new Date(val)` if a number is passed.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "number",
            "description": "Converts to a number with `+(val)`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "boolean",
            "description": "Converts to `false` if `val` is falsey, `\"0\"`, or `\"false\"`; otherwise, converts to `true`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "htmlbool",
            "description": "Like `boolean`, but converts to `true` if empty string (`\"\"`) is passed.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "compute",
            "description": "Allows computes to be passed and the property take on the value of the compute.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "stringOrObservable",
            "description": "Converts plain Objects to [can-define/map/map DefineMaps], plain Arrays to [can-define/list/list DefineLists] and everything else to strings.  This is useful for routing.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "title": "types",
    "name": "can-define.types",
    "type": "property",
    "parent": "can-define.static",
    "comment": " "
  },
  "can-define.types.propDefinition": {
    "src": {
      "path": "node_modules/can-define/docs/types.propDefinition.md"
    },
    "body": "\n\n\n## Use\n\nA property definition can be defined in several ways.  The `Object` form is the most literal\nand directly represents a `PropDefinition` object.  The other forms\nget converted to a `PropDefinition` as follows:\n\n\n```js\nDefineMap.extend({\n  propertyA: Object      -> PropertyDefinition\n  propertyB: String      -> {type: String}\n  propertyC: Constructor -> {Type: Constructor}\n  propertyD: [PropDefs]  -> {Type: DefineList.extend({\"#\": PropDefs})>}\n  get propertyE(){...}   -> {get: propertyE(){...}}\n  set propertyF(){...}   -> {get: propertyF(){...}}\n  method: Function\n})\n```\n\nWithin a property definition, the available properties and their signatures look like:\n\n```js\nDefineMap.extend({\n  property: {\n    get: function(lastSetValue, resolve){...},\n    set: function(newValue, resolve){...},\n\n    type: function(newValue, prop){...}| Array<PropertyDefinition> | PropertyDefinition,\n    Type: Constructor | Array<PropertyDefinition> | PropertyDefinition,\n\n    value: function(){...},\n    Value: Constructor,\n\n    serialize: Boolean | function(){...}\n  }\n})\n```\n\nFor example:\n\n\n```js\nvar Person = DefineMap.extend(\"Person\",{\n  // a `DefineList` of `Address`\n  addresses: [Address],\n  // A `DefineMap` with a `first` and `last` property\n  name: { type: {first: \"string\", last: \"string\"} },\n  // A `DefineList of a ``DefineMap` with a `make` and `year` property.\n  cars: { Type: [{make: \"string\", year: \"number\"}] }\n});\n\nvar person = new Person({\n  addresses: [{street: \"1134 Pinetree\"}],\n  name: {first: \"Kath\", last: \"Iann\"}\n  cars: [{ make: \"Nissan\", year: 2010 }]\n});\n```\n\n",
    "description": "\nDefines the type, initial value, and get, set, and serialize behavior for an\nobservable property.  These behaviors can be specified with as an `Object`, `String`,\n`Constructor` function, `Array`, a `getter expression`, or `setter expression`.\n",
    "type": "typedef",
    "title": "PropDefinition",
    "types": [
      {
        "type": "Object",
        "description": "Defines multiple behaviors for a single property.\n\n```js\npropertyName: {\n  get: function(){ ... },\n  set: function(){ ... },\n  type: function(){ ... },\n  Type: Constructor,\n  value: function(){ ... },\n  Value: Constructor,\n  serialize: function(){ ... }\n}\n```\n",
        "options": [
          {
            "name": "value",
            "description": "Specifies the initial value of the property or\na function that returns the initial value.\n\n```js\n// A default age of `0`:\nvar Person = DefineMap.extend({\n  age: {\n    value: 0\n  },\n  address: {\n    value: function(){\n      return {city: \"Chicago\", state: \"IL\"};\n    };\n  }\n});\n```\n",
            "types": [
              {
                "type": "can-define.types.value"
              }
            ]
          },
          {
            "name": "Value",
            "description": "Specifies a function that will be called with `new` whose result is\nset as the initial value of the attribute.\n\n```js\n// A default empty DefineList of hobbies:\nvar Person = DefineMap.extend({\n  hobbies: {Value: DefineList}\n});\n\nnew Person().hobbies //-> []\n```\n",
            "types": [
              {
                "type": "can-define.types.ValueConstructor"
              }
            ]
          },
          {
            "name": "type",
            "description": "Specifies the type of the\nproperty.  The type can be specified as either a function\nthat returns the type coerced value or one of the [can-define.types] names.\n\n```js\nvar Person = DefineMap.extend({\n  age: {type: \"number\"},\n  hobbies: {\n    type: function(newValue){\n      if(typeof newValue === \"string\") {\n        return newValue.split(\",\")\n      } else if( Array.isArray(newValue) ) {\n        return newValue;\n      }\n    }\n  }\n});\n```\n",
            "types": [
              {
                "type": "can-define.types.type"
              }
            ]
          },
          {
            "name": "Type",
            "description": "A constructor function that takes\nthe assigned property value as the first argument and called with new. For example, the following will call\n`new Address(newValue)` with whatever non null, undefined, or address type is set as a `Person`'s address property.\n\n```js\nvar Address = DefineMap.extend({\n  street: \"string\",\n  state: \"string\"    \n});\n\nvar Person = DefineMap.extend({\n  address: {Type: Address}    \n});\n```\n",
            "types": [
              {
                "type": "can-define.types.TypeConstructor"
              }
            ]
          },
          {
            "name": "set",
            "description": "A set function that specifies what should happen when a property is set. `set` is called with the result of `type` or `Type`. The following\ndefines a `page` setter that updates the map's offset:\n\n```js\nDefineMap.extend({\n  page: {\n    set: function(newVal){\n      this.offset = (parseInt(newVal) - 1) * this.limit;\n    }\n  }\n});\n```\n",
            "types": [
              {
                "type": "can-define.types.set"
              }
            ]
          },
          {
            "name": "get",
            "description": "A function that specifies how the value is retrieved.  The get function is\nconverted to an [can-compute.async async compute].  It should derive its value from other values on the object. The following\ndefines a `page` getter that reads from a map's offset and limit:\n\n```js\nDefineMap.extend({\n  page: {\n    get: function (newVal) {\n\t  return Math.floor(this.offset / this.limit) + 1;\n\t}\n  }\n});\n```\n\nA `get` definition makes the property __computed__ which means it will not be enumerable by default.\n",
            "types": [
              {
                "type": "can-define.types.get"
              }
            ]
          },
          {
            "name": "serialize",
            "description": "Specifies the behavior of the property when [can-define/map/map::serialize serialize] is called.\n\nBy default, serialize does not include computed values. Properties with a `get` definition\nare computed and therefore are not added to the result.  Non-computed properties values are\nserialized if possible and added to the result.\n\n```js\nvar Todo = DefineMap.extend({\n  date: {\n    type: \"date\",\n    serialize: function(value) {\n      return value.getTime();\n    }\n  }\n});\n",
            "types": [
              {
                "type": "can-define.types.serialize"
              }
            ]
          }
        ]
      },
      {
        "type": "String",
        "description": "Defines a [can-define.types.type] converter as one of the named types in [can-define.types].\n\n```js\npropertyName: \"typeName\"\n```\n"
      },
      {
        "type": "Constructor",
        "description": "Either creates a method or Defines a [can-define.types.TypeConstructor Type] setting with a constructor function.  Constructor functions are identified with [can-reflect.isConstructorLike].\n\n```\npropertyName: Constructor\n```\nOR\n```\npropertyName: function() {}\n```\n\nFor example:\n```js\nsubMap: DefineMap // <- sets Type to DefineMap\n```\nOR\n```js\nincrement: function() { ++this.count } // <- sets method prop\n```\n"
      },
      {
        "type": "Array",
        "description": "Defines an inline [can-define/list/list] Type setting. This is\nused as a shorthand for creating a property that is an [can-define/list/list] of another type.\n\n```\npropertyName: [Constructor | propDefinitions]\n```\n\nFor example:\n\n```js\nusers: [User],\ntodos: [{complete: \"boolean\", name: \"string\"}]\n```\n",
        "options": []
      },
      {
        "type": "GETTER",
        "description": "Defines a property's [can-define.types.get] behavior with the\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get syntax].\n\n```js\nget propertyName(){ ... }\n```\n\nFor example:\n\n```js\nget fullName() {\n    return this.first + \" \" + this.last;\n}\n```\n\nThis is a shorthand for providing an object with a `get` property like:\n\n```\nfullName: {\n    get: function(){\n        return this.first + \" \" + this.last;\n    }\n}\n```\n\nYou must use an object with a [can-define.types.get] property if you want your get to take the `lastSetValue`\nor `resolve` arguments.\n"
      },
      {
        "type": "SETTER",
        "description": "Defines a property's [can-define.types.set] behavior with the\n[set syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set).\n\n```js\nset propertyName(newValue){ ... }\n```\n\nFor example:\n\n```js\nset fullName(newValue) {\n    var parts = newVal.split(\" \");\n    this.first = parts[0];\n    this.last = parts[1];\n}\n```\n\nThis is a shorthand for providing an object with a `set` property like:\n\n```\nfullName: {\n    set: function(newValue){\n        var parts = newVal.split(\" \");\n        this.first = parts[0];\n        this.last = parts[1];\n    }\n}\n```\n\nYou must use an object with a [can-define.types.set] property if you want your set to take the `resolve` argument.\n\n"
      }
    ],
    "name": "can-define.types.propDefinition",
    "parent": "can-define.typedefs",
    "comment": " "
  },
  "can-define.types.value": {
    "src": {
      "path": "node_modules/can-define/docs/value.md"
    },
    "body": "\n\nThere is a third way to provide a default value, which is explained in the [can-define.types.ValueConstructor Value] docs page. `value` lowercased is for providing default values for a property type, while `Value` uppercased is for providing a constructor function, which will be invoked with `new` to create a default value for each instance of this map.\n\n```js\n// A default age of `0`:\nvar Person = DefineMap.extend({\n  age: {\n    value: 0\n  },\n  address: {\n    value: function(){\n      return {city: \"Chicago\", state: \"IL\"};\n    };\n  }\n});\n```\n\n",
    "description": "\nReturns the default value for instances of the defined type.  The default value is defined on demand, when the property\nis read for the first time.\n",
    "title": "value",
    "name": "can-define.types.value",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "value()",
        "description": "\n\nA function can be provided that returns the default value used for this property, like:\n\n```js\nprop: {\n  value: function(){ return []; }\n}\n```\n\n\nIf the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property `value` above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The default value.  This will be passed through setter and type.\n"
        }
      },
      {
        "code": "value",
        "description": "\n\nAny value can be provided as the default value used for this property, like:\n\n```\nprop: {\n  value: 'foo'\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "defaultVal",
            "description": "The default value, which will be passed through setter and type.\n"
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The default value.  This will be passed through setter and type.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "defaultVal",
      "description": "The default value, which will be passed through setter and type.\n"
    },
    "comment": " "
  },
  "can-define.types.set": {
    "src": {
      "path": "node_modules/can-define/docs/types.set.md"
    },
    "body": "\n\n## Use\n\nA property's `set` function can be used to customize the behavior of when an attribute value is set.  Lets see some common cases:\n\n#### Side effects\n\nThe following makes setting a `page` property update the `offset`:\n\n\n```js\npage: {\n    set: function(newVal){\n        this.offset =  (parseInt(newVal) - 1) * this.limit;\n    }\n}\n```\n\nThe following makes changing `makeId` un-define the `modelId` property:\n\n```\nmakeId: {\n    set: function(newValue){\n        // Check if we are changing.\n        if(newValue !== this.makeId) {\n            this.modelId = undefined;\n        }\n        // Must return value to set as we have a `newValue` argument.\n        return newValue;\n    }\n}\n```\n\n#### Asynchronous Setter\n\nThe following shows an async setter:\n\n```js\nprop: {\n    set: function( newVal, setVal){\n        $.get(\"/something\", {}, setVal );\n    }\n}\n```\n\n\n## Behavior depends on the number of arguments.\n\nWhen a setter returns `undefined`, its behavior changes depending on the number of arguments.\n\nWith 0 arguments, the original set value is set on the attribute.\n\n```js\nMyMap = DefineMap.extend({\n    prop: {set: function(){}}\n})\n\nvar map = new MyMap({prop : \"foo\"});\n\nmap.prop //-> \"foo\"\n```\n\nWith 1 argument, an `undefined` return value will set the property to `undefined`.  \n\n```js\nMyMap = DefineMap.extend({\n    prop: {set: function(newVal){}}\n})\n\nvar map = new MyMap({prop : \"foo\"});\n\nmap.prop //-> undefined\n```\n\nWith 2 arguments, `undefined` leaves the property in place.  It is expected\nthat `resolve` will be called:\n\n```js\nMyMap = DefineMap.extend({\n    prop: {\n        set: function(newVal, resolve){\n            setVal(newVal+\"d\");\n        }\n    }\n});\n\nvar map = new MyMap({prop : \"foo\"});\n\nmap.prop //-> \"food\";\n```\n\n## Side effects\n\nA set function provides a useful hook for performing side effect logic as a certain property is being changed.\n\nFor example, in the example below, Paginator DefineMap includes a `page` property, which derives its value entirely from other properties (limit and offset).  If something tries to set the `page` directly, the set method will set the value of `offset`:\n\n```js\nvar Paginate = DefineMap.extend({\n    limit: 'number',\n    offset: 'number',\n    page: {\n        set: function (newVal) {\n            this.offset = (parseInt(newVal) - 1) * this.limit;\n        },\n        get: function () {\n            return Math.floor(this.offset / this.limit) + 1;\n        }\n    }\n});\n\nvar p = new Paginate({limit: 10, offset: 20});\n```\n\n\n\n## Merging\n\nBy default, if a value returned from a setter is an object the effect will be to replace the property with the new object completely.\n\n```js\nvar Contact = DefineMap.extend({\n    info: {\n        set: function(newVal){\n            return newVal;\n        }\n    }\n})\n\nvar alice = new Contact({\n\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n});\n\nvar info  = alice.info;\n\nalice.info = {name: 'Allison Wonderland', phone: '888-888-8888'};\n\ninfo === alice.info // -> false\n```\n\nIn contrast, you can merge properties with:\n\n```js\nContact = DefineMap.extend({\n    info: {\n        set: function(newVal){\n            if(this.info) {\n                return this.info.set(newVal);\n            } else {\n                return newVal;\n            }\n        }\n    }\n});\n\nvar alice = new Contact({\n\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n});\n\nvar info  = alice.info;\n\nalice.info = {name: 'Allison Wonderland', phone: '888-888-8888'};\n\ninfo === alice.info // -> true\n```\n\n## Batched Changes\n\nBy default, calls to `set` methods are wrapped in a call to [can-event/batch/batch.start canBatch.start] and [can-event/batch/batch.stop canBatch.stop], so if a set method has side effects that set more than one property, all these sets are wrapped in a single batch for better performance.\n\n",
    "description": "\nSpecify what happens when a property value is set.\n",
    "title": "set",
    "name": "can-define.types.set",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "set( [newVal,] [resolve] )",
        "description": "\n\nA set function defines the behavior of what happens when a value is set on an\ninstance. It is typically used to:\n\n - Add or update other properties as side effects\n - Coerce the set value into an appropriate action\n\nThe behavior of the setter depends on the number of arguments specified. This means that a\nsetter like:\n\n```js\nprop: {\n    set: function(){}\n}\n```\n\nbehaves differently than:\n\n```js\nprop: {\n    set: function(newVal){}\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "The [can-define.types.type type function] coerced value the user intends to set on the\ninstance.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "resolve",
            "description": "A callback that can set the value of the property\nasynchronously.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the property value is set to the type converted value.\n - If the setter specifies the `newValue` argument only, the attribute value will be set to `undefined`.\n - If the setter specifies both `newValue` and `resolve`, the value of the property will not be\n   updated until `resolve` is called.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ]
        }
      ],
      "optional": true,
      "name": "resolve",
      "description": "A callback that can set the value of the property\nasynchronously.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the property value is set to the type converted value.\n - If the setter specifies the `newValue` argument only, the attribute value will be set to `undefined`.\n - If the setter specifies both `newValue` and `resolve`, the value of the property will not be\n   updated until `resolve` is called.\n\n"
    },
    "comment": " "
  },
  "can-define.types.get": {
    "src": {
      "path": "node_modules/can-define/docs/types.get.md"
    },
    "body": "\n\n\n## Use\n\nGetter methods are useful for:\n\n - Defining virtual properties on a map.\n - Defining property values that change with their _internal_ set value.\n\n## Virtual properties\n\n\nVirtual properties are properties that don't actually store any value, but derive their value\nfrom some other properties on the map.\n\nWhenever a getter is provided, it is wrapped in a [can-compute], which ensures\nthat whenever its dependent properties change, a change event will fire for this property also.\n\n```js\nvar Person = DefineMap.extend({\n    first: \"string\",\n    last: \"string\",\n\tfullName: {\n\t\tget: function () {\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n});\n\nvar p = new Person({first: \"Justin\", last: \"Meyer\"});\n\np.fullName; // \"Justin Meyer\"\n\np.on(\"fullName\", function(ev, newVal){\n  newVal //-> \"Lincoln Meyer\";\n});\n\np.first = \"Lincoln\";\n```\n\n## Asynchronous virtual properties\n\nOften, a virtual property's value only becomes available after some period of time.  For example,\ngiven a `personId`, one might want to retrieve a related person:\n\n```js\nvar AppState = DefineMap.extend({\n    personId: \"number\",\n    person: {\n        get: function(lastSetValue, resolve){\n          Person.get({id: this.personId})\n        \t.then(function(person){\n                       resolve(person);\n        \t});\n        }\n    }\n});\n```\n\nAsynchronous properties should be bound to before reading their value.  If\nthey are not bound to, the `get` function will be called each time.\n\nThe following example will make multiple `Person.get` requests:\n\n```\nvar state = new AppState({personId: 5});\nstate.person //-> undefined\n\n// called sometime later ...\nstate.person //-> undefined\n```\n\nHowever, by binding, the compute only reruns the `get` function once `personId` changes:\n\n```\nvar state = new AppState({personId: 5});\n\nstate.on(\"person\", function(){})\n\nstate.person //-> undefined\n\n// called sometime later\nstate.person //-> Person<{id: 5}>\n```\n\nA template like [can-stache] will automatically bind for you, so you can pass\n`state` to the template like the following without binding:\n\n```\nvar template = stache(\"<span>{{person.fullName}}</span>\");\nvar state = new AppState({});\nvar frag = template(state);\n\nstate.personId = 5;\nfrag.childNodes[0].innerHTML //=> \"\"\n\n// sometime later\nfrag.childNodes[0].innerHTML //=> \"Lincoln Meyer\"\n```\n\nThe magic tags are updated as `personId`, `person`, and `fullName` change.\n\n\n## Properties values that change with their _internal_ set value\n\nA getter can be used to derive a value from a set value. A getter's\n`lastSetValue` argument is the last value set by `instance.propertyName = value`.\n\nFor example, a property might be set to a compute, but when read, provides the value\nof the compute.\n\n```\nvar MyMap = DefineMap.extend({\n    value: {\n        get: function( lastSetValue ){\n            return lastSetValue();\n        }\n    }\n});\n\nvar map = new MyMap();\nvar compute = compute(1);\nmap.value = compute;\n\nmap.value //-> 1\ncompute(2);\nmap.value //-> 2\n```\n\nThis technique should only be used when the `lastSetValue` is some form of\nobservable, that when it changes, can update the `getter` value.\n\nFor simple conversions, [can-define.types.set] or [can-define.types.type] should be used.\n\n## Updating the virtual property value\n\nIt's common to update virtual property values\ninstead of replacing it.\n\nThe following example creates an empty `locationIds` [can-define/list/list] when a new\ninstance of `Store` is created.  However, as `locations` change,\nthe [can-define/list/list] will be updated with the `id`s of the `locations`.\n\n\n```\nvar Store = DefineMap.extend({\n    locations: DefineList,\n\tlocationIds: {\n\t\tValue: DefineList,\n\t\tget: function(initialValue){\n\t\t\tvar ids = this.locations.map(function(location){\n\t\t\t\tids.push(location.id);\n\t\t\t});\n\t\t\treturn initialValue.replace(ids);\n\t\t}\n\t}\n});\n```\n\n",
    "description": "\nSpecify what happens when a certain property is read on a map. `get` functions\nwork like a [can-compute] and automatically update themselves when a dependent\nobservable value is changed.\n",
    "title": "get",
    "name": "can-define.types.get",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "get( [lastSetValue] )",
        "description": "\n\nDefines the behavior when a property value is read on a instance. Used to provide properties that derive their value from\nother properties on the object, or the property value that was set on the object.\n\nSpecify `get` like:\n\n```js\npropertyName: {\n    get: function(){ ... }\n},\npropertyName: {\n    get: function(lastSetValue) { ... }\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The value last set by `instance.propertyName = value`.  Typically, _lastSetValue_\nshould be an observable value, like a [can-compute] or promise. If it's not, it's likely\nthat a [can-define.types.set] should be used instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property.\n"
        }
      },
      {
        "code": "get( lastSetValue, resolve(value) )",
        "description": "\n\nAsynchronously defines the behavior when a value is read on an instance. Used to provide property values that\nare available asynchronously.\n\nOnly observed properties (via [can-event.on], [can-event.addEventListener], etc) will be passed the `resolve` function.  It will be `undefined` if the value is not observed. This is for memory safety.\n\nSpecify `get` like:\n\n```js\npropertyName: {\n  get: function(lastSetValue, resolve){ ... }\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "lastSetValue",
            "description": "The value last set by `instance.propertyName = value`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "name": "value"
                  }
                ]
              },
              {
                "type": "undefined"
              }
            ],
            "name": "resolve",
            "description": "Updates the value of the property. This can be called\nmultiple times if needed. Will be `undefined` if the value is not observed.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property before `resolve` is called.  Or a value for unobserved property reads\nto return.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of the property before `resolve` is called.  Or a value for unobserved property reads\nto return.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "name": "value"
            }
          ]
        },
        {
          "type": "undefined"
        }
      ],
      "name": "resolve",
      "description": "Updates the value of the property. This can be called\nmultiple times if needed. Will be `undefined` if the value is not observed.\n"
    },
    "comment": " "
  },
  "can-define/list/list": {
    "name": "can-define/list/list",
    "type": "module",
    "src": {
      "path": "node_modules/can-define/list/docs/define-list.md"
    },
    "body": "\n\n## Use\n\nThe `can-define/list/list` module exports a `DefineList` constructor function.  It can be used\nwith `new` to create observable lists that behave very similar to `Array`s.  For example:\n\n```js\nvar list = new DefineList([\"a\",\"b\", \"c\"]);\nlist[0] //-> \"a\";\n\nlist.push(\"x\");\nlist.pop() //-> \"x\"\n```\n\nIt can also be extended to define custom observable list types with\n[can-define/list/list.extend].  For example, the following defines a `StringList` type\nwhere every item is converted to a string by specifying the [can-define/list/list.prototype.wildcardItems items definition] `(#)`:\n\n```js\nvar StringList = DefineList.extend({\n\t\"#\": \"string\"\n});\n\nvar strings = new StringList([1,new Date(1475370478173),false]);\n\nstrings[0] //-> \"1\"\nstrings[1] //-> \"Sat Oct 01 2016 20:07:58 GMT-0500 (CDT)\"\nstrings[2] //-> \"false\"\n```\n\nNon-numeric properties can also be defined on custom DefineList type.  The following\ndefines a `completed` property that returns the completed todos:\n\n```js\nvar TodoList = DefineList.extend({\n\t\"#\": Todo,\n\tget completed(){\n\t\treturn this.filter({complete: true})\n\t}\n});\n\nvar todos = new TodoList([{complete: true}, {complete:false}]);\ntodos.completed.length //-> 1\n```\n\nFinally, DefineList instances are observable, so you can use the [can-event]\nmethods to listen to its [can-define/list/list/AddEvent],\n[can-define/list/list/LengthEvent], [can-define/list/list/RemoveEvent],\nand [can-define/list/list/PropertyNameEvent] events:\n\n```js\nvar people = new DefineList([\"alice\",\"bob\",\"eve\"]);\n\npeople.on(\"add\", function(ev, items, index){\n\tconsole.log(\"add\", items, index);\n}).on(\"remove\", function(ev, items, index){\n\tconsole.log(\"remove\", items, index);\n}).on(\"length\", function(ev, newVal, oldVal){\n\tconsole.log(\"length\", newVal, oldVal);\n})\n\npeople.pop(); // remove [\"eve\"] 2\n              // length 2 3\n\npeople.unshift(\"Xerxes\"); // add [\"Xerxes\"] 1\n                          // length 3 2\n```\n\n__NOTE:__ Only changes made to indexed values using the list's `set` method will dispatch change events.\n👍  `defineList.set(0, 'newValue'); // will dispatch event`\n👎  `defineList[0] = 'newValue'; // will NOT dispatch event`\n\n",
    "description": "Create observable lists. \n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-observables",
    "collection": "can-core",
    "alias": "can.DefineList",
    "inherits": "can.Construct",
    "signatures": [
      {
        "code": "new DefineList([items])",
        "description": "\n\nCreates an instance of a DefineList or an extended DefineList with enumerated properties from `items`.\n\n```js\nvar DefineList = require(\"can-define/list/list\");\n\nvar people = new DefineList([\n  { first: \"Justin\", last: \"Meyer\" },\n  { first: \"Paula\", last: \"Strozak\" }\n])\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "items",
            "description": "An array of items to seed the list with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "An instance of `DefineList` with the values from _items_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "items",
      "description": "An array of items to seed the list with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "An instance of `DefineList` with the values from _items_.\n"
    },
    "comment": " "
  },
  "can-define/list/list.static": {
    "src": {
      "line": 41,
      "codeLine": 42,
      "path": "node_modules/can-define/list/list.js"
    },
    "type": "static",
    "body": "",
    "description": "",
    "name": "can-define/list/list.static",
    "parent": "can-define/list/list",
    "title": "static"
  },
  "can-define/list/list.prototype": {
    "src": {
      "line": 60,
      "codeLine": 61,
      "path": "node_modules/can-define/list/list.js"
    },
    "type": "prototype",
    "body": "",
    "description": "",
    "name": "can-define/list/list.prototype",
    "parent": "can-define/list/list",
    "title": "prototype"
  },
  "can-define/list/list.prototype.get": {
    "type": "function",
    "name": "can-define/list/list.prototype.get",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 121,
      "codeLine": 175,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nGets an item or all items from a DefineList.\n",
    "title": "get",
    "signatures": [
      {
        "code": "list.get()",
        "description": "\n\nReturns the list converted into a plain JS array. Any items that also have a\n`get` method will have their `get` method called and the resulting value will be used as item value.\n\nThis can be used to recursively convert a list instance to an Array of other plain JavaScript objects.\nCycles are supported and only create one object.\n\n`get()` can still return other non-plain JS objects like Dates.\nUse [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.get() //-> [\"A\",\"B\"]\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "A plain JavaScript `Array` that contains each item in the list.\n"
        }
      },
      {
        "code": "list.get(index)",
        "description": "\n\nGets the item at `index`. `list.get(index)` should be used instead of\n`list[index]` if the list's items are going to be updated via [can-define/list/list.prototype.set list.set(index, value)]\n(as opposed to [can-define/list/list.prototype.splice] which is the better way).\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.get(1) //-> \"B\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "A numeric position in the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at index.\n"
        }
      },
      {
        "code": "list.get(prop)",
        "description": "\n\nGets the property at `prop` if it might not have already been defined.\n\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(\"count\",1000)\nlist.get(\"count\") //-> 1000\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "A property on the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at `prop`.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value at `prop`.\n\t "
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "prop",
      "description": "A property on the list.\n"
    }
  },
  "can-define/list/list.prototype.set": {
    "type": "function",
    "name": "can-define/list/list.prototype.set",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 183,
      "codeLine": 246,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "",
    "description": "Sets an item or property or items or properties on a list. \n",
    "title": "set",
    "deprecated": [
      {
        "version": "3.10.1",
        "description": "Using .set with {Object} `props` has been deprecated in favour of `assign` and `update`\n"
      }
    ],
    "signatures": [
      {
        "code": "list.set(prop, value)",
        "description": "\n\nSets the property at `prop`. This should be used when the property\nisn't already defined.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(\"count\",1000);\nlist.get(\"count\") //-> 1000;\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "prop",
            "description": "A property name."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to add to the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(newProps)",
        "description": "\n\nUpdates the properties on the list with `newProps`.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set({count: 1000, skip: 2});\nlist.get(\"count\") //-> 1000\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "newProps",
            "description": "An object of properties and values to set on the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(index, value)",
        "description": "\n\nSets the item at `index`.  Typically, [can-define/list/list::splice] should be used instead.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(2,\"C\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "A numeric position in the list."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to add to the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(newItems [,replaceAll])",
        "description": "\n\nReplaces items in the list with `newItems`\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set([\"c\"])        //-> DefineList[\"c\",\"B\"]\nlist.set([\"x\"], true)  //-> DefineList[\"x\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "newItems",
            "description": "Items used to replace existing items in the list."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "replaceAll",
            "description": "If true, will remove items at the end of the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance.\n\t "
    },
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "replaceAll",
      "description": "If true, will remove items at the end of the list."
    }
  },
  "can-define/list/list.prototype.assign": {
    "type": "function",
    "name": "can-define/list/list.prototype.assign",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 290,
      "codeLine": 308,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nSets items or properties on a list.\n",
    "title": "assign",
    "signatures": [
      {
        "code": "list.assign(newProps)",
        "description": "\n\nAssigns the properties on the list with `newProps`. Properties not present in `newProps` will be left unchanged.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.assign({count: 1000, skip: 2});\nlist.get(\"count\") //-> 1000\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "newProps",
            "description": "Properties that need to be assigned to the list instance"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "newProps",
      "description": "Properties that need to be assigned to the list instance"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance.\n\t "
    }
  },
  "can-define/list/list.prototype.update": {
    "type": "function",
    "name": "can-define/list/list.prototype.update",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 316,
      "codeLine": 336,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nSets an item or property or items or properties on a list.\n",
    "title": "update",
    "signatures": [
      {
        "code": "list.update(newProps)",
        "description": "\n\nUpdates the properties on the list with `newProps`. Properties not in `newProps` will be set to `undefined`.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.assign({count: 0, skip: 2});\nlist.update({count: 1000});\nlist.get(\"count\") //-> 1000\nlist.get(\"skip\") //-> undefined\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "newProps",
            "description": "Properties that need to be updated to the list instance"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "newProps",
      "description": "Properties that need to be updated to the list instance"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance.\n\t "
    }
  },
  "can-define/list/list.prototype.assignDeep": {
    "type": "function",
    "name": "can-define/list/list.prototype.assignDeep",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 344,
      "codeLine": 367,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nSets an item or property or items or properties on a list.\n",
    "title": "assignDeep",
    "signatures": [
      {
        "code": "list.assignDeep(newProps)",
        "description": "\n\nUpdates the properties on the list with `newProps`. Properties not in `newProps` will be left unchanged.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.assign({count: 1, skip: 2});\nlist.get(\"count\") //-> 1\n\nlist.assignDeep({count: 1000});\nlist.get(\"count\") //-> 1000\nlist.get(\"skip\") //-> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "newProps",
            "description": "Properties that need to be assigned to the list instance"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "newProps",
      "description": "Properties that need to be assigned to the list instance"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance.\n\t "
    }
  },
  "can-define/list/list.prototype.updateDeep": {
    "type": "function",
    "name": "can-define/list/list.prototype.updateDeep",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 375,
      "codeLine": 397,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nSets an item or property or items or properties on a list.\n",
    "title": "updateDeep",
    "signatures": [
      {
        "code": "list.updateDeep(newProps)",
        "description": "\n\nRecursively updates the properties on the list with `newProps`. Properties not in `newProps` will be set to `undefined`.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.assign({count: 0, skip: 2, foo: {bar: 'zed', a: 'b'}});\nlist.updateDeep({foo: {bar: 'yay'}});\n\nlist.get(\"count\") //-> undefined\nlist.get(\"skip\") //-> undefined\nlist.get(\"foo\") // -> {bar: 'yay', a: undefined}\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "newProps",
            "description": "Properties that need to be updated on the list instance"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "newProps",
      "description": "Properties that need to be updated on the list instance"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance.\n\t "
    }
  },
  "can-define/list/list.prototype.splice": {
    "type": "function",
    "name": "can-define/list/list.prototype.splice",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 418,
      "codeLine": 463,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`splice` lets you remove elements from and insert elements into a DefineList.\n\nThis example demonstrates how to do surgery on a list of numbers:\n\n```\nvar list = new DefineList([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.get(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n## Events\n\n`splice` causes the DefineList it's called on to emit\n_add_ events, _remove_ events, and _length_ events. If there are\nany elements to remove, a _remove_ event, and a\n_length_ event will be fired. If there are any elements to insert, a\nseparate _add_ event, and a separate _length_ event\nwill be fired.\n\n\t \n",
    "description": "Insert and remove elements from a DefineList. ",
    "title": "splice",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newItems]])",
        "description": "\n\nRemoves `howMany` items at `index` and adds `newItems` in their place.\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "Where to start removing or inserting elements.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "The number of elements to remove\nIf _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the DefineList.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newItems",
            "description": "Items to insert into the DefineList\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "The elements removed by `splice`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newItems",
      "description": "Items to insert into the DefineList\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "The elements removed by `splice`.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.serialize": {
    "type": "function",
    "name": "can-define/list/list.prototype.serialize",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 512,
      "codeLine": 536,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nReturns the a serialized version of this list.\n",
    "title": "serialize",
    "signatures": [
      {
        "code": "list.serialize()",
        "description": "\n\nGoes through each item in the list and gets its serialized\nvalue and returns them in a plain Array.\n\nEach items serialized value is the result of calling `.serialize()`\non the item or if the item doesn't have a `serialize` method,\nthe item itself.\n\n```\nvar list = new DefineList([\"first\", {foo: \"bar\"}]);\nvar serializedList = list.serialize();\n\nserializedList //-> [\"first\", {foo: \"bar\"}]\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "An array with each item's serialied value.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "An array with each item's serialied value.\n\t "
    }
  },
  "can-define/list/list.prototype.push": {
    "name": "can-define/list/list.prototype.push",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 549,
      "codeLine": 599,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`push` adds elements onto the end of a DefineList here is an example:\n\n```\nvar list = new DefineList(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.get(); // ['Alice', 'Bob', 'Eve']\n```\n\nIf you have an array you want to concatenate to the end\nof the DefineList, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new DefineList(['Alice']);\n\nlist.push.apply(list, names);\nlist.get(); // ['Alice', 'Bob', 'Eve']\n```\n\n## Events\n\n`push` causes _add_, and _length_ events to be fired.\n\n## See also\n\n`push` has a counterpart in [can-define/list/list::pop pop], or you may be\nlooking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\n\t \n",
    "description": "Add elements to the end of a list. ",
    "title": "push",
    "signatures": [
      {
        "code": "list.push(...elements)",
        "description": "\n\n`push` adds elements onto the end of a DefineList.\n\n```\nvar names = new DefineList(['Alice']);\nnames.push('Bob', 'Eve');\nnames //-> DefineList['Alice','Bob', 'Eve']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the DefineList\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the DefineList\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the DefineList\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the DefineList\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.unshift": {
    "name": "can-define/list/list.prototype.unshift",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 600,
      "codeLine": 644,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n\n\nIf you have an array you want to concatenate to the beginning\nof the DefineList, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new DefineList(['Alice']);\n\nlist.unshift.apply(list, names);\nlist.get(); // ['Bob', 'Eve', 'Alice']\n```\n\n## Events\n\n`unshift` causes _add_ and _length_ events to be fired.\n\n## See also\n\n`unshift` has a counterpart in [can-define/list/list::shift shift], or you may be\nlooking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\n\t \n",
    "description": "Add items to the beginning of a DefineList. ",
    "title": "unshift",
    "signatures": [
      {
        "code": "list.unshift(...items)",
        "description": "\n\n`unshift` adds items onto the beginning of a DefineList.\n\n```\nvar list = new DefineList(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist; // DefineList['Bob', 'Eve', 'Alice']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "items",
            "description": "The items to add to the DefineList.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The new length of the DefineList.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "items",
      "description": "The items to add to the DefineList.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The new length of the DefineList.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.pop": {
    "name": "can-define/list/list.prototype.pop",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 682,
      "codeLine": 721,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`pop` is the opposite action from [can-define/list/list::push push]:\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined\n```\n\n## Events\n\n`pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\nwhen it is called.\n\n## See also\n\n`pop` has its counterpart in [can-define/list/list::push push], or you may be\nlooking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\n\t \n",
    "description": "Remove an element from the end of a DefineList. ",
    "title": "pop",
    "signatures": [
      {
        "code": "list.pop()",
        "description": "\n\n`pop` removes an element from the end of a DefineList.\n\n```js\nvar names = new DefineList(['Alice', 'Bob', 'Eve']);\nnames.pop() //-> 'Eve'\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The element just popped off the DefineList, or `undefined` if the DefineList was empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The element just popped off the DefineList, or `undefined` if the DefineList was empty\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.shift": {
    "name": "can-define/list/list.prototype.shift",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 722,
      "codeLine": 754,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`shift` is the opposite action from `[can-define/list/list::unshift unshift]`:\n\n## Events\n\n`pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\nwhen it is called.\n\n## See also\n\n`shift` has a counterpart in [can-define/list/list::unshift unshift], or you may be\nlooking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\n\t \n",
    "description": "Remove an item from the front of a list. ",
    "title": "shift",
    "signatures": [
      {
        "code": "list.shift()",
        "description": "\n\n`shift` removes an element from the beginning of a DefineList.\n\n```\nvar list = new DefineList(['Alice','Adam']);\nlist.shift(); //-> 'Alice'\nlist.shift(); //-> 'Adam'\nlist.shift(); //-> undefined\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The element just shifted off the DefineList, or `undefined` if the DefineList is empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The element just shifted off the DefineList, or `undefined` if the DefineList is empty\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.map": {
    "name": "can-define/list/list.prototype.map",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 790,
      "codeLine": 823,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Map the values in this list to another list. \n",
    "title": "map",
    "signatures": [
      {
        "code": "list.map(callback[, thisArg])",
        "description": "\n\nLoops through the values of the list, calling `callback` for each one until the list\nends.  The return values of `callback` are used to populate the returned list.\n\n```js\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar names = todos.map(function(todo){\n  return todo.name;\n});\nnames //-> DefineList[\"dishes\",\"lawn\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe three parameters that callback gets passed are:\n   - item (*) - the element at index.\n   - index (Integer) - the index of the current element of the list.\n   - list (DefineList) - the `DefineList` the elements are coming from.\n\nThe return value of `callback`, including `undefined` values are used to populate the resulting list.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "a new `DefineList` with the results of the map transform."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "a new `DefineList` with the results of the map transform."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.filter": {
    "name": "can-define/list/list.prototype.filter",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 824,
      "codeLine": 870,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nFilter a list to a new list of the matched items.\n",
    "title": "filter",
    "signatures": [
      {
        "code": "list.filter( callback [,thisArg] )",
        "description": "\n\nFilters `list` based on the return value of `callback`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\nvar aNames = names.filter(function(name){\n  return name[0] === \"a\"\n});\naNames //-> DefineList[\"alice\",\"adam\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can-define/list/list"
                      }
                    ],
                    "name": "list"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A\nfunction to call with each element of the DefineList. The three parameters that callback gets passed are:\n - item (*) - the element at index.\n - index (Integer) - the index of the current element of the list.\n - list (DefineList) - the `DefineList` the elements are coming from.\n\nIf `callback` returns a truthy result, `item` will be added to the result.  Otherwise, the `item` will be\nexcluded.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "thisArg",
            "description": "What `this` should be in the `callback`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A new instance of this `DefineList` (may be a subclass), containing the items that passed the filter.\n"
        }
      },
      {
        "code": "list.filter( props )",
        "description": "\n\nFilters items in `list` based on the property values in `props`.\n\n```\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar complete = todos.filter({complete: true});\ncomplete //-> DefineList[{name: \"lawn\", complete: true}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to be in the returned list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A new `DefineList` of the same type.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A new `DefineList` of the same type.\n "
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to be in the returned list."
    }
  },
  "can-define/list/list.prototype.reduce": {
    "name": "can-define/list/list.prototype.reduce",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 871,
      "codeLine": 909,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Map the values in this list to a single value \n",
    "title": "reduce",
    "signatures": [
      {
        "code": "list.reduce(callback, initialValue, [, thisArg])",
        "description": "\n\nLoops through the values of the list, calling `callback` for each one until the list\nends.  The return value of `callback` is passed to the next iteration as the first argument,\nand finally returned by `reduce`.\n\n```js\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar todosAsOneObject = todos.reduce(function(todos, todo){\n  todos[todo.name] = todo.complete;\n  return todos;\n}, {});\ntodosAsOneObject //-> { dishes: false, lawn: true }\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe four parameters that callback gets passed are:\n   - current (*) - the current aggregate value of reducing over the list -- the initial value if the first iteration\n   - item (*) - the element at index.\n   - index (Integer) - the index of the current element of the list.\n   - list (DefineList) - the `DefineList` the elements are coming from.\n\nThe return value of `callback` is passed to the next iteration as the first argument, and returned from\n`reduce` if the last iteration.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "initialValue",
            "description": "The initial value to use as `current` in the first iteration"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The result of the final call of `callback` on the list."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The result of the final call of `callback` on the list."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.reduceRight": {
    "name": "can-define/list/list.prototype.reduceRight",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 910,
      "codeLine": 948,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Map the values in this list to a single value from right to left \n",
    "title": "reduceRight",
    "signatures": [
      {
        "code": "list.reduceRight(callback, initialValue, [, thisArg])",
        "description": "\n\nLoops through the values of the list in reverse order, calling `callback` for each one until the list\nends.  The return value of `callback` is passed to the next iteration as the first argument,\nand finally returned by `reduce`.\n\n```js\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar todosAsOneObject = todos.reduce(function(todos, todo){\n  todos[todo.name] = todo.complete;\n  return todos;\n}, {});\ntodosAsOneObject //-> { dishes: false, lawn: true }\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe four parameters that callback gets passed are:\n   - current (*) - the current aggregate value of reducing over the list -- the initial value if the first iteration\n   - item (*) - the element at index.\n   - index (Integer) - the index of the current element of the list.\n   - list (DefineList) - the `DefineList` the elements are coming from.\n\nThe return value of `callback` is passed to the next iteration as the first argument, and returned from\n`reduce` if the last iteration.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "initialValue",
            "description": "The initial value to use as `current` in the first iteration"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The result of the final call of `callback` on the list."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The result of the final call of `callback` on the list."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.every": {
    "name": "can-define/list/list.prototype.every",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 949,
      "codeLine": 997,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nReturn true if every item in a list matches a predicate.\n",
    "title": "every",
    "signatures": [
      {
        "code": "list.every( callback [,thisArg] )",
        "description": "\n\nTests each item in `list` by calling `callback` on it.  If `callback` returns truthy for every element in\n`list`, `every` returns `true`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\nvar aNames = names.every(function(name){\n  return name[0] === \"a\"\n});\naNames //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can-define/list/list"
                      }
                    ],
                    "name": "list"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A\nfunction to call with each element of the DefineList. The three parameters that callback gets passed are:\n - item (*) - the element at index.\n - index (Integer) - the index of the current element of the list.\n - list (DefineList) - the `DefineList` the elements are coming from.\n\nIf `callback` returns a truthy result, `every` will evaluate the callback on the next element.  Otherwise, `every`\nwill return `false`.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "thisArg",
            "description": "What `this` should be in the `callback`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if calling the callback on every element in `list` returns a truthy value, `false` otherwise.\n"
        }
      },
      {
        "code": "list.every( props )",
        "description": "\n\nTests each item in `list` by comparing its properties to `props`.  If `props` match for every element in\n`list`, `every` returns `true`.\n\n```\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar complete = todos.every({complete: true});\ncomplete //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to match."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if every element in `list` matches `props`, `false` otherwise\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if every element in `list` matches `props`, `false` otherwise\n "
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to match."
    }
  },
  "can-define/list/list.prototype.some": {
    "name": "can-define/list/list.prototype.some",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 998,
      "codeLine": 1046,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nReturn true if at least one item in a list matches a predicate.\n",
    "title": "some",
    "signatures": [
      {
        "code": "list.some( callback [,thisArg] )",
        "description": "\n\nTests each item in `list` by calling `callback` on it.  If `callback` returns truthy for some element in\n`list`, `some` returns `true`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\nvar aNames = names.some(function(name){\n  return name[0] === \"a\"\n});\naNames //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can-define/list/list"
                      }
                    ],
                    "name": "list"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A\nfunction to call with each element of the DefineList. The three parameters that callback gets passed are:\n - item (*) - the element at index.\n - index (Integer) - the index of the current element of the list.\n - list (DefineList) - the DefineList the elements are coming from.\n\nIf `callback` returns a falsy result, `some` will evaluate the callback on the next element.  Otherwise, `some`\nwill return `true`.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "thisArg",
            "description": "What `this` should be in the `callback`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`false` if calling the callback on some element in `list` returns a falsy value, `true` otherwise.\n"
        }
      },
      {
        "code": "list.some( props )",
        "description": "\n\nTests each item in `list` by comparing its properties to `props`.  If `props` match for some element in\n`list`, `some` returns `true`.\n\n```\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar complete = todos.some({complete: true});\ncomplete //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to match."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`false` if every element in `list` fails to match `props`, `true` otherwise\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`false` if every element in `list` fails to match `props`, `true` otherwise\n "
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to match."
    }
  },
  "can-define/list/list.prototype.indexOf": {
    "type": "function",
    "name": "can-define/list/list.prototype.indexOf",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1081,
      "codeLine": 1101,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Look for an item in a DefineList. ",
    "title": "indexOf",
    "signatures": [
      {
        "code": "list.indexOf(item)",
        "description": "\n\n`indexOf` finds the position of a given item in the DefineList.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "The item to find.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "The item to find.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.lastIndexOf": {
    "type": "function",
    "name": "can-define/list/list.prototype.lastIndexOf",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1110,
      "codeLine": 1130,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Look for an item in a DefineList starting from the end. ",
    "title": "lastIndexOf",
    "signatures": [
      {
        "code": "list.lastIndexOf(item)",
        "description": "\n\n`lastIndexOf` finds the last position of a given item in the DefineList.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Alice', 'Eve']);\nlist.lastIndexOf('Alice');   // 2\nlist.lastIndexOf('Charlie'); // -1\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "The item to find.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "The item to find.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.join": {
    "type": "function",
    "name": "can-define/list/list.prototype.join",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1140,
      "codeLine": 1158,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "",
    "description": "Join a DefineList's elements into a string. ",
    "title": "join",
    "signatures": [
      {
        "code": "list.join(separator)",
        "description": "\n\n`join` turns a DefineList into a string by inserting _separator_ between the string representations\nof all the elements of the DefineList.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "separator",
            "description": "The string to seperate elements.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The joined string.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "separator",
      "description": "The string to seperate elements.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The joined string.\n\n "
    }
  },
  "can-define/list/list.prototype.reverse": {
    "type": "function",
    "name": "can-define/list/list.prototype.reverse",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1163,
      "codeLine": 1183,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Reverse the order of a DefineList. ",
    "title": "reverse",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\nReverses the elements of the DefineList in place.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList; //-> DefineList['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The DefineList, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The DefineList, for chaining.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.slice": {
    "type": "function",
    "name": "can-define/list/list.prototype.slice",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1189,
      "codeLine": 1223,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`slice` is the simplest way to copy a DefineList:\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy           //-> DefineList['Alice', 'Bob', 'Eve']\nlist === copy; //-> false\n```\n \n",
    "description": "Make a copy of a part of a DefineList. ",
    "title": "slice",
    "signatures": [
      {
        "code": "list.slice([start[, end]])",
        "description": "\n\n`slice` creates a copy of a portion of the DefineList.\n\n```js\nvar list = new DefineList(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList //-> DefineList['Bob', 'Charlie', 'Daniel']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "start",
            "defaultValue": "0",
            "description": "The index to start copying from. Defaults to `0`.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "end",
            "description": "The first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A new `DefineList` with the extracted elements.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "end",
      "description": "The first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A new `DefineList` with the extracted elements.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.concat": {
    "type": "function",
    "name": "can-define/list/list.prototype.concat",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1230,
      "codeLine": 1260,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`concat` makes a new DefineList with the elements of the DefineList followed by the elements of the parameters.\n\n```\nvar list = new DefineList();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new DefineList(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.get(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n```\n \n",
    "description": "Merge many collections together into a DefineList. ",
    "title": "concat",
    "signatures": [
      {
        "code": "list.concat(...args)",
        "description": "\n\nReturns a `DefineList` with the `list`'s items and the additional `args`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can-define/list/list"
              },
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a DefineList, each of its elements will be added to\nthe end of the concatenated DefineList. Otherwise, the parameter itself will be added.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A DefineList of the same type.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can-define/list/list"
        },
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a DefineList, each of its elements will be added to\nthe end of the concatenated DefineList. Otherwise, the parameter itself will be added.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A DefineList of the same type.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.forEach": {
    "type": "function",
    "name": "can-define/list/list.prototype.forEach",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1286,
      "codeLine": 1322,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`forEach` calls a callback for each element in the DefineList.\n\n```\nvar list = new DefineList([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.get(index, element * element);\n});\nlist.get(); // [1, 4, 9]\n```\n \n",
    "description": "Call a function for each element of a DefineList. ",
    "title": "forEach",
    "signatures": [
      {
        "code": "list.forEach(callback[, thisArg])",
        "description": "\n\nLoops through the values of the list, calling `callback` for each one until the list ends\nor `false` is returned.\n\n```\nlist.forEach(function(item, index, list){ ... })\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe three parameters that callback gets passed are:\n   - item - the element at index.\n   - index - the current element of the list.\n   - list - the DefineList the elements are coming from.\n\nIf the callback returns `false` the looping stops.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.replace": {
    "type": "function",
    "name": "can-define/list/list.prototype.replace",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1333,
      "codeLine": 1359,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`replace` is essentially a shortcut for [can-define/list/list.prototype.splice].\n\n## Events\n\n`replace` causes _remove_, _add_, and _length_ events.\n \n",
    "description": "Replace all the elements of a DefineList. ",
    "title": "replace",
    "signatures": [
      {
        "code": "list.replace(collection)",
        "description": "\n\nReplaces every item in the list with `collection`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"eve\"]);\nnames.replace([\"Justin\",\"Xena\"]);\nnames //-> DefineList[\"Justin\",\"Xena\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can-define/list/list"
              }
            ],
            "name": "collection",
            "description": "The collection of items that will be in `list`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "Returns the `list`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can-define/list/list"
        }
      ],
      "name": "collection",
      "description": "The collection of items that will be in `list`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "Returns the `list`.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.sort": {
    "type": "function",
    "name": "can-define/list/list.prototype.sort",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1373,
      "codeLine": 1417,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "```\n \n",
    "description": "Sort the properties of a list. \n",
    "title": "sort",
    "signatures": [
      {
        "code": "list.sort([compareFunction])",
        "description": "\n\nSorts the elements of a list in place and returns the list. The API is the\nsame as the native JavaScript `Array.prototype.sort` API.\n\n```js\nvar accounts = new Account.List([\n  { name: \"Savings\", amount: 20.00 },\n  { name: \"Checking\", amount: 103.24 },\n  { name: \"Kids Savings\", amount: 48155.13 }\n]);\naccounts.sort(function(a, b){\n  if (a.name < b.name) {\n    return -1;\n  } else if (a.name > b.name){\n    return 1;\n  } else {\n    return 0;\n  }\n});\naccounts[0].name === \"Checking\"\naccounts[1].name === \"Kids Savings\"\naccounts[2].name === \"Savings\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "a"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "b"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "compareFunction",
            "description": "Specifies a function that defines the sort order.\n\nIf `compareFunction` is supplied, the list elements are sorted according to the return\nvalue of the compare function. If `a` and `b` are two elements being compared, then:\n\n - If `compareFunction(a, b)` returns a value less than 0, `a` will be sorted to\n a lower index than `b`, so `a` will now come first.\n - If `compareFunction(a, b)` returns 0, the order of the two values will not be changed.\n - If `compareFunction(a, b)` returns a value greater than 0, `a` will be sorted to\n a higher index than `b`, so `b` will now come first.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "a"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "b"
                }
              ]
            }
          ]
        }
      ],
      "name": "compareFunction",
      "description": "Specifies a function that defines the sort order.\n\nIf `compareFunction` is supplied, the list elements are sorted according to the return\nvalue of the compare function. If `a` and `b` are two elements being compared, then:\n\n - If `compareFunction(a, b)` returns a value less than 0, `a` will be sorted to\n a lower index than `b`, so `a` will now come first.\n - If `compareFunction(a, b)` returns 0, the order of the two values will not be changed.\n - If `compareFunction(a, b)` returns a value greater than 0, `a` will be sorted to\n a higher index than `b`, so `b` will now come first.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance."
    },
    "comment": " "
  },
  "can-define/map/map.prototype.get": {
    "type": "function",
    "name": "can-define/map/map.prototype.get",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 108,
      "codeLine": 146,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Get a value or all values from a DefineMap. \n",
    "title": "get",
    "signatures": [
      {
        "code": "map.get()",
        "description": "\n\nReturns a plain JavaScript object that contains the properties and values of the map instance.  Any property values\nthat also have a `get` method will have their `get` method called and the resulting value will be used as\nthe property value.  This can be used to recursively convert a map instance to an object of other plain\nJavaScript objects.  Cycles are supported and only create one object.\n\n`.get()` can still return other non plain JS objects like Date.\nUse [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\n\n```js\nvar map = new DefineMap({foo: new DefineMap({bar: \"zed\"})});\nmap.get() //-> {foo: {bar: \"zed\"}};\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A plain JavaScript `Object` that contains all the properties and values of the map instance.\n"
        }
      },
      {
        "code": "map.get(propName)",
        "description": "\n\nGet a single property on a DefineMap instance.\n\n`.get(propName)` only should be used when reading properties that might not have been defined yet, but\nwill be later via [can-define/map/map.prototype.set].\n\n```js\nvar map = new DefineMap();\nmap.get(\"name\") //-> undefined;\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "The property name of a property that may not have been defined yet."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of that property.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of that property.\n "
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "propName",
      "description": "The property name of a property that may not have been defined yet."
    }
  },
  "can-define/map/map.prototype.set": {
    "type": "function",
    "name": "can-define/map/map.prototype.set",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 153,
      "codeLine": 183,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Sets multiple properties on a map instance or a property that wasn't predefined. \n",
    "title": "set",
    "deprecated": [
      {
        "version": "3.10.1",
        "description": "Using .set with {Object} `props` has been deprecated in favour of `assign` and `update`\n"
      }
    ],
    "signatures": [
      {
        "code": "map.set(props [,removeProps])",
        "description": "\n\nAssigns each value in `props` to a property on this map instance named after the\ncorresponding key in `props`, effectively merging `props` into the Map. If `removeProps` is true, properties not in\n`props` will be set to `undefined`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "removeProps",
            "defaultValue": "false",
            "description": "Whether to set keys not present in `props` to `undefined`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\n"
        }
      },
      {
        "code": "map.set(propName, value)",
        "description": "\n\nAssigns _value_ to a property on this map instance called _propName_.  This will define\nthe property if it hasn't already been predefined.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "The property to set."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign to `propName`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "This map instance, for chaining.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "This map instance, for chaining.\n "
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value to assign to `propName`."
    }
  },
  "can-define/map/map.prototype.assignDeep": {
    "type": "function",
    "name": "can-define/map/map.prototype.assignDeep",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 200,
      "codeLine": 234,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Sets multiple properties on a map instance or a property that wasn't predefined. \n",
    "title": "assignDeep",
    "signatures": [
      {
        "code": "map.assignDeep(props)",
        "description": "\n\nAssigns each value in `props` to a property on this map instance named after the\ncorresponding key in `props`, effectively replacing `props` into the Map.\nProperties not in `props` will not be changed.\n\n```js\nvar MyMap = DefineMap.extend({\n\tlist: DefineList,\n\tname: 'string'\n});\nvar obj = new MyMap({\n\tlist: ['1', '2', '3'],\n\tfoo: 'bar'\n});\nobj.assignDeep({\n\tlist: ['first']\n});\n\nobj.list //-> ['first']\nobj.foo //-> 'bar'\n```",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "The map instance for chaining.\n\n "
    }
  },
  "can-define/map/map.prototype.updateDeep": {
    "type": "function",
    "name": "can-define/map/map.prototype.updateDeep",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 238,
      "codeLine": 280,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Sets multiple properties on a map instance or a property that wasn't predefined. \n",
    "title": "updateDeep",
    "signatures": [
      {
        "code": "map.updateDeep(props)",
        "description": "\n\nAssigns each value in `props` to a property on this map instance named after the\ncorresponding key in `props`, effectively merging `props` into the Map.\nProperties not in `props` will be set to `undefined`.\n\n```js\nvar MyMap = DefineMap.extend({\n\tlist: DefineList,\n\tname: 'string'\n});\nvar obj = new MyMap({\n\tlist: ['1', '2', '3'],\n\tname: 'bar',\n\tfoo: {\n\t\tbar: 'zed',\n\t\tboo: 'goo'\n\t}\n});\nobj.updateDeep({\n\tlist: ['first'],\n\tfoo: {\n\t\tbar: 'abc'\n\t}\n});\n\nobj.list //-> ['first', '2', '3']\nobj.foo\t//-> { bar: 'abc', boo: undefined }\nobj.name //-> 'undefined'\n```",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "The map instance for chaining.\n\n "
    }
  },
  "can-define/map/map.prototype.assign": {
    "type": "function",
    "name": "can-define/map/map.prototype.assign",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 284,
      "codeLine": 318,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Sets multiple properties on a map instance or a property that wasn't predefined. \n",
    "title": "assign",
    "signatures": [
      {
        "code": "map.assign(props)",
        "description": "\n\n```js\nvar MyMap = DefineMap.extend({\n\tlist: DefineList,\n\tname: 'string'\n});\nvar obj = new MyMap({\n\tlist: ['1', '2', '3'],\n\tfoo: 'bar'\n});\nobj.assign({\n\tlist: ['first']\n});\n\nobj.list //-> ['first']\nobj.foo //-> 'bar'\n```\nAssigns each value in `props` to a property on this map instance named after the\ncorresponding key in `props`, effectively replacing `props` into the Map.\nProperties not in `props` will not be changed.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "The map instance for chaining.\n\n "
    }
  },
  "can-define/map/map.prototype.update": {
    "type": "function",
    "name": "can-define/map/map.prototype.update",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 322,
      "codeLine": 356,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Sets multiple properties on a map instance or a property that wasn't predefined. \n",
    "title": "update",
    "signatures": [
      {
        "code": "map.update(props)",
        "description": "\n\n```js\nvar MyMap = DefineMap.extend({\n\tlist: DefineList,\n\tname: 'string'\n});\nvar obj = new MyMap({\n\tlist: ['1', '2', '3'],\n\tfoo: 'bar'\n});\nobj.update({\n\tlist: ['first']\n});\n\nobj.list //-> ['first', '2', '3']\nobj.foo //-> 'undefined'\n```\nAssigns each value in `props` to a property on this map instance named after the\ncorresponding key in `props`, effectively merging `props` into the Map.\nProperties not in `props` will be set to `undefined`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "The map instance for chaining.\n\n "
    }
  },
  "can-define/map/map.prototype.serialize": {
    "type": "function",
    "name": "can-define/map/map.prototype.serialize",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 360,
      "codeLine": 392,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Get a serialized representation of the map instance and its children. \n",
    "title": "serialize",
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n\nGet the serialized Object form of the map.  Serialized\ndata is typically used to send back to a server.  Use [can-define.types.serialize]\nto customize a property's serialized value or if the property should be added to\nthe result or not.\n\n`undefined` serialized values are not added to the result.\n\n```js\nvar MyMap = DefineMap.extend({\n  date: {\n    type: \"date\",\n    serialize: function(date){\n      return date.getTime()\n    }\n  }\n});\n\nvar myMap = new MyMap({date: new Date(), count: 5});\nmyMap.serialize() //-> {date: 1469566698504, count: 5}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A JavaScript Object that can be serialized with `JSON.stringify` or other methods.\n\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A JavaScript Object that can be serialized with `JSON.stringify` or other methods.\n\n "
    }
  },
  "can-ejs/methods.from": {
    "src": {
      "path": "node_modules/can-ejs/doc/from.md"
    },
    "body": "\n",
    "description": "Return a template loaded from an element. \n",
    "title": "from",
    "name": "can-ejs/methods.from",
    "type": "function",
    "parent": "can-ejs/methods",
    "signatures": [
      {
        "code": "ejs.from(id)",
        "description": "\n\nLoad a template from an HTML element (usually a `<script>` element)\nspecified by id.  This is used typically for demo purposes.\n\nFor example, with a `<script>` tag as follows in your HTML:\n\n```\n<script type='text/ejs' id='my-template'>\n<h1><%= message %></h1>\n</script>\n```\n\nLoad and render that template like:\n\n```\nvar template = ejs.from(\"my-template\");\ntemplate({message: \"Hello There!\"});\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "id",
            "description": "The id of the element, whose `innerHTML` will be used to create a template."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A renderer function that will render the\ntemplate.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "id",
      "description": "The id of the element, whose `innerHTML` will be used to create a template."
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A renderer function that will render the\ntemplate.\n"
    },
    "comment": " "
  },
  "can-ejs/tags": {
    "name": "can-ejs/tags",
    "title": "tags",
    "type": "group",
    "parent": "can-ejs",
    "description": "",
    "order": 0
  },
  "can-ejs/methods": {
    "name": "can-ejs/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-ejs",
    "description": "",
    "order": 1
  },
  "can-ejs": {
    "src": {
      "path": "node_modules/can-ejs/doc/can-ejs.md"
    },
    "body": "\n## Basic Example\n\nThe following renders a Teacher's name and students into an element.  First,\ncreate a teacher template in a script tag like:\n\n```\n<script type='text/ejs' id='teacherEJS'>\n\n  <h2 class='<%= teacher.grade < 'c'? \"good\" : \"bad\" %>'>\n    <%= teacher.name %>\n  </h2>\n\n  <ul>\n    <% for(var i =0; i< teacher.students.length; i++){ %>\n      <li><%= teacher.students[i].name %></li>\n    <% } %>\n  </ul>\n\n</script>\n```\n\nNotice the magic tags?  Those are things that look like `<% %>` and\n`<%= %>`.  Code between `<% %>` is run and the return value of code\nbetween `<%= %>` is inserted into the page.\n\nNext, create a teacher and render the template:\n\n    var teacher = {\n      name : \"Mr. Smith\",\n      grade : \"a\",\n      students : [\n        {name : \"Suzy\"},\n        {name : \"Payal\"},\n        {name : \"Curtis\"},\n        {name : \"Alexis\"}\n      ]\n    };\n\n    var template = ejs.from(\"teacherEJS\");\n\n    document.getElementById('teacher')\n      .appendChild( template(teacher) )\n\nThis results in HTML like:\n\n    <div id='teachers'>\n      <h2 class='good'>\n        Mr. Smith\n      </h2>\n\n      <ul>\n         <li>Suzy</li>\n         <li>Payal</li>\n         <li>Curtis</li>\n         <li>Alexis</li>\n      </ul>\n    </div>\n\nThis is nice, but what if we change properties of the teacher?\n\n## Basic Live Binding Example\n\nEJS sets up live templating binding when a [can-map]'s properties are read\nvia [can-map::attr attr] within a magic tag.  To make this template\nrespond to changes in the teacher data, first rewrite the template\nto use the attr method to read properties and `list( observeList, cb(item, i) )`\nto iterate through a list like:\n\n    <script type='text/ejs' id='teacherEJS'>\n\n      <h2 class='<%= teacher.attr('grade') < 'c'? \"good\" : \"bad\" %>'>\n        <%= teacher.attr('name') %>\n      </h2>\n\n      <ul>\n        <% list(teacher.students, function(student){ %>\n          <li><%= student.attr('name') %></li>\n        <% }) %>\n      </ul>\n\n    </script>\n\n__Note:__ The end of this page discusses why using `list` is\nhelpful, but it does nothing fancy.\n\nNext, turn your teacher into a `new CanMap(object)` and pass\nthat to the template:\n\n    var teacher = new CanMap({\n      name : \"Mr. Smith\",\n      grade : \"a\",\n      students : [\n        {name : \"Suzy\"},\n        {name : \"Payal\"},\n        {name : \"Curtis\"},\n        {name : \"Alexis\"}\n      ]\n    });\n\n\tvar template = ejs.from(\"teacherEJS\");\n\n    document.getElementById('teacher')\n      .appendChild( template(teacher) );\n\nFinally, update some properties of teacher and slap your\nhead with disbelief ...\n\n    teacher.attr('name',\"Prof. Snape\")\n    teacher.attr('grade','f+')\n    teacher.attr('students').push({\n      name : \"Harry Potter\"\n    })\n\n... but don't slap it too hard, you'll need it for building awesome apps.\n\n## Demo\n\nThe following demo shows an EJS template being rendered with observable data.\nIt demonstrates live binding to attributes. The template and all data properties\nare editable, so experiment!\n\n<div class='iframe_wrapper' data-iframe-src='can/view/ejs/doc/demo.html' data-iframe-height='1020'></div>\n## Magic Tags\n\nEJS uses 5 types of tags:\n\n\n\n__`<%= CODE %>`__ - Runs JS Code and writes the _escaped_ result into the result of the template.\n\nThe following results in the user seeing \"my favorite element is &lt;blink>BLINK&lt;blink>\" and not\n<blink>BLINK</blink>.\n\n     <div>my favorite element is <%= '<blink>BLINK</blink>' %>.</div>\n\n__`<%== CODE %>`__  - Runs JS Code and writes the _unescaped_ result into the result of the template.\n\nThe following results in \"my favorite element is <B>B</B>.\". Using `<%==` is useful\nfor sub-templates.\n\n         <div>my favorite element is <%== '<B>B</B>' %>.</div>\n\n__`<%% CODE %>`__ - Writes <% CODE %> to the result of the template.  This is very useful for generators.\n\n         <%%= 'hello world' %>\n\n__`<%# CODE %>`__  - Used for comments.  This does nothing.\n\n         <%# 'hello world' %>\n\n## Live Binding\n\nEJS allows live binding by wrapping magic tag content within a function. When `attr()` is called\nto update an observable object, these functions are executed to return the new value.\n\n    // Suppose an observable \"foo\":\n\n    var foo = new CanMap({\n      bar: 'baz'\n    });\n\n    // Suppose also, the above observable is passed to our view:\n\n    <%= foo.attr('bar') %>\n\n    // EJS locates the magic tag and turns the above into:\n\n    function() { return foo.attr('bar'); }\n\n    // As \"foo\" is updated using attr(), this function is called again to\n    // render the view with the new value.\n\nThis means that each function tag has a closure will reference variables in it's\nparent functions. This can cause problems if you don't understand closures in\nJavaScript. For example, the following binding does not work:\n\n    <% for(var i =0; i < items.attr('length'); i++){ %>\n      <li><%= items[i].attr('name') %></li>\n    <% } %>\n\nThis is because it gets turned into:\n\n\n    <% for(var i =0; i < items.attr('length'); i++){ %>\n      LIVEBIND( function() { return items[i].attr('name') )\n    <% } %>\n\nWhen the wrapping function is called again, `i` will\nnot be the index of the item, but instead be items.length.\n\nThe [can-list.prototype.each can-list::each] method on all observable lists should be used to iterate through it:\n\n    <% items.each(function(item){ %>\n      <li><%= item.attr('name') %></li>\n    <% }) %>\n\n## Advanced Live Binding\n\nOnce you get the hang of how EJS works, it makes live-binding of complex\ncalculations possible.  The following extends a [can.Model.List] to suppot a `completed` method that\nreturns the total number of completed items in the list.  It can be used in a template like:\n\n    <h2><%= todos.complete() %> Complete Todos </h2>\n\nAnd implemented like:\n\n    Todo.List = List.extend({\n      completed: function() {\n        var count = 0;\n\n        this.attr('length');\n        this.each(function(i, todo) {\n          if(this.attr('completed')) {\n            count++;\n          }\n        });\n\n        return count;\n      }\n    });\n\n`completed` listens on changes to the list (via `this.attr('length')`) and\neach item's `'completed'` property.  EJS keeps track of which observe/attribute pairs are called\nby `.complete()`.  If they change, EJS will automatically unbind.\n\n\n## Element Callbacks\n\nIf a function is returned by the `<%= %>` or `<%== %>` magic tags within an element’s tag like:\n\n    <div <%= function( element ) { element.style.display = 'none' } %> >\n      Hello\n    </div>\n\nThe function is called back with the HTMLElement as the first argument. This is useful to initialize functionality on an element within the view. This is so common that EJS supports ES5 arrow functions that get passed the NodeList wrapped element. Using jQuery, this lets you write the above callback as:\n\n    <div <%= (el) -> el.hide() %> >\n      Hello\n    </div>\n\nThis technique is commonly used to add data, especially model instances, to an element like:\n\n    <% todos.each( function( todo ) { %>\n      <li <%= (el) -> el.data( 'todo', todo ) %>>\n        <%= todo.attr( 'name' ) %>\n      </li>\n    <% } ) %>\n\njQuery’s `el.data( NAME, data )` adds data to an element. If your library does not support this, can provides it as `can.data( NodeList, NAME, data )`. Rewrite the above example as:\n\n    <% todos.each( function( todo ) { %>\n      <li <%= (el) -> can.data( el, 'todo', todo ) %>>\n        <%= todo.attr( 'name' ) %>\n      </li>\n    <% } ) %>\n\n",
    "description": "EJS provides __live__ ERB-style client-side templates. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-ejs",
    "parent": "can-views",
    "collection": "can-legacy",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "justin@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.3.0",
        "can-globals": "^0.2.3",
        "can-legacy-view-helpers": "^0.6.0",
        "can-namespace": "^1.0.0",
        "can-observation": "^3.3.0",
        "can-reflect": "^1.1.0",
        "can-stache-key": "0.1.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "legacy EJS layer for canjs",
      "devDependencies": {
        "can-list": "^3.1.0",
        "can-map": "^3.1.0",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.5.13",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.8.4",
        "testee": "^0.7.0"
      },
      "homepage": "https://canjs.com/2.3/docs/can.ejs.html",
      "keywords": [
        "CanJS",
        "MVVM"
      ],
      "main": "can-ejs",
      "name": "can-ejs",
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "can-serve --static --develop --port 8080",
        "jshint": "jshint can-ejs.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version pre && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-ejs",
        "ext": {
          "ejs": "can-ejs/steal-ejs.js"
        },
        "plugins": [
          "can-ejs"
        ],
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.1.6"
    },
    "deprecated": [
      {
        "version": "2.1",
        "description": "EJS is incompatible with [can-component] and should\nbe avoided for new projects. Projects using EJS should consider\nswitching to [can-stache].\n"
      }
    ],
    "signatures": [
      {
        "code": "ejs( template )",
        "description": "\n\nReturns `template` compiled to a renderer function.\n\n```js\nvar ejs = require(\"can-ejs\");\nvar renderer = ejs(\"<h1><%= message %></h1>\");\nvar frag = renderer({message: \"Hello World\"});\nfrag //-> <h1>Hello World</h1>\n\ndocument.body.appendChild(frag);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "The content of the mustache template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "Any"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A function that renders the ejs template into\na live documentFragment given data.\n"
        }
      },
      {
        "code": "new ejs(options)",
        "description": "\n\nCreates an EmbeddedJS template instance.  This form can be used\nto render a string.\n\n```js\nvar ejs = require(\"can-ejs\");\nvar ejsInstance = new ejs({\n\ttext: \"<h1><%= message %></h1>\"\n});\nvar string = ejsInstance.render({message: \"Hello World\"});\nstring //-> \"<h1>Hello World</h1>\"\n```\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Any"
                }
              ]
            }
          ]
        }
      ],
      "description": "A function that renders the ejs template into\na live documentFragment given data.\n"
    },
    "comment": " "
  },
  "can-ejs/tags.escaped": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.escaped.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "<%= CODE %>",
    "name": "can-ejs/tags.escaped",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 1,
    "signatures": [
      {
        "code": "<%= CODE %>",
        "description": "\n\nRuns JS Code and writes the _escaped_ result into the result of the template. This is useful for when you want to show code in your page.\n\nThe following results in the user seeing \"my favorite element is &lt;blink>BLINK&lt;blink>\" and not\n<blink>BLINK</blink>.\n\n     <div>my favorite element is <%= '<blink>BLINK</blink>' %>.</div>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.scriptlet": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.scriptlet.md"
    },
    "body": "",
    "description": "\n",
    "title": "<% CODE %>",
    "name": "can-ejs/tags.scriptlet",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 0,
    "signatures": [
      {
        "code": "<% CODE %>",
        "description": "\n\nRuns JavaScript Code.\n\nThis type of magic tag does not modify the template but is used for JS control statements\nlike for-loops, if/else, switch, etc.  An example:\n\n    <% if( items.attr('length') === 0 ) { %>\n        <tr><td>You have no items</td></tr>\n    <% } else { %>\n        <% items.each(function(item){ %>\n          <tr> .... </tr>\n        <% }) %>\n    <% } %>\n\nVariable declarations and control blocks should always be defined in\ntheir own dedicated tags. Live binding leverages this hinting to ensure that logic is declared and executed at its intended scope.\n\n\t<!-- Each statement has its own dedicated EJS tag -->\n    <% var address = person.attr('address') %>\n    <% items.each(function(item){ %>\n        <tr> .... </tr>\n    <% }) %>\n    <span><%= address.attr('street') %><span>\n\n    <!-- This won't work! -->\n    <%\n      var address = person.attr('address');\n      items.each(function(item) {\n    %>\n        <tr> .... </tr>\n    <% }) %>\n    <span><%= address.attr('street') %><span>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.comment": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.comment.md"
    },
    "body": "",
    "description": "\n",
    "title": "<%# CODE %>",
    "name": "can-ejs/tags.comment",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 4,
    "signatures": [
      {
        "code": "<%# CODE %>",
        "description": "\n\nUsed for explicitly for comments.  This will not render anything.\n\n         <%# 'hello world' %>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.templated": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.templated.md"
    },
    "body": "",
    "description": "\n",
    "title": "<%% CODE %>",
    "name": "can-ejs/tags.templated",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 3,
    "signatures": [
      {
        "code": "<%% CODE %>",
        "description": "\n\nRenders <% CODE %> as text in result of the template rather than running CODE itself. This is useful for generators.\n\nThe following results in \"<%= 'hello world' %>\" rather than the string \"hello world.\"\n\n         <%%= 'hello world' %>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.unescaped": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.unescaped.md"
    },
    "body": "",
    "description": "\n",
    "title": "<%== CODE %>",
    "name": "can-ejs/tags.unescaped",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 2,
    "signatures": [
      {
        "code": "<%== CODE %>",
        "description": "\n\nRuns JS Code and writes the _unescaped_ result into the result of the template.\n\nThe following results in \"my favorite element is <B>B</B>.\". Using `<%==` is useful\nfor sub-templates.\n\n         <div>my favorite element is <%== '<B>B</B>' %>.</div>\n",
        "params": []
      }
    ]
  },
  "can-define-stream.tocompute": {
    "src": {
      "path": "node_modules/can-define-stream/docs/methods.toCompute.md"
    },
    "body": "",
    "description": "Create a compute that gets updated whenever the stream value changes. \n",
    "title": "toCompute",
    "name": "can-define-stream.tocompute",
    "type": "function",
    "parent": "can-define-stream.fns",
    "signatures": [
      {
        "code": "DefineMap.toCompute( stream )",
        "description": "\n\nCreates a compute that gets updated whenever the stream value changes.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stream"
              }
            ],
            "name": "stream",
            "description": "A [can-stream] stream\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A [can-compute] compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stream"
        }
      ],
      "name": "stream",
      "description": "A [can-stream] stream\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A [can-compute] compute.\n"
    }
  },
  "can-define-stream.types": {
    "name": "can-define-stream.types",
    "title": "types",
    "type": "group",
    "parent": "can-define-stream",
    "description": "",
    "order": 3
  },
  "can-define-stream.fns": {
    "name": "can-define-stream.fns",
    "title": "DefineMap methods",
    "type": "group",
    "parent": "can-define-stream",
    "description": "",
    "order": 4
  },
  "can-define-stream": {
    "src": {
      "path": "node_modules/can-define-stream/docs/can-define-stream.md"
    },
    "body": "\n## Use\n\nThe [can-define-stream.toStream] method has shorthands for all of the other methods:\n\n```js\ntoStream(\"eventName\")           //-> stream\ntoStream(\".propName\")           //-> stream\ntoStream(\".propName eventName\") //-> stream\n```\n\nFor example:\n\n__Update map property based on stream value__\n\n```js\nvar DefineMap = require('can-define/map/map');\nvar canStream = require(\"can-stream-kefir\");\nvar canDefineStream = require(\"can-define-stream\");\n\nvar Person = DefineMap.extend({\n    name: \"string\",\n    lastValidName: {\n        stream: function() {\n            return this.toStream(\".name\").filter(function(name) { // using propName\n                return name.indexOf(\" \") >= 0;\n            });\n        }\n    }\n});\n\ncanDefineStream(canStream)(Person);\n\nvar me = new Person({name: \"James\"});\n\nme.on(\"lastValidName\", function(lastValid) {});\n\nme.name = \"JamesAtherton\"; //lastValidName -> undefined\nme.name = \"James Atherton\"; //lastValidName -> James Atherton\n```\n\n__Stream on DefineList__\n\n```js\nvar DefineList = require('can-define/list/list');\nvar canStream = require(\"can-stream-kefir\");\nvar canDefineStream = require(\"can-define-stream\");\n\nvar PeopleList = DefineList.extend({});\n\ncanDefineStream(canStream)(PeopleList);\n\nvar people = new PeopleList([\n    { first: \"Justin\", last: \"Meyer\" },\n    { first: \"Paula\", last: \"Strozak\" }\n]);\n\nvar stream = people.toStream('length'); // using eventName\n\nstream.onValue(function(val) {\n    val //-> 2, 3\n});\n\npeople.push({\n    first: 'Obaid',\n    last: 'Ahmed'\n}); //-> stream.onValue -> 3\n```\n\n",
    "description": "Add useful stream conversion methods to a supplied [can-define/map/map] or [can-define/list/list] constructor using a [can-define-stream.types.streamInterface stream interface] such as [can-stream-kefir]. \n",
    "type": "module",
    "title": "can-define-stream",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-stream",
    "parent": "can-observables",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-define-stream/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.2.0",
        "can-define": "^1.4.0",
        "can-observation": "^3.2.0",
        "can-stream": "^0.3.0",
        "can-util": "^3.9.0",
        "kefir": "^3.5.1"
      },
      "deprecated": false,
      "description": "[![Join the chat at https://gitter.im/canjs/canjs](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/canjs/canjs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://github.com/canjs/can-define-stream/blob/master/LICENSE) [![npm version](https://badge.fury.io/js/can-define-stream.svg)](https://www.npmjs.com/package/can-define-stream) [![Travis build status](https://travis-ci.org/canjs/can-define-stream.svg?branch=master)](https://travis-ci.org/canjs/can-define-stream) [![Greenkeeper badge](https://badges.greenkeeper.io/canjs/can-define-stream.svg)](https://greenkeeper.io/)",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.2.0",
        "donejs-cli": "^1.0.1",
        "generator-donejs": "^1.0.5",
        "jshint": "^2.9.1",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-define-stream",
      "name": "can-define-stream",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-define-stream.git"
      },
      "scripts": {
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git push",
        "preversion": "npm test",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "0.2.1"
    },
    "signatures": [
      {
        "code": "canDefineStream(streamInterface)",
        "description": "\n\nThe `can-define-stream` module exports a function that takes a [can-define-stream.types.streamInterface] and returns a function that takes a [can-define-stream.types.DefineMap DefineMap.prototype] or [can-define-stream.types.DefineList DefineList.prototype] and uses the supplied stream interface to create streamed property definitions.\n\n```js\nvar canStream = require(\"can-stream-kefir\");\nvar canDefineStream = require(\"can-define-stream\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Person = DefineMap.extend({\n    first: \"string\",\n    last: \"string\",\n    fullName: {\n        get: function() {\n            return this.first + \" \" + this.last;\n        }\n    },\n    fullNameChangeCount: {\n        stream: function() {\n            return this.toStream(\".fullName\").scan(function(last) {\n                return last + 1;\n            }, 0);\n        }\n    }\n});\n\ncanDefineStream(canStream)(Person);\n\nvar me = new Person({name: \"Justin\", last: \"Meyer\"});\n\nme.on(\"fullNameChangeCount\", function(ev, newVal) {\n    console.log(newVal);\n});\nme.fullNameChangeCount //-> 0\nme.first = \"Obaid\"; //-> console.logs 1\nme.last = \"Ahmed\"; //-> console.logs 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-define-stream.types.streamInterface"
              }
            ],
            "name": "streamInterface",
            "description": "A [can-define-stream.types.streamInterface] function. See [can-stream-kefir] for implementation.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function that takes a [can-define-stream.types.DefineMap DefineMap.prototype] or [can-define-stream.types.DefineList DefineList.prototype].\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-define-stream.types.streamInterface"
        }
      ],
      "name": "streamInterface",
      "description": "A [can-define-stream.types.streamInterface] function. See [can-stream-kefir] for implementation.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function that takes a [can-define-stream.types.DefineMap DefineMap.prototype] or [can-define-stream.types.DefineList DefineList.prototype].\n"
    },
    "comment": " "
  },
  "can-define-stream.tostreamfromevent": {
    "src": {
      "path": "node_modules/can-define-stream/docs/methods.toStreamFromEvent.md"
    },
    "body": "\n",
    "description": "Create a stream based on an event \n",
    "title": "toStreamFromEvent",
    "name": "can-define-stream.tostreamfromevent",
    "type": "function",
    "parent": "can-define-stream.fns",
    "signatures": [
      {
        "code": "DefineMap.toStreamFromEvent( eventName )",
        "description": "\n\nCreates a stream from an event that gets updated whenever the event is triggered.\n\n```js\nvar DefineList = require('can-define/list/list');\nvar canStream = require(\"can-stream-kefir\");\nvar canDefineStream = require(\"can-define-stream\");\n\nvar PeopleList = DefineList.extend({});\n\ncanDefineStream(canStream)(PeopleList);\n\nvar people = new PeopleList([\n    { first: \"Justin\", last: \"Meyer\" },\n    { first: \"Paula\", last: \"Strozak\" }\n]);\n\nvar stream = people.toStreamFromEvent('length'); // using eventName\n\nstream.onValue(function(val) {\n    val //-> 2, 3\n});\n\npeople.push({\n    first: 'Obaid',\n    last: 'Ahmed'\n}); //-> stream.onValue -> 3\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "An event name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [can-stream] stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "event",
      "description": "An event name\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [can-stream] stream.\n"
    }
  },
  "can-define-stream.toStream": {
    "src": {
      "path": "node_modules/can-define-stream/docs/methods.toStream.md"
    },
    "body": "",
    "description": "Provide a shorthand for creating a stream on properties and/or events. \n",
    "title": "toStream",
    "name": "can-define-stream.toStream",
    "type": "function",
    "parent": "can-define-stream.fns",
    "signatures": [
      {
        "code": "DefineMap.toStream( propAndOrEvent[,event] )",
        "description": "\n\nCreates a stream that gets updated whenever the property value changes or event is triggered.\n\n```js\nvar DefineMap = require('can-define/map/map');\nvar canStream = require(\"can-stream-kefir\");\nvar canDefineStream = require(\"can-define-stream\");\n\nvar Person = DefineMap.extend({\n    name: \"string\",\n    lastValidName: {\n        stream: function() {\n            return this.toStream(\".name\").filter(function(name) { // using propName\n                return name.indexOf(\" \") >= 0;\n            });\n        }\n    }\n});\n\ncanDefineStream(canStream)(Person);\n\nvar me = new Person({name: \"James\"});\n\nme.on(\"lastValidName\", function(lastValid) {});\n\nme.name = \"JamesAtherton\"; //lastValidName -> undefined\nme.name = \"James Atherton\"; //lastValidName -> James Atherton\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "A property name prepended by a dot '.prop'\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "An event name 'event'\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propAndEvent",
            "description": "A property name prepended by a dot follow by an event name seperated by a space '.prop event'\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [can-stream] stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "propAndEvent",
      "description": "A property name prepended by a dot follow by an event name seperated by a space '.prop event'\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [can-stream] stream.\n"
    }
  },
  "can-define-stream.tostreamfromproperty": {
    "src": {
      "path": "node_modules/can-define-stream/docs/methods.toStreamFromProperty.md"
    },
    "body": "",
    "description": "Create a stream based on a property \n",
    "title": "toStreamFromProperty",
    "name": "can-define-stream.tostreamfromproperty",
    "type": "function",
    "parent": "can-define-stream.fns",
    "signatures": [
      {
        "code": "DefineMap.toStreamFromProperty( property )",
        "description": "\n\nCreates a stream from a property that gets updated whenever the property value changes.\n\n```js\nvar DefineMap = require('can-define/map/map');\nvar canStream = require(\"can-stream-kefir\");\nvar canDefineStream = require(\"can-define-stream\");\n\nvar Person = DefineMap.extend({\n    name: \"string\",\n    lastValidName: {\n        stream: function() {\n            return this.toStreamFromProperty(\".name\").filter(function(name) { // using propName\n                return name.indexOf(\" \") >= 0;\n            });\n        }\n    }\n});\n\ncanDefineStream(canStream)(Person);\n\nvar me = new Person({name: \"James\"});\n\nme.on(\"lastValidName\", function(lastValid) {});\n\nme.name = \"JamesAtherton\"; //lastValidName -> undefined\nme.name = \"James Atherton\"; //lastValidName -> James Atherton\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "A property name prepended by a dot. '.prop'\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [can-stream] stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "property",
      "description": "A property name prepended by a dot. '.prop'\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [can-stream] stream.\n"
    }
  },
  "can-define-stream.types.DefineList": {
    "src": {
      "path": "node_modules/can-define-stream/docs/types.DefineList.prototype.md"
    },
    "body": "\n## Use\n\nSee: [can-define/list/list] and the related [can-define/list/list.extend] method.\n\n",
    "description": "A [can-define/list/list] constructor to add stream methods to. \n",
    "type": "typedef",
    "title": "DefineList.prototype",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-stream.types.DefineList",
    "parent": "can-define-stream.types",
    "signatures": [
      {
        "code": "new DefineList([items])",
        "description": "\n\nCreates a DefineList type instance\n\n```js\nimport DefineMap from 'can-define/map/map';\nimport DefineList from 'can-define/list/list';\n\nvar People = DefineList.extend([\n\t'#': {\n\t\ttype: {\n\t\t\tfirst: 'string',\n\t\t\tlast: 'string'\n\t\t}\n\t}\n]);\n\nvar people = new People([\n\t{ first: 'John', last: 'Gardner' },\n\t{ first: 'Justin', last: 'Meyer' }\n])\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define-stream.types.DefineMap": {
    "src": {
      "path": "node_modules/can-define-stream/docs/types.DefineMap.prototype.md"
    },
    "body": "\n## Use\n\nSee: [can-define/map/map] and [can-define/map/map.extend]\n\n",
    "description": "A [can-define/map/map] constructor to add stream methods to. \n",
    "type": "typedef",
    "title": "DefineMap.prototype",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-stream.types.DefineMap",
    "parent": "can-define-stream.types",
    "signatures": [
      {
        "code": "new DefineMap({props})",
        "description": "\n\nCreates a DefineMap type instance\n\n```js\nimport DefineMap from 'can-define/map/map';\n\nvar Person = DefineMap.extend({\n\tfirst: 'string',\n\tlast: 'string',\n\tfullName: {\n\t\tget() {\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n});\n\nvar john = new Person({\n\tfirst: 'John',\n\tlast: 'Gardner'\n});\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define-stream.types.streamInterface": {
    "src": {
      "path": "node_modules/can-define-stream/docs/types.streamInterface.md"
    },
    "body": "\n## Use\n\nSee [can-stream.types.streamInterface].\n\nSee [can-stream-kefir] for an example implementation.\n\n",
    "description": "A [can-stream.types.streamInterface] function. \n",
    "type": "typedef",
    "title": "streamInterface",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-stream.types.streamInterface",
    "parent": "can-define-stream.types",
    "signatures": [
      {
        "code": "streamInterface([observable], propAndOrEvent[,event])",
        "description": "\n\nThe stream interface function returned from [can-stream] that will be used to add streamable props to a provided [can-define-stream.types.DefineMap DefineMap.prototype] or [can-define-stream.types.DefineList DefineList.prototype] and has the following property methods:\n\n- .toStream(observable, propAndOrEvent[,event])\n- .toStreamFromProperty(property)\n- .toStreamFromEvent(property)\n- .toCompute([can-stream.types.makeStream makeStream(setStream)], context):compute\n\n```js\nimport DefineMap from 'can-define/map/map';\nimport canDefineStream from 'can-define-stream';\nimport streamInterface from 'can-stream-kefir';\n\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\",\n\tfullName: {\n\t\t\tget: function() {\n\t\t\t\t\treturn this.first + \" \" + this.last;\n\t\t\t}\n\t}\n});\n\nvar john = new Person({ first: 'John' });\njohn.toStream('.first'); //-> Error (toStream doesn't exist)\n\nvar defineStreamAdder = canDefineStream(streamInterface);\ndefineStreamAdder(Person);\n\nvar justin = new Person({ first: 'Justin' });\njustin.toStream('.first'); //-> Stream\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "make-event-registry.registry": {
    "name": "make-event-registry.registry",
    "title": "EventRegistry",
    "type": "group",
    "parent": "can-dom-events/helpers/make-event-registry",
    "description": "",
    "order": 0
  },
  "can-dom-events/helpers/make-event-registry": {
    "type": "module",
    "name": "can-dom-events/helpers/make-event-registry",
    "parent": "can-dom-events.helpers",
    "src": {
      "line": 6,
      "codeLine": 28,
      "path": "node_modules/can-dom-events/helpers/make-event-registry.js"
    },
    "body": "\n```js\nvar makeEventRegistry = require('can-dom-events/helpers/make-event-registry');\nvar registry = makeEventRegistry();\n\nvar radioChange = require('can-events-dom-radiochange');\nvar removeRadioChange = registry.add(radioChange);\n\nregistry.has('radiochange'); // => true\nregistry.get('radiochange'); // => radioChange\n\nremoveRadioChange();\n```\n\n",
    "description": "Create an event registry. ",
    "title": "",
    "signatures": [
      {
        "code": "makeEventRegistry()",
        "description": "\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "make-event-registry.has": {
    "type": "function",
    "name": "make-event-registry.has",
    "parent": "make-event-registry.registry",
    "src": {
      "line": 32,
      "codeLine": 42,
      "path": "node_modules/can-dom-events/helpers/make-event-registry.js"
    },
    "body": "\n",
    "description": "\nCheck whether an event type has already been registered.\n",
    "title": "eventRegistry.has",
    "signatures": [
      {
        "code": "eventRegistry.has( eventType )",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The event type for which to check."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Whether the event type is registered.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "eventType",
      "description": "The event type for which to check."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Whether the event type is registered.\n"
    }
  },
  "make-event-registry.get": {
    "type": "function",
    "name": "make-event-registry.get",
    "parent": "make-event-registry.registry",
    "src": {
      "line": 46,
      "codeLine": 56,
      "path": "node_modules/can-dom-events/helpers/make-event-registry.js"
    },
    "body": "\n",
    "description": "\nRetrieve an event type which has already been registered.\n",
    "title": "eventRegistry.get",
    "signatures": [
      {
        "code": "eventRegistry.get( eventType )",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The event type for which to retrieve."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "EventDefinition"
            }
          ],
          "description": "The registered event definition, or undefined if unregistered.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "eventType",
      "description": "The event type for which to retrieve."
    },
    "_curReturn": {
      "types": [
        {
          "type": "EventDefinition"
        }
      ],
      "description": "The registered event definition, or undefined if unregistered.\n"
    }
  },
  "make-event-registry.add": {
    "type": "function",
    "name": "make-event-registry.add",
    "parent": "make-event-registry.registry",
    "src": {
      "line": 60,
      "codeLine": 71,
      "path": "node_modules/can-dom-events/helpers/make-event-registry.js"
    },
    "body": "\n",
    "description": "\nAdd an event to the registry.\n",
    "title": "eventRegistry.add",
    "signatures": [
      {
        "code": "eventRegistry.add( event [, eventType ] )",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "EventDefinition"
              }
            ],
            "name": "event",
            "description": "The event definition to register."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The event type with which to register the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "The callback to remove the event from the registry.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "eventType",
      "description": "The event type with which to register the event."
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "The callback to remove the event from the registry.\n"
    }
  },
  "can-element/attributes": {
    "src": {
      "path": "node_modules/can-element/docs/attributes.md"
    },
    "body": "\n\n## Use\n\nTo use this [can-define] behavior just import it. For any defined property on the element, you can specify `attribute: true` and the property will be two-way bound to the attribute. Any change in either will update the other.\n\nSince the [can-define.types.type] can still be specified, you can have properties which are typed even though the attribute will always be a string.\n\n```js\nvar define = require(\"can-define\");\nvar Element = require(\"can-element\").Element;\nvar view = require(\"./calc.stache\");\nvar defineAttr = require(\"can-element/attributes\");\n\nvar Calculator = class extends Element {\n\tstatic get view() {\n\t\treturn view;\n\t}\n};\n\ndefine(Calculator.prototype, {\n\tnum: {\n\t\ttype: \"number\",\n\t\tattribute: true\n\t}\n});\n\ndefineAttr(Calculator);\n\ncustomElements.define(\"my-calculator\", Calculator);\n\nvar el = new Calculator();\n\nel.setAttribute(\"num\", \"34\");\n\nel.num; // -> 34\n```\n\n",
    "description": "\nSets up attribute bindings when using [can-define].\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "attribute",
            "description": "Defines if this property should be bound to the attribute of the same name.\n",
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true
          }
        ]
      }
    ],
    "name": "can-element/attributes",
    "parent": "can-element.modules",
    "comment": " "
  },
  "can-element.CanElement": {
    "src": {
      "path": "node_modules/can-element/docs/can-element.CanElement.md"
    },
    "body": "\n",
    "description": "\nAn interface for derived elements using either [can-element] or [can-element.element].\n",
    "type": "typedef",
    "title": "CanElement",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-element.CanElement",
    "parent": "can-element.types"
  },
  "can-element.CanElement.view": {
    "src": {
      "path": "node_modules/can-element/docs/can-element.CanElement.view.md"
    },
    "body": "\n```js\nvar Element = require(\"can-element\").Element;\nvar view = require(\"./some-template.stache\");\n\nclass MyApp extends Element {\n\tstatic get view() {\n\t\treturn view;\n\t}\n}\n\ncustomElements.define(\"my-app\", MyApp);\n```\n\n",
    "description": "\nA static getter that returns the renderer function used to render the element's shadow DOM.\n",
    "type": "typedef",
    "title": "CanElement.view",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-element.CanElement.view",
    "parent": "can-element.CanElement"
  },
  "can-element.properties": {
    "name": "can-element.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-element",
    "description": "",
    "order": 1
  },
  "can-element.modules": {
    "name": "can-element.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-element",
    "description": "",
    "order": 2
  },
  "can-element.types": {
    "name": "can-element.types",
    "title": "types",
    "type": "group",
    "parent": "can-element",
    "description": "",
    "order": 3
  },
  "can-element": {
    "src": {
      "path": "node_modules/can-element/docs/can-custom-elements.md"
    },
    "body": "\n## Use\n\n`can-element` makes it possible to create standard custom elements (part of [web components](https://developer.mozilla.org/en-US/docs/Web/Web_Components)).\n\nUse can-element to create a class that can be passed into [customElements.define](https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define) to register the element in the window.\n\n```js\nvar Element = require(\"can-element\").Element;\nvar stache = require(\"can-stache\");\nvar define = require(\"can-define\");\n\nvar view = stache(\"Hello {{name}}\");\n\nvar MyApp = class extends Element {\n\tstatic get view() {\n\t\treturn view;\n\t}\n};\n\ndefine(MyApp.prototype, {\n\tname: {\n\t\tvalue: \"world\"\n\t}\n});\n\ncustomElements.define(\"my-app\", MyApp);\n\nvar el = document.createElement(\"my-app\");\n\nel.name; // -> \"world\"\n```\n\n",
    "description": "Allows you to create [customelement](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements) classes with CanJS. \nSafari only supports custom elements that derive from HTMLElement, so you'll usually want to use [can-element.element].\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-element",
    "parent": "can-views",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-element/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-util": "^3.2.2",
        "can-view-nodelist": "^3.0.4",
        "can-view-scope": "^3.3.6"
      },
      "deprecated": false,
      "description": "Create custom elements with CanJS",
      "devDependencies": {
        "@webcomponents/custom-elements": "github:webcomponents/custom-elements#v1.0.0-alpha.4",
        "bit-docs": "0.0.7",
        "can-compute": "^3.0.5",
        "can-define": "^1.0.0",
        "can-stache": "^3.0.18",
        "can-stache-bindings": "^3.0.6",
        "cloudydom": "1.0.6",
        "detect-cyclic-packages": "^1.1.0",
        "documentjs": "^0.4.4",
        "done-serve": "^1.0.0-alpha.0",
        "donejs-cli": "^1.0.0-alpha.2",
        "generator-donejs": "^1.0.0-alpha.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.5",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.3.0"
      },
      "homepage": "https://github.com/canjs/can-element",
      "keywords": [
        "web component",
        "custom elements",
        "canjs"
      ],
      "license": "MIT",
      "main": "can-element.js",
      "name": "can-element",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-element.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js ./test/ --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "0.2.2"
    },
    "signatures": [
      {
        "code": "CustomElement(Element)",
        "description": "\n\nCreate a base Element class based on `Element`, any element that derives from [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).\n\n**Important**: Safari only supports custom elements that derive from [HTMLElement].\n\n```js\nvar CustomElement = require(\"can-element\");\n\nvar SuperButton = class extends CustomElement(HTMLButtonElement) {\n\n};\n\ncustomElements.define(\"super-button\", SuperButton);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "Element",
            "description": "The base element from which to derive."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-element.CanElement"
            }
          ],
          "description": "A derived element with CanJS behaviors added.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "name": "Element",
      "description": "The base element from which to derive."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-element.CanElement"
        }
      ],
      "description": "A derived element with CanJS behaviors added.\n"
    },
    "comment": " "
  },
  "can-element.element": {
    "src": {
      "path": "node_modules/can-element/docs/can-element.element.md"
    },
    "body": "\n## Use\n\nTo use this element, just extend your own element based off of it:\n\n```js\nvar Element = require(\"can-element\").Element;\n\nclass MyElement extends Element {\n  ...\n}\n```\n\nThis element uses the [can-element.CanElement] interface, so any properties of CanElement are supported.\n\n",
    "description": "A class that can be extended to create custom elements. \nElement is a [can-element.CanElement] that is derived from the [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement). This is the element you will want to use to derive your own custom elements.\n\n",
    "title": "Element",
    "name": "can-element.element",
    "type": "function",
    "parent": "can-element.properties",
    "comment": " "
  },
  "can-event/async/async.dispatch": {
    "type": "function",
    "name": "can-event/async/async.dispatch",
    "parent": "can-event/async/async",
    "src": {
      "line": 19,
      "codeLine": 39,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "Dispatch events asynchronously. \n",
    "title": "dispatch",
    "signatures": [
      {
        "code": "asych.dispatch.call(target, event, [args])",
        "description": "\n\nDispatches `event` on `target` in a task queue scheduled to\nrun [can-util/js/set-immediate/set-immediate immediately] after the current\nevent loop.\n\nIf [can-event/async/async.async] is called, this will replace\nthe default [can-event.dispatch].\n\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "target",
            "description": "The object to dispatch the event on."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "event",
            "description": "The event to dispatch."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Additional arguments to pass to event handlers"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "event The resulting event object\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "args",
      "description": "Additional arguments to pass to event handlers"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "event The resulting event object\n "
    }
  },
  "can-event/async/async.queue": {
    "type": "function",
    "name": "can-event/async/async.queue",
    "parent": "can-event/async/async",
    "src": {
      "line": 49,
      "codeLine": 64,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "Queues a method to be called asynchronously. \n",
    "title": "queue",
    "signatures": [
      {
        "code": "async.queue(task)",
        "description": "\n\nQueues a method to be run scheduled to\n[can-util/js/set-immediate/set-immediate immediately] after the current\nevent loop.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "task",
            "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                }
              ]
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "task",
      "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
    }
  },
  "can-event/async/async.flush": {
    "type": "function",
    "name": "can-event/async/async.flush",
    "parent": "can-event/async/async",
    "src": {
      "line": 71,
      "codeLine": 80,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "flush",
    "signatures": [
      {
        "code": "async.flush()",
        "description": "\n\nFlushes the task queue immediately so all events or other tasks\nwill be immediately invoked.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async.async": {
    "type": "function",
    "name": "can-event/async/async.async",
    "parent": "can-event/async/async",
    "src": {
      "line": 93,
      "codeLine": 101,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "async",
    "signatures": [
      {
        "code": "async.async()",
        "description": "\n\nMakes event dispatching and event binding happen asynchronously.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async.sync": {
    "type": "function",
    "name": "can-event/async/async.sync",
    "parent": "can-event/async/async",
    "src": {
      "line": 105,
      "codeLine": 113,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "sync",
    "signatures": [
      {
        "code": "async.sync()",
        "description": "\n\nMakes event dispatching and event binding happen synchronously.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async": {
    "src": {
      "path": "node_modules/can-event/async/async.md"
    },
    "body": "\n## Use\n\nUse `can-event/async/async`'s `async` method to make event binding and\ndispatching happen immediately following the current event loop.\n\n```js\nvar canEvent = require(\"can-event\");\nvar canAsync = require(\"can-event/async/async\");\ncanAsync.async();\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){\n  console.log(\"heard foo\");\n});\nobj.dispatch(\"foo\");\nconsole.log(\"dispatched foo\");\n\n// Logs -> \"dispatched foo\" then \"heard foo\"\n```\n\nThis means you never have to call [can-event/batch/batch.start] and [can-event/batch/batch.stop]. Notice\nthat in the following example `\"change\"` is only fired once:\n\n```js\nvar canAsync = require(\"can-event/async/async\");\ncanAsync.async();\n\nvar compute = require(\"can-compute\");\n\nvar first = compute(\"Justin\");\nvar last = compute(\"Meyer\");\n\nvar fullName = compute(function(){\n\treturn first() + \" \" + last();\n});\n\nfullName.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Payal Shah\"\n\toldVal //-> \"Justin Meyer\"\n});\n\nfirst(\"Payal\");\nlast(\"Shah\");\n```\n\n",
    "description": "Makes the event system asynchronous. __WARNING:__ This is experimental technology. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event/async/async",
    "parent": "can-observables",
    "collection": "can-infrastructure",
    "signatures": [
      {
        "code": "Object",
        "description": "\n\nThe `can-event/async/async` module makes the event system asynchronous.  It:\n\n - Provides an [can-event/async/async.async] method which converts event binding and dispatching to happen asynchronously.\n - Provides [can-event/async/async.sync]  method which converts event binding and dispatching to happen synchronously.\n - Provides an asynchronous [can-event/async/async.dispatch], [can-event/async/async.queue],\n  [can-event/async/async.addEventListener] and [can-event/async/async.removeEventListener].\n - Provides a [can-event/async/async.flush] which can be used to immediately run all tasks in the\n   task queue.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-event/batch/batch": {
    "src": {
      "path": "node_modules/can-event/batch/batch.md"
    },
    "body": "\n## Use\n\nTo batch events, call  [can-event/batch/batch.start], then make changes that\n[can-event/batch/batch.dispatch] batched events, then call [can-event/batch/batch.stop].\n\nFor example, a map might have a `first` and `last` property:\n\n```js\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\"\n});\n\nvar baby = new Person({first: \"Roland\", last: \"Shah\"});\n```\n\nNormally, when `baby`'s `first` and `last` are fired, those events are dispatched immediately:\n\n```js\nbaby.on(\"first\", function(ev, newFirst){\n\tconsole.log(\"first is \"+newFirst);\n}).on(\"last\", function(ev, newLast){\n\tconsole.log(\"last is \"+newLast);\n});\n\nbaby.first = \"Ramiya\";\n// console.logs -> \"first is Ramiya\"\nbaby.last = \"Meyer\";\n// console.logs -> \"first is Meyer\"\n```\n\nHowever, if a batch is used, events will not be dispatched until [can-event/batch/batch.stop] is called:\n\n```js\nvar canBatch = require(\"can-event/batch/batch\");\n\ncanBatch.start();\nbaby.first = \"Lincoln\";\nbaby.last = \"Sullivan\";\ncanBatch.stop();\n// console.logs -> \"first is Lincoln\"\n// console.logs -> \"first is Sullivan\"\n```\n\n\n\n## Performance\n\nCanJS synchronously dispatches events when a property changes.\nThis makes certain patterns easier. For example, if you\nare utilizing live-binding and change a property, the DOM is\nimmediately updated.\n\nOccasionally, you may find yourself changing many properties at once. To\nprevent live-binding from performing unnecessary updates,\nupdate the properties within a pair of calls to `canBatch.start` and\n`canBatch.stop`.\n\nConsider a todo list with a `completeAll` method that marks every todo in the list as\ncomplete and `completeCount` that counts the number of complete todos:\n\n```js\nvar Todo = DefineMap.extend({\n\tname: \"string\",\n\tcomplete: \"boolean\"\n});\n\nvar TodoList = DefineList.extend({\n\t\"#\": Todo,\n\tcompleteAll: function(){\n\t\tthis.forEach(function(todo){\n\t\t\ttodo.complete = true;\n\t\t})\n\t},\n\tcompleteCount: function(){\n\t\treturn this.filter({complete: true}).length;\n\t}\n})\n```\n\nAnd a template that uses the `completeCount` and calls `completeAll`:\n\n```\n<ul>\n{{#each todos}}\n\t<li><input type='checklist' checked:bind=\"complete\"/> {{name}}</li>\n{{/each}}\n</ul>\n<button on:click=\"todos.completeAll()\">\n  Complete {{todos.completeCount}} todos\n</button>\n```\n\nWhen `completeAll` is called, the `{{todos.completeCount}}` magic tag will update\nonce for every completed count.  We can prevent this by wrapping `completeAll` with calls to\n`start` and `stop`:\n\n```js\n\tcompleteAll: function(){\n\t\tcanBatch.start();\n\t\tthis.forEach(function(todo){\n\t\t\ttodo.complete = true;\n\t\t});\n\t\tcanBatch.end();\n\t},\n```\n\n\n## batchNum\n\nAll events created within a set of `start` / `stop` calls share the same\nbatchNum value. This can be used to respond only once for a given batchNum.\n\n    var batchNum;\n    person.on(\"name\", function(ev, newVal, oldVal) {\n      if(!ev.batchNum || ev.batchNum !== batchNum) {\n        batchNum = ev.batchNum;\n        // your code here!\n      }\n    });\n\n",
    "description": "Adds task batching abilities to event dispatching. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event/batch/batch",
    "parent": "can-observables",
    "collection": "can-infrastructure",
    "signatures": [
      {
        "code": "Object",
        "description": "\n\nThe `can-event/batch/batch` module adds task batching abilities to\nthe [can-event] module.  It:\n\n - Provides a [can-event/batch/batch.queue] method to add batched work.\n - Provides [can-event/batch/batch.dispatch] and overwrites [can-event.dispatch can-event.dispatch] to use the task queue when dispatching events.\n - Provides a [can-event/batch/batch.start] and [can-event/batch/batch.stop] method that can create a new task queue.\n - Provides [can-event/batch/batch.collecting] which returns the queue collecting tasks.\n - Provides [can-event/batch/batch.dispatching] which returns the queue dispatching tasks.\n - Dispatches `batchEnd` when a queue's tasks have been completed.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-event/batch/batch.start": {
    "type": "function",
    "name": "can-event/batch/batch.start",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 49,
      "codeLine": 155,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "`canBatch.start` begins an event batch. Until `[can-event/batch/batch.stop]` is called, any\nevents that would result from calls to [can-event/batch/batch.trigger] to are held back from firing. If you have\nlots of changes to make to observables, batching them together can help performance - especially if\nthose observables are live-bound to the DOM.\n\nIn this example, you can see how the _first_ event is not fired (and their handlers\nare not called) until `canBatch.stop` is called.\n\n```\nvar person = new DefineMap({\n    first: 'Alexis',\n    last: 'Abril'\n});\n\nperson.on('first', function() {\n    console.log(\"First name changed.\");\n}).on('last', function() {\n    console.log(\"Last name changed.\");\n});\n\ncanBatch.start();\nperson.first = 'Alex';\nconsole.log('Still in the batch.');\ncanBatch.stop();\n\n// the log has:\n// Still in the batch.\n// First name changed.\n```\n\nYou can also pass a callback to `canBatch.start` which will be called after all the events have\nbeen fired:\n\n```\ncanBatch.start(function() {\n    console.log('The batch is over.');\n});\nperson.first = \"Izzy\"\nconsole.log('Still in the batch.');\ncanBatch.stop();\n\n// The console has:\n// Still in the batch.\n// First name changed.\n// The batch is over.\n```\n\n## Calling `canBatch.start` multiple times\n\nIf you call `canBatch.start` more than once, `canBatch.stop` needs to be called\nthe same number of times before any batched events will fire. For ways\nto circumvent this process, see [can-event/batch/batch.stop].\n\nHere is an example that demonstrates how events are affected by calling\n`canBatch.start` multiple times.\n\n```\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  name: \"string\"\n  updatedAt: \"date\",\n  complete: function(){\n    canBatch.start();\n    this.completed = true;\n    this.updatedAt = new Date();\n    canBatch.end();\n  }\n});\n\nTodo.List = DefineList.extend({\n  \"#\": Todo,\n  completeAll: function(){\n    this.forEach(function(todo){\n      todo.complete();\n    });\n  }\n});\n\nvar todos = new Todo.List([\n  {name: \"dishes\", completed: false},\n  {name: \"lawn\", completed: false}\n]);\n\ntodos[0].on(\"completed\", function(ev){\n  console.log(\"todos[0] \"+ev.batchNum);\n})\ntodos[1].on(\"completed\", function(ev){\n  console.log(\"todos[1] \"+ev.batchNum);\n});\n\ntodos.completeAll();\n// console.logs ->\n//        todos[0] 1\n//        todos[1] 1\n```\n \n",
    "description": "Begin an event batch. \n",
    "title": "start",
    "signatures": [
      {
        "code": "canBatch.start([batchStopHandler])",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "batchStopHandler",
            "description": "a callback that gets called after all batched events have been called.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "batchStopHandler",
      "description": "a callback that gets called after all batched events have been called.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.collecting": {
    "type": "function",
    "name": "can-event/batch/batch.collecting",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 197,
      "codeLine": 215,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "\n",
    "title": "collecting",
    "signatures": [
      {
        "code": "batch.collecting()",
        "description": "\n\nReturns the Queue that is currently collecting tasks.\n\n```\nbatch.start();\nbatch.collecting() //-> Queue\n\nbatch.stop();\nbatch.collecting() //-> null\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-event/batch/Queue"
            }
          ],
          "description": "The queue currently collecting tasks.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-event/batch/Queue"
        }
      ],
      "description": "The queue currently collecting tasks.\n "
    }
  },
  "can-event/batch/batch.dispatching": {
    "type": "function",
    "name": "can-event/batch/batch.dispatching",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 218,
      "codeLine": 242,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "\n",
    "title": "dispatching",
    "signatures": [
      {
        "code": "batch.dispatching()",
        "description": "\n\nReturns the Queue that is executing tasks.\n\n```\nvar canEvent = require(\"can-event\");\nvar batch = require(\"can-event/batch/batch\");\n\n\nvar obj = Object.assign({}, canEvent);\n\n\n\nbatch.start();\nobj.dispatch(\"first\");\nbatch.stop();\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-event/batch/Queue"
            }
          ],
          "description": "The queue currently executing tasks.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-event/batch/Queue"
        }
      ],
      "description": "The queue currently executing tasks.\n "
    }
  },
  "can-event/batch/batch.stop": {
    "type": "function",
    "name": "can-event/batch/batch.stop",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 245,
      "codeLine": 270,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "\n`canBatch.stop` matches an earlier `[can-event/batch/batch.start]` call. If `canBatch.stop` has been\ncalled as many times as `canBatch.start` (or if _force_ is true), all batched events will be\nfired and any callbacks passed to `canBatch.start` since the beginning of the batch will be\ncalled. If _force_ and _callStart_ are both true, a new batch will be started when all\nthe events and callbacks have been fired.\n\nSee `[can-event/batch/batch.start]` for examples of `canBatch.start` and `canBatch.stop` in normal use.\n\n \n",
    "description": "End an event batch. \n",
    "title": "stop",
    "signatures": [
      {
        "code": "canBatch.stop([force[, callStart]])",
        "description": "\n\nIf this call to `stop` matches the number of calls to `start`, all of this batch's [can-event/batch/batch.trigger triggered]\nevents will be dispatched.  If the firing of those events creates new events, those new events will be dispatched\nafter the current batch in their own batch.\n",
        "params": [
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "force",
            "defaultValue": "false",
            "description": "Whether to stop batching events immediately."
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "callStart",
            "defaultValue": "false",
            "description": "Whether to call [can-event/batch/batch.start] after firing batched events.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "callStart",
      "defaultValue": "false",
      "description": "Whether to call [can-event/batch/batch.start] after firing batched events.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.dispatch": {
    "type": "function",
    "name": "can-event/batch/batch.dispatch",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 356,
      "codeLine": 380,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "\n \n",
    "description": "Dispatchs an event within the event batching system. ",
    "title": "dispatch",
    "signatures": [
      {
        "code": "canBatch.trigger(item, event [, args])",
        "description": "\n\nMakes sure an event is fired at the appropriate time within the appropriate batch.\nHow and when the event fires depends on the batching state.\n\nThere are three states of batching:\n\n- no queues - `trigger` is called outside of any `start` or `stop` call -> The event is dispatched immediately.\n- collecting batch - `trigger` is called between a `start` or `stop` call -> The event is dispatched when `stop` is called.\n- firing queues -  `trigger` is called due to another `trigger` called within a batch -> The event is dispatched after the current batch has completed in a new batch.\n\nFinally, if the event has a `batchNum` it is fired immediately.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "item",
            "description": "the target of the event."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": [
                  {
                    "name": "type",
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "event",
            "description": "the type of event, or an event object with a type given like `{type: 'name'}`"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "the parameters to trigger the event with.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "args",
      "description": "the parameters to trigger the event with.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.queue": {
    "type": "function",
    "name": "can-event/batch/batch.queue",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 444,
      "codeLine": 469,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "Queues a method to be called. \n",
    "title": "queue",
    "signatures": [
      {
        "code": "batch.queue(task)",
        "description": "\n\nQueues a method to be called in the current [can-event/batch/batch.collecting]\nqueue if there is one.  If there is a [can-event/batch/batch.dispatching] queue,\nit will create a batch and add the task to that batch.\nFinally, if there is no batch, the task will be executed immediately.\n\n```\nvar me = {\n  say: function(message){\n    console.log(this.name,\"says\", message);\n  }\n}\nbatch.queue([me.say, me, [\"hi\"]]);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "task",
            "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                }
              ]
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "task",
      "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
    }
  },
  "can-event/batch/batch.afterPreviousEvents": {
    "src": {
      "line": 494,
      "codeLine": 572,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\nWith batching, it's possible for a piece of code to read some observable, and listen to\nchanges in that observable, but have events fired that it should ignore.\n\nFor example, consider a list widget that creates `<li>`'s for each item in the list and listens to\nupdates in that list and adds or removes `<li>`s:\n\n```js\nvar makeLi = function(){\n  return document.createElement(\"li\")\n};\n\nvar listWidget = function(list){\n  var lis = list.map(makeLi);\n  list.on(\"add\", function(ev, added, index){\n    var newLis = added.map(makeLi);\n    lis.splice.apply(lis, [index, 0].concat(newLis) );\n  }).on(\"remove\", function(ev, removed, index){\n    lis.splice(index, removed.length);\n  });\n\n  return lis;\n}\n```\n\nThe problem with this is if someone calls `listWidget` within a batch:\n\n```js\nvar list = new DefineList([]);\n\ncanBatch.start();\nlist.push(\"can-event\",\"can-event/batch/\");\nlistWidget(list);\ncanBatch.stop();\n```\n\nThe problem is that list will immediately create an `li` for both `can-event` and `can-event/batch/`, and then,\nwhen `canBatch.stop()` is called, the `add` event listener will create duplicate `li`s.\n\nThe solution, is to use `afterPreviousEvents`:\n\n```js\nvar makeLi = function(){\n  return document.createElement(\"li\")\n};\n\nvar listWidget = function(list){\n  var lis = list.map(makeLi);\n  canBatch.afterPreviousEvents(function(){\n    list.on(\"add\", function(ev, added, index){\n      var newLis = added.map(makeLi);\n      lis.splice.apply(lis, [index, 0].concat(newLis) );\n    }).on(\"remove\", function(ev, removed, index){\n      lis.splice(index, removed.length);\n    });\n  });\n\n  return lis;\n}\n```\n\n \n",
    "description": "Run code when all previuos state has settled. \n",
    "title": "afterPreviousEvents",
    "name": "can-event/batch/batch.afterPreviousEvents",
    "parent": "can-event/batch/batch",
    "signatures": [
      {
        "code": "canBatch.afterPreviousEvents(handler)",
        "description": "\n\nCalls `handler` when all previously [can-event/batch/batch.trigger triggered] events have\nbeen fired.  This is useful to know when all fired events match the current state.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "A function to call back when all previous events have fired.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "A function to call back when all previous events have fired.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.debounce": {
    "src": {
      "line": 588,
      "codeLine": 599,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "type": "function",
    "body": "",
    "description": "Provides a debounced event listener ",
    "title": "debounce",
    "name": "can-event/batch/batch.debounce",
    "parent": "can-event/batch/batch",
    "signatures": [
      {
        "code": "canBatch.debounce(handler)",
        "description": "\n\nMakes sure an event handler function is only run once per batch.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "The debounced function\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "The handler that will be executed to handle the event."
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "The debounced function\n"
    }
  },
  "can.util.bind": {
    "src": {
      "line": 1,
      "codeLine": 10,
      "path": "node_modules/can-event/lifecycle/lifecycle.js"
    },
    "type": "typedef",
    "body": "\n\n",
    "description": "\nProvides mixin-able bind and unbind methods. `bind()` calls `this._bindsetup`\nwhen the first bind happens and.  `unbind()` calls `this._bindteardown` when there\nare no more event handlers.\n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "bind",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "unbind",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can.util.bind",
    "hide": true
  },
  "can-event/lifecycle/lifecycle": {
    "src": {
      "path": "node_modules/can-event/lifecycle/lifecycle.md"
    },
    "body": "\n## Use\n\nTo use lifecycle events, provide an object with add/removeEventListener methods.\n\n```js\nvar Todo = function(){\n\n};\n\nlifecycle(assign(Todo.prototype, canEvent));\n\nTodo.prototype._eventSetup = function(){\n\t// Called the first time bindings are added.\n};\n```\n\n",
    "description": "Mixin lifecycle events onto a prototype. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event/lifecycle/lifecycle",
    "parent": "can-observables",
    "collection": "can-infrastructure",
    "signatures": [
      {
        "code": "lifecycle(prototype)",
        "description": "\n\nThe `can-event/lifecycle/lifecycle` module adds lifecycle events to a prototype that already has `addEventListener` and `removeEventListener`. It allows you to define:\n\n - `_eventSetup`: A method that is called the first time a binding is added to the object.\n - `_eventTeardown`: A method that is called when there are no longer any more bindings on an object.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-globals/methods": {
    "name": "can-globals/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-globals",
    "description": "",
    "order": 0
  },
  "can-globals/modules": {
    "name": "can-globals/modules",
    "title": "modules",
    "type": "group",
    "parent": "can-globals",
    "description": "",
    "order": 1
  },
  "can-globals": {
    "src": {
      "path": "node_modules/can-globals/doc/can-globals.md"
    },
    "body": "",
    "description": "An environment agnostic container for global variables. Useful for testing and server-side rendering (SSR), typically used internally by CanJS. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "The `can-globals` package exports an object with\nmethods used to set and get global variables. For example, get the global [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object:\n\n```js\nconst globals = require('can-globals');\n\nconst LOCATION = globals.getKeyValue('location');\n```\n\nNew keys can be defined with the `define` method, overwritten with the `set` method, and reset to their original value with the `reset` method.\nAll of these methods are demonstrated in the following example\n\n```js\nconst globals = require('can-globals');\n\nglobals.define('foo', 'bar'); // foo === 'bar'\n\nglobals.set('foo', 'baz'); // foo === 'baz'\n\nglobals.reset('foo'); // foo === 'bar'\n```\n"
      }
    ],
    "name": "can-globals",
    "parent": "can-js-utilities",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "https://www.bitovi.com/"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": [
            "node_modules/**/*",
            "**/*{-,_,}{test,qunit}{s,}.js",
            "build.js",
            "demo.js",
            "test-wrapper.js"
          ]
        },
        "readme": {
          "apis": "./doc/apis.json"
        },
        "parent": "can-globals"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-globals/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "^1.0.0",
        "can-reflect": "^1.2.6",
        "can-symbol": "^1.0.0"
      },
      "deprecated": false,
      "description": "This module provides a dependency injection container. Modules may define a key and specify a default value (which can be static, cached lazy, or dynamic lazy), but other code can set and reset the value as needed. There is also an event system, for alerting on value changes, both specific to a key and for any key.",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.5",
        "qunitjs": "^2.4.0",
        "steal": "^1.5.6",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.7.0",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-globals#readme",
      "keywords": [
        "canjs",
        "can-globals",
        "globals",
        "dependancy",
        "injection"
      ],
      "license": "MIT",
      "main": "can-globals.js",
      "name": "can-globals",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-globals.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm run build && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "0.2.4"
    }
  },
  "can-globals/document/document": {
    "src": {
      "line": 5,
      "codeLine": 26,
      "path": "node_modules/can-globals/document/document.js"
    },
    "type": "module",
    "body": "\n",
    "description": "\nGet the global [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the current context.\n",
    "title": "document",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-globals/document/document",
    "parent": "can-globals/modules",
    "signatures": [
      {
        "code": "DOCUMENT([newDocument])",
        "description": "\n\nOptionally sets, and returns, the [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the context.\n\n```js\nvar documentShim = { getElementById() {...} };\nvar DOCUMENT = require('can-globals/document/document');\nDOCUMENT(documentShim); //-> document\nDOCUMENT().getElementById('foo');\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "newDocument",
            "description": "An optional document-like object to set as the context's document \n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The window object for this JavaScript environment.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "newDocument",
      "description": "An optional document-like object to set as the context's document \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The window object for this JavaScript environment.\n"
    }
  },
  "can-globals/location/location": {
    "src": {
      "line": 5,
      "codeLine": 26,
      "path": "node_modules/can-globals/location/location.js"
    },
    "type": "module",
    "body": "\n",
    "description": "\nGet the global [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the current context.\n",
    "title": "location",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-globals/location/location",
    "parent": "can-globals/modules",
    "signatures": [
      {
        "code": "LOCATION([newLocation])",
        "description": "\n\nOptionally sets, and returns, the [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the context.\n\n```js\nvar locationShim = { path: '/' };\nvar LOCATION = require('can-globals/location/location');\nLOCATION(locationShim);\nLOCATION().path; // -> '/'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "location",
            "description": "An optional location-like object to set as the context's location\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The location object for this JavaScript environment.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "location",
      "description": "An optional location-like object to set as the context's location\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The location object for this JavaScript environment.\n"
    }
  },
  "can-globals/global/global": {
    "src": {
      "line": 7,
      "codeLine": 32,
      "path": "node_modules/can-globals/global/global.js"
    },
    "type": "module",
    "body": "\n",
    "description": "\nGet the global object for the current context.\n",
    "title": "global",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-globals/global/global",
    "parent": "can-globals/modules",
    "signatures": [
      {
        "code": "GLOBAL([newGlobal])",
        "description": "\n\nOptionally sets, and returns the global that this environment provides. It will be one of:\n\n```js\nvar GLOBAL = require('can-globals/global/global');\nvar g = GLOBAL();\n// In a browser\nconsole.log(g === window); // -> true\n```\n\n- **Browser**: [`window`](https://developer.mozilla.org/en-US/docs/Web/API/window)\n- **Web Worker**: [`self`](https://developer.mozilla.org/en-US/docs/Web/API/Window/self)\n- **Node.js**: [`global`](https://nodejs.org/api/globals.html#globals_global)\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "newGlobal",
            "description": "An optional global-like object to set as the context's global \n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The global object for this JavaScript environment.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "newGlobal",
      "description": "An optional global-like object to set as the context's global \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The global object for this JavaScript environment.\n"
    }
  },
  "can-globals/is-browser-window/is-browser-window": {
    "src": {
      "line": 4,
      "codeLine": 23,
      "path": "node_modules/can-globals/is-browser-window/is-browser-window.js"
    },
    "type": "module",
    "body": "",
    "description": "",
    "title": "is-browser-window",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-globals/is-browser-window/is-browser-window",
    "parent": "can-globals/modules",
    "signatures": [
      {
        "code": "isBrowserWindow()",
        "description": "\n\nReturns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).\n\n```js\nvar isBrowserWindow = require(\"can-globals/is-browser-window/is-browser-window\");\nvar GLOBAL = require(\"can-globals/global/global\");\n\nif(isBrowserWindow()) {\n  console.log(GLOBAL() === window); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the environment is a Browser window.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the environment is a Browser window.\n"
    }
  },
  "can-globals/mutation-observer/mutation-observer": {
    "src": {
      "line": 5,
      "codeLine": 26,
      "path": "node_modules/can-globals/mutation-observer/mutation-observer.js"
    },
    "type": "module",
    "body": "\n",
    "description": "\nGet the global [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the current context.\n",
    "title": "mutation-observer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-globals/mutation-observer/mutation-observer",
    "parent": "can-globals/modules",
    "signatures": [
      {
        "code": "MUTATIONOBSERVER([newMutationObserver])",
        "description": "\n\nOptionally sets, and returns, the [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the context.\n\n```js\nvar mutationObserverShim = require('can-globals/mutation-observer/mutation-observer');\nMUTATIONOBSERVER(mutationObserverShim);\nMUTATIONOBSERVER() //-> MutationObserver\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "MutationObserver",
            "description": "An optional MutationObserver-like object to set as the context's MutationObserver\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The MutationObserver object for this JavaScript environment.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "MutationObserver",
      "description": "An optional MutationObserver-like object to set as the context's MutationObserver\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The MutationObserver object for this JavaScript environment.\n"
    }
  },
  "can-fixture.properties": {
    "name": "can-fixture.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-fixture",
    "description": "",
    "order": 0
  },
  "can-fixture.types": {
    "name": "can-fixture.types",
    "title": "types",
    "type": "group",
    "parent": "can-fixture",
    "description": "",
    "order": 0
  },
  "can-fixture": {
    "src": {
      "path": "node_modules/can-fixture/docs/can-fixture.md"
    },
    "body": "",
    "description": "can-fixture intercepts an AJAX request and simulates the response with a file or function. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-fixture",
    "parent": "can-data-modeling",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-fixture/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-connect": "^1.5.4",
        "can-deparam": "^1.0.1",
        "can-namespace": "1.0.0",
        "can-set": "^1.3.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Intercept AJAX requests and simulate responses.",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "detect-cyclic-packages": "^1.1.0",
        "jquery": "^3.1.1",
        "jshint": "^2.7.0",
        "steal": "^1.0.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-fixture",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "fixture.js",
      "name": "can-fixture",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-fixture.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint fixture.js core.js store.js xhr.js --config",
        "postpublish": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee --browsers firefox test/test.html",
        "version": "git commit -am \"Update version number\" && git checkout -b release && git add -f dist/"
      },
      "version": "1.1.1"
    },
    "signatures": [
      {
        "code": "fixture(ajaxSettings, requestHandler(...))",
        "description": "\n\nIf an XHR request matches ajaxSettings, calls requestHandler with the XHR requests data. Makes the XHR request respond with the return value of requestHandler or the result of calling its response argument.\n\nThe following traps requests to GET /todos and responds with an array of data:\n\n```js\nfixture({method: \"get\", url: \"/todos\"},\n        function(request, response, headers, ajaxSettings){\n    return {\n        data: [\n            {id: 1, name: \"dishes\"},\n            {id: 2, name: \"mow\"}\n        ]\n    };\n})\n```\n\nWhen adding a fixture, it will remove any identical fixtures from the list of fixtures. The last fixture added will be the first matched.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/ajaxSettings"
              }
            ],
            "name": "ajaxSettings",
            "description": "An object that is used to match values on an XHR object, namely the url and method. url can be templated like /todos/{_id}."
          },
          {
            "types": [
              {
                "type": "can-fixture.requestHandler"
              }
            ],
            "name": "requestHandler",
            "description": "Handles the request and provides a response. The next section details this function's use.\n"
          }
        ]
      },
      {
        "code": "fixture(ajaxSettings, url)",
        "description": "\n\nRedirects the request to another url.  This can be useful for simulating a response with a file.\n\n```js\nfixture({url: \"/tasks\"}, \"fixtures/tasks.json\");\n```\n\nPlaceholders available in the `ajaxSettings` url will be available in the redirect url:\n\n```js\nfixture({url: \"/tasks/{id}\"}, \"fixtures/tasks/{id}.json\");\n```\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, data)",
        "description": "\n\nResponds with the `JSON.stringify` result of `data`.\n\n```js\nfixture({url: \"/tasks\"}, {tasks: [{id: 1, complete: false}]});\n```\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, delay)",
        "description": "\n\nDelays the ajax request from being made for `delay` milliseconds.\n\n```js\nfixture({url: \"/tasks\"}, 2000);\n```\n\nThis doesn't simulate a response, but is useful for simulating slow connections.\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, null)",
        "description": "\n\nRemoves the matching fixture from the list of fixtures.\n\n```js\nfixture({url: \"/tasks\"}, \"fixtures/tasks.json\");\n\n$.get(\"/tasks\") // requests fixtures/tasks.json\n\nfixture({url: \"/tasks\"}, null);\n\n$.get(\"/tasks\") // requests /tasks\n```\n",
        "params": []
      },
      {
        "code": "fixture(methodAndUrl, url|data|requestHandler)",
        "description": "\n\nA short hand for creating an [can-fixture/types/ajaxSettings] with a `method` and `url`.\n\n```js\nfixture(\"GET /tasks\", requestHandler );\n\n// is the same as\n\nfixture({method: \"get\", url: \"/tasks\"}, requestHandler );\n```\n\nThe format is `METHOD URL`.\n",
        "params": []
      },
      {
        "code": "fixture(url, url|data|requestHandler)",
        "description": "\n\nA short hand for creating an [can-fixture/types/ajaxSettings] with just a `url`.\n\n```js\nfixture(\"/tasks\", requestHandler);\n\n// is the same as\n\nfixture({url: \"/tasks\"}, requestHandler);\n```\n",
        "params": []
      },
      {
        "code": "fixture(fixtures)",
        "description": "\n\nCreate multiple fixtures at once.\n\n```js\nfixture({\n    \"POST /tasks\": function(){\n        return {id: Math.random()}\n    },\n    \"GET /tasks\": {data: [{id: 1, name: \"mow lawn\"}]},\n    \"/people\": \"fixtures/people.json\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "methodAndUrl"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      },
                      {
                        "type": "Object"
                      },
                      {
                        "type": "can-fixture.requestHandler"
                      },
                      {
                        "type": "can-fixture/StoreType"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "fixtures",
            "description": "A mapping of methodAndUrl to\nsome response argument type.\n\n\n"
          }
        ]
      },
      {
        "code": "fixture(restfulUrl, store)",
        "description": "\n\nWire up a restful API scheme to a store.\n\n```js\nvar todoAlgebra = new set.Algebra(\n    set.props.id(\"id\")\n);\nvar todoStore = fixture.store([\n  { id: 1, name: 'Do the dishes'},\n  { id: 2, name: 'Walk the dog'}\n], todoAlgebra);\n\nfixture(\"/api/todos/{id}\", todoStore); // can also be written fixture(\"/api/todos\", todoStore);\n```\n\nThis is a shorthand for wiring up the `todoStore` as follows:\n\n```js\nfixture({\n    \"GET /api/todos\": todoStore.getListData,\n    \"GET /api/todos/{id}\": todoStore.getData,\n    \"POST /api/todos\": todoStore.createData,\n    \"PUT /api/todos/{id}\": todoStore.updateData,\n    \"DELETE /api/todos/{id}\": todoStore.destroyData\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "restfulUrl",
            "description": "The url that may include a template for the place of the ID prop.  The `list` url is assumed to be `restfulUrl` with the `/{ID_PROP}` part removed, if provided; otherwise the `item` url is assumed to have the `/{ID_PROP}` part appended to the end."
          },
          {
            "types": [
              {
                "type": "can-fixture/StoreType"
              }
            ],
            "name": "store",
            "description": "A store produced by [can-fixture.store].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-fixture/StoreType"
        }
      ],
      "name": "store",
      "description": "A store produced by [can-fixture.store].\n"
    }
  },
  "can-fixture.fixtures": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.fixtures.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Array",
        "options": []
      }
    ],
    "title": "fixtures",
    "name": "can-fixture.fixtures",
    "type": "property",
    "hide": true,
    "signatures": [
      {
        "code": "fixture.fixtures",
        "description": "\n\nThe list of currently active fixtures.\n",
        "params": []
      }
    ]
  },
  "can-fixture.delay": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.delay.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Number"
      }
    ],
    "title": "delay",
    "name": "can-fixture.delay",
    "type": "property",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.delay",
        "description": "\n\nSets the delay until a response is fired in milliseconds.\n\n```js\nfixture.delay = 1000; // 1 second delay\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture.on": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.on.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "on",
    "name": "can-fixture.on",
    "type": "property",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.on",
        "description": "\n\nTurns the fixtures on or off. Defaults to `true` for on.\n\n```js\nfixture.on = false; //-> AJAX requests will not be trapped\n```\n\nTo remove a fixture you can also use `fixture(ajaxSetting, null)`.\n",
        "params": []
      }
    ]
  },
  "can-fixture.rand": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.rand.md"
    },
    "body": "",
    "description": "\n",
    "title": "rand",
    "name": "can-fixture.rand",
    "type": "function",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.rand(min, max)",
        "description": "\n\nReturns a random integer in the range [min, max]. If only one argument is provided,\nreturns a random integer from [0, max].\n\n```js\nfixture.rand(1, 10) //-> Random number between 1 and 10 inclusive.\nfixture.rand(10) //-> Random number between 0 and 10 inclusive.\n```",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "min",
            "description": "The lower limit of values that will be returned."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "max",
            "description": "The upper limit of values that will be returned.  `max` is valid return value.\n"
          }
        ]
      },
      {
        "code": "fixture.rand(choices, min, max)",
        "description": "\n\nAn array of between min and max random items from choices. If only `min` is\nprovided, `max` will equal `min`.  If both `max` and `min` are not provided,\n`min` will be 1 and `max` will be `choices.length`.\n\n```js\n// pick a random number of items from an array\nfixture.rand([\"a\",\"b\",\"c\"]) //-> [\"c\"]\nfixture.rand([\"a\",\"b\",\"c\"]) //-> [\"b\",\"a\"]\n\n// pick one item from an array\nfixture.rand([\"a\",\"b\",\"c\"],1) //-> [\"c\"]\n\n// get one item from an array\nfixture.rand([\"a\",\"b\",\"c\"],1)[0] //-> \"b\"\n\n// get 2 or 3 items from the array\nfixture.rand([\"a\",\"b\",\"c\"],2,3) //-> [\"c\",\"a\",\"b\"]\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "choices",
            "description": "An array of values to chose from. The returned array will only include a value once."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "min",
            "description": "The minimum number of items to be in the returned array."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "max",
            "description": "The maximum number of items in the returned array.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "max",
      "description": "The maximum number of items in the returned array.\n"
    }
  },
  "can-fixture.store": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.store.md"
    },
    "body": "",
    "description": "\n",
    "title": "store",
    "name": "can-fixture.store",
    "type": "function",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.store(baseItems, algebra)",
        "description": "\n\nCreate a store that starts with `baseItems` for a service layer\ndescribed by `algebra`.\n\n```js\n// Describe the services parameters:\nvar todoAlgebra = new set.Algebra({\n    set.props.id(\"_id\"),\n    set.props.boolean(\"completed\"),\n    set.props.rangeInclusive(\"start\",\"end\"),\n    set.props.sort(\"orderBy\"),\n});\n\n// Create a store with initial data.\n// Pass [] if you want it to be empty.\nvar todoStore = fixture.store([\n    {\n      _id : 1,\n      name : 'Do the dishes',\n      complete: true\n    }, {\n      _id : 2,\n      name : 'Walk the dog',\n      complete: false\n    }],\n    todoAlgebra );\n\n// Hookup urls to the store:\nfixture(\"/todos/{_id}\", todoStore);\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "baseItems",
            "description": "An array of items that will populate the store."
          },
          {
            "types": [
              {
                "type": "can-set.Algebra"
              }
            ],
            "name": "algebra",
            "description": "A description of the service layer's parameters."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-fixture/StoreType"
            }
          ],
          "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n\n"
        }
      },
      {
        "code": "fixture.store(count, makeItems, algebra)",
        "description": "\n\nSimilar to `fixture.store(baseItems, algebra)`, except that\nit uses `makeItems` to create `count` entries in the store.\n\n```js\n// Describe the services parameters:\nvar todoAlgebra = new set.Algebra({ ... });\n\n// Create a store with initial data.\n// Pass [] if you want it to be empty.\nvar todoStore = fixture.store(\n    1000,\n    function(i){\n        return {\n          _id : i+1,\n          name : 'Todo '+i,\n          complete: fixture.rand([true, false],1)[0]\n        }\n    },\n    todoAlgebra );\n\n// Hookup urls to the store:\nfixture(\"/todos/{_id}\", todoStore);\n```",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "count",
            "description": "TODO describe"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "makeItems",
            "description": "A function that will generate `baseItems`"
          },
          {
            "types": [
              {
                "type": "can-set.Algebra"
              }
            ],
            "name": "algebra",
            "description": "A description of the service layer's parameters."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-fixture/StoreType"
            }
          ],
          "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-fixture/StoreType"
        }
      ],
      "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-set.Algebra"
        }
      ],
      "name": "algebra",
      "description": "A description of the service layer's parameters."
    }
  },
  "fixture.types.Store.findOne": {
    "type": "function",
    "name": "fixture.types.Store.findOne",
    "parent": "fixture.types.Store",
    "src": {
      "line": 177,
      "codeLine": 197,
      "path": "node_modules/can-fixture/helpers/legacyStore.js"
    },
    "body": "`store.findOne(request, response(item))` simulates a request to\nget a single item from the server by id.\n\n    todosStore.findOne({\n      url: \"/todos/5\"\n    }, function(todo){\n\n    });\n\n\t \n",
    "description": "Simulate a findOne request on a fixture. \n",
    "title": "",
    "signatures": [
      {
        "code": "store.findOne(request, response)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "request",
            "description": "Parameters for the request."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "response",
            "description": "A function to call with the retrieved item."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "response",
      "description": "A function to call with the retrieved item."
    },
    "hide": true,
    "comment": " "
  },
  "fixture.types.Store.destroy": {
    "type": "function",
    "name": "fixture.types.Store.destroy",
    "parent": "fixture.types.Store",
    "src": {
      "line": 225,
      "codeLine": 244,
      "path": "node_modules/can-fixture/helpers/legacyStore.js"
    },
    "body": "`store.destroy(request, response())` simulates\na request to destroy an item from the server.\n\n```\ntodosStore.destroy({\n  url: \"/todos/5\"\n}, function(){});\n```\n\t \n",
    "description": "Simulate destroying a Model on a fixture. \n",
    "title": "",
    "signatures": [
      {
        "code": "store.destroy(request, callback)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "request",
            "description": "Parameters for the request."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "callback",
            "description": "A function to call after destruction."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "callback",
      "description": "A function to call after destruction."
    },
    "hide": true,
    "comment": " "
  },
  "can-kefir/symbols": {
    "name": "can-kefir/symbols",
    "title": "symbols",
    "type": "group",
    "parent": "can-kefir",
    "description": "",
    "order": 0
  },
  "can-kefir/methods": {
    "name": "can-kefir/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-kefir",
    "description": "",
    "order": 0
  },
  "can-kefir": {
    "src": {
      "path": "node_modules/can-kefir/doc/can-kefir.md"
    },
    "body": "\n## Use\n\nTo use it with [can-stache], create a stream and use `.value` or `.error` to write out the  \nlast emitted value or error.\n\n\nThe following will show a number increasing to 3 over 3 seconds:\n\n```js\nvar Kefir = require(\"can-kefir\");\n\nvar countTo3Stream = Kefir.sequentially(1000,[1,2,3]);\n\nvar view = stache(\"<p>Number: {{countTo3Stream.value}}</p>\");\n\nvar frag = view({\n\tcountTo3Stream: countTo3Stream\n});\n\ndocument.body.appendChild(frag);\n```\n\n## emitterProperty\n\nUse [can-kefir/emitterProperty] to create an stream object that also\nhas an emitter-like object attached.  The following creates an `age` stream that we can emit events on with its `emitter.value()` method:\n\n```js\nvar Kefir = require(\"can-kefir\");\n\nvar age = Kefir.emitterProperty();\n\nage.onValue(function(age){\n  console.log(age)\n});\n\nage.emitter.value(20) //-> logs 20\n\nage.emitter.value(30) //-> logs 30\n```\n\n",
    "description": "Integrate [KefirJS](https://rpominov.github.io/kefir/) streams directly within [can-stache] and other parts of CanJS.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n`can-kefir` exposes `value` and `error` key values on a stream that can be read and listened to\nby [can-reflect] and therefore many other CanJS libraries like [can-stache] and [can-stache-bindings].\n\nThe `can-kefir` module imports [KefirJS](https://rpominov.github.io/kefir/) and mutates it in two ways:\n\nFirst, it adds [can-symbol symbols]\nto Kefir's types so Kefir streams can be read and listened to for changes by [can-reflect].  This allows integration with various parts of CanJS like [can-stache] and [can-stache-bindings].  \n\nSecond, it adds a [can-kefir/emitterProperty] method that creates a stream that is more easily writable.\n\nThe decorated `Kefir` object is exported by the `can-kefir` module.\n"
      }
    ],
    "name": "can-kefir",
    "parent": "can-observables",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "DoneJS",
        "email": "core@donejs.com",
        "url": "http://canjs.com"
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-kefir/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.0.3",
        "can-define-lazy-value": "^1.0.0",
        "can-event": "^3.7.0",
        "can-observation": "^3.3.0",
        "can-reflect": "^1.2.0",
        "can-symbol": "^1.0.0",
        "can-util": "^3.9.0",
        "kefir": "^3.5.1"
      },
      "deprecated": false,
      "description": "Reflects Kefir streams so they work with the rest of CanJS",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.3.1",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.2.0",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "donejs-plugin",
        "Kefir",
        "streams"
      ],
      "license": "MIT",
      "main": "can-kefir",
      "name": "can-kefir",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-kefir.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postpublish": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update version number\" && git checkout -b release && git add -f dist/"
      },
      "version": "0.2.2"
    },
    "comment": " "
  },
  "can-kefir/can.offKeyValue": {
    "src": {
      "path": "node_modules/can-kefir/doc/can.offKeyValue.md"
    },
    "body": "",
    "description": "Used by [can-reflect/observe.offKeyValue can-reflect.offKeyValue] to stop listening to when the underlying stream emits either a `value` or `error` with a new value.\n\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "title": "can.offKeyValue",
    "name": "can-kefir/can.offKeyValue",
    "type": "property",
    "parent": "can-kefir/symbols",
    "signatures": [
      {
        "code": "stream[@@can.offKeyValue](key, handler)",
        "description": "\n\n[can-reflect/observe.offKeyValue can-reflect.offKeyValue] will use this function\nto stop listening to when emitted `value`s or `error`s change.\n\n```js\nvar Kefir = require(\"can-kefir\");\n\nvar count = Kefir.sequentially(1000, [1, 2, 2, 3]);\n\nfunction handler(newVal) {\n\tconsole.log(\"new value\", newVal); // logs 1, 2\n\tif(newVal > 2) {\n\t\tcanReflect.offKeyValue(stream, \"value\", handler);\n\t}\n}\n\ncanReflect.onKeyValue(stream, \"value\", handler);\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "Either `value` for values emitted by the stream or `error` or\nerror values emitted by the stream.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "value"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The same handler passed to `onKeyValue`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "value"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The same handler passed to `onKeyValue`.\n"
    }
  },
  "can-kefir/can.getKeyValue": {
    "src": {
      "path": "node_modules/can-kefir/doc/can.getKeyValue.md"
    },
    "body": "",
    "description": "Used by [can-reflect.getKeyValue can-reflect.getKeyValue] to read the stream's last emitted `value` or `error` and make those properties observable\nby [can-observation].\n\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "title": "can.getKeyValue",
    "name": "can-kefir/can.getKeyValue",
    "type": "property",
    "parent": "can-kefir/symbols",
    "signatures": [
      {
        "code": "stream[@@can.getKeyValue](key)",
        "description": "\n\n[can-reflect.getKeyValue can-reflect.getKeyValue] will use this function\nto read the last emitted `value` or `error` by this stream.  \n\nNote, `streams` only have a value if [can-reflect/observe.onKeyValue] is used to listen to changes.  Use\nKefir `properties` if you want to always be able to read a value.\n\n\nThe following creates a stream that immediately emits a value.  When `onKeyValue`\nis used to listen to changes, it will immediately log 1.  However,\nthat value is preserved so `getKeyValue` can still be used:\n\n\n```js\nvar Kefir = require(\"can-kefir\");\n\nvar stream = Kefir.stream(function(emit){\n\temit.value(1);\n});\n\ncanReflect.onKeyValue(stream, \"value\", function(newVal){\n\tconsole.log(\"new value\", newVal);\n}); // logs 1\n\ncanReflect.getKeyValue(stream,\"value\") //-> 1\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "Either `value` for values emitted by the stream or `error` for\nerror values emitted by the stream.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at that key.  The value will be stable for streams that\nhave already been bound by `onKeyValue` or Kefir properties.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "name",
      "description": "Either `value` for values emitted by the stream or `error` for\nerror values emitted by the stream.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value at that key.  The value will be stable for streams that\nhave already been bound by `onKeyValue` or Kefir properties.\n"
    }
  },
  "can-kefir/can.onKeyValue": {
    "src": {
      "path": "node_modules/can-kefir/doc/can.onKeyValue.md"
    },
    "body": "",
    "description": "Used by [can-reflect/observe.onKeyValue can-reflect.onKeyValue] to listen to when the underlying stream emits either a `value` or `error` with a new value.\n\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "title": "can.onKeyValue",
    "name": "can-kefir/can.onKeyValue",
    "type": "property",
    "parent": "can-kefir/symbols",
    "signatures": [
      {
        "code": "stream[@@can.onKeyValue](key, handler)",
        "description": "\n\n[can-reflect/observe.onKeyValue can-reflect.onKeyValue] will use this function\nto listen to when emitted `value`s or `error`s change.\n\nNotice how the following only logs 3 numbers even though 4 numbers are emitted:\n\n```js\nvar Kefir = require(\"can-kefir\");\n\nvar count = Kefir.sequentially(1000, [1, 2, 2, 3]);\n\ncanReflect.onKeyValue(stream, \"value\", function(newVal){\n\tconsole.log(\"new value\", newVal);\n}); // logs 1, 2, 3\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "Either `value` for values emitted by the stream or `error` or\nerror values emitted by the stream.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "value"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "A function handler that will be called when the emitted value changes with the emitted value.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "value"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "A function handler that will be called when the emitted value changes with the emitted value.\n"
    }
  },
  "can-kefir/emitterProperty": {
    "src": {
      "path": "node_modules/can-kefir/doc/emitterProperty.md"
    },
    "body": "",
    "description": "`.emitterProperty()` \n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [],
        "description": "\n\nEmitter property creates a Kefir [property](https://rpominov.github.io/kefir/#about-observables),\nbut then adds `emitter.value` and `emitter.error` methods that calls the\nproperty's [emitter object](https://rpominov.github.io/kefir/#emitter-object).\n\nThe end result is a single object that has methods of a stream, property and\nan attached emitter-like object.  \n\n```js\nvar Kefir = require(\"can-kefir\");\n\nvar age = Kefir.emitterProperty();\n\nage.onValue(function(age){\n  console.log(age)\n});\n\nage.emitter.value(20) //-> logs 20\n\nage.emitter.value(30) //-> logs 30\n```\n"
      }
    ],
    "title": "emitterProperty",
    "name": "can-kefir/emitterProperty",
    "type": "property",
    "parent": "can-kefir/methods"
  },
  "can-kefir/can.setKeyValue": {
    "src": {
      "path": "node_modules/can-kefir/doc/can.setKeyValue.md"
    },
    "body": "",
    "description": "Used by [can-reflect.settKeyValue can-reflect.setKeyValue] to set the stream's last emitted `value` or `error`.  This symbol is only added to\n[can-kefir/emitterProperty] objects.\n\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "title": "can.setKeyValue",
    "name": "can-kefir/can.setKeyValue",
    "type": "property",
    "parent": "can-kefir/symbols",
    "signatures": [
      {
        "code": "emitterProperty[@@can.setKeyValue](key, value)",
        "description": "\n\n[can-reflect.setKeyValue can-reflect.setKeyValue] will use this function\nto emit a `value` or `error` on the emitterProperty.\n\n\n```js\nvar Kefir = require(\"can-kefir\");\n\nvar age = Kefir.emitterProperty();\n\nage.onValue(function(value){\n\tconsole.log(value)\n});\n\ncanReflect.setKeyValue(age,\"value\",30) // logs 30\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "Either `value` to emit value or `error` to\nemit errors.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "Any value to emit.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "Any value to emit.\n"
    }
  },
  "can-fixture-socket.Server.prototype.onFeathersService": {
    "src": {
      "path": "node_modules/can-fixture-socket/docs/can-fixture-socket.on-feathers-service.md"
    },
    "body": "\n\n## Use\n\nInstantiate fixture store by calling [can-fixture.store] and provide FeathersJS service name:\n```js\nvar fixtureStore = fixture.store([\n  {_id: 1, title: 'One'},\n  {_id: 2, title: 'Two'},\n  {_id: 3, title: 'Three'}\n], new canSet.Algebra(canSet.props.id('_id')));\n *\nmockServer.onFeathersService('messages', fixtureStore, {id: \"_id\"});\n```\n\nThis will emulate FeathersJS server CRUD service.\n\nNow from Feathers client app you can do:\n```js\n// Import dependencies:\nvar io = require(\"socket.io-client\");\nvar feathers = require('feathers/client');\nvar feathersSocketio = require('feathers-socketio/client');\nvar hooks = require('feathers-hooks');\n\n// Configure Feathers client app:\nvar socket = io(\"http://api.my-feathers-server.com\");\nvar app = feathers()\n  .configure(hooks())\n  .configure(feathersSocketio(socket));\n\n// Create client Feathers service:\nvar messagesService = app.service('messages');\n\n// Test:\nmessagesService.get(1).then(function(data){\n  assert.deepEqual(data, {id: 1, title: 'One'}, 'get should receive an item');\n});\n```\n\n",
    "description": "\nSubscribes to mocked server socket events to work as FeathersJS CRUD service.\n",
    "title": "onFeathersService",
    "name": "can-fixture-socket.Server.prototype.onFeathersService",
    "type": "function",
    "parent": "can-fixture-socket.Server.prototype",
    "signatures": [
      {
        "code": "server.onFeathersService(name, fixtureStore, [options])",
        "description": "\n\nSubscribes to mocked server socket events according to FeathersJS protocol. Uses fixture store [can-fixture.Store] as a resource storage.\n\n```\nvar fixtureStore = fixture.store([\n  {id: 1, title: 'One'},\n  {id: 2, title: 'Two'},\n  {id: 3, title: 'Three'}\n], new canSet.Algebra({}));\n\nserver.onFeathersService(\"messages\", fixtureStore})\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of Feathers service."
          },
          {
            "types": [
              {
                "type": "can-fixture/StoreType"
              }
            ],
            "name": "fixtureStore",
            "description": "A fixture store. See [can-fixture.store] for more details."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options, e.g. property name for id.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options, e.g. property name for id.\n"
    },
    "comment": " "
  },
  "can-fixture-socket.socket-event-listener": {
    "src": {
      "path": "node_modules/can-fixture-socket/docs/can-fixture-socket.listener.md"
    },
    "body": "",
    "description": "A listener handler that will be executed to handle the socket event. \n",
    "type": "typedef",
    "title": "SocketEventListener",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-fixture-socket.socket-event-listener",
    "parent": "can-fixture-socket.types",
    "signatures": [
      {
        "code": "handler(...data, [ackFn])",
        "description": "\n\nSocket event listener handler expects one or more data arguments and an optional ACK callback.\n\n```js\n// Client:\nsocket.on(\"news\": function handler(data, ackCb){\n  console.log(\"received some news\", data);\n  ackCb(\"Acknowledged\", \"thank you\");\n});\n\n// Server:\nserver.emit(\"news\", {some: \"news here\"}, function ackFn(...data){\n  console.log(\"Client acknowledged data receiving\")\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "data",
            "description": "Event data. Socket.io allows to pass as many arguments as needed."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "ackCb",
            "description": "Optional acknowledgement callback to let emitter know about success receiving data.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "ackCb",
      "description": "Optional acknowledgement callback to let emitter know about success receiving data.\n"
    }
  },
  "can-fixture-socket.Server.prototype": {
    "name": "can-fixture-socket.Server.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-fixture-socket.Server",
    "description": "",
    "order": 0
  },
  "can-fixture-socket.Server": {
    "src": {
      "path": "node_modules/can-fixture-socket/docs/can-fixture.server.md"
    },
    "body": "\n\n## Use\n\n1. Instantiate a server to intercept socket.io connection:\n```js\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n\n2. Mock socket.io server behaviour:\n```js\nmockServer.on(\"connection\", function(){\n  mockServer.emit(\"notifications\", [{text: \"A new notification\"}]);\n});\n\nmockServer.on(\"some event\", function(data, ackCb){\n  console.log(\"Client send some \", data);\n  ackCb(\"thanks\");\n});\n```\n\n3. Test your client app:\n```js\nvar socket = io(\"http://localhost:8080/ws\");\nsocket.emit(\"some event\", \"some data\", function(data){\n  assert.equal(data, \"thanks\", \"Server acknowledged our event\");\n});\n```\n\n## Examples\n\n### CRUD service with fixture store\n\nLets see how we can test a possible implementation of a CRUD service that utilizes socket.io ACK callbacks. We will use fixture store to emulate our CRUD storage and link it to our mocked server.\n\n```js\nvar fixture = require(\"can-fixture\");\n\n// First, lets create fixture store:\nvar fixtureStore = fixture.store([\n  {id: 1, title: \"One\", rank: \"good\"},\n  {id: 2, title: \"Two\", rank: \"average\"},\n  {id: 3, title: \"Three\", rank: \"good\"}\n], new canSet.Algebra({}));\n\n// And instantiate a mocked server:\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n\nFixture store is designed to work with XHR requests, thus its methods take two arguments: `request` and `response`. See [can-fixture.Store.prototype.getListData] for more details. Our mocked server can listen to socket events and its event listener expects data and an optional ACK callback. To convert a request handler to an event listener we can use [can-fixture-socket.requestHandlerToListener]:\n\nNow we can create socket event listeners for our CRUD operations:\n```js\nvar toListener = fixtureSocket.requestHandlerToListener\nmockServer.on(\"messages find\",   toListener( fixtureStore.getListData ));\nmockServer.on(\"messages get\",    toListener( fixtureStore.getData     ));\nmockServer.on(\"messages remove\", toListener( fixtureStore.destroyData ));\nmockServer.on(\"messages create\", toListener( fixtureStore.createData  ));\nmockServer.on(\"messages update\", toListener( fixtureStore.updateData  ));\n```\n\nThere is also a helper [can-fixture-socket.storeToListeners] to create all listeners at once:\n```\nvar listeners = fixtureSocket.storeToListeners(messagesStore);\nmockServer.on({\n\t\"messages find\": listeners.getListData,\n\t\"messages get\": listeners.getData,\n\t\"messages remove\": listeners.destroyData,\n\t\"messages create\": listeners.createData,\n\t\"messages update\": listeners.updateData\n});\n```\n\nNow lets implement a CRUD model on our client. We define that all our ACK callbacks take an error as the first argument, and data as the second one.\n```js\nvar socket = io(\"localhost\");\n\nsocket.emit(\"messages find\", {rank: \"good\"}, function(err, response){\n  if (err){\n    console.log(\"Error: \", err);\n    return;\n  }\n  console.log(`We found ${response.count} good items\", response.data);\n  assert.equal(response.count, 3)\n});\n```\n\nNow lets test the rest of the methods:\n```js\nsocket.emit(\"messages get\", {id: 1}, function(err, data){s\n  assert.deepEqual(data, {id: 1, title: \"One\"}, \"received the item\");\n});\nsocket.emit(\"messages update\", {id: 2, title: \"TwoPlus\"}, function(err, data){\n  assert.deepEqual(data, {id: 2, title: \"TwoPlus\"}, \"received the updated item\");\n});\nsocket.emit(\"messages get\", {id: 999}, function(err, data){\n  assert.deepEqual(err, {error: 404, message: \"no data\"}, \"received 404 when looking for a non-existent item id\");\n});\n```\n\n",
    "description": "\nIntercept socket.io messages and simulates socket.io server responses.\n",
    "type": "constructor",
    "name": "can-fixture-socket.Server",
    "title": "Server",
    "parent": "can-fixture-socket.properties",
    "signatures": [
      {
        "code": "new Server( io )",
        "description": "\n\nWhen server is instantiated with socket.io `io` object it intercepts a socket.io connection and allows to mock socket.io server behaviour. On instantiation we:\n  - empty `io.managers` object which is a cache of socket.io `io.Manager` instances;\n  - override `io.Manager.prototype` to work with current instance of the mocked server.\n  \n```js\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "io",
            "description": "Imported `socket.io-client` object.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "io",
      "description": "Imported `socket.io-client` object.\n"
    },
    "comment": " "
  },
  "can-jquery.modules": {
    "name": "can-jquery.modules",
    "title": "Modules",
    "type": "group",
    "parent": "can-jquery",
    "description": "",
    "order": 0
  },
  "can-jquery.fns": {
    "name": "can-jquery.fns",
    "title": "Methods",
    "type": "group",
    "parent": "can-jquery",
    "description": "",
    "order": 1
  },
  "can-jquery": {
    "src": {
      "path": "node_modules/can-jquery/docs/can-jquery.md"
    },
    "body": "\nUsing `can-jquery` causes the two event systems to be cross-bound. You can listen to special events within [can-stache-bindings] using jQuery and you can listen to custom jQuery events within [can-control]s.\n\n## Listening to inserted/removed events\n\nUsing `can-jquery` you can listen to the removed/inserted event on an element.\n\n```js\nvar $ = require(\"can-jquery\");\n\nvar el = $(\"<div>\");\n\nel.on(\"inserted\", function(){\n\t// The element was inserted.\n});\n\n$(document.body).append(el);\n```\n\n## Listening to jQuery events within Controls\n\nInside a [can-control] you can listen to any custom jQuery events.\n\n```js\nvar $ = require(\"can-jquery\");\nvar Control = require(\"can-control\");\n\nvar MyControl = Control.extend({\n\t\"names-added\": function(el, ev, first, second, third){\n\t\t// first is \"Matthew\"\n\t\t// second is \"David\"\n\t\t// third is \"Brian\"\n\t}\n});\n\nvar dom = $(\"<div><ul></ul></div>\");\n\nnew MyControl(dom);\n\ndom.find(\"ul\").trigger(\"names-added\", [\n\t\"Matthew\",\n\t\"David\",\n\t\"Brian\"\n]);\n```\n\n",
    "description": "Extensions to the event system so that can events and jQuery events are cross-bound. \n",
    "type": "module",
    "title": "can-jquery",
    "types": [
      {
        "type": "jQuery"
      }
    ],
    "name": "can-jquery",
    "parent": "can-dom-utilities",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-dom-events": "^1.0.4",
        "can-event": "^3.7.5",
        "can-event-dom-enter": "^1.0.2",
        "can-globals": "^0.2.3",
        "can-util": "^3.10.12",
        "can-view-model": "^3.4.0",
        "jquery": "2.x - 3.x"
      },
      "deprecated": false,
      "description": "CanJS integrations for jQuery",
      "devDependencies": {
        "can-component": "^3.3.4",
        "can-control": "^3.2.0",
        "can-define": "^1.5.0",
        "can-list": "^3.2.1",
        "can-map": "^3.4.0",
        "can-stache": "^3.8.0",
        "can-stache-bindings": "^3.4.0",
        "can-test-helpers": "^1.0.1",
        "can-vdom": "^3.2.1",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "qunitjs": "^2.4.0",
        "steal": "^1.5.15",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.9.0",
        "testee": "^0.7.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs"
      ],
      "main": "can-jquery.js",
      "name": "can-jquery",
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.2.3"
    },
    "signatures": [
      {
        "code": "jQuery",
        "description": "\n\nImporting `can-jquery` will return the [jQuery object](http://api.jquery.com/jquery/) and wire up the event system.\n\n```js\nvar $ = require(\"can-jquery\");\n\nvar div = $(\"<div>\");\n\ndiv.on(\"inserted\", function(){\n\t// it inserted!\n});\n\n$(\"body\").append(div);\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-jquery/legacy": {
    "src": {
      "path": "node_modules/can-jquery/docs/legacy.md"
    },
    "body": "\nImporting can-jquery/legacy will also bring in [can-jquery], but also has the side effect of enabling jQuery wrappers being applied to places such as [can-control]s and [can-stache-bindings.event] callbacks.\n\n***Note*** that simply importing can-jquery-legacy will enable this, so any [can-control]s expecting to receive the raw [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) will break.\n\n```js\nvar $ = require(\"can-jquery/legacy\");\nvar Control = require(\"can-control\");\n\nvar MyControl = Control.extend({\n\t\"li click\": function(el){\n\t\t// `el` is jQuery wrapped!\n\t}\n});\n\nvar dom = $(\"<div><ul><li>First</li><li>Second</li></ul></div>\");\nnew MyControl(dom);\n\ndom.find(\"li:first\").trigger(\"click\");\n```\n\n",
    "description": "Enables legacy integrations between CanJS and jQuery. \nImporting can/jquery/legacy will return the [jQuery object](http://api.jquery.com/jquery/). It will also import [can-jquery] so that the event system hooks are set up.\n\nAdditionally it will force element callbacks (such as those in [can-control]) to be jQuery wrapped.\n\n```js\nvar $ = require(\"can-jquery/legacy\");\n```\n\n",
    "type": "module",
    "title": "can-jquery/legacy",
    "types": [
      {
        "type": "jQuery"
      }
    ],
    "name": "can-jquery/legacy",
    "parent": "can-jquery.modules",
    "comment": " "
  },
  "can-jquery.fns.viewModel": {
    "src": {
      "path": "node_modules/can-jquery/docs/viewModel.md"
    },
    "body": "",
    "description": "Gets an element's View Model. \n",
    "title": "viewModel",
    "name": "can-jquery.fns.viewModel",
    "type": "function",
    "parent": "can-jquery.fns",
    "signatures": [
      {
        "code": ".viewModel()",
        "description": "\n\nCalls [can-view-model] with the unwrapped HTMLElement.\n\n```js\nvar vm = $(\"my-component\").viewModel();\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            },
            {
              "type": "can-map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the View Model set for this element.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        },
        {
          "type": "can-map"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the View Model set for this element.\n"
    }
  },
  "subscribeFeathersStoreToServer": {
    "type": "function",
    "name": "subscribeFeathersStoreToServer",
    "params": [
      {
        "name": "serviceName",
        "description": ""
      },
      {
        "name": "fixtureStore",
        "description": ""
      },
      {
        "name": "mockServer",
        "description": ""
      },
      {
        "name": "options",
        "description": ""
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 42,
      "codeLine": 55,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "\nfixture.store data:\n\t\tgetListData: {}\n\n",
    "description": "Subscribes to mocked socket server events for FeathersJS service.\nTransforms ((query, fn))\n",
    "_curParam": {
      "name": "options",
      "description": ""
    },
    "returns": "{*}",
    "hide": true
  },
  "wrapToId": {
    "type": "function",
    "name": "wrapToId",
    "params": [
      {
        "name": "options",
        "description": ""
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 87,
      "codeLine": 93,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "\n",
    "description": "Wraps given id into an object with property name `id` (or options.id).\n",
    "_curParam": {
      "name": "options",
      "description": ""
    },
    "returns": "{Function}",
    "hide": true
  },
  "toFeathersRemoveHandler": {
    "type": "function",
    "name": "toFeathersRemoveHandler",
    "params": [
      {
        "name": "getData",
        "description": "The wrapped fixture.store.getData method."
      },
      {
        "name": "destroyData",
        "description": "The wrapped fixture.store.destroyData method."
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 120,
      "codeLine": 131,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "\nFeathers `remove` method emits 2 arguments with data: `id` and `query`. But we ignore 2nd data argument for now.\n\n\n",
    "description": "FeathersJS's `remove` method returns the whole item back, when fixture.store's `destroyData` gives back only the given query (e.g. {id: 123}).\nFind the item by id first, then remove from fixture.store and return the item back.\n",
    "_curParam": {
      "name": "getData",
      "description": "The wrapped fixture.store.getData method."
    },
    "returns": "{Function}",
    "hide": true
  },
  "can-fixture-socket.Server.prototype.on": {
    "type": "function",
    "name": "can-fixture-socket.Server.prototype.on",
    "parent": "can-fixture-socket.Server.prototype",
    "src": {
      "line": 37,
      "codeLine": 71,
      "path": "node_modules/can-fixture-socket/src/index.js"
    },
    "body": "\n",
    "description": "\nAdds a socket event listener.\n",
    "title": "on",
    "signatures": [
      {
        "code": "server.on(event, handler)",
        "description": "\n\nAdds a socket event listener.\n\n```js\nserver.on(\"notifications\", function(data, ackFn){\n  console.log(\"Received \" + data);\n  ackFn(\"Acknowledged, thank you\");\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "string"
              }
            ],
            "name": "event",
            "description": "The name of the socket event to listen for."
          },
          {
            "types": [
              {
                "type": "can-fixture-socket.socket-event-listener"
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the socket event.\n"
          }
        ]
      },
      {
        "code": "server.on(eventsObject)",
        "description": "\n\nA short hand method to add multiple event listeners.\n\n```js\nserver.on({\n  \"news\": handleNews,\n  \"tweets\": handleTweets,\n  \"users\": handleUsers\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "object"
              }
            ],
            "name": "eventsObject",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "object"
        }
      ],
      "name": "eventsObject",
      "description": "\n"
    }
  },
  "can-fixture-socket.Server.prototype.emit": {
    "type": "function",
    "name": "can-fixture-socket.Server.prototype.emit",
    "parent": "can-fixture-socket.Server.prototype",
    "src": {
      "line": 85,
      "codeLine": 105,
      "path": "node_modules/can-fixture-socket/src/index.js"
    },
    "body": "\n",
    "description": "\nEmits a socket event.\n",
    "title": "emit",
    "signatures": [
      {
        "code": "server.emit(event, ...data, [ackFn])",
        "description": "\n\nEmits a socket event.\n\n```js\nserver.emit(\"news\", data1, data2, function(ackData){\n  console.log(\"Client acknowledged\", ackData);\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "string"
              }
            ],
            "name": "event",
            "description": "The name of the socket event."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "data",
            "description": "Data to be sent with the event. Socket.io allows to send more than one data objects."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "ackFn",
            "description": "The acknowledgement function that will be executed if the receiver calls the acknowledgement callback.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "ackFn",
      "description": "The acknowledgement function that will be executed if the receiver calls the acknowledgement callback.\n"
    }
  },
  "can-fixture-socket.Server.prototype.restore": {
    "type": "function",
    "name": "can-fixture-socket.Server.prototype.restore",
    "parent": "can-fixture-socket.Server.prototype",
    "src": {
      "line": 123,
      "codeLine": 135,
      "path": "node_modules/can-fixture-socket/src/index.js"
    },
    "body": "",
    "description": "\n",
    "title": "restore",
    "signatures": [
      {
        "code": "server.restore()",
        "description": "\n\nRestores `io.Manager.prototype` and clears `io.managers` cache.\n\n```\nserver.restore();\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture-socket.requestHandlerToListener": {
    "type": "function",
    "name": "can-fixture-socket.requestHandlerToListener",
    "parent": "can-fixture-socket.properties",
    "src": {
      "line": 2,
      "codeLine": 50,
      "path": "node_modules/can-fixture-socket/src/store.js"
    },
    "body": "\n\n\n## Use\n\nFixture [can-fixture.store] methods expect two arguments `req` and `res` and work like this:\n  - grab query from `req.data`;\n  - on error call `res( 403, err )`;\n  - on success call `res( data )`.\n  \nThe format of the returned data is:\n  - for [can-fixture/StoreType.prototype.getDataList]: {count: <number>, limit: <number>, offset: <number> , data: [{...},{...}, ...]}\n  - for [can-fixture/StoreType.prototype.getData]: the item object.\n\nWe can use the helper to transform fixture store methods into event listeners:\n```js\nvar fixture = require(\"can-fixture\");\nvar canSet = require(\"can-set\");\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\n\n// Create fixture store:\nvar fixtureStore = fixture.store([\n  {id: 1, title: 'One'},\n  {id: 2, title: 'Two'},\n  {id: 3, title: 'Three'}\n], new canSet.Algebra({}));\n\nvar mockedServer = new fixtureSocket.Server(io);\nmockedServer.on(\"books find\", fixtureStore.requestHandlerToListener( fixtureStore.getListData ));\n```\n\n",
    "description": "\nTransforms XHR request handler into socket event listener.\n",
    "title": "requestHandlerToListener",
    "signatures": [
      {
        "code": "requestHandlerToListener( reqHandler )",
        "description": "\n\nTransforms request handler that expects two arguments `request` and `response` into socket event listener.\n\n```js\nserver.on(\"news find\", requestHandlerToListener( fixtureStore.getListData ));\n```\n    ",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "reqHandler",
            "description": "A request handler, e.g. [can-fixture/StoreType.prototype.getListData]."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "reqHandler",
      "description": "A request handler, e.g. [can-fixture/StoreType.prototype.getListData]."
    },
    "returns": "{can-fixture-store.socket-event-listener}",
    "comment": " "
  },
  "can-fixture-socket.storeToListeners": {
    "type": "function",
    "name": "can-fixture-socket.storeToListeners",
    "parent": "can-fixture-socket.properties",
    "src": {
      "line": 65,
      "codeLine": 122,
      "path": "node_modules/can-fixture-socket/src/store.js"
    },
    "body": "\n\n\n## Use\n\nFixture [can-fixture.store] provides REST-ful resource storage. Its designed to work with XHR requests thus its methods expect two arguments `request` and `response`. To work with socket events we need to transform request handlers into socket event listeners.\n\nHere is how we can do this:\n\n```js\nvar fixture = require(\"can-fixture\");\nvar canSet = require(\"can-set\");\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\n\n// Create fixture store:\nvar fixtureStore = fixture.store([\n  {id: 1, title: 'One'},\n  {id: 2, title: 'Two'},\n  {id: 3, title: 'Three'}\n], new canSet.Algebra({}));\n\n// Instantiate mocked socket server:\nvar mockedServer = new fixtureSocket.Server(io);\n\n// Now use fixture store to emulate REST-ful service:\nvar toListener = fixtureStore.requestHandlerToListener;\nmockedServer.on({\n  \"books find\":   toListener( fixtureStore.getListData ),\n  \"books get\":    toListener( fixtureStore.getData ),\n  \"books create\": toListener( fixtureStore.createData ),\n  \"books update\": toListener( fixtureStore.updateData ),\n  \"books delete\": toListener( fixtureStore.destroyData )\n});\n```\n\n",
    "description": "\nReturns a set of listeners transformed from fixture store request handlers. Useful for working with REST-ful resources.\n",
    "title": "storeToListeners",
    "signatures": [
      {
        "code": "storeToListeners( fixtureStore )",
        "description": "\n\nWraps methods of fixture.store to make them socket event listener.\n\n```js\nvar listeners = storeToListeners( fixtureStore );\n\nserver.on({\n  \"news find\": listeners.getListData,\n  \"news get\": listeners.getData,\n})\n```\n",
        "params": [
          {
            "name": "fixtureStore",
            "description": ""
          }
        ]
      }
    ],
    "_curParam": {
      "name": "fixtureStore",
      "description": ""
    },
    "returns": "{*}",
    "comment": " "
  },
  "can-map.prototype.compute": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.compute.md"
    },
    "body": "\n`compute` is a convenience method for making computes from properties\nof Observes. More information about computes can be found under [can.compute].\n\n\n    var map = new Map({a: 'Alexis'});\n    var name = map.compute('a');\n    name.bind('change', function(ev, nevVal, oldVal) {\n        console.log('a changed from ' + oldVal + 'to' + newName + '.');\n    });\n\n    name(); // 'Alexis'\n\n    map.attr('a', 'Adam'); // 'a changed from Alexis to Adam.'\n    name(); // 'Adam'\n\n    name('Alice'); // 'a changed from Adam to Alice.'\n    name(); // 'Alice'\n\n",
    "description": "Make a can.compute from an observable property. \n",
    "title": "compute",
    "name": "can-map.prototype.compute",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 4,
    "signatures": [
      {
        "code": "map.compute(attrName)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "the property to bind to"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "a [can-compute] bound to _attrName_\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "the property to bind to"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "a [can-compute] bound to _attrName_\n"
    },
    "comment": " "
  },
  "can-map.prototype.attr": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.attr.md"
    },
    "body": "`attr` gets or sets properties on the `Map` it's called on. Here's a tour through\nhow all of its forms work:\n\n\n    var people = new Map({});\n\n    // set a property:\n    people.attr('a', 'Alex');\n\n    // get a property:\n    people.attr('a'); // 'Alex'\n\n    // set and merge multiple properties:\n    people.attr({\n        a: 'Alice',\n        b: 'Bob'\n    });\n\n    // get all properties:\n    people.attr(); // {a: 'Alice', b: 'Bob'}\n\n    // set properties while removing others:\n    people.attr({\n        b: 'Bill',\n        e: 'Eve'\n    }, true);\n\n    people.attr(); // {b: 'Bill', e: 'Eve'}\n\n\n## Deep properties\n\n`attr` can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using `attr`.\n\n\n    var people = new Map({names: {}});\n\n    // set a property:\n    people.attr('names.a', 'Alice');\n\n    // get a property:\n    people.attr('names.a'); // 'Alice'\n    people.names.attr('a'); // 'Alice'\n\n    // get all properties:\n    people.attr(); // {names: {a: 'Alice'}}\n\n\nObjects that are added to Observes become Observes themselves behind the scenes,\nso changes to deep properties fire events at each level, and you can bind at any\nlevel. As this example shows, all the same events are fired no matter what level\nyou call `attr` at:\n\n\n    var people = new Map({names: {}});\n\n    people.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    people.names.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    people.bind('names', function(ev, newVal, oldVal) {\n        console.log('people names: ' + newVal + ', ' + oldVal);\n    });\n\n    people.names.bind('a', function(ev, newVal, oldVal) {\n        console.log('people.names a: ' + newVal + ', ' + oldVal);\n    });\n\n    people.bind('names.a', function(ev, newVal, oldVal) {\n        console.log('people names.a: ' + newVal + ', ' + oldVal);\n    });\n\n    people.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined\n                                  // people.names change: a, add, Alice, undefined\n                                  // people.names a: Alice, undefined\n                                  // people names.a: Alice, undefined\n\n    people.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined\n                                  // people.names change: b, add, Bob, undefined\n                                  // people.names b: Bob, undefined\n                                  // people names.b: Bob, undefined\n\n\n## Properties with dots in their name\n\nAs shown above, `attr` enables reading and setting deep properties so special care must be taken when property names include dots (`.`).  When setting a property containing dots, `attr` looks for an existing container object in the path.  If found, it will repeat the process for the child Map and the rest of the path; if not, any remaining path (dots included) becomes the property key to be set on the container.\n\n```\nvar person = new Map({\n\t'first.name': 'Alice',\n\t'second': {\n\t\t'name': 'Amy',\n\t\t'old.name': 'Andrea'\n\t}\n});\n\nperson.attr('first.name', 'Bob'); // 'Alice' -> 'Bob'\nperson.attr('second.name', 'Bob'); // 'Amy' -> 'Bob'\nperson.attr({'second.old.name': 'Bob'}); // 'Andrea' -> 'Bob'\nperson.attr({'second.better.name': 'Bob'}); // 'better.name' is set to 'Bob' on `person.second`\nperson.attr({'third.name': 'Bob'}); // 'third.name' is set to 'Bob' on `person`\n\n```\n\nA property `foo` and a property `foo.bar` will be in conflict with each other; when reading `'foo.bar'` with `attr`, the full string `foo.bar` takes precedence, but when writing, `foo` takes precedence and `foo.bar` cannot be written to.  For this reason, it is inadvisable to set properties that create these conflicts.\n\n```\nvar person = new Map({\n\t'first.name': 'Alice',\n\t'first': {\n\t\t'name': 'Amy'\n\t}\n});\n\nperson.attr('first.name'); // 'Alice'\nperson.attr('first').attr('name'); // 'Amy'\n\nperson.attr('first.name', 'Bob'); // 'Amy' -> 'Bob'\nperson.attr('first').attr('name'); // 'Amy' -> 'Bob'\n\n```\n\n\n\n## See also\n\nFor information on the events that are fired on property changes and how\nto listen for those events, see [can.Map.prototype.bind bind].\n\n",
    "description": "Get or set properties on a Map. \n",
    "title": "attr",
    "name": "can-map.prototype.attr",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 2,
    "signatures": [
      {
        "code": "map.attr()",
        "description": "\n\nGets a collection of all the properties in this `Map`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with all the properties in this `Map`.\n"
        }
      },
      {
        "code": "map.attr(key)",
        "description": "\n\nReads a property from this `Map`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the property to read"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value assigned to _key_.\n"
        }
      },
      {
        "code": "map.attr(key, value)",
        "description": "\n\nAssigns _value_ to a property on this `Map` called _key_.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the property to set"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "the",
            "description": "value to assign to _key_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      },
      {
        "code": "map.attr(obj[, removeOthers])",
        "description": "\n\nAssigns each value in _obj_ to a property on this `Map` named after the\ncorresponding key in _obj_, effectively merging _obj_ into the Map.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "a collection of key-value pairs to set.\nIf any properties already exist on the `Map`, they will be overwritten.\n"
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "removeOthers",
            "defaultValue": "false",
            "description": "whether to remove keys not present in _obj_.\nTo remove keys without setting other keys, use `[can.Map::removeAttr removeAttr]`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "removeOthers",
      "defaultValue": "false",
      "description": "whether to remove keys not present in _obj_.\nTo remove keys without setting other keys, use `[can.Map::removeAttr removeAttr]`.\n"
    },
    "comment": " "
  },
  "can-map.prototype.bind": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.bind.md"
    },
    "body": "`bind` binds event handlers to property changes on `Map`s. When you change\na property using `attr`, two events are fired on the Map, allowing other parts\nof your application to map the changes to the object.\n\n## The _change_ event\n\nThe first event that is fired is the _change_ event. The _change_ event is useful\nif you want to react to all changes on a Map.\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('Something changed.');\n    });\n\n\nThe parameters of the event handler for the _change_ event are:\n\n- _ev_ The event object.\n- _attr_ Which property changed.\n- _how_ Whether the property was added, removed, or set. Possible values are `'add'`, `'remove'`, or `'set'`.\n- _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n- _oldVal_ This is the value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\nHere is a concrete tour through the _change_ event handler's arguments:\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log(ev + ', ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    o.attr('a', 'Alexis'); // [object Object], a, add, Alexis, undefined\n    o.attr('a', 'Adam');   // [object Object], a, set, Adam, Alexis\n    o.attr({\n        'a': 'Alice',      // [object Object], a, set, Alice, Adam\n        'b': 'Bob'         // [object Object], b, add, Bob, undefined\n    });\n    o.removeAttr('a');     // [object Object], a, remove, undefined, Alice\n\n\n(See also `[can.Map::removeAttr removeAttr]`, which removes properties).\n\n## The _property name_ event\n\nThe second event that is fired is an event whose type is the same as the changed\nproperty's name. This event is useful for noticing changes to a specific property.\n\n\n    var o = new Map({});\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log('The value of a changed.');\n    });\n\n\nThe parameters of the event handler for the _property name_ event are:\n\n- _ev_ The event object.\n- _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n- _oldVal_ The value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\nHere is a concrete tour through the _property name_ event handler's arguments:\n\n\n    var o = new Map({});\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log(ev + ', ' + newVal + ', ' + oldVal);\n    });\n\n    o.attr('a', 'Alexis'); // [object Object], Alexis, undefined\n    o.attr('a', 'Adam');   // [object Object], Adam, Alexis\n    o.attr({\n        'a': 'Alice',      // [object Object], Alice, Adam\n        'b': 'Bob'\n    });\n    o.removeAttr('a');     // [object Object], undefined, Alice\n\n\n## See also\n\nMore information about changing properties on Observes can be found under\n[can.Map.prototype.attr attr].\n\nFor a more specific way to changes on Observes, see the [can.Map.delegate] plugin.\n*/\n\n",
    "description": "Bind event handlers to a Map. \n",
    "title": "bind",
    "name": "can-map.prototype.bind",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 3,
    "signatures": [
      {
        "code": "map.bind(eventType, handler)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "the type of event to bind this handler to"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "comment": " "
  },
  "can-map.prototype.DEFAULT-ATTR": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.default-attr.md"
    },
    "body": "\n## Use\n\nWhen extending [can-map], if a prototype property is not a function,\nit is used as a default value on instances of the extended Map.  For example:\n\n```\nvar Paginate = Map.extend({\n    limit: 20,\n    offset: 0,\n    next: function(){\n        this.attr(\"offset\", this.attr(\"offset\")+this.attr(\"limit\"))\n    }\n});\n\nvar paginate = new Paginate({limit: 30});\n\npaginate.attr(\"offset\") //-> 0\npaginate.attr(\"limit\")  //-> 30\n\npaginate.next();\n\npaginate.attr(\"offset\") //-> 30\n```\n\n",
    "description": "Specify a default property and value. \n",
    "types": [
      {
        "type": "*",
        "description": "A value of any type other than a function that will\nbe set as the `DEFAULT-ATTR` attribute's value.\n"
      }
    ],
    "title": "DEFAULT-ATTR",
    "name": "can-map.prototype.DEFAULT-ATTR",
    "type": "property",
    "parent": "can-map.prototype",
    "order": 1,
    "comment": " "
  },
  "can-map.prototype": {
    "name": "can-map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-map",
    "description": "",
    "order": 0
  },
  "can-map.static": {
    "name": "can-map.static",
    "title": "static",
    "type": "group",
    "parent": "can-map",
    "description": "",
    "order": 1
  },
  "can-map.prototype.each": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.each.md"
    },
    "body": "\n    var names = [];\n    new Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n        names.push(value);\n    });\n\n    names; // ['Alice', 'Bob', 'Eve']\n\n    names = [];\n    new Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n        names.push(value);\n        if(key === 'b') {\n            return false;\n        }\n    });\n\n    names; // ['Alice', 'Bob']\n    \n\n",
    "description": "Call a function on each property of a Map. \n",
    "title": "each",
    "name": "can-map.prototype.each",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 5,
    "signatures": [
      {
        "code": "map.each( callback(item, propName ) )",
        "description": "\n\n`each` iterates through the Map, calling a function\nfor each property value and key.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "propName"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "item"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "propName"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "comment": " "
  },
  "can-map.prototype.removeAttr": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.removeAttr.md"
    },
    "body": "`removeAttr` removes a property by name from a Map.\n\n\n    var people = new Map({a: 'Alice', b: 'Bob', e: 'Eve'});\n\n    people.removeAttr('b'); // 'Bob'\n    people.attr();          // {a: 'Alice', e: 'Eve'}\n\n\nRemoving an attribute will cause a _change_ event to fire with `'remove'`\npassed as the _how_ parameter and `undefined` passed as the _newVal_ to\nhandlers. It will also cause a _property name_ event to fire with `undefined`\npassed as _newVal_. An in-depth description at these events can be found\nunder `[can-map.prototype.attr attr]`.\n\n",
    "description": "Remove a property from a Map. \n",
    "title": "removeAttr",
    "name": "can-map.prototype.removeAttr",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 6,
    "signatures": [
      {
        "code": "map.removeAttr(attrName)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "the name of the property to remove"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value of the property that was removed\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "the name of the property to remove"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value of the property that was removed\n"
    },
    "comment": " "
  },
  "can-map.prototype.unbind": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.unbind.md"
    },
    "body": "`unbind` unbinds event handlers previously bound with [can-map.prototype.bind bind].\nIf no _handler_ is passed, all handlers for the given event type will be unbound.\n\n\n    var i = 0,\n        increaseBy2 = function() { i += 2; },\n        increaseBy3 = function() { i += 3; },\n        o = new Map();\n\n    o.bind('change', increaseBy2);\n    o.bind('change', increaseBy3);\n    o.attr('a', 'Alice');\n    i; // 5\n\n    o.unbind('change', increaseBy2);\n    o.attr('b', 'Bob');\n    i; // 8\n\n    o.unbind('change');\n    o.attr('e', 'Eve');\n    i; // 8\n\n",
    "description": "Unbind event handlers from a Map. \n",
    "title": "unbind",
    "name": "can-map.prototype.unbind",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 8,
    "signatures": [
      {
        "code": "map.unbind(eventType[, handler])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "the type of event to unbind, exactly as passed to `bind`"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "handler",
            "description": "the handler to unbind\n\n```js\nvar map = new Map({ a: 1 });\n\nfunction log(){\n\tconsole.log(\"val\", map.attr(\"a\");\n}\n\nmap.bind(\"change\", log);\n\nmap.attr(\"a\", 2);\n\n// Bind callback called.\nmap.unbind(\"change\", log);\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "handler",
      "description": "the handler to unbind\n\n```js\nvar map = new Map({ a: 1 });\n\nfunction log(){\n\tconsole.log(\"val\", map.attr(\"a\");\n}\n\nmap.bind(\"change\", log);\n\nmap.attr(\"a\", 2);\n\n// Bind callback called.\nmap.unbind(\"change\", log);\n```\n"
    },
    "comment": " "
  },
  "can-map.keys": {
    "src": {
      "path": "node_modules/can-map/docs/static.keys.md"
    },
    "body": "",
    "description": "Returns an array of the map's keys. \n",
    "title": "keys",
    "name": "can-map.keys",
    "type": "function",
    "parent": "can-map.static",
    "order": 0,
    "signatures": [
      {
        "code": "Map.keys(map)",
        "description": "\n\n```js\nvar people = new Map({\n\t\ta: 'Alice',\n\t\tb: 'Bob',\n\t\te: 'Eve'\n});\n\nMap.keys(people); // ['a', 'b', 'e']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-map"
              }
            ],
            "name": "map",
            "description": "the `Map` to get the keys from"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "array An array containing the keys from _map_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "name": "map",
      "description": "the `Map` to get the keys from"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "array An array containing the keys from _map_.\n"
    }
  },
  "can-map.prototype.serialize": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.serialize.md"
    },
    "body": "",
    "description": "Serialize this object to something that can be passed to `JSON.stringify`. \n",
    "title": "serialize",
    "name": "can-map.prototype.serialize",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 7,
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n\nGet the serialized Object form of the map.  Serialized\ndata is typically used to send back to a server.\n\n\n    o.serialize() //-> { name: 'Justin' }\n\n\nSerialize currently returns the same data\nas [can.Map.prototype.attrs].  However, in future\nversions, serialize will be able to return serialized\ndata similar to [can.Model].  The following will work:\n\n\n    new Map({time: new Date()})\n        .serialize() //-> { time: 1319666613663 }\n\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a JavaScript Object that can be\nserialized with `JSON.stringify` or other methods.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a JavaScript Object that can be\nserialized with `JSON.stringify` or other methods.\n"
    }
  },
  "can-list.prototype.filter": {
    "src": {
      "path": "node_modules/can-list/docs/filter.md"
    },
    "body": "\nA filter function that accepts a function, which is run on every element of the list.  If the \nfilter callback returns true, the list returned will contain this item, false and it will not.\n\nReturns a new List instance.\n\t\n\tvar list = new List([1, 2, 3])\n\n\t// returns new List([1, 2])\n\tvar filtered = list.filter( function(item, index, list)\n\t{\n\t\treturn item < 3;\n\t}); \n\n",
    "description": "Filter the elements of a List, returning a new List instance with just filtered items. \n",
    "title": "filter",
    "name": "can-list.prototype.filter",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.filter(filterFunc, context)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "Boolean"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can.List"
                      }
                    ],
                    "name": "list"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "filterFunc",
            "description": "A function to call with each element of the list. Returning `false` will remove the index."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "The object to use as `this` inside the callback.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "context",
      "description": "The object to use as `this` inside the callback.\n"
    },
    "comment": " "
  },
  "can-list.prototype": {
    "name": "can-list.prototype",
    "title": "Prototype",
    "type": "group",
    "parent": "can-list",
    "description": "",
    "order": 0
  },
  "can-list.static": {
    "name": "can-list.static",
    "title": "Static",
    "type": "group",
    "parent": "can-list",
    "description": "",
    "order": 1
  },
  "can-list.Map": {
    "src": {
      "path": "node_modules/can-list/docs/Map.md"
    },
    "body": "",
    "description": "Specify the Map type used to make objects added to this list observable. \n",
    "types": [
      {
        "type": "can-map",
        "description": "When objects are added to a `List`, those objects are converted into can.Map instances. For example:\n\n     var list = new List();\n     list.push({name: \"Justin\"});\n\n     var map = list.attr(0);\n     map.attr(\"name\") //-> \"Justin\"\n\nBy changing [can-list.Map], you can specify a different type of Map instance to create. For example:\n\n     var User = Map.extend({\n       fullName: function(){\n         return this.attr(\"first\")+\" \"+this.attr(\"last\")\n       }\n     });\n\n     User.List = List.extend({\n       Map: User\n     }, {});\n\n     var list = new User.List();\n     list.push({first: \"Justin\", last: \"Meyer\"});\n\n     var user = list.attr(0);\n     user.fullName() //-> \"Justin Meyer\"\n"
      }
    ],
    "title": "Map",
    "name": "can-list.Map",
    "type": "property",
    "parent": "can-list.static"
  },
  "can-list.extend": {
    "src": {
      "path": "node_modules/can-list/docs/extend.md"
    },
    "body": "",
    "description": "\n",
    "title": "extend",
    "name": "can-list.extend",
    "type": "function",
    "parent": "can-list.static",
    "signatures": [
      {
        "code": "List.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function. Learn more at [can.Construct.extend].\n\n```js\nvar MyList = List.extend({}, {\n\t// silly unnecessary method\n\tcount: function(){\n\t\treturn this.attr('length');\n\t}\n});\n\nvar list = new MyList([{}, {}]);\nconsole.log(list.count()); // -> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "If provided, adds the extened List constructor function to the window at the given name.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties and methods directly on the constructor function. The most common property to set is [can-list.Map].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "instanceProperties",
            "description": "Properties and methods on instances of this list type.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "instanceProperties",
      "description": "Properties and methods on instances of this list type.\n"
    }
  },
  "can-list.prototype.attr": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.attr.md"
    },
    "body": "\n\n## Use\n\n`attr` gets or sets elements on the `List` it's called on. Here's a tour through how all of its forms work:\n\n     var people = new List(['Alex', 'Bill']);\n\n     // set an element:\n     people.attr(0, 'Adam');\n\n     // get an element:\n     people.attr(0); // 'Adam'\n     people[0]; // 'Adam'\n\n     // get all elements:\n     people.attr(); // ['Adam', 'Bill']\n\n     // extend the array:\n     people.attr(4, 'Charlie');\n     people.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n     // merge the elements:\n     people.attr(['Alice', 'Bob', 'Eve']);\n     people.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']\n\n## Deep properties\n\n`attr` can also set and read deep properties. All you have to do is specify the property name as you normally would if you weren't using `attr`.\n\n```\nvar people = new List([{name: 'Alex'}, {name: 'Bob'}]);\n\n// set a property:\npeople.attr('0.name', 'Alice');\n\n// get a property:\npeople.attr('0.name');  // 'Alice'\npeople[0].attr('name'); // 'Alice'\n\n// get all properties:\npeople.attr(); // [{name: 'Alice'}, {name: 'Bob'}]\n```\n\nThe discussion of deep properties under `[can-map.prototype.attr]` may also be enlightening.\n\n## Events\n\n`List`s emit five types of events in response to changes. They are:\n\n- the _change_ event fires on every change to a List.\n- the _set_ event is fired when an element is set.\n- the _add_ event is fired when an element is added to the List.\n- the _remove_ event is fired when an element is removed from the List.\n- the _length_ event is fired when the length of the List changes.\n\n### The _change_ event\n\nThe first event that is fired is the _change_ event. The _change_ event is useful\nif you want to react to all changes on an List.\n\n```\nvar list = new List([]);\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log('Something changed.');\n});\n```\n\nThe parameters of the event handler for the _change_ event are:\n\n- _ev_ The event object.\n- _index_ Where the change took place.\n- _how_ Whether elements were added, removed, or set.\n Possible values are `'add'`, `'remove'`, or `'set'`.\n- _newVal_ The elements affected after the change\n _newVal_ will be a single value when an index is set, an Array when elements\nwere added, and `undefined` if elements were removed.\n- _oldVal_ The elements affected before the change.\n_newVal_ will be a single value when an index is set, an Array when elements\nwere removed, and `undefined` if elements were added.\n\nHere is a concrete tour through the _change_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\nlist.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined\nlist.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined\nlist.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis\nlist.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam\n                               // [object Object], 1, set, Bob, Bill\nlist.removeAttr(1);            // [object Object], 1, remove, undefined, Bob\n```\n\n### The _set_ event\n\n_set_ events are fired when an element at an index that already exists in the List is modified. Actions can cause _set_ events to fire never also cause _length_ events to fire (although some functions, such as `[can-list.prototype.splice splice]` may cause unrelated sets of events to fire after being batched).\n\nThe parameters of the event handler for the _set_ event are:\n\n- _ev_ The event object.\n- _newVal_ The new value of the element.\n- _index_ where the set took place.\n\nHere is a concrete tour through the _set_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('set', function(ev, newVal, index) {\n    console.log(newVal + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');\nlist.attr(0, 'Adam');          // Adam, 0\nlist.attr(['Alice', 'Bob']);   // Alice, 0\n                               // Bob, 1\nlist.removeAttr(1);\n```\n\n### The _add_ event\n\n_add_ events are fired when elements are added or inserted\ninto the List.\n\nThe parameters of the event handler for the _add_ event are:\n\n- _ev_ The event object.\n- _newElements_ The new elements.\n If more than one element is added, _newElements_ will be an array. Otherwise, it is simply the new element itself.\n- _index_ Where the add or insert took place.\n\nHere is a concrete tour through the _add_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('add', function(ev, newElements, index) {\n    console.log(newElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0\nlist.attr(2, 'Eve');           // Eve, 2\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);\n```\n\n### The _remove_ event\n\n_remove_ events are fired when elements are removed from the list.\n\nThe parameters of the event handler for the _remove_ event are:\n\n- _ev_ The event object.\n- _removedElements_ The removed elements.\n If more than one element was removed, _removedElements_ will be an array. Otherwise, it is simply the element itself.\n- _index_ Where the removal took place.\n\nHere is a concrete tour through the _remove_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('remove', function(ev, removedElements, index) {\n    console.log(removedElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);            // Bob, 1\n```\n\n### The _length_ event\n\n_length_ events are fired whenever the list changes.\n\nThe parameters of the event handler for the _length_ event are:\n\n- _ev_ The event object.\n- _length_ The current length of the list.\n If events were batched when the _length_ event was triggered, _length_ will have the length of the list when `stopBatch` was called. Because of this, you may receive multiple _length_ events with the same _length_ parameter.\n\nHere is a concrete tour through the _length_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('length', function(ev, length) {\n    console.log(length);\n});\n\nlist.attr(['Alexis', 'Bill']); // 2\nlist.attr(2, 'Eve');           // 3\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);            // 2\n```\n\n",
    "description": "Get or set elements in a List. \n",
    "title": "attr",
    "name": "can-list.prototype.attr",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.attr()",
        "description": "\n\nGets an array of all the elements in this `List`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "An array with all the elements in this List.\n"
        }
      },
      {
        "code": "list.attr(index)",
        "description": "\n\nReads an element from this `List`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The element to read."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at _index_.\n"
        }
      },
      {
        "code": "list.attr(index, value)",
        "description": "\n\nAssigns _value_ to the index _index_ on this `List`, expanding the list if necessary.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The element to set."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign at _index_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      },
      {
        "code": "list.attr(elements[, replaceCompletely])",
        "description": "\n\nMerges the members of _elements_ into this List, replacing each from the beginning in order. If _elements_ is longer than the current List, the current List will be expanded. If _elements_ is shorter than the current List, the extra existing members are not affected (unless _replaceCompletely_ is `true`). To remove elements without replacing them, use `[can-map::removeAttr removeAttr]`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "elements",
            "description": "An array of elements to merge in.\n"
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "replaceCompletely",
            "defaultValue": "false",
            "description": "whether to completely replace the elements of List\n\nIf _replaceCompletely_ is `true` and _elements_ is shorter than the List, the existing extra members of the List will be removed.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "This list, for chaining.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "replaceCompletely",
      "defaultValue": "false",
      "description": "whether to completely replace the elements of List\n\nIf _replaceCompletely_ is `true` and _elements_ is shorter than the List, the existing extra members of the List will be removed.\n"
    },
    "comment": " "
  },
  "can-list.prototype.each": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.each.md"
    },
    "body": "```\nvar i = 0;\nnew List([1, 10, 100]).each(function(element, index) {\n    i += element;\n});\n\ni; // 111\n\ni = 0;\nnew List([1, 10, 100]).each(function(element, index) {\n    i += element;\n    if(index >= 1) {\n        return false;\n    }\n});\n\ni; // 11\n```\n\n",
    "description": "Call a function on each element of a List. ",
    "name": "can-list.prototype.each",
    "title": "each",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.each( callback(item, index) )",
        "description": "\n\n`each` iterates through the List, calling a function\nfor each element.\n\n```js\nvar list = new List([1, 2, 3]);\n\nlist.each(function(elem){\n\tconsole.log(elem);\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "this List, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "this List, for chaining\n"
    },
    "comment": " "
  },
  "can-list.prototype.splice": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.splice.md"
    },
    "body": " `splice` lets you remove elements from and insert elements into a List.\n\n This example demonstrates how to do surgery on a list of numbers:\n\n```\n var list = new List([0, 1, 2, 3]);\n\n // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n list.splice(2, 1, 'Alice', 'Bob');\n list.attr(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n ## Events\n\n `splice` causes the List it's called on to emit _change_ events,\n _add_ events, _remove_ events, and _length_ events. If there are\n any elements to remove, a _change_ event, a _remove_ event, and a\n _length_ event will be fired. If there are any elements to insert, a\n separate _change_ event, an _add_ event, and a separate _length_ event\n will be fired.\n\n This slightly-modified version of the above example should help\n make it clear how `splice` causes events to be emitted:\n\n```\n var list = new List(['a', 'b', 'c', 'd']);\n list.bind('change', function(ev, attr, how, newVals, oldVals) {\n     console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n });\n list.bind('add', function(ev, newVals, where) {\n     console.log('add: ' + newVals + ', ' + where);\n });\n list.bind('remove', function(ev, oldVals, where) {\n     console.log('remove: ' + oldVals + ', ' + where);\n });\n list.bind('length', function(ev, length) {\n     console.log('length: ' + length + ', ' + this.attr());\n });\n\n // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n list.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                    // remove: ['c'], 2\n                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                    // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                    // add: ['Alice', 'Bob'], 2\n                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n```\n\n More information about binding to these events can be found under [can.List.attr attr].\n\n",
    "description": "Insert and remove elements from a List. ",
    "title": "splice",
    "name": "can-list.prototype.splice",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newElements]])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "where to start removing or inserting elements\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "the number of elements to remove\n If _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the List.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newElements",
            "description": "elements to insert into the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the elements removed by `splice`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newElements",
      "description": "elements to insert into the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the elements removed by `splice`\n"
    },
    "comment": " "
  },
  "can-list.prototype.map": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.map.md"
    },
    "body": "```\nvar list = new List([1, 10, 100, 1000, 10000, 100000]);\nvar newList = list.map(function(element, index, listReference) {\n  var result;\n\n  switch(index) {\n    case 0: {\n      result = false;\n      break;\n    }\n    case 1: {\n      result = undefined;\n      break;\n    }\n    case 2: {\n      result = element;\n      break;\n    }\n    case 3: {\n      result = element * 5;\n      break;\n    }\n    default: {\n      result = listReference[index] /= 2;\n      break;\n    }\n  }\n\n  return result;\n});\n\nconsole.log(list);    // [    1,        10, 100, 1000, 5000, 50000]\nconsole.log(newList); // [false, undefined, 100, 5000, 5000, 50000]\n```\n\n",
    "description": "Call a function on each element of a List and return a new List instance from the results. ",
    "title": "map",
    "name": "can-list.prototype.map",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.map( callback(item, index, listReference), context )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can.List"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each\nelement of the list."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "An optional object to use as `this` inside the callback.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "A new can.List instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "context",
      "description": "An optional object to use as `this` inside the callback.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "A new can.List instance.\n"
    },
    "comment": " "
  },
  "can-log/dev": {
    "name": "can-log/dev",
    "type": "module",
    "parent": "can-log",
    "src": {
      "line": 4,
      "codeLine": 13,
      "path": "node_modules/can-log/dev/dev.js"
    },
    "body": "\n",
    "description": "\nUtilities for logging development-mode messages. Use this module for\nanything that should be shown to the user during development but isn't\nneeded in production. In production these functions become noops.\n",
    "title": "dev",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "hide": true
  },
  "can-log/dev.stringify": {
    "type": "function",
    "name": "can-log/dev.stringify",
    "parent": "can-log",
    "src": {
      "line": 16,
      "codeLine": 36,
      "path": "node_modules/can-log/dev/dev.js"
    },
    "body": "",
    "description": " \nJSON stringifies a value, but unlike JSON, will output properties with\na value of `undefined` (e.g. `{ \"prop\": undefined }`, not `{}`).\n\n```\nvar dev = require('can-log/dev');\nvar query = { where: undefined };\n\ndev.warn('No records found: ' + dev.stringify(query));\n```\n\n",
    "title": "stringify",
    "hide": true,
    "signatures": [
      {
        "code": "dev.stringify(value)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Any"
              }
            ],
            "name": "value",
            "description": "A value to stringify."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A stringified representation of the passed in value.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Any"
        }
      ],
      "name": "value",
      "description": "A value to stringify."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A stringified representation of the passed in value.\n "
    }
  },
  "can-log/dev.warn": {
    "type": "function",
    "name": "can-log/dev.warn",
    "parent": "can-log",
    "src": {
      "line": 45,
      "codeLine": 62,
      "path": "node_modules/can-log/dev/dev.js"
    },
    "body": "",
    "description": " \nAdds a warning message to the console.\n\n```\nvar dev = require('can-log/dev');\n\ndev.warn(\"something evil\");\n```\n\n",
    "title": "warn",
    "hide": true,
    "signatures": [
      {
        "code": "dev.warn(msg)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "msg",
            "description": "The warning message.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "msg",
      "description": "The warning message.\n "
    }
  },
  "can-log/dev.log": {
    "type": "function",
    "name": "can-log/dev.log",
    "parent": "can-log",
    "src": {
      "line": 67,
      "codeLine": 84,
      "path": "node_modules/can-log/dev/dev.js"
    },
    "body": "",
    "description": " \nAdds a message to the console.\n\n```\nvar dev = require('can-log/dev');\n\ndev.log(\"hi\");\n```\n\n",
    "title": "log",
    "hide": true,
    "signatures": [
      {
        "code": "dev.log(msg)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "msg",
            "description": "The message.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "msg",
      "description": "The message.\n "
    }
  },
  "can-log/dev.error": {
    "type": "function",
    "name": "can-log/dev.error",
    "parent": "can-log",
    "src": {
      "line": 89,
      "codeLine": 106,
      "path": "node_modules/can-log/dev/dev.js"
    },
    "body": "",
    "description": " \nAdds an error message to the console.\n\n```\nvar dev = require(\"can-log/dev\");\n\ndev.error(new Error(\"Oh no!\"));\n```\n\n",
    "title": "error",
    "hide": true,
    "signatures": [
      {
        "code": "dev.error(err)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Error"
              }
            ],
            "name": "err",
            "description": "The error to be logged.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Error"
        }
      ],
      "name": "err",
      "description": "The error to be logged.\n "
    }
  },
  "can-map-define.TypeConstructor": {
    "src": {
      "path": "node_modules/can-map-define/docs/TypeConstructor.md"
    },
    "body": "\n\n\nSimilar to [can-map-define._type type], this uppercase version provides a mechanism for converting incoming values to another format or type.\n\nSpecifically, this constructor will be invoked any time this property is set, and any data passed into the setter will be passed as arguments for the constructor.\n\nIf the call to attr passes an object that is already an instance of the constructor specified with `Type`, no conversion is done.\n\n",
    "description": "\nProvides a constructor function to be used to convert any value passed into [can-map.prototype.attr attr] into an appropriate value\n",
    "title": "Type",
    "name": "can-map-define.TypeConstructor",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "constructorFunc",
        "description": "\n\nA constructor function can be provided that is called to convert incoming values set on this property, like:\n\n    define: {\n      prop: {\n        Type: Person\n      }\n    }\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-map-define.ValueConstructor": {
    "src": {
      "path": "node_modules/can-map-define/docs/ValueConstructor.md"
    },
    "body": "\n\nSimilar to [can-map-define.value value], this uppercase version provides a mechanism for providing a default value.  If the default value is an object, providing a constructor is a good way to ensure a copy is made for each instance.\n\n",
    "description": "\nProvides a constructor function to be used to provide a default value for a certain property of a [can-map Map].  This constructor will be invoked with `new` each time a new instance of the map is created.\n",
    "title": "Value",
    "name": "can-map-define.ValueConstructor",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "constructorFunc",
        "description": "\n\nA constructor function can be provided that is called to create a default value used for this property, like:\n\n    define: {\n      prop: {\n        Value: Array\n      },\n      person: {\n      \tValue: Person\n      }\n    }\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-map-define.attrDefinition": {
    "src": {
      "path": "node_modules/can-map-define/docs/attrDefinition.md"
    },
    "body": "\n",
    "description": "\nDefines the type, initial value, and get, set, and remove behavior for an attribute of a [can-map Map].\n",
    "type": "typedef",
    "title": "attribute definition",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "value",
            "description": "Specifies the initial value of the attribute or\na function that returns the initial value. For example, a default value of `0` can be\nspecified like:\n\n    define: {\n      prop: {\n        value: 0\n      }\n    }\n\n`Object` types should not be specified directly on `value` because that same object will\nbe shared on every instance of the Map.  Instead, a [can-map-define.value value function] that\nreturns a fresh copy can be provided:\n\n    define: {\n      prop: {\n        value: function(){\n          return {foo: \"bar\"}\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.value"
              },
              {
                "type": "*"
              }
            ]
          },
          {
            "name": "Value",
            "description": "Specifies a function that will be called with `new` whose result is\nset as the initial value of the attribute. For example, if the default value should be a [can-list List]:\n\n    define: {\n      prop: {\n        Value: Map.List\n      }\n    }\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "type",
            "description": "Specifies the type of the\nattribute.  The type can be specified as either a [can-map-define._type type function]\nthat returns the type coerced value or one of the following strings:\n\n - `\"string\"` - Converts the value to a string.\n - `\"date\"` - Converts the value to a date or `null if the date can not be converted.\n - `\"number\"` - Passes the value through `parseFloat`.\n - `\"boolean\"` - Converts falsey, `\"false\"` or `\"0\"` to `false` and everything else to true.\n - `\"*\"` - Prevents the default type coersion of converting Objects to [can-map Map]s and Arrays to [can-list List]s.\n\nThe following example converts the `count` property to a number and the `items` property to an array:\n\n     define: {\n       count: {type: \"number\"},\n       items: {\n         type: function(newValue){\n           if(typeof newValue === \"string\") {\n             return newValue.split(\",\")\n           } else if( Array.isArray(newValue) ) {\n             return newValue;\n           }\n         }\n       }\n     }\n",
            "types": [
              {
                "type": "can-map-define._type"
              },
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "Type",
            "description": "A constructor function that takes\nthe value passed to [can-map.prototype.attr attr] as the first argument and called with\nnew. For example, if you want whatever\ngets passed to go through `new Array(newValue)` you can do that like:\n\n    define: {\n      items: {\n        Type: Array\n      }\n    }\n\nIf the value passed to [can-map.prototype.attr attr] is already an Array, it will be left as is.\n",
            "types": [
              {
                "type": "can-map-define.TypeConstructor"
              }
            ]
          },
          {
            "name": "set",
            "description": "A set function that specifies what should happen when an attribute\nis set on a [can-map]. `set` is called with the result of `type` or `Type`. The following\ndefines a `page` setter that updates the map's offset:\n\n    define: {\n      page: {\n        set: function(newVal){\n          this.attr('offset', (parseInt(newVal) - 1) *\n                               this.attr('limit'));\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.set"
              }
            ]
          },
          {
            "name": "get",
            "description": "A function that specifies how the value is retrieved.  The get function is\nconverted to an [can-compute.async async compute].  It should derive its value from other values\non the map. The following\ndefines a `page` getter that reads from a map's offset and limit:\n\n    define: {\n      page: {\n        get: function (newVal) {\n\t\t  return Math.floor(this.attr('offset') /\n\t\t                    this.attr('limit')) + 1;\n\t\t}\n      }\n    }\n\nA `get` definition makes the property __computed__ which means it will not be serialized by default.\n",
            "types": [
              {
                "type": "can-map-define.get"
              }
            ]
          },
          {
            "name": "remove",
            "description": "A function that specifies what should happen when an attribute is removed\nwith [can-map.prototype.removeAttr removeAttr]. The following removes a `modelId` when `makeId` is removed:\n\n    define: {\n      makeId: {\n        remove: function(){\n          this.removeAttr(\"modelId\");\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.remove"
              }
            ]
          },
          {
            "name": "serialize",
            "description": "Specifies the behavior of the\nproperty when [can-map.prototype.serialize serialize] is called.\n\nBy default, serialize does not include computed values. Properties with a `get` definition\nare computed and therefore are not added to the result.  Non-computed properties values are\nserialized if possible and added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        pageNum: {\n          get: function(){ return this.offset() / 20 }\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 40}\n\nIf `true` is specified, computed properties will be serialized and added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        pageNum: {\n          get: function(){ return this.offset() / 20 },\n          serialize: true\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 40, pageNum: 2}\n\n\nIf `false` is specified, non-computed properties will not be added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        offset: {\n          serialize: false\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {}\n\nIf a [can-map-define.serialize serialize function] is specified, the result\nof the function is added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        offset: {\n          serialize: function(offset){\n            return (offset / 20)+1\n          }\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 3}\n",
            "types": [
              {
                "type": "can-map-define.serialize"
              },
              {
                "type": "Boolean"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-map-define.attrDefinition",
    "parent": "can-map-define"
  },
  "can-map-define": {
    "src": {
      "path": "node_modules/can-map-define/docs/define.md"
    },
    "body": "\n\n## Use\n\nThe [can-map-define define] plugin allows you to completely control the behavior\nof attributes on a [can-map Map]. To use it, you specify\nan `define` object that is a mapping of properties\nto [can-map-define.attrDefinition attribute definitions]. The following example\nspecifies a Paginate Map:\n\n    var Paginate = Map.extend({\n      define: {\n        count: {\n          type: \"number\",\n          value: Infinity,\n          // Keeps count above 0.\n          set: function(newCount){\n            return newCount < 0 ? 0 : newCount;\n          }\n        },\n        offset: {\n          type: \"number\",\n          value: 0,\n          // Keeps offset between 0 and count\n          set: function(newOffset){\n            var count = this.attr(\"count\");\n            return newOffset < 0 ?\n\t\t      0 :\n\t\t      Math.min(newOffset, !isNaN( count - 1) ?\n\t\t        count - 1 :\n\t\t        Infinity);\n          }\n        },\n        limit: {\n          type: \"number\",\n          value: 5\n        },\n        page: {\n          // Setting page changes the offset\n          set: function(newVal){\n            this.attr('offset', (parseInt(newVal) - 1) *\n                                 this.attr('limit'));\n          },\n          // The page value is derived from offset and limit.\n          get: function (newVal) {\n\t\t    return Math.floor(this.attr('offset') /\n\t\t                      this.attr('limit')) + 1;\n\t\t  }\n        }\n      }\n    });\n\n## Default behaviors\n\nThe [can-map-define define] plugin not only allows you to define\nindividual attribute behaviors on a [can-map Map], but you can also define default\nbehaviors that would apply to any unspecified attribute. This is particularly\nhelpful for when you need a particular behavior to apply to every attribute on\na [can-map Map] but won't be certain of what every attribute will be.\n\nThe following example is a [can-map Map] that is tied to [can-route route] where only\nspecified attributes that are serialized will be updated in the location hash:\n\n    var State = Map.extend({\n      define: {\n        foo: {\n          serialize: true\n        },\n        '*': {\n          serialize: false\n        }\n      }\n    });\n\n    var state = new State();\n\n    // tie State map to the route\n    route.map(state);\n    route.ready();\n\n    state.attr('foo', 'bar');\n    state.attr('bar', 'baz');\n\n    window.location.hash; // -> #!foo=bar\n\n\n## Overview\n\nThis plugin is a replacement for the now deprecated attributes and setter plugins. It intends to provide a single place to define the behavior of all the properties of a [can-map Map].\n\nHere is the cliffnotes version of this plugin.  To define...\n\n* The default value for a property - use [can-map-define.value value]\n* That default value as a constructor function - use [can-map-define.ValueConstructor Value]\n* What value is returned when a property is read - use [can-map-define.get get]\n* Behavior when a property is set - use [can-map-define.set set]\n* How a property is serialized when [can-map.prototype.serialize serialize] is called on it - use [can-map-define.serialize serialize]\n* Behavior when a property is removed - use [can-map-define.remove remove]\n* A custom converter method or a pre-defined standard converter called whenever a property is set - use [can-map-define._type type]\n* That custom converter method as a constructor function - use [can-map-define.TypeConstructor Type]\n\n## Demo\n\nThe following shows picking cars by make / model / year:\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-map-define/make-model-year.html'></div>\n\n",
    "description": "\nDefines the\n`type`, initial `value`, `get`, `set`, `remove`, and `serialize` behavior for attributes\nof a [can-map Map].\n",
    "type": "module",
    "title": "can-map-define",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "define",
            "description": "Exports object with helper methods internal to\n`can-map-define`.  The export of `can-map-define` is not used directly, instead\nthe module is imported and all [can-map]'s can have their properties defined like:\n\n```js\nvar CanMap = require(\"can-map\");\nrequire(\"can-map-define\");\n\nvar Person = CanMap.extend({\n    define: {\n        fullName: function(){\n            return this.attr(\"first\") + \" \"+ this.attr(\"last\")\n        }\n    }\n})\n```\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can-map-define",
    "parent": "can-observables",
    "collection": "can-legacy",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-map-define/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.1.0",
        "can-event": "^3.5.0",
        "can-list": "^3.1.0",
        "can-map": "^3.1.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Define rich attribute behavior",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-component": "^3.1.0",
        "can-route": "^3.1.0",
        "can-stache": "^3.1.0",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^0.2.5",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^1.0.7",
        "jshint": "^2.9.4",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs"
      ],
      "main": "can-map-define",
      "name": "can-map-define",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-map-define.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-map-define"
      },
      "version": "3.1.1"
    },
    "comment": " "
  },
  "can-map-define.get": {
    "src": {
      "path": "node_modules/can-map-define/docs/get.md"
    },
    "body": "\n\n\n## Use\n\nGetter methods are useful for:\n\n - Defining virtual properties on a map.\n - Defining property values that change with their _internal_ set value. \n \n## Virtual properties\n\n\nVirtual properties are properties that don't actually store any value, but derive their value \nfrom some other properties on the map.\n\nWhenever a getter is provided, it is wrapped in a [can-compute compute], which ensures \nthat whenever its dependent properties change, a change event will fire for this property also.\n\n```\nvar Person = Model.extend({\n\tdefine: {\n\t\tfullName: {\n\t\t\tget: function () {\n\t\t\t\treturn this.attr(\"first\") + \" \" + this.attr(\"last\");\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar p = new Person({first: \"Justin\", last: \"Meyer\"});\n\np.attr(\"fullName\"); // \"Justin Meyer\"\n\np.bind(\"fullName\", function(ev, newVal){\n  newVal //-> \"Lincoln Meyer\";\n});\n\np.attr(\"first\",\"Lincoln\");\n```\n\n## Asyncronous virtual properties\n\nOften, a virtual property's value only becomes available after some period of time.  For example,\ngiven a `personId`, one might want to retrieve a related person:\n\n```\nvar AppState = Map.extend({\n  define: {\n    person: {\n      get: function(lastSetValue, setAttrValue){\n        Person.findOne({id: this.attr(\"personId\")})\n        \t.then(function(person){\n        \t\tsetAttrValue(person);\n        \t});\n      }\n    }\n  }\n});\n```\n\nAsyncronous properties should be bound to before reading their value.  If \nthey are not bound to, the `get` function will be called each time.\n\nThe following example will make multiple `Person.findOne` requests: \n\n```\nvar state = new AppState({personId: 5});\nstate.attr(\"person\") //-> undefined\n\n// called sometime later ...\nstate.attr(\"person\") //-> undefined\n```\n\nHowever, by binding, the compute only reruns the `get` function once `personId` changes:\n\n```\nvar state = new AppState({personId: 5});\n\nstate.bind(\"person\", function(){})\n\nstate.attr(\"person\") //-> undefined\n\n// called sometime later\nstate.attr(\"person\") //-> Person<{id: 5}>\n```\n\nA template like [can-stache stache] will automatically bind for you, so you can pass\n`state` to the template like the following without binding:\n\n```\nvar template = stache(\"<span>{{person.fullName}}</span>\");\nvar state = new AppState({});\nvar frag = template(state);\n\nstate.attr(\"personId\",5);\nfrag.childNodes[0].innerHTML //=> \"\"\n\n// sometime later\nfrag.childNodes[0].innerHTML //=> \"Lincoln Meyer\"\n\n```\n\nThe magic tags are updated as `personId`, `person`, and `fullName` change.\n\n\n## Properties values that change with their _internal_ set value \n\nA getter can be used to derive a value from a set value. A getter's\n`lastSetValue` argument is the last value set by [can-map.prototype.attr attr]. \n\nFor example, a property might be set to a compute, but when read, provides the value\nof the compute.\n\n```\nvar MyMap = Map.extend({\n  define: {\n    value: {\n      get: function( lastSetValue ){\n        return lastSetValue();\n      }\n    }\n  }\n});\n\nvar map = new MyMap();\nvar compute = can.compute(1);\nmap.attr(\"value\", compute);\n\nmap.attr(\"value\") //-> 1\ncompute(2);\nmap.attr(\"value\") //-> 2\n```\n\nThis technique should only be used when the `lastSetValue` is some form of\nobservable, that when it changes, can update the `getter` value.\n\nFor simple conversions, [can-map-define.set set] or [can-map-define._type type] should be used.\n\n## Updating the virtual property value\n\nIt's very common (and better performing) to update the virtual property value \ninstead of replacing it. \n\nThe following example creates an empty `locationIds` [can-list List] when a new\ninstance of `Store` is created.  However, as `locations` change,\nthe [can-list List] will be updated with the `id`s of the `locations`.\n\n\n```\nvar Store = Map.extend({\n\tdefine: {\n\t\tlocationIds: {\n\t\t\tValue: Map.List,\n\t\t\tget: function(initialValue){\n\t\t\t\tvar ids = [];\n\t\t\t\tthis.attr('locations').each(function(location){\n\t\t\t\t\tids.push(location.attr(\"id\"));\n\t\t\t\t});\n\t\t\t\treturn initialValue.replace(ids);\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n",
    "description": "\nSpecify what happens when a certain property is read on a map. `get` functions\nwork like a [can-compute compute] and automatically update themselves when a dependent\nobservable value is changed.\n",
    "title": "get",
    "name": "can-map-define.get",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "get( [lastSetValue] )",
        "description": "\n\n  Defines the behavior when a value is read on a [can-map Map]. Used to provide properties that derive their value from \n  other properties of the map, or __update__ their value from \n  the changes in the value that was set. \n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The value last set by `.attr(property, value)`.  Typically, _lastSetValue_ \nshould be an observable value, like a [can-compute compute] or promise. If it's not, it's likely \nthat a [can-map-define.set define.set] should be used instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property.\n"
        }
      },
      {
        "code": "get( lastSetValue, setAttrValue(value) )",
        "description": "\n\n  Asynchronously defines the behavior when a value is read on a [can-map Map]. Used to provide property values that\n  are available asynchronously. \n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "lastSetValue",
            "description": "The value last set by `.attr(property, value)`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "value"
                  }
                ]
              }
            ],
            "name": "setAttrValue",
            "description": "Updates the value of the property. This can be called\nmultiple times if needed.\n "
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of the property.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "value"
            }
          ]
        }
      ],
      "name": "setAttrValue",
      "description": "Updates the value of the property. This can be called\nmultiple times if needed.\n "
    },
    "comment": " "
  },
  "can-map-define.remove": {
    "src": {
      "path": "node_modules/can-map-define/docs/remove.md"
    },
    "body": "\n\n## Use\n\nThe following prevents removing the _prop_ attribute if someone tries to remove the value 0:\n\n\n    define: {\n      prop: {\n        remove: function( currentVal ){\n          return currentVal !== 0;\n        }\n      }\n    }\n\n\n",
    "description": "\nCalled when an attribute is removed.\n",
    "title": "remove",
    "name": "can-map-define.remove",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "remove( currentValue )",
        "description": "\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "false"
            }
          ],
          "description": "If `false` is returned, the value is not removed.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "false"
        }
      ],
      "description": "If `false` is returned, the value is not removed.\n"
    },
    "comment": " "
  },
  "can-map-define.serialize": {
    "src": {
      "path": "node_modules/can-map-define/docs/serialize.md"
    },
    "body": "\n\n## Use\n\n[can-map.prototype.serialize serialize] is useful for serializing a Map instance into \na more JSON-friendly form.  This can be used for many reasons, including saving a \n[can-model Model] instance on the server or serializing [can-route route]'s internal \nMap for display in the hash or pushstate URL.\n\nThe serialize property allows an opportunity to define how \neach attribute will behave when the map is serialized.  This can be useful for:\n\n- serializing complex types like dates, arrays, or objects into string formats\n- causing certain properties to be ignored when serialize is called\n\nThe following causes a locationIds property to be serialized into \nthe comma separated ID values of the location property on this map:\n\n    define: {\n      locationIds: {\n        serialize: function(){\n\t\t  var ids = [];\n\t\t  this.attr('locations').each(function(location){\n\t\t    ids.push(location.id);\n\t\t  });\n\t\t  return ids.join(',');\n        }\n      }\n    }\n\nReturning `undefined` for any property means this property will not be part of the serialized \nobject.  For example, if the property numPages is not greater than zero, the following example \nwon't include it in the serialized object.\n\n    define: {\n      prop: {\n        numPages: function( num ){\n          if(num <= 0) {\n          \treturn undefined;\n          }\n          return num;\n        }\n      }\n    }\n\n",
    "description": "\nCalled when an attribute is removed.\n",
    "title": "serialize",
    "name": "can-map-define.serialize",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "serialize( currentValue )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The current value of the attribute. \n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attr",
            "description": "The name of the attribute being serialized.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If `undefined` is returned, the value is not serialized.\n"
        },
        "context": {
          "types": [
            {
              "type": "Map"
            }
          ],
          "description": "The map instance being serialized.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attr",
      "description": "The name of the attribute being serialized.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If `undefined` is returned, the value is not serialized.\n"
    },
    "comment": " "
  },
  "can-map-define._type": {
    "src": {
      "path": "node_modules/can-map-define/docs/type.md"
    },
    "body": "\n\n## Use\n\nThe `type` property specifies the type of the attribute.  The type can be specified\nas either a type function that returns the type coerced value or one of the following strings:\n\n - `\"string\"` - Converts the value to a string except `null` or `undefined`.\n - `\"date\"` - Converts the value to a date or `null` if the date can not be converted.\n - `\"number\"` - Passes the value through `parseFloat` except for `null` or `undefined`.\n - `\"boolean\"` - Converts falsey, `\"false\"` or `\"0\"` to `false` and everything else to true.\n - `\"htmlbool\"` - Like `boolean`, but also converts empty strings to\n   `true`. Used, for example, when input is from component attributes like\n   `<can-tabs reverse/>`\n - `\"compute\"` - If the value set is a compute, will allow the returning of the computed value.\n - `\"*\"` - Prevents the default type coersion of converting Objects to [can-map Map]s and Arrays to [can-list List]s.\n\n### Basic Example\n\nThe following example converts the `count` property to a number and the `items` property to an array:\n\n     define: {\n       count: {type: \"number\"},\n       items: {\n         type: function(newValue){\n           if(typeof newValue === \"string\") {\n             return newValue.split(\",\")\n           } else if( Array.isArray(newValue) ) {\n             return newValue;\n           }\n         }\n       }\n     }\n\nWhen a user tries to set those properties like:\n\n    map.attr({count: \"4\", items: \"1,2,3\"});\n\nThe number converter will be used to turn count into 4, and the items type converter function will be used to turn items into [1,2,3].\n\n### Preventing Arrays and Objects from Automatic Conversion\n\nWhen an array is passed into a Map setter, it is automatically converted into a List. Likewise, objects are converted into Map instances. This behavior can be prevented like the following:\n\n     define: {\n       locations: {type: \"*\"}\n     }\n\nWhen a user tries to set this property, the resulting value will remain an array.\n\n    map.attr('locations', [1, 2, 3]); // locations is an array, not a List\n\n### Working with the 'compute' type\n\nSetting type as [can-compute `compute`] allows for resolving a computed property with the .attr()\nmethod.\n\n```js\nMyMap = Map.extend({\n  define: {\n    value: {\n      type: \"compute\"\n    }\n  }\n});\n\nvar myMap = new MyMap();\nvar c = compute(5);\n\nmyMap.attr(\"value\",c);\nmyMap.attr(\"value\"); //-> 5\n\nc(6);\nmyMap.attr(\"value\"); //-> 6\n\n//Be sure if setting to pass the new compute\nvar c2 = compute(\"a\");\nmyMap.attr(\"value\",c2);\nmyMap.attr(\"value\"); //-> \"a\"\n```\n\n",
    "description": "\nConverts a value passed to [can-map.prototype.attr attr] into an appropriate value.\n",
    "title": "type",
    "name": "can-map-define._type",
    "type": "function",
    "parent": "can-map-define",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "newValue",
        "description": "The value passed to `attr`."
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "attrName",
        "description": "The attribute name being set."
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The attribute name being set."
    },
    "context": {
      "types": [
        {
          "type": "Map"
        }
      ],
      "description": "the instance of the [can-map Map]."
    },
    "returns": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
    },
    "comment": " "
  },
  "can-map-define.value": {
    "src": {
      "path": "node_modules/can-map-define/docs/value.md"
    },
    "body": "\n\nThere is a third way to provide a default value, which is explained in the [can-map-define.ValueConstructor Value] docs page. `value` lowercased is for providing default values for a property type, while `Value` uppercased is for providing a constructor function, which will be invoked with `new` to create a default value for each instance of this map.\n\n",
    "description": "\nReturns the default value for instances of this [can-map Map].  This is called before `init`.\n",
    "title": "value",
    "name": "can-map-define.value",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "defaulter()",
        "description": "\n\nA function can be provided that returns the default value used for this property, like:\n\n    define: {\n      prop: {\n        value: function(){ return []; }\n      }\n    }\n\nIf the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property `value` above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).\n",
        "params": [],
        "context": {
          "types": [
            {
              "type": "Map"
            }
          ],
          "description": "the instance of the [can-map Map].\n"
        },
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The default value.  This will be passed through setter and type.\n"
        }
      },
      {
        "code": "defaulVal",
        "description": "\n\nAny value can be provided as the default value used for this property, like:\n\n    define: {\n      prop: {\n        value: 'foo'\n      }\n    }\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "defaultVal",
            "description": "The default value, which will be passed through setter and type.\n"
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The default value.  This will be passed through setter and type.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "defaultVal",
      "description": "The default value, which will be passed through setter and type.\n"
    },
    "comment": " "
  },
  "can-map-define.set": {
    "src": {
      "path": "node_modules/can-map-define/docs/set.md"
    },
    "body": "\n\n## Use\n\nAn attribute's `set` function can be used to customize the behavior of when an attribute value is set\nvia [can-map.prototype.attr `.attr()`].  Lets see some common cases:\n\n#### Side effects\n\nThe following makes setting a `page` property update the `offset`:\n\n    define: {\n      page: {\n        set: function(newVal){\n          this.attr('offset', (parseInt(newVal) - 1) *\n                               this.attr('limit'));\n        }\n      }\n    }\n\nThe following makes changing `makeId` remove the `modelId` property:\n\n    define: {\n      makeId: {\n        set: function(newValue){\n          // Check if we are changing.\n          if(newValue !== this.attr(\"makeId\")) {\n            this.removeAttr(\"modelId\");\n          }\n          // Must return value to set as we have a `newValue` argument.\n          return newValue;\n        }\n      }\n    }\n\n#### Asynchronous Setter\n\nThe following shows an async setter:\n\n    define: {\n      prop: {\n        set: function( newVal, setVal){\n          $.get(\"/something\", {}, setVal );\n        }\n      }\n    }\n\n\n## Behavior depends on the number of arguments.\n\nWhen a setter returns `undefined`, its behavior changes depending on the number of arguments.\n\nWith 0 arguments, the original set value is set on the attribute.\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    map.attr(\"prop\") //-> \"foo\"\n\nWith 1 argument, `undefined` will remove the property.  \n\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(newVal){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    Map.keys(map) //-> []\n\nWith 2 arguments, `undefined` leaves the property in place.  It is expected\nthat `setValue` will be called:\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(newVal, setValue){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    map.attr(\"prop\") //-> \"foo\"\n\n## Side effects\n\nA set function provides a useful hook for performing side effect logic as a certain property is being changed.\n\nFor example, in the example below, Paginator can.Map includes a `page` property, which derives its value entirely from other properties (limit and offset).  If something tries to set the `page` directly, the set method will set the value of `offset`:\n\n\n    var Paginate = Map.extend({\n      define: {\n        page: {\n          set: function (newVal) {\n            this.attr('offset', (parseInt(newVal) - 1) * this.attr('limit'));\n          },\n          get: function () {\n            return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n          }\n        }\n      }\n    });\n\n    var p = new Paginate({limit: 10, offset: 20});\n\n## Merging\n\nBy default, if a value returned from a setter is an object, array, can.Map, or can.List, the effect will be to replace the property with the new object completely.\n\n    Contact = Map.extend({\n      define: {\n        info: {\n          set: function(newVal){\n            return newVal;\n          }\n        }\n      }\n    })\n\n    var alice = new Contact({\n\t\t\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n\t\t});\n    alice.attr(); // {name: 'Alice Liddell', 'email': 'alice@liddell.com'}\n    alice.info._cid; // '.map1'\n\n    alice.attr('info', {name: 'Allison Wonderland', phone: '888-888-8888'});\n    alice.attr(); // {name: 'Allison Wonderland', 'phone': '888-888-8888'}\n    alice.info._cid; // '.map2'\n\nBy contrast, if you access a property of a Map using `.attr`, then change it by calling `.attr` on it directly, the new properties will be merged with the existing nested Map, not replaced.\n\n    var contact = new Map({\n      'info' : {'breath' : 'smells like roses'}\n    });\n    var newInfo = {'teeth' : 'shiny and clean'};\n    contact.attr('info').attr(newInfo); // info is now a merged object\n\nIf you would rather have the new Map or List merged into the current value, not replaced, call\n`.attr` inside the setter:\n\n\n    Contact = Map.extend({\n      define: {\n        info: {\n          set: function(newVal){\n            this.info.attr(newVal);\n            return this.info;\n          }\n        }\n      }\n    })\n\n    var alice = new Contact({\n\t\t\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n\t\t});\n    alice.attr(); // {name: 'Alice Liddell', 'email': 'alice@liddell.com'}\n    alice.info._cid; // '.map1'\n\n    alice.attr('info', {name: 'Allison Wonderland', phone: '888-888-8888'});\n    alice.attr();\n    //{\n    //  name: 'Allison Wonderland',\n    //  email: 'alice@liddell.com',\n    //  phone: '888-888-8888'\n    //}\n    alice.info._cid; // '.map1'\n\n## Batched Changes\n\nBy default, calls to set methods are wrapped in a call to [can-event/batch/batch.start batch.start] and [can-event/batch/batch.stop batch.stop], so if a set method has side effects that set more than one property, all these sets are wrapped in a single batch for better performance.\n\n",
    "description": "\nSpecify what happens when a value is set on a map attribute.\n",
    "title": "set",
    "name": "can-map-define.set",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "set( [newVal,] [setValue] )",
        "description": "\n\nA set function defines the behavior of what happens when a value is set on a\n[can-map Map]. It is typically used to:\n\n - Add or remove other attributes as side effects\n - Coerce the set value into an appropriate action\n\nThe behavior of the setter depends on the number of arguments specified. This means that a\nsetter like:\n\n    define: {\n      prop: {\n        set: function(){}\n      }\n    }\n\nbehaves differently than:\n\n    define: {\n      prop: {\n        set: function(newVal){}\n      }\n    }\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "The [can-map-define._type type function] coerced value the user intends to set on the\n[can-map Map].\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "setValue",
            "description": "A callback that can set the value of the property\nasyncronously.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the attribute value is set\n   to whatever was passed to [can-map.prototype.attr attr].\n - If the setter specifies the `newValue` argument only, the attribute value will be removed.\n - If the setter specifies both `newValue` and `setValue`, the value of the property will not be\n   updated until `setValue` is called.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ]
        }
      ],
      "optional": true,
      "name": "setValue",
      "description": "A callback that can set the value of the property\nasyncronously.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the attribute value is set\n   to whatever was passed to [can-map.prototype.attr attr].\n - If the setter specifies the `newValue` argument only, the attribute value will be removed.\n - If the setter specifies both `newValue` and `setValue`, the value of the property will not be\n   updated until `setValue` is called.\n\n"
    },
    "comment": " "
  },
  "can-map-backup/can-map.prototype": {
    "name": "can-map-backup/can-map.prototype",
    "title": "can-map.prototype",
    "type": "group",
    "parent": "can-map-backup",
    "description": "",
    "order": 0
  },
  "can-map-backup": {
    "src": {
      "path": "node_modules/can-map-backup/doc/can-map-backup.md"
    },
    "body": "\n`can-map-backup` is a plugin that provides a dirty bit for properties on an Map,\nand lets you restore the original values of an Map's properties after they are changed.\n\n## Overview\n\nHere is an example showing how to use [can-map-backup/can-map.prototype.backup] to save values,\n`[can-map-backup/can-map.prototype.restore restore]` to restore them, and `[can-map-backup/can-map.prototype.isDirty isDirty]`\n\nto check if the Map has changed:\n\n```js\nvar CanMap = require(\"can-map\");\nrequire('can-map-backup');\n\nvar recipe = new CanMap({\n  title: 'Pancake Mix',\n  yields: '3 batches',\n  ingredients: [{\n    ingredient: 'flour',\n    quantity: '6 cups'\n  },{\n    ingredient: 'baking soda',\n    quantity: '1 1/2 teaspoons'\n  },{\n    ingredient: 'baking powder',\n    quantity: '3 teaspoons'\n  },{\n    ingredient: 'salt',\n    quantity: '1 tablespoon'\n  },{\n    ingredient: 'sugar',\n    quantity: '2 tablespoons'\n  }]\n});\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.title;     // 'Flapjack Mix'\nrecipe.isDirty(); // true\n\nrecipe.restore();\nrecipe.title;     // 'Pancake Mix'\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "can-map"
      }
    ],
    "name": "can-map-backup",
    "parent": "can-observables",
    "collection": "can-legacy",
    "test": "src/test/test.html",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.3.1",
        "can-connect": "^1.5.4",
        "can-fixture": "^1.1.0",
        "can-jquery": "^3.1.0",
        "can-list": "^3.1.0",
        "can-map": "^3.3.1",
        "can-set": "^1.3.0",
        "can-util": "^3.9.5"
      },
      "deprecated": false,
      "description": "Backup and restore a Maps state",
      "devDependencies": {
        "can-map-define": "^3.1.0",
        "detect-cyclic-packages": "^1.1.0",
        "documentjs": "^0.4.2",
        "done-ssr": "^1.0.4",
        "donejs-cli": "^1.0.1",
        "generator-donejs": "^1.0.5",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs"
      ],
      "main": "can-map-backup",
      "name": "can-map-backup",
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "can-serve --static --develop --port 8080",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-map-backup",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.1.0"
    },
    "signatures": [
      {
        "code": "require('can-map-backup')",
        "description": "\n\nAdds a [can-map-backup/can-map.prototype.backup],\n[can-map-backup/can-map.prototype.isDirty] and\n[can-map-backup/can-map.prototype.restore] method to [can-map].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "Exports [can-map].\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "Exports [can-map].\n"
    },
    "comment": " "
  },
  "can-map-backup/can-map.prototype.isDirty": {
    "src": {
      "path": "node_modules/can-map-backup/doc/prototype.isDirty.md"
    },
    "body": "\n```\nvar CanMap = require('can-map');\nrequire('can-map-backup')\n\nvar recipe = new CanMap(\"Recipe\", {\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\n\nrecipe.isDirty();     // false\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.isDirty();     // true\nrecipe.restore();\nrecipe.isDirty();   // false\n\nrecipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // true\n\nrecipe.backup();\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // false\n```\n\n",
    "description": "Check whether an Observe has changed since the last time it was backed up. \n",
    "title": "isDirty",
    "name": "can-map-backup/can-map.prototype.isDirty",
    "type": "function",
    "parent": "can-map-backup/can-map.prototype",
    "signatures": [
      {
        "code": "map.isDirty([deep])",
        "description": "\n\n`isDirty` checks whether any properties have changed value or whether any properties have\nbeen added or removed since the last time the Observe was backed up. If _deep_ is `true`,\nIf the Observe has never been backed up, `isDirty` returns `undefined`.\n`isDirty` will include nested Observes in its checks.\n",
        "params": [
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "deep",
            "defaultValue": "false",
            "description": "whether to check nested Observes"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "bool"
            }
          ],
          "description": "Whether the Observe has changed since the last time it was [can.Map.backup.prototype.backup backed up].\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "deep",
      "defaultValue": "false",
      "description": "whether to check nested Observes"
    },
    "_curReturn": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "description": "Whether the Observe has changed since the last time it was [can.Map.backup.prototype.backup backed up].\n\n"
    },
    "comment": " "
  },
  "can-map-backup/can-map.prototype.backup": {
    "src": {
      "path": "node_modules/can-map-backup/doc/prototype.backup.md"
    },
    "body": "\n## Example\n\n```\nvar CanMap = require('can-map');\nrequire('can-map-backup')\n\nvar recipe = new CanMap(\"Recipe\", {\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.title;     // 'Flapjack Mix'\n\nrecipe.restore();\nrecipe.title;     // 'Pancake Mix'\n```\n\n",
    "description": "Save the values of the properties of an Map. \n",
    "title": "backup",
    "name": "can-map-backup/can-map.prototype.backup",
    "type": "function",
    "parent": "can-map-backup/can-map.prototype",
    "signatures": [
      {
        "code": "map.backup()",
        "description": "\n\n`backup` backs up the current state of the properties of an Observe and marks\nthe Observe as clean. If any of the properties change value, the original\nvalues can be restored with [can.Map.backup.prototype.restore restore].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "The map, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "The map, for chaining.\n"
    },
    "comment": " "
  },
  "can-map-backup/can-map.prototype.restore": {
    "src": {
      "path": "node_modules/can-map-backup/doc/prototype.restore.md"
    },
    "body": "\n```js\nvar CanMap = require('can-map');\nrequire('can-map-backup')\n\nvar recipe = new CanMap(\"Recipe\", {\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\n\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.restore();\nrecipe.attr('title'); // 'Pancake Mix'\n\nrecipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.restore();\nrecipe.attr('ingredients.0.quantity'); // '7 cups'\nrecipe.restore(true);\nrecipe.attr('ingredients.0.quantity'); // '6 cups'\n```\n\n## Events\nWhen `restore` sets values or re-adds properties, the same events will be fired (including\n_change_, _add_, and _set_) as if the values of the properties had been set using [`attr`](http://canjs.com/docs/can.Map.prototype.attr.html).\n\n",
    "description": "Restore saved values of an Observe's properties. \n",
    "title": "restore",
    "name": "can-map-backup/can-map.prototype.restore",
    "type": "function",
    "parent": "can-map-backup/can-map.prototype",
    "signatures": [
      {
        "code": "map.restore( [deep] )",
        "description": "\n\n`restore` sets the properties of an Observe back to what they were the last time\n[can-map-backup.prototype.backup backup] was called. If _deep_ is `true`,\n`restore` will also restore the properties of nested Observes.\n\n`restore` will not remove properties that were added since the last backup, but it\nwill re-add properties that have been removed.\n",
        "params": [
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "deep",
            "defaultValue": "false",
            "description": "whether to restore properties in nested Observes"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "The Observe, for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "deep",
      "defaultValue": "false",
      "description": "whether to restore properties in nested Observes"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "The Observe, for chaining.\n"
    },
    "comment": " "
  },
  "can.view.elements": {
    "name": "can.view.elements",
    "type": "property",
    "parent": "can.view",
    "src": {
      "line": 6,
      "codeLine": 13,
      "path": "node_modules/can-legacy-view-helpers/src/elements.js"
    },
    "body": "\n",
    "description": "\nProvides helper methods for and information about the behavior\nof DOM elements.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": ""
  },
  "can.view.elements.attrMap": {
    "body": "\nA mapping of\nspecial attributes to their JS property. For example:\n\n    \"class\" : \"className\"\n\nmeans get or set `element.className`. And:\n\n     \"checked\" : true\n\nmeans set `element.checked = true`.\n\n\nIf the attribute name is not found, it's assumed to use\n`element.getAttribute` and `element.setAttribute`.\n \n",
    "description": "\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Boolean"
              },
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "title": "",
    "name": "can.view.elements.attrMap",
    "type": "property",
    "parent": "can.view.elements"
  },
  "can.view.elements.tagMap": {
    "name": "can.view.elements.tagMap",
    "type": "property",
    "parent": "can.view.elements",
    "src": {
      "line": 38,
      "codeLine": 47,
      "path": "node_modules/can-legacy-view-helpers/src/elements.js"
    },
    "body": " \n",
    "description": "\nA mapping of parent node names to child node names that can be inserted within\nthe parent node name.  For example: `table: \"tbody\"` means that\nif you want a placeholder element within a `table`, a `tbody` will be\ncreated.\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "title": ""
  },
  "pendingHookups": {
    "name": "pendingHookups",
    "type": "property",
    "parent": "node_modules/can-legacy-view-helpers/src/render.js",
    "src": {
      "line": 6,
      "codeLine": 9,
      "path": "node_modules/can-legacy-view-helpers/src/render.js"
    },
    "body": "\n",
    "description": "Helper(s)\n"
  },
  "can.view.txt": {
    "type": "function",
    "name": "can.view.txt",
    "parent": "node_modules/can-legacy-view-helpers/src/render.js",
    "src": {
      "line": 102,
      "codeLine": 131,
      "path": "node_modules/can-legacy-view-helpers/src/render.js"
    },
    "body": "\n",
    "description": "\nA helper function used to insert the\nvalue of the contents of a magic tag into\na template's output. It detects if an observable value is\nread and will setup live binding.\n",
    "title": "",
    "hide": true,
    "signatures": [
      {
        "code": "can.view.txt(escape, tagName, status, self, func)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "1",
            "description": "if the content returned should be escaped, 0 if otherwise."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "the name of the tag the magic tag is most immediately\nwithin. Ex: `\"li\"`."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "name": "status",
            "description": "A flag indicates which part of a tag the\nmagic tag is within. Status can be:\n\n - _STRING_ - The name of the attribute the magic tag is within. Ex: `\"class\"`\n - `1` - The magic tag is within a tag like `<div <%= %>>`\n - `0` - The magic tag is outside (or between) tags like `<div><%= %></div>`\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "self",
            "description": "The `this` of the current context template. `func` is called with\nself as this.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "func",
            "description": "The \"wrapping\" function. For\nexample:  `<%= task.attr('name') %>` becomes\n  `(function(){return task.attr('name')})\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "func",
      "description": "The \"wrapping\" function. For\nexample:  `<%= task.attr('name') %>` becomes\n  `(function(){return task.attr('name')})\n\n "
    }
  },
  "elements": {
    "name": "elements",
    "type": "property",
    "parent": "node_modules/can-legacy-view-helpers/src/scanner.js",
    "src": {
      "line": 0,
      "codeLine": 5,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n",
    "description": "This module must be CJS format because is uses `with () { ... }`\nstatements which will not work in ES6 since it forces strict mode.\n"
  },
  "newLine": {
    "name": "newLine",
    "type": "property",
    "parent": "node_modules/can-legacy-view-helpers/src/scanner.js",
    "src": {
      "line": 10,
      "codeLine": 13,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n",
    "description": "Helper(s)\n"
  },
  "can.view.Scanner": {
    "type": "constructor",
    "name": "can.view.Scanner",
    "params": [
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "Object",
            "options": [
              {
                "name": "text",
                "types": [
                  {
                    "type": "can.view.Scanner.text"
                  }
                ]
              },
              {
                "name": "tokens",
                "types": [
                  {
                    "type": "Array",
                    "template": [
                      {
                        "types": [
                          {
                            "type": "can.view.Scanner.token"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "name": "helpers",
                "types": [
                  {
                    "type": "Array",
                    "template": [
                      {
                        "types": [
                          {
                            "type": "can.view.Scanner.helpers"
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "description": "\n"
      }
    ],
    "parent": "node_modules/can-legacy-view-helpers/src/scanner.js",
    "src": {
      "line": 84,
      "codeLine": 97,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n\n",
    "description": "\ncan.view.Scanner is used to convert a template into a JavaScript function.  That\nfunction is called to produce a rendered result as a string. Often\nthe rendered result will include data-view-id attributes on elements that\nwill be processed after the template is used to create a document fragment.\n",
    "title": "",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "text",
              "types": [
                {
                  "type": "can.view.Scanner.text"
                }
              ]
            },
            {
              "name": "tokens",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can.view.Scanner.token"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "helpers",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can.view.Scanner.helpers"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    }
  },
  "can.view.Scanner.text": {
    "name": "can.view.Scanner.text",
    "type": "typedef",
    "parent": "can.view.Scanner",
    "src": {
      "line": 100,
      "codeLine": 103,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "",
    "description": "\t \n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "start",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "escape",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "scope",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "options",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ]
  },
  "can.view.Scanner.prototype": {
    "name": "can.view.Scanner.prototype",
    "type": "property",
    "parent": "can.view.Scanner",
    "src": {
      "line": 159,
      "codeLine": 162,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n",
    "description": "Extend can.View to add scanner support.\n"
  },
  "can.view": {
    "name": "can.view",
    "type": "add",
    "description": "undefined\n"
  },
  "can.view.frag": {
    "type": "function",
    "name": "can.view.frag",
    "params": [
      {
        "name": "result",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "parentNode",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can.view.static",
    "src": {
      "line": 42,
      "codeLine": 46,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": "",
    "description": " \n",
    "title": "frag"
  },
  "can.view.hookup": {
    "type": "function",
    "name": "can.view.hookup",
    "params": [
      {
        "name": "fragment",
        "description": ""
      },
      {
        "name": "parentNode",
        "description": ""
      }
    ],
    "parent": "can.view",
    "src": {
      "line": 76,
      "codeLine": 83,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": "",
    "description": "hook up a fragment to its parent node\n",
    "hide": true,
    "_curParam": {
      "name": "parentNode",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "\n "
    }
  },
  "can.view.hookups": {
    "name": "can.view.hookups",
    "type": "property",
    "parent": "can.view",
    "src": {
      "line": 109,
      "codeLine": 114,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": " \n",
    "description": "A list of pending 'hookups'\n",
    "title": "",
    "hide": true
  },
  "can.view.hook": {
    "type": "function",
    "name": "can.view.hook",
    "parent": "can.view.static",
    "src": {
      "line": 119,
      "codeLine": 137,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": "Registers a hookup function that can be called back after the html is\nput on the page.  Typically this is handled by the template engine.  Currently\nonly EJS supports this functionality.\n\n    var id = can.view.hook(function(el){\n           //do something with el\n        }),\n        html = \"<div data-view-id='\"+id+\"'>\"\n    $('.foo').html(html);\n \n",
    "description": "Create a hookup to insert into templates. ",
    "title": "hook",
    "signatures": [
      {
        "code": "can.view.hook(callback)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "callback",
            "description": "A callback function to be called with the element.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "callback",
      "description": "A callback function to be called with the element.\n"
    },
    "comment": " "
  },
  "can.view.cached": {
    "name": "can.view.cached",
    "type": "property",
    "parent": "can.view",
    "src": {
      "line": 142,
      "codeLine": 148,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": " \n",
    "description": "Cached are put in this object\n",
    "hide": true,
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "view"
  },
  "can-observe": {
    "src": {
      "path": "node_modules/can-observe/docs/can-observe.md"
    },
    "body": "\n## Use\n\nUsing `can-observe` allows you to create observable objects where any property added is immediately observable, including nested objects. This makes `can-observe` ideal for use-cases where the data may be dynamic, or where the more rigid approach of [can-define] is unneeded.\n\nTo use `can-observe` call the `observe()` method with an object. This will return a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) object where any changes will reflect back on the target object. Nested objects will be observed lazily when they are accessed or set dynamically after initialization on a `can-observe` proxy object.\n\nTo listen for changes on a property, use [can-reflect/observe.onKeyValue canReflect.onKeyValue]. Pass the handler as the third argument which will be triggered when a new value is set on the proxy. In the example below, updating `dog.name` to `\"Wilbur\"` will trigger the callback that will `console.log` the new value `\"Wilbur\"`.\n\n```js\nvar canReflect = require(\"can-reflect\");\nvar dog = observe({});\n\ncanReflect.onKeyValue(dog, 'name', function(newVal){\n\tconsole.log(newVal); //-> \"Wilbur\"\n});\n\ndog.name = \"Wilbur\";\n```\n\n`can-observe` can be combined with any other CanJS observable type, like [can-define] or [can-compute]. In this example we create a compute that changes when a can-observe proxy changes. Note that with computes we use [can-reflect/observe.onValue canReflect.onValue] to set up the event listener and handler.\n\n```js\nvar compute = require(\"can-compute\");\nvar observe = require(\"can-observe\");\nvar canReflect = require(\"can-reflect\");\n\nvar person = observe({});\n\nvar fullName = compute(function(){\n\treturn person.first + \" \" + person.last;\n});\n\nfullName.on(\"change\", function(ev, newVal){\n\tconsole.log(newVal); // -> Chasen Le Hara\n});\n\n\nperson.first = \"Chasen\";\nperson.last = \"Le Hara\";\n```\n\n## Nested Objects\n\nAny Object property in a `can-observe` will be replaced with a `can-observe` observed Proxy on read or write.  This allows deep path traversal in objects, with observable changes all along the way.\n\n```js\nvar observe = require(\"can-observe\");\n\nvar name = { first: \"Justin\", last: \"Meyer\" };\nvar person = { \n\tname: name\n};\n\nvar observed = observe(person); \nobserved;       // -> observed is a Proxy;\nobserved.name;  // -> also a Proxy\nperson.name;    // -> this is a plain object instead\n\nobserved.address = { city: \"Chicago\" };  // this gets proxified on set, so...\nperson.address // -> this is a Proxy\n```\n\n## ES6 Classes\n\n`can-observe` is specifically designed to work with ES6 classes.  To make view models for your [can-component can-components] from ES6 classes, only a few lines of constructor code are necessary:\n\n```js\nimport observe from (\"can-observe\");\nimport canComponent from (\"can-component\");\nimport stache from (\"can-stache\")\n\nclass WidgetViewModel {\n\tconstructor(obj) {\n\t\t// view model instances receive properties as an object on instantiation\n\t\tObject.assign(this, obj);\n\t\treturn observe(this);\n\t}\n\tget fixedMessage() {\n\t\treturn \"Hello\"\n\t}\n\t// ... more static and prototype functions.\n}\n\ncanComponent.extend({\n\ttag: \"my-widget\",\n\tview: stache(\"<p>{{fixedMessage}}, {{messageFromParent}}</p>\"),\n\tViewModel: WidgetViewModel\n});\n```\n\n```html\n<my-widget messageFromParent:from=\"'world'\" />\n\n<!-- above tag will contain \"<p>Hello, world!</p>\" on render --> \n```\n\n## Browser support\n\ncan-observe uses the Proxy feature of JavaScript to observe arbitrary properties. Proxies are available in [all modern browsers](http://caniuse.com/#feat=proxy).\n\nA [polyfill is available](https://github.com/GoogleChrome/proxy-polyfill) that brings Proxies back to IE9, with the caveat that only existing properties on the target object can be observed. This means this code:\n\n```js\nvar person = observe({first: '', last: ''});\n```\n\nThe *first* and *last* properties are observable in older browsers, but any other property added would not be. To ensure maximum compatibility make sure to give all properties a default value.\n\n",
    "description": "Create an observable object. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-observe",
    "parent": "can-observables",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-observe/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.0.1",
        "can-event": "^3.7.5",
        "can-namespace": "^1.0.0",
        "can-observation": "^3.0.7",
        "can-reflect": "^1.4.2",
        "can-symbol": "^1.2.0"
      },
      "deprecated": false,
      "description": "Like can.Map, but without the .attr method.",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-compute": "^3.0.5",
        "can-stache": "^3.0.19",
        "can-util": "^3.2.2",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.9.1",
        "testee": "^0.3.1"
      },
      "homepage": "https://github.com/canjs/can-observe",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "can-observe.js",
      "name": "can-observe",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-observe.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "1.0.0"
    },
    "signatures": [
      {
        "code": "observe(target)",
        "description": "\n\nCreate an observable object that acts as a [proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) for a target object.\n\n```js\nvar stache = require(\"can-stache\");\nvar dog = observe({});\n\nvar frag = stache(\"<p>dog's name is {{name}}</p>\")(dog);\ndocument.body.appendChild(frag);\n\ndog.name = 'Wilbur'; // -> \"<p>dog's name is Wilbur</p>\" on the document body\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The object from which an observable instance is created.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Proxy"
            }
          ],
          "description": "A proxy for the target object.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "target",
      "description": "The object from which an observable instance is created.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Proxy"
        }
      ],
      "description": "A proxy for the target object.\n"
    },
    "comment": " "
  },
  "can-react-component": {
    "src": {
      "path": "node_modules/can-react-component/docs/can-react-component.md"
    },
    "body": "\n## Use\n\n```jsx\nimport React from \"react\";\nimport CanComponent from \"can-component\";\nimport canReactComponent from \"can-react-component\";\nimport stache from \"can-stache\";\n\nconst InnerComponent = canReactComponent(\n  CanComponent.extend(\"InnerComponent\", {\n    tag: \"inner-component\",\n    view: stache(\"<div class='inner'>Inner text: {{text}}</div>\")\n  })\n);\n\nexport default class AppComponent extends React.Component {\n  render() {\n    return (\n      <InnerComponent text=\"hello world\" />\n    );\n  }\n}\n```\n\nYou can play with the above example on JS Bin:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/cisowob/3/embed?js,output\">can-react-component demo on jsbin.com</a>\n\nYou can also use this module with [Preact](https://preactjs.com):\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/fexezi/2/embed?js,output\">can-react-component demo with Preact on jsbin.com</a>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "Create a React component out of a [can-component]. \n",
    "title": "can-react-component",
    "name": "can-react-component",
    "parent": "can-views",
    "type": "function",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-react-component/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "^1.0.0",
        "can-util": "^3.7.0",
        "can-view-scope": "^3.1.1"
      },
      "deprecated": false,
      "description": "Create a React component out of a CanComponent.",
      "devDependencies": {
        "babel-eslint": "^7.2.3",
        "bit-docs": "0.0.7",
        "can-component": "^3.0.7",
        "can-define": "^1.5.0",
        "can-stache": "^3.0.24",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.3.0",
        "eslint": "^3.18.0",
        "eslint-plugin-react": "^7.0.1",
        "react": "^16.0.0",
        "react-dom": "^16.0.0",
        "steal": "^1.5.2",
        "steal-builtins": "^1.0.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.3.5",
        "testee": "^0.6.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs",
        "react"
      ],
      "main": "can-react-component",
      "name": "can-react-component",
      "peerDependencies": {
        "react": "15.x - 16.x"
      },
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-react-component.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "eslint": "eslint \"**/*.js\" --ignore-pattern \"dist\" --ignore-pattern \"node_modules\"",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "prepublish": "npm run build",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run detect-cycle && npm run eslint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-react-component",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "babel-eslint",
          "bit-docs",
          "done-serve",
          "eslint",
          "eslint-plugin-react",
          "testee"
        ]
      },
      "version": "0.1.9"
    },
    "signatures": [
      {
        "code": "canReactComponent( displayName, CanComponent )",
        "description": "\n\nConverts a [can-component] constructor into a React Component and updates the component’s `viewModel` any time the React props change.\n\n```jsx\nimport CanComponent from \"can-component\";\nimport canReactComponent from \"can-react-component\";\nimport ReactDOM from \"react-dom\";\n\nconst MyCanComponent = CanComponent.extend({ ... });\nconst InnerComponent = canReactComponent( \"InnerComponent\", MyCanComponent );\n\nReactDOM.render(\n  <InnerComponent text=\"inner text\" number={ 5 } />,\n  document.getElementById(\"app\")\n)\n```\n\nValues will be passed to the `viewModel` in the same way they would be for a normal React Component, e.g. the `text` prop in the above example would provide the string `\"inner text\"` to the `viewModel`, `number` would provide the number `5`, etc.\n\nSince the component doesn’t produce DOM artifacts of its own, you won’t end up with any wrapper divs or anything else to worry about, but [React Developer Tools](https://github.com/facebook/react-devtools) will show you the component with the `displayName` in the React tree.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "displayName",
            "description": "The name of the created component. If this is not specified, it will be the CanComponent’s name appended with “Wrapper”."
          },
          {
            "types": [
              {
                "type": "CanComponent"
              }
            ],
            "name": "CanComponent",
            "description": "Any [can-component].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "ReactComponent"
            }
          ],
          "description": "A React component\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "CanComponent"
        }
      ],
      "name": "CanComponent",
      "description": "Any [can-component].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "ReactComponent"
        }
      ],
      "description": "A React component\n"
    },
    "comment": " "
  },
  "can-ndjson-stream": {
    "src": {
      "path": "node_modules/can-ndjson-stream/docs/can-ndjson-stream.md"
    },
    "body": "\n## Use\n\nThis module is typically used with [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) to parse an NDJSON response stream. Follow the steps below to use `fetch` with an NDJSON stream service. See the [Creating an NDJSON stream service with NodeJS](#CreatinganNDJSONstreamservicewithNodeJS_) section below to learn how to create a service that emits an NDJSON stream.\n\n\nAssuming your raw data looks something like this:\n\n```js\n{\"item\":\"first\"}\\n\n{\"item\":\"second\"}\\n\n{\"item\":\"third\"}\\n\n{\"item\":\"fourth\"}\\n\n```\n\nfollow these steps to make a request from an NDJSON service at `/some/endpoint`:\n\n1. Make a `fetch` request to an NDJSON service by passing the endpoint as an argument.\n2. The service responds with a stream with each value being one line of NDJSON: `{\"item\":\"first\"}\\n`\n3. `Fetch`'s `then` method is provided a `Response` instance, which we can parse using `ndjsonStream()` into a JavaScript `ReadableStream`.\n5. Each JavaScript object in the stream can be read by calling `[streamName].getReader.read()`, which returns a promise.\n6. The result of that promise will be one JS object from your NDJSON: `{item: \"first\"}`\n\n```js\n  const ndjsonStream = require('can-ndjson-stream');\n\n  fetch('/some/endpoint')  // make a fetch request to a NDJSON stream service\n    .then((response) => {\n    return ndjsonStream(response.body); //ndjsonStream parses the response.body\n  }).then((exampleStream) => {\n    //retain access to the reader so that you can cancel it\n    const reader = exampleStream.getReader();\n    let read;\n\n    reader.read().then(read = (result) => {\n      if (result.done) return;\n      console.log(result.value); //logs {item:\"first\"}\n      exampleStream.getReader().read().then(read);\n    });\n  });\n```\n## What is NDJSON?\n\n[NDJSON](http://ndjson.org) is a data format that is separated into individual JSON objects with a newline character (`\\n`). The 'nd' stands for newline delimited JSON. Essentially, you have some data that is formatted like this:\n\n```js\n{\"item\":\"first\"}\\n\n{\"item\":\"second\"}\\n\n{\"item\":\"third\"}\\n\n{\"item\":\"fourth\"}\\n\n```\nEach item above is separated with a newline and each of those can be sent individually over a stream which allows the client to receive and process the data in specified increments.\n\n## Creating an NDJSON stream service with NodeJS.\n\nThis is a quick start guide to getting a NDJSON stream API up and running.\nIt reads from a local `todos.ndjson` file and responds with a line from the\nfile every 500ms.\n\n1. Install dependencies:\n```bash\n$ npm i express path fs ndjson\n```\n\n2. Create a server.js file and copy this code:\n\n```js\n// server.js\nconst express = require('express');\nconst app = express();\nconst path = require('path');\nconst fs = require('fs');\nconst ndjson = require('ndjson');\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', (req, res) => {\n  let readStream = fs.createReadStream(__dirname + '/todos.ndjson').pipe(ndjson.parse())\n\nreadStream.on('data', (data) => {\n    chunks.push(JSON.stringify(data));\n  });\n\n  readStream.on('end', () => {\n    var id = setInterval(() => {\n      if (chunks.length) {\n        res.write(chunks.shift() + '\\n');\n      } else {\n        clearInterval(id);\n        res.end();\n      }\n    }, 500);\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Example app listening on port 3000!');\n});\n```\nWe use a `setInterval` to slow the stream down so that you can see the stream in action. Feel free to remove the setInterval and use a `while` loop to remove the delay.\n\n",
    "description": "Parses an [NDJSON](http://www.ndjson.org) stream into a stream of JavaScript objects. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-ndjson-stream",
    "parent": "can-data-modeling",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-ndjson-stream/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "^1.0.0"
      },
      "deprecated": false,
      "description": "[![Join the chat at https://gitter.im/canjs/canjs](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/canjs/canjs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://github.com/canjs/can-ndjson-stream/blob/master/license.md) [![npm version](https://badge.fury.io/js/can-ndjson-stream.svg)](https://www.npmjs.com/package/can-ndjson-stream) [![Travis build status](https://travis-ci.org/canjs/can-ndjson-stream.svg?branch=master)](https://travis-ci.org/canjs/can-ndjson-stream) [![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/canjs/can-ndjson-stream?branch=master&svg=true)](https://ci.appveyor.com/project/matthewp/can-ndjson-stream) [![Coverage status](https://coveralls.io/repos/github/canjs/can-ndjson-stream/badge.svg?branch=master)](https://coveralls.io/github/canjs/can-ndjson-stream?branch=master) [![Greenkeeper badge](https://badges.greenkeeper.io/canjs/can-ndjson-stream.svg)](https://greenkeeper.io/)",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "http-server": "^0.10.0",
        "jshint": "^2.9.1",
        "saucelabs": "^1.4.0",
        "steal": "^1.0.5",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "test-saucelabs": "0.0.2",
        "testee": "^0.7.0"
      },
      "false": {},
      "homepage": "https://github.com/canjs/can-ndjson-stream#readme",
      "keywords": [],
      "licenses": [
        {
          "type": "MIT",
          "url": "http://opensource.org/licenses/MIT"
        }
      ],
      "main": "can-ndjson-stream",
      "name": "can-ndjson-stream",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-ndjson-stream.git"
      },
      "scripts": {
        "build": "node build.js",
        "ci": "npm run build && npm run test && node ./test-sauce-labs.js",
        "demo": "cd demo/ && npm i && npm run start",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "http-server": "http-server -p 3000 --silent",
        "jshint": "jshint ./*.js --config",
        "postpublish": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "test": "npm run detect-cycle && npm run jshint && node test.js",
        "test-local": "npm run jshint && npm run testee-local",
        "testee-local": "testee test.html --browsers chrome",
        "version": "git commit -am \"Update version number\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-ndjson-stream",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "0.1.6"
    },
    "signatures": [
      {
        "code": "ndjsonStream(stream)",
        "description": "\n\nThe `can-ndjson-stream` module converts a stream of NDJSON to a [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) of JavaScript objects. It is likely that you would use this module to parse an NDJSON stream `response` object received from a [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) request to a service that sends NDJSON streams.\n```js\nconst ndjsonStream = require('can-ndjson-stream');\n\nfetch('/some/endpoint')  // make a fetch request to a NDJSON stream service\n  .then((response) => {\n    return ndjsonStream(response.body); //ndjsonStream parses the response.body\n\n  }).then((exampleStream) => {\n    let read;\n    exampleStream.getReader().read().then(read = (result) => {\n      if (result.done) return;\n\n      console.log(result.value);\n      exampleStream.getReader().read().then(read);\n\n    });\n  });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "ReadableStream",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Byte"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "stream",
            "description": "A readable [NDJSON](http://www.ndjson.org/) byte stream.  \n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "ReadableStream",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The output is a [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) that has the following methods:\n- getReader()\n- cancel([optional cancellation message])\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ReadableStream",
          "template": [
            {
              "types": [
                {
                  "type": "Byte"
                }
              ]
            }
          ]
        }
      ],
      "name": "stream",
      "description": "A readable [NDJSON](http://www.ndjson.org/) byte stream.  \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "ReadableStream",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "The output is a [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) that has the following methods:\n- getReader()\n- cancel([optional cancellation message])\n"
    },
    "comment": " "
  },
  "can-simple-map.prototype.attr": {
    "src": {
      "path": "node_modules/can-simple-map/docs/prototype.attr.md"
    },
    "body": "\n## Use\n\n`attr` gets or sets properties on the `SimpleMap` it's called on. Here's a tour through how all of its forms work:\n\n```\nvar map = new SimpleMap({ age: 29 });\n\n// get a property:\nfoo.attr('age'); // 29\n\n// set a property:\nfoo.attr('age', 30);\nfoo.attr('age'); // 30\n\n// set and merge multiple properties:\nfoo.attr({\n\tfirst: 'Kevin',\n\tlast: 'Phillips'\n});\nfoo.attr('age'); // 30\nfoo.attr('first'); // 'Kevin'\nfoo.attr('last'); // 'Phillips'\n```\n\nWhen properties are changed using attr, the `SimpleMap` will emit events. Events can be listened to using [can-event.on] or [can-event.bind].\n\n```\nvar map = new SimpleMap({ age: 29 });\n\nmap.on('age', function(ev, newVal, oldVal) {\n\tnewVal; // 30\n\toldVal; // 29\n});\n\nmap.attr('age', 30);\n```\n\n",
    "description": "Get or set properties on a SimpleMap. \n",
    "title": "attr",
    "name": "can-simple-map.prototype.attr",
    "type": "function",
    "parent": "can-simple-map.prototype",
    "signatures": [
      {
        "code": "map.attr(key)",
        "description": "\n\nReads a property from this `SimpleMap`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The property to read."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value assigned to _key_.\n"
        }
      },
      {
        "code": "map.attr(key, value)",
        "description": "\n\nAssigns _value_ to a property on this `SimpleMap` called _key_.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The property to set."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign to _key_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.SimpleMap"
            }
          ],
          "description": "This SimpleMap, for chaining.\n"
        }
      },
      {
        "code": "map.attr(obj)",
        "description": "\n\nAssigns each value in _obj_ to a property on this `SimpleMap` named after the\ncorresponding key in _obj_, effectively merging _obj_ into the SimpleMap.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "A collection of key-value pairs to set.\nIf any properties already exist on the `SimpleMap`, they will be overwritten.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.SimpleMap"
            }
          ],
          "description": "this SimpleMap, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.SimpleMap"
        }
      ],
      "description": "this SimpleMap, for chaining\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "A collection of key-value pairs to set.\nIf any properties already exist on the `SimpleMap`, they will be overwritten.\n"
    },
    "comment": " "
  },
  "can-simple-map.prototype.get": {
    "src": {
      "path": "node_modules/can-simple-map/docs/prototype.get.md"
    },
    "body": "\n\n",
    "description": "Get properties on a SimpleMap. \n",
    "title": "get",
    "name": "can-simple-map.prototype.get",
    "type": "function",
    "parent": "can-simple-map.prototype",
    "signatures": [
      {
        "code": "map.get(key)",
        "description": "\n\nReads a property from this `SimpleMap`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The property to read."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value assigned to _key_.\n\n"
        }
      },
      {
        "code": "map.get()",
        "description": "\n\nReturns the data of this simple-map as a plain JavaScript object.\n\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The data as a plain JavaScript object of this simple-map.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The data as a plain JavaScript object of this simple-map.\n"
    },
    "comment": " "
  },
  "can-simple-map.prototype.serialize": {
    "src": {
      "path": "node_modules/can-simple-map/docs/prototype.serialize.md"
    },
    "body": "",
    "description": "Returns the serialized form of the simple-map. \n",
    "title": "serialize",
    "name": "can-simple-map.prototype.serialize",
    "type": "function",
    "parent": "can-simple-map.prototype",
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n\nReturns the serialized form of the simple-map, with any values in the map that\nhave a serialize method also having serialized called.\n\n```js\nvar map = new SimpleMap();\nmap.set(\"deep\", new SimpleMap({a: \"b\"}));\n\nmap.serialize() //->  {deep: {a: \"b\"}}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A plain JavaScript object that will only contain\nprimitives and other plain JavaScript objects.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A plain JavaScript object that will only contain\nprimitives and other plain JavaScript objects.\n"
    }
  },
  "can-simple-map.prototype.set": {
    "src": {
      "path": "node_modules/can-simple-map/docs/prototype.set.md"
    },
    "body": "\n",
    "description": "Set properties on a SimpleMap. \n",
    "title": "set",
    "name": "can-simple-map.prototype.set",
    "type": "function",
    "parent": "can-simple-map.prototype",
    "signatures": [
      {
        "code": "map.set(key, value)",
        "description": "\n\nAssigns _value_ to a property on this `SimpleMap` called _key_.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The property to set"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign to _key_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.SimpleMap"
            }
          ],
          "description": "this SimpleMap, for chaining\n"
        }
      },
      {
        "code": "map.set(obj)",
        "description": "\n\nAssigns each value in _obj_ to a property on this `SimpleMap` named after the\ncorresponding key in _obj_, effectively merging _obj_ into the SimpleMap.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "a collection of key-value pairs to set.\nIf any properties already exist on the `SimpleMap`, they will be overwritten.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.SimpleMap"
            }
          ],
          "description": "this SimpleMap, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.SimpleMap"
        }
      ],
      "description": "this SimpleMap, for chaining\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "a collection of key-value pairs to set.\nIf any properties already exist on the `SimpleMap`, they will be overwritten.\n"
    },
    "comment": " "
  },
  "can-simple-map.prototype": {
    "name": "can-simple-map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-simple-map",
    "description": "",
    "order": 0
  },
  "can-simple-map": {
    "src": {
      "path": "node_modules/can-simple-map/docs/simple-map.md"
    },
    "body": "\n## Use\n\n`SimpleMap` provides a way to create an Observable whose properties can be changed using [can-simple-map.prototype.attr attr].\n\n```\nvar map = new SimpleMap({ age: 29 });\n\nmap.on('age', function(ev, newVal, oldVal) {\n\tnewVal; // 30\n\toldVal; // 29\n});\n\nfoo.attr('age'); // 29\n\nmap.attr('age', 30);\n```\n\n",
    "description": "A performant live-bound map. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "name": "can-simple-map",
    "parent": "can-observables",
    "collection": "can-infrastructure",
    "inherits": "can",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-simple-map/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.0.3",
        "can-construct": "^3.2.0",
        "can-event": "^3.6.0",
        "can-observation": "^3.3.1",
        "can-reflect": "^1.2.1",
        "can-symbol": "^1.0.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "A performant live-bound map",
      "devDependencies": {
        "can-compute": "^3.3.1",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [],
      "main": "can-simple-map",
      "name": "can-simple-map",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-simple-map.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-simple-map",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.3.1"
    },
    "signatures": [
      {
        "code": "new SimpleMap([props])",
        "description": "\n\nCreates a new instance of can.SimpleMap.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the Observe with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.SimpleMap"
            }
          ],
          "description": "An instance of `can.SimpleMap` with the properties from _props_.\n"
        }
      },
      {
        "code": "SimpleMap.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.SimpleMap"
        }
      ],
      "description": "An instance of `can.SimpleMap` with the properties from _props_.\n"
    },
    "comment": " "
  },
  "can-set.Algebra.prototype": {
    "name": "can-set.Algebra.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-set.Algebra",
    "description": "",
    "order": 0
  },
  "can-set.Algebra": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.algebra.md"
    },
    "body": "",
    "description": "Perform set logic with an awareness of how certain properties represent a set.\n\n\n",
    "title": "Algebra",
    "name": "can-set.Algebra",
    "type": "function",
    "parent": "can-set.properties",
    "signatures": [
      {
        "code": "new set.Algebra(compares...)",
        "description": "\n\nAn `algebra` instance can perform a variety of set logic methods\nusing the `compares` configuration.\n\nA default `algebra` instance can be created like:\n\n```js\nvar set = require(\"can-set\");\nvar defaultAlgebra = new set.Algebra();\n```\n\nThis treats every property as a filter in a `where` clause.  For example:\n\n```js\n// `{id: 2, ownerId: 5}` belongs to ``.getList({ownerId: 5})`\ndefaultAlgebra.has({ownerId: 5}, {id: 2, ownerId: 5}) //-> true\n\ndefaultAlgebra.getSubset({ownerId: 5}, {},\n    [\n        {id: 1, ownerId: 2},\n        {id: 2, ownerId: 5},\n        {id: 3, ownerId: 12}\n    ]) //-> [{id: 2, ownerId: 5}]\n```\n\n[can-set.compares] configurations can be passed to\nadd better property behavior awareness:\n\n\n```js\nvar set = require(\"can-set\");\nvar todoAlgebra = new set.Algebra(\n  set.props.boolean(\"completed\"),\n  set.props.id(\"_id\"),\n  set.props.offsetLimit(\"offset\",\"limit\")\n);\n\ndefaultAlgebra.getSubset({limit: 2, offset: 1}, {},\n    [\n        {id: 1, ownerId: 2},\n        {id: 2, ownerId: 5},\n        {id: 3, ownerId: 12}\n    ]) //-> [{id: 2, ownerId: 5},{id: 3, ownerId: 12}]\n```\n\n[can-set.props] has helper functions that make common [can-set.compares]\nconfigurations.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.compares"
              }
            ],
            "name": "compares",
            "description": "Each argument is a compares. These\nare returned by the functions on [can-set.props] or can be created\nmanually.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.Algebra"
            }
          ],
          "description": "Returns an instance of an algebra.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "name": "compares",
      "description": "Each argument is a compares. These\nare returned by the functions on [can-set.props] or can be created\nmanually.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.Algebra"
        }
      ],
      "description": "Returns an instance of an algebra.\n"
    }
  },
  "can-set.prop": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.comparator.md"
    },
    "body": "\n",
    "description": "\n",
    "type": "typedef",
    "title": "Prop",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-set.prop",
    "parent": "can-set.types",
    "signatures": [
      {
        "code": "prop(aValue, bValue, a, b, prop, algebra)",
        "description": "\n\nA prop function returns algebra values for two values for a given property.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "aValue",
            "description": "The value of A's property in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "bValue",
            "description": "The value of A's property in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "a",
            "description": "The A set in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "b",
            "description": "The B set in a set difference A and B (A  B)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "Boolean"
            }
          ],
          "description": "A prop function should either return a Boolean which indicates if `aValue` and `bValue` are\nequal or an `AlgebraResult` object that details information about the union, intersection, and difference of `aValue` and `bValue`.\n\nAn `AlgebraResult` object has the following values:\n\n- `union` - A value the represents the union of A and B.\n- `intersection` - A value that represents the intersection of A and B.\n- `difference` - A value that represents all items in A that are not in B.\n- `count` - The count of the items in A.\n\nFor example, if you had a `colors` property and A is `[\"Red\",\"Blue\"]` and B is `[\"Green\",\"Yellow\",\"Blue\"]`, the\nAlgebraResult object might look like:\n\n```js\n{\n  union: [\"Red\",\"Blue\",\"Green\",\"Yellow\"],\n  intersection: [\"Blue\"],\n  difference: [\"Red\"],\n  count: 2000\n}\n```\n\nThe count is `2000` because there might be 2000 items represented by colors \"Red\" and \"Blue\".  Often\nthe real number can not be known.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "b",
      "description": "The B set in a set difference A and B (A  B)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Boolean"
        }
      ],
      "description": "A prop function should either return a Boolean which indicates if `aValue` and `bValue` are\nequal or an `AlgebraResult` object that details information about the union, intersection, and difference of `aValue` and `bValue`.\n\nAn `AlgebraResult` object has the following values:\n\n- `union` - A value the represents the union of A and B.\n- `intersection` - A value that represents the intersection of A and B.\n- `difference` - A value that represents all items in A that are not in B.\n- `count` - The count of the items in A.\n\nFor example, if you had a `colors` property and A is `[\"Red\",\"Blue\"]` and B is `[\"Green\",\"Yellow\",\"Blue\"]`, the\nAlgebraResult object might look like:\n\n```js\n{\n  union: [\"Red\",\"Blue\",\"Green\",\"Yellow\"],\n  intersection: [\"Blue\"],\n  difference: [\"Red\"],\n  count: 2000\n}\n```\n\nThe count is `2000` because there might be 2000 items represented by colors \"Red\" and \"Blue\".  Often\nthe real number can not be known.\n"
    }
  },
  "can-set/Set": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.Set.md"
    },
    "body": "\n",
    "description": "\nAn object that represents a set of data.\n",
    "type": "typedef",
    "title": "Set",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nA `Set` is a plain JavaScript object used to represent a\n[https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation set] of data usually returned by the server.  For example,\na list of all completed todos might be represented by:\n\n```\n{complete: true}\n```\n\nThis set might be passed to [can-connect/can/map/map.getList] like:\n\n```\nTodo.getList({complete: true})\n```\n\nA [can-set.Algebra] is used to detail the behavior of these sets like:\n\n```\nvar todoAlgebra = new set.Algebra(\n  set.props.boolean(\"complete\")    \n);\n```\n\nUsing an algebra, all sorts of special behaviors can be performed:\n\n```\ntodoAlgebra.union({complete: true}, {complete: false}) //-> {}\n```\n"
      }
    ],
    "name": "can-set/Set",
    "parent": "can-set.types"
  },
  "can-set.types": {
    "name": "can-set.types",
    "title": "types",
    "type": "group",
    "parent": "can-set",
    "description": "",
    "order": 0
  },
  "can-set.properties": {
    "name": "can-set.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-set",
    "description": "",
    "order": 0
  },
  "can-set": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.md"
    },
    "body": "\n## Use\n\nA [can-set/Set] is a plain JavaScript object used to represent a\n[https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation set] of data usually sent to the server to fetch a list of records.  For example,\na list of all completed todos might be represented by:\n\n```\n{complete: true}\n```\n\nThis set might be passed to [can-connect/can/map/map.getList] like:\n\n```\nTodo.getList({complete: true})\n```\n\nAn [can-set.Algebra] is used to detail the behavior of these sets,\noften using already provided [can-set.props] comparators:\n\n```\nvar todoAlgebra = new set.Algebra(\n  set.props.boolean(\"complete\"),\n  set.props.id(\"_id\")\n);\n```\n\nUsing an algebra, all sorts of special behaviors can be performed. For\nexample, if we already loaded the incomplete todos (`{complete: false}`) and\nwanted to load all todos (`{}`), we could use a set [can-set.Algebra.prototype.difference] to figure out how to load\nonly the data that hasn't been loaded.\n\n```js\ntodoAlgebra.difference({}, {complete: false}) //-> {complete: true}\n```\n\nThese algebra's are typically used internally by either [can-connect] or\n[can-fixture] to provide these special behaviors:\n\n```js\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{\n  algebra: todoAlgebra\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/cache-requests/cache-requests\")\n],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\",\n  algebra: todoAlgebra\n});\n```\n\n```js\nvar todoStore = fixture.store([\n    { _id : 1, name : 'Do the dishes', complete: true },\n    { _id : 2, name : 'Walk the dog', complete: false }\n  ],\n  todoAlgebra );\n\nfixture(\"/todos/{_id}\", todoStore);\n```\n\nThe best way to think about `can-set` is that its a way to detail\nthe behavior of your service layer so other utilities can benefit.\n\n## Solving Common Issues\n\nConfiguring the proper `set.Algebra` can be tricky.  The best way to make sure you\nhave things working is to create an algebra and make sure some of the basics\nwork.  \n\nThe most common problem is that your `algebra` isn't configured to know what\ninstance data belongs in which set.  \n\nFor example, `{id: 1, name: \"do dishes\"}` should belong to the\nset `{sort: \"name asc\"}`, but it doesn't:\n\n```js\nvar algebra = new set.Algebra();\nalgebra.has({sort: \"name asc\"}, {id: 1, name: \"do dishes\"}) //-> false\n```\n\nThe fix is to either ignore `sort` like:\n\n```js\nvar algebra = new set.Algebra({\n    sort: function() { return true; }\n});\nalgebra.has({sort: \"name asc\"}, {id: 1, name: \"do dishes\"}) //-> false\n```\n\nOr even better, make `sort` actually able to understand sorting:\n\n```js\nvar algebra = new set.Algebra(\n    set.props.sort(\"sort\")\n);\nalgebra.has({sort: \"name asc\"}, {id: 1, name: \"do dishes\"}) //-> true\n```\n\nSimilarly, you can verify that [can-set.Algebra.prototype.getSubset]\nworks.  The following, with a default algebra gives\nthe wrong results:\n\n```js\nvar algebra = new set.Algebra();\nalgebra.getSubset(\n    {offset: 1, limit: 2},\n    {},\n    [\n        {id: 1, name: \"do dishes\"}\n        {id: 2, name: \"mow lawn\"},\n        {id: 3, name: \"trash\"}]) //-> []\n```\n\nThis is because it's looking for instance data where `offset===1` and `limit===2`.\nAgain, you can teach your algebra what to do with these properties like:\n\n```js\nvar algebra = new set.Algebra(\n    set.props.offsetLimit(\"offset\",\"limit\")\n);\nalgebra.getSubset(\n    {offset: 1, limit: 2},\n    {},\n    [\n        {id: 1, name: \"do dishes\"}\n        {id: 2, name: \"mow lawn\"},\n        {id: 3, name: \"trash\"}]) //-> [\n            //  {id: 2, name: \"mow lawn\"},\n            // {id: 3, name: \"trash\"}\n            // ]\n```\n\n",
    "description": " \ncan-set is a utility for comparing [can-set/Set sets] that are represented by the parameters commonly passed to service requests.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nOnce you've imported the `can-set` module into your project, use it to create a `set.Algebra` and then use that to compare and perform operations on sets.  \n\n```js\nvar set = require('can-set');\n// create an algebra\nvar algebra = new set.Algebra(\n    // specify the unique identifier on data\n    set.props.id(\"_id\"),  \n    // specify that completed can be true, false or undefined\n    set.props.boolean(\"completed\"),\n    // specify properties that define pagination\n    set.props.rangeInclusive(\"start\",\"end\"),\n    // specify the property that controls sorting\n    set.props.sort(\"orderBy\"),\n)\n\n// compare two sets\nalgebra.subset({start: 2, end: 3}, {start: 1, end: 4}) //-> true\nalgebra.difference({} , {completed: true}) //-> {completed: false}\n\n// perform operations on sets\nalgebra.getSubset({start: 2,end: 3},{start: 1,end: 4},\n            [{id: 1},{id: 2},{id: 3},{id: 4}])\n//-> [{id: 2},{id: 3}]\n```\n"
      }
    ],
    "name": "can-set",
    "parent": "can-data-modeling",
    "collection": "can-core",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-set/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "^1.0.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Set logic for CanJS",
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.7.0",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-set",
      "keywords": [
        "canjs"
      ],
      "license": "MIT",
      "main": "src/set.js",
      "name": "can-set",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-set.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint src/. --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "plugins": [
          "steal-qunit"
        ]
      },
      "version": "1.3.2"
    },
    "comment": " "
  },
  "can-set.compares": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.compares.md"
    },
    "body": "\n",
    "description": "An object of property names and `prop` functions. \n```js\n{\n  // return `true` if the values should be considered the same:\n  lastName: function(aValue, bValue){\n    return (\"\"+aValue).toLowerCase() === (\"\"+bValue).toLowerCase();\n  }\n}\n```\n\n\n",
    "type": "typedef",
    "title": "Compares",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-set.prop"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-set.compares",
    "parent": "can-set.types"
  },
  "exports": {
    "name": "exports",
    "type": "property",
    "parent": "node_modules/can-set/src/clause.js",
    "src": {
      "line": 5,
      "codeLine": 13,
      "path": "node_modules/can-set/src/clause.js"
    },
    "body": "\nnew clause.Where()\n\nThis is so we can tell what type of clause some properties are for.\n\n",
    "description": "Exports a clause constructor functions like:\n",
    "hide": true
  },
  "subsetComparesType": {
    "type": "function",
    "name": "subsetComparesType",
    "params": [
      {
        "name": "a",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "b",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "aParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "bParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "prop",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "compares",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-set/src/compare.js",
    "src": {
      "line": 197,
      "codeLine": 203,
      "path": "node_modules/can-set/src/compare.js"
    },
    "body": " \n",
    "description": "Checks if A is a subset of B.  If A is a subset of B if:\n- A \\ B = undefined\n- A ∩ B = defined\n- B ∩ A = defined\n"
  },
  "properSubsetComparesType": {
    "type": "function",
    "name": "properSubsetComparesType",
    "params": [
      {
        "name": "a",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "b",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "aParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "bParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "prop",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "compares",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-set/src/compare.js",
    "src": {
      "line": 264,
      "codeLine": 268,
      "path": "node_modules/can-set/src/compare.js"
    },
    "body": " \n",
    "description": "Checks if A is a subset of B.  If A is a subset of B, A \\ B will be undefined. But B \\ A will be defined.\n",
    "hide": true
  },
  "can-set.props": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.props.md"
    },
    "body": "",
    "description": "Contains a collection of prop generating functions. \nThe following functions create `compares` objects that can be mixed together to create a set `Algebra`.\n\n```js\nvar set = require(\"can-set\");\nvar algebra = new set.Algebra(\n  {\n    // ignore this property in set algebra\n    sessionId:  function(){ return true }\n  },\n  set.props.boolean(\"completed\"),\n  set.props.rangeInclusive(\"start\",\"end\")\n);\n```\n\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "props",
    "name": "can-set.props",
    "type": "property",
    "parent": "can-set.properties"
  },
  "can-set.props.enum": {
    "type": "function",
    "name": "can-set.props.enum",
    "parent": "can-set.props",
    "src": {
      "line": 136,
      "codeLine": 148,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "\n",
    "title": "enum",
    "signatures": [
      {
        "code": "set.props.enum(property, propertyValues)",
        "description": "\n\nMakes a prop for a set of values.\n\n```\nvar compare = set.props.enum(\"type\", [\"new\",\"accepted\",\"pending\",\"resolved\"])\n```\n ",
        "params": []
      }
    ]
  },
  "can-set.props.boolean": {
    "type": "function",
    "name": "can-set.props.boolean",
    "parent": "can-set.props",
    "src": {
      "line": 256,
      "codeLine": 278,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports boolean properties. \n",
    "title": "boolean",
    "signatures": [
      {
        "code": "set.props.boolean(property)",
        "description": "\n\nMakes a compare object with a `property` function that has the following logic:\n\n```js\nA(true) ∪ B(false) = undefined\n\nA(undefined) \\ B(true) = false\nA(undefined) \\ B(false) = true\n```\n\nIt understands that `true` and `false` are complementary sets that combined to `undefined`. Another way to think of this is that if you load `{complete: false}` and `{complete: true}` you've loaded `{}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The name of the boolean property."
          },
          {
            "types": [
              {
                "type": "can-set.compares"
              }
            ],
            "name": "A",
            "description": "`Compares` object that can be an argument to [can-set.Algebra]\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "name": "A",
      "description": "`Compares` object that can be an argument to [can-set.Algebra]\n "
    }
  },
  "can-set.props.sort": {
    "type": "function",
    "name": "can-set.props.sort",
    "parent": "can-set.props",
    "src": {
      "line": 303,
      "codeLine": 333,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Defines the sortable property and behavior. \n",
    "title": "sort",
    "signatures": [
      {
        "code": "set.props.sort(prop, [sortFunc])",
        "description": "\n\nDefines the sortable property and behavior.\n\n```js\nvar algebra = new set.Algebra(set.props.sort(\"sortBy\"));\nalgebra.index(\n  {sortBy: \"name desc\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 1\n\nalgebra.index(\n  {sortBy: \"name\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "The sortable property."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "sortPropValue"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "item1"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "item2"
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "sortFunc",
            "description": "The\nsortable behavior. The default behavior assumes the sort property value\nlooks like `PROPERTY DIRECTION` (ex: `name desc`)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "sortPropValue"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "item1"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "item2"
                }
              ]
            }
          ]
        }
      ],
      "optional": true,
      "name": "sortFunc",
      "description": "The\nsortable behavior. The default behavior assumes the sort property value\nlooks like `PROPERTY DIRECTION` (ex: `name desc`)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
    }
  },
  "can-set.props.id": {
    "type": "function",
    "name": "can-set.props.id",
    "parent": "can-set.props",
    "src": {
      "line": 341,
      "codeLine": 370,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Defines the identify property. \n",
    "title": "id",
    "signatures": [
      {
        "code": "set.props.id(prop)",
        "description": "\n\nDefines the property name on items that uniquely\nidentifies them. This is the default sorted property if no\n[can-set.props.sort] is provided.\n\n```js\nvar algebra = new set.Algebra(set.props.id(\"_id\"));\nalgebra.index(\n  {sortBy: \"name desc\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 1\n\nalgebra.index(\n  {sortBy: \"name\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "The property name that defines the unique property id."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "prop",
      "description": "The property name that defines the unique property id."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
    }
  },
  "can-set.props.offsetLimit": {
    "type": "function",
    "name": "can-set.props.offsetLimit",
    "parent": "can-set.props",
    "src": {
      "line": 407,
      "codeLine": 427,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports sets that include a limit and offset. \n",
    "title": "offsetLimit",
    "signatures": [
      {
        "code": "set.props.offsetLimit( [offsetProperty][, limitProperty] )",
        "description": "\n\nMakes a prop for two ranged properties that specify a range of items\nthat includes both the offsetProperty and limitProperty.  For example, set like:\n`{offset: 20, limit: 10}` loads 10 items starting at index 20.\n\n```\nnew set.Algebra( set.props.offsetLimit(\"offset\",\"limit\") );\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "offsetProperty",
            "description": "The offset property name on sets.  Defaults to `\"offset\"` if none is provided."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "limitProperty",
            "description": "The offset limit name on sets. Defaults to `\"limit\"` if none is provided."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a comparator used to build a set algebra.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "limitProperty",
      "description": "The offset limit name on sets. Defaults to `\"limit\"` if none is provided."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a comparator used to build a set algebra.\n"
    }
  },
  "can-set.props.rangeInclusive": {
    "type": "function",
    "name": "can-set.props.rangeInclusive",
    "parent": "can-set.props",
    "src": {
      "line": 439,
      "codeLine": 459,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports ranged properties. \n",
    "title": "rangeInclusive",
    "signatures": [
      {
        "code": "set.props.rangeInclusive(startIndexProperty, endIndexProperty)",
        "description": "\n\nMakes a prop for two ranged properties that specify a range of items\nthat includes both the startIndex and endIndex.  For example, a range of\n[0,20] loads 21 items.\n\n```\nset.props.rangeInclusive(\"start\",\"end\")\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "startIndexProperty",
            "description": "The starting property name"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "endIndexProperty",
            "description": "The ending property name"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a prop\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "endIndexProperty",
      "description": "The ending property name"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a prop\n"
    }
  },
  "can-set.props.dotNotation": {
    "type": "function",
    "name": "can-set.props.dotNotation",
    "parent": "can-set.props",
    "src": {
      "line": 496,
      "codeLine": 514,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports MongoDB-style 'dot notation' properties. \n",
    "title": "dotNotation",
    "signatures": [
      {
        "code": "set.props.dotNotation(dotProperty)",
        "description": "\n\nDefines a property that specifies a MongoDB-style nested property match.\nFor example, a set property of \"address.city\" matches against the value of the nested `{address: {city}}` value.\n\n```\nset.props.dotNotation(\"address.city\")\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "dotProperty",
            "description": "The MongoDB-style nested property name"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a comparator used to build a set algebra\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "dotProperty",
      "description": "The MongoDB-style nested property name"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a comparator used to build a set algebra\n"
    }
  },
  "can-set.Translate": {
    "type": "function",
    "name": "can-set.Translate",
    "parent": "can-set.properties",
    "src": {
      "line": 9,
      "codeLine": 33,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "",
    "title": "Translate",
    "signatures": [
      {
        "code": "new set.Translate(clauseType, propertyName)",
        "description": "\n\nLocalizes a clause's properties within another nested property.\n\n```js\nvar algebra = new set.Algebra(\n  new set.Translate(\"where\",\"$where\")\n);\nalgebra.has(\n  {$where: {complete: true}},\n  {id: 5, complete: true}\n) //-> true\n```\n\nThis is useful when filters (which are `where` clauses) are\nwithin a nested object.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "clause",
            "description": "A clause type.  One of `'where'`, `'order'`, `'paginate'`, `'id'`."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "propertyName",
            "description": "The property name which contains the clauses's properties."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "A set compares object that can do the translation.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "propertyName",
      "description": "The property name which contains the clauses's properties."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "A set compares object that can do the translation.\n"
    }
  },
  "Algebra": {
    "type": "function",
    "name": "Algebra",
    "params": [],
    "parent": "node_modules/can-set/src/set-core.js",
    "src": {
      "line": 49,
      "codeLine": 57,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "\nnew set.Algebra(Where(),Paginate(),Sort())\n\n\n",
    "description": "An `Algebra` internally keeps different properties organized by clause type.\nIf an object comes in that isn't a clause type, it's assuemd to be a where.\n",
    "hide": true
  },
  "can-set.Algebra.prototype.equal": {
    "type": "function",
    "name": "can-set.Algebra.prototype.equal",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 254,
      "codeLine": 270,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "equal",
    "signatures": [
      {
        "code": "algebra.equal(a, b)",
        "description": "\n\n  Returns true if the two sets the exact same.\n\n  ```js\n  algebra.equal({type: \"critical\"}, {type: \"critical\"}) //-> true\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the two sets are equal.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the two sets are equal.\n "
    }
  },
  "can-set.Algebra.prototype.subset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.subset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 273,
      "codeLine": 290,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "subset",
    "signatures": [
      {
        "code": "algebra.subset(a, b)",
        "description": "\n\nReturns true if _A_ is a subset of _B_ or _A_ is equal to _B_ (_A_ ⊆ _B_).\n\n```js\nalgebra.subset({type: \"critical\"}, {}) //-> true\nalgebra.subset({}, {}) //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `a` is a subset of `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `a` is a subset of `b`.\n "
    }
  },
  "can-set.Algebra.prototype.properSubset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.properSubset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 313,
      "codeLine": 330,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "properSubset",
    "signatures": [
      {
        "code": "algebra.properSubset(a, b)",
        "description": "\n\nReturns true if _A_ is a strict subset of _B_ (_A_ ⊂ _B_).\n\n```js\nalgebra.properSubset({type: \"critical\"}, {}) //-> true\nalgebra.properSubset({}, {}) //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `a` is a subset of `b` and not equal to `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `a` is a subset of `b` and not equal to `b`.\n "
    }
  },
  "can-set.Algebra.prototype.difference": {
    "type": "function",
    "name": "can-set.Algebra.prototype.difference",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 333,
      "codeLine": 365,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "difference",
    "signatures": [
      {
        "code": "algebra.difference(a, b)",
        "description": "\n\nReturns a set that represents the difference of sets _A_ and _B_ (_A_ \\ _B_), or\nreturns if a difference exists.\n\n```js\nalgebra1 = new set.Algebra(set.props.boolean(\"completed\"));\nalgebra2 = new set.Algebra();\n\n// A has all of B\nalgebra1.difference( {} , {completed: true} ) //-> {completed: false}\n\n// A has all of B, but we can't figure out how to create a set object\nalgebra2.difference( {} , {completed: true} ) //-> true\n\n// A is totally inside B\nalgebra2.difference( {completed: true}, {} )  //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set/Set"
            },
            {
              "type": "Boolean"
            }
          ],
          "description": "If an object is returned, it is difference of sets _A_ and _B_ (_A_ \\ _B_).\n\nIf `true` is returned, that means that _B_ is a subset of _A_, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is no difference or the sets are not comparable.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set/Set"
        },
        {
          "type": "Boolean"
        }
      ],
      "description": "If an object is returned, it is difference of sets _A_ and _B_ (_A_ \\ _B_).\n\nIf `true` is returned, that means that _B_ is a subset of _A_, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is no difference or the sets are not comparable.\n "
    }
  },
  "can-set.Algebra.prototype.union": {
    "type": "function",
    "name": "can-set.Algebra.prototype.union",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 397,
      "codeLine": 418,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "union",
    "signatures": [
      {
        "code": "algebra.union(a, b)",
        "description": "\n\nReturns a set that represents the union of _A_ and _B_ (_A_ ∪ _B_).\n\n```js\nalgebra.union(\n  {start: 0, end: 99},\n  {start: 100, end: 199},\n) //-> {start: 0, end: 199}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set/Set"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If an object is returned, it is the union of _A_ and _B_ (_A_ ∪ _B_).\n\nIf `undefined` is returned, it means a union can't be created.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set/Set"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If an object is returned, it is the union of _A_ and _B_ (_A_ ∪ _B_).\n\nIf `undefined` is returned, it means a union can't be created.\n "
    }
  },
  "can-set.Algebra.prototype.intersection": {
    "type": "function",
    "name": "can-set.Algebra.prototype.intersection",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 422,
      "codeLine": 447,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "intersection",
    "signatures": [
      {
        "code": "algebra.intersection(a, b)",
        "description": "\n\nReturns a set that represents the intersection of sets _A_ and _B_ (_A_ ∩ _B_).\n\n```js\nalgebra.intersection(\n  {completed: true, due: \"tomorrow\"},\n  {completed: true, type: \"critical\"},\n) //-> {completed: true, due: \"tomorrow\", type: \"critical\"}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "["
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "["
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set/Set"
            },
            {
              "type": "Boolean"
            }
          ],
          "description": "If an object is returned, it\nrepresents the intersection of sets _A_ and _B_ (_A_ ∩ _B_).\n\nIf `true` is returned, that means that an intersection exists, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is intersection.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "["
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set/Set"
        },
        {
          "type": "Boolean"
        }
      ],
      "description": "If an object is returned, it\nrepresents the intersection of sets _A_ and _B_ (_A_ ∩ _B_).\n\nIf `true` is returned, that means that an intersection exists, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is intersection.\n "
    }
  },
  "can-set.Algebra.prototype.count": {
    "type": "function",
    "name": "can-set.Algebra.prototype.count",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 451,
      "codeLine": 472,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "count",
    "signatures": [
      {
        "code": "algebra.count(set)",
        "description": "\n\nReturns the number of items that might be loaded by the `set`. This makes use of set.Algebra's\nBy default, this returns Infinity.\n\n```js\nvar algebra =  new set.Algebra({\n  set.props.rangeInclusive(\"start\", \"end\")\n});\nalgebra.count({start: 10, end: 19}) //-> 10\nalgebra.count({}) //-> Infinity\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "[description]"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of items in the set if known, `Infinity`\nif unknown.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "[description]"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of items in the set if known, `Infinity`\nif unknown.\n "
    }
  },
  "can-set.Algebra.prototype.has": {
    "type": "function",
    "name": "can-set.Algebra.prototype.has",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 475,
      "codeLine": 498,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "has",
    "signatures": [
      {
        "code": "algebra.has(set, props)",
        "description": "\n\nUsed to tell if the `set` contains the instance object `props`.\n\n```\nvar algebra = new set.Algebra(\n  new set.Translate(\"where\",\"$where\")\n);\nalgebra.has(\n  {\"$where\": {playerId: 5}},\n  {id: 5, type: \"3pt\", playerId: 5, gameId: 7}\n) //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An instance's raw data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Returns `true` if `props` belongs in `set` and\n`false` it not.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An instance's raw data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Returns `true` if `props` belongs in `set` and\n`false` it not.\n "
    }
  },
  "can-set.Algebra.prototype.index": {
    "type": "function",
    "name": "can-set.Algebra.prototype.index",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 529,
      "codeLine": 558,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "index",
    "signatures": [
      {
        "code": "algebra.index(set, items, item)",
        "description": "\n\nReturns where `item` should be inserted into `items` which is represented by `set`.\n\n```js\nalgebra = new set.Algebra(\n  set.props.sort(\"orderBy\")\n);\nalgebra.index(\n  {orderBy: \"age\"},\n  [{id: 1, age: 3},{id: 2, age: 5},{id: 3, age: 8},{id: 4, age: 10}],\n  {id: 6, age: 3}\n)  //-> 2\n```\n\nThe default sort property is what is specified by\n[can-set.props.id]. This means if that if the sort property\nis not specified, it will assume the set is sorted by the specified\nid property.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The `set` that describes `items`."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "items",
            "description": "An array of data objects."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "item",
            "description": "The data object to be inserted."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The position to insert `item`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "item",
      "description": "The data object to be inserted."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The position to insert `item`.\n "
    }
  },
  "can-set.Algebra.prototype.getSubset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.getSubset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 582,
      "codeLine": 606,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "getSubset",
    "signatures": [
      {
        "code": "algebra.getSubset(a, b, bData)",
        "description": "\n\nGets `a` set's items given a super set `b` and its items.\n\n```js\nalgebra.getSubset(\n  {type: \"dog\"},\n  {},\n  [{id: 1, type:\"cat\"},\n   {id: 2, type: \"dog\"},\n   {id: 3, type: \"dog\"},\n   {id: 4, type: \"zebra\"}]\n) //-> [{id: 2, type: \"dog\"},{id: 3, type: \"dog\"}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "The set whose data will be returned."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A superset of set `a`."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "bData",
            "description": "The data in set `b`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The data in set `a`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "bData",
      "description": "The data in set `b`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "The data in set `a`.\n "
    }
  },
  "can-set.Algebra.prototype.getUnion": {
    "type": "function",
    "name": "can-set.Algebra.prototype.getUnion",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 622,
      "codeLine": 648,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "getUnion",
    "signatures": [
      {
        "code": "algebra.getUnion(a, b, aItems, bItems)",
        "description": "\n\nUnifies items from set A and setB into a single array of items.\n\n```js\nalgebra = new set.Algebra(\n  set.props.rangeInclusive(\"start\",\"end\")\n);\nalgebra.getUnion(\n  {start: 1,end: 2},\n  {start: 2,end: 4},\n  [{id: 1},{id: 2}],\n  [{id: 2},{id: 3},{id: 4}]);\n  //-> [{id: 1},{id: 2},{id: 3},{id: 4}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "aItems",
            "description": "Set `a`'s items."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "bItems",
            "description": "Set `b`'s items."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns items in both set `a` and set `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "bItems",
      "description": "Set `b`'s items."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns items in both set `a` and set `b`.\n "
    }
  },
  "can-set.Algebra.prototype.id": {
    "type": "function",
    "name": "can-set.Algebra.prototype.id",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 696,
      "codeLine": 723,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "id",
    "signatures": [
      {
        "code": "algebra.id(props)",
        "description": "\n\nReturns the configured `id` property value from `props`.  If there are\nmultiple ids, a `JSON.stringify`-ed JSON object is returned with each\n[can-set.props.id] value is returned.\n\n```js\nvar algebra1 = new set.Algebra(set.props.id(\"_id\"));\nalgebra1.id({_id: 5}) //-> 5\n\nvar algebra2 = new set.Algebra(\n  set.props.id(\"studentId\"),\n  set.props.id(\"classId\")\n);\n\nalgebra2.id({studentId: 6, classId: \"7\", foo: \"bar\"})\n    //-> '{\"studentId\": 6, \"classId\": \"7\"}'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An instance's raw data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "String"
            }
          ],
          "description": "If a single [can-set.props.id] is configured, it's value will be returned.\nIf multiple [can-set.props.id] properties are configured a `JSON.stringify`-ed object is returned.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An instance's raw data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "String"
        }
      ],
      "description": "If a single [can-set.props.id] is configured, it's value will be returned.\nIf multiple [can-set.props.id] properties are configured a `JSON.stringify`-ed object is returned.\n "
    }
  },
  "can-stache.scopeAndContext": {
    "src": {
      "path": "node_modules/can-stache/docs/context.md"
    },
    "body": "\nEvery part of a stache template is rendered with a\ngiven [can-view-scope scope]. The scope is used to lookup\nvalues. A scope can contain multiple places to lookup values. Each of those\nplaces is called a `context`.  \n\nThis is very similar to how `last` is looked up in the following JavaScript:\n\n```js\nvar message = \"Hello\"\nfunction outer(){\n\tvar last = \"Abril\";\n\n\tfunction inner(){\n\t\tvar first = \"Alexis\";\n\t\tconsole.log(message + \" \"+ first + \" \" + last);\n\t}\n\tinner();\n}\nouter();\n```\n\nJavaScript looks for `last` looks in the `inner` context and then walks up the\nscope to the `outer` context to find a `last` variable.\n\n\nLets look at what happens with the scope the following example:\n\n```\nTemplate:\n\t<h1>{{message}} {{#person}}{{first}} {{last}}{{/person}}</h1>\n\nData:\n\t{\n\t  person: { first: \"Alexis\" },\n\t  last: \"Abril\",\n\t  message: \"Hello\"\n    }\n\nResult:\n\t<h1>Hello Alexis Abril</h1>\n```\n\n1. The template is rendered with `Data` as the only item in the scope. `scope:[Data]`\n2. `{{message}}` is looked up within `Data`.\n3. `{{#person}}` adds the `person` context to the top of the scope. `scope:[Data,Data.person]`\n4. `{{first}}` is looked up in the scope.  It will be found on `Data.person`.\n5. `{{last}}` is looked up in the scope.  \n   1. `last` is looked in `Data.person`, it's not found.\n   2. `last` is looked up in `Data` and returned.\n6. `{{/person}}` removes `person` from the scope. `scope:[Data]`\n\n\n\nThe context used to lookup a value can be controlled with adding `../` or `./` before a\nkey. For instance, if we wanted to make sure `last` was only going to lookup on `person`,\nwe could change the template to:\n\n```\nTemplate:\n\t<h1>{{message}} {{#person}}{{first}} {{./last}}{{/person}}</h1>\n\nData:\n\t{\n\t  person: { first: \"Alexis\" },\n\t  last: \"Abril\",\n\t  message: \"Hello\"\n\t}\n\nResult:\n\t<h1>Hello Alexis</h1>\n```\n\n[can-stache.tags.section Sections], [can-stache.Helpers Helpers],\nand [can-component custom elements] can modify the scope used to render a subsection.\n\n[can-stache.key] modifiers  like `../` and `@key` can control the context and value that\ngets returned.\n\n## Preventing Scope Walking\n\nIn order to prevent walking up the scope, you can explicitly choose the context a value is read from.\n\nAs mentioned above, you can explicitly read from the current context using `./` before the key:\n\n```\nTemplate:\n\t<h1>{{message}} {{#person}}{{first}} {{./last}}{{/person}}</h1>\n\nData:\n\t{\n\t  person: { first: \"Alexis\" },\n\t  last: \"Abril\",\n\t  message: \"Hello\"\n    }\n\nResult:\n\t<h1>Hello Alexis</h1>\n```\n\nYou can also explicitly read from the parent context using `../`:\n\n```\nTemplate:\n\t<h1>{{#person}}{{../message}} {{first}}{{/person}}</h1>\n\nData:\n\t{\n\t  person: { first: \"Alexis\", message: \"Hello\" },\n\t  message: \"Hi\"\n\t}\n\nResult:\n\t<h1>Hi Alexis</h1>\n```\n\nYou can also create unique scope variables using [Hash Expressions](https://canjs.com/doc/can-stache/expressions/hash.html).\n\nin the [`{{#each}}`](http://localhost/canjs/doc/can-stache.helpers.each.html#___eachEXPRESSIONHASH_EXPRESSION__FN__else__INVERSE___each__) helper:\n\n```\n{{#each(todos, todo=value num=index)}}\n\t<li data-index=\"{{num}}\">{{todo.name}}</li>\n{{/each}}\n```\n\nand the [`{{#with}}`](https://canjs.com/doc/can-stache.helpers.with.html#___withHASHES__BLOCK___with__) helper:\n\n```\n{{#with(street=person.address.street city=person.address.city)}}\n    Street: {{street}}\n\tCity: {{city}}\n{{/with}}\n```\n\nYou can also always read from the root scope using `scope.root`. This allows you to read data from the context you passed to your renderer function even in loops or recursive templates:\n\n```\n<span>{{scope.root.message}}{{name}}</span>\n{{#./child}}\n\t<div>\n\t\t{{>*self}}\n\t</div>\n{{/child}}\n```\n\n",
    "description": "\n",
    "name": "can-stache.scopeAndContext",
    "title": "Scope and Context",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 1,
    "comment": " "
  },
  "can-stache.Acquisition": {
    "src": {
      "path": "node_modules/can-stache/docs/acquisition.md"
    },
    "body": "\n## Raw Text\n\nRaw text can be templated by passing the text containing your template.  For example:\n\n\tvar text = \"My body lies over the {{.}}\",\n\t\ttemplate = stache(text),\n\t\tfragment = template(\"ocean\");\n\n\tdocument.body.appendChild(fragment);\n\n## Module Loaders\n\nFor [http://stealjs.com StealJS], use [steal-stache] to import stache templates directly.\n\n\n## Script Tags\n\nYou can embed a `<script>` tag and use its text as a stache template like:\n\n```html\n<script type='text/stache' id='my-template'>\n  <h1>{{message}}</h1>\n</script>\n```\n\nLoad this template like:\n\n```js\nvar stache = require(\"can-stache\");\nvar text = document.getElementById(\"my-template\");\nvar template = stache(text);\n```\n\n",
    "description": "\nThere are number of ways to acquire templates such as: raw text,\na module loader, or script tags in the markup.\n",
    "name": "can-stache.Acquisition",
    "title": "Template Acquisition",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 3
  },
  "can-stache.from": {
    "src": {
      "path": "node_modules/can-stache/docs/from.md"
    },
    "body": "\n",
    "description": "Return a template loaded from an element. \n",
    "title": "from",
    "name": "can-stache.from",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.from(id)",
        "description": "\n\nLoad a template from an HTML element (usually a `<script>` element)\nspecified by id.  This is used typically for demo purposes.\n\nFor example, with a `<script>` tag as follows in your HTML:\n\n```\n<script type='text/stache' id='my-template'>\n<h1>{{message}}</h1>\n</script>\n```\n\nLoad and render that template like:\n\n```\nvar template = stache.from(\"my-template\");\ntemplate({message: \"Hello There!\"});\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "id",
            "description": "The id of the element, whose `innerHTML` will be used to create a template."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A renderer function that will render the\ntemplate.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "id",
      "description": "The id of the element, whose `innerHTML` will be used to create a template."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A renderer function that will render the\ntemplate.\n"
    },
    "comment": " "
  },
  "can-stache.getterSetter": {
    "src": {
      "path": "node_modules/can-stache/docs/getterSetter.md"
    },
    "body": "\n",
    "description": "The getterSetter argument passed to [can-stache.registerConverter registerConverter]. \n",
    "type": "typedef",
    "title": "getterSetter",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "description": "Takes the arguments from a [can-stache/expressions/call]\nand returns a value.\n\nAn argument is a compute if the argument has been marked with a tilde (`~`) prefix, otherwise the\nvalue of the argument is the same as the value of the corresponding scope property.\nAt least one argument should be a compute so `set` can update the value.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "args",
                    "variable": true
                  }
                ]
              }
            ]
          },
          {
            "name": "set",
            "description": "Takes the new value of the `left` side of a\n[can-stache-bindings.twoWay {(two-way)} binding] followed by the other arguments to the\n[can-stache/expressions/call].  This should change one of the compute arguments.\n\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "setValue"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "args",
                    "variable": true
                  }
                ]
              }
            ]
          }
        ],
        "description": "\n\nAn object with a `get` and `set` method that get converted to a two-way helper.\n\n```js\nstache.registerConverter(\"numberToString\", {\n get: function(fooCompute) {\n \treturn \"\" + fooCompute();\n },\n set: function(newVal, fooCompute) {\n \tfooCompute(+newVal);\n }\n});\n```\n\n\nA `getterSetter` object provides:\n\n - A `get` method that returns the value\n  of the `left` value given the arguments passed on the `right`.\n - a `set` method that updates one or multiple of the `right` arguments\n   computes given a new `left` value.\n"
      }
    ],
    "name": "can-stache.getterSetter",
    "parent": "can-stache.types",
    "comment": " "
  },
  "can-stache.helper": {
    "src": {
      "path": "node_modules/can-stache/docs/helper.md"
    },
    "body": "\n\n## Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create stache tags that have rich behavior.\n\nIf the helper is called __within a tag__ like:\n\n    <ul {{sortable}}/>\n\nThe returned function is called with the `<ul>` element:\n\n    stache.registerHelper(\"sortable\",function(){\n      return function(el){\n        $(el).slider();\n      }\n    });\n\nIf the helper is called __between tags__ like:\n\n    <ul>{{items}}</ul>\n\nThe returned function is called with a temporary text node:\n\n    stache.registerHelper(\"items\",function(){\n      return function(textNode){\n\t\t  // do something, probably replace textNode\n      }\n    });\n\nWhile this form of helper is still supported, it's more common\nto create similar functionality with [can-component] or [can-view-callbacks].\n\n",
    "description": "A helper function passed to [can-stache.registerHelper]. \nGiven the arguments, returns the content that should be shown in the DOM\nor a function that will be called on the DOM element the helper was\ncalled on.\n\n",
    "type": "typedef",
    "title": "helper",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            },
            {
              "type": "String"
            },
            {
              "type": "Array"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "Node"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The content to be inserted into the template or a callback function.  The content can be a:\n\n - `documentFragment` like those returned by [can-stache.helperOptions].fn.\n - `String` like `\"Hello World\"`\n - `Array` of strings and nodes like `[\"Hello\", document.createElement('div')]`\n\nIf a `function(Node)` is returned, it will be called back with an HTML Element or text node.  \n\nIf the helper is called on an element like:\n\n```\n<div {{myHelper}}>\n```\n\n... the callback function will be called with the `div`.  \n\nIf the helper is called\noutside of an element's tag like:\n\n```\n<div> {{myHelper}} </div>\n```\n\n... the callback function will be called with a placeholder text node.  \n\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-compute"
              }
            ],
            "optional": true,
            "variable": true,
            "name": "arg",
            "description": "Arguments passed from the tag. After the helper\nname, any space separated [can-stache.key keys], numbers or\nstrings are passed as arguments. [can-stache.key Keys] that\nread an observable value in [can-stache/expressions/helper helpers] are passed as [can-compute.computed]s .\n"
          },
          {
            "types": [
              {
                "type": "can-stache.helperOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "An options object\nthat is an additional argument in `Helper` expressions that is populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "can-stache.context"
            }
          ],
          "description": "The context the helper was\ncalled within.\n"
        }
      }
    ],
    "name": "can-stache.helper",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helperOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "An options object\nthat is an additional argument in `Helper` expressions that is populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        },
        {
          "type": "String"
        },
        {
          "type": "Array"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "description": "The content to be inserted into the template or a callback function.  The content can be a:\n\n - `documentFragment` like those returned by [can-stache.helperOptions].fn.\n - `String` like `\"Hello World\"`\n - `Array` of strings and nodes like `[\"Hello\", document.createElement('div')]`\n\nIf a `function(Node)` is returned, it will be called back with an HTML Element or text node.  \n\nIf the helper is called on an element like:\n\n```\n<div {{myHelper}}>\n```\n\n... the callback function will be called with the `div`.  \n\nIf the helper is called\noutside of an element's tag like:\n\n```\n<div> {{myHelper}} </div>\n```\n\n... the callback function will be called with a placeholder text node.  \n\n"
    },
    "comment": " "
  },
  "can-stache.helperOptions": {
    "src": {
      "path": "node_modules/can-stache/docs/helperOptions.md"
    },
    "body": "",
    "description": "The options argument passed to a [can-stache.helper helper function] when called by a [can-stache/expressions/helper].\n\n",
    "type": "typedef",
    "title": "helperOptions",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "fn",
            "description": "Renders the \"truthy\" subsection\nBLOCK.  `options.fn` is only available if the helper is called as a\n[can-stache.tags.section] or [can-stache.tags.inverse]. Read about\n[can-stache.sectionRenderer section renderer] for more information.\n",
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true
          },
          {
            "name": "inverse",
            "description": "Renders the \"falsey\" subsection\nINVERSE.  `options.inverse` is only available if the helper is called as a\n[can-stache.tags.section] or [can-stache.tags.inverse] and [can-stache.helpers.else]\nis used. Read about\n[can-stache.sectionRenderer section renderer] for more information.\n",
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true
          },
          {
            "name": "hash",
            "description": "An object containing all of the\n[can-stache.expressions Hash expression] keys and values. For example:\n\n```\n{{helper arg1 arg2 name=value other=3 position=\"top\"}}\n```\n\nmight provide a `hash` like:\n\n```\n{\n\t\tname: compute(\"Mr. Pig\"),\n\t\tother: 3,\n\t\tposition: \"top\"\n}\n```\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "context",
            "description": "The current context the stache helper is called within. Read\n[can-stache.scopeAndContext] for more information.\n\n",
            "types": [
              {
                "type": "*"
              }
            ]
          },
          {
            "name": "scope",
            "description": "An object that represents the current context and all parent\ncontexts. It can be used to look up [can-stache.key key] values in the current scope.\nRead [can-stache.scopeAndContext] and [can-view-scope] for more information.\n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "It can be used to look up [can-stache.key key] values in the current options scope.\nRead [can-stache.scopeAndContext] and [can-view-scope.Options] for more information.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          }
        ],
        "description": "\n\nWhen a [can-stache.helper helper function]\nis called by a [can-stache/expressions/helper], a `helperOptions`\nobject is passed with the following properties:\n\n```\nstache.registerHelper(\"myHelper\", function(helperOptions){\n  helperOptions.fn      //-> sectionRenderer(){}\n  helperOptions.inverse //-> sectionRenderer(){}\n  helperOptions.hash    //-> Object\n  helperOptions.context //-> *\n  helperOptions.scope   //-> Scope\n  helperOptions.option  //-> Scope.Options\n});\n```\n"
      }
    ],
    "name": "can-stache.helperOptions",
    "parent": "can-stache.types"
  },
  "can-stache.Binding": {
    "src": {
      "path": "node_modules/can-stache/docs/livebinding.md"
    },
    "body": "\nLive binding lets you focus on changing data and state without having to worry about also updating the\nDOM to reflect those changes.\n\nIn this example, we have a simple user welcome screen.\n\n\t<h1>Welcome {{user}}!</h1>\n\t<p>\n\t\t{{#if(messages)}}\n\t\t\tYou have {{messages}} new messages.\n\t\t{{else}}\n\t\t\tYou no messages.\n\t\t{{/messages}}\n\t</p>\n\n\tvar data = new DefineMap({\n\t\tuser: 'Tina Fey',\n\t\tmessages: 0\n\t});\n\n\tvar template = stache( document.getElementById(\"template\").innerHTML );\n\tvar frag = template( data );\n\tdocument.body.appendChild( frag );\n\n\nThe template evaluates the `messages` and adds the hooks for live binding automatically.\nSince we have no message it will render:\n\n\t<h1>Welcome Tina Fey!</h1>\n\t<p>You no messages.</p>\n\nNow say we have a request that updates\nthe `messages` attribute to have `5` messages.\n\n\tdata.message = 5;\n\n\nAfter the template receives this update, it will automatically\nupdate the paragraph tag to reflect the new value.\n\n\t<p>You have 5 new message.</p>\n\n\nFor more information visit the [can-define/map/map] documentation.\n\n### Binding between components\n\nIf you are looking for information on bindings between components like this:\n```\non:event=\"key()\" for event binding.\nprop:from=\"key\" for one-way binding to a child.\nprop:to=\"key\" for one-way binding to a parent.\nprop:bind=\"key\" for two-way binding.\n```\nSee [can-stache-bindings].\n\n",
    "description": "\nLive binding refers to templates which update themselves when their state or data changes.\n[can-stache] templates are able to listen to observables\n(like [can-define/map/map], [can-define/list/list], and [can-compute]) changing and update the page\nto reflect those changes.\n",
    "name": "can-stache.Binding",
    "title": "Live Binding",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 5
  },
  "can-stache.Helpers": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers.md"
    },
    "body": "\nExample custom helpers might include:\n\n - Converting a raw `Date` to a more user friendly timestamp. `{{timestamp birthday}}`\n - Internationalization. `{{i18n 'Hello'}}`\n - Convert markdown into HTML. `{{markdown(comment)}}`\n\nStache includes a number of built-in helpers, but custom helpers can be registered as well.\n\n## Built-in Helpers\n\nThe `[can-stache.tags.section {{#if(key)}}]` helper is used for **if** statements. The **if** helper is similar\nto using a `[can-stache.tags.section {{#key}}]` section. If they key passed to the helper is **truthy**, the\nsection will be rendered.\n\n\tTemplate:\n\t\t{{#if(friends)}}\n\t\t\tI have friends!\n\t\t{{/if}}\n\n\tData:\n\t\t{\n\t\t\tfriends: true\n\t\t}\n\n\tResult:\n\t\tI have friends!\n\nWhen using the `[can-stache.helpers.if {{#if(key)}}]` helper, or any other helper for that matter,\nthe special `[can-stache.helpers.else {{else}}]` helper is available. `{{else}}` is equivalent to\nan [can-stache.tags.inverse {{^key}}] inverse section (renders if given **falsey** data), except that it\nonly uses a single tag and exists inside a helper section.\n\n\tTemplate:\n\t\t<ul>\n\t\t\t{{#if(friends)}}\n\t\t\t\t</li>{{name}}</li>\n\t\t\t{{else}}\n\t\t\t\t<li>No friends.</li>\n\t\t\t{{/if}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tfriends: false\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>No friends.</li>\n\t\t</ul>\n\nThe `[can-stache.helpers.unless {{#unless(key)}}]` helper is equivalent to using a\n`[can-stache.tags.inverse {{^key}}]` inverse section. If they key passed to the helper is **falsey**, the\nsection will be rendered.\n\n\tTemplate:\n\t\t{{#unless(friends)}}\n\t\t\tYou don't have any friends!\n\t\t{{/unless}}\n\n\tData:\n\t\t{\n\t\t\tfriends: []\n\t\t}\n\n\tResult:\n\t\tYou don't have any friends!\n\nThe `[can-stache.helpers.each {{#each(key)}}]` helper is similar to using a\n`[can-stache.tags.section {{#key}}]` section for iterating an array. In this case, the entire array\nwill be rendered using the inner text item by item.\n\n\tTemplate:\n\t\t<ul>\n\t\t\t{{#each(friends)}}\n\t\t\t\t<li>{{name}}</li>\n\t\t\t{{/each}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tfriends: [\n\t\t\t\t{ name: \"Austin\" },\n\t\t\t\t{ name: \"Justin\" }\n\t\t\t]\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>Austin</li>\n\t\t\t<li>Justin</li>\n\t\t</ul>\n\nThe `[can-stache.helpers.with {{#with(key)}}]` helper is equivalent to using a\n`[can-stache.tags.section {{#key}}]` section for regular objects. The helper will change\nthe current context so that all tags inside will look for keys on the local context first.\n\n\tTemplate:\n\t\t<h1>Hi {{name}}</h1>\n\t\t{{#with(friend)}}\n\t\t\t<p>You have a new friend: {{name}}</p>\n\t\t{{/with}}\n\n\tData:\n\t\t{\n\t\t\tname: \"Andy\",\n\t\t\tfriend: { name: \"Justin\" }\n\t\t}\n\n\tResult:\n\t\t<h1>Hi Austin</h1>\n\t\t<p>You have a new friend: Justin</p>\n\nWhen using the `[can-stache.helpers.is {{#eq(key1, key2)}}]` helper you can simply compare\nkey1 and key2. If the result of comparsion is **truthy**, the section will be rendered.\n\n\tTemplate:\n\t\t<ul>\n\t\t{{#eq(name, 'Alex')}}\n\t\t\t</li>Your name is {{name}}</li>\n\t\t{{else}}\n\t\t\t<li>Your name is not Alex!</li>\n\t\t{{/is}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tname: 'John'\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>Your name is not Alex!</li>\n\t\t</ul>\n\n## Registering Helpers\n\nYou can register your own global helper with the `[can-stache.registerSimpleHelper registerSimpleHelper]` or `[can-stache.registerHelper registerHelper]` methods.\n\n`[can-stache.registerSimpleHelper registerSimpleHelper]` calls the registered helper function with\nvalues, while `[can-stache.registerHelper registerHelper]` calls the registered helper function with\n[can-compute.computed computes] if observable data is passed. `registerSimpleHelper` is\neasiser to use for basic helper functionality.\n\n\nLocalization is a good example of a custom helper you might implement\nin your application. The below example takes a given key and\nreturns the localized value using\n[jQuery Globalize](https://github.com/jquery/globalize).\n\n\tstache.registerSimpleHelper('l10n', function(str, options){\n\t\treturn Globalize != undefined\n\t\t\t? Globalize.localize(str)\n\t\t\t: str;\n\t});\n\n\nIn the template, invoke the helper by calling the helper\nname followed by any additional arguments.\n\n\tTemplate:\n\t\t<span>{{l10n 'mystring'}}</span>\n\n\tResult:\n\t\t<span>my string localized</span>\n\n### Helper Arguments\n\nThe type of arguments passed to a `registerHelper` function depends on how the helper was called and the values\npassed to the helper. In short, observables will be passed as [can-compute.computed compute] arguments\nin helper expressions.  In any other circumstance,  values will be passed.\n\nHelpers can be called as either a [can-stache.expressions Call or Helper Expression]:\n\n - Call expression - `{{myHelper(firstValue, secondValue)}}`\n - Helper expression - `{{myHelper firstValue secondValue}}`\n\nHelpers can also be called with observable values or non-observable values.\n\nConsidering a helper like:\n\n```js\nstache.registerHelper(\"myHelper\", function(value){ ... })\n```\n\nThe following details what `value` is depending on how the helper is called\nand the data passed.\n\n#### Call expression with non-observable data\n\n\tData:\n\t\t{ name: 'John' }\n\n\tTemplate:\n\t\t{{ myHelper(name) }}\n\n\tvalue:\n\t\t'John'\n\n#### Call expression with observable data\n\n\tData:\n\t\tnew DefineMap({ name: 'John' })\n\n\tTemplate:\n\t\t{{ myHelper(name) }}\n\n\tvalue:\n\t\t'John'\n\n#### Helper expression with non-observable data\n\n\tData:\n\t\t{ name: 'John' }\n\n\tTemplate:\n\t\t{{ myHelper name }}\n\n\tvalue:\n\t\t'John'\t    \n\n#### Helper expression with observable data\n\n\tData:\n\t\tnew DefineMap({ name: 'John' })\n\n\tTemplate:\n\t\t{{ myHelper name }}\n\n\tvalue:\n\t\tcompute('John')\n\n\n### Evaluating Helpers\n\nIf you want to use a helper with a [can-stache.tags.section] tag, you need to call\n`options.fn(context)` in your return statement. This will return a\ndocument fragment or string with the resulting evaluated subsection.\n\nSimilarly, you can call `options.inverse(context)` to evaluate the\ntemplate between an `{{else}}` tag and the closing tag.\n\nFor example, when a route matches the string passed to our\nrouting helper it will show/hide the text.\n\n\tstache.registerHelper('routing', function(str, options){\n\t\tif (route.attr('filter') === str)\n\t\t\treturn options.fn(this);\n\t\t}\n\t});\n\n\t{{#routing('advanced')}}\n\t\tYou have applied the advanced filter.\n\t{{/routing}}\n\n__Advanced Helpers__\n\nHelpers can be passed normal objects, native objects like numbers and strings,\nas well as a hash object. The hash object will be an object literal containing\nall ending arguments using the `key=value` syntax. The hash object will be provided\nto the helper as `options.hash`. Additionally, when using [can-stache.tags.section] tags with a helper,\nyou can set a custom context by passing the object instead of `this`.\n\n\tstache.registerHelper('exercise', function(group, action,\n\t\t\t\t\t\t\t\t\t\t\tnum, options){\n\t\tif (group && group.length > 0 && action && num > 0) {\n\t\t\treturn options.fn({\n\t\t\t\tgroup: group,\n\t\t\t\taction: action,\n\t\t\t\twhere: options.hash.where,\n\t\t\t\twhen: options.hash.when,\n\t\t\t\tnum: num\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\treturn options.inverse(this);\n\t\t}\n\t});\n\n\t{{#exercise(pets, 'walked', 3, where='around the block' when=time)}}\n\t\tAlong with the {{#group}}{{.}}, {{/group}}\n\t\twe {{action}} {{where}} {{num}} times {{when}}.\n\t{{else}}\n\t\tWe were lazy today.\n\t{{/exercise}}\n\n\t{\n\t\tpets: ['cat', 'dog', 'parrot'],\n\t\ttime: 'this morning'\n\t}\n\nThis would output:\n\n\tAlong with the cat, dog, parrot, we walked around the block\n\t3 times this morning.\n\nWhereas an empty data object would output:\n\n\tWe were lazy today.\n\n",
    "description": "\nHelpers are functions that can be registered and called from within templates.  These functions\nare typically used to provide functionality that is more appropriate for\nthe `view` than the `viewModel`.\n",
    "name": "can-stache.Helpers",
    "title": "Helpers",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 4
  },
  "can-stache.magicTagTypes": {
    "src": {
      "path": "node_modules/can-stache/docs/magicTagTypes.md"
    },
    "body": "\nRendering behavior is controlled with magic tags that look like `{{}}`.  There\nare two main forms of magic tags:\n\n - Insertion tags - insert their value into the result like `{{expression}}` and `{{{expression}}}`.\n - Section tags - optional render a sub-section like `{{#expression}} ... {{/expression}}`.\n\nLet’s see the general behavior of each tag type:\n\n### Insertion Tags\n\nInsertion tags render a value into result.\n\n#### [can-stache.tags.escaped]\n\nInserts the escaped value of `expression` into the result. This is the most common tag.\n\n```\nTemplate:\n\t<div>{{name}}</div>\n\nData:\n\t{ name: \"<b>Justin</b>\" }\n\nResult:\n\t<div>&lt;b&gt;Justin&lt;/b&gt;</div>\n```\n\n#### [can-stache.tags.unescaped]\n\nInserts the unescaped value of `expression` into the result.\n\n```\nTemplate:\n\t<div>{{{name}}}</div>\n\nData:\n\t{ name: \"<b>Justin</b>\" }\n\nResult:\n\t<div><b>Justin</b></div>\n```\n\n#### [can-stache.tags.partial]\n\nRenders another template with the same context as the current context.\n\n```\nvar template = stache(\"<h1>{{>title}}</h1>\");\n\n\nvar frag = template(\n\t{message: \"Hello\"},\n\t{\n\t\tpartials: { title: \tstache(\"<blink>{{message}}</blink>”) }\n\t});\n\n\tfrag //-> <h1><blink>Hello</blink></h1>\n```\n\nOther ways to load and reference partials are discussed [can-stache.tags.partial here].\n\n#### [can-stache.tags.comment]\n\nIgnores the magic tag.\n\n```\nTemplate:\n\t<h1>{{!message}}</h1>\n\nData:\n\t{ message: \"<blink>Hello</blink>\" };\n\nResult:\n\t<h1></h1>\n```\n\n### Section Tags\n\nSection tags are passed a subsection and an optional inverse subsection. They\noptionally render the subsections and insert them into the result.\n\n#### [can-stache.tags.section {{#expression}} ... {{/expression}}]\n\nRenders the subsection or inverse subsection depending on the value of expression.\n\nIf `expression` is truthy, renders the subsection:\n\n```\nTemplate:\n\t<h1>{{#shown}}Hello{{/shown}}</h1>\n\nData:\n\t{ shown: true };\n\nResult:\n\t<h1>Hello</h1>\n```\n\nThe subsection is rendered with the `expression` value as the top of the scope:\n\n```\nTemplate:\n\t<h1>{{#person}}Hello {{first}}  {{person.last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\", last: \"Abril\"} };\n\nResult:\n\t<h1>Hello Alexis Abril</h1>\n```\n\n\nIf `expression` is falsey, renders the inverse subsection if present:\n\n```\nTemplate:\n\t<h1>{{#shown}}Hello{{else}}Goodbye{{/shown}}</h1>\n\nData:\n\t{ shown: false };\n\nResult:\n\t<h1>Goodbye</h1>\n```\n\nIf `expression` is array-like and its `length` is greater than 0, the subsection\nis rendered with each item in the array as the top of the scope:\n\n```\nTemplate:\n\t<p>{{#items}}{{.}} {{/items}}</p>\n\nData:\n\t{items: [2,4,8,16]}\n\nResult:\n\t<p>2 4 8 16 </p>\n```\n\nIf `expression` is array-like and its `length` is 0, the inverse subsection\nis rendered:\n\n```\nTemplate:\n\t<p>{{#items}}{{.}} {{else}}No items{{/items}}</p>\n\nData:\n\t{items: []}\n\nResult:\n\t<p>No items</p>\n```\n\n#### [can-stache.tags.inverse {{^expression}} ... {{/expression}}]\n\nThe [can-stache.tags.inverse inverse] section does the opposite of the\nnormal [can-stache.tags.section] tag.  That is, it renders\nthe subsection when [can-stache.tags.section] would render the inverse subsection\nand it renders the inverse subsection when [can-stache.tags.section] would\nrender the subsection.\n\n```\nTemplate:\n\t<h1>{{^shown}}Hello{{/shown}}</h1>\n\nData:\n\t{ shown: false };\n\nResult:\n\t<h1>Hello</h1>\n```\n\n",
    "description": "\n",
    "name": "can-stache.magicTagTypes",
    "title": "Magic Tag Types",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 0,
    "comment": " "
  },
  "can-stache.registerPartial": {
    "src": {
      "path": "node_modules/can-stache/docs/registerPartial.md"
    },
    "body": "\n",
    "description": "Register a partial template that can be rendered with [can-stache.tags.partial]. \n",
    "title": "registerPartial",
    "name": "can-stache.registerPartial",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerPartial(name, template)",
        "description": "\n\nRegisters a template so it can be rendered with `{{>name}}`.\n\n```js\nstache.registerPartial(\"item.stache\", \"<li>{{name}}</li>\");\n\nvar itemsTemplate = stache(\"{{#each(items)}}{{>item.stache}}{{/each}}\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the partial."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "can-stache.renderer"
              }
            ],
            "name": "template",
            "description": "The string of a stache template or the\nreturned result of a stache template.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "can-stache.renderer"
        }
      ],
      "name": "template",
      "description": "The string of a stache template or the\nreturned result of a stache template.\n"
    },
    "comment": " "
  },
  "can-stache.renderer": {
    "src": {
      "path": "node_modules/can-stache/docs/renderer.md"
    },
    "body": "\n",
    "description": "A function returned by [can-stache] that renders a template into an html documentFragment.\n\n",
    "type": "typedef",
    "title": "renderer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "helpers"
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList"
          }
        ]
      }
    ],
    "name": "can-stache.renderer",
    "parent": "can-stache.types",
    "signatures": [
      {
        "code": "renderer(data, [helpers], [nodeList])",
        "description": "\n\n  A \"renderer\" function is a function returned by templates that can be used\n  to render data into a documentFragment.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "An object of data used to render the template.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "helpers",
            "description": "Local helper functions used by the template.\n"
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "optional": true,
            "name": "nodeList",
            "description": "Local helper functions used by the template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ],
          "description": "A documentFragment that contains the HTML rendered by the template.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "optional": true,
      "name": "nodeList",
      "description": "Local helper functions used by the template.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        }
      ],
      "description": "A documentFragment that contains the HTML rendered by the template.\n"
    },
    "comment": " "
  },
  "can-stache.safeString": {
    "src": {
      "path": "node_modules/can-stache/docs/safeString.md"
    },
    "body": "\n## Use\n\nIf you write a helper that generates its own HTML, you will\nusually want to return a `stache.safeString.` In this case,\nyou will want to manually escape parameters with [can-util/js/string/string.esc].\n\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nstache.registerHelper('link', function(text, url) {\n  text = string.esc(text);\n  url  = string.esc(url);\n\n  var result = '<a href=\"' + url + '\">' + text + '</a>';\n  return stache.safeString(result);\n});\n```\n\n\nRendering:\n\n```\n<div>{{link \"Google\", \"http://google.com\"}}</div>\n```\n\nResults in:\n\n```\n<div><a href=\"http://google.com\">Google</a></div>\n```\n\nAs an anchor tag whereas if we would have just returned the result rather than a\n`stache.safeString` our template would have rendered a div with the escaped anchor tag.\n\n",
    "description": "Indicate that a string does not need to be escaped to be safely inserted into the page.\n\n",
    "title": "safeString",
    "name": "can-stache.safeString",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.safeString(str)",
        "description": "\n\nBy default, stache tries to prevent some common forms of [cross site scripting attacks](https://en.wikipedia.org/wiki/Cross-site_scripting) by escaping content passed\nto tags like [can-stache.tags.escaped] and the result of helpers.  However,\none will often need to create helpers that return HTML content that shouldn't be escaped.\n\n`stache.safeString` can be used to indicate that a returned string from a helper is safe:\n\n```js\nstache.registerHelper(\"myHelper\", function(){\n  return stache.safeString(\"<blink>Hello There!</blink>\");\n})\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "A string you don't want to become escaped."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A string flagged by `stache` as safe, which will\nnot become escaped, even if you use [can-stache.tags.escaped].\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "A string you don't want to become escaped."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A string flagged by `stache` as safe, which will\nnot become escaped, even if you use [can-stache.tags.escaped].\n"
    },
    "comment": " "
  },
  "can-stache.registerConverter": {
    "src": {
      "path": "node_modules/can-stache/docs/registerConverter.md"
    },
    "body": "\n## Use\n\n> __NOTE__: Before creating your own converter, you may want to look at what’s provided by [can-stache-converters].\n\nThese helpers are useful for avoiding creating [can-define/map/map] getters and setters that do similar conversions on the view model.  Instead,\na converter can keep your viewModels more ignorant of the demands of the\nview.  Especially as the view's most common demand is that everything\nmust be converted to a string.\n\nThat being said, the following is a richer example of a converter,\nbut one that should probably be part of a view model.\n\n```handlebars\n<input {($value)}='fullName(~first, ~last)'/>\n```\n\nThe following might converts both ways `first` and `last` to `value`.\n\n```js\nvar canBatch = require(\"can-event/batch/batch\");\n\nstache.registerConverter(\"fullName\", {\n get: function(first, last) {\n \treturn first() + last();\n },\n set: function(newFullName, first, last) {\n\tcanBatch.start();\n\tvar parts = newFullName.split(\" \");\n\tfirst(parts[0]);\n\tlast(parts[1]);\n\tcanBatch.stop();\n }\n});\n```\n\n",
    "description": "Register a helper for bidirectional value conversion. \n",
    "title": "registerConverter",
    "name": "can-stache.registerConverter",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerConverter(converterName, getterSetter)",
        "description": "\n\nCreates a helper that can do two-way conversion between two\nvalues.  This is especially useful with\n[can-stache-bindings.twoWay {($two-way)} bindings] like:\n\n```handlebars\n<input {($value)}='numberToString(~age)'/>\n```\n\nA converter helper provides:\n\n - a `get` method that returns the value\n  of the `left` value given the arguments passed on the `right`.\n - a `set` method that updates one or multiple of the `right` arguments\n   computes given a new `left` value.\n\n`numberToString` might converts a number (`age`)\nto a string (`value`), and the string (`value`) to a number (`age`)\nas follows:\n\n\n```js\nstache.registerConverter(\"numberToString\", {\n get: function(fooCompute) {\n \treturn \"\" + fooCompute();\n },\n set: function(newVal, fooCompute) {\n \tfooCompute(+newVal);\n }\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "converterName",
            "description": "The name of the converter helper."
          },
          {
            "types": [
              {
                "type": "can-stache.getterSetter"
              }
            ],
            "name": "getterSetter",
            "description": "An object containing get() and set() functions.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.getterSetter"
        }
      ],
      "name": "getterSetter",
      "description": "An object containing get() and set() functions.\n"
    },
    "comment": " "
  },
  "can-stache.sectionRenderer": {
    "src": {
      "path": "node_modules/can-stache/docs/sectionRenderer.md"
    },
    "body": "\n## Use\n\nRenderer functions are provided to stache [can-stache.helper helpers] on \nthe [can-stache.helperOptions options] argument and are used to render the\ncontent between sections. The `context` and `helpers` option let you control\nthe data and helpers used to render the section.\n\nThe following example adds `{first: \"Justin\"}` to the lookup \ndata. Notice how the section has access to `first` and `last`.\n\n    stache.registerHelper(\"myhelper\", function(options){\n      var section = options.fn({first: \"Justin\"});\n      return $(\"<h1>\").append( section );\n    })\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1>Justin Meyer</h1>\n\nIf no `context` is provided, the current context is passed.  Notice\nhow the section has access to `last`:\n\n    stache.registerHelper(\"myhelper\", function(options){\n      \n       var section = options.fn();\n       return $(\"<h1>\").append( section );\n      \n    });\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1> Meyer</h1>\n    \nIf a [can-view-scope] is provided, it is used to render the \nsection. Notice how `last` is not available in the section:\n\n    stache.registerHelper(\"myhelper\", function(options){\n      \n      var section = options.fn( new Scope( {first: \"Justin\"}) );\n      return $(\"<h1>\").append( section );\n      \n    });\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1>Justin </h1>\n\n\n\n\n",
    "description": "Renders a section. These functions are usually provided as `.fn` and `.inverse` on a stache helper's [can-stache.helperOptions options].\n\n",
    "type": "typedef",
    "title": "sectionRenderer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            },
            {
              "type": "String"
            }
          ],
          "description": "Returns the rendered result of the helper. If the\nsection is within a tag, like:\n\n    <h1 {{#helper}}class='power'{{/helper}}>\n\na String is returned.  \n\nIf the section is outside a tag like: \n\n    <div> {{#helper}}<h2>Tasks</h2>{{/helper}} </div>\n    \na documentFragment is returned.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-view-scope"
              }
            ],
            "optional": true,
            "name": "context",
            "description": "Specifies the data the section is rendered \nwith.  If a [can-view-scope] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current scope as it's parent.  If nothing is provided, the current\nscope is used to render the section.\n"
          },
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-view-scope.Options"
              }
            ],
            "optional": true,
            "name": "helpers",
            "description": "Specifies the helpers the section is rendered \nwith.  If a [can-view-scope.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.\n"
          }
        ]
      }
    ],
    "name": "can-stache.sectionRenderer",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "can-view-scope.Options"
        }
      ],
      "optional": true,
      "name": "helpers",
      "description": "Specifies the helpers the section is rendered \nwith.  If a [can-view-scope.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        },
        {
          "type": "String"
        }
      ],
      "description": "Returns the rendered result of the helper. If the\nsection is within a tag, like:\n\n    <h1 {{#helper}}class='power'{{/helper}}>\n\na String is returned.  \n\nIf the section is outside a tag like: \n\n    <div> {{#helper}}<h2>Tasks</h2>{{/helper}} </div>\n    \na documentFragment is returned.\n"
    },
    "comment": " "
  },
  "can-stache.Sections": {
    "src": {
      "path": "node_modules/can-stache/docs/sections.md"
    },
    "body": "\nThe most basic form of section will simply render a section of code if the key referenced is considered **truthy** (has a value):\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\n\tData:\n\t\t{\n\t\t\tperson: {\n\t\t\t\tname: \"Andy\"\n\t\t\t}\n\t\t}\n\n\tResult:\n\t\tHello!\n\t\tAndy\n\nWhenever the key doesn't exist or the value is **falsey**, the section won't be rendered:\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\n\tData:\n\t\t{}\n\n\tResult:\n\t\tHello!\n\nHowever, this scenario can be covered through the use of an inverse section \n(`[can-stache.tags.inverse {{^key}}]` followed by `[can-stache.tags.close {{/key}}]`):\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\t\t{{^person}}\n\t\t\tNo one is here.\n\t\t{{/person}}\n\n\tData:\n\t\t{}\n\n\tResult:\n\t\tHello!\n\t\tNo one is here.\n\n## Iteration\n\nThere is a special case for sections where the key references an array. In this case, the section iterates \nthe entire array, rendering the inner text for each item in the array. Arrays are considered **truthy** if \nthey aren't empty. The `{{.}}` tag will reference the current item within the array during iteration (which is \nprimarily used when the items in the array are primitives like strings and numbers).\n\n\tTemplate:\n\t\t{{#people}}\n\t\t\t{{.}} \n\t\t{{/people}}\n\n\tData:\n\t\t{\n\t\t\tpeople: [\"Andy\", \"Austin\", \"Justin\"]\n\t\t}\n\n\tResult:\n\t\tAndy Austin Justin\n\n## Understanding when to use Sections with lists\n\nSection iteration will re-render the entire section for any change in the list. It is the prefered method to\nuse when a list is replaced or changing significantly. Whereas [can-stache.helpers.each {{#each(key)}}] iteration\nwill do basic diffing and aim to only update the DOM where the change occured. When doing single list item\nchanges frequently, [can-stache.helpers.each {{#each(key)}}] iteration is the faster choice.\n\nFor example, assuming \"list\" is a [can-list] instance:\n\n{{#if(list)}} will check for the truthy value of list. This is akin to checking for the truthy value of any JS object and will result to true, regardless of list contents or length.\n\n{{#if(list.length)}} will check for the truthy value of the length attribute. If you have an empty list, the length will be 0, so the #if will result to false and no contents will be rendered. If there is a length >= 1, this will result to true and the contents of the #if will be rendered.\n\n{{#each(list)}} and {{#list}} both iterate through an instance of [can-list], however we setup the bindings differently.\n\n{{#each(list)}} will setup bindings on every individual item being iterated through, while {{#list}} will not. This makes a difference in two scenarios:\n\n1) You have a large list, with minimal updates planned after initial render. In this case, {{#list}} might be more advantageous as there will be a faster initial render. However, if any part of the list changes, the entire {{#list}} area will be re-processed.\n\n2) You have a large list, with many updates planned after initial render. A grid with many columns of editable fields, for instance. In this case, you many want to use {{#each(list)}}, even though it will be slower on initial render(we're setting up more bindings), you'll have faster updates as there are now many sections.\n\n",
    "description": "\nSections (`[can-stache.tags.section {{#key}}]` followed by `[can-stache.tags.close {{/key}}]`) have multiple uses \ndepending on what type of object is passed to the section. In all cases, using a section will change \nthe current [can-stache.context context].\n",
    "name": "can-stache.Sections",
    "title": "Sections",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 7
  },
  "can-stache.simpleHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/simplehelper.md"
    },
    "body": "\n\n## Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create mustache tags that have rich behavior.\n\nIf the helper is called __within a tag__ like:\n\n    <ul {{sortable}}/>\n\nThe returned function is called with the `<ul>` element:\n\n    stache.registerSimpleHelper(\"sortable\",function(){\n      return function(el){\n        $(el).slider();\n      }\n    });\n\nIf the helper is called __between tags__ like:\n\n    <ul>{{items}}</ul>\n\nThe returned function is called with a temporary element. The\nfollowing helper would be called with a temporary `<li>` element:\n\n    stache.registerSimpleHelper(\"items\",function(){\n      return function(li){\n\n      }\n    });\n\nThe temporary element depends on the parent element. The default temporary element\nis a `<span>` element.\n\n",
    "description": "A helper function passed to [can-stache.registerSimpleHelper]. \n",
    "type": "typedef",
    "title": "simpleHelper",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "HTMLElement"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The content to be inserted into\nthe template.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "variable": true,
            "name": "arg",
            "description": "Arguments passed from the tag. After the helper\nname, any space separated [can-stache.key keys], numbers or\nstrings are passed as arguments.\n\nThe following template:\n\n    <p>{{madLib \"Lebron James\" verb 4}}</p>\n\nRendered with\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements.\n\n    stache.registerSimpleHelper('madLib',\n      function(subject, verb, number){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n    });\n\nUnlike [can-stache.helper] simple helpers will always pass the actual\nvalue (instead of a compute).\n"
          },
          {
            "types": [
              {
                "type": "can-stache.helperOptions"
              }
            ],
            "name": "options",
            "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "can-stache.context"
            }
          ],
          "description": "The context the helper was\ncalled within.\n"
        }
      }
    ],
    "name": "can-stache.simpleHelper",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helperOptions"
        }
      ],
      "name": "options",
      "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ]
            }
          ]
        }
      ],
      "description": "The content to be inserted into\nthe template.\n"
    },
    "comment": " "
  },
  "can-stache.Whitespace": {
    "src": {
      "path": "node_modules/can-stache/docs/whitespace.md"
    },
    "body": "\n## Examples\n\n### Basic Usage\n\n```html\n<div>\n\t{{-#if(user.isMarried)-}}\n\t\tMrs\n\t{{-else-}}\n\t\tMiss\n\t{{-/if-}}\n</div>\n```\n\nwould render as:\n\n```html\n<div>{{#if(user.isMarried)}}Mrs{{else}}Miss{{/if}}</div>\n```\n\nand\n\n```html\n<div>\n\t{{{- toMarkdown(content) -}}}\n</div>\n```\n\nwould render as:\n\n```html\n<div>{{{ toMarkdown(content) }}}</div>\n```\n\n### Span Elements\n\nOne use case is to remove spaces around span elements.\n\n```html\n<div>\n\t<span>\n\t\t{{-#if(user.isMarried)-}}\n\t\t\tMrs.\n\t\t{{-else-}}\n\t\t\tMiss.\n\t\t{{-/if-}}\n\t</span>\n\t{{- user.name }}\n</div>\n```\n\nwould render as:\n\n```html\n<div>\n\t<span>{{#if(user.isMarried)}}Mrs.{{else}}Miss.{{/if}}</span>{{ user.name }}\n</div>\n```\n\n### Empty Elements\n\nAnother would be to assure that empty elements are able to match the `:empty`\ncss pseudo-class (the whitespace that would be otherwise present prevents this),\nwhile still being cleanly formatted for human consumption.\n\n```html\n<div>\n\t{{-! output the users name }}\n\t{{-#if(user.name)}}\n\t\t{{ user.name }}\n\t{{/if-}}\n</div>\n```\n\nwould render as:\n\n```html\n<div>{{-! output the users name }}{{-#if(user.name)}}\n\t\t{{ user.name }}\n\t{{/if-}}</div>\n```\n\n",
    "description": "Omit whitespace from around the output of the template. \n",
    "name": "can-stache.Whitespace",
    "title": "Whitespace Control",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 6,
    "signatures": [
      {
        "code": "{{-EXPRESSION-}}",
        "description": "\n\nWhitespace may be omitted from either or both ends of a magic tag by including a\n`-` character by the braces. When present, all whitespace on that side will be\nomitted up to the next tag, magic tag, or non-whitespace character. It also works with [can-stache.tags.unescaped].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression whose unescaped result is inserted into the page.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression whose unescaped result is inserted into the page.\n"
    },
    "comment": " "
  },
  "can-stache.pages": {
    "name": "can-stache.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 0
  },
  "can-stache.static": {
    "name": "can-stache.static",
    "title": "Methods",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 1
  },
  "can-stache.tags": {
    "name": "can-stache.tags",
    "title": "Tags",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 2
  },
  "can-stache/expressions": {
    "name": "can-stache/expressions",
    "title": "Expressions",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 3
  },
  "can-stache/keys": {
    "name": "can-stache/keys",
    "title": "Key Operators",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 4
  },
  "can-stache.htags": {
    "name": "can-stache.htags",
    "title": "Helpers",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 5
  },
  "can-stache.types": {
    "name": "can-stache.types",
    "title": "Types",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 6
  },
  "can-stache": {
    "src": {
      "path": "node_modules/can-stache/docs/stache.md"
    },
    "body": "\n\n\n## Use\n\nStache templates are a [mustache](https://mustache.github.io/mustache.5.html) and [handlebars](http://handlebarsjs.com/) compatible\nsyntax.  Stache templates are used to:\n\n- Convert data into HTML.\n- Update the HTML when observable data changes.\n- Enable [can-component custom elements] and [can-stache-bindings bindings].\n\nThe following\ncreates a stache template, renders it with data, and inserts\nthe result into the page:\n\n```js\nvar stache = require(\"can-stache\");\n// renderer is a \"renderer function\"\nvar renderer = stache(\"<h1>Hello {{subject}}</h1>\");\n\n// \"renderer functions\" render a template and return a\n// document fragment.\nvar fragment = renderer({subject: \"World\"})\n\n// A document fragment is a collection of elements that can be\n// used with jQuery or with normal DOM methods.\nfragment //-> <h1>Hello World</h1>\ndocument.body.appendChild(fragment)\n```\n\nRender a template with observable data like [can-define/map/map DefineMap]s or [can-define/list/list DefineList]s and the\nresulting HTML will update when the observable data changes.\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\n\nvar renderer = stache(\"<h1>Hello {{subject}}</h1>\");\nvar map = new DefineMap({subject: \"World\"});\nvar fragment = renderer(map)\ndocument.body.appendChild(fragment)\n\nmap.subject = \"Earth\";\n\ndocument.body.innerHTML //-> <h1>Hello Earth</h1>\n```\n\nThere's a whole lot of behavior that `stache` provides.  The following walks through\nthe most important stuff:\n\n- [can-stache.magicTagTypes] - The different tag types like `{{key}}` and `{{#key}}...{{/key}}`\n- [can-stache.scopeAndContext] - How key values are looked up.\n- [can-stache.expressions] - Supported expression types like `{{helper arg}}` and `{{method(arg)}}`\n- [can-stache.Acquisition] - How to load templates into your application.\n- [can-stache.Helpers] - The built in helpers and how to create your own.\n- [can-stache.Binding] - How live binding works.\n\n## See also\n\n[can-view-scope] is used by `stache` internally to hold and lookup values.  This is similar to\nhow JavaScript's closures hold variables, except you can use it programmatically.\n\n[can-component] and [can-view-callbacks.tag can-view-callbacks.tag] allow you to define custom\nelements for use within a stache template.  [can-view-callbacks.attr can-view-callbacks.attr] allow\nyou to define custom attributes.\n\n[can-stache-bindings] sets up __element and bindings__ between a stache template's [can-view-scope],\ncomponent [can-component.prototype.ViewModel viewModels], or an element's attributes.\n\n",
    "description": "Live binding Mustache and Handlebars-compatible templates. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-stache",
    "parent": "can-views",
    "collection": "can-core",
    "release": "2.1",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-stache/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-attribute-encoder": "^0.3.0",
        "can-compute": "^3.3.1",
        "can-globals": "^0.2.0",
        "can-log": "^0.1.0",
        "can-namespace": "1.0.0",
        "can-observation": "^3.3.1",
        "can-reflect": "^1.2.1",
        "can-route": "^3.2.0",
        "can-stache-key": "0.1.0",
        "can-symbol": "^1.0.0",
        "can-util": "^3.10.6",
        "can-view-callbacks": "^3.2.0",
        "can-view-live": "^3.2.0",
        "can-view-nodelist": "^3.1.0",
        "can-view-parser": "^3.6.0",
        "can-view-scope": "^3.5.1",
        "can-view-target": "^3.1.0"
      },
      "deprecated": false,
      "description": "Live binding handlebars templates",
      "devDependencies": {
        "can-define": "^1.3.0",
        "can-event": "^3.6.0",
        "can-list": "^3.2.0",
        "can-map": "^3.3.0",
        "can-test-helpers": "^1.1.0",
        "can-vdom": "^3.1.0",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.4",
        "steal": "^1.0.5",
        "steal-benchmark": "^0.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-stache",
      "name": "can-stache",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-stache.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.13.0"
    },
    "link": "../docco/view/stache/mustache_core.html docco",
    "test": "can/view/stache/test/test.html",
    "plugin": "can/view/stache",
    "download": "http://canjs.us/release/latest/can.stache.js",
    "signatures": [
      {
        "code": "stache([name,] template)",
        "description": "\n\nProcesses the template and returns a [can-stache.renderer renderer function].\nUse [steal-stache] to import template renderer functions with [http://stealjs.com StealJS].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Provides an optional name for this type that will show up\nnicely in errors. Files imported with [steal-stache] will use their filename.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "The text of a stache template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A [can-stache.renderer renderer] function that returns a live document fragment\nthat can be inserted in the page.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "template",
      "description": "The text of a stache template.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A [can-stache.renderer renderer] function that returns a live document fragment\nthat can be inserted in the page.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.syntaxes": {
    "name": "can-stache-bindings.syntaxes",
    "title": "Syntaxes",
    "type": "group",
    "parent": "can-stache-bindings",
    "description": "",
    "order": 0
  },
  "can-stache-bindings": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/bindings.md"
    },
    "body": "\n\n## Use\n\nThe `can-stache-bindings` plugin provides useful [can-view-callbacks.attr custom attributes] for template declarative event, one-way bindings, and two-way\nbindings on element attributes, component [can-component::ViewModel ViewModels], and the [can-view-scope scope]. Bindings look like:\n\n\n- `on:event=\"key()\"` for event binding.\n- `prop:from=\"key\"` for one-way binding to a child.\n- `prop:to=\"key\"` for one-way binding to a parent.\n- `prop:bind=\"key\"` for two-way binding.\n\n__Note:__ DOM attribute names are case-insensitive, but [can-component::ViewModel ViewModel] or [can-view-scope scope] properties can be `camelCase` and [can-stache stache] will encode them so they work correctly in the DOM.\n\nThe following are the bindings that should be used with [can-stache]:\n\n#### [can-stache-bindings.event event]\n\nBinds to `childEvent` on `<my-component>`'s [can-component::ViewModel ViewModel] and calls\n`method` on the [can-view-scope scope] with the specified arguments:\n\n```\n<my-component on:childEvent=\"method('primitive', key, hash1=key1)\"/>\n```\n\nIf the element does not have a [can-component::ViewModel ViewModel], binds to `domEvent` on the element and calls\n`method` on the [can-view-scope scope] with the specified arguments.\n\n```\n<div on:domEvent=\"method('primitive', key, hash1=key1)\"/>\n```\n\nYou can also explicitly listen to events on the [can-component::ViewModel ViewModel] using `on:vm:childEvent` or on the element using `on:el:domEvent`.\n\n#### [can-stache-bindings.toChild one-way to child]\n\nUpdates `childProp` in `<my-component>`’s [can-component::ViewModel ViewModel] with `value` in the [can-view-scope scope]:\n\n```\n<my-component childProp:from=\"value\"/>\n```\n\n> This can be read as \"set `childProp` _from_ `value`\".\n\nIf the element does not have a [can-component::ViewModel ViewModel], updates the `child-attr` attribute or property of the\nelement with `value` in the [can-view-scope scope]:\n\n```\n<div child-attr:from=\"value\"/>\n```\n\nYou can also explicitly use the [can-component::ViewModel ViewModel] using `vm:childProp:from=\"value\"` or the element using `el:child-attr:from=\"value\"`.\n\n> __Note:__ If value being passed to the component is an object, changes to the objects properties will still be visible to the component. Objects are passed by reference. See [can-stache-bindings#OneWayBindingWithObjects One Way Binding With Objects].\n\n#### [can-stache-bindings.toParent one-way to parent]\n\nUpdates `value` in the [can-view-scope scope]  with `childProp`\nin `<my-component>`’s [can-component::ViewModel ViewModel]:\n\n```\n<my-component childProp:to=\"value\"/>\n```\n\n> This can be read as \"send `childProp` _to_ `value`\".\n\nIf the element does not have a [can-component::ViewModel ViewModel], updates `value`\nin the [can-view-scope scope] with the `child-attr` attribute or property of the element.\n\n```\n<div child-attr:to=\"value\"/>\n```\n\nYou can also explicitly use the [can-component::ViewModel ViewModel] using `vm:childProp:to=\"value\"` or the element using `el:child-attr:to=\"value\"`.\n\n> __Note:__ If value being passed to the component is an object, changes to the objects properties will still be visible to the component. Objects are passed by reference. See [can-stache-bindings#OneWayBindingWithObjects One Way Binding With Objects].\n\n#### [can-stache-bindings.twoWay two-way]\n\nUpdates `childProp` in `<my-component>`’s [can-component::ViewModel ViewModel] with `value` in the [can-view-scope scope] and vice versa:\n\n```\n<my-component childProp:bind=\"value\"/>\n```\n\nUpdates the `child-attr` attribute or property of the element with `value`\nin the [can-view-scope scope] and vice versa:\n\n```\n<div child-attr:bind=\"value\"/>\n```\n\nYou can also explicitly use the [can-component::ViewModel ViewModel] using `vm:childProp:bind=\"value\"` or the element using `el:child-attr:bind=\"value\"`.\n\n## One Way Binding With Objects\n\n`childProp:from=\"key\"` ([can-stache-bindings.toChild one-way to child]) or `child-prop:to=\"key\"` ([can-stache-bindings.toParent one-way to parent]) is used to pass values from the current scope to a component or vice versa, respectively.\n\nGenerally, this binding only observes changes in one direction, but when [can-stache.key] is an object (POJO, DefineMap, etc), it is passed as a reference, behaving in much the same way as the following snippet.\n\n```javascript\nfunction component(bar) {\n\t// changes to bar's properties are preserved\n\tbar.quux = 'barfoo';\n\n\t// but replacing bar is not\n\tbar = {\n\t\tquux: 'hello world'\n\t};\n}\n\nvar foo = {\n\tquux: 'foobar'\n};\ncomponent(foo);\n```\n\n",
    "description": "\nProvides template event, one-way bindings, and two-way bindings.\n",
    "type": "module",
    "title": "",
    "name": "can-stache-bindings",
    "parent": "can-views",
    "collection": "can-core",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-attribute-encoder": "^0.3.0",
        "can-compute": "^3.3.1",
        "can-event": "^3.5.0",
        "can-event-dom-enter": "^1.0.2",
        "can-event-dom-radiochange": "^1.0.2",
        "can-globals": "^0.2.2",
        "can-log": "^0.1.0",
        "can-observation": "^3.3.1",
        "can-reflect": "^1.2.1",
        "can-simple-map": "^3.3.0",
        "can-simple-observable": "^1.0.0",
        "can-stache": "^3.7.1",
        "can-stache-key": "0.1.0",
        "can-symbol": "^1.0.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.0",
        "can-view-callbacks": "^3.2.0",
        "can-view-live": "^3.2.0",
        "can-view-model": "^3.4.0",
        "can-view-scope": "^3.4.2"
      },
      "deprecated": false,
      "description": "Default binding syntaxes for can-stache",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^1.3.0",
        "can-list": "^3.2.0",
        "can-map": "^3.3.1",
        "can-test-helpers": "^1.1.0",
        "can-vdom": "^3.1.0",
        "can-view-nodelist": "^3.1.0",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "donejs"
      ],
      "main": "can-stache-bindings",
      "name": "can-stache-bindings",
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint test/ ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-stache-bindings"
      },
      "version": "3.11.0"
    },
    "comment": " "
  },
  "can-stache-bindings.event": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/event.md"
    },
    "body": "\n## Use\n\n## DOM events\n\n`on:el:` will listen for events on the DOM, `on:` can also be used to listen for DOM events if the element does not have a [can-component::ViewModel ViewModel].\n\n```\n<div on:click=\"doSomething()\"/>\n```\n\nBy adding `on:EVENT='methodKey()'` to an element, the function pointed to\nby `methodKey` is bound to the element’s `EVENT` event. The function can be\npassed any number of arguments from the surrounding scope, or `name=value`\nattributes for named arguments. Direct arguments will be provided to the\nhandler in the order they were given.\n\nThe following uses `on:click=\"items.splice(%index,1)\"` to remove a\nitem from `items` when that item is clicked on.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/event-args.html'></div>\n\n### Special Event Types\n\n[can-stache-bindings] supports creating special event types\n(events that aren’t natively triggered by the DOM), which are\nbound by adding attributes like `on:SPECIAL='KEY'`. This is\nsimilar to [$.special](http://benalman.com/news/2010/03/jquery-special-events/).\n\n### on:enter\n\n`on:enter` is a special event that calls its handler whenever the enter\nkey is pressed while focused on the current element. For example:\n\n\t<input type='text' on:enter='save()' />\n\nThe above template snippet would call the save method\n(in the [can-view-scope scope]) whenever\nthe user hits the enter key on this input.\n\n## viewModel events\n\nTo listen on a [can-component Component’s] [can-component.prototype.ViewModel ViewModel], prepend the event with `on:` (`on:vm:` can also be used to be make this more explicit) like:\n\n```\n<player-edit\n\ton:close=\"removeEdit()\"\n\tplayer:from=\"editingPlayer\"/>\n```\n\nViewModels can publish events on themselves. The following `<player-edit>` component\ndispatches a `\"close\"` event on itself when its `close` method is called:\n\n```\nComponent.extend({\n  tag: \"player-edit\",\n  template: can.view('player-edit-stache'),\n  viewModel: {\n    close: function(){\n      this.dispatch(\"close\");\n    }\n  }\n});\n```\n\nThe following demo uses this ability to create a close button that\nhides the player editor:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next_event.html'></div>\n\n## Changing a property when an event occurs\n\nAn event on either the element or viewModel can be set to bind the element's value to a property \non the scope like:\n\n```\n<input type=\"text\" value=\"\" on:blur:value:to=\"myScopeProp\">\n```\n\nThis will set the value of myScopeProp to the input's value anytime the input loses focus.\n\n",
    "description": "Respond to events on elements or component ViewModels. \n",
    "title": "on:event",
    "name": "can-stache-bindings.event",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 0,
    "signatures": [
      {
        "code": "on:VIEW_MODEL_OR_DOM_EVENT='CALL_EXPRESSION'",
        "description": "\n\nIf the element has a [can-component::ViewModel ViewModel], listens to an event on the [can-component::ViewModel ViewModel] and calls the [can-stache/expressions/call] when that event occurs.\n\nIf the element does **not** have a [can-component::ViewModel ViewModel], listens to an event on the element and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<my-component on:show=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "VIEW_MODEL_OR_DOM_EVENT",
            "description": "A viewModel or DOM event.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression like `method(key)` that is called when the `VIEW_MODEL_EVENT`\nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component’s [can-component::ViewModel ViewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n"
          }
        ]
      },
      {
        "code": "on:el:DOM_EVENT='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on the element and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<div on:el:click=\"doSomething()\"/>\n```\n\nParameters are the same as [can-stache-bindings.event#on_VIEW_MODEL_OR_DOM_EVENT__CALL_EXPRESSION_ on:VIEW_MODEL_OR_DOM_EVENT='CALL_EXPRESSION']\n",
        "params": []
      },
      {
        "code": "on:vm:VIEW_MODEL_EVENT='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on the element’s [can-component::ViewModel ViewModel] and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<my-component on:vm:show=\"doSomething()\"/>\n```\n\nParameters are the same as [can-stache-bindings.event#on_VIEW_MODEL_OR_DOM_EVENT__CALL_EXPRESSION_ on:VIEW_MODEL_OR_DOM_EVENT='CALL_EXPRESSION']\n",
        "params": []
      },
      {
        "code": "on:VIEW_MODEL_OR_DOM_EVENT:value:to='SCOPE_VALUE'",
        "description": "\n\nIf the element has a [can-component::ViewModel ViewModel], listens to an event on the [can-component::ViewModel ViewModel] and binds the element's value to the SCOPE_VALUE when that event occurs.\n\nIf the element does **not** have a [can-component::ViewModel ViewModel], listens to an event on the element and binds binds the element's value to the SCOPE_VALUE when that event occurs.\n\n```\n<my-component on:show:value:to=\"myScopeProp\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "VIEW_MODEL_OR_DOM_EVENT",
            "description": "A viewModel or DOM event.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "SCOPE_VALUE",
            "description": "A value in the current scope.\n"
          }
        ]
      },
      {
        "code": "on:SCOPE_EVENT:by:this='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on the [can-view-scope scope] and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<my-component on:show:by:this=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "SCOPE_EVENT",
            "description": "a scope event.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression like `method(key)` that is called when the `VIEW_MODEL_EVENT` is fired. Same as [can-stache-bindings.event#on_VIEW_MODEL_OR_DOM_EVENT__CALL_EXPRESSION_ on:VIEW_MODEL_OR_DOM_EVENT='CALL_EXPRESSION']\n"
          }
        ]
      },
      {
        "code": "on:SCOPE_PROP_EVENT:by:SCOPE_PROP='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on a property of the [can-view-scope scope] and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<my-component on:show:by:obj=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "SCOPE_PROP_EVENT",
            "description": "an event triggered by a scope property.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "SCOPE_PROP",
            "description": "a scope property.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression like `method(key)` that is called when the `VIEW_MODEL_EVENT`\nis fired. Same as [can-stache-bindings.event#on_VIEW_MODEL_OR_DOM_EVENT__CALL_EXPRESSION_ on:VIEW_MODEL_OR_DOM_EVENT='CALL_EXPRESSION']\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.expressions"
        }
      ],
      "name": "CALL_EXPRESSION",
      "description": "A call expression like `method(key)` that is called when the `VIEW_MODEL_EVENT`\nis fired. Same as [can-stache-bindings.event#on_VIEW_MODEL_OR_DOM_EVENT__CALL_EXPRESSION_ on:VIEW_MODEL_OR_DOM_EVENT='CALL_EXPRESSION']\n\n"
    },
    "comment": " "
  },
  "can-stache-bindings.toChild": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/to-child.md"
    },
    "body": "\n## Use\n\n`childProp:from=\"key\"` is used to pass values from the scope to a component.  You can use CallExpressions like:\n\n```\n<player-scores scores:from=\"game.scoresForPlayer('Alison')\"/>\n<player-scores scores:from=\"game.scoresForPlayer('Jeff')\"/>\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-child.html'></div>\n\n",
    "description": "One-way bind a value in the parent scope to the [can-component.prototype.ViewModel ViewModel] or element. \n",
    "title": "toChild:from",
    "name": "can-stache-bindings.toChild",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 1,
    "signatures": [
      {
        "code": "childProp:from=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` in [can-component.prototype.view-model viewModel]. It also updates `childProp` with the value of `key` when `key` changes.\n\n  ```\n  <my-component someProp:from=\"value\"/>\n  ```\n\n  > __Note:__ If [can-stache.key] is an object, changes to the objects properties will still be visible to the component. Objects are passed by reference. See [can-stache-bindings#OneWayBindingWithObjects One Way Binding With Objects].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "childProp",
            "description": "The name of the property to set in the\ncomponent’s viewmodel.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression whose resulting value is used to set as `childProp`.\n"
          }
        ]
      },
      {
        "code": "child-prop:from=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `child-prop` property or attribute on the element.\n\n  ```\n  <input value:from=\"name\"/>\n  ```\n\n  This signature works, but the following should be used instead:\n\n  ```\n  <input value=\"{{name}}\"/>\n  ```\n",
        "params": []
      },
      {
        "code": "vm:childProp:from=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` in [can-component.prototype.view-model viewModel]. It also updates `childProp` with the value of `key` when `key` changes.\n\n  ```\n  <my-component vm:someProp:from=\"value\"/>\n  ```\n\n  > __Note:__ If [can-stache.key] is an object, changes to the objects properties will still be visible to the component. Objects are passed by reference. See [can-stache-bindings#OneWayBindingWithObjects One Way Binding With Objects].\n\nParameters are the same as [can-stache-bindings.toChild#childProp_from__key_ childProp:from=\"key\"]\n",
        "params": []
      },
      {
        "code": "el:child-prop:from=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `child-prop` property or attribute on the element.\n\n  ```\n  <input el:value:from=\"name\"/>\n  ```\n\n  This signature works, but the following should be used instead:\n\n  ```\n  <input value=\"{{name}}\"/>\n  ```\n\nParameters are the same as [can-stache-bindings.toChild#child_prop_from__key_ child-prop:from=\"key\"]\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache-bindings.reference": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/reference.md"
    },
    "body": "\n## Use\n\nExport a view model to the references scope by adding an attribute with the \nhypenated name of the reference scope property:\n\n```\n<year-selector *year-selector />\n```\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/reference-one-way.html'></div>\n\n",
    "description": "Export a viewModel into a template's references scope. \n",
    "title": "*REFERENCE",
    "name": "can-stache-bindings.reference",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 4,
    "deprecated": [
      {
        "version": "4.0",
        "description": "This syntax is deprecated in favor of [can-stache-bindings.toParent `this:to=\"refProp\"`]\n"
      }
    ],
    "signatures": [
      {
        "code": "*ref-prop",
        "description": "\n\n  A shorthand for exporting an element’s viewModel to the reference scope.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "ref-prop",
            "description": "The name of the property to set in the template's 'references' scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "ref-prop",
      "description": "The name of the property to set in the template's 'references' scope.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.toParent": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/to-parent.md"
    },
    "body": "\n## Use\n\nDepending on whether the element has a [can-component.prototype.ViewModel ViewModel], `:to` bindings change\nbetween exporting __viewModel properties__ or __DOM properties__.\n\n## Exporting ViewModel properties\n\n`childProp:to=\"key\"` can be used to export single values or the complete view model from a\nchild component into the parent scope. Typically, the values are exported to the references scope.\n\nIn the following example, it connects the __selected__ driver in `<drivers-list>` with an editable __plateName__ in\n`<edit-plate>`:\n\n    <drivers-list selected:to=\"*editing\"/>\n    <edit-plate plateName:bind=\"*editing.licensePlate\"/>\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-parent.html'></div>\n\n## Exporting DOM properties\n\n`child-prop:to=\"key\"` can be used to export an attribute value into the scope.  For example:\n\n```\n<input value:to=\"name\"/>\n```\n\nUpdates `name` in the scope when the `<input>` element’s `value` changes.\n\n## Exporting Functions\n\nYou can export a function to the parent scope with a binding like:\n\n```\n<my-tabs @addPanel:to=\"@*addPanel\">\n```\n\nAnd pass the method like:\n\n```\n<my-panel addPanel:from=\"@*addPanel\" title=\"CanJS\">CanJS Content</my-panel>\n```\n\nCheck it out in this demo:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-parent-function.html'></div>\n\nNotice that `@` is used to prevent reading the function. You can read more about the [@ operator in the can-stache docs](https://canjs.com/doc/can-stache/keys/at.html).\n\n",
    "description": "One-way bind a value from the [can-component.prototype.view-model viewModel] or element to the parent scope. \n",
    "title": "toParent:to",
    "name": "can-stache-bindings.toParent",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 2,
    "signatures": [
      {
        "code": "childProp:to=\"key\"",
        "description": "\n\nExports `childProp` in the [can-component.prototype.ViewModel ViewModel] to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n`key` with the value of `childProp` when `childProp` changes.\n\n```\n<my-component someProp:to=\"value\"/>\n```\n\n> __Note:__ If [can-stache.key] is an object, changes to the objects properties will still be visible to the component. Objects are passed by reference. See [can-stache-bindings#OneWayBindingWithObjects One Way Binding With Objects].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "childProp",
            "description": "The name of the property to export from the\nchild components viewmodel. Use `this:to` or `.:to` to export the entire viewModel.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression that will be used to set in the parent scope.\n"
          }
        ]
      },
      {
        "code": "child-prop:to=\"key\"",
        "description": "\n\n  Exports the element’s `child-prop` property or attribute to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n  `key` with the value of `child-prop` when `child-prop` changes.\n\n  ```\n  <input value:to=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element’s property or attribute to export.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression whose resulting value with be used to set in the parent scope.\n"
          }
        ]
      },
      {
        "code": "vm:childProp:to=\"key\"",
        "description": "\n\nExports `childProp` in the [can-component.prototype.ViewModel ViewModel] to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n`key` with the value of `childProp` when `childProp` changes.\n\n```\n<my-component vm:someProp:to=\"value\"/>\n```\n\n> __Note:__ If [can-stache.key] is an object, changes to the objects properties will still be visible to the component. Objects are passed by reference. See [can-stache-bindings#OneWayBindingWithObjects One Way Binding With Objects].\n\nParameters are the same as [can-stache-bindings.toParent#childProp_to__key_ childProp:to=\"key\"]\n",
        "params": []
      },
      {
        "code": "el:child-prop:to=\"key\"",
        "description": "\n\n  Exports the element’s `child-prop` property or attribute to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n  `key` with the value of `child-prop` when `child-prop` changes.\n\n  ```\n  <input el:value:to=\"name\"/>\n  ```\n\nParameters are the same as [can-stache-bindings.toParent#child_prop_to__key_ child-prop:to=\"key\"]\n",
        "params": []
      },
      {
        "code": "on:VIEW_MODEL_OR_DOM_EVENT:value:to='SCOPE_VALUE'",
        "description": "\n\nIf the element has a [can-component::ViewModel ViewModel], listens to an event on the [can-component::ViewModel ViewModel] and binds the element's value to the SCOPE_VALUE when that event occurs.\n\nIf the element does **not** have a [can-component::ViewModel ViewModel], listens to an event on the element and binds binds the element's value to the SCOPE_VALUE when that event occurs.\n\n```\n<my-component on:show:value:to=\"myScopeProp\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "VIEW_MODEL_OR_DOM_EVENT",
            "description": "A viewModel or DOM event.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "SCOPE_VALUE",
            "description": "A value in the current scope.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "SCOPE_VALUE",
      "description": "A value in the current scope.\n\n"
    },
    "comment": " "
  },
  "can-stache-bindings.twoWay": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/two-way.md"
    },
    "body": "\n## Use\n\n`childProp:bind=\"key\"` is used to two-way bind a value in a [can-component.prototype.ViewModel ViewModel] to\na value in the  [can-view-scope scope].  If one value changes, the other value is updated.\n\nThe following two-way binds the `<edit-plate>` element’s `plateName` to the `editing.licensePlate`\nvalue in the scope.  This allows `plateName` to update if `editing.licensePlate` changes and\n`editing.licensePlate` to update if `plateName` changes.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/two-way.html'></div>\n\nThis demo can be expressed a bit easier with the references scope:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/reference.html'></div>\n\n## Initialization\n\nWhen a binding is being initialized, the behavior of what the viewModel and scope properties\nare set to depends on their initial values.\n\nIf the viewModel value is `not undefined` and the scope is `undefined`, scope will be set to the viewModel value.\n\nIf the viewModel value is `undefined` and the scope is `not undefined`, viewModel will be set to the scope value.\n\nIf both the viewModel and scope are `not undefined`, viewModel will be set to the scope value.\n\n",
    "description": "Two-way bind a value in the [can-component.prototype.view-model viewModel] or the element to the parent scope. \n",
    "title": "twoWay:bind",
    "name": "can-stache-bindings.twoWay",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 3,
    "signatures": [
      {
        "code": "childProp:bind=\"key\"",
        "description": "\n\n  Two-way binds `childProp` in the  [can-component.prototype.ViewModel ViewModel] to\n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n\n  ```\n  <my-component someProp:bind=\"value\"/>\n  ```\n\n  When setting up the binding:\n\n  - If `childProp` is `undefined`, `key` will be set to `childProp`.\n  - If `key` is `undefined`, `childProp` will be set to `key`.\n  - If both `childProp` and `key` are defined, `key` will be set to `childProp`.\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "childProp",
            "description": "The name of the property of the viewModel to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
          }
        ]
      },
      {
        "code": "child-prop:bind=\"key\"",
        "description": "\n\n  Two-way binds the element’s `child-prop` property or attribute to\n  [can-stache.key] in the parent [can-view-scope scope].  If `child-prop` is updated `key` will be updated\n  and vice-versa.\n\n  ```\n  <input value:bind=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element’s property or attribute to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
          }
        ]
      },
      {
        "code": "vm:childProp:bind=\"key\"",
        "description": "\n\n  Two-way binds `childProp` in the  [can-component.prototype.ViewModel ViewModel] to\n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n\n  ```\n  <my-component vm:someProp:bind=\"value\"/>\n  ```\n\n  When setting up the binding:\n\n  - If `childProp` is `undefined`, `key` will be set to `childProp`.\n  - If `key` is `undefined`, `childProp` will be set to `key`.\n  - If both `childProp` and `key` are defined, `key` will be set to `childProp`.\n\n\n\nParameters are the same as [can-stache-bindings.twoWay#childProp_bind__key_ childProp:bind=\"key\"]\n",
        "params": []
      },
      {
        "code": "el:child-prop:bind=\"key\"",
        "description": "\n\n  Two-way binds the element’s `child-prop` property or attribute to\n  [can-stache.key] in the parent [can-view-scope scope].  If `child-prop` is updated `key` will be updated\n  and vice-versa.\n\n  ```\n  <input el:value:bind=\"name\"/>\n  ```\n\nParameters are the same as [can-stache-bindings.twoWay#child_prop_bind__key_ child-prop:bind=\"key\"]\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache-converters.boolean-to-inList": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/boolean-to-inList.md"
    },
    "body": "\n## Use\n\nUse this converter when two-way binding to an element with a boolean attribute, such as a checkbox.\n\n```js\nvar map = new DefineMap({\n\titem: 5,\n\tlist: [1, 2, 3, 4, 5]\n});\n\nvar template = stache('<input type=\"checkbox\" checked:bind=\"boolean-to-inList(item, list)\" />');\n\ndocument.body.appendChild(template(map));\n\nvar input = document.querySelector('input[type=checkbox]');\n\nconsole.log(input.checked); // -> true\n\nmap.item = 6;\n\nconsole.log(input.checked); // -> false\n\nmap.list.push(6);\n\nconsole.log(input.checked); // -> true\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-checkbox.html'></div>\n\n",
    "description": "A [can-stache.registerConverter converter] that binds a boolean attribute, such as an `<input>` value, to whether or not an item is in a list. \n",
    "title": "boolean-to-inList",
    "name": "can-stache-converters.boolean-to-inList",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "boolean-to-inList(item, list)",
        "description": "\n\nWhen the getter is called, returns true if **item** is within the **list**, determined using `.indexOf`.\n\nWhen the setter is called, if the new value is truthy then the item will be added to the list using `.push`; if it is falsey the item will removed from the list using `.splice`.\n\n```handlebars\n<input type=\"checkbox\" checked:bind=\"boolean-to-inList(item, list)\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "The item to which to check"
          },
          {
            "types": [
              {
                "type": "can-define/list/list"
              },
              {
                "type": "can-list"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "list",
            "description": "The list"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element’s value changes.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-define/list/list"
        },
        {
          "type": "can-list"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "list",
      "description": "The list"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element’s value changes.\n"
    },
    "comment": " "
  },
  "can-stache-converters.either-or": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/either-or.md"
    },
    "body": "\n## Use\n\n**either-or** is made to be used with `<input type=checkbox>` elements when there is a binary decision that can be made (so that multiple radio buttons are not needed).\n\nYou pass 3 arguments to this [can-stache.registerConverter converter]. The first argument is a compute that represents the chosen value. The second argument is the default, truthy, value. And the third argument is the falsey value.\n\n\n```handlebars\n<p>\n\t<input type=\"checkbox\"\n\t\tchecked:bind=\"either-or(~pref, 'Star Trek', 'Star Wars')\" />\n\t<span>Star Trek</span>\n</p>\n\n<p>Your fandom: {{pref}}</p>\n```\n\n```js\nvar template = stache.from(\"demo-template\");\n\nvar fan = new DefineMap({\n\tpref: \"Star Trek\"\n});\n\ndocument.body.appendChild(template(fan));\n\n// User unchecks the checkbox\nfan.pref === \"Star Wars\";\n\n// Changing the value in code:\nfan.pref === \"Star Trek\";\n\n// Checkbox is now checked again.\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-checkbox-binary.html'></div>\n\n",
    "description": "A [can-stache.registerConverter converter] that two-way binds to a checkbox two values provided as arguments. This converter is useful when you have a binary decision between two fixed values. \n",
    "title": "either-or",
    "name": "can-stache-converters.either-or",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "either-or(~chosen, a, b)",
        "description": "\n\nWhen the getter is called, gets the value of the **chosen** compute and if it is equal to **a**, returns true, otherwise it returns false.\n\nWhen the setter is called, if the new value is truthy, sets the **chosen** [can-compute] to **a**’s value, otherwise sets it to **b**’s value.\n\n```handlebars\n<span>Favorite superhero:</span>\n<input type=\"checkbox\" checked:bind=\"either-or(~chosen, 'Batman', 'Superman')\"> Batman?\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "chosen",
            "description": "A compute where the chosen value (between `a` and `b` is stored). When the setter is called, this compute’s value will be updated.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "a",
            "description": "The `true` value. If the checkbox is checked, then **a**’s value will be stored in the **chosen** compute.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "b",
            "description": "The `false` value. If the checkbox is unchecked, then **b**’s value will be stored in the **chosen** compute.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter bound to the element or a component's viewModel.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "b",
      "description": "The `false` value. If the checkbox is unchecked, then **b**’s value will be stored in the **chosen** compute.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter bound to the element or a component's viewModel.\n"
    },
    "comment": " "
  },
  "can-stache-converters.examples": {
    "name": "can-stache-converters.examples",
    "title": "Examples",
    "type": "group",
    "parent": "can-stache-converters",
    "description": "",
    "order": 0
  },
  "can-stache-converters.converters": {
    "name": "can-stache-converters.converters",
    "title": "Converters",
    "type": "group",
    "parent": "can-stache-converters",
    "description": "",
    "order": 0
  },
  "can-stache-converters": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/can-stache-converters.md"
    },
    "body": "\n\n## Use\n\nThe **can-stache-converters** plugin provides a set of useful converters useful for binding to form elements.\n\nAdd a binding with a converter to an input or select element and\nthe element's value will be cross-bound to an observable value specified by the binding attribute's value.\n\nDepending on the element and the element's type, different behaviors to properly synchronize view model data\nand element attributes.\n\n## input type=text\n\n`value:bind=\"key\"` cross-binds the input's string text value with the observable value.\n\nThe value of the observable is changed after the input's `change` event,\nwhich is after `blur`.\n\n## input type=checkbox\n\n`checked:bind=\"key\"` cross-binds the checked property to a true or false value.\n\n`checked:bind=\"boolean-to-inList(~key, list)\"` cross-binds the checked property to `key` being added to / removed from `list`.  The tilde (`~`) is important here because the compute it sets up acts as a channel between the element's property and the scope's property.\n\n`checked:bind=\"either-or(~key, checkedval, uncheckedval)\"` cross-binds the checked property to `key`, but uses the `checkedval`\nvalue to represent checked, and the `uncheckedval` value to represent unchecked.\n\n## input type='radio'\n\n`checked:bind=\"key\"` cross-binds the checked property to `key` being true or false.\n\n`checked:bind=\"equal(~key, value)\"` cross-binds the checked property to `key` having a value equal to `value`. This is useful for radio groups representing options for a single data property.\n\n## select\n\n`value:bind=\"key\"` cross-binds the selected option value with an observable value.\n\nFor multiple-selection lists, `values:bind=\"key\"` cross-binds selected options with membership in `key`, with the requirement that `key` on the scope is an array-like or a string.  If `key` is a string, it is treated as a comma-separated list of values.\n\n## textarea\n\n`value:bind=\"key\"` cross-binds the textarea's string text value with the observable value.\n\nThe value of the observable is changed after the textarea's `change` event,\nwhich is after `blur`.\n\n> There is a way of making changes respond to key events as well: `on:keyup=\"%scope.set('key', %element.value)`.  However, this  sets the value of `key` at the current scope level.  If `key` was set at a higher level of the scope, the cross binding of `value:bind` will not point to the same item as the keyup target.\n\n\n",
    "description": "\nProvides a set of [can-stache.registerConverter converters] useful for two-way binding with form elements such as `<input>` and `<select>`.\n",
    "type": "module",
    "title": "",
    "name": "can-stache-converters",
    "parent": "can-views",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "DoneJS Contributors",
        "email": "contact@bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-stache-converters/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-stache": "^3.1.0",
        "can-stache-bindings": "^3.2.0",
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Common converters for Stache",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-compute": "^3.1.0",
        "can-define": "^1.2.0",
        "can-event": "^3.5.0",
        "detect-cyclic-packages": "^1.1.0",
        "documentjs": "^0.4.2",
        "done-serve": "^1.2.0",
        "donejs-cli": "^1.0.1",
        "generator-donejs": "^1.0.5",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-stache-converters",
      "keywords": [
        "Done",
        "JS",
        "Can",
        "JS"
      ],
      "main": "can-stache-converters",
      "name": "can-stache-converters",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-stache-converters.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-stache-converters"
      },
      "version": "3.2.2"
    },
    "comment": " "
  },
  "can-stache-converters.equal": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/equal.md"
    },
    "body": "\n## Use\n\nThis [can-stache-converters converter] will most often be used in conjunction with a radio input in order to bind a scope’s value (such as string, but could be any value) based on the selection of the radio group.\n\nIn this example we are using objects, to select a captain from one of three players:\n\n```handlebars\n{{#each players}}\n\t<input type=\"radio\" checked:bind=\"equal(~captain, this)\" /> {{name}}\n{{/each}}\n```\n\n```js\nvar template = stache.from(\"demo\");\nvar vm = new DefineMap({\n\tcaptain: null,\n\tplayers: [\n\t\t{ name: \"Matthew\" },\n\t\t{ name: \"Wilbur\" },\n\t\t{ name: \"Anne\" }\n\t]\n});\nvm.captain = vm.players[0];\n\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-radio.html'></div>\n\n\n",
    "description": "A [can-stache.registerConverter converter] that is usually for binding to a `<input type=\"radio\">` group, so that a scope value can be set the radio group’s selected value. \n",
    "title": "equal",
    "name": "can-stache-converters.equal",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "equal(~compute, value)",
        "description": "\n\nWhen the getter is called **compute**, a [can-compute.computed], is compared to **value** and if they are equal, returns true.\n\nWhen the setter is called, if the radio is now checked the **compute**'s setter is called with **value** as the value.\n\n```handlebars\n<input type=\"radio\" checked:bind=\"equal(~color, 'red')\" /> Red\n<input type=\"radio\" checked:bind=\"equal(~color, 'blue')\" /> Blue\n```\n\nIn this example, the `color` scope value will be set to 'red' when the first radio is selected and 'blue' when the second radio is selected.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "A compute whose value will be compared to the second argument."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "A value of any type, that will be compared to the compute's internal value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound to the radio's checked property.\n"
        }
      },
      {
        "code": "equal(valueOne, valueTwo)",
        "description": "\n\nWhen the getter is called the two values will be compared and if they are equal, returns true.\n\nIn this example there is only a one-way binding, parent to child, so there is no setter case.  This removes the requirement that the first argument is converted to a compute with `~`.\n\n```handlebars\n<my-modal show:from=\"equal(showModal, true)\" />\n```\n\nIn this example, the `show` value of `my-modal`'s view model will be set to `true` when `showModal` in the scope is set to true.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "valueOne",
            "description": "A value of any type, that will be compared to valueTwo."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "valueTwo",
            "description": "A value of any type, that will be compared to valueOne.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be one-way bound to the `show` property.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be one-way bound to the `show` property.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "valueTwo",
      "description": "A value of any type, that will be compared to valueOne.\n"
    },
    "comment": " "
  },
  "can-stache-converters.index-to-selected": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/index-to-selected.md"
    },
    "body": "\n## Use\n\nThis will most often be used in conjunction with a `<select>` element and a bunch of options.\n\nThe provided `item` **must** be a [can-compute] so that its value can be set when the user selects own of the dropdown options.\n\nYou **must** use the indexes from the list as your `<option>` values. This is how it looks up items in the list both in the getter and the setter.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/index-to-selected.html'></div>\n\n",
    "description": "A [can-stache.registerConverter converter] that binds to a `<select>` value in order to two-way bind a selected item from a list to the selected item's index as a viewModel property. \n",
    "title": "index-to-selected",
    "name": "can-stache-converters.index-to-selected",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "index-to-selected(~item, list)",
        "description": "\n\nWhen the getter is called, returns the index of the passed in item (which should be a [can-compute] from the provided list.\n\nWhen the setter is called, takes the selected index value and finds the item from the list with that index and passes that to set the compute’s value.\n\n```handlebars\n<select value:bind=\"index-to-selected(~person, people)\">\n\n\t{{#each people}}\n\n\t\t<option value=\"{{%index}}\">{{name}}</option>\n\n\t{{/each}}\n\n</select>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "item",
            "description": "A compute whose item is in the list."
          },
          {
            "types": [
              {
                "type": "can-define/list/list"
              },
              {
                "type": "can-list"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "list",
            "description": "A list used to find the `item`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound to the select’s value.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-define/list/list"
        },
        {
          "type": "can-list"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "list",
      "description": "A list used to find the `item`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be two-way bound to the select’s value.\n"
    },
    "comment": " "
  },
  "can-stache-converters.examples.input-checkbox": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/input-checkbox.md"
    },
    "body": "\n\n## Binding to checkboxes\n\nTo bind to a checkbox and set a boolean value within your [can-view-scope scope], set up a [can-stache-bindings.twoWay two-way] binding to the input’s `checked` property like so:\n\n```\n<input type=\"checkbox\" checked:bind=\"val\" />\n```\n\n[can-stache-converters] provides a couple of convenient converters that handle common use cases for binding to a checkbox.\n\n## Binding based on whether an item is in a list\n\nUsing [can-stache-converters.boolean-to-inList] is useful to two-way bind to a checkbox based on whether an item is in a list or not. When the checkbox is checked/unchecked, the list will be updated and that item will either be removed or added to the list.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-checkbox.html'></div>\n\n## Binding based on a binary decision\n\nAn alternative true and false value can be specified by using [can-stache-converters.either-or]. This is used for setting up a “boolean” property that only has two possible valid values, whose values are modelled by the true/false checked property of a checkbox, as in the following example:\n\n\n```\n<input type=\"checkbox\" checked:bind=\"either-or(~val, 'a', 'b')\" />\n```\n\nIn this case, the data passed in as `val` is a [can-compute] that contains either the value **a** or **b**. If the value of `val` is **a** then the checkbox will be checked. When the user checks/unchecks the checkbox then the value of `val` is set to be either **a** or **b** depending on whether it is checked.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-checkbox-binary.html'></div>\n\n",
    "description": "\nCross bind a value to a checkbox.\n",
    "name": "can-stache-converters.examples.input-checkbox",
    "title": "input[type=checkbox]",
    "type": "page",
    "parent": "can-stache-converters.examples",
    "comment": " "
  },
  "can-stache-converters.examples.input-radio": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/input-radio.md"
    },
    "body": "\n\n## Binding to radios\n\nTo bind to a radio input, if you have a set of boolean values you can bind to the input’s `checked` property as you do with [can-stache-converters.examples.input-checkbox].\n\n```handlebars\n<input type=\"radio\" {($checked)}=\"one\" /> One\n<input type=\"radio\" {($checked)}=\"two\" /> Two\n```\n\n```js\nvar template = stache.from(\"demo\");\nvar map = new DefineMap({\n\tone: true,\n\ttwo: false\n});\n\ndocument.body.appendChild(template(map));\n```\n\n## Binding to a selected value\n\nMore often than binding to boolean values of each radio's `checked` value, you will want to know what the `value` is of the radio group. Since each radio has its own `value`, the radio's selected value is the value of the radio item that is selected.\n\nUsing the [can-stache-converters.equal] [can-stache.registerConverter converter] you can bind a value within your scope to the radio group’s selected value:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-radio.html'></div>\n\n",
    "description": "\nCross bind a value to a radio input.\n",
    "name": "can-stache-converters.examples.input-radio",
    "title": "input[type=radio]",
    "type": "page",
    "parent": "can-stache-converters.examples",
    "comment": " "
  },
  "can-stache-converters.not": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/not.md"
    },
    "body": "\n## Use\n\nUse this converter to two-way bind to the negation of some value. For example:\n\n```handlebars\n<input type=\"checkbox\" checked:bind=\"not(~val)\" />\n```\n\n```js\nvar map = new DefineMap({\n\tval: true\n});\n\ndocument.body.appendChild(template(map));\n\nvar input = document.querySelector('input');\n\ninput.checked; // -> false\n\nmap.val = false;\n\ninput.checked; // -> true\n\n// Now if you click the checkbox\nmap.val === true; // because the checkbox is now false.\n```\n\n### Combined with other converters\n\n`not()` can be useful when used in combination with other converters that deal with boolean conversion. [can-stache-converters.boolean-to-inList] determines if an item is in a list. Here we wrap `not()` around this conversion so that the inverse is what is saved in the map’s value:\n\n```handlebars\n<input type=\"checkbox\" checked:bind=\"not(~boolean-to-inList(item, list))\" />\n```\n\n```js\nvar map = new DefineMap({\n\titem: 2,\n\tlist: new DefineList([ 1, 2, 3 ])\n});\n\ndocument.body.appendChild(template(map));\nvar input = document.querySelector('input');\n\n\ninput.checked; // -> false\n\n// Set `item` to a value not in the list\nmap.item = 4;\n\ninput.checked; // -> true\n\n// Check the input, whick will set its value to `false`\n// This will be converted to `true` by not() and pushed into the list\n\nmap.list.indexOf(4); // -> 3\n\n// Remove it from the list, which will be converted to true by not()\nmap.list.splice(3, 1);\n\ninput.checked; // -> true\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that two-way binds the negation of a value. \n",
    "title": "not",
    "name": "can-stache-converters.not",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "not(~value)",
        "description": "\n\nWhen the getter is called, gets the value of the compute and returns the negation.\n\nWhen the setter is called, sets the compute’s value to the negation of the new value derived from the element.\n\n*Note* that `not` needs a compute so that it can update the scope’s value when the setter is called.\n\n```handlebars\n<input type=\"checkbox\" checked:bind=\"not(~val)\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "value",
            "description": "A value stored in a [can-compute]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound by [can-stache-bindings] as a getter/setter on the element.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "value",
      "description": "A value stored in a [can-compute]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be two-way bound by [can-stache-bindings] as a getter/setter on the element.\n"
    },
    "comment": " "
  },
  "can-stache-converters.examples.select-multiple": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/select-multiple.md"
    },
    "body": "\n\n## Use\n\nSelect elements with the multiple attribute (`<select multiple values:bind=\"KEY\"/>`)\nhave a specified behavior if the value of KEY is Array-like or\n`undefined`.\n\n## Cross binding to Arrays\n\n`<select>` tags with a multiple attribute cross bind\na [can-map] property, [can-compute.computed] or [can-list]\nin sync with the selected items of the `<select>` element.\n\nFor example, the following template:\n\n    <select multiple values:bind=\"colors\">\n      <option value='red'>Red</option>\n      <option value='green'>Green</option>\n      <option value='yellow'>Yellow</option>\n    </select>\n\nCould be rendered with one of the following:\n\n    // A can-map property\n    new DefineMap({colors: []})\n\n    // A compute\n    { colors: compute([]) }\n\n    // A DefineList\n    { colors: new DefineList() }\n    \n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/multi-values.html'></div>\n\n",
    "description": "\nCross bind a value to a `<select>` element with multiple selections permitted.\n",
    "title": "select[multiple]",
    "name": "can-stache-converters.examples.select-multiple",
    "type": "function",
    "parent": "can-stache-converters.examples",
    "signatures": [
      {
        "code": "<select multiple values:bind=\"KEY\"/>",
        "description": "\n\nCross binds the selected option values with an observable value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can.stache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current \nscope. `KEY`’s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY`’s value should be an Array-like,\nor `undefined`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can.stache.key"
        }
      ],
      "name": "KEY",
      "description": "A named value in the current \nscope. `KEY`’s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY`’s value should be an Array-like,\nor `undefined`.\n"
    },
    "comment": " "
  },
  "can-stache-converters.examples.select": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/select.md"
    },
    "body": "\n\n## Use\n\nThe following cross bind's a `<select>` to a `person` map's `attending` property:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/select.html'></div>\n\n",
    "description": "\nCross bind a value to a `<select>` element.\n",
    "title": "select ",
    "name": "can-stache-converters.examples.select",
    "type": "function",
    "parent": "can-stache-converters.examples",
    "signatures": [
      {
        "code": "value:bind=\"KEY\"",
        "description": "\n\nCross binds the selected option value with an observable value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current \nscope. `KEY`’s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY` should specify either a [can-map]/[can-define/map/map] property or a [can-compute.computed].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "KEY",
      "description": "A named value in the current \nscope. `KEY`’s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY` should specify either a [can-map]/[can-define/map/map] property or a [can-compute.computed].\n"
    },
    "comment": " "
  },
  "can-stache-converters.selected-to-index": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/selected-to-index.md"
    },
    "body": "\n## Use\n\nThe provided `index` **must** be a [can-compute] so that its value can be set on user actions.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/selected-to-index.html'></div>\n\n",
    "description": "A [can-stache.registerConverter converter] that binds an index in a list to the selected item's value as a viewModel property. \n",
    "title": "selected-to-index",
    "name": "can-stache-converters.selected-to-index",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "selected-to-index(~index, list)",
        "description": "\n\nWhen the getter is called, returns the item at the passed in index (which should be a [can-compute] from the provided list.\n\nWhen the setter is called, takes the selected item and finds the index from the list and passes that to set the compute’s value.\n\n```handlebars\n<input value:bind=\"selected-to-index(~index, people)\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "item",
            "description": "A compute whose value is an index from the list."
          },
          {
            "types": [
              {
                "type": "can-define/list/list"
              },
              {
                "type": "can-list"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "list",
            "description": "A list used to find the `item`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound to the value.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-define/list/list"
        },
        {
          "type": "can-list"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "list",
      "description": "A list used to find the `item`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be two-way bound to the value.\n"
    },
    "comment": " "
  },
  "can-stache-converters.string-to-any": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/string-to-any.md"
    },
    "body": "\n## Use\n\nThis is usually used with `<select>`s where you would like to two-way bind a string to a primitive value.\n\n```handlebars\n<select value:bind=\"string-to-any(~someValue)\">\n  <option value=\"2\">Number</option>\n  <option value=\"null\">Null</option>\n  <option value=\"foo\">String</option>\n  <option value=\"true\">Boolean</option>\n  <option value=\"NaN\">NaN</option>\n  <option value=\"Infinity\">Infinity</option>\n</select>\n```\n\n```js\nvar str = document.getElementById('select-template').innerHTML;\nvar template = stache(str);\n\nvar map = new DefineMap({\n\tsomeValue: \"foo\"\n});\n\ndocument.body.appendChild(template(map));\n\nmap.item = NaN; // select.value becomes \"NaN\"\n\n// Click the select box and choose Boolean\nmap.item === true; // -> true\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that binds a value to a primitive value, two-way converted back to that primitive value when the attribute changes. \n",
    "title": "string-to-any",
    "name": "can-stache-converters.string-to-any",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "string-to-any(~item)",
        "description": "\n\nWhen the getter is called, gets the value of the compute and calls `.toString()` on that value.\n\nWhen the setter is called, takes the new value and converts it to the primitive value using [can-util/js/string-to-any/string-to-any] and sets the compute using that converted value.\n\n```handlebars\n<select value:bind=\"string-to-any(~favePlayer)\">\n  <option value=\"23\">Michael Jordan</option>\n\t<option value=\"32\">Magic Johnson</option>\n</select>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "item",
            "description": "A compute holding a primitive value."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element’s value changes.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "item",
      "description": "A compute holding a primitive value."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element’s value changes.\n"
    },
    "comment": " "
  },
  "can.stache.Lookup": {
    "src": {
      "line": 20,
      "codeLine": 27,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "type": "typedef",
    "body": "",
    "description": "",
    "hide": true,
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "types": [
              {
                "type": "String"
              }
            ],
            "description": "A value in the scope to look up.\n"
          }
        ]
      }
    ],
    "name": "can.stache.Lookup"
  },
  "makeEvaluator": {
    "type": "function",
    "name": "makeEvaluator",
    "params": [
      {
        "name": "scope",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "helperOptions",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "nodeList",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": "Either null, #, ^. > is handled elsewhere"
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "exprData",
        "description": "Data about what was in the mustache expression"
      },
      {
        "types": [
          {
            "type": "renderer"
          }
        ],
        "optional": true,
        "name": "truthyRenderer",
        "description": "Used to render a subsection"
      },
      {
        "types": [
          {
            "type": "renderer"
          }
        ],
        "optional": true,
        "name": "falseyRenderer",
        "description": "Used to render the inverse subsection"
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "optional": true,
        "name": "stringOnly",
        "description": "A flag to indicate that only strings will be returned by subsections."
      },
      {
        "types": [
          {
            "type": "can.view.Options"
          }
        ],
        "name": "The",
        "description": "option helpers in which the expression is evaluated."
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 43,
      "codeLine": 55,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Given a mode and expresion data, returns a function that evaluates that expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "stringOnly",
      "description": "A flag to indicate that only strings will be returned by subsections."
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "An 'evaluator' function that evaluates the expression.\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "An 'evaluator' function that evaluates the expression.\n "
    }
  },
  "makeLiveBindingPartialRenderer": {
    "type": "function",
    "name": "makeLiveBindingPartialRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "expressionString",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The html state of where the expression was found."
      },
      {
        "name": "lineNo",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 155,
      "codeLine": 163,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns a renderer function that live binds a partial.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The html state of where the expression was found."
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            }
          ],
          "context": {
            "types": [
              {
                "type": "HTMLElement"
              }
            ]
          }
        }
      ],
      "description": "A renderer function\nlive binds a partial.\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            }
          ],
          "context": {
            "types": [
              {
                "type": "HTMLElement"
              }
            ]
          }
        }
      ],
      "description": "A renderer function\nlive binds a partial.\n "
    }
  },
  "makeStringBranchRenderer": {
    "type": "function",
    "name": "makeStringBranchRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": ""
      },
      {
        "name": "expressionString",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "lineNo",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 239,
      "codeLine": 246,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Return a renderer function that evaluates to a string.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "can.stache.Expression"
        }
      ],
      "name": "expression",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can.view.Scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-stache.renderer"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.renderer"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can.view.Scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-stache.renderer"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.renderer"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "makeLiveBindingBranchRenderer": {
    "type": "function",
    "name": "makeLiveBindingBranchRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": ""
      },
      {
        "name": "expressionString",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The html state of where the expression was found.\n "
      },
      {
        "name": "lineNo",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 296,
      "codeLine": 303,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns a renderer function that evaluates the mustache expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The html state of where the expression was found.\n "
    }
  },
  "splitModeFromExpression": {
    "type": "function",
    "name": "splitModeFromExpression",
    "params": [
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The state of HTML where the expression was found.\n "
      },
      {
        "name": "lineNo",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 409,
      "codeLine": 415,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns the mustache mode split from the rest of the expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The state of HTML where the expression was found.\n "
    }
  },
  "cleanLineEndings": {
    "type": "function",
    "name": "cleanLineEndings",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "template",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 435,
      "codeLine": 441,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Prunes line breaks accoding to the mustache specification.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "template",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    }
  },
  "cleanWhitespaceControl": {
    "type": "function",
    "name": "cleanWhitespaceControl",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "template",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 484,
      "codeLine": 490,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Prunes whitespace according to the whitespace control.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "template",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    }
  },
  "can-symbol/symbols/apply": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-apply.md"
    },
    "body": "",
    "description": "How to apply a List-like as the arguments to a call of the function. \n",
    "type": "typedef",
    "title": "can.apply",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/apply",
    "parent": "can-symbol/symbols/call",
    "signatures": [
      {
        "code": "@@can.apply( obj, args )",
        "description": "\n\nThe `can.apply` symbol points to a Function or callable object's apply function, which converts an ArrayLike of arguments into the positional parameters and calls the function with them.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to call the function on as the bound element"
          },
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "args",
            "description": "The list of arguments to pass to the function\n\n\n ```\nfunction func(c) {\n\treturn c.process();\n};\n\n// Handle non-native lists or even non-list-likes being passed in\nobj[canSymbol.for('can.apply')] = function(ctx, list) {\n\tlist = list.serialize ? list.serialize() : list;\n\tif(!list[canSymbol.for('can.isListLike')]) {\n\t\tlist = [list];\n\t}\n\treturn Function.prototype.apply.call(this, ctx, list); \n};\n```\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "a function or callable"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ArrayLike"
        }
      ],
      "name": "args",
      "description": "The list of arguments to pass to the function\n\n\n ```\nfunction func(c) {\n\treturn c.process();\n};\n\n// Handle non-native lists or even non-list-likes being passed in\nobj[canSymbol.for('can.apply')] = function(ctx, list) {\n\tlist = list.serialize ? list.serialize() : list;\n\tif(!list[canSymbol.for('can.isListLike')]) {\n\t\tlist = [list];\n\t}\n\treturn Function.prototype.apply.call(this, ctx, list); \n};\n```\n"
    }
  },
  "can-symbol/symbols/assignDeep": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-assignDeep.md"
    },
    "body": "",
    "description": "Defines how to copy values onto an object. \n",
    "type": "typedef",
    "title": "can.assignDeep",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-symbol/symbols/assignDeep",
    "parent": "can-symbol/symbols/shape",
    "signatures": [
      {
        "code": "@@can.assignDeep( source )",
        "description": "\n\nThe `can.assignDeep` symbol specifies how a deep assign should happen. This means the copying of\nall of sources values, and child values onto the current object.  \n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "The source of values that will be copied.\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object with named properties"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "The source of values that will be copied.\n"
    }
  },
  "can-symbol/symbols/deleteKeyValue": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-deleteKeyValue.md"
    },
    "body": "",
    "description": "Defines a function that deletes one of an object's named properties. \n",
    "type": "typedef",
    "title": "can.deleteKeyValue",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/deleteKeyValue",
    "parent": "can-symbol/symbols/get-set",
    "signatures": [
      {
        "code": "@@can.deleteKeyValue( key )",
        "description": "\n\nThe `can.deleteKeyValue` symbol points to a Map-like object's property removal function, which removes the object's property with the supplied key. This is only applicable to objects where keyed properties are relevant (like maps).\n\n```\nvar map = {\n\tremoveKey: function (key) {\n\t\tdelete this[key];\n\t}\n}\n\nmap[canSymbol.for('can.deleteKeyValue')] = map.removeKey;\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the key to remove from the object\n\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with named properties"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "the key to remove from the object\n\n"
    }
  },
  "can-symbol/symbols/getKeyDependencies": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-getKeyDependencies.md"
    },
    "body": "",
    "description": "A symbol placed on a constructor to reference a function that returns the other events that will trigger an event for the key on the object. \n",
    "type": "typedef",
    "title": "can.getKeyDependencies",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/getKeyDependencies",
    "parent": "can-symbol/symbols/observe",
    "signatures": [
      {
        "code": "@@can.getKeyDependencies(key)",
        "description": "\n\nThe `@@can.getKeyDependencies` symbol points to a function that returns an object containing all values that affect the\nvalue of a computed property of this Map-like object, keyed on `key`.  \nIf the dependencies include properties on a Map-like object, they are placed in a [can-util/js/cid-map/cid-map CIDMap] \nkeyed on `keyDependencies` in the return object. If the dependencies include the values of Value-like objects, they are \nplaced in a [can-util/js/cid-set/cid-set CIDSet] keyed on `valueDependencies`.\nReturn `undefined` if the value is not computed, or an empty object if a key is computed without external dependencies.\n\n```\nvar someOtherObj;\n// This is a clear but not very useful implementation of a computed key value.\n//  Map-likes in CanJS are backed by can-computes and can-observations, and we recommend can-observation for new development.\nvar obj = {\n\t_computedAttrs: {\n\t\tfoo: [{ \n\t\t\thandler: function() { return canReflect.getKeyValue(someOtherObj, \"bar\") },\n\t\t\treads: [{ object: someOtherObj, key: \"bar\" }]\n\t\t}]\n\t}\n};\n\nobj[canSymbol.for(\"can.getKeyDependencies\")] = function(key) {\n  var ret;\n  if(this._computedAttrs[key]) {\n  \tret = {};\n  \tthis._computedAttrs[key].reads.forEach(function(read) {\n  \t\tif(read.key) {\n  \t\t\tret.keyDependencies = ret.keyDependencies || new CIDMap();\n  \t\t\tif(!ret.keyDependencies.has(read.object)) {\n  \t\t\t\tret.keyDependencies.add(read.object, []);\n  \t\t\t}\n  \t\t\tret.keyDependencies.get(read.object).push(read.key);\n  \t\t} else {\n  \t\t\tret.valueDependencies = ret.valueDependencies || new CIDMap();\n  \t\t\tret.valueDependencies.add(read.object);\n  \t\t}\n  \t});\n  }\n  return ret;\n};\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "a property key on `this`"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "obj a Map-like object"
        },
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object of key dependencies in a CIDMap and value dependencies in a CIDSet\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "a property key on `this`"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "an object of key dependencies in a CIDMap and value dependencies in a CIDSet\n"
    }
  },
  "can-symbol/symbols/getIdentity": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-getIdentity.md"
    },
    "body": "",
    "description": "Returns a name/label that identifies the object \n",
    "type": "typedef",
    "title": "can.getIdentity",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "name": "can-symbol/symbols/getIdentity",
    "parent": "can-symbol/symbols/shape",
    "hide": true,
    "signatures": [
      {
        "code": "@@can.getIdentity()",
        "description": "\n\nThe `@@can.getIdentity` symbol points to a function/value that labels the\nidentity of the object. Ideally this should be a unique identifier, like the\nprimary key (id) in a database table. The `@@can.getName` symbol behavior\nuses the value of `@can.getIdentity` (if set) to decorate its output.\n\nE.g:\n\n```js\nvar obj = {};\nvar canReflect = require(\"can-reflect\");\n\n// without setting `can.getIdentity`\ncanReflect.getName(obj); // -> Object<>\n\nfoo[canSymbol.for(\"can.getIdentity\")] = function() {\n\treturn \"15\";\n};\n\nobj[canSymbol.for(\"can.getIdentity\")](); //-> \"15\"\ncanReflect.getName(obj); // -> Object<15>\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The name/label that identifies the object \n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The name/label that identifies the object \n"
    }
  },
  "can-symbol/symbols/getKeyValue": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-getKeyValue.md"
    },
    "body": "",
    "description": "Defines a function to access and return the value of one of the object's named properties.   \n",
    "type": "typedef",
    "title": "can.getKeyValue",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/getKeyValue",
    "parent": "can-symbol/symbols/get-set",
    "signatures": [
      {
        "code": "@@can.getKeyValue( key )",
        "description": "\n\nThe `can.getKeyValue` symbol points to a Map-like object's property accessor function, which returns the value of the object's property with the supplied key.   This is only applicable to objects where keyed properties are relevant (like maps).\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the key to look up on the object"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with named properties"
        },
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value of the key\n\n\n```\nvar map = {\n\tget: function (key) {\n\t\tObservation.add(this, key);\n\t\treturn this[key];\n\t}\n}\n\nmap[canSymbol.for('can.getKeyValue')] = map.get;\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "the key to look up on the object"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value of the key\n\n\n```\nvar map = {\n\tget: function (key) {\n\t\tObservation.add(this, key);\n\t\treturn this[key];\n\t}\n}\n\nmap[canSymbol.for('can.getKeyValue')] = map.get;\n```\n"
    }
  },
  "can-symbol/symbols/getOwnEnumerableKeys": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-getOwnEnumerableKeys.md"
    },
    "body": "",
    "description": "List the enumerable keys (as defined by its property descriptor) an object has, but not those from its prototype chain. \n",
    "type": "typedef",
    "title": "can.getOwnEnumerableKeys",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-symbol/symbols/getOwnEnumerableKeys",
    "parent": "can-symbol/symbols/shape",
    "signatures": [
      {
        "code": "@@can.getOwnEnumerableKeys()",
        "description": "\n\nReturn the array of enumerable keys for the object, as defined by the custom behavior of this function.\n",
        "params": [],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with named properties"
        },
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "An array of enumerable key strings on the object.\n\n\n```\nvar shapeless = {};\n\n// Nothing enumerable in a shapeless object\nshapeless[canSymbol.for('can.getOwnEnumerableKeys')] = function() { return []; }\n\nvar thingsInMyEar = {};\nObject.defineProperty(thingsInMyEar, \"banana\", {\n\tenumerable: false,\n\tvalue: {\n\t\tpeeled: false\n\t}\n});\n\nthingsInMyEar[canSymbol('can.getOwnEnumerableKeys')] = function() { \n\treturn Object.getOwnPropertyNames(this).filter(function(key) { \n\t\treturn !!Object.getOwnPropertyDescriptor(this, key).enumerable \n\t}.bind(this))\n\t.concat([\"banana\"]);  // There's always a banana in my ear\n};\n\n```\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "An array of enumerable key strings on the object.\n\n\n```\nvar shapeless = {};\n\n// Nothing enumerable in a shapeless object\nshapeless[canSymbol.for('can.getOwnEnumerableKeys')] = function() { return []; }\n\nvar thingsInMyEar = {};\nObject.defineProperty(thingsInMyEar, \"banana\", {\n\tenumerable: false,\n\tvalue: {\n\t\tpeeled: false\n\t}\n});\n\nthingsInMyEar[canSymbol('can.getOwnEnumerableKeys')] = function() { \n\treturn Object.getOwnPropertyNames(this).filter(function(key) { \n\t\treturn !!Object.getOwnPropertyDescriptor(this, key).enumerable \n\t}.bind(this))\n\t.concat([\"banana\"]);  // There's always a banana in my ear\n};\n\n```\n"
    }
  },
  "can-symbol/symbols/getName": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-getName.md"
    },
    "body": "",
    "description": "Returns a human-readable name of an object \n",
    "type": "typedef",
    "title": "can.getName",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "name": "can-symbol/symbols/getName",
    "parent": "can-symbol/symbols/shape",
    "signatures": [
      {
        "code": "@@can.getName()",
        "description": "\n\nThe `@@can.getName` symbol points to a function that returns human-readable name of the object. Depending on the context this name could be decorated with extra information, like the `cid` of a given instance. \n\n\n```js\nvar foo = function() {};\n\nfoo[canSymbol.for('can.getName')] = function() {\n\treturn \"MyFooFunction\";\n};\n\nobj[canSymbol.for('can.getName')]() //-> \"MyFooFunction\"\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The name of the object/function\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The name of the object/function\n"
    }
  },
  "can-symbol/symbols/getOwnKeyDescriptor": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-getOwnKeyDescriptor.md"
    },
    "body": "",
    "description": "Describe the attributes of an object's keyed property. \n",
    "type": "typedef",
    "title": "can.getOwnKeyDescriptor",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/getOwnKeyDescriptor",
    "parent": "can-symbol/symbols/shape",
    "signatures": [
      {
        "code": "@@can.getOwnKeyDescriptor(key)",
        "description": "\n\nReturn a single key's descriptor from the object, as defined by the custom behavior of this function.\n\n\n```\nvar shapeless = {};\n\n// Nothing enumerable in a shapeless object\nshapeless[canSymbol.for('can.getOwnKeyDescriptor')] = function() { return; }\n\n// Banana is on the prototype chain, so default \"own key descriptor\" functions would not return it.\nvar thingsInMyEar = Object.create(\n\t\"banana\": {\n\t\tpeeled: false\n\t}\n});\n\nthingsInMyEar[canSymbol.for('can.getOwnKeyDescriptor')] = function(key) { \n\tif(Object.getOwnPropertyNames(this).indexOf(key) || key === \"banana\") {\n\t\treturn !!Object.getOwnPropertyDescriptor(this, key) ||\n\t\t\tthis[canSysmbol.for('can.getOwnKeyDescritpor')].call(this[canSymbol.for('proto')], key);\n\t};  // There's always a banana in my ear\n};\n\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The string key to look up on the object"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with named properties"
        },
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a property descriptor, containing the keys `configurable`, `enumerable`, and either `value` and `writable`, or `get` and `set`, if the property exists on the object; `undefined` otherwise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The string key to look up on the object"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a property descriptor, containing the keys `configurable`, `enumerable`, and either `value` and `writable`, or `get` and `set`, if the property exists on the object; `undefined` otherwise.\n"
    }
  },
  "can-symbol/symbols/getOwnKeys": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-getOwnKeys.md"
    },
    "body": "",
    "description": "List which keys an object has of its own (not other objects on the prototype chain). \n",
    "type": "typedef",
    "title": "can.getOwnKeys",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-symbol/symbols/getOwnKeys",
    "parent": "can-symbol/symbols/shape",
    "signatures": [
      {
        "code": "@@can.getOwnKeys()",
        "description": "\n\nReturn all string keys on an object, including those whose corresponding properties are defined not to be enumerable.\n\n```\nvar shapeless = {};\n\n// Nothing enumerable in a shapeless object\nshapeless[canSymbol.for('can.getOwnKeys')] = function() { return []; }\n\nvar thingsInMyEar = {};\nObject.setPrototypeOf(thingsInMyEar, {\n\t\"banana\": {\n\t\tpeeled: false\n\t}\n});\n\nthingsInMyEar[canSymbol('can.getOwnEnumerableKeys')] = function() { \n\treturn Object.getOwnPropertyNames(this)\n\t\t.concat([\"banana\"]);  // There's always a banana in my ear\n};\n\n```\n",
        "params": [],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with named properties"
        },
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "an array of Strings representing the object's string keys.\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "an array of Strings representing the object's string keys.\n\n"
    }
  },
  "can-symbol/symbols/getValue": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-getValue.md"
    },
    "body": "",
    "description": "Defines a function that returns the object's current value when called. \n",
    "type": "typedef",
    "title": "can.getValue",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-symbol/symbols/getValue",
    "parent": "can-symbol/symbols/get-set",
    "signatures": [
      {
        "code": "@@can.getValue()",
        "description": "\n\nThe `@@can.getValue` symbol points to a function that returns the context object's value. Value may mean different\nthings in different contexts; e.g. a `can-compute`'s value is the value stored internally to the compute, while an observable object's value may be a non-observable, serialized representation of its properties.\n\n```\nvar internalValue = undefined\nexport var foo = function(val) {\n\tif(val) {\n\t\tinternalValue = val;\n\t} else {\n\t\treturn internalValue;\n\t}\n};\n\n// Get the internal value as the representative value\nfoo[canSymbol.for('can.getValue')] = function() { \n\treturn internalValue;\n}\n\n```\n",
        "params": [],
        "context": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "anything that can be resolved to a value"
        },
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "any value\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "any value\n"
    }
  },
  "can-symbol/symbols/getValueDependencies": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-getValueDependencies.md"
    },
    "body": "",
    "description": "A symbol placed on a constructor to reference a function that returns the other events that will trigger a value change event on the object. \n",
    "type": "typedef",
    "title": "can.getValueDependencies",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "ValueLike"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/getValueDependencies",
    "parent": "can-symbol/symbols/observe",
    "signatures": [
      {
        "code": "@@can.getValueDependencies()",
        "description": "\n\nThe `@@can.getValueDependencies` symbol points to a function that returns an object containing all values that affect the\nvalue of this Value-like object.\nIf the dependencies include properties on a Map-like object, they are placed in a [can-util/js/cid-map/cid-map CIDMap] \nkeyed on `keyDependencies` in the return object. If the dependencies include the values of Value-like objects, they are \nplaced in a [can-util/js/cid-set/cid-set CIDSet] keyed on `valueDependencies`.\nReturn `undefined` if the value is not computed, or an empty object if a key is computed without external dependencies.\n\n```\nvar someOtherObj;\n// This is a clear but not very useful implementation of a computed value.\n// We recommend can-observation for new development of computed values.\nvar val = function() { \n\treturn canReflect.getKeyValue(someOtherObj, \"bar\");\n};\nval.reads: [{ object: someOtherObj, key: \"bar\" }]\n\nval[canSymbol.for(\"can.getValueDependencies\")] = function(key) {\n  var ret;\n  if(this.reads) {\n  \tret = {};\n  \tthis.reads.forEach(function(read) {\n  \t\tif(read.key) {\n  \t\t\tret.keyDependencies = ret.keyDependencies || new CIDMap();\n  \t\t\tif(!ret.keyDependencies.has(read.object)) {\n  \t\t\t\tret.keyDependencies.add(read.object, []);\n  \t\t\t}\n  \t\t\tret.keyDependencies.get(read.object).push(read.key);\n  \t\t} else {\n  \t\t\tret.valueDependencies = ret.valueDependencies || new CIDMap();\n  \t\t\tret.valueDependencies.add(read.object);\n  \t\t}\n  \t});\n  }\n  return ret;\n};\n```\n",
        "params": [],
        "context": {
          "types": [
            {
              "type": "ValueLike"
            }
          ],
          "description": "obj an object with its own value having possible dependencies on other values"
        },
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with an optional CIDMap of key dependencies and an optional CIDSet of value dependencies\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "an object with an optional CIDMap of key dependencies and an optional CIDSet of value dependencies\n"
    }
  },
  "can-symbol/symbols/hasOwnKey": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-hasOwnKey.md"
    },
    "body": "",
    "description": "Define a function to determine key membership of an object \n",
    "type": "typedef",
    "title": "can.hasOwnKey",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/hasOwnKey",
    "parent": "can-symbol/symbols/shape",
    "signatures": [
      {
        "code": "@@can.hasOwnKey(key)",
        "description": "\n\nThe `@@can.hasOwnKey` symbol points to a function on an object that, given a String key, determines whether the key is a member of the object's own key set (not that of the prototype chain).\n\n```\nvar shapeless = {};\n\n// Nothing enumerable in a shapeless object\nshapeless[canSymbol.for('can.hasOwnKey')] = function() { return false; }\n\nvar thingsInMyEar = {};\nObject.setPrototypeOf(thingsInMyEar, {\n\t\"banana\": {\n\t\tpeeled: false\n\t}\n});\n\nthingsInMyEar[canSymbol('can.hasOwnKey')] = function(key) { \n\treturn key === \"banana\" || Object.getOwnPropertyNames(this).indexOf(key) > -1\n\t// There's always a banana in my ear\n};\n\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the string key for which to test membership in the object"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "any object with key properties"
        },
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "true if there is a property on the object with a matching key, false otherwise.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "the string key for which to test membership in the object"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "true if there is a property on the object with a matching key, false otherwise.\n\n"
    }
  },
  "can-symbol/symbols/isListLike": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-isFunctionLike.md"
    },
    "body": "",
    "description": "Set to `true` on objects with numeric indexes and length. \n",
    "type": "typedef",
    "title": "can.isListLike",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "name": "can-symbol/symbols/isListLike",
    "parent": "can-symbol/symbols/type",
    "signatures": [
      {
        "code": "@@can.isListLike",
        "description": "\n\nSetting the value of `can.isListLike` to `true` on an object shows that this object can be used with numeric properties, like a [can-define/list/list DefineList].\n",
        "params": []
      }
    ]
  },
  "can-symbol/symbols/isFunctionLike": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-isListLike.md"
    },
    "body": "",
    "description": "Set to `true` on objects with numeric indexes and length. \n",
    "type": "typedef",
    "title": "can.isFunctionLike",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "name": "can-symbol/symbols/isFunctionLike",
    "parent": "can-symbol/symbols/type",
    "signatures": [
      {
        "code": "@@can.isFunctionLike",
        "description": "\n\nSetting the value of `can.isFunctionLike` to `true` on an object shows that this object can be called as a function. Setting it to `false` on a function shows that it should not be called as a function.\n",
        "params": []
      }
    ]
  },
  "can-symbol/symbols/isMapLike": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-isMapLike.md"
    },
    "body": "",
    "description": "Set to `true` to show that an object is usable like a Map with named properties. \n",
    "type": "typedef",
    "title": "can.isMapLike",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "name": "can-symbol/symbols/isMapLike",
    "parent": "can-symbol/symbols/type",
    "signatures": [
      {
        "code": "@@can.isMapLike = true",
        "description": "\n\nShows that this object can be used with named properties, like a [can-define/map/map DefineMap].\n",
        "params": []
      }
    ]
  },
  "can-symbol/symbols/isValueLike": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-isValueLike.md"
    },
    "body": "",
    "description": "Set to `true` to show than an object is usable like an atomic value (a number, string, boolean, or undefined value). \n",
    "type": "typedef",
    "title": "can.isValueLike",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "name": "can-symbol/symbols/isValueLike",
    "parent": "can-symbol/symbols/type",
    "signatures": [
      {
        "code": "@@can.isValueLike = true",
        "description": "\n\nShows that this object can be used as an atomic value; it may make sense to also implement `valueOf()` and [can-symbol/symbols/getValue `@@can.getValue()`]\n\nIn the case of a MapLike, an object is ValueLike if and only if:\n\n* it always returns the same value from `getValue`; and\n* the same value that is set from `setValue` is returned by `getValue`\n",
        "params": []
      }
    ]
  },
  "can-symbol/symbols/keyHasDependencies": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-keyHasDependencies.md"
    },
    "body": "",
    "description": "Check if there are any other objects that affect the value of a named property. \n",
    "type": "typedef",
    "title": "can.keyHasDependencies",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/keyHasDependencies",
    "parent": "can-symbol/symbols/observe",
    "signatures": [
      {
        "code": "@@can.keyHasDependencies(key)",
        "description": "\n\nThe `@@can.keyHasDependencies` symbol points to a function that returns `true` if there are any other events or property \nchanges that will change the value of the property on the context object with key `key`; `false` otherwise.  \nBy convention, if an object implementation distinguishes between unbound objects or values, and those \nwhich are bound without external dependencies (as is the case with [can-map]), `@@can.keyHasDependencies` may return \n`undefined` for unbound objects instead of `false`.\n\n```\nvar someOtherObj;\nvar obj = {\n\t__bindEvents: {\n\t\tfoo: [{ \n\t\t\thandler: function() {},\n\t\t\treads: [{ object: someOtherObj, key: \"bar\" }]\n\t\t}]\n\t}\n};\n\nobj[canSymbol.for(\"can.keyHasDependencies\")] = function(key) {\n\treturn this.__bindEvents[key] && \n\t\tthis.__bindEvents[key].filter(function(binding) {\n\t\t\treturn binding.reads && binding.reads.length > 0;\n\t\t}).length > 0;\n};\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the key to check for dependent bindings"
          }
        ],
        "context": {
          "types": [
            {
              "type": "MapLike"
            }
          ],
          "description": "any map-like object with named properties"
        },
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "true if there are any other objects that this keyed propertey depends on\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "the key to check for dependent bindings"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "true if there are any other objects that this keyed propertey depends on\n\n"
    }
  },
  "can-symbol/symbols/offKeyValue": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-offKeyValue.md"
    },
    "body": "",
    "description": "Defines how observable values can be listened to on a type. \n\n",
    "type": "typedef",
    "title": "can.offKeyValue",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/offKeyValue",
    "parent": "can-symbol/symbols/observe",
    "signatures": [
      {
        "code": "@@can.offKeyValue( key, handler(newValue) )",
        "description": "\n\nthe `@@can.offKeyValue` symbol is placed on a Map-like object to point to a function used to stop listening to changes on the `key` property with the `handler` function.\n\n\n```\nvar obj = {\n\thandlers: {},\n\tsetKeyValue: function(key, value){\n\t\tthis[key] = value;\n\t\tvar self = this;\n\t\tobj.handlers[key].forEach(function(handler){\n\t\t\thandler.call(self, value);\n\t\t});\n\t}\n};\n\nobj[canSymbol.for(\"can.offKeyValue\")] = function(key, handler){\n\tif(!obj.handlers[key]) {\n\t\tobj.handlers[key] = [];\n\t}\n\tobj.handlers[key].splice(obj.handlers[key].indexOf(handler), 1);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the string key to stop binding on changes to."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The handler that was previously bound with [can-symbol/symbols/onKeyValue `@@can.onKeyValue`]\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "any Map-like object with named properties"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ],
          "context": {
            "types": [
              {
                "type": "*"
              }
            ]
          }
        }
      ],
      "name": "handler",
      "description": "The handler that was previously bound with [can-symbol/symbols/onKeyValue `@@can.onKeyValue`]\n"
    }
  },
  "can-symbol/symbols/new": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-new.md"
    },
    "body": "",
    "description": "Create a new instance of a constructor function or prototype object. \n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "variable": true
          }
        ]
      }
    ],
    "title": "can.new",
    "name": "can-symbol/symbols/new",
    "type": "property",
    "parent": "can-symbol/symbols/call",
    "signatures": [
      {
        "code": "@@can.new(...args)",
        "description": "\n\nThe `@@can.new` symbol points to a function that constructs and returns a new instance object.  It is left to the\nimplementation to create the object, set the prototype chain, and handle any arguments passed to the constructor.\n\n```\nfunction constructor() {}\nconstructor.prototype = { foo: \"bar\" };\n\n// ES6 rest and spread params used below to be concise.\nconstructor[canSymbol.for(\"can.new\")] = function(...args) {\n\treturn new this(...args);\n};\n\nvar prototype = { baz: \"quux\" };\nprototype[canSymbol.for(\"can.new\")] = function(props) {\n\treturn Object.create(this, props);\n};\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "pass any number of parameters of any type"
          }
        ],
        "context": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "A callable constructor or a prototype object."
        },
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A new instance of the type.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "pass any number of parameters of any type"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A new instance of the type.\n"
    }
  },
  "can-symbol/symbols/offValue": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-offValue.md"
    },
    "body": "",
    "description": "Defines how observables can stop listening to the object's value changing. \n",
    "type": "typedef",
    "title": "can.offValue",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/offValue",
    "parent": "can-symbol/symbols/observe",
    "signatures": [
      {
        "code": "@@can.offValue( handler(newValue) )",
        "description": "\n\nThe `@@can.offValue` symbol points to a function that unregisters \n `handler` from being called when the object's value\n changes.  \n\n```\nvar obj = function(value) {\n\tif(arguments.length >= 1) {\n\t\tobj.currentValue = value;\n\t\tobj.handlers.forEach(function(handler){\n\t\t\thandler.call(obj, value);\n\t\t});\n\t} else {\n\t\treturn obj.currentValue;\n\t}\n};\n\nobj[canSymbol.for(\"can.offValue\")] = function(handler){\n\tif(!obj.handlers) {\n\t\tobj.handlers = [];\n\t}\n\tobj.handlers.splice(obj.handlers.indexOf(handler), 1);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The handler was previously added with [can-symbol/symbols/onValue `@@can.onValue`]. \n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "any object with a mutable value"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ],
          "context": {
            "types": [
              {
                "type": "*"
              }
            ]
          }
        }
      ],
      "name": "handler",
      "description": "The handler was previously added with [can-symbol/symbols/onValue `@@can.onValue`]. \n"
    }
  },
  "can-symbol/symbols/onKeyValue": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-onKeyValue.md"
    },
    "body": "",
    "description": "Defines how observable values can be listened to on a type. \n",
    "type": "typedef",
    "title": "can.onKeyValue",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/onKeyValue",
    "parent": "can-symbol/symbols/observe",
    "signatures": [
      {
        "code": "@@can.onKeyValue( key, handler(newValue) )",
        "description": "\n\nThe `@@can.onKeyValue` symbol points to a function that registers \n `handler` to be called back with the new value of `key` when `key`\n changes.  \n\n ```\nvar obj = {\n\thandlers: {},\n\tsetKeyValue: function(key, value){\n\t\tthis[key] = value;\n\t\tvar self = this;\n\t\tobj.handlers[key].forEach(function(handler){\n\t\t\thandler.call(self, value);\n\t\t});\n\t}\n};\n\nobj[canSymbol.for(\"can.onKeyValue\")] = function(key, handler){\n\tif(!obj.handlers[key]) {\n\t\tobj.handlers[key] = [];\n\t}\n\tobj.handlers[key].push(handler);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the string key to bind on changes to."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The handler must be called back with `this` as the instance of the observable. \n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "any Map-like object with named properties"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ],
          "context": {
            "types": [
              {
                "type": "*"
              }
            ]
          }
        }
      ],
      "name": "handler",
      "description": "The handler must be called back with `this` as the instance of the observable. \n"
    }
  },
  "can-symbol/symbols/onKeys": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-onKeys.md"
    },
    "body": "",
    "description": "Define a function used to listen to when the object's key set changes. \n",
    "type": "typedef",
    "title": "can.onKeys",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/onKeys",
    "parent": "can-symbol/symbols/observe",
    "signatures": [
      {
        "code": "@@can.onKeys( handler(newValue) )",
        "description": "\n\nThe `@@can.onKeys` symbol points to a function that registers \n `handler` to be called back when the keys on the object\n change via new properties or deletions.\n\n```\nvar obj = {\n\thandlers: {},\n\tsetKeyValue: function(key, value){\n\t\tvar newKey = this[canSymbol.for(\"hasOwnKey\")](key);\n\t\tthis[key] = value;\n\t\tvar self = this;\n\t\tif(newKey) {\n\t\t\tobj.handlers.__keys.forEach(function(handler){\n\t\t\t\thandler.call(self, this[canSymbol.for(\"getOwnKeys\")]());\n\t\t\t});\n\t\t}\n\t}\n};\n\nobj[canSymbol.for(\"can.onKeys\")] = function(handler){\n\tif(!obj.handlers.__keys) {\n\t\tobj.handlers.__keys = [];\n\t}\n\tobj.handlers.__keys.push(handler);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ],
                    "name": "newValue"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The handler must be called back with `this` as the instance of the observable, and passed the current key set as an Array.\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "any Map-like object with named properties"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ],
              "name": "newValue"
            }
          ],
          "context": {
            "types": [
              {
                "type": "*"
              }
            ]
          }
        }
      ],
      "name": "handler",
      "description": "The handler must be called back with `this` as the instance of the observable, and passed the current key set as an Array.\n"
    }
  },
  "can-symbol/symbols/onKeysAdded": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-onKeysAdded.md"
    },
    "body": "",
    "description": "Define a function used to listen to when the object's key set has new additions. \n",
    "type": "typedef",
    "title": "can.onKeysAdded",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/onKeysAdded",
    "parent": "can-symbol/symbols/observe",
    "signatures": [
      {
        "code": "@@can.onKeysAdded( handler(newValue) )",
        "description": "\n\nThe `@@can.onKeysAdded` symbol points to a function that registers \n `handler` to be called back when the keys on the object\n change via new properties added.\n\n```\nvar obj = {\n\thandlers: {},\n\tsetKeyValue: function(key, value){\n\t\tvar newKey = this[canSymbol.for(\"hasOwnKey\")](key);\n\t\tthis[key] = value;\n\t\tvar self = this;\n\t\tif(newKey) {\n\t\t\tobj.handlers.__keysAdded.forEach(function(handler){\n\t\t\t\thandler.call(self, [key]);\n\t\t\t});\n\t\t}\n\t}\n};\n\nobj[canSymbol.for(\"can.onKeysAdded\")] = function(handler){\n\tif(!obj.handlers.__keysAdded) {\n\t\tobj.handlers.__keysAdded = [];\n\t}\n\tobj.handlers.__keysAdded.push(handler);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ],
                    "name": "newValue"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The handler must be called back with `this` as the instance of the observable, and passed the added keys as an Array.\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "any Map-like object with named properties"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ],
              "name": "newValue"
            }
          ],
          "context": {
            "types": [
              {
                "type": "*"
              }
            ]
          }
        }
      ],
      "name": "handler",
      "description": "The handler must be called back with `this` as the instance of the observable, and passed the added keys as an Array.\n"
    }
  },
  "can-symbol/symbols/onValue": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-onValue.md"
    },
    "body": "",
    "description": "Defines how observables can listen to the object's value changing. \n",
    "type": "typedef",
    "title": "can.onValue",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/onValue",
    "parent": "can-symbol/symbols/observe",
    "signatures": [
      {
        "code": "@@can.onValue( handler(newValue) )",
        "description": "\n\nThe `@@can.onValue` symbol points to a function that registers \n `handler` to be called back with the new value of the object when it\n changes.  \n\n```\nvar obj = function(value) {\n\tif(arguments.length >= 1) {\n\t\tobj.currentValue = value;\n\t\tobj.handlers.forEach(function(handler){\n\t\t\thandler.call(obj, value);\n\t\t});\n\t} else {\n\t\treturn obj.currentValue;\n\t}\n};\n\nobj[canSymbol.for(\"can.onValue\")] = function(handler){\n\tif(!obj.handlers) {\n\t\tobj.handlers = [];\n\t}\n\tobj.handlers.push(handler);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The handler must be called back with `this` as the instance of the observable. \n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "any object with a mutable value"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ],
          "context": {
            "types": [
              {
                "type": "*"
              }
            ]
          }
        }
      ],
      "name": "handler",
      "description": "The handler must be called back with `this` as the instance of the observable. \n"
    }
  },
  "can-symbol/symbols/onKeysRemoved": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-onKeysRemoved.md"
    },
    "body": "",
    "description": "Define a function used to listen to when the object's key set has keys removed through deletion. \n",
    "type": "typedef",
    "title": "can.onKeysRemoved",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/onKeysRemoved",
    "parent": "can-symbol/symbols/observe",
    "signatures": [
      {
        "code": "@@can.onKeysRemoved( handler(newValue) )",
        "description": "\n\nThe `@@can.onKeysRemoved` symbol points to a function that registers \n `handler` to be called back when the keys on the object\n change via properties deleted.\n\n```\nvar obj = {\n\thandlers: {},\n\tremoveKeyValue: function(key){\n\t\tvar result = delete this[key];\n\t\tvar keyStillExists = this[canSymbol.for(\"hasOwnKey\")](key);\n\t\tvar self = this;\n\t\tif(result && !keyStillExists) {\n\t\t\tobj.handlers.__keysRemoved.forEach(function(handler){\n\t\t\t\thandler.call(self, [key]);\n\t\t\t});\n\t\t}\n\t}\n};\n\nobj[canSymbol.for(\"can.onKeysRemoved\")] = function(handler){\n\tif(!obj.handlers.__keysRemoved) {\n\t\tobj.handlers.__keysRemoved = [];\n\t}\n\tobj.handlers.__keysRemoved.push(handler);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ],
                    "name": "newValue"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The handler must be called back with `this` as the instance of the observable, and passed the removed keys as an Array.\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "any Map-like object with named properties"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ],
              "name": "newValue"
            }
          ],
          "context": {
            "types": [
              {
                "type": "*"
              }
            ]
          }
        }
      ],
      "name": "handler",
      "description": "The handler must be called back with `this` as the instance of the observable, and passed the removed keys as an Array.\n"
    }
  },
  "can-symbol/symbols/setValue": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-setValue.md"
    },
    "body": "",
    "description": "Define a function that sets the object's value.   \n",
    "type": "typedef",
    "title": "can.setValue",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-symbol/symbols/setValue",
    "parent": "can-symbol/symbols/get-set",
    "signatures": [
      {
        "code": "@@can.setValue( value )",
        "description": "\n\nThe `@@can.setValue` symbol points to a function that sets the current value on the context object. \"Value\" may mean different\nthings in different contexts; e.g. setting a [can-compute]'s value updates the value stored internally to the compute, while setting an observable object's value will update all of the same-keyed properties of the object argument.\n\n```\nvar internalValue = undefined\nexport var foo = function(val) {\n\tif(val) {\n\t\tinternalValue = val;\n\t} else {\n\t\treturn internalValue;\n\t}\n};\n\n// Get the internal value as the representative value\nfoo[canSymbol.for('can.setValue')] = function(value) {\n\tinternalValue = value;\n}\n\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "any appropriate value to set on the object\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "anything that can be resolved to a value"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "any appropriate value to set on the object\n"
    }
  },
  "can-symbol/symbols/size": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-size.md"
    },
    "body": "",
    "description": "Return the number of items in the collection. \n",
    "type": "typedef",
    "title": "can.size",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "name": "can-symbol/symbols/size",
    "parent": "can-symbol/symbols/shape",
    "signatures": [
      {
        "code": "@@can.size()",
        "description": "\n\nThe `@@can.size` symbol points to a function that returns the number of\nitems in the collection.\n\n```js\nvar obj = {\n    [canSymbol.for('can.size')]: function(){\n        return Object.keys(this).length;\n    }\n};\n\nobj.foo = true;\nobj.bar = true;\nobj[canSymbol.for('can.size')]() //-> 2\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of items in the collection.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of items in the collection.\n"
    }
  },
  "can-symbol/symbols/proto": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-proto.md"
    },
    "body": "",
    "description": "Defines the \"proto\" (first element in the prototype chain) of an object \n\n",
    "type": "typedef",
    "title": "can.proto",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-symbol/symbols/proto",
    "parent": "can-symbol/symbols/shape",
    "signatures": [
      {
        "code": "@@can.proto",
        "description": "\n\nThe `@@can.proto` symbol is placed on an object to reference its prototype.  Since the non-standard `__proto__` is deprecated, this can serve as a prototype chain reference without invoking `Object.getPrototypeOf()` every time.\n\n```\nfunction Foo() {}\nFoo.prototype = {\n\tbar: \"baz\"\n};\n\nvar obj = new Foo();\nobj[canSymbol.for(\"can.proto\")] = Foo.prototype;\n\n```\n",
        "params": []
      }
    ]
  },
  "can-symbol/symbols/setKeyValue": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-setKeyValue.md"
    },
    "body": "",
    "description": "Defines a function that sets the value of one of an object's named properties. \n",
    "type": "typedef",
    "title": "can.setKeyValue",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "*"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-symbol/symbols/setKeyValue",
    "parent": "can-symbol/symbols/get-set",
    "signatures": [
      {
        "code": "@@can.setKeyValue( key, value )",
        "description": "\n\nThe `@@can.setKeyValue` symbol points to a Map-like object's property mutator function, which updates the value of the \nobject's property with the supplied key. This is only applicable to objects where keyed properties are relevant (like maps).\n\n```\nvar map = {\n\tset: function (key, value) {\n\t\tObservation.add(this, key);\n\t\tthis[key] = value;\n\t}\n}\n\nmap[canSymbol.for('can.setKeyValue')] = map.set;\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the key to set on the object"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "key",
            "description": "the property value to set on the object\n\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with named properties"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "key",
      "description": "the property value to set on the object\n\n"
    }
  },
  "can-symbol/symbols/updateDeep": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-updateDeep.md"
    },
    "body": "",
    "description": "Defines how to change the state of the current object to match the state of another object. \n",
    "type": "typedef",
    "title": "can.updateDeep",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-symbol/symbols/updateDeep",
    "parent": "can-symbol/symbols/shape",
    "signatures": [
      {
        "code": "@@can.updateDeep( source )",
        "description": "\n\nThe `can.updateDeep` symbol specifies how a deep update should happen. This means the copying of\nall of source's values, and child values onto the current object and removal of values from the current\nobject that are not in source and its children..  \n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "The source of values that will be copied.\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object with named properties"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "The source of values that will be copied.\n"
    }
  },
  "can-symbol/symbols/updateValues": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-updateValues.md"
    },
    "body": "",
    "description": "Add and remove multiple values at once. \n",
    "type": "typedef",
    "title": "can.updateValues",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-symbol/symbols/updateValues",
    "parent": "can-symbol/symbols/get-set",
    "signatures": [
      {
        "code": "@@can.updateValues( index, removing, adding )",
        "description": "\n\nThe `@@can.updateValues` symbol points to a function that can add\nand remove multiple items at once.  It's similar to splice, but\nis passed an array of items to remove instead of how many items to\nbe removed.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "removing",
            "description": "An array of the items to remove."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "adding",
            "description": "An Array of the items to add.\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "Anything object with this symbol."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "adding",
      "description": "An Array of the items to add.\n"
    }
  },
  "can-symbol/symbols/valueHasDependencies": {
    "src": {
      "path": "node_modules/can-symbol/docs/symbols-valueHasDependencies.md"
    },
    "body": "",
    "description": "Define a function that checks if there are any other observable objects that affect the value of the object. \n",
    "type": "typedef",
    "title": "can.valueHasDependencies",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-symbol/symbols/valueHasDependencies",
    "parent": "can-symbol/symbols/observe",
    "signatures": [
      {
        "code": "@@can.valueHasDependencies()",
        "description": "\n\nThe `@@can.valueHasDependencies` symbol points to a function that returns `true` if there are any other events or property\nchanges that will trigger an event for the value on the context object; \n`false` otherwise.  By convention, if an object implementation distinguishes between unbound objects or values, and those \nwhich are bound without external dependencies (as is the case with [can-compute]), `@@can.valueHasDependencies` may return \n`undefined` for unbound objects instead of `false`.\n\n```\nvar someOtherObj;\nvar internalValue;\nfunction computed(value) {\n\tif(arguments.length >= 1) {\n\t\tinternalValue = value;\n\t\tobj.__bindEvents.forEach(function(handler) {\n\t\t\thandler.call(this, value);\n\t\t});\n\t} else {\n\t\treturn internalValue;\n\t}\n}\nobj.__bindEvents = [{ \n\thandler: function() {},\n\treads: [{ object: someOtherObj }]\n}];\n\nobj[canSymbol.for(\"can.valueHasDependencies\")] = function() {\n\treturn this.__bindEvents && \n\t\tthis.__bindEvents.filter(function(binding) {\n\t\t\treturn binding.reads && binding.reads.length > 0;\n\t\t}).length > 0;\n};\n```\n",
        "params": [],
        "context": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "any value-like object"
        },
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "true if there are any other objects or properties that the object's value depends on\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "true if there are any other objects or properties that the object's value depends on\n"
    }
  },
  "can-stream-kefir.fns": {
    "name": "can-stream-kefir.fns",
    "title": "Methods",
    "type": "group",
    "parent": "can-stream-kefir",
    "description": "",
    "order": 2
  },
  "can-stream-kefir": {
    "src": {
      "path": "node_modules/can-stream-kefir/docs/can-stream-kefir.md"
    },
    "body": "\n## Usage\n\nThe [can-stream-kefir.toStream] method takes a compute and returns a [Kefir](https://rpominov.github.io/kefir/) stream instance.\n\n```\nvar canStream = require(\"can-stream-kefir\");\n\ncanStream.toStream(compute)                    //-> stream\n```\n\nFor example:\n\n__Converting a compute to a stream__\n\n```js\nvar canCompute = require(\"can-compute\");\nvar canStream = require(\"can-stream-kefir\");\n\nvar compute = canCompute(0);\nvar stream = canStream.toStream(compute);\n\nstream.onValue(function(newVal){\n\tconsole.log(newVal);\n});\n\ncompute(1);\n//-> console.logs 1\n```\n\n",
    "description": "Convert observable values into streams. [Kefir](https://rpominov.github.io/kefir/) is used to provide the stream functionality. \n",
    "type": "module",
    "title": "can-stream-kefir",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n  The `can-stream-kefir` module exports methods useful for converting observable values like [can-compute]s\n  or [can-define/map/map] properties into streams.\n\n  ```js\n  var canStream = require(\"can-stream-kefir\");\n  var DefineMap = require(\"can-define/map/map\");\n\n  var me = new DefineMap({name: \"Justin\"});\n\n  var nameStream = canStream.toStream(me,\".name\");\n\n\n  nameStream.onValue(function(name){\n\t  // name -> \"Obaid\";\n  });\n\n  me.name = \"Obaid\";\n  ```\n"
      }
    ],
    "name": "can-stream-kefir",
    "parent": "can-observables",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-stream-kefir/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.1.0",
        "can-event": "^3.5.0",
        "can-namespace": "^1.0.0",
        "can-observation": "^3.2.0",
        "can-stream": "^0.3.0",
        "can-util": "^3.9.0",
        "kefir": "^3.5.1"
      },
      "deprecated": false,
      "description": "Stream values into and out of computes",
      "devDependencies": {
        "can-define": "^1.2.3",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.3.0",
        "donejs-cli": "^1.0.1",
        "generator-donejs": "^1.0.5",
        "jshint": "^2.9.1",
        "steal": "^1.5.4",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.3.6",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-stream-kefir",
      "name": "can-stream-kefir",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-stream-kefir.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "0.3.2"
    },
    "comment": " "
  },
  "can-stream-kefir.toCompute": {
    "src": {
      "path": "node_modules/can-stream-kefir/docs/toCompute.md"
    },
    "body": "",
    "description": "Creates a [can-compute.computed] from a stream generator function. \n",
    "title": "toCompute",
    "name": "can-stream-kefir.toCompute",
    "type": "function",
    "parent": "can-stream-kefir.fns",
    "signatures": [
      {
        "code": "canStream.toCompute( makeStream(setStream), [context] )",
        "description": "\n\nThis returns a [can-compute.computed] that when [can-compute.computed.on bound]\ntakes on the value of the stream returned by `makeStream`.  `makeStream`\nis called with:\n\n - its `this` as the `context`, and\n - `setStream` which is a stream of values set on the returned compute (ex: `compute(5)`).\n\nThis is used to create computes from streams.  \n\n```js\nvar count = Kefir.sequentially(1000, [1, 2]);\n\nvar myCompute = canStream.toCompute(function(setStream){\n\treturn setStream.merge(count);\n});\n\n// listen to the compute for it to have a value\nmyCompute.on(\"change\", function(){})\n\nmyCompute(\"A\")\n\n// immediate value\nmyCompute() //-> \"A\"\n\n// 1000ms later\nmyCompute() //-> 1\n\n// 1000ms later\nmyCompute() //-> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "Stream"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Stream"
                      }
                    ],
                    "name": "setStream"
                  }
                ]
              }
            ],
            "name": "makeStream",
            "description": "A stream generator\nfunction.  This function takes the stream of set values, and typically other streams and manipulates them into the final returned output stream.  The output stream's values are used as the value of the returned [can-compute.computed].\n\nThe `setStream` is the stream of values set on the returned compute. In the following example, `setStream` will emit the values `1` and then `2`.\n\n```js\nvar returnedCompute = canStream.toCompute(function(setStream){\n return setStream;\n});\nreturnedCompute(1);\nreturnedCompute(2);\n```\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "An optional context which will be the `this` of `makeStream`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute that when read will return the value of the stream returned by `setStream`.  When the compute is written to, it will update `setStream`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "context",
      "description": "An optional context which will be the `this` of `makeStream`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute that when read will return the value of the stream returned by `setStream`.  When the compute is written to, it will update `setStream`.\n"
    }
  },
  "can-stream-kefir.toStream": {
    "src": {
      "path": "node_modules/can-stream-kefir/docs/tostream.md"
    },
    "body": "\n",
    "description": "Provides a shorthand for creating a stream from observable objects, properties and events.\n\n",
    "title": "toStream",
    "name": "can-stream-kefir.toStream",
    "type": "function",
    "parent": "can-stream-kefir.fns",
    "signatures": [
      {
        "code": "canStream.toStream( compute )",
        "description": "\n\n  Creates a stream from a [can-compute] compute. This stream gets updated whenever the compute value changes.\n\n  ```js\n  var compute = require('can-compute');\n  var canStream = require('can-stream-kefir');\n\n  var c1 = compute(0);\n\n  var resultCompute = canStream.toStream(c1);\n\n  resultCompute.onValue(function (val) {\n    console.log(val);\n  });\n\n  c1(1);\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "A compute whose value will be the stream values.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream.\n"
        }
      },
      {
        "code": "canStream.toStream( obs, \"eventName\" )",
        "description": "\n\n  Creates an event stream with the event objects dispatched on `obs` for `eventName`.\n  This is a shorthand for [can-stream-kefir.toStreamFromEvent].\n\n  ```js\n  var DefineList = require('can-define/list/list');\n  var canStream = require('can-stream-kefir');\n\n  var hobbies = new DefineList([\"js\",\"kayaking\"]);\n\n  var changeCount = canStream.toStream(hobbies, \"length\").scan(function(prev){\n\t  return prev + 1;\n  }, 0);\n  changeCount.onValue(function(event) {\n      console.log(event);\n  });\n\n  hobbies.push(\"bball\")\n  //-> console.logs {type: \"add\", args: [2,[\"bball\"]]}\n  hobbies.shift()\n  //-> console.logs {type: \"remove\", args: [0,[\"js\"]]}\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\nPromises can work too."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An observable event name.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream make up of the event objects dispatched on `obs`.\n\n"
        }
      },
      {
        "code": "canStream.toStream( obs, \".propName\" )",
        "description": "\n\n  Creates a stream from an observable property value. This is a shorthand for [can-stream-kefir.toStreamFromProperty].\n\n  ```js\n  var canStream = require('can-stream-kefir');\n  var DefineMap = require(\"can-define/map/map\");\n\n  var person = new DefineMap({\n      first: \"Justin\",\n\t  last: \"Meyer\"\n  });\n\n  var first = canStream.toStream(person, '.first'),\n      last = canStream.toStream(person, '.last');\n\n  var fullName = Kefir.combine(first, last, function(first, last){\n\t  return first + last;\n  });\n\n  fullName.onValue(function(newVal){\n      console.log(newVal);\n  });\n\n  map.first = \"Payal\"\n  //-> console.logs \"Payal Meyer\"\n  ```\n\n  Create a stream based on a event on an observable property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\n  Promises can work too."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name.  Multiple property names can be provided like `\".foo.bar.car\"`\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream of values at the specified `propName`.\n"
        }
      },
      {
        "code": "canStream.toStream( obs, \".propName eventName\" )",
        "description": "\n\n  Creates a stream from an observable property value. This is a shorthand for the second signature of [can-stream-kefir.toStreamFromEvent].\n\n  ```js\n  var canStream = require('can-stream-kefir');\n  var DefineMap = require(\"can-define/map/map\");\n  var DefineList = require(\"can-define/list/list\");\n\n  var me = new DefineMap({\n      todos: [\"mow lawn\"]\n  });\n\n  var addStream = canStream.toStream(me, \".todos add\");\n\n  addStream.onValue(function(event){\n      console.log(event);\n  });\n\n  map.todos.push(\"do dishes\");\n  //-> console.logs {type: \"add\", args: [1,[\"do dishes\"]]}\n  ```\n\n  Create a stream based on a event on an observable property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\n  Promises can work too.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name.  Multiple property names can be provided like `\".foo.bar.car\"`"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An observable event name."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream of the `eventName` event objects dispatched on the objects specified by `propName`.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A [Kefir](https://rpominov.github.io/kefir/) stream of the `eventName` event objects dispatched on the objects specified by `propName`.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "eventName",
      "description": "An observable event name."
    }
  },
  "can-stream.types": {
    "name": "can-stream.types",
    "title": "types",
    "type": "group",
    "parent": "can-stream",
    "description": "",
    "order": 0
  },
  "can-stream": {
    "src": {
      "path": "node_modules/can-stream/docs/can-stream.md"
    },
    "body": "\n## Use\n\nSee [can-stream-kefir] for an example.\n\n",
    "description": "Create useful stream methods from a minimal stream wrapper implementation. \n",
    "type": "module",
    "title": "can-stream",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-stream",
    "parent": "can-observables",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-stream/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.2.0",
        "can-define": "^1.2.0",
        "can-event": "^3.5.0",
        "can-observation": "^3.2.0",
        "can-types": "^1.1.0",
        "can-util": "^3.9.0",
        "kefir": "^3.5.1"
      },
      "deprecated": false,
      "description": "Stream values into and out of computes",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.2.4",
        "donejs-cli": "^1.0.2",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.6.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-stream",
      "name": "can-stream",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-stream.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "0.3.1"
    },
    "signatures": [
      {
        "code": "canStream(streamImplementation)",
        "description": "\n\nExports a function that takes a [can-stream.types.streamImplementation] (like [can-stream-kefir]) and uses it internally to provide several useful string methods.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stream.types.streamImplementation"
              }
            ],
            "name": "streamImplementation",
            "description": "A [can-stream.types.streamImplementation] object that implements the `toStream` and `toCompute` methods for a stream library.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stream.types.streamInterface"
            }
          ],
          "description": "An object that has the following methods:\n\n- .toStream(observable, propAndOrEvent[,event])\n- .toStreamFromProperty(property)\n- .toStreamFromEvent(property)\n- .toCompute([can-stream.types.makeStream makeStream(setStream)], context):compute\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stream.types.streamImplementation"
        }
      ],
      "name": "streamImplementation",
      "description": "A [can-stream.types.streamImplementation] object that implements the `toStream` and `toCompute` methods for a stream library.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stream.types.streamInterface"
        }
      ],
      "description": "An object that has the following methods:\n\n- .toStream(observable, propAndOrEvent[,event])\n- .toStreamFromProperty(property)\n- .toStreamFromEvent(property)\n- .toCompute([can-stream.types.makeStream makeStream(setStream)], context):compute\n"
    },
    "comment": " "
  },
  "can-stream/type/implementation.toCompute": {
    "src": {
      "path": "node_modules/can-stream/docs/implementation.toCompute.md"
    },
    "body": "",
    "description": "Creates a [can-compute.computed] from a stream generator function. \n",
    "title": "toCompute",
    "name": "can-stream/type/implementation.toCompute",
    "type": "function",
    "parent": "can-stream.types.streamImplementation",
    "signatures": [
      {
        "code": "toCompute( makeStream(setStream), [context] )",
        "description": "\n\nThis returns a [can-compute.computed] that when [can-compute.computed.on bound]\ntakes on the value of the stream returned by `makeStream`.  `makeStream`\nis called with:\n\n - its `this` as the `context`, and\n - `setStream` which is a stream of values set on the returned compute (ex: `compute(5)`).\n\nThis is used to create computes from streams.\n\n```js\nvar count = Kefir.sequentially(1000, [1, 2]);\n\nvar myCompute = canStream.toCompute(function(setStream){\n\treturn setStream.merge(count);\n});\n\n// listen to the compute for it to have a value\nmyCompute.on(\"change\", function(){})\n\nmyCompute(\"A\")\n\n// immediate value\nmyCompute() //-> \"A\"\n\n// 1000ms later\nmyCompute() //-> 1\n\n// 1000ms later\nmyCompute() //-> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "Stream"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Stream"
                      }
                    ],
                    "name": "setStream"
                  }
                ]
              }
            ],
            "name": "makeStream",
            "description": "A stream generator\nfunction.  This function takes the stream of set values, and typically other streams\nand manipulates them into the final returned output stream.  The output stream's\nvalues are used as the value of the returned [can-compute.computed].\n\nThe `setStream` is the stream of values set on the returned compute. In the following example, `setStream` will emit the values `1` and then `2`.\n\n```js\nvar returnedCompute = canStream.toCompute(function(setStream){\n return setStream;\n});\nreturnedCompute(1);\nreturnedCompute(2);\n```\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "An optional context which will be the `this` of `makeStream`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute that when read will return the value of\nthe stream returned by `setStream`.  When the compute is written to, it will\nupdate `setStream`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "context",
      "description": "An optional context which will be the `this` of `makeStream`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute that when read will return the value of\nthe stream returned by `setStream`.  When the compute is written to, it will\nupdate `setStream`.\n"
    }
  },
  "can-stream/type/implementation.toStream": {
    "src": {
      "path": "node_modules/can-stream/docs/implementation.toStream.md"
    },
    "body": "",
    "description": "Create a stream from an observable. \n",
    "title": "toStream",
    "name": "can-stream/type/implementation.toStream",
    "type": "function",
    "parent": "can-stream.types.streamImplementation",
    "signatures": [
      {
        "code": "toStream( compute )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Compute"
              }
            ],
            "name": "compute",
            "description": "An [can-compute] object\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Compute"
        }
      ],
      "name": "compute",
      "description": "An [can-compute] object\n"
    }
  },
  "can-stream/type/interface.toStream": {
    "src": {
      "path": "node_modules/can-stream/docs/interface.toStream.md"
    },
    "body": "",
    "description": "Provides a shorthand for creating a stream from observable objects, properties and events.\n\n",
    "title": "toStream",
    "name": "can-stream/type/interface.toStream",
    "type": "function",
    "parent": "can-stream.types.streamInterface",
    "signatures": [
      {
        "code": "canStream.toStream( observable, propAndOrEvent )",
        "description": "\n\n  Creates a stream from a [can-compute] compute or an observable. This stream gets updated whenever the observable value changes.\n\n  ```js\n  var compute = require('can-compute');\n  var canStreamKefir = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n\n  var c1 = compute(0);\n\n  var resultCompute = canStreaming.toStream(c1);\n\n  resultCompute.onValue(function (val) {\n    console.log(val);\n  });\n\n  c1(1);\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "A compute whose value will be the stream values.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A stream object.\n"
        }
      },
      {
        "code": "canStream.toStream( observable, \"eventName\" )",
        "description": "\n\n  Creates an event stream with the event objects dispatched on `obs` for `eventName`.\n  This is a shorthand for [can-stream.toStreamFromEvent].\n\n  ```js\n  var DefineList = require('can-define/list/list');\n  var canStream = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n\n  var hobbies = new DefineList([\"js\",\"kayaking\"]);\n\n  var changeCount = canStreaming.toStream(hobbies, \"length\").scan(function(prev){\n\t  return prev + 1;\n  }, 0);\n  changeCount.onValue(function(event) {\n      console.log(event);\n  });\n\n  hobbies.push(\"bball\")\n  //-> console.logs {type: \"add\", args: [2,[\"bball\"]]}\n  hobbies.shift()\n  //-> console.logs {type: \"remove\", args: [0,[\"js\"]]}\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "observable",
            "description": "An observable object like a [can-define/map/map].\nPromises can work too."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An observable event name.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A stream make up of the event objects dispatched on `obs`.\n\n"
        }
      },
      {
        "code": "canStream.toStream( observable, \".propName\" )",
        "description": "\n\n  Creates a stream from an observable property value. This is a shorthand for [can-stream.toStreamFromProperty].\n\n  ```js\n  var canStreamKefir = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n\n  var DefineMap = require(\"can-define/map/map\");\n\n  var person = new DefineMap({\n      first: \"Justin\",\n\t  last: \"Meyer\"\n  });\n\n  var first = canStreaming.toStream(person, '.first'),\n      last = canStreaming.toStream(person, '.last');\n\n  var fullName = Kefir.combine(first, last, function(first, last){\n\t  return first + last;\n  });\n\n  fullName.onValue(function(newVal){\n      console.log(newVal);\n  });\n\n  map.first = \"Payal\"\n  //-> console.logs \"Payal Meyer\"\n  ```\n\n  Create a stream based on a event on an observable property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\n  Promises can work too."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name.  Multiple property names can be provided like `\".foo.bar.car\"`\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A stream of values at the specified `propName`.\n"
        }
      },
      {
        "code": "canStream.toStream( obs, \".propName eventName\" )",
        "description": "\n\n  Creates a stream from an observable property value. This is a shorthand for the second signature of [can-stream.toStreamFromEvent].\n\n  ```js\n  var canStreamKefir = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n\n  var DefineMap = require(\"can-define/map/map\");\n  var DefineList = require(\"can-define/list/list\");\n\n  var me = new DefineMap({\n      todos: [\"mow lawn\"]\n  });\n\n  var addStream = canStreaming.toStream(me, \".todos add\");\n\n  addStream.onValue(function(event){\n      console.log(event);\n  });\n\n  map.todos.push(\"do dishes\");\n  //-> console.logs {type: \"add\", args: [1,[\"do dishes\"]]}\n  ```\n\n  Create a stream based on a event on an observable property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\n  Promises can work too.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name.  Multiple property names can be provided like `\".foo.bar.car\"`"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An observable event name."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A stream of the `eventName` event objects dispatched on the objects specified by `propName`.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A stream of the `eventName` event objects dispatched on the objects specified by `propName`.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "eventName",
      "description": "An observable event name."
    }
  },
  "can-stream/type/interface.toCompute": {
    "src": {
      "path": "node_modules/can-stream/docs/interface.toCompute.md"
    },
    "body": "",
    "description": "Create a [can-compute.computed] from a stream generator function. \n",
    "title": "toCompute",
    "name": "can-stream/type/interface.toCompute",
    "type": "function",
    "parent": "can-stream.types.streamInterface",
    "signatures": [
      {
        "code": "canStream.toCompute( makeStream(setStream), [context] )",
        "description": "\n\nThis returns a [can-compute.computed] that when [can-compute.computed.on bound]\ntakes on the value of the stream returned by `makeStream`.  `makeStream`\nis called with:\n\n - its `this` as the `context`, and\n - `setStream` which is a stream of values set on the returned compute (ex: `compute(5)`).\n\nThis is used to create computes from streams.\n\n```js\nvar count = Kefir.sequentially(1000, [1, 2]);\n\nvar myCompute = canStream.toCompute(function(setStream){\n\treturn setStream.merge(count);\n});\n\n// listen to the compute for it to have a value\nmyCompute.on(\"change\", function(){})\n\nmyCompute(\"A\")\n\n// immediate value\nmyCompute() //-> \"A\"\n\n// 1000ms later\nmyCompute() //-> 1\n\n// 1000ms later\nmyCompute() //-> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "Stream"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Stream"
                      }
                    ],
                    "name": "setStream"
                  }
                ]
              }
            ],
            "name": "makeStream",
            "description": "A stream generator\nfunction.  This function takes the stream of set values, and typically other streams\nand manipulates them into the final returned output stream.  The output stream's\nvalues are used as the value of the returned [can-compute.computed].\n\nThe `setStream` is the stream of values set on the returned compute. In the following example, `setStream` will emit the values `1` and then `2`.\n\n```js\nvar returnedCompute = canStream.toCompute(function(setStream){\n return setStream;\n});\nreturnedCompute(1);\nreturnedCompute(2);\n```\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "An optional context which will be the `this` of `makeStream`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute that when read will return the value of\nthe stream returned by `setStream`.  When the compute is written to, it will\nupdate `setStream`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "context",
      "description": "An optional context which will be the `this` of `makeStream`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute that when read will return the value of\nthe stream returned by `setStream`.  When the compute is written to, it will\nupdate `setStream`.\n"
    }
  },
  "can-stream/type/interface.toStreamFromEvent": {
    "src": {
      "path": "node_modules/can-stream/docs/interface.toStreamFromEvent.md"
    },
    "body": "",
    "description": "Creates a stream on a {Observable} object that gets updated whenever the event occurs on the observable object. \n",
    "title": "toStreamFromEvent",
    "name": "can-stream/type/interface.toStreamFromEvent",
    "type": "function",
    "parent": "can-stream.types.streamInterface",
    "signatures": [
      {
        "code": "canStream.toStreamFromEvent( obs, eventName )",
        "description": "\n\n  Creates a stream based on event on observable\n\n  ```js\n  var canStreamKefir = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n\n  var compute = require('can-compute');\n  var DefineMap = require('can-define/map/map');\n  var DefineList = require('can-define/list/list');\n\n  var MyMap = DefineMap.extend({\n      tasks: {\n          Type: DefineList.List,\n          value: []\n      }\n  });\n  var map = new MyMap();\n\n  var stream = canStreaming.toStreamFromEvent(map, 'tasks');\n\n  stream.onValue(function(ev){\n      console.log('map.tasks has been updated');\n  });\n\n  map.fooList.push('New task');\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "An",
            "description": "observable object"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A stream.\n\n"
        }
      },
      {
        "code": "canStream.toStreamFromEvent( obs, propName, eventName )",
        "description": "\n\n  Creates a stream based on event trigger on observable property\n\n  ```js\n  var canStreamKefir = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n  var compute = require('can-compute');\n  var DefineMap = require('can-define/map/map');\n  var DefineList = require('can-define/list/list');\n\n  var MyMap = DefineMap.extend({\n      tasks: {\n          Type: DefineList.List,\n          value: []\n      }\n  });\n  var map = new MyMap();\n\n  var stream = canStreaming.toStreamFromEvent(map, 'tasks', 'length');\n\n  stream.onValue(function(ev){\n      console.log('map.tasks has been updated');\n  });\n\n  map.fooList.push('New task');\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "An",
            "description": "observable object"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "observable",
            "description": "property name"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "observable",
            "description": "event name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A stream.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A stream.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "observable",
      "description": "event name\n"
    }
  },
  "can-stream/type/interface.toStreamFromProperty": {
    "src": {
      "path": "node_modules/can-stream/docs/interface.toStreamFromProperty.md"
    },
    "body": "",
    "description": "Creates a stream on a {Observable} object that gets updated whenever the property value on the observable changes. \n",
    "title": "toStreamFromProperty",
    "name": "can-stream/type/interface.toStreamFromProperty",
    "type": "function",
    "parent": "can-stream.types.streamInterface",
    "signatures": [
      {
        "code": "canStream.toStreamFromProperty( obs, propName )",
        "description": "\n\n  Creates a stream based on property value change on observable\n\n  ```js\n  var map = {\n      foo: \"bar\"\n  };\n  var stream = canStreaming.toStreamFromProperty(map, 'foo');\n\n  stream.onValue(function(value){\n    console.log(value); // -> foobar\n  });\n\n  map.foo = \"foobar\";\n  ```",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "An",
            "description": "observable object"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "property",
      "description": "name\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A stream.\n"
    }
  },
  "can-stream.types.makeStream": {
    "src": {
      "path": "node_modules/can-stream/docs/types.makeStream.md"
    },
    "body": "",
    "description": "This function takes a stream whose values are bound to the returned [can-compute.computed]. \n",
    "type": "typedef",
    "title": "makeStream",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-stream.types.makeStream",
    "parent": "can-stream.types",
    "signatures": [
      {
        "code": "makeStream(setStream)",
        "description": "\n\n```js\nvar Kefir = require('kefir');\nvar count = Kefir.sequentially(1000, [1, 2]);\n\nvar myCompute = canStream.toCompute(function(setStream) {\n\treturn setStream.merge(count);\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Stream"
              }
            ],
            "name": "setStream",
            "description": "A stream to bind to the returned [can-compute.computed].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "name": "setStream",
      "description": "A stream to bind to the returned [can-compute.computed].\n"
    }
  },
  "can-validate.methods": {
    "name": "can-validate.methods",
    "title": "Methods",
    "type": "group",
    "parent": "can-validate",
    "description": "",
    "order": 1
  },
  "can-validate.types": {
    "name": "can-validate.types",
    "title": "Types",
    "type": "group",
    "parent": "can-validate",
    "description": "",
    "order": 2
  },
  "can-validate": {
    "src": {
      "path": "node_modules/can-validate/docs/can-validate.md"
    },
    "body": "\n\n## Usage\n\nThe [can-validate.formatErrors] method can be used to convert errors into something more useful.\n\n```javascript\nvar formatErrors = require('can-validate').formatErrors;\nvar errors = [\n    'is required',\n    {\n        message: 'must be a number',\n        related: 'age'\n    }\n];\n\nformatErrors(errors, 'object');\n//=> [{'*': ['is required']}, {'age': ['must be a number']}]\n\nformatErrors(errors, 'flat');\n//=> ['is required', 'must be a number']\n\nformatErrors(errors, 'errors');\n//=> [{message: 'is required', related: '*'}, {'age': ['must be a number']}]\n```\n\n## Types\n\nCore definitions of types used in validation.\n\n- [can-validate.error] A flexible typedef that describes a validation error.\n- [can-validate.errors] Different error types understood by `can-validate`.\n- [can-validate.validator] A function that validates a given value against registered constraints.\n\n",
    "description": "\nShared utilities and type definitions to process validation errors.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nThe `can-validate` module exports helpful methods used for validation and also describes\nthe different types used during validation.\n\n```javascript\nvar validate = require('my-validator');\nvar utils = require('can-validate');\n\n// Normalize errors into a flat structure\nvar errors = utils.formatErrors(validate(obj, constraints), 'flat');\n```\n"
      }
    ],
    "name": "can-validate",
    "parent": "can-data-validation",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "browser": {},
      "bugs": {
        "url": "https://github.com/canjs/can-validate/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-util": "^3.9.0"
      },
      "deprecated": false,
      "description": "Validation plugin for CanJS.",
      "devDependencies": {
        "bit-docs": "0.0.8-2",
        "detect-cyclic-packages": "^1.1.0",
        "http-server": "^0.10.0",
        "jshint": "^2.9.4",
        "steal": "^1.0.8",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.5.0"
      },
      "homepage": "https://github.com/canjs/can-validate",
      "keywords": [
        "Validate",
        "plugin",
        "canjs"
      ],
      "license": "MIT",
      "main": "can-validate.js",
      "name": "can-validate",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-validate.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "http-server -c-1",
        "jshint": "jshint .",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:pre": "npm version prerelease && npm run build && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "ignoreBrowser": true,
        "npmIgnore": [
          "documentjs",
          "testee",
          "steal-tools"
        ],
        "npmAlgorithm": "flat",
        "npmDependencies": [
          "steal-qunit"
        ],
        "transpiler": "babel"
      },
      "version": "1.1.0"
    },
    "comment": " "
  },
  "can-stream.types.streamInterface": {
    "src": {
      "path": "node_modules/can-stream/docs/types.streamInterface.md"
    },
    "body": "",
    "description": "Stream interface function returned from [can-stream] \n",
    "type": "typedef",
    "title": "streamInterface",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-stream.types.streamInterface",
    "parent": "can-stream.types",
    "signatures": [
      {
        "code": "streamInterface( observable, propAndOrEvent[,event] )",
        "description": "\n\nThe stream interface function returned from [can-stream] that has the following property methods:\n\n- .toStream(observable, propAndOrEvent[,event])\n- .toStreamFromProperty(property)\n- .toStreamFromEvent(property)\n- .toCompute([can-stream.types.makeStream makeStream(setStream)], context):compute\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "observable",
            "description": "An observable object\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "A property of the observable object prepended with `.`\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "event",
            "description": "An optional event name of the observable object\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "event",
      "description": "An optional event name of the observable object\n\n"
    }
  },
  "can-stream.types.streamImplementation": {
    "src": {
      "path": "node_modules/can-stream/docs/types.streamImplementation.md"
    },
    "body": "\n## Use\n\nSee [can-stream-kefir] for example implementation.\n\n",
    "description": "Export an object with a minimal implementation of `toStream` and `toCompute` methods specific to a streaming library like [Kefir](https://rpominov.github.io/kefir/) \n",
    "type": "typedef",
    "title": "StreamImplementation",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "toStream",
            "description": "\n",
            "types": [
              {
                "type": "can-stream/type/implementation.toStream"
              }
            ]
          },
          {
            "name": "toCompute",
            "description": "\n",
            "types": [
              {
                "type": "can-stream/type/implementation.toCompute"
              }
            ]
          }
        ],
        "description": "\n  An object with `toStream` and `toCompute` methods.\n\n```js\nvar streamImplementation = {\n\ttoStream: function(compute){\n\t\treturn MAKE_THE_STREAM_FROM_A_COMPUTE(compute);\n\t},\n\ttoCompute: function(makeStream, context){\n\t\tvar setStream = MAKE_A_SETTABLE_STREAM_THAT_IS_SET_WHEN_COMPUTE_IS_SET();\n\t\tvar stream = makeStream.call(context, setStream);\n\n\t\tvar compute = MAKE_COMPUTE_TO_HAVE_VALUE_FROM_stream_AND_SET_TO_setStream;\n\n\t\treturn compute;\n\t}\n};\n\nvar canStream = require(\"can-stream\");\n\nvar streamInterface = canStream(streamImplementation);\n\nvar map = new DefineMap({name: \"John\"});\nstreamInterface(map, \".name\") //-> an instance of the stream library.\n\nmodule.exports = streamInterface;\n```\n"
      }
    ],
    "name": "can-stream.types.streamImplementation",
    "parent": "can-stream.types",
    "comment": " "
  },
  "can-validate.errors": {
    "src": {
      "path": "node_modules/can-validate/docs/errors.md"
    },
    "body": "\n",
    "description": "\nThe expected response from a validator if a value fails validation.\n",
    "type": "typedef",
    "title": "Errors",
    "types": [
      {
        "type": "undefined",
        "description": "Expected when value passes validation.\n"
      },
      {
        "type": "null",
        "description": "Will be treated similarly as `undefined`; value passed validation.\n"
      },
      {
        "type": "string",
        "description": "A message explaining the validation failure.\n\n```javascript\n\"is required\"\n```\n"
      },
      {
        "type": "ERROR",
        "description": "An object used to describe an error message. See [can-validate.error].\n\n```json\n{\n    \"message\": \"is required\",\n    \"related\": [\"billingZip\", \"residenceZip\"]\n}\n```\n"
      },
      {
        "type": "array",
        "description": "Items can be any of the valid [can-validate.errors].\n\n```json\n[\n    \"is required\",\n    {\n        \"message\": \"is required\",\n        \"related\": [\"billingZip\", \"residenceZip\"]\n    }\n]\n```\n"
      }
    ],
    "name": "can-validate.errors",
    "parent": "can-validate.types"
  },
  "can-validate.formatErrors": {
    "src": {
      "path": "node_modules/can-validate/docs/format-errors.md"
    },
    "body": "\n## Usage\n\nThe `errors` value should match the possible [can-validate.errors] type.\n\nGiven the following...\n\n```js\n// validate this object\nvar person = {};\n// against these constraints\nvar constraints = {\n\tage: {\n\t\trequired: true,\n\t\tnumber: true\n\t}\n};\n// will return some errors\nvar errors = someValidator(person, constraints);//> [\"is required\", \"must be a number\"]\n```\n\nWe can expect the following responses\n\n### Object Example\n\nIf no key exists in the error response, an array like object will be created.\n\n```json\n{\n\t\"0\": [\"is required\", \"must be a number\"]\n}\n```\n\n### Flat Example\n\n```json\n[\n\t\"is required\",\n\t\"must be a number\"\n]\n```\n\n\n\n### Errors Example\n\nIf a key name exists in the error response, then we can expect to see the key name\nin `related`.\n\n```json\n[\n\t{ \"message\": \"is required\", \"related\": []},\n\t{ \"message\": \"must be a number\", \"related\": []}\n]\n```\n\n### Handling errors without `related`\n\nGiven the following errors object\n\n```json\n[\n\t\"is required\",\n\t{\"message\": \"must be a number\"},\n\t{\"message\": \"must be a number\", \"related\": [\"zipCode\"]}\n]\n```\n\nBecause only one item in the array has a `related` property, the other two items\nwill be grouped together by assigning them the wildcard (`*`) key. Once processed,\nthe errors will look like\n\n```json\n[\n\t{\"message\": \"is required\", \"related\": [\"*\"]},\n\t{\"message\": \"must be a number\", \"related\": [\"*\"]},\n\t{\"message\": \"must be a number\", \"related\": [\"zipCode\"]}\n]\n```\n\n",
    "description": "\n",
    "title": "formatErrors",
    "name": "can-validate.formatErrors",
    "type": "function",
    "parent": "can-validate.methods",
    "signatures": [
      {
        "code": "formatErrors(errors, format)",
        "description": "\n  Processes `errors` (only items that match the [can-validate.errors] type) and\n  converts items to a structure defined by `format`.\n\n  ```js\n  formatErrors(['is required', {message: 'is invalid'}], 'errors');\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-validate.errors"
              }
            ],
            "name": "errors",
            "description": "A value that matches the [can-validate.errors] type."
          },
          {
            "types": [
              {
                "type": "string"
              }
            ],
            "optional": true,
            "name": "format",
            "description": "Should be equal to `object`, `flat`, or `errors`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The errors either flattened into a single array, grouped in\nby key in an object, or a single array of [can-validate.error] items. If no\n`format` is passed, errors will be returned in the raw parsed format.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "string"
        }
      ],
      "optional": true,
      "name": "format",
      "description": "Should be equal to `object`, `flat`, or `errors`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The errors either flattened into a single array, grouped in\nby key in an object, or a single array of [can-validate.error] items. If no\n`format` is passed, errors will be returned in the raw parsed format.\n"
    },
    "comment": " "
  },
  "can-validate.validator": {
    "src": {
      "path": "node_modules/can-validate/docs/validator.md"
    },
    "body": "\n\n## Creating a validator\n\nGiven that a `required` validation exists\n```js\n// Custom required check\nvar checkRequired = function (val) {\n    if (typeof value === 'undefined' || value === '') {\n        return false;\n    }\n    return true;\n};\n```\n\nTypically a validator can be created like so\n\n```js\n// Validator factory\nvar makeValidator = function (constraints) {\n\treturn function (value) {\n\t\tif (constraints.required && !checkRequired(value)) {\n\t\t\treturn 'is required';\n\t\t}\n\t}\n};\n```\n\nNow, creating a validator for any value is possible by doing\n\n```js\nvar nameValidator = makeValidator({required: true});\n```\n\nWhich then allows validating values as needed\n\n```js\nnameValidator('Juan'); //> undefined\nnameValidator(); //> 'is required'\n```\n\n## Validator Response\n\nThe response should match the [can-validate.errors] type. The most flexible response\nis the [can-validate.error] type which describes the error message any value keys that\ntriggered the error state.\n\n",
    "description": "\nA function that validates a value against predefined constraints and returns validation errors, if any are found.\n",
    "type": "typedef",
    "title": "validator",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-validate.validator",
    "parent": "can-validate.types",
    "signatures": [
      {
        "code": "validator(value)",
        "description": "\n\n  ```js\n  function (value) {\n  \tif (typeof value === 'undefined' || value === '')) {\n  \t\treturn 'is required';\n  \t}\n  }\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "A simple value to validate\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Error"
            },
            {
              "type": "String"
            },
            {
              "type": "undefined"
            },
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Error"
                    },
                    {
                      "type": "String"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns undefined if no errors found. Otherwise, will return an error type with the error message.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "A simple value to validate\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Error"
        },
        {
          "type": "String"
        },
        {
          "type": "undefined"
        },
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Error"
                },
                {
                  "type": "String"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns undefined if no errors found. Otherwise, will return an error type with the error message.\n"
    },
    "comment": " "
  },
  "can-validate.error": {
    "src": {
      "path": "node_modules/can-validate/docs/error-object.md"
    },
    "body": "\n\n\n## Wild card\n\nIt is common to group errors by the property that triggered the error state. In\nsome cases, it possible to group errors where one error is not identified with\na property.\n\n```javascript\nvar errors = [\n    { message: 'is required'},\n    {\n        message: 'must be a number',\n        related: 'age'\n    }\n];\n```\n\nIn this situation, the first object in the array is not identified with a property.\nThis item will have a `related` assumed to be `*`. It possible for this error item\nto be grouped with other \"orphaned\" errors.\n\n```javascript\nvar errors = [\n    {\n        message: 'is required',\n        related: '*'\n    }, {\n        message: 'must be a number',\n        related: 'age'\n    }\n];\n```\n\n",
    "description": "\nAn object that defines a validation failure.\n",
    "type": "typedef",
    "title": "Error",
    "types": [
      {
        "type": "object",
        "options": [
          {
            "name": "message",
            "description": "A reason why value is in an invalid state.\n\n```javascript\nvar error = { \"message\": \"is required\"};\n```\n",
            "types": [
              {
                "type": "string"
              }
            ]
          },
          {
            "name": "related",
            "description": "Key names that are related to triggering the\ninvalid state of the current value.\n\n```json\n{ \"message\": \"is required\", \"related\": \"age\"}\n```\n\n```json\n{ \"message\": \"is required\", \"related\": [\"billingZip\", \"residenceZip\"]}\n```\n\nIf no value is passed, the wild card value (`*`) is used internally for grouping.\n",
            "types": [
              {
                "type": "string"
              },
              {
                "type": "array"
              }
            ],
            "optional": true,
            "defaultValue": "*"
          }
        ]
      }
    ],
    "name": "can-validate.error",
    "parent": "can-validate.types",
    "comment": " "
  },
  "can-util/dom": {
    "name": "can-util/dom",
    "title": "can-util/dom",
    "type": "group",
    "parent": "can-util",
    "description": "",
    "order": 0
  },
  "can-util/js": {
    "name": "can-util/js",
    "title": "can-util/js",
    "type": "group",
    "parent": "can-util",
    "description": "",
    "order": 0
  },
  "can-util": {
    "src": {
      "path": "node_modules/can-util/doc/can-util.md"
    },
    "body": "\n\n## can-util/js\n\n- [can-util/js/assign/assign] - A simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.\n- [can-util/js/base-url/base-url] - Get and/or set the \"base\" (containing path) of the document.\n- [can-util/js/cid/cid] - Deprecated. Use [can-cid] instead.\n- [can-util/js/deep-assign/deep-assign] - Assign properties from a source object to a target object, deeply copying properties that are objects or arrays.\n- [can-util/js/defaults/defaults] - Mimics [_.defaults](https://lodash.com/docs/4.16.2#defaults). Assigns first level properties in sources from left to right if they are not already defined.\n- [can-util/js/deparam/deparam] - Takes a string of name value pairs and returns a Object literal that represents those params.\n- [can-util/js/dev/dev] - Utilities for logging development-mode messages. Use this module for anything that should be shown to the user during development but isn't needed in production. In production these functions become noops.\n- [can-util/js/diff/diff] - Returns the difference between two ArrayLike objects (that have nonnegative integer keys and the `length` property) as an array of patch objects.\n- [can-util/js/diff-object/diff-object] - Find the differences between two objects, based on properties and values.\n- [can-util/js/each/each] - Loop over each element in an Array-Like data structure.\n- [can-util/js/get/get] - Returns the value at the specified property path of an object.\n- [can-util/js/global/global] - Returns the global that an environment provides.      \n- [can-util/js/import/import] - Imports a module.\n- [can-util/js/is-array-like/is-array-like] - Determines if an object is \"array like\", meaning it can be looped over. Any object with a `.length` property is array like.\n- [can-util/js/is-browser-window/is-browser-window] - Returns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).\n- [can-util/js/is-empty-object/is-empty-object] - Used to determine if an object is an empty object (an object with no enumerable properties) such as `{}`.\n- [can-util/js/is-function/is-function] - Used to determine if a value is a function.\n- [can-util/js/is-node/is-node] - Determines if your code is running in [Node.js](https://nodejs.org).\n- [can-util/js/is-plain-object/is-plain-object] - Attempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`.\n- [can-util/js/is-promise/is-promise] - Determines if object is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n- [can-util/js/is-promise-like/is-promise-like] - Determines if an object is \"Then-able\".\n- [can-util/js/is-string/is-string] - Determines if the provided argument is a string.\n- [can-util/js/is-web-worker/is-web-worker] - Determines if the code is running with a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers).\n- [can-util/js/join-uris/join-uris] - Provides a convenient way to join together URIs handling relative paths.\n- [can-util/js/log/log] - Utilities for logging to the console.\n- [can-util/js/make-array/make-array] - Takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array.\n- [can-util/js/make-promise/make-promise] - Will make isPromiseLike object into [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n- [can-util/js/omit/omit] - Omit properties from an object.\n- [can-util/js/param/param] - Takes an Object of name value pairs and returns a String with the parameters encoded.\n- [can-util/js/set-immediate/set-immediate] - Polyfill for setImmediate() if it doesn't exist in the global context.\n- [can-util/js/string/string] - String utilities used by CanJS libraries.\n- [can-util/js/string-to-any/string-to-any] - Turns a string representation of a primitive type back into the associated primitive.\n- [can-util/js/types/types] - Deprecated. Use [can-types] instead.\n\n## can-util/dom\n\n- [can-util/dom/ajax/ajax] - Used to make an asynchronous HTTP (AJAX) request\nsimilar to [http://api.jquery.com/jQuery.ajax/jQuery.ajax].\n- [can-util/dom/attr/attr] - A module that makes it easy to access attributes and properties of elements.\n- [can-util/dom/child-nodes/child-nodes] - Get all of the childNodes of a given node.\n- [can-util/dom/class-name/class-name] - Allows querying and manipulation of classes on HTML elements.\n- [can-util/dom/data/data] - Allows associating data as a key/value pair for a particular DOM node.\n- [can-util/dom/dispatch/dispatch] - Dispatch an event on an element.\n- [can-util/dom/document/document] - Optionally sets, and returns, the document object for the context.\n- [can-util/dom/events/events] - Allows you to listen to a domEvent and special domEvents as well as dispatch domEvents.\n- [can-util/dom/frag/frag] - Convert a String, HTMLElement, documentFragment, or contentArray into a documentFragment.\n- [can-util/dom/mutate/mutate] - Mutate an element by appending, inserting, and removing DOM nodes. Use this so that on the server \"inserted\" will be fired.\n\n",
    "description": "\nCommon JavaScript utilities for the rest of CanJS.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-util",
    "parent": "can-js-utilities",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-util/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-ajax": "^1.0.0",
        "can-assign": "^1.0.0",
        "can-cid": "^1.1.0",
        "can-deparam": "^1.0.0",
        "can-dom-data-state": "^0.1.0",
        "can-event-dom-enter": "^1.0.0",
        "can-event-dom-radiochange": "^1.0.2",
        "can-globals": "^0.2.2",
        "can-log": "^0.1.0",
        "can-namespace": "1.0.0",
        "can-param": "^1.0.0",
        "can-parse-uri": "^1.0.0",
        "can-reflect": "^1.2.0",
        "can-symbol": "^1.0.0",
        "can-types": "^1.1.0"
      },
      "deprecated": false,
      "description": "Common utilities for CanJS projects",
      "devDependencies": {
        "async": "^2.2.0",
        "can-vdom": "^3.2.3",
        "detect-cyclic-packages": "^1.1.0",
        "http-server": "^0.10.0",
        "jshint": "^2.9.1",
        "qunitjs": "^2.4.0",
        "saucelabs": "^1.4.0",
        "steal": "^1.5.5",
        "steal-css": "^1.2.5",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.4.1",
        "test-saucelabs": "0.0.2",
        "testee": "^0.7.0",
        "wd": "^1.1.3",
        "xmlhttprequest2": "^1.0.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "license": "MIT",
      "main": "can-util",
      "name": "can-util",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-util.git"
      },
      "scripts": {
        "build": "node build.js",
        "ci": "npm run build && npm run test && node test/test-sauce-labs.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "http-server": "http-server -p 3000 --silent",
        "jshint": "jshint dom/. js/. *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run test:server && npm run testee",
        "test:server": "TEST=qunit qunit test/node.js",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.10.12"
    },
    "comment": " "
  },
  "can-test-helpers": {
    "src": {
      "path": "node_modules/can-test-helpers/doc/can-test.md"
    },
    "body": "\n\nThe `can-test-helpers` library contains useful utilities for running the CanJS unit test batteries.  This library and its associated files should only ever be included in your module's `devDependencies` in `package.json`, not in the runtime `dependencies`.\n",
    "description": "\nCommon utilities for effectively testing the features of CanJS.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-test-helpers",
    "parent": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-test-helpers/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-log": "^0.1.0",
        "can-util": "^3.10.12"
      },
      "deprecated": false,
      "description": "Test utilities for CanJS modules",
      "devDependencies": {
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.5",
        "steal": "^1.5.13",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.8.4",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-test-helpers#readme",
      "keywords": [
        "canjs",
        "donejs",
        "qunit"
      ],
      "license": "MIT",
      "main": "can-test-helpers.js",
      "name": "can-test-helpers",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-test-helpers.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push origin master",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "1.1.0"
    },
    "comment": " "
  },
  "can-test-helpers/dev": {
    "name": "can-test-helpers/dev",
    "type": "module",
    "parent": "can-test-helpers",
    "src": {
      "line": 0,
      "codeLine": 8,
      "path": "node_modules/can-test-helpers/lib/dev.js"
    },
    "body": "\n",
    "description": "\nThe `dev` utilities group contains functions to assist with testing with the [can-util/js/dev/dev can-util dev] module.\ncan-util's dev provides facilities for development that are switched off in production builds.\n",
    "title": "dev",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-test-helpers/lib/dev.willWarn": {
    "name": "can-test-helpers/lib/dev.willWarn",
    "type": "function",
    "parent": "can-test-helpers/dev",
    "src": {
      "line": 70,
      "codeLine": 106,
      "path": "node_modules/can-test-helpers/lib/dev.js"
    },
    "body": "\n`willWarn()` takes either a String or a RegExp as its `expected` warning, and does a full, case-sensitive String \nmatch in the case of a String, or a regex test in the case of a RegExp, for every warning logged through\n[can-util/js/dev/dev.warn].  In addition, if `fn` is provided, it is fired on _every_ warning with the content\nof the warning message and whether it matched `expected`.\n\n`willWarn()` returns a teardown function, which must be called at least once to disable the tracking of the matched\nwarning.  when called, the teardown function returns the number of times `expected` was matched by a dev warning.\n\n```\nvar dev = require('can-util/js/dev/dev');\nvar devHelpers = require('can-test-helpers/lib/dev');\n\nvar finishWarningCheck = devHelpers.willWarn(\"something evil\", function(message, match) {\n\t message; // -> \"something evil\"\n\t match; // true\n});\n\ncanDev.warn(\"something evil\");\n\nfinishWarningCheck(); // -> 1\n\n```\n \n",
    "description": "Requests that [can-util/js/dev/dev.warn canDev.warn] track and notify about matching warnings. \n",
    "title": "willWarn",
    "signatures": [
      {
        "code": "dev.willWarn(expected, [fn])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Regexp"
              }
            ],
            "name": "expected",
            "description": "The warning message to check for"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Boolean"
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "fn",
            "description": "an optional callback to fire on every warning; each call has the actual warning\n message and a Boolean indicating whether it was matched"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function that tears down the warning check and returns the number of matched warnings when called.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Boolean"
                }
              ]
            }
          ]
        }
      ],
      "optional": true,
      "name": "fn",
      "description": "an optional callback to fire on every warning; each call has the actual warning\n message and a Boolean indicating whether it was matched"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function that tears down the warning check and returns the number of matched warnings when called.\n"
    },
    "comment": " "
  },
  "can-test-helpers/lib/dev.willError": {
    "name": "can-test-helpers/lib/dev.willError",
    "type": "function",
    "parent": "can-test-helpers/dev",
    "src": {
      "line": 108,
      "codeLine": 144,
      "path": "node_modules/can-test-helpers/lib/dev.js"
    },
    "body": "\n`willError()` takes either a String or a RegExp as its `expected` error, and does a full, case-sensitive String \nmatch in the case of a String, or a regex test in the case of a RegExp, for every error logged through\n[can-util/js/dev/dev.error].  In addition, if `fn` is provided, it is fired on _every_ error logged by dev.error\nwith the content of the error message and whether it matched `expected`.\n\n`willError()` returns a teardown function, which must be called at least once to disable the tracking of the matched\nerror.  when called, the teardown function returns the number of times `expected` was matched by a dev error.\n\n```\nvar dev = require('can-util/js/dev/dev');\nvar devHelpers = require('can-test-helpers/lib/dev');\n\nvar finishErrorCheck = devHelpers.willError(\"something evil\", function(message, match) {\n\t message; // -> \"something evil\"\n\t match; // true\n});\n\ncanDev.error(\"something evil\");\n\nfinishErrorCheck(); // -> 1\n\n```\n \n",
    "description": "Requests that [can-util/js/dev/dev.error canDev.error] track and notify about matching errors. \n",
    "title": "willError",
    "signatures": [
      {
        "code": "dev.willError(expected, [fn])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Regexp"
              }
            ],
            "name": "expected",
            "description": "The error message to check for"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Boolean"
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "fn",
            "description": "an optional callback to fire on every error; each call has the actual error\n message and a Boolean indicating whether it was matched"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function that tears down the error check and returns the number of matched errors when called.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Boolean"
                }
              ]
            }
          ]
        }
      ],
      "optional": true,
      "name": "fn",
      "description": "an optional callback to fire on every error; each call has the actual error\n message and a Boolean indicating whether it was matched"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function that tears down the error check and returns the number of matched errors when called.\n"
    },
    "comment": " "
  },
  "can-test-helpers/lib/dev.devOnlyTest": {
    "type": "function",
    "name": "can-test-helpers/lib/dev.devOnlyTest",
    "parent": "can-test-helpers/dev",
    "src": {
      "line": 146,
      "codeLine": 171,
      "path": "node_modules/can-test-helpers/lib/dev.js"
    },
    "body": "\n```\ndev.devOnlyTest(\"it works\", function() {\n   QUnit.ok(true, \"it works!\");\n});\n```\n \n",
    "description": "Defines a test that runs only in development mode. \n",
    "title": "devOnlyTest",
    "signatures": [
      {
        "code": "dev.devOnlyTest(...)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "waits",
            "description": "an optional number of async waits"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "the String identifier for the test in the test module"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "the function body of the test.\n\n\nThe parameter list above assumes that `test` on the global object is a QUnit test function. With `devOnlyTest`,\nthe global test function will be run with the supplied parameters when the system environment is either\nunknown or not one of the production tests.  This is to help facilitate tests that rely on, e.g., canDev\nbehavior that only exists in development builds.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "the function body of the test.\n\n\nThe parameter list above assumes that `test` on the global object is a QUnit test function. With `devOnlyTest`,\nthe global test function will be run with the supplied parameters when the system environment is either\nunknown or not one of the production tests.  This is to help facilitate tests that rely on, e.g., canDev\nbehavior that only exists in development builds.\n"
    },
    "comment": " "
  },
  "can-vdom.types.window": {
    "src": {
      "path": "node_modules/can-vdom/docs/window.md"
    },
    "body": "\n",
    "description": "\nAn object representing a fake `window` object.\n",
    "type": "typedef",
    "title": "window",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "document",
            "description": "A browser document\n",
            "types": [
              {
                "type": "can-simple-dom/document/document"
              }
            ]
          },
          {
            "name": "window",
            "description": "The window itself.\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "self",
            "description": "The `self` object is an alias for `window`.\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "addEventListener",
            "description": "A stub for `window.addEventListener`, does not actually set up events unless overridden some place else.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "removeEventListener",
            "description": "A stub for `window.removeEventListener`.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "navigator",
            "description": "\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "location",
            "description": "\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "history",
            "description": "\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can-vdom.types.window",
    "parent": "can-vdom.types"
  },
  "can-validate-legacy.core": {
    "src": {
      "path": "node_modules/can-validate-legacy/docs/can-validate-legacy-core.md"
    },
    "body": "\n## Initialization\n\n```javascript\nvar validate = require('can-validate-legacy');\n// Validation library\nrequire('validate.js');\n// Shim for library\nrequire('can-validate-legacy/shims/validatejs');\n```\n\nThe key initializing part is the shim. The shim will define how the can-validate methods\nbehave and will also define the necessary parameters.\n\n## Registering a Shim\n\nIf a new shim is needed, it must first be register itself with can-validate.\n\n<div class='demo_wrapper' data-demo-src='./demo/core-demo/demo.html'></div>\n\n",
    "description": "  Returns an object with helpful methods that will call a validation library to validate\n values.\n\n How each method behaves depends on the chosen shim and validation library.\n\n",
    "title": "Core",
    "name": "can-validate-legacy.core",
    "type": "function",
    "parent": "can-validate-legacy",
    "comment": " ",
    "signatures": [
      {
        "code": "validate.register(LIBRARY_NAME, MAP_OF_METHODS)",
        "description": "\n\nThe `MAP_OF_METHODS` consists of three methods that define the three main uses cases, validate many, validate one, and check one.\n\n## Demo\n",
        "params": []
      }
    ]
  },
  "can-validate-legacy.map-plugin": {
    "src": {
      "path": "node_modules/can-validate-legacy/docs/can-map-plugin.md"
    },
    "body": "\n## Initialization\nImport the validation library, validate plugin and a shim to immediately use the\ncan.Map.validate plugin.\n```js\nimport \"validatejs\";\nimport \"can-validate/map/validate\";\nimport \"can-validate/shims/validatejs.shim\";\n```\n\n## Usage\n\nUsing can-validate Map plugin only requires two extra actions,\n\n- add a validate object to the desired property\n- add a check in the view for the errors object\n\nThe validate object depends on the desired valdiation library. The examples\nbelow use ValidateJS.\n\n```js\nvar ViewModel = can.Map.extend({\n  define: {\n    name: {\n      value: \"\",\n      validate: {\n        required: true\n      }\n    }\n  }\n});\nvar viewModel = new ViewModel({});\nviewModel.validate();\n// `errors` will have an error because the `name` value is empty\n//  and required is true.\nviewModel.attr(\"errors\");\nviewModel.attr(\"name\", \"Juan\");\nviewModel.attr(\"errors\"); // => Errors is now empty!\n```\n\n## Demo\n\n<div class='demo_wrapper' data-demo-src='./can-validate/map/validate/demo.html'></div>\n\n",
    "description": "The can.Map plugin will works alongside can.Map.define to add validation to properties on a can.Map. Importing the plugin, validation library, and a shim will\nallow the ability to dynamically check values against validation configuration. errors\nare stored on the can.Map instance and are observable.\n\n",
    "title": "Map Plugin",
    "name": "can-validate-legacy.map-plugin",
    "type": "function",
    "parent": "can-validate-legacy",
    "comment": " "
  },
  "can-validate-legacy.changelog": {
    "src": {
      "path": "node_modules/can-validate-legacy/docs/changelog.md"
    },
    "body": "\n### Changed\n\n- Restructured repository, main files live in root now; no `can-validate` subdirectory now.\n- Refactored tests to match CanJS standard of using QUnit.\n- Refactored codebase to match CanJS standard of using ES5.\n- Restructured Demos after repo changes\n- Updated dependencies to use CanJS 3.0 modules\n- Moved repository to `can-validate-legacy`. Original repository will continue but will soon change to match CanJS 3.0 patterns.\n- Updated docs to work with Bit-Docs\n\n## [0.9.2] - 2015-06-02\n\n### Changed\n\n- Cleaning up code after incorrect merge.\n\n## [0.9.1] - 2015-06-02\n\n### Changed\n\n- Fixed Validate all bug where some properties would not get properly validate when undefined in map instance.\n- Fixed overloading of validate list on validate all method.\n\n## [0.9.0] - 2015-06-01\n\n### Changed\n\n- [#26](https://github.com/canjs/can-validate/issues/26) Fixed bug that overwrote validate properties for all instances of a Map or Model. Computes are now cached to a dunder property versus overwriting the main `validate` property.\n- [#27](https://github.com/canjs/can-validate/issues/27) Fixed the `validate` method so it resolves computes. Computes are created from functions passed as validate options so validation can be triggered when compute change is triggered.\n- Improved validate init. Using a better method for detecting when Map is initing.\n\n## [0.8.4] - 2016-06-01\n\n### Added\n\n- Added tests for issue [#26](https://github.com/canjs/can-validate/issues/26)\n- Added tests for issue [#27](https://github.com/canjs/can-validate/issues/27)\n\n### Changed\n\n- Updated dependencies\n- Switched to Mocha\n- Improved tests\n\n## [0.8.3] - 2016-04-21\n\n### Changed\n\n- Fixed bug when errors was blank would cause console error\n\n## [0.8.2] - 2016-03-02\n\n### Changed\n\n- Improved handling of validation strings, passes strings through to Validate.JS.\n\n## [0.8.1] - 2016-02-03\n\n### Added\n\n- This change log\n- Contributing guide\n\n### Changed\n\n- Changed documentation root to `can-validate-plugin`, changed from `can-validate-library`.\n- Improved readme.\n- Improved overall documentation.\n\n### Removed\n\n- Removed CanJS Validations library documentation since it is still a WIP.\n\n## [0.8.0] - 2015-12-03\n\n### Changed\n- Fixed memory leaks.\n- Improved validate object compute handling.\n- Updated to work with CanJS 2.3.x.\n\n## [0.7.1] - 2015-11-23\n\n### Changed\n- Improved build.\n\n## [0.7.0] - 2015-10-19\n\n### Added\n- Added XO for linting.\n\n### Changed\n- Cleaned up lint errors in repo.\n\n## [0.6.0] - 2015-10-19\n\n### Added\n- Improved ability to pass functions to validation properties.\n\n### Changed\n- Fixed map init bug.\n\n## [0.5.2] - 2015-10-18\n\n### Changed\n- Fixed tests.\n- Fixed merge conflicts/errors.\n\n## [0.5.1] - 2015-10-01\n\n### Changed\n- Fixed require bug.\n\n## [0.5.0] - 2015-07-16\n\n### Added\n- Added \"validate all\" method to can.Map plugin\n\n## [0.4.2] - 2015-07-13\n\n### Added\n- Published to NPM\n\n## [0.4.1] - 2015-07-13\n\n### Added\n- Inline docs.\n- Added DocumentJS dependency.\n\n## [0.4.0] - 2015-07-10\n\n### Changed\n- Restructured repository.\n\n## [0.3.0] - 2015-07-10\n\n### Added\n- Browserify build.\n\n### Changed\n- Overall build improvements.\n\n## [0.2.0] - 2015-07-09\n\n### Changed\n- Made buildable. Using `import` over Steal syntax.\n\n## [0.1.0] - 2015-07-08\n\n### Added\n- Created can-validate entry point.\n- Created can.Map plugin.\n- Created ValidateJS shim\n\n\n[0.8.0]: https://github.com/canjs/can-validate/commit/0b98de198af17980174531146e43fb8c4b5e11a6\n[0.7.1]: https://github.com/canjs/can-validate/commit/2a58bf9ef280c2bb378221c6c18e85c7fed6daa3\n[0.7.0]: https://github.com/canjs/can-validate/commit/6be268da2a02e2985f71fa1f7196bfad94c84ca5\n[0.6.0]: https://github.com/canjs/can-validate/commit/0383d482353319a6eec3cf218daaa99b8ce62585\n[0.5.2]: https://github.com/canjs/can-validate/commit/17f46a11fb3f788e029359476bca83a67dca2b94\n[0.5.1]: https://github.com/canjs/can-validate/commit/5280c965df668b3eb1b95d10847f20676a3c5820\n[0.5.0]: https://github.com/canjs/can-validate/commit/53d965869263f39ea03dca97822fd5173cf62cdc\n[0.4.2]: https://github.com/canjs/can-validate/commit/608ee0cefdc161ecdf186980738952c86c937981\n[0.4.1]: https://github.com/canjs/can-validate/commit/c15d0b72bcc3e7343615d41baccbf3cf10242898\n[0.4.0]: https://github.com/canjs/can-validate/commit/a1d581aa31c304b04a7bdb4dc40106cf5c48771d\n[0.3.0]: https://github.com/canjs/can-validate/commit/4a7de30a12c27e7db992ac2bfcdb55e94e61c17a\n[0.2.0]: https://github.com/canjs/can-validate/commit/7ba46b1ea42315f68532f4246031d9bf074b785d\n[0.1.0]: https://github.com/canjs/can-validate/commit/b9a9aa2c43d672d9c238a506d788bafb3f89ee70\n\n",
    "description": "\n## UNRELEASED - 2016-11-23\n",
    "name": "can-validate-legacy.changelog",
    "title": "Changelog",
    "type": "page",
    "parent": "can-validate-legacy"
  },
  "can-validate-legacy.shims": {
    "src": {
      "path": "node_modules/can-validate-legacy/docs/shims.md"
    },
    "body": "\n## Available Shims\n\nThe original validations plugin for CanJS included a basic validation library, it\nwas ported over to can-validate as it's own library and can be used with can-validate\nusing it's shim.\n\nThere is also a shim for the popular library ValidateJS.\n\nMore libraries/shims may be added in the future but it is very easy to create a shim\nfor any library in your project.\n\n\n## Creating your own shim\n\nStart by extending can.Construct.\n\n```js\nvar Shim = can.Construct.extend({});\n```\n\nYou'll need `can` and your library, so let's add them...\n\n```js\nimport can from 'can';\nimport myLibrary from 'awesomeLibrary';\n\nvar Shim = can.Construct.extend({});\n```\n\nWe might as well register the shim now...\n\n```js\nimport can from 'can';\nimport myLibrary from 'awesomeLibrary';\n\nvar Shim = can.Construct.extend({});\n\ncan.validate.register('myLibrary', Shim);\n```\n\nSweet. Looks good so far. Now let's add the meat.\n\n```js\nimport can from 'can';\nimport myLibrary from 'awesomeLibrary';\n\nvar Shim = can.Construct.extend({\n\tisValid: function (value, options, name) {\n\t\treturn;\n\t},\n\tonce: function (value, options) {\n\t\treturn;\n\t},\n\tvalidate: function (values, options) {\n\t\treturn;\n\t}\n});\n\ncan.validate.register('myLibrary', Shim);\n```\n\nThis is all that is required. Not a lot of validation going on but the rest depends\non how your validation library works.\n\nYou may need to process the options or values a bit. You might even need to make\nsure the errors object is correct.\n\n**Remember, these methods should return `undefined` if no errors occurred. Otherwise,\nthey should return an array of errors.**\n\n",
    "description": "\nShims allow the flexibility of using any validation library with `can.validate`.\nCreating a shim requires just three methods, `isValid`, `once`, and `validate`.\nThe shim should also import the validation library itself. The shim then registers\nitself with can.validate and passes the methods object.\n",
    "title": "Shims",
    "name": "can-validate-legacy.shims",
    "type": "function",
    "parent": "can-validate-legacy"
  },
  "validatejs-shim": {
    "src": {
      "path": "node_modules/can-validate-legacy/docs/validatejs-shim.md"
    },
    "body": "\nHello world\n\n\n## Initialization\nImport ValidateJS, validate plugin and this shim to immediately use the\nValidateJS in a CanJS project plugin.\n```js\nimport \"validatejs\";\nimport \"can-validate/can-validate\";\nimport \"can-validate/shims/validatejs.shim\";\n```\n\n## Usage\n\n",
    "description": " This shim requires ValidateJS in the consuming app's package.json. It processes\nthe passed in options so they can be properly used by the ValidateJS libarary.\n",
    "type": "module",
    "title": "ValidateJS Shim",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "validatejs-shim",
    "parent": "can-validate-legacy.shims",
    "comment": " ",
    "signatures": [
      {
        "code": "validate(MAP_OF_VALUES, MAP_OF_CONSTRAINTS)",
        "description": "\n\n```javascript\nvar errors = validate.validate(user, constraints);\n```\n\nValidate is a can.Construct that is set to can.validate. It is possible to create\nan instance for the purpose of storing errors in the instance. It is recommended\nto use can.Map, can.Map.define, and can.Map.validate instead.\n",
        "params": []
      },
      {
        "code": "once(VALUE, CONSTRAINTS, VALUE_NAME)",
        "description": "\n\n```javascript\nvar errors = validate.once(user.firstName, constraints.firstName, 'firstName');\n```",
        "params": []
      },
      {
        "code": "isValid(VALUE, CONSTRAINTS, VALUE_NAME)",
        "description": "\n\n```javascript\nvar errors = validate.once(user.firstName, constraints.firstName, 'firstName');\n```\n",
        "params": []
      }
    ]
  },
  "can-validate-legacy": {
    "src": {
      "path": "node_modules/can-validate-legacy/docs/can-validate-legacy.md"
    },
    "body": "\nCan-Validate can be used in two ways, in a can-map instance or standalone.\n\n## Usage\n\nThe module should require the following files\n\n```javascript\nimport 'can-validate-legacy';\nimport 'validate.js';\nimport 'can-validate-legacy/shims/validatejs.shim';\n```\nNow, can-validate can be used in two ways, either in a can-map or standalone.\n\n### Can-Map Plugin Usage\n\nUsing the plugin for can-map requires the can-map-define plugins as well.\n\n```javascript\nimport 'can-validate-legacy/map/validate';\nimport 'can/map/define/define';\n```\n\nAll can-maps created in the module will now have an augmented setter that checks properties as they are set.\n\n```javascript\nvar ViewModel = Map.extend({\n  define: {\n    name: {\n      value: '',\n      validate: {\n        required: true\n      }\n    }\n  }\n});\nvar viewModel = new ViewModel({});\n//\nviewModel.validate();\n// `errors` will have an error because the `name` value is empty\n//  and required is true.\nviewModel.attr('errors'); //> Returns the raw response from validation library\nviewModel.attr('name', 'Juan');\nviewModel.attr('errors'); // => Errors is now empty!\n```\n\n### Standalone Usage\n\nFirst, make sure the correct files are required.\n\n```javascript\n// can.validate is now available\nimport 'can-validate-legacy';\n// Substitute with your library of choice\nimport 'validate.js';\n// If not using ValidateJS, then you'll need a custom shim\nimport 'can-validate-legacy/shims/validatejs.shim';\n```\n\nNow, we can validate many or a single property. Let's start with the\nfollowing values and constraints:\n\n\n```javascript\nvar user = {\n\tfirstName: \"juan\",\n\tlastName: \"Orozco\"\n};\n\nvar constraints = {\n\tfirstName: {\n\t\trequired: true,\n\t\tformat: {\n\t\t\tpattern: /^[A-Z].*/,\n\t\t\tmessage: \"^ must be proper cased.\"\n\t\t}\n\t},\n\tlastName: {\n\t\trequired: true,\n\t\tformat: {\n\t\t\tpattern: /^[A-Z].*/,\n\t\t\tmessage: \"^ must be proper cased.\"\n\t\t}\n\t}\n};\n```\n\nTo validate many properties, just run...\n\n```javascript\nvar errors = validate.validate(user, constraints);\n```\n\nThe `once` method allows validating just a single value.\n\n```javascript\nvar errors = validate.once(user.firstName, constraints.firstName, 'firstName');\n```\n\n\n## Shims and Validation Libraries\n\nA shim registers a validation library with can-validate. It also processes properties and values into a structure more acceptable by the validation library. This allows consuming libraries to switch validation libraries simply by switching out their shim - any new behavior or legacy behavior can be baked into the new shim.\n\nDon't have a library of choice? Can.Validate ships with a shim for [ValidateJS](http://validatejs.org/).\n\n## Change Log\n\nA change log is maintained [here](changelog.html).\n\n## Contributing\n\nWant to contribute? [Read the contributing](contributing.html) guide to start.\n\n",
    "description": "A plugin for CanJS that wraps any validation library to `can.validate`. **Can-Validate doesn't do any validation of its own** but instead provides some abstraction to your library of choice. The chosen library is registered with can-validate using a shim.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nCan-Validate provides methods that can be used to validate values regardless of the validation library used.\n\n  ```js\n  var validate = require(\"can-validate-legacy\");\n  require(\"can-validate-legacy/shims/validatejs.shim\");\n\n  var user = {\n\t  firstName: \"juan\"\n  };\n\n  var constraints = {\n\t  firstName: {\n\t\t  required: true,\n\t\t  format: {\n\t\t\t  pattern: /^[A-Z].*/,\n      \t\t  message: \"^ must be proper cased.\"\n\t\t  }\n\t  }\n  };\n\n  var errors = validate.validate(user, constraints);\n  ```\n"
      }
    ],
    "name": "can-validate-legacy",
    "parent": "can-data-validation",
    "collection": "can-legacy",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "browser": {
        "./can-validate": "./dist/cjs/can-validate/can-validate",
        "./map/validate": "./dist/cjs/can-validate/map/validate/validate",
        "./validations": "./dist/cjs/can-validate/validations",
        "./shims/validatejs.shim": "./dist/cjs/can-validate/shims/validatejs.shim"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-validate-legacy/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-util": "^3.9.0-pre.4",
        "validate.js": "^0.11.1"
      },
      "deprecated": false,
      "description": "Validation plugin for CanJS that provides an abstraction layer to your validation library of choice (Shim may be required).",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-compute": "^3.1.0-pre.11",
        "can-map": "^3.1.0-pre.11",
        "can-map-define": "^3.1.0-pre.1",
        "can-stache": "^3.1.0-pre.5",
        "detect-cyclic-packages": "^1.1.0",
        "jquery": "^3.1.1",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-stache": "^3.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-validate-legacy",
      "keywords": [
        "Validate",
        "plugin",
        "canjs"
      ],
      "license": "MIT",
      "main": "can-validate.js",
      "name": "can-validate-legacy",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-validate-legacy.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:pre": "npm version prerelease && npm run build && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "ignoreBrowser": true,
        "npmIgnore": [
          "documentjs",
          "testee",
          "steal-tools"
        ],
        "npmDependencies": [
          "steal-qunit"
        ],
        "paths": {
          "validate.js": "./node_modules/validate.js/validate.js"
        }
      },
      "version": "1.1.0"
    },
    "comment": " "
  },
  "can-vdom/make-parser/": {
    "name": "can-vdom/make-parser/",
    "type": "module",
    "parent": "node_modules/can-vdom/make-parser/make-parser.js",
    "src": {
      "line": 0,
      "codeLine": 8,
      "path": "node_modules/can-vdom/make-parser/make-parser.js"
    },
    "body": "\n",
    "description": "\nReturns a function that can generate a HTML->TOKENs parser\ngiven a document.\n",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "hide": true
  },
  "can-vdom/make-document/make-document": {
    "name": "can-vdom/make-document/make-document",
    "type": "module",
    "parent": "can-vdom.modules",
    "src": {
      "line": 0,
      "codeLine": 22,
      "path": "node_modules/can-vdom/make-document/make-document.js"
    },
    "body": "\n",
    "description": "\nExports a function that when called, returns a dom-light document object.\n",
    "title": "./make-document/make-document",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeDocument()",
        "description": "\n\n\nCreates a new simple document using [can-simple-dom]. Provides light-weight document needs,\nmostly for server-side rendering.\n\n```js\nvar makeDocument = require(\"can-vdom/make-document/make-document\");\nvar document = makeDocument();\n\ndocument.body //-> Node\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-simple-dom/document/document"
            }
          ],
          "description": "A can-simple-dom document.\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-simple-dom/document/document"
        }
      ],
      "description": "A can-simple-dom document.\n\n"
    }
  },
  "can-vdom/make-window/make-window": {
    "name": "can-vdom/make-window/make-window",
    "type": "module",
    "parent": "can-vdom.modules",
    "src": {
      "line": 0,
      "codeLine": 34,
      "path": "node_modules/can-vdom/make-window/make-window.js"
    },
    "body": "\n\n",
    "description": "\nExports a function that window called, returns an object that looks like a `window`.\n",
    "title": "./make-window/make-window",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeWindow()",
        "description": "\n\nCreates a document and places it, along with other common browser globals,\non a new object and then returns that object.\n\n```js\nvar makeWindow = require(\"can-vdom/make-window/make-window\");\nmakeWindow();\n\nwindow.document.body //-> Node\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-vdom.types.window"
            }
          ],
          "description": "An object with common browser globals.\n"
        }
      },
      {
        "code": "makeWindow(global)",
        "description": "\n\nCreates a document and places it, along with other common browser globals, on the `global` object.\n\n```js\nvar makeWindow = require(\"can-vdom/make-window/make-window\");\n\nvar window = makeWindow({});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-vdom.types.window"
              }
            ],
            "name": "global",
            "description": "An object that represents the environment's global."
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-vdom.types.window"
        }
      ],
      "description": "An object with common browser globals.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-vdom.types.window"
        }
      ],
      "name": "global",
      "description": "An object that represents the environment's global."
    }
  },
  "can-view-import.can-tag": {
    "src": {
      "path": "node_modules/can-view-import/docs/can-tag.md"
    },
    "body": "\n## Use\n\n**can-tag** allows a component to be injected using the imported promise as the\ninjected component’s view model.\n\nThe example below shows a loading graphic until the cart component has been loaded.\nOnce the cart promise is resolved, `<shopping-cart></shopping-cart>` is injected\ninto the page.\n\nFor example, here’s a `loading-indicator` component:\n\n```\nvar template = stache('{{#isResolved}}<content/>{{else}}<img src=\"loading.gif\"/>{{/isResolved}}');\n\nComponent.extend({\n  tag: \"loading-indicator\",\n  view: template\n});\n```\n\nHere’s how `can-tag` can be used to show the loading indicator before the `shopping-cart` component is imported:\n\n```\n<can-import from=\"cart\" can-tag=\"loading-indicator\">\n  <shopping-cart></shopping-cart>\n</can-import>\n```\n\n",
    "description": "Use another [can-view-callbacks.tag] (such as a [can-component]) to control the `<content>` of a [can-view-import].  \n",
    "title": "can-tag",
    "name": "can-view-import.can-tag",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "can-tag=\"TAG_NAME\"",
        "description": "\n\nInstantiates the provided [can-view-callbacks.tag] and sets its [can-component.prototype.view-model viewModel] to be the Promise for the import.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "TAG_NAME",
            "description": "The tag name (usually a [can-component]) to use.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "TAG_NAME",
      "description": "The tag name (usually a [can-component]) to use.\n"
    },
    "comment": " "
  },
  "can-view-import.pages": {
    "name": "can-view-import.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-view-import",
    "description": "",
    "order": 0
  },
  "can-view-import.attributes": {
    "name": "can-view-import.attributes",
    "title": "Attributes",
    "type": "group",
    "parent": "can-view-import",
    "description": "",
    "order": 1
  },
  "can-view-import": {
    "src": {
      "path": "node_modules/can-view-import/docs/can-view-import.md"
    },
    "body": "\n## Use\n\nA template might depend on component or helper modules. `<can-import>` allows\nyou to specify these dependencies.\n\nExample:\n\n```\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\nCurrently this __only__ works with [can-view-autorender] or the [steal-stache] plugin.\n\n## Progressive Loading\n\nA template may (conditionally) load a module after the initial page load. `<can-import>` allows progressive loading by using an end tag.\n\nThis example shows a component being loaded ad hoc:\n\n```\n<can-import from=\"components/home\"></can-import>\n```\n\nThis example illustrates conditionally loading modules based on some application state:\n\n```\n{{#eq location 'home'}}\n  <can-import from=\"components/home\">\n    ...\n  </can-import>\n{{/eq}}\n\n{{#eq location 'away'}}\n  <can-import from=\"components/away\">\n    ...\n  </can-import>\n{{/eq}}\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-view-import",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-import",
    "parent": "can-views",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-import/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-assign": "^1.0.0",
        "can-dom-data-state": "^0.1.1",
        "can-event": "^3.6.0",
        "can-globals": "^0.2.3",
        "can-log": "^0.1.0",
        "can-stache": "^3.7.3",
        "can-util": "^3.9.5",
        "can-view-callbacks": "^3.2.0",
        "can-view-nodelist": "^3.1.0"
      },
      "deprecated": false,
      "description": "Import dependencies in CanJS views",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-component": "^3.2.2",
        "can-compute": "^3.3.1",
        "can-map": "^3.3.1",
        "can-stache": "^3.3.0",
        "can-test-helpers": "^1.0.1",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.0",
        "steal-qunit": "^1.0.0",
        "steal-stache": "^3.1.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.7.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [],
      "main": "can-view-import",
      "name": "can-view-import",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-import.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve,steal-stache",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.2.2"
    },
    "signatures": [
      {
        "code": "<can-import from=\"MODULE_NAME\" />",
        "description": "\n\nStatically import a module from within a [can-stache] template. *MODULE_NAME* will be imported before the template renders.\n\n```\n<can-import from=\"components/tabs\" />\n<tabs-widget />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "optional": true,
            "name": "MODULE_NAME",
            "description": "A module that this template depends on.\n"
          }
        ]
      },
      {
        "code": "<can-import from=\"MODULE_NAME\">content</can-import>",
        "description": "\n\nDynamically import *MODULE_NAME* if *content* is anything other than whitespace; the scope within the template is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```\n<can-import from=\"components/tabs\">\n  {{#if isResolved}}\n    <tabs-widget />\n  {{/if}}\n</can-import>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "optional": true,
            "name": "MODULE_NAME",
            "description": "A module that this template depends on.\n"
          }
        ]
      },
      {
        "code": "<can-dynamic-import from=\"MODULE_NAME\">content</can-import>",
        "description": "\n\nDynamically import *MODULE_NAME*; the scope within the template is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```\n<can-dynamic-import from=\"components/tabs\">\n  {{#if isResolved}}\n    <tabs-widget />\n  {{/if}}\n</can-dynamic-import>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "optional": true,
            "name": "MODULE_NAME",
            "description": "A module that this template depends on.\n"
          }
        ]
      },
      {
        "code": "<can-dynamic-import from=\"MODULE_NAME\" value:to=\"*MODULE_REF\"/>",
        "description": "\n\nDynamically import a module from within a [can-stache] template. Since there is no subtemplate to attach the [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) to as the current scope, you must export the Promise's resolved value to the template's refs scope using [can-view-import.value].\n\n```\n<can-dynamic-import from=\"components/tabs\" value:to=\"*tabsWidget\" />\n{{#if *tabsWidget}}\n\t<tabs-widget />\n{{/if}}\n\n{{! other can-reflect-promise keys also work, as does the *REFERENCE shorthand from can-stache-bindings }}\n\n<can-dynamic-import from=\"components/tabs\" \n\tisPending:to=\"*tabsWidgetPending\"\n\tisRejected:to=\"*tabsWidgetError\"\n\tthis:to\"*tabsWidgetPromise\" />\n{{#if *tabsWidgetPending}}\n\tLoading...\n{{else}}\n\t<tabs-widget />\n\t{{#if *tabsWidgetError}}\n\t\t{{*tabsWidgetPromise.reason}}\n\t{{/if}}\n{{/if}}\n\n{{! load a stache partial \n\t -- staches are functions, so prefix it with `@` to put the function in the ref scope without running it }}\n\n<can-dynamic-import from \"my-partial.stache!\" @value:to=\"*myPartial\" />\n\n{{> *myPartial}}\n\n\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "optional": true,
            "name": "MODULE_NAME",
            "description": "A module that this template depends on.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "moduleName"
        }
      ],
      "optional": true,
      "name": "MODULE_NAME",
      "description": "A module that this template depends on.\n"
    },
    "comment": " "
  },
  "can-view-import.pages.dynamic": {
    "src": {
      "path": "node_modules/can-view-import/docs/dynamic.md"
    },
    "body": "\n### Example\n\nThese `can-dynamic-import` and Steal import examples are equivalent:\n\n```\n<can-dynamic-import from=\"components/foobar\">\n  {{#if isResolved}}\n    <foobar/>\n  {{/if}}\n</can-dynamic-import>\n```\n\n```\nsteal.import('components/foobar').then(function(foobar) {\n // access to the module you loaded.\n // e.g. access to a component's ViewModel \n // foobar.ViewModel\n});\n```\n\n__Note:__ when dynamically importing modules in a stache file, the scope inside [can-view-import <can-import>] is a Promise, so you have to wait until it is resolved before injecting something like a [can-component]. Use the `{{#if isResolved}}` helper to determine whether the Promise has been resolved.\n\n",
    "description": "\nDynamic imports are used in conditional situations such as within an [can-stache.helpers.if] to prevent unnecessarily fetching resources that might not be needed in all cases.\n",
    "name": "can-view-import.pages.dynamic",
    "title": "Dynamic Imports",
    "type": "page",
    "parent": "can-view-import.pages"
  },
  "can-view-import.from": {
    "src": {
      "path": "node_modules/can-view-import/docs/from.md"
    },
    "body": "",
    "description": "Set the module name that will be imported into the template. \n",
    "title": "from",
    "name": "can-view-import.from",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "from=\"MODULE_NAME\"",
        "description": "\n\nPasses MODULE_NAME to [can-util/js/import/import] and sets the [can-view-import <can-import>]'s viewModel to be the returned Promise.\n\n```js\n<can-import from=\"bootstrap/bootstrap.css\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "MODULE_NAME",
            "description": "The name of the module to import.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "MODULE_NAME",
      "description": "The name of the module to import.\n"
    }
  },
  "can-view-import.pages.static": {
    "src": {
      "path": "node_modules/can-view-import/docs/static.md"
    },
    "body": "\nTo make your import be static, it *must* not have any content.  Make it a self closing tag (ending in  `/>`) or make sure to not have anything but space between the opening and closing tag.\n\n## Example\n\nThese `can-import` and ES6 import examples are equivalent:\n\n```\n<can-import from=\"mymodule\" />\n```\n\n```\nimport from \"mymodule\";\n```\n\n",
    "description": "\nStatic imports reflect direct dependencies of the template. Most uses of [can-view-import] will be for static imports.\n",
    "name": "can-view-import.pages.static",
    "title": "Static Imports",
    "type": "page",
    "parent": "can-view-import.pages"
  },
  "can-view-import.value": {
    "src": {
      "path": "node_modules/can-view-import/docs/value.md"
    },
    "body": "",
    "description": "Set the value that is returned from the [can-view-import can-import] Promise to a [can-stache-bindings.reference reference scope] variable. \n",
    "title": "value:to",
    "name": "can-view-import.value",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "value:to=\"*NAME\"",
        "description": "\n\nSets up a [can-stache-bindings.toParent] binding to \\*NAME in the references scope.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "NAME",
            "description": "The variable name to assign to the references scope. This can be any string name you want to use, but must be preceded by `*` or it will be placed on the template's View Model.\n\n```html\n<can-import from=\"app/person\" {^value}=\"*person\" />\n\t\n<section>\n\thello {{*person.name}}\n</section>\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "NAME",
      "description": "The variable name to assign to the references scope. This can be any string name you want to use, but must be preceded by `*` or it will be placed on the template's View Model.\n\n```html\n<can-import from=\"app/person\" {^value}=\"*person\" />\n\t\n<section>\n\thello {{*person.name}}\n</section>\n```\n"
    }
  },
  "can-view-callbacks.attrData": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/attrData.md"
    },
    "body": "\n",
    "description": "\nThe data provided to [can-view-callbacks.attr].\n",
    "type": "typedef",
    "title": "attrData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "scope",
            "description": "The scope of the element.\n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "The mustache helpers and other non-data values passed to the template.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          },
          {
            "name": "attributeName",
            "description": "The attribute name that was matched.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ],
        "description": "\n\n  ```js\n  var canViewCallbacks = require(\"can-view-callbacks\");\n  var stache = require(\"can-stache\");\n\n  canViewCallbacks.attr(\"my-attr\", function(el, attrData){\n    attrData.scope.peak(\"value\") //-> 123\n\tattrData.attributeName       //-> \"my-attr\"\n\n  });\n\n  stache(\"<div my-attr='value'/>\")({\n\t  value: 123\n  });\n  ```\n"
      }
    ],
    "name": "can-view-callbacks.attrData",
    "parent": "can-view-callbacks/types"
  },
  "can-view-callbacks.attr": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/attr.md"
    },
    "body": "\n\n## Use\n\n`canViewCallbacks.attr` is used to add custom behavior to elements that contain a\nspecified html attribute. Typically it is used to mixin behavior (whereas\n[can-view-callbacks.tag] is used to define behavior).\n\nThe following example adds a jQueryUI tooltip to any element that has\na `tooltip` attribute like `<div tooltip=\"Click to edit\">Name</div>`.\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/tooltip.html'></div>\n\n## Listening to attribute changes\n\nIn the previous example, the content of the tooltip was static. However,\nit's likely that the tooltip's value might change. For instance, the template\nmight want to dynamically update the tooltip like:\n\n    <button tooltip=\"{{deleteTooltip}}\">\n      Delete\n    </button>\n\nWhere `deleteTooltip` changes depending on how many users are selected:\n\n    deleteTooltip: function(){\n      var selectedCount = selected.length;\n      if(selectedCount) {\n        return \"Delete \"+selectedCount+\" users\";\n      } else {\n        return \"Select users to delete them.\";\n      }\n    }\n\n\nThe [can-util/dom/events/attributes/attributes attributes] event can be used to listen to when\nthe toolip attribute changes its value like:\n\n```js\ncanViewCallbacks.attr(\"tooltip\", function( el, attrData ) {\n\t// A helper that updates or sets up the tooltip\n\tvar updateTooltip = function(){\n\t\t$(el).tooltip({\n\t\t\tcontent: el.getAttribute(\"tooltip\"),\n\t\t\titems: \"[tooltip]\"\n\t\t})\n\t}\n\t// When the tooltip attribute changes, update the tooltip\n\tdomEvents.addEventListener.call(el, \"attributes\", function(ev){\n\t\tif(ev.attributeName === \"tooltip\") {\n\t\t\tupdateTooltip();\n\t\t}\n\t});\n\t// Setup the tooltip\n\tupdateTooltip();\n\n});\n```\n\nTo see this behavior in the following demo, hover the mouse over the \"Delete\" button.  Then\nselect some users and hover over the \"Delete\" button again:\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/dynamic_tooltip.html'></div>\n\n\n## Reading values from the scope.\n\nIt's common that attribute mixins need complex, observable data to\nperform rich behavior. The attribute mixin is able to read\ndata from the element's [can.view.Scope scope]. For example,\n__toggle__ and __fade-in-when__ will need the value of `showing` in:\n\n    <button toggle=\"showing\">\n      {{#showing}}Show{{else}}Hide{{/showing}} more info</button>\n    <div fade-in-when=\"showing\">\n      Here is more info!\n    </div>\n\nThese values can be read from [can-view-callbacks.attrData]'s scope like:\n\n    attrData.scope.attr(\"showing\")\n\nBut often, you want to update scope value or listen when the scope value\nchanges. For example, the __toggle__ mixin might want to update `showing`\nand the __fade-in-when__ mixin needs to know when\nthe `showing` changes.  Both of these can be achived by\nusing [can-view-scope::compute compute] to get a get/set compute that is\ntied to the value in the scope:\n\n    var showing = attrData.scope.compute(\"showing\")\n\nThis value can be written to by `toggle`:\n\n\n    canViewCallbacks.attr(\"toggle\", function(el, attrData){\n\n      var attrValue = el.getAttribute(\"toggle\")\n          toggleCompute = attrData.scope.compute(attrValue);\n\n      $(el).click(function(){\n        toggleCompute(! toggleCompute() )\n      })\n\n    })\n\nOr listened to by `fade-in-when`:\n\n    canViewCallbacks.attr(\"fade-in-when\", function( el, attrData ) {\n      var attrValue = el.getAttribute(\"fade-in-when\");\n          fadeInCompute = attrData.scope.compute(attrValue),\n          handler = function(ev, newVal, oldVal){\n            if(newVal && !oldVal) {\n              $(el).fadeIn(\"slow\")\n            } else if(!newVal){\n              $(el).hide()\n            }\n          }\n\n      fadeInCompute.on(\"change\",handler);\n\n      ...\n    });\n\nWhen you listen to something other than the attribute's element, remember to\nunbind the event handler when the element is [can-util/dom/events/removed/removed removed] from the page:\n\n```js\ndomEvents.addEventListener.call(el,\"removed\", function(){\n\tfadeInCompute.off(handler);\n});\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/fade_in_when.html'></div>\n\n## When to call\n\n`canViewCallbacks.attr` must be called before a template is processed. When [using `can.view` to create a renderer function](http://canjs.com/docs/can.view.html#sig_can_view_idOrUrl_), `canViewCallbacks.attr` must be called before the template is loaded, not simply before it is rendered.\n\n\t\t//Call canViewCallbacks.attr first\n\t\tcanViewCallbacks.attr('tooltip', tooltipFunction);\n\t\t//Preload a template for rendering\n\t\tvar renderer = stache(\"<div tooltip='Hi There'>...</div>\");\n\t\t//No calls to canViewCallbacks.attr after this will be used by `renderer`\n\n",
    "description": "\nRegister custom behavior for an attribute.\n",
    "title": "attr",
    "name": "can-view-callbacks.attr",
    "type": "function",
    "parent": "can-view-callbacks/methods",
    "signatures": [
      {
        "code": "callbacks.attr(attributeName, attrHandler(el, attrData))",
        "description": "\n\nRegisters the `attrHandler` callback when `attributeName` is found\nin a template.\n\nHandlers must be registered before templates using them are parsed.\n\n```js\nvar canViewCallbacks = require(\"can-view-callbacks\");\n\ncanViewCallbacks.attr(\"show-when\", function(el, attrData){\n\tvar prop = el.getAttribute(\"show-when\");\n\tvar compute = attrData.compute(prop);\n\n\tvar showOrHide = function(){\n\t\tvar val = compute();\n\t\tif(val) {\n\t\t\tel.style.display = 'block';\n\t\t} else {\n\t\t\tel.style.display = 'hidden';\n\t\t}\n\t};\n\n\tcompute.on(\"change\", showOrHide);\n\tshowOrHide();\n\n\tdomEvents.addEventListener.call( el, \"removed\", function onremove(){\n\t\tcompute.off(\"change\", showOrHide);\n\t\tdomEvents.removeEventListener.call(\"removed\", onremove);\n\t});\n});\n```\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "RegExp"
              }
            ],
            "name": "attributeName",
            "description": "A lower-case attribute name or regular expression\nthat matches attribute names. Examples: `\"my-fill\"` or `/my-\\w/`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "HTMLElement"
                      }
                    ],
                    "name": "el"
                  },
                  {
                    "types": [
                      {
                        "type": "can-view-callbacks.attrData"
                      }
                    ],
                    "name": "attrData"
                  }
                ]
              }
            ],
            "name": "attrHandler",
            "description": "\nA function that adds custom behavior to `el`. Note that `el` might not be in the DOM\nwhen the callback is called.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ],
              "name": "el"
            },
            {
              "types": [
                {
                  "type": "can-view-callbacks.attrData"
                }
              ],
              "name": "attrData"
            }
          ]
        }
      ],
      "name": "attrHandler",
      "description": "\nA function that adds custom behavior to `el`. Note that `el` might not be in the DOM\nwhen the callback is called.\n"
    },
    "comment": " "
  },
  "can-view-callbacks/methods": {
    "name": "can-view-callbacks/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-view-callbacks",
    "description": "",
    "order": 0
  },
  "can-view-callbacks/types": {
    "name": "can-view-callbacks/types",
    "title": "types",
    "type": "group",
    "parent": "can-view-callbacks",
    "description": "",
    "order": 0
  },
  "can-view-callbacks": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/can-view-callbacks.md"
    },
    "body": "\nAllows registering callback functions that will be called when tags and attributes are rendered in [can-view-target].\n\n## Registering tags\n\n[can-view-callbacks.tag callbacks.tag] allows you to register a tag that custom behavior will be attached to.\n\nThis will style elements using the *blue-el* tag with a blue background.\n\n```js\nvar callbacks = require(\"can-view-callbacks\");\n\ncallbacks.tag(\"blue-el\", function(el){\n\tel.style.background = \"blue\";\n});\n```\n\n```html\n<blue-el><p>Some content with a blue background, gross!</p></blue-el>\n```\n\n## Registering attributes\n\nSimilarly you can register a callback for an attribute. Here we are using a regular expression to match an attribute that starts with `foo-`:\n\n```js\ncallbacks.attr(/foo-[\\w\\.]+/, function(el, attrData){\n\t// Get the part after foo-\n\tvar attrValue = attrData.attributeName.substr(4);\n\n\t// Set it's content\n\tel.textContent = attrValue;\n});\n```\n\nSo that:\n\n```html\n<div foo-bar></div>\n```\n\nRenders as:\n\n```html\n<div foo-bar>bar</div>\n```\n\n",
    "description": "Registered callbacks for behaviors \n",
    "type": "module",
    "title": "can-view-callbacks",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-callbacks",
    "parent": "can-views",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-callbacks/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-namespace": "1.0.0",
        "can-observation": "^3.3.1",
        "can-util": "^3.9.5"
      },
      "deprecated": false,
      "description": "Registered callbacks for behaviors",
      "devDependencies": {
        "can-test-helpers": "^1.0.1",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.2.0",
        "jshint": "^2.9.1",
        "steal": "^1.5.6",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.4.0",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-callbacks",
      "name": "can-view-callbacks",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-callbacks.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.2.2"
    },
    "comment": " "
  },
  "can-view-callbacks.tagData": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/tagData.md"
    },
    "body": "\n",
    "description": "\nThe data passed to [can-view-callbacks.tag].\n",
    "type": "typedef",
    "title": "tagData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "subtemplate",
            "description": "If the special tag has content,\nthe content can be rendered with subtemplate.  For example:\n\n```js\ncallbacks.tag(\"foo-bar\", function(el, tagData){\n  var frag = tagData.subtemplate(tagData.scope, tagData.options);\n  $(el).html(frag);\n});\n```\n",
            "types": [
              {
                "type": "can-stache.renderer"
              }
            ],
            "optional": true
          },
          {
            "name": "scope",
            "description": "The scope of the element.  \n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "The mustache helpers and other non-data values passed to the template.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          }
        ],
        "description": "\n"
      }
    ],
    "name": "can-view-callbacks.tagData",
    "parent": "can-view-callbacks/types"
  },
  "can-view-callbacks.tag": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/tag.md"
    },
    "body": "\n\n## Use\n\n`canViewCallbacks.tag` is a low-level way to add custom behavior to custom elements. Often, you\nwant to do this with [can-component]. However, [can-view-callbacks.tag callbacks.tag] is\nuseful for when [can-component] might be considered overkill.  For example, the\nfollowing creates a [jQueryUI DatePicker](http://api.jqueryui.com/datepicker/) everytime a\n`<jqui-datepicker>` element is found:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker()\n    })\n\n\nThe `tagHandler`'s [can-view-callbacks.tagData] argument is an object\nthat contains the stache [can-view-scope Scope] and helper [can-view-scope.Options]\nwhere `el` is found and a [can-stache.renderer subtemplate] that renders the contents of the\ntemplate within the custom tag.\n\n## Getting values from the template\n\n`tagData.scope` can be used to read data from the template.  For example, if I wanted\nthe value of `\"format\"` within the current template, it could be read like:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker({format: tagData.scope.get(\"format\")})\n    })\n\n    var template = mustache(\"<jqui-datepicker></jqui-datepicker>\")\n    template({format: \"mm/dd/yy\"})\n\n`tagData.options` contains the helpers and partials provided\nto the template.  A helper function might need to be called to get the current value of format like:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker({format: tagData.options.get(\"helpers.format\")()})\n    })\n\n    var template = mustache(\"<jqui-datepicker></jqui-datepicker>\")\n    template({},{format: function(){\n      return \"mm/dd/yy\"\n    }})\n\n## Responding to changing data\n\nOften, data passed to a template is observable.  If you use [can-view-callbacks.tag], you must\nlisten and respond to chagnes yourself.  Consider if format is property on a\n`settings` [can.Map] like:\n\n    var settings = new Map({\n      format: \"mm/dd/yy\"\n    })\n\nYou want to update the datepicker if `format` changes.  The easiest way to do this\nis to use [can-view-scope::compute Scope's compute] method which returns a get-set\ncompute that is tied to a key value:\n\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n\n      var formatCompute = tagData.scope.compute(\"format\"),\n          changeHandler = function(ev, newVal){\n            $(el).datepicker(\"option\",\"format\", newVal});\n          }\n\n      formatCompute.bind(\"change\",changeHandler)\n\n      changeHandler({}, formatCompute());\n\n      ...\n\n    })\n\n    var template = mustache(\"<jqui-datepicker/>\")\n    template(settings)\n\nIf you listen on something outside the tag, it's a good practice to stop listening\nwhen the element is [can-util/dom/events/removed/removed removed] from the page:\n\n\tdomEvents.addEventListener.call( el, \"removed\", function onremove(){\n\t\tcompute.off(\"change\", showOrHide);\n\t\tformatCompute.unbind(\"change\",changeHandler)\n\t});\n\n\n## Subtemplate\n\nIf content is found within a custom tag like:\n\n    var template = stache(\n      \"<my-form>\\\n         <input value=\"{{first}}\"/>\\\n         <input value=\"{{last}}\"/>\\\n       </my-form>\")\n\nA separate template function is compiled and passed\nas `tagData.subtemplate`.  That subtemplate can\nbe rendered with custom data and options. For example:\n\n    callbacks.tag(\"my-form\", function(el, tagData){\n       var frag = tagData.subtemplate({\n         first: \"Justin\"\n       }, tagData.options)\n\n       $(el).html( frag )\n    })\n\n    template({\n      last: \"Meyer\"\n    })\n\n\nIn this case, the sub-template will not get a value for `last`.  To\ninclude the original data in the subtemplate's scope, [can-view-scope::add] to\nthe old scope like:\n\n    callbacks.tag(\"my-form\", function(el, tagData){\n       var frag = tagData.subtemplate(\n         tagData.scope.add({ first: \"Justin\" }),\n         tagData.options)\n\n       $(el).html( frag )\n    })\n\n    template({\n      last: \"Meyer\"\n    })\n\n",
    "description": "\n",
    "title": "tag",
    "name": "can-view-callbacks.tag",
    "type": "function",
    "parent": "can-view-callbacks/methods",
    "signatures": [
      {
        "code": "callbacks.tag(tagName, tagHandler(el, tagData))",
        "description": "\n\nRegisters the `tagHandler` callback when `tagName` is found\nin a template.\n\n```js\nvar $ = require(\"jquery\");\nrequire(\"jquery-datepicker\");\nvar canViewCallbacks = require(\"can-view-callbacks\");\n\ncanViewCallbacks.tag(\"date-picker\", function(el, tagData){\n\t$(el).datePicker();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "A lower-case, hypenated or colon-seperated html\ntag. Example: `\"my-widget\"` or `\"my:widget\"`.  It is considered a best-practice to\nhave a hypen or colon in all custom-tag names.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "can.view.Scope"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "HTMLElement"
                      }
                    ],
                    "name": "el"
                  },
                  {
                    "types": [
                      {
                        "type": "can.view.tagData"
                      }
                    ],
                    "name": "tagData"
                  }
                ]
              }
            ],
            "name": "tagHandler",
            "description": "\n\nAdds custom behavior to `el`.  If `tagHandler` returns data, it is used to\nrender `tagData.subtemplate` and the result is inserted as the childNodes of `el`.\n"
          }
        ],
        "release": "2.1"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "can.view.Scope"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ],
              "name": "el"
            },
            {
              "types": [
                {
                  "type": "can.view.tagData"
                }
              ],
              "name": "tagData"
            }
          ]
        }
      ],
      "name": "tagHandler",
      "description": "\n\nAdds custom behavior to `el`.  If `tagHandler` returns data, it is used to\nrender `tagData.subtemplate` and the result is inserted as the childNodes of `el`.\n"
    },
    "comment": " "
  },
  "can-validate-validatejs.methods": {
    "name": "can-validate-validatejs.methods",
    "title": "Methods",
    "type": "group",
    "parent": "can-validate-validatejs",
    "description": "",
    "order": 1
  },
  "can-validate-validatejs": {
    "src": {
      "path": "node_modules/can-validate-validatejs/docs/can-validate-validatejs.md"
    },
    "body": "\n## Usage\n\nA validator can be created either for a single value or for many values.  More information on how to configure Validate.JS constraints can be found [here](https://validatejs.org/#validators).\n\n### Single value validation\n\nUsing the [Validate.js](https://validatejs.org/) library validators and configuration, call `makeValidator` and pass the desired constraints. The resulting function can then be used to validate specific values.\n\n```js\nvar makeValidator = require('can-validate-validatejs');\nvar validateAge = makeValidator({\n    numericality: true\n});\n\nvar age = 'hello';\nvalidateAge(age); //> ['is not a number']\n\nvar anotherAge = 35;\nvalidateAge(anotherAge); //> undefined\n```\n\n### Multiple value validation\n\nUsing the [can-validate-validatejs.many] works similar to `makeValidator`, except that `makeValidator.many` produces a validator that expects an object of values. The validator will run constraints on respective values based on the keys provided.\n\n```javascript\nvar makeValidator = require('can-validate-validatejs');\nvar validatePerson = makeValidator.many({\n    age: {\n        numericality: true\n    },\n    name: {\n        presence: true\n    }\n});\n\nvar invalidPerson = {\n    name: '',\n    age: 'hello'\n};\nvalidatePerson(invalidPerson); //> {name: ['is required'], age: ['is not a number']}\n\nvar validPerson = {\n    name: 'Juan',\n    age: 35\n};\nvalidatePerson(validPerson); //> undefined\n```\n\n",
    "description": "Create [can-validate.validator] functions using [validate.js](https://validatejs.org/). \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-validate-validatejs",
    "parent": "can-data-validation",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-validate-validatejs/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-util": "^3.9.0",
        "validate.js": "^0.11.1"
      },
      "deprecated": false,
      "description": "Create validator functions that use ValidateJS to validate values.",
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "detect-cyclic-packages": "^1.1.0",
        "http-server": "^0.10.0",
        "jshint": "^2.9.4",
        "steal": "^1.0.8",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-validate-validatejs#readme",
      "keywords": [
        "Validate",
        "Validate.js",
        "can-validate",
        "plugin",
        "canjs"
      ],
      "license": "MIT",
      "main": "can-validate-validatejs.js",
      "name": "can-validate-validatejs",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-validate-validatejs.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "http-server -c-1",
        "jshint": "jshint .",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:pre": "npm version prerelease && npm run build && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "ignoreBrowser": true,
        "npmIgnore": [
          "bit-docs",
          "testee",
          "steal-tools"
        ],
        "npmAlgorithm": "flat",
        "npmDependencies": [
          "steal-qunit"
        ],
        "paths": {
          "validate.js": "./node_modules/validate.js/validate.js"
        },
        "transpiler": "babel"
      },
      "version": "0.1.0"
    },
    "signatures": [
      {
        "code": "makeValidator(constraints)",
        "description": "\n\nReturns a validator function that can be used to validate a single value.\n\n  ```js\n  var validateAge = makeValidator({\n      numericality: true\n  });\n  ```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "constraints",
            "description": "An object of definitions used by the Validate.js library to run validations on a value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Validator"
            }
          ],
          "description": "A validator type function that takes a value and validates it against the provided constraints.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "constraints",
      "description": "An object of definitions used by the Validate.js library to run validations on a value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Validator"
        }
      ],
      "description": "A validator type function that takes a value and validates it against the provided constraints.\n"
    },
    "comment": " "
  },
  "can-view-live.attr": {
    "type": "function",
    "name": "can-view-live.attr",
    "parent": "can-view-live",
    "src": {
      "line": 3,
      "codeLine": 22,
      "path": "node_modules/can-view-live/lib/attr.js"
    },
    "body": "",
    "description": "\n",
    "title": "attr",
    "signatures": [
      {
        "code": "live.attr(el, attributeName, compute)",
        "description": "\n\nKeep an attribute live to a [can-compute].\n\n```js\nvar div = document.createElement('div');\nvar compute = canCompute(\"foo bar\");\nlive.attr(div,\"class\", compute);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "The element whos attribute will be kept live."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attributeName",
            "description": "The attribute name."
          },
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "The compute.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "compute",
      "description": "The compute.\n\n"
    }
  },
  "can-validate-validatejs.many": {
    "src": {
      "path": "node_modules/can-validate-validatejs/docs/validate-many.md"
    },
    "body": "\n## Example\n\n  ```js\n  var makeValidator = require('can-validate-validatejs');\n  var validatePerson = makeValidator.many({\n      age: {\n          numericality: true\n      },\n      name: {\n          presence: true\n      }\n  });\n\n  var invalidPerson = {\n      name: '',\n      age: 'hello'\n  };\n  validatePerson(invalidPerson); //> {name: ['is required'], age: ['is not a number']}\n\n  var validPerson = {\n      name: 'Juan',\n      age: 35\n  };\n  validatePerson(validPerson); //> undefined\n  ```\n\n",
    "description": "\n",
    "title": "many",
    "name": "can-validate-validatejs.many",
    "type": "function",
    "parent": "can-validate-validatejs.methods",
    "signatures": [
      {
        "code": "makeValidator.many(constraints)",
        "description": "\n\n  Returns a validator function that can be used to validate many values at once.\n\n  ```js\n  var validatePerson = makeValidator.many({\n      age: {\n          numericality: true\n      },\n      name: {\n          presence: true\n      }\n  });\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "constraints",
            "description": "A map of objects which contain definitions used by the Validate.js library.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Validator"
            }
          ],
          "description": "A [can-validate.validator] type function that takes an object of values and validates every value based on the provided constraints.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "constraints",
      "description": "A map of objects which contain definitions used by the Validate.js library.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Validator"
        }
      ],
      "description": "A [can-validate.validator] type function that takes an object of values and validates every value based on the provided constraints.\n\n"
    },
    "comment": " "
  },
  "can-view-live": {
    "name": "can-view-live",
    "type": "module",
    "parent": "can-views",
    "src": {
      "line": 12,
      "codeLine": 43,
      "path": "node_modules/can-view-live/lib/core.js"
    },
    "body": "\n\n\n## Use\n\n [can-view-live] is an object with utility methods for setting up\n live-binding in relation to different parts of the DOM and DOM elements.  For\n example, to make an `<h2>`'s text stay live with\n a compute:\n\n ```js\n var live = require(\"can-view-live\");\n var text = canCompute(\"Hello World\");\n var textNode = $(\"h2\").text(\" \")[0].childNodes[0];\n live.text(textNode, text);\n ```\n\n\n",
    "description": "\nSetup live-binding between the DOM and a compute manually.\n",
    "title": "can-view-live",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "An",
            "description": "object with the live-binding methods:\n[can-view-live.html], [can-view-live.list], [can-view-live.text], and\n[can-view-live.attr].\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-live/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-compute": "^3.3.1",
        "can-event": "^3.6.0",
        "can-observation": "^3.3.1",
        "can-reflect": "^1.2.1",
        "can-types": "^1.1.0",
        "can-util": "^3.9.6",
        "can-view-callbacks": "^3.2.0",
        "can-view-nodelist": "^3.1.0",
        "can-view-parser": "^3.4.0",
        "can-view-target": "^3.1.0"
      },
      "deprecated": false,
      "description": "[![Join the chat at https://gitter.im/canjs/canjs](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/canjs/canjs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) [![License: MIT](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/canjs/can-view-live/blob/master/LICENSE.md) [![npm version](https://badge.fury.io/js/can-view-live.svg)](https://www.npmjs.com/package/can-view-live) [![Travis build status](https://travis-ci.org/canjs/can-view-live.svg?branch=master)](https://travis-ci.org/canjs/can-view-live) [![Greenkeeper badge](https://badges.greenkeeper.io/canjs/can-view-live.svg)](https://greenkeeper.io/)",
      "devDependencies": {
        "can-list": "^3.2.0",
        "can-map": "^3.3.1",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "CanJS",
        "DoneJS"
      ],
      "main": "can-view-live",
      "name": "can-view-live",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-live.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint lib/**/*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-view-live",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.2.4"
    },
    "release": "2.0.4",
    "comment": " "
  },
  "can.view.live.replace": {
    "type": "function",
    "name": "can.view.live.replace",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "HTMLElement"
                  }
                ]
              }
            ]
          }
        ],
        "name": "nodes",
        "description": "An array of elements.  There should typically be one element."
      },
      {
        "types": [
          {
            "type": "String"
          },
          {
            "type": "HTMLElement"
          },
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "val",
        "description": "The content that should replace\n`nodes`.  If a string is passed, it will be [can.view.hookup hookedup].\n"
      },
      {
        "types": [
          {
            "type": "function",
            "returns": {
              "types": [
                {
                  "type": "undefined"
                }
              ]
            },
            "params": []
          }
        ],
        "optional": true,
        "name": "teardown",
        "description": "A callback if these elements are torn down.\n "
      }
    ],
    "parent": "can.view.live",
    "src": {
      "line": 130,
      "codeLine": 145,
      "path": "node_modules/can-view-live/lib/core.js"
    },
    "body": "\n",
    "description": "\nReplaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\ncorrect.\n",
    "title": "",
    "release": "2.0.4",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "teardown",
      "description": "A callback if these elements are torn down.\n "
    }
  },
  "can-view-live.html": {
    "type": "function",
    "name": "can-view-live.html",
    "parent": "can-view-live",
    "src": {
      "line": 7,
      "codeLine": 39,
      "path": "node_modules/can-view-live/lib/html.js"
    },
    "body": "\n",
    "description": "\nLive binds a compute's value to a collection of elements.\n",
    "title": "html",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.html(el, compute, [parentNode])",
        "description": "\n\n`live.html` is used to setup incremental live-binding on a block of html.\n\n```js\n// a compute that changes its list\nvar greeting = compute(function(){\n  return \"Welcome <i>\"+me.attr(\"name\")+\"</i>\"\n});\n\nvar placeholder = document.createTextNode(\" \");\n$(\"#greeting\").append(placeholder);\n\nlive.html(placeholder, greeting);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "An html element to replace with the live-section.\n"
          },
          {
            "types": [
              {
                "type": "can.compute"
              }
            ],
            "name": "compute",
            "description": "A [can.compute] whose value is HTML.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "optional": true,
            "name": "parentNode",
            "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "optional": true,
      "name": "parentNode",
      "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
    }
  },
  "can-view-live.list": {
    "type": "function",
    "name": "can-view-live.list",
    "parent": "can-view-live",
    "src": {
      "line": 84,
      "codeLine": 124,
      "path": "node_modules/can-view-live/lib/list.js"
    },
    "body": "",
    "description": "\n",
    "title": "list",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.list(el, list, render, context, [parentNode])",
        "description": "\n\nLive binds a compute's list incrementally.\n\n```js\n// a compute that change's it's list\nvar todos = compute(function(){\n  return new Todo.List({page: can.route.attr(\"page\")})\n})\n\nvar placeholder = document.createTextNode(\" \");\n$(\"ul#todos\").append(placeholder);\n\ncan.view.live.list(\n  placeholder,\n  todos,\n  function(todo, index){\n    return \"<li>\"+todo.attr(\"name\")+\"</li>\"\n  });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "An html element to replace with the live-section.\n"
          },
          {
            "types": [
              {
                "type": "can-compute"
              },
              {
                "type": "can-list"
              },
              {
                "type": "can-define/list/list"
              }
            ],
            "name": "list",
            "description": "An observable list type.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "String"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ],
                    "name": "index"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "render",
            "description": "A function that when called with\nthe incremental item to render and the index of the item in the list.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "The `this` the `render` function will be called with.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "optional": true,
            "name": "parentNode",
            "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "optional": true,
      "name": "parentNode",
      "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
    }
  },
  "can-view-live.text": {
    "type": "function",
    "name": "can-view-live.text",
    "parent": "can-view-live",
    "src": {
      "line": 4,
      "codeLine": 13,
      "path": "node_modules/can-view-live/lib/text.js"
    },
    "body": "",
    "description": "\n",
    "title": "text",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.text(el, compute, [parentNode], [nodeList])",
        "description": "\n\nReplaces one element with some content while keeping [can-view-live.nodeLists nodeLists] data correct.\n",
        "params": []
      }
    ]
  },
  "can-view-scope.static": {
    "name": "can-view-scope.static",
    "title": "static",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope.prototype": {
    "name": "can-view-scope.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope.types": {
    "name": "can-view-scope.types",
    "title": "types",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope": {
    "src": {
      "path": "node_modules/can-view-scope/docs/can-view-scope.md"
    },
    "body": "\n## Use\n\nA [can-view-scope] represents a lookup context and parent contexts\nthat can be used to lookup a [can-stache.key key] value.\n\nIf no parent scope is provided, only the scope's context will be\nexplored for values.  For example:\n\n    var data = {name: {first: \"Justin\"}},\n    \tscope = new Scope(data);\n\n    scope.get(\"name.first\") //-> \"Justin\"\n    scope.get(\"length\")     //-> undefined\n\nHowever, if a `parent` scope is provided, key values will be\nsearched in the parent's context after the initial context is explored.  For example:\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n    \tjustin = list[0];\n\n    var listScope = new Scope(list),\n    \tcurScope = new Scope(justin, listScope)\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\nUse [can-view-scope::add add] to easily create a new scope from a parent scope like:\n\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n    \tjustin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\n",
    "description": "Create a lookup node for [can-mustache.key keys]. \n\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-scope",
    "parent": "can-views",
    "collection": "can-infrastructure",
    "inherits": "can",
    "test": "can/view/scope/test.html",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-scope/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-cid": "^1.0.3",
        "can-compute": "^3.3.7",
        "can-construct": "^3.2.0",
        "can-define-lazy-value": "^1.0.0",
        "can-event": "^3.5.0",
        "can-log": "^0.1.0",
        "can-namespace": "1.0.0",
        "can-observation": "^3.3.1",
        "can-reflect": "^1.2.1",
        "can-simple-map": "^3.3.0",
        "can-stache-key": "^0.1.0",
        "can-symbol": "^1.0.0",
        "can-util": "^3.9.5"
      },
      "deprecated": false,
      "description": "Observable scopes",
      "devDependencies": {
        "can-define": "^1.3.3",
        "can-list": "^3.2.0",
        "can-map": "^3.3.1",
        "can-test-helpers": "^1.0.1",
        "detect-cyclic-packages": "^1.1.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-scope",
      "name": "can-view-scope",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-scope.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js test/*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.5.2"
    },
    "signatures": [
      {
        "code": "new Scope(context, [parent], [meta] )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "A value that represents the\ncurrent context. This is often an object or observable and is the first\nplace a `key` is looked up.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope"
              }
            ],
            "optional": true,
            "name": "parent",
            "description": "The parent scope. If a `key` value\nis not found in the current scope, it will then look in the parent\nscope.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope/Meta"
              }
            ],
            "optional": true,
            "name": "meta",
            "description": "A configuration object that\ncan specify special behavior of the context.\n"
          }
        ],
        "release": "2.0.1",
        "returns": {
          "types": [
            {
              "type": "can-view-scope"
            }
          ],
          "description": "Returns a scope instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope/Meta"
        }
      ],
      "optional": true,
      "name": "meta",
      "description": "A configuration object that\ncan specify special behavior of the context.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-view-scope"
        }
      ],
      "description": "Returns a scope instance.\n"
    },
    "comment": " "
  },
  "can-view-scope.attr": {
    "src": {
      "path": "node_modules/can-view-scope/docs/attr.md"
    },
    "body": "\n## Use\n\n`scope.attr(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.attr(\"name\"); //-> \"Justin\"\n    curScope.attr(\"length\"); //-> 2\n\nPrefixing a key with `\"./\"` prevents any parent scope look ups.\nPrefixing a key with one or more `\"../\"` shifts the lookup path\nthat many levels up.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}];\n    list.name = \"Programmers\";\n    list.surname = \"CanJS\";\n\n    var justin = list[0];\n    var brian = list[1];\n    var curScope = new Scope(list).add(justin).add(brian);\n\n    curScope.attr(\"name\"); //-> \"Brian\"\n    curScope.attr(\"surname\"); //-> \"CanJS\"\n    curScope.attr(\"./surname\"); //-> undefined\n    curScope.attr(\"../name\"); //-> \"Justin\"\n    curScope.attr(\"../surname\"); //-> \"CanJS\"\n    curScope.attr(\".././surname\"); //-> \"undefined\"\n    curScope.attr(\"../../name\"); //-> \"Programmers\"\n\n",
    "description": "\n",
    "title": "attr",
    "name": "can-view-scope.attr",
    "type": "function",
    "hide": true,
    "signatures": [
      {
        "code": "scope.attr(key)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-mustache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.compute": {
    "src": {
      "path": "node_modules/can-view-scope/docs/compute.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "compute",
    "name": "can-view-scope.compute",
    "type": "function",
    "hide": true,
    "signatures": [
      {
        "code": "scope.compute(key, [options])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope.readOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options that configure how the `key` gets read.\n"
          }
        ],
        "release": "2.1",
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute that can get or set `key`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope.readOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options that configure how the `key` gets read.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute that can get or set `key`.\n"
    }
  },
  "can-view-scope.computeData": {
    "src": {
      "path": "node_modules/can-view-scope/docs/compute_data.md"
    },
    "body": "\n## Use\n\n`scope.computeData(key, options)` is used heavily by [can-mustache] to get the value of\na [can-mustache.key key] value in a template. Configure how it reads values in the\nscope and what values it returns with the [can-view-scope.readOptions options] argument.\n\n    var context = new Map({\n      name: {first: \"Curtis\"}\n    })\n    var scope = new Scope(context)\n    var computeData = scope.computeData(\"name.first\");\n\n    computeData.scope === scope //-> true\n    computeData.initialValue    //-> \"Curtis\"\n    computeData.compute()       //-> \"Curtis\"\n\nThe `compute` value is writable.  For example:\n\n    computeData.compute(\"Andy\")\n    context.attr(\"name.first\") //-> \"Andy\"\n\n",
    "description": "\n",
    "title": "computeData",
    "name": "can-view-scope.computeData",
    "type": "function",
    "hide": true,
    "signatures": [
      {
        "code": "scope.computeData(key)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope.readOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options that configure how the `key` gets read.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": [
                {
                  "name": "compute",
                  "description": "A compute that returns the\nvalue of `key` looked up in the scope's context or parent context. This compute can\nalso be written to, which will set the observable attribute or compute value at the\nlocation represented by the key.\n",
                  "types": [
                    {
                      "type": "can-compute.computed"
                    }
                  ]
                },
                {
                  "name": "scope",
                  "description": "The scope the key was found within. The key might have\nbeen found in a parent scope.\n",
                  "types": [
                    {
                      "type": "can-view-scope"
                    }
                  ]
                },
                {
                  "name": "initialData",
                  "description": "The initial value at the key's location.\n",
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An object with the following values:\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope.readOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options that configure how the `key` gets read.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "compute",
              "description": "A compute that returns the\nvalue of `key` looked up in the scope's context or parent context. This compute can\nalso be written to, which will set the observable attribute or compute value at the\nlocation represented by the key.\n",
              "types": [
                {
                  "type": "can-compute.computed"
                }
              ]
            },
            {
              "name": "scope",
              "description": "The scope the key was found within. The key might have\nbeen found in a parent scope.\n",
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "name": "initialData",
              "description": "The initial value at the key's location.\n",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An object with the following values:\n"
    },
    "types": [],
    "comment": " "
  },
  "can-view-scope.prototype.add": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.add.md"
    },
    "body": "\n## Use\n\n`scope.add(context)` creates a new scope object that\nfirst looks up values in context and then in the\nparent `scope` object.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\n",
    "description": "\n",
    "title": "add",
    "name": "can-view-scope.prototype.add",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.add(context [,meta])",
        "description": "\n\nCreates a new scope and sets the current scope to be the parent.\n\n```js\nvar scope = new Scope([\n   {name:\"Chris\"},\n   {name: \"Justin\"}\n]).add({name: \"Brian\"});\nscope.get(\"name\") //-> \"Brian\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "The context to add on top of the current scope."
          },
          {
            "types": [
              {
                "type": "can-view-scope/Meta"
              }
            ],
            "name": "meta",
            "description": "A meta option that can be used to configure special behaviors of this context.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope/Meta"
        }
      ],
      "name": "meta",
      "description": "A meta option that can be used to configure special behaviors of this context.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.compute": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.compute.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "compute",
    "name": "can-view-scope.prototype.compute",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.compute(key [, options])",
        "description": "\n\nGet a compute that is two-way bound to the `key` value in the scope. These computes\ncan be optimized beyond wrapping a compute around a call to [can-view-scope::get].\n\n```js\nscope.compute(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.peek": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.peek.md"
    },
    "body": "\n\n## Use\n\n`scope.peek(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.peek(\"name\"); //-> \"Justin\"\n    curScope.peek(\"length\"); //-> 2\n\n",
    "description": "\nRead a value from the scope without being observable.\n",
    "title": "peek",
    "name": "can-view-scope.prototype.peek",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.peek(key [, options])",
        "description": "\n\nWorks just like [can-view-scope.prototype.get], but prevents any calls to [can-observation.add].\n\n\nWalks up the scope to find a value at `key`.  Stops at the first context where `key` has\na value.\n\n```js\nscope.peek(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.set": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.set.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "set",
    "name": "can-view-scope.prototype.set",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.set(key, value [, options])",
        "description": "\n\nTries to set `key` in the scope to `value`.  This looks for the first context in the value where\n`key` can be set.  For example, if `key` is `\"person.first.name\"`, it will find the first\ncontext where `person.first` is some type of Object whose `name` property can be set.\n\n```js\nscope.set(\"person.first.name\", \"Justin\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to be set.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value to be set.\n"
    },
    "comment": " "
  },
  "can-view-scope.Refs": {
    "src": {
      "path": "node_modules/can-view-scope/docs/static.Refs.md"
    },
    "body": "",
    "description": "\n",
    "title": "Refs",
    "name": "can-view-scope.Refs",
    "type": "function",
    "parent": "can-view-scope.static",
    "hide": true
  },
  "can-view-scope/Meta": {
    "src": {
      "path": "node_modules/can-view-scope/docs/types.Meta.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "Meta",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "notContext",
            "description": "The context should not be reference-able with `./` or `../`.\n",
            "types": [
              {
                "type": "Boolean"
              }
            ]
          }
        ],
        "description": "\n\n  Specify special behavior of a scope.\n\n"
      }
    ],
    "name": "can-view-scope/Meta",
    "parent": "can-view-scope.types"
  },
  "can-view-scope.prototype.get": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.get.md"
    },
    "body": "\n## Use\n\n`scope.get(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\"); //-> \"Justin\"\n    curScope.get(\"length\"); //-> 2\n\nPrefixing a key with `\"./\"` prevents any parent scope look ups.\nPrefixing a key with one or more `\"../\"` shifts the lookup path\nthat many levels up.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}];\n    list.name = \"Programmers\";\n    list.surname = \"CanJS\";\n\n    var justin = list[0];\n    var brian = list[1];\n    var curScope = new Scope(list).add(justin).add(brian);\n\n    curScope.get(\"name\"); //-> \"Brian\"\n    curScope.get(\"surname\"); //-> \"CanJS\"\n    curScope.get(\"./surname\"); //-> undefined\n    curScope.get(\"../name\"); //-> \"Justin\"\n    curScope.get(\"../surname\"); //-> \"CanJS\"\n    curScope.get(\".././surname\"); //-> \"undefined\"\n    curScope.get(\"../../name\"); //-> \"Programmers\"\n\n",
    "description": "\n",
    "title": "get",
    "name": "can-view-scope.prototype.get",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.get(key [, options])",
        "description": "\n\nWalks up the scope to find a value at `key`.  Stops at the first context where `key` has\na value.\n\n```js\nscope.get(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.Options": {
    "src": {
      "path": "node_modules/can-view-scope/docs/static.Options.md"
    },
    "body": "\nA Scope that can be used to lookup stache helpers.\n\n",
    "description": "\n",
    "title": "Options",
    "name": "can-view-scope.Options",
    "type": "function",
    "parent": "can-view-scope.static"
  },
  "can-view-nodelist/types/NodeList": {
    "src": {
      "path": "node_modules/can-view-nodelist/doc/NodeList.md"
    },
    "body": "\n",
    "description": "\nA collection of nodes being managed by a part of a live-bound template and\nreferences to other collections.\n",
    "type": "typedef",
    "title": "NodeList",
    "types": [
      {
        "type": "Array",
        "options": [],
        "description": "\n\n  A `NodeList` is an array of nodes that a part of a live-bound template manages.  For\n  example `{{name}}` might manage a single text node while something\n  like `{{#each todos}}{{name}}{{/each}}` might manage multiple nodes and other child.\n\n  NodeLists are primarily used to teardown live binding.  When a \"parent\" section of a template\n  is updated, every sub-section needs to be torn down.  NodeLists provide this structure.\n\n  __NOTE: The structure of a NodeList is purposefully not documented as it's subject to change.__\n"
      }
    ],
    "name": "can-view-nodelist/types/NodeList",
    "parent": "can-view-nodelist/types"
  },
  "can-view-parser.ParseHandler.attrEnd": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrEnd.md"
    },
    "body": "",
    "description": "",
    "title": "attrEnd",
    "name": "can-view-parser.ParseHandler.attrEnd",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "attrEnd(attrName, lineNo)",
        "description": "\n\nCalled at the end of parsing an attribute; after the [can-view-parser.ParserHandler.attrStart] and [can-view-parser.ParserHandler.attrValue] functions have been called.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "The name of the attribute."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "lineNo",
            "description": "The line number of the opening tag (undefined in production).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "lineNo",
      "description": "The line number of the opening tag (undefined in production).\n"
    }
  },
  "can-view-parser.ParseHandler.attrStart": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrStart.md"
    },
    "body": "",
    "description": "",
    "title": "attrStart",
    "name": "can-view-parser.ParseHandler.attrStart",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "attrStart(attrName, lineNo)",
        "description": "\n\nCalled when an attribute is found on an element.\n\nHandles encoding of certain characthers using [can-attribute-encoder].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "The name of the attribute."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "lineNo",
            "description": "The line number of the opening tag (undefined in production).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "lineNo",
      "description": "The line number of the opening tag (undefined in production).\n"
    }
  },
  "can-view-parser": {
    "src": {
      "path": "node_modules/can-view-parser/docs/can-view-parser.md"
    },
    "body": "",
    "description": "Parse HTML and mustache tokens. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-parser",
    "parent": "can-views",
    "collection": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-parser/issues"
      },
      "bundleDependencies": false,
      "dependencies": {
        "can-attribute-encoder": "^0.3.1",
        "can-log": "^0.1.0",
        "can-namespace": "1.0.0"
      },
      "deprecated": false,
      "description": "Parses html and magic tags",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-test-helpers": "^1.0.1",
        "detect-cyclic-packages": "^1.1.0",
        "done-serve": "^1.2.0",
        "donejs-cli": "^1.0.1",
        "generator-donejs": "^1.0.5",
        "jshint": "^2.9.1",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.7.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-parser",
      "name": "can-view-parser",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-parser.git"
      },
      "scripts": {
        "build": "node build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag=pre",
        "test": "npm run detect-cycle && npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.6.2"
    },
    "signatures": [
      {
        "code": "parse(html, handler, [returnIntermediate])",
        "description": "\n\nParse an html string:\n\n```js\nvar parser = require(\"can-view-parser\");\n\nvar html = '<h1><span bob=\"phillips\"></span><span bob=\"meyers\"></span>' +\n\t'</h1>';\n\nvar bobs = {};\nvar curAttr;\n\nparser(html, {\n\tattrStart: function(attrName){\n\t\tcurAttr = attrName;\n\t},\n\tattrValue: function(value){\n\t\tbobs[curAttr] = value;\n\t}\n});\n\nfor(var first in bobs) {\n\tvar last = bobs[first];\n\tconsole.log(\"Hello\", first, last);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "html",
            "description": "A mustache and html string to parse or an intermediate object the represents a previous parsing."
          },
          {
            "types": [
              {
                "type": "can-view-parser.ParseHandler"
              }
            ],
            "name": "handler",
            "description": "An object of callbacks."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "returnIntermediate",
            "defaultValue": "false",
            "description": "If true, returns a JS object representation of the parsing.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "returnIntermediate",
      "defaultValue": "false",
      "description": "If true, returns a JS object representation of the parsing.\n"
    }
  },
  "can-view-parser.ParseHandler.attrValue": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrValue.md"
    },
    "body": "",
    "description": "",
    "title": "attrValue",
    "name": "can-view-parser.ParseHandler.attrValue",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "attrValue(value, lineNo)",
        "description": "\n\nCalled when an attribute's **value** has been found.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The value discovered associated with an attribute."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "lineNo",
            "description": "The line number of the opening tag (undefined in production).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "lineNo",
      "description": "The line number of the opening tag (undefined in production).\n"
    }
  },
  "can-view-parser.ParseHandler.chars": {
    "src": {
      "path": "node_modules/can-view-parser/docs/chars.md"
    },
    "body": "",
    "description": "",
    "title": "chars",
    "name": "can-view-parser.ParseHandler.chars",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "chars(value, lineNo)",
        "description": "\n\nCalled when [CharacterData](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData) is found within a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The character data within the tag."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "lineNo",
            "description": "The starting line number of the text (undefined in production).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "lineNo",
      "description": "The starting line number of the text (undefined in production).\n"
    }
  },
  "can-view-parser.ParseHandler.close": {
    "src": {
      "path": "node_modules/can-view-parser/docs/close.md"
    },
    "body": "",
    "description": "",
    "title": "close",
    "name": "can-view-parser.ParseHandler.close",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "close(tagName, lineNo)",
        "description": "\n\nCalled when a closing tag is found. If no closing tag exists for this tag (because it is self-closing) this function will not be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "lineNo",
            "description": "The line number of the tag (undefined in production).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "lineNo",
      "description": "The line number of the tag (undefined in production).\n"
    }
  },
  "can-view-parser.ParseHandler.comment": {
    "src": {
      "path": "node_modules/can-view-parser/docs/comment.md"
    },
    "body": "",
    "description": "",
    "title": "comment",
    "name": "can-view-parser.ParseHandler.comment",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "comment(value, lineNo)",
        "description": "\n\nCalled when a [Comment](https://developer.mozilla.org/en-US/docs/Web/API/Comment) is found within a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The Comment within the tag."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "lineNo",
            "description": "The starting line number of the comment (undefined in production).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "lineNo",
      "description": "The starting line number of the comment (undefined in production).\n"
    }
  },
  "can-view-parser.ParseHandler.done": {
    "src": {
      "path": "node_modules/can-view-parser/docs/done.md"
    },
    "body": "",
    "description": "",
    "title": "done",
    "name": "can-view-parser.ParseHandler.done",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "done(lines)",
        "description": "\n\nCalled at the end of parsing the template.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "lines",
            "description": "The number of lines in the template (undefined in production).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "lines",
      "description": "The number of lines in the template (undefined in production).\n"
    }
  },
  "can-view-parser.ParseHandler.end": {
    "src": {
      "path": "node_modules/can-view-parser/docs/end.md"
    },
    "body": "",
    "description": "",
    "title": "end",
    "name": "can-view-parser.ParseHandler.end",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "end(tagName, unary, lineNo)",
        "description": "\n\nCalled at the end of parsing a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "unary",
            "description": "If this tag is unary (has no closing tag)."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "lineNo",
            "description": "The starting line number of the tag (undefined in production).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "lineNo",
      "description": "The starting line number of the tag (undefined in production).\n"
    }
  },
  "can-view-parser.ParseHandler.magicMatch": {
    "src": {
      "path": "node_modules/can-view-parser/docs/magicMatch.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "RegExp",
        "description": "\n\nA regular expression that matches from the start of the magic tag to the end of the\nmagic tag.  It should also have the first capture group match the content within the\nmagic tag.  \n\n```js\nparser(\" ... content ....\", {\n\t...\n\tmagicStart: \"{\",\n\tmagicMatch:  /\\{([^\\}]*)\\}/g\n});\n```\n"
      }
    ],
    "title": "magicMatch",
    "name": "can-view-parser.ParseHandler.magicMatch",
    "type": "property",
    "parent": "can-view-parser.ParseHandler"
  },
  "can-view-parser.ParseHandler": {
    "src": {
      "path": "node_modules/can-view-parser/docs/parse-handler.md"
    },
    "body": "",
    "description": "An object consisting of callback functions that handle stages in the parsing process and settings that configure the parsing process.\n\n",
    "type": "typedef",
    "title": "ParseHandler",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-parser.ParseHandler",
    "parent": "can-view-parser"
  },
  "can-view-parser.ParseHandler.magicStart": {
    "src": {
      "path": "node_modules/can-view-parser/docs/magicStart.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "String",
        "description": "\n\nThe starting characters of a magic tag.\n\n```js\nparser(\" ... content ....\", {\n\t...\n\tmagicStart: \"{\",\n\tmagicMatch:  /\\{([^\\}]*)\\}/g\n});\n```\n"
      }
    ],
    "title": "magicStart",
    "name": "can-view-parser.ParseHandler.magicStart",
    "type": "property",
    "parent": "can-view-parser.ParseHandler"
  },
  "can-view-parser.ParseHandler.start": {
    "src": {
      "path": "node_modules/can-view-parser/docs/start.md"
    },
    "body": "",
    "description": "",
    "title": "start",
    "name": "can-view-parser.ParseHandler.start",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "start(tagName, unary, lineNo)",
        "description": "\n\nCalled when parsing a tag begins.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "unary",
            "description": "If this tag is unary (has no closing tag)."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "lineNo",
            "description": "The starting line number of the tag (undefined in production).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "lineNo",
      "description": "The starting line number of the tag (undefined in production).\n"
    }
  },
  "can-zone.ZoneSpec": {
    "src": {
      "path": "node_modules/can-zone/docs/ZoneSpec.md"
    },
    "body": "",
    "description": " A ZoneSpec is the way you tap into the lifecycle hooks of a [can-zone Zone]. The hooks are described below.\n\nUsing these hooks you can do things like create timers and override global variables that will change the *shape* of code that runs within the Zone.\n\n",
    "type": "typedef",
    "title": "ZoneSpec",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "created",
            "description": "\n\nCalled when the zone is first created, after all ZoneSpecs have been parsed. this is useful if you need to do setup behavior that covers the entire zone lifecycle.\n\n```js\nnew Zone({\n\tcreated: function(){\n\t\t// Called as soon as `new Zone` is called\n\t}\n});\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "beforeRun",
            "description": "\n\nCalled immediately before the [can-zone.prototype.run] function is called.\n\n```js\nvar zone = new Zone({\n\tbeforeRun: function(){\n\t\t// Setup that needs to happen immediately before running\n\t\t// the zone function\n\t}\n});\n\nzone.run(function() { ... });\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "afterRun",
            "description": "\n\nCalled immediately after the [can-zone.prototype.run] function is called. This hook is useful for any cleanup that might need to be done after the run function is called, but before the zone's promise is resolved. You might use this if the promise is not waited on before performing some action.\n\n```js\nrequire(\"http\").createServer(function(req, res){\n\tvar zone = new Zone(function(data){\n\t\tvar document = new SomeDocument();\n\n\t\treturn {\n\t\t\t...\n\t\t\tafterRun: function(){\n\t\t\t\tdata.html = document.documentElement.outerHTML;\n\t\t\t}\n\t\t};\n\t});\n\n\tzone.run(render); // We don't want to wait for all async stuff.\n\n\tres.write(zone.data.html);\n\tres.end();\n}).listen(8080);\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "beforeTask",
            "description": "\n\nCalled before each Task is called. Use this to override any globals you want to exist during the execution of the task:\n\n```js\nnew Zone({\n\tbeforeTask: function(){\n\t\twindow.setTimeout = mySpecialSetTimeout;\n\t}\n});\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "ended",
            "description": "\n\nCalled when the Zone has ended and is about to exit (it's Promise will resolve).\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "hooks",
            "description": "\n\n**hooks** allows you to specify custom hooks that your plugin calls. This is mostly to communicate between plugins that inherit each other.\n\n```js\nvar barZone = {\n\tcreated: function(){\n\t\tthis.execHook(\"beforeBar\");\n\t},\n\n\thooks: [\"beforeBar\"]\n};\n\nvar fooZone = {\n\tbeforeBar: function(){\n\t\t// Called!\n\t},\n\tplugins: [barZone]\n};\n\nnew Zone({\n\tplugins: [fooZone]\n});\n\nzone.run(function() { ... });\n```\n",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "string"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "name": "plugins",
            "description": "\n\nAllows specifying nested [can-zone.ZoneSpec ZoneSpecs] that the current depends on. This allows creating rich plugins that depend on other plugins (ZoneSpecs). You can imagine having a bunch of tiny plugins that do one thing and then composing them together into one meta-plugin that is more end-user friendly.\n\nSimilar to the [can-zone Zone] constructor you can either specify [can-zone.ZoneSpec] objects or functions that return ZoneSpec objects. The former gives you a closure specific to the Zone, which is often needed for variables. These two forms are equivalent:\n\n```js\nvar specOne = {\n\tcreated: function(){\n\n\t}\n};\n\nvar specTwo = function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t}\n};\n\nvar zone = new Zone({\n\tplugins: [ specOne, specTwo ]\n});\n```\n",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-zone.ZoneSpec"
                      },
                      {
                        "type": "can-zone.makeZoneSpec"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone.ZoneSpec",
    "parent": "can-zone.types"
  },
  "can-zone.prototype.addWait": {
    "src": {
      "path": "node_modules/can-zone/docs/addWait.md"
    },
    "body": "",
    "description": "\n",
    "title": "addWait",
    "name": "can-zone.prototype.addWait",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.addWait()",
        "description": "\n\nAdds a wait to the [can-zone Zone]. Adding a wait will delay the Zone's Promise from resolving (the promise created by calling [can-zone.prototype.run zone.run]) by incrementing its internal counter.\n\nUsually a corresponding [can-zone.prototype.removeWait] will be called to decrement the counter.\n\n```js\nnew Zone().run(function(){\n\n\tvar zone = Zone.current;\n\n\tzone.addWait(); // counter at 1\n\tzone.removeWait(); // counter at 0, Promise resolves\n\n}).then(function(){\n\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.static": {
    "name": "can-zone.static",
    "title": "static",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.prototype": {
    "name": "can-zone.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.types": {
    "name": "can-zone.types",
    "title": "types",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.modules": {
    "name": "can-zone.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.plugins": {
    "name": "can-zone.plugins",
    "title": "plugins",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone": {
    "src": {
      "path": "node_modules/can-zone/docs/can-zone.md"
    },
    "body": "\n## Tasks\n\nJavaScript uses various task queues (and a microtask queue) to run JavaScript in the event loop. See [this article](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/) and [this StackOverflow answer](http://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context) to learn more.\n\nFor can-zone to work we have to override various task-creating functionality, this is the list of what we currently implement:\n\n**Macrotasks**\n\n* setTimeout\n* XMLHttpRequest\n\n**Microtasks**\n\n* requestAnimationFrame\n* Promise\n* process.nextTick\n\n## Use\n\n**can-zone** is a library that aids in tracking asynchronous calls in your application. To create a new Zone call it's constructor function with `new`:\n\n```js\nvar zone = new Zone();\n```\n\nThis gives you a [can-zone Zone] from which you can run code using [can-zone.prototype.run zone.run]:\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\n\tsetTimeout(function(){\n\t\t\n\t}, 29);\n\n\tsetTimeout(function(){\n\t\t\n\t}, 13);\n\n\tvar xhr = new XMLHttpRequest();\n\txhr.open(\"GET\", \"http://chat.donejs.com/api/messages\");\n\txhr.onload = function(){\n\t\t\n\t};\n\txhr.send();\n\n}).then(function(){\n\t// All done!\n});\n```\n\nThe function you provide to [can-zone.prototype.run] will be run within the Zone. This means any calls to asynchronous functions (in this example `setTimeout`)\twill be waited on.\n\n## Tasks\n\nJavaScript uses various task queues (and a microtask queue) to run JavaScript in the event loop. See [this article](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/) and [this StackOverflow answer](http://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context) to learn more.\n\nFor can-zone to work we have to override various task-creating functionality, this is the list of what we currently implement:\n\n**Macrotasks**\n\n* setTimeout\n* XMLHttpRequest\n\n**Microtasks**\n\n* requestAnimationFrame\n* Promise\n* process.nextTick\n\n",
    "description": "A library that tracks asynchronous activity and lets you know when it has completed. Useful when you need to call a function and wait for all async behavior to complete, such as when performing server-side rendering. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone",
    "parent": "can-js-utilities",
    "collection": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-view-live"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-zone/issues"
      },
      "bundleDependencies": false,
      "deprecated": false,
      "description": "Asynchronous render for all frameworks",
      "devDependencies": {
        "bit-docs": "0.0.8-0",
        "chai": "^4.0.1",
        "detect-cyclic-packages": "^1.1.0",
        "mocha": "^4.0.0",
        "steal": "^1.2.10",
        "steal-mocha": "^1.0.0",
        "steal-tools": "^1.5.0",
        "testee": "^0.7.0"
      },
      "homepage": "https://github.com/canjs/can-zone#readme",
      "keywords": [
        "server-side",
        "rendering",
        "canjs",
        "asynchronous",
        "rendering"
      ],
      "license": "MIT",
      "main": "lib/zone.js",
      "name": "can-zone",
      "repository": {
        "type": "git",
        "url": "git+ssh://git@github.com/canjs/can-zone.git"
      },
      "scripts": {
        "build": "node scripts/build.js",
        "detect-cycle": "detect-cyclic-packages --ignore done-serve",
        "document": "bit-docs",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run detect-cycle && npm run test:node && npm run test:browser && npm run test:xss",
        "test:browser": "testee test/test.html test/register.html --browsers firefox --reporter Spec",
        "test:node": "mocha test/test.js && mocha test/test_register_node.js",
        "test:win": "testee test/test.html --browsers firefox --reporter Spec",
        "test:xss": "mocha test/xss/test.js",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "npmDependencies": [
          "steal-mocha",
          "mocha",
          "chai"
        ],
        "map": {
          "./assert": "chai/chai"
        },
        "meta": {
          "chai/chai": {
            "format": "global",
            "exports": "chai.assert"
          }
        },
        "plugins": [
          "chai"
        ]
      },
      "version": "0.6.13"
    },
    "signatures": [
      {
        "code": "new Zone()",
        "description": "\n\nCreates a new Zone with no additional overrides. Can then call [can-zone.prototype.run zone.run] to call a function within the Zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar zone = new Zone();\n\nzone.run(function(){\n\n\treturn \"hello world\";\n\n}).then(function(data){\n\tdata.result // -> \"hello world\"\n});\n```\n\n*Note: See the [can-zone/register docs](https://github.com/canjs/can-zone/blob/master/docs/register.md) about ensuring can-zone is registered properly.*\n",
        "params": []
      },
      {
        "code": "new Zone(zoneSpec)",
        "description": "\n\nCreate a new Zone using the provided [can-zone.ZoneSpec] to configure the Zone. The following examples configures a Zone that will time out after 5 seconds.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar timeoutSpec = function(){\n\tvar timeoutId;\n\n\treturn {\n\t\tcreated: function(){\n\t\t\ttimeoutId = setTimeout(function(){\n\t\t\t\tZone.error(new Error(\"This took too long!\"));\n\t\t\t}, 5000);\n\t\t},\n\t\tended: function(){\n\t\t\tclearTimeout(timeoutId);\n\t\t}\n\t};\n};\n\nvar zone = new Zone(timeoutSpec);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-zone.ZoneSpec"
              },
              {
                "type": "can-zone.makeZoneSpec"
              }
            ],
            "name": "zoneSpec",
            "description": "A [can-zone.ZoneSpec] object or a [can-zone.makeZoneSpec function that returns] a ZoneSpec object.\n\nThese two are equivalent:\n\n```js\nnew Zone({\n\tcreated: function(){\n\n\t}\n});\n\nnew Zone(function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t};\n});\n```\n\nThe latter form is useful so that you have a closure specific to that [can-zone Zone].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        },
        {
          "type": "can-zone.makeZoneSpec"
        }
      ],
      "name": "zoneSpec",
      "description": "A [can-zone.ZoneSpec] object or a [can-zone.makeZoneSpec function that returns] a ZoneSpec object.\n\nThese two are equivalent:\n\n```js\nnew Zone({\n\tcreated: function(){\n\n\t}\n});\n\nnew Zone(function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t};\n});\n```\n\nThe latter form is useful so that you have a closure specific to that [can-zone Zone].\n"
    },
    "comment": " "
  },
  "can-zone.current": {
    "src": {
      "path": "node_modules/can-zone/docs/current.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "can-zone"
      }
    ],
    "title": "current",
    "name": "can-zone.current",
    "type": "property",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.current",
        "description": "\n\nRepresents the currently running [can-zone zone]. If the code using **Zone.current** is not running within a zone the value will be undefined.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar myZone = new Zone();\n\nmyZone.run(function(){\n\n\tZone.current === myZone;\n\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.prototype.data": {
    "src": {
      "path": "node_modules/can-zone/docs/data.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "data",
    "name": "can-zone.prototype.data",
    "type": "property",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.data",
        "description": "\n\nYou might want to get data back from can-zone, for example if you are using the library to track asynchronous rendering requests. Each zone contains a **data** object which can be used to store artibitrary values.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"http://example.com\");\nxhr.onload = function(){\n\t// Save this data for later\n\tZone.current.data.xhr = xhr.responseText;\n};\nxhr.send();\n```\n\n",
        "params": []
      }
    ]
  },
  "can-zone.error": {
    "src": {
      "path": "node_modules/can-zone/docs/error.md"
    },
    "body": "",
    "description": "\n",
    "title": "error",
    "name": "can-zone.error",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.error(err)",
        "description": "\n\nAllows you to add an error to the currently running zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\n\tsetTimeout(function(){\n\t\tZone.error(new Error(\"oh no\"));\n\t}, 100);\n\n}).then(null, function(error){\n\terror; // -> {message: \"oh no\"}\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Error"
              }
            ],
            "name": "err",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Error"
        }
      ],
      "name": "err",
      "description": "\n"
    }
  },
  "can-zone.ignore": {
    "src": {
      "path": "node_modules/can-zone/docs/ignore.md"
    },
    "body": "\n## Use\n\n**Zone.ignore** is used to prevent a function from being waited on within a Zone. Normally a Zone's calls to functions like `setTimeout` and `XMLHttpRequest` are waited on before the [can-zone.prototype.run run promise] is resolved, but in some cases you might not want to wait on these calls; for example if there is a very long delay or a delay that will not result in rendering to take place.\n\nProvide Zone.ignore a function and it will return a function that can be called in it's place.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar fn = Zone.ignore(function(){\n\t// do any asynchronous stuff here\n});\n\nfn(); // waits ignored\n```\n\n",
    "description": "\n",
    "title": "ignore",
    "name": "can-zone.ignore",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.ignore(fn)",
        "description": "\n\nCreates a function that, when called, will not track any calls. This might be needed if you are calling code that does unusual things, like using setTimeout recursively indefinitely.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\tfunction recursive(){\n\t\tsetTimeout(function(){\n\t\t\trecursive();\n\t\t}, 20000);\n\t}\n\n\tvar fn = Zone.ignore(recursive);\n\n\t// This call will not be waited on.\n\tfn();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "A function that contains calls to asynchronous functions that are needing to be ignored.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function in which calls to [can-zone.prototype.addWait] and [can-zone.prototype.removeWait] will be ignored, preventing the Zone's promise from remaining unresolved while asynchronous activity continues within.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "A function that contains calls to asynchronous functions that are needing to be ignored.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function in which calls to [can-zone.prototype.addWait] and [can-zone.prototype.removeWait] will be ignored, preventing the Zone's promise from remaining unresolved while asynchronous activity continues within.\n"
    },
    "comment": " "
  },
  "can-zone.makeZoneSpec": {
    "src": {
      "path": "node_modules/can-zone/docs/makeZoneSpec.md"
    },
    "body": "\nUsing a function rather than a ZoneSpec object gives you a closure where you can store local variables that will be specific to the [can-zone Zone] you are running in.\n\n",
    "description": "\nA function that returns a [can-zone.ZoneSpec] object. This can be used any place where a [can-zone.ZoneSpec] is accepted.\n",
    "type": "typedef",
    "title": "makeZoneSpec",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "can-zone.ZoneSpec"
            }
          ],
          "description": "A [can-zone.ZoneSpec]\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-zone.prototype.data"
              }
            ],
            "name": "data",
            "description": "The [can-zone Zone's] data object, useful when you want to append data to the Zone.\n\nThis examples wraps [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to keep count of how many elements are created, and appends the count to [can-zone.prototype.data] when the Zone ends.\n\n```js\nvar mySpec = function(data){\n\tvar realCreateElement,\n\t\tcount = 0;\n\n\treturn {\n\t\tbeforeTask: function(){\n\t\t\trealCreateElement = document.createElement;\n\t\t\tdocument.createElement = function(){\n\t\t\t\tcount++;\n\t\t\t\treturn realCreateElement.apply(this, arguments);\n\t\t\t};\n\t\t},\n\t\tafterTask: function(){\n\t\t\tdocument.createElement = realCreateElement;\n\t\t},\n\t\tended: function(){\n\t\t\tdata.elementsCreated = count;\n\t\t}\n\t};\n};\n\nvar zone = new Zone(mySpec);\n\nzone.run(function(){\n\t// Do stuff here\n})\n.then(function(data){\n\tdata.elementsCreated; // -> 5\n});\n```\n"
          }
        ]
      }
    ],
    "name": "can-zone.makeZoneSpec",
    "parent": "can-zone.types",
    "_curParam": {
      "types": [
        {
          "type": "can-zone.prototype.data"
        }
      ],
      "name": "data",
      "description": "The [can-zone Zone's] data object, useful when you want to append data to the Zone.\n\nThis examples wraps [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to keep count of how many elements are created, and appends the count to [can-zone.prototype.data] when the Zone ends.\n\n```js\nvar mySpec = function(data){\n\tvar realCreateElement,\n\t\tcount = 0;\n\n\treturn {\n\t\tbeforeTask: function(){\n\t\t\trealCreateElement = document.createElement;\n\t\t\tdocument.createElement = function(){\n\t\t\t\tcount++;\n\t\t\t\treturn realCreateElement.apply(this, arguments);\n\t\t\t};\n\t\t},\n\t\tafterTask: function(){\n\t\t\tdocument.createElement = realCreateElement;\n\t\t},\n\t\tended: function(){\n\t\t\tdata.elementsCreated = count;\n\t\t}\n\t};\n};\n\nvar zone = new Zone(mySpec);\n\nzone.run(function(){\n\t// Do stuff here\n})\n.then(function(data){\n\tdata.elementsCreated; // -> 5\n});\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        }
      ],
      "description": "A [can-zone.ZoneSpec]\n"
    }
  },
  "can-zone/register": {
    "src": {
      "path": "node_modules/can-zone/docs/register.md"
    },
    "body": "",
    "description": " \nIn order to do it's magic, [can-zone] has to register handlers for all of the common JavaScript async operations. If you have code (or a dependency with this code) that does:\n\n```js\nvar st = setTimeout;\n```\n\nAnd this module loads before can-zone, any time `st` is used we won't be able to track that within the Zone.\n\nTo work around this, **can-zone/register** is used as a script that you run before any other modules.\n\n### In Node\n\n```js\nrequire(\"can-zone/register\");\n```\n\nAt the top of your entry-point script.\n\n### In the Browser\n\nYou can either add a script tag above all others:\n\n```js\n<script src=\"node_modules/can-zone/register.js\"></script>\n```\n\nOr, if you're using a module loader / bundler, configure it so that can-zone/register is placed above all others in the bundle.\n\n",
    "type": "module",
    "title": "can-zone/register",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone/register",
    "parent": "can-zone.modules"
  },
  "can-zone.prototype.removeWait": {
    "src": {
      "path": "node_modules/can-zone/docs/removeWait.md"
    },
    "body": "",
    "description": "\n",
    "title": "removeWait",
    "name": "can-zone.prototype.removeWait",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.removeWait()",
        "description": "\n\nDecrements the [can-zone Zone's] internal counter that is used to decide when its [can-zone.prototype.run run Promise] will resolve.\n\nUsually used in conjuction with [can-zone.prototype.addWait]. Most of the time you'll want to use [can-zone.waitFor], but in some cases where a callback is not enough to know waiting is complete, using addWait/removeWait gives you finer grained control.\n\n```js\nvar zone = new Zone();\n\nvar obj = new SomeObject();\n\n// This is only done when the event.status is 3\nobj.onprogress = function(ev){\n\tif(ev.status === 3) {\n\t\tzone.removeWait();\n\t}\n};\n\nzone.addWait();\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.waitFor": {
    "src": {
      "path": "node_modules/can-zone/docs/waitFor.md"
    },
    "body": "",
    "description": "\n",
    "title": "waitFor",
    "name": "can-zone.waitFor",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.waitFor(fn)",
        "description": "\n\n**Zone.waitFor** is a function that creates a callback that can be used with any async functionality. Calling Zone.waitFor registers a wait with the currently running request and returns a function that, when called, will decrement the wait count.\n\nThis is useful if there is async functionality other than what [we implement](#tasks). You might be using a library that has C++ bindings and doesn't go through the normal JavaScript async APIs.\n\n```js\nvar Zone = require(\"can-zone\");\nvar fs = require(\"fs\");\n\nfs.readFile(\"data.json\", \"utf8\", Zone.waitFor(function(){\n\t// We waited on this!\n}));\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "\n"
    }
  },
  "can-zone.prototype.run": {
    "src": {
      "path": "node_modules/can-zone/docs/run.md"
    },
    "body": "",
    "description": "\n",
    "title": "run",
    "name": "can-zone.prototype.run",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.run(fn)",
        "description": "\n\nRuns a function within a [can-zone Zone]. Calling run will set the Zone's internal Promise which will only resolve once all asynchronous calls within `fn` are complete.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "Any function which needs to run within the Zone. The function will be executed immediately.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-zone.prototype.data"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that will resolve with the Zone's [can-zone.prototype.data] object.\n\n```js\nvar zone = new Zone();\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\t\tzone.data.foo = \"bar\";\n\t});\n\n}).then(function(data){\n\tdata.foo // -> \"bar\"\n});\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "Any function which needs to run within the Zone. The function will be executed immediately.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-zone.prototype.data"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that will resolve with the Zone's [can-zone.prototype.data] object.\n\n```js\nvar zone = new Zone();\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\t\tzone.data.foo = \"bar\";\n\t});\n\n}).then(function(data){\n\tdata.foo // -> \"bar\"\n});\n```\n"
    }
  },
  "can-zone-storage.methods": {
    "name": "can-zone-storage.methods",
    "title": "methods",
    "type": "group",
    "parent": "can-zone-storage",
    "description": "",
    "order": 0
  },
  "can-zone-storage.properties": {
    "name": "can-zone-storage.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-zone-storage",
    "description": "",
    "order": 1
  },
  "can-zone-storage": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.md"
    },
    "body": "\n## Use\n\n`can-zone-storage` provides a Zone-safe method of storing data for a user.\n\nIt implements three of the methods from the WebStorage Interface:\n - [can-zone-storage.setItem setItem] stores keyed data.\n - [can-zone-storage.getItem getItem] retrieves keyed data.\n - [can-zone-storage.removeItem removeItem] deletes keyed data.\n\nOne additional method, [can-zone-storage.getStore getStore], allows you to retrieve the current data store and inspect it directly.\n\n## Zone Safe\n\nDone-SSR, the Server Side Rendering solution built into DoneJS, uses Zones to increase performance.  Other web servers will completely rebuild the app for every incoming request.  Done-SSR uses Zones to keep the app running in memory and share it between all incoming connections.  \n\nSharing modules between connections is often fine, but some data should not be shared.  Private data belonging to one user should not reach another user on the same server.  Can-Zone provides each incoming request with a `CanZone.current` object that is not shared.  The `can-zone-storage` module detects if CanZone is in the global namespace.  If it *is* found, it uses the `CanZone.current.data` object as the data store.  If `CanZone` is not found, an internal memory store is used.\n",
    "description": "Implement Zone-safe memory-based storage \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-zone-storage",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.4"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "parent": "can-zone-storage",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-zone-storage/issues"
      },
      "bundleDependencies": false,
      "deprecated": false,
      "description": "Implement Zone-safe memory-based storage",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "bit-docs-generate-readme": "0.0.10",
        "can-zone": "^0.6.1",
        "semistandard": "^9.2.1",
        "steal": "^1.0.6",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.3.0"
      },
      "homepage": "https://github.com/canjs/can-zone-storage",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "can-zone-storage.js",
      "name": "can-zone-storage",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-zone-storage.git"
      },
      "scripts": {
        "build": "node build.js",
        "lint": "semistandard --fix",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run lint && npm run testee",
        "testee": "testee test/zone-test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-zone-storage"
      },
      "version": "1.0.0"
    },
    "signatures": [
      {
        "code": "define(prototype, propDefinitions)",
        "description": "\n\nImplement a Zone-safe memory-based storage solution.  This is especially useful for Server Side Rendering (SSR).\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\n\nvar value = 'Store me';\n\nzoneStorage.setItem('key-name', value);\n\nzoneStorage.getItem('key-name') === 'Store me' // --> true\n\nzoneStorage.removeItem('key-name');\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-zone-storage.getItem": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.methods.getItem.md"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "name": "can-zone-storage.getItem",
    "type": "function",
    "parent": "can-zone-storage.methods",
    "signatures": [
      {
        "code": "getItem(key)",
        "description": "\n\nStores keyed data in the current data store.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\n\nvar test = zoneStorage.getItem('key-name') // test === undefined\n\nvar value = 'Store me';\n\nzoneStorage.setItem('key-name', value);\nzoneStorage.getItem('key-name') // test === 'Store me'\n\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key name from which the data will be retrieved."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key name from which the data will be retrieved."
    }
  },
  "can-zone-storage.getStore": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.methods.getStore.md"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "name": "can-zone-storage.getStore",
    "type": "function",
    "parent": "can-zone-storage.methods",
    "signatures": [
      {
        "code": "getStore()",
        "description": "\n\nRetrieves the current store.  \n\nIf the [can-zone] library has been imported, `getStore` returns the `CanZone.current.data` object.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\nvar Zone = require(\"can-zone\");\nvar store = zoneStorage.getStore();\n\nstore === window.CanZone.current.data // true\n```\n\nIf the [can-zone] library has NOT been imported, `getStore` returns the internal [can-zone-storage.data] object.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\nvar store = zoneStorage.getStore();\n\nstore === zoneStorage.data // true\n```\n",
        "params": []
      }
    ]
  },
  "can-zone-storage.removeItem": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.methods.removeItem.md"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "name": "can-zone-storage.removeItem",
    "type": "function",
    "parent": "can-zone-storage.methods",
    "signatures": [
      {
        "code": "removeItem(key, value)",
        "description": "\n\nRemoves keyed data from the current data store.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\n\nzoneStorage.removeItem('key-name');\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key name that will be deleted from the data store.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key name that will be deleted from the data store.\n"
    }
  },
  "can-zone-storage.data": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.properties.data.md"
    },
    "body": "",
    "description": "Implement Zone-safe memory-based storage \n",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nThe `data` property of `can-zone-storage` is a plain old JavaScript object.  It is used as the memory-based storage when window.CanZone is undefined (when the [can-zone] module hasn't been loaded).  If `window.CanZone` is found (when [can-zone] is used), the `CanZone.current.data` object is used, instead, for Zone-safe storage.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\n\nconsole.log(zoneStorage.data) // --> {}\n\nzoneStorage.setItem('test', 123);\n\nconsole.log(zoneStorage.data) // --> {test: 123}\n```\n"
      }
    ],
    "title": "data",
    "name": "can-zone-storage.data",
    "type": "property",
    "parent": "can-zone-storage.properties"
  },
  "can-zone-storage.setItem": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.methods.setItem.md"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "name": "can-zone-storage.setItem",
    "type": "function",
    "parent": "can-zone-storage.methods",
    "signatures": [
      {
        "code": "setItem(key, value)",
        "description": "\n\nStores keyed data in the current data store.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\n\nvar value = 'Store me';\n\nzoneStorage.setItem('key-name', value);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key name under which the data will be stored."
          },
          {
            "types": [
              {
                "type": "Any"
              }
            ],
            "name": "value",
            "description": "The data to be stored."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Any"
        }
      ],
      "name": "value",
      "description": "The data to be stored."
    }
  },
  "guides/recipes/file-navigator-advanced": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/file-navigator-ajax.md"
    },
    "body": "\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/xuzerum/embed?js,output\">JS Bin on jsbin.com</a>\n\n> Note: If you don't see any files show up, run the JS Bin again. This\n> JS Bin uses randomly generated files so it's possible nothing shows up.\n\n__Start this tutorial by cloning the following JS Bin__:\n\n<a class=\"jsbin-embed\" href=\"//justinbmeyer.jsbin.com/xokopog/embed?html,output\">JS Bin on jsbin.com</a>\n\nThis JS Bin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\nThe following sections are broken down into:\n\n- Problem - A description of what the section is trying to accomplish.\n- Things to know - Information about CanJS that is useful for solving the problem.\n- Solution - The solution to the problem.\n\nWatch a video of us building this recipe here:\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/_7FJA0PzAgA\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n## Build a fixtured service layer\n\n### Problem\n\nMake an `/api/entities` service layer that provides the files and folders for another folder.  An `entity` can be either a file or folder.  A single `entity` looks like:\n\n```js\n{\n  id: \"2\",\n  name: \"dogs\",\n  parentId: \"0\",     // The id of the folder this file or folder is within.\n  type: \"folder\"     // or \"file\",\n  hasChildren: true  // false for a folder with no children, or a file\n}\n```\n\nTo get the list of files and folders within a given folder, a `GET` request should be made as follows:\n\n```\nGET /api/entities?folderId=0\n```\n\nThis should return the list of folders and files directly within that folder like:\n\n```js\n{\n  data: [\n   { id: \"7\", name: \"pekingese.png\", parentId: \"0\", type: \"file\",   hasChildren: false },\n   { id: \"8\", name: \"poodles\",       parentId: \"0\", type: \"folder\", hasChildren: false },\n   { id: \"9\", name: \"hounds\",        parentId: \"0\", type: \"folder\", hasChildren: true }\n  ]\n}\n```\n\nThe first level files and folders should have a `parentId` of `\"0\"`.\n\n### Things to know\n\n- [can-fixture] is used to trap AJAX requests like:\n\n  ```js\n  can.fixture(\"/api/entities\", function(request){\n    request.data.folderId //-> \"1\"\n\n    return {data: [...]}\n  })\n  ```\n\n- [can-fixture.store] can be used to automatically filter records using the querystring.\n\n  ```js\n  var entities = [ .... ];\n  var entitiesStore = can.fixture.store( entities );\n  can.fixture(\"/api/entities\", entitiesStore);\n  ```\n\n- [can-fixture.rand] can be used to create a random integer.\n  ```\n  can.fixture.rand(10) //-> 10\n  can.fixture.rand(10) //-> 0\n  ```\n\n\n\n### Solution\n\nFirst, make a function that generates an array of `entities` that will be stored on our fake server:\n\n```js\n// Stores the next entity id to use.\nvar entityId = 1;\n\n// Returns an array of entities for the given `parentId`.\n// Makes sure the `depth` of entities doesn't exceed 5.\nvar makeEntities = function(parentId, depth){\n  if(depth > 5) {\n    return [];\n  }\n  // The number of entities to create.\n  var entitiesCount = can.fixture.rand(10);\n\n  // The array of entities we will return.\n  var entities = [];\n\n  for(var i = 0 ;  i< entitiesCount; i++) {\n\n    // The id for this entity\n    var id = \"\"+(entityId++),\n        // If the entity is a folder or file\n        isFolder = Math.random() > 0.3,\n        // The children for this folder.\n        children = isFolder ? makeEntities(id, depth+1) : [];\n\n    var entity = {\n      id: id,\n      name: (isFolder ? \"Folder\" : \"File\")+\" \"+id,\n      parentId: parentId,\n      type: (isFolder ? \"folder\" : \"file\"),\n      hasChildren: children.length ? true : false\n    };\n    entities.push(entity);\n\n    // Add the children of a folder\n    [].push.apply(entities,  children)\n\n  }\n  return entities;\n};\n```\n\nThen, make those entities, create a `store` to house them, and trap AJAX requests to use that `store`.\n\n```js\n// Make the entities for the demo\nvar entities = makeEntities(\"0\", 0);\n\n// Add them to a client-like DB store\nvar entitiesStore = can.fixture.store(entities);\n\n// Trap requests to /api/entities to read items from the entities store.\ncan.fixture(\"/api/entities\", entitiesStore);\n\n// Make requests to /api/entities take 1 second\ncan.fixture.delay = 1000;\n```\n\n## Create the `Entity` Model\n\n### The problem\n\nWhen we load entities from the server, it's useful to convert them into `Entity` type instances.  We will want to create an observable `Entity` type using [can-define/map/map] so we can do:\n\n```js\nvar entity = new Entity({\n  id: \"2\",\n  name: \"dogs\",\n  parentId: \"0\",     // The id of the folder this file or folder is within.\n  type: \"folder\"     // or \"file\",\n  hasChildren: true  // false for a folder with no children, or a file\n});\n\nentity.on(\"name\", function(ev, newName){\n  console.log(\"entity name changed to \", newName);\n});\n\nentity.name = \"cats\" //-> logs \"entity name changed to cats\"\n```\n\n### Things to know\n\nYou can create a `DefineMap` type using [can-define/map/map.extend DefineMap.extend] with the type's properties and the properties' types like:\n\n```js\nType = can.DefineMap.extend({\n  id: \"string\",\n  hasChildren: \"boolean\",\n  ...\n})\n```\n\n### The solution\n\nExtend `can.DefineMap` with each property and its type as follows:\n\n```js\nvar Entity = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  parentId: \"string\",\n  hasChildren: \"boolean\",\n  type: \"string\"\n});\n```\n\n## Connect the `Entity` model to the service layer\n\n### The problem\n\nWe want to be able to load a list of `Entity` instances from `GET /api/entities` with:\n\n```js\nEntity.getList({parentId: \"0\"}).then(function(entities){\n    console.log(entities.get()) //-> [ Entity{id: \"1\", parentId: \"0\", ...}, ...]\n})\n```\n\n### Things to know\n\n[can-connect/can/base-map/base-map can.connect.baseMap()] can connect a `Map` type to\na `url` like:\n\n```js\ncan.connect.baseMap({\n  Map: Entity,\n  url: \"URL\"\n})\n```\n\n### The solution\n\nUse `can.connect.baseMap` to connect `Entity` to `/api/entities` like:\n\n```js\ncan.connect.baseMap({\n  Map: Entity\n  url: \"/api/entities\"\n})\n```\n\n## Create the ROOT entity and render it\n\n### The problem\n\nWe need to begin converting the static HTML the designer gave us into live HTML.  This means\nrendering it in a template.  We'll start slow by rendering the `root` parent folder's name\nin the same way it's expected by the designer.\n\n\n### Things to know\n\n- CanJS uses [can-stache] to render data in a template\n  and keep it live.  Templates can be authored in `<script>` tags like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-template\">\n    TEMPLATE CONTENT\n  </script>\n  ```\n\n  A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] magic tags to insert data into\n  the HTML output like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-template\">\n    {{something.name}}\n  </script>\n  ```\n\n- Load a template from a `<script>` tag with [can-stache.from can.stache.from] like:\n  ```js\n  var template = can.stache.from(SCRIPT_ID);\n  ```\n\n- Render the template with data into a documentFragment like:\n\n  ```js\n  var frag = template({\n    something: {name: \"Derek Brunson\"}\n  });\n  ```\n\n- Insert a fragment into the page with:\n\n  ```\n  document.body.appendChild(frag);\n  ```\n\n- You can create an `Entity` instance as follows:\n  ```js\n  var folder = new Entity({...});\n  ```\n\n  Where {...} is an object of the properties you need to create like `{id: \"0\", name: \"ROOT\", ...}`.\n  Pass this to the template.\n\n\n### The solution\n\nUpdate the __HTML__ tab to render the `folder`'s name.\n\n```html\n<script type=\"text/stache\" id=\"app-template\">\n<span>{{folder.name}}</span>\n</script>\n```\n\nUpdate the __JavaScript__ tab to:\n\n1. Create a `folder` `Entity` instance.\n2. Load the `app-template`.  Renders it with `folder` instance, and inserts the result in the `<body>` element.\n\n```js\nvar folder = new Entity({\n  id: \"0\",\n  name: \"ROOT/\",\n  hasChildren: true,\n  type: \"folder\"\n});\n\nvar template = can.stache.from(\"app-template\"),\n    frag = template({\n      folder: folder\n    });\n\ndocument.body.appendChild( frag );\n```\n\n\n\n## Render the ROOT entities children\n\n### The problem\n\nIn this section, we’ll list the files and folders within the root folder.\n\n### Things to know\n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n- Use [can-stache.helpers.each {{#each value}}] to do looping in `can-stache`.\n- Use [can-stache.helpers.is {{#eq value1 value2}}] to test equality in `can-stache`.\n- `Promise`s are observable in `can-stache`.  Given a promise `somePromise`, you can:\n  - Check if the promise is loading like: `{{#if somePromise.isPending}}`.\n  - Loop through the resolved value of the promise like: `{{#each somePromise.value}}`.\n- Write `<div class=\"loading\">Loading</div>` when files are loading.\n- Write a `<ul>` to contain all the files.  Within the `<ul>` there should be:\n  - An `<li>` with a class attribute that includes `file` or `folder` and `hasChildren` if the folder has children.\n  - The `<li>` should have `📝 <span>{{FILE_NAME}}</span>` if a file and `📁 <span>{{FOLDER_NAME}}</span>` if a folder.\n\n### The solution\n\nThe following uses `entitiesPromise` to write `<div class=\"loading\">Loading</div>` while\nthe promise is pending, and then writes out an `<li>` for each entity in the resolved `entitiesPromise`:\n\n```html\n<script type=\"text/stache\" id=\"app-template\">\n<span>{{folder.name}}</span>\n{{#if entitiesPromise.isPending}}\n  <div class=\"loading\">Loading</div>\n{{else}}\n  <ul>\n    {{#each entitiesPromise.value}}\n      <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n        {{#eq type 'file'}}\n          📝 <span>{{name}}</span>\n        {{else}}\n          📁 <span>{{name}}</span>\n        {{/eq}}\n      </li>\n    {{/each}}\n  </ul>\n{{/if}}\n</script>\n```\n\nThe following adds an `entitiesPromise` to data passed to the template.  `entitiesPromise`\nwill contain the files and folders that are directly within the root folder.\n\n```js\n    frag = template({\n      folder: folder,\n      entitiesPromise: Entity.getList({parentId: \"0\"})\n    });\n```\n\n## Toggle children with a ViewModel\n\n### The problem\n\nWe want to hide the root folder's children until the root folder is clicked on.  An subsequent\nclicks on the root folder's name should toggle if the children are displayed.\n\n### Things to know\n\n- CanJS uses [guides/technicalViewModels#MaintainableMVVM ViewModels] to manage the behavior\n  of views.  ViewModels can have their own state, such as if a folder `isOpen` and should be showing\n  its children. `ViewModels` are custructor functions created with [can-define/map/map can.DefineMap].\n\n- `can.DefineMap` can detail the type of a property with another type like:\n  ```js\n  var Address = can.DefineMap.extend({\n    street: \"string\",\n    city: \"string\"\n  });\n  var Person = can.DefineMap.extend({\n    address: Address\n  });\n  ```\n\n- `can.DefineMap` can also specify default values:\n  ```js\n  var Person = can.DefineMap.extend({\n    address: Address,\n    age: {value: 33}\n  });\n  ```\n\n- `can.DefineMap` can also specify a default value and a type:\n  ```js\n  var Person = can.DefineMap.extend({\n    address: Address,\n    age: {value: 33, type: \"number\"}\n  });\n  ```\n\n- `can.DefineMap` can also have methods:\n\n  ```js\n  var Person = can.DefineMap.extend({\n    address: Address,\n    age: {value: 33, type: \"number\"},\n    birthday: function(){\n      this.age++;\n    }\n  });\n  ```\n\n- Use [can-stache-bindings.event] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked.\n\n   ```html\n   <div on:click=\"doSomething()\"> ... </div>\n   ```\n\n### The solution\n\nThe following:\n\n - Defines a `FolderVM` type that will manage the UI state around a folder.  Specifically `FolderVM` has:\n   - `folder` which references the folder being displayed.\n   - `entitiesPromise` which will be a promise of all files for that folder.\n   - `isOpen` which tracks if the folder's children should be displayed.\n   - `toggleOpen` which changes `isOpen`.\n -  Creates an instance of the `FolderVM` and uses it to render the template.\n\n```js\nvar FolderVM = can.DefineMap.extend({\n  folder: Entity,\n  entitiesPromise: {\n    value: function(){\n      return Entity.getList({parentId: this.folder.id});\n    }\n  },\n  isOpen: {type: \"boolean\", value: false},\n  toggleOpen: function(){\n    this.isOpen = !this.isOpen;\n  }\n});\n\n// Create an instance of `FolderVM` with the root folder\nvar rootFolderVM = new FolderVM({\n  folder: folder\n});\n\nvar template = can.stache.from(\"app-template\"),\n    frag = template(rootFolderVM);\n\ndocument.body.appendChild( frag );\n```\n<span line-highlight='1-17,20'></span>\nThe following wraps the listing of child entities with a `{{#if isOpen}} {{/if}}`:\n\n```html\n<script type=\"text/stache\" id=\"app-template\">\n<span on:click=\"toggleOpen()\">{{folder.name}}</span>\n{{#if isOpen}}\n  {{#if entitiesPromise.isPending}}\n    <div class=\"loading\">Loading</div>\n  {{else}}\n    <ul>\n      {{#each entitiesPromise.value}}\n        <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n          {{#eq type 'file'}}\n            📝 <span>{{name}}</span>\n          {{else}}\n            📁 <span>{{name}}</span>\n          {{/eq}}\n        </li>\n      {{/each}}\n    </ul>\n  {{/if}}\n{{/if}}      \n</script>\n```\n<span line-highlight='3,19'></span>\n## Create an `<a-folder>` custom element to manage folder behavior\n\n### The problem\n\nNow we want to make all the folders able to open and close.  This means creating a `FolderVM` for every folder entity.\n\n### Things to know\n\n- [can-component can.Component] is used to create custom elements like:\n  ```js\n  var MyComponentVM = DefineMap.extend({\n    message: {value: \"Hello There!\"}\n  });\n\n  can.Component.extend({\n    tag: \"my-component\",\n    ViewModel: MyComponentVM,\n    view: can.stache(\"<h1>{{message}}</h1>\");\n  });\n  ```\n  This component will be created anytime a `<my-component>` element is found in the page.  When the component is created, it creates\n  an instance of it's `ViewModel`, in this case `MyComponentVM`.\n\n- You can pass data to a component's `ViewModel` with [can-stache-bindings.toChild {data-bindings}] like:\n\n  ```html\n  <my-component message:from=\"'Hi There'\"/>\n  ```\n\n  This sets `message` on the ViewModel to `'Hi There'`.  You can also send data within stache like:\n\n  ```html\n  <my-component message:from=\"greeting\"/>\n  ```\n  This sets `message` on the ViewModel to what `greeting` is in the stache template.\n\n- A component's [View] is rendered inside the component.  This means that if the following is in a template:\n\n  ```\n  <my-component {message}=\"'Hi There'\"/>\n  ```\n\n  The following will be inserted into the page:\n\n  ```\n  <my-component {message}=\"'Hi There'\"><h1>Hi There</h1></my-component>\n  ```\n\n- `this` in a stache template refers to the current context of a template or section.  \n\n  For example, the `this` in `this.name` refers to the `context` object:\n\n  ```javascript\n  var template = stache(\"{{this.name}}\");\n  var context = {name: \"Justin\"};\n  template(context);\n  ```\n\n  Or, when looping through a list of items, `this` refers to each item:\n\n  ```html\n  {{#each items}}\n    <li>{{this.name}}</li> <!-- this is each item in items -->\n  {{/each}}\n  ```\n\n\n### The solution\n\nThe following:\n\n1. Changes the `app-template` to use the `<a-folder>` component to render the root folder. It\n   passes the root folder as `folder` to the `<a-folder>` component's ViewModel.  It also sets the\n   `<a-folder>` component's ViewModel's `isOpen` property to `true`.\n2. Moves the content that was in `app-template` to the `folder-template` `<script>` tag.\n3. Recursively renders each child folder with `<a-folder {folder}=\"this\"/>`.\n\n```html\n<script type=\"text/stache\" id=\"app-template\">\n  <a-folder folder:from=\"this\" isOpen:from=\"true\"/>        <!-- CHANGED -->\n</script>\n\n<!-- CONTENT FROM app-template-->\n<script type=\"text/stache\" id=\"folder-template\">\n<span on:click=\"toggleOpen()\">{{folder.name}}</span>\n{{#if isOpen}}\n  {{#if entitiesPromise.isPending}}\n    <div class=\"loading\">Loading</div>\n  {{else}}\n    <ul>\n      {{#each entitiesPromise.value}}\n        <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n          {{#eq type 'file'}}\n            📝 <span>{{name}}</span>\n          {{else}}\n            📁 <a-folder folder:from=\"this\"/>            <!-- CHANGED -->\n          {{/eq}}\n        </li>\n      {{/each}}\n    </ul>\n  {{/if}}\n{{/if}}\n</script>\n```\n<span line-highlight='2,17'></span>\nThe following:\n\n1. Defines a custom `<a-folder>` element that manages its behavior with `FolderVM` and uses it to render a `folder-template`\n   template.\n2. Renders the `app-template` with the root `parent` folder instead of the `rootFolderVM`.\n\n```js\nvar FolderVM = can.DefineMap.extend({\n  folder: Entity,\n  entitiesPromise: {\n    value: function(){\n      return Entity.getList({parentId: this.folder.id});\n    }\n  },\n  isOpen: {type: \"boolean\", value: false},\n  toggleOpen: function(){\n    this.isOpen = !this.isOpen;\n  }\n});\n\ncan.Component.extend({\n  tag: \"a-folder\",\n  ViewModel: FolderVM,\n  view: can.stache.from(\"folder-template\")\n});\n\n/*var rootFolderVM = new FolderVM({          // REMOVED\n  folder: folder\n});*/\n\nvar template = can.stache.from(\"app-template\"),\n    frag = template(folder);\n\ndocument.body.appendChild( frag );\n```\n<span line-highlight='14-22,25,only'></span>\nWhen complete, you should have a working file-navigation widget\nlike the completed JS Bin above.\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "This guide walks you through building a file navigation widget.  It takes about 45 minutes to complete.  It was written with\nCanJS 3.4. Checkout the [guides/recipes/file-navigator-simple]\nfor an easier example that produces similar functionality.\n\n\n",
    "name": "guides/recipes/file-navigator-advanced",
    "title": "File Navigator Guide (Advanced)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/recipes.md"
    },
    "body": "\n\n## Credit Card\n\nThe [guides/recipes/credit-card-simple]  walks through building\na simple credit card payment form with Stripe. It also performs\nsimple validation on the payment form values.\n\n![Credit Card App](https://user-images.githubusercontent.com/78602/27451508-d86e9bd8-5754-11e7-954b-a812e1ed63b1.png)\n\nThe [guides/recipes/credit-card-advanced] recipe builds nearly same application, but\nwith better validations and with Kefir streams instead of [can-define].\n\n## CTA Bus Map\n\nThe [guides/recipes/cta-bus-map] walks through showing Chicago Transit Authority (CTA) bus locations on a Google Map.  You'll learn how to create a [can-component] that integrates with 3rd party widgets.\n\n![CTA Bus Map](../../docs/can-guides/commitment/recipes/cta-bus-map/cta-bus-map.png)\n\n## Signup and Login\n\nThe [guides/recipes/signup-simple] walks through building simple signup, login forms and\na logout button.   \n\n![Signup and Login](../../docs/can-guides/commitment/recipes/signup-simple/signup.png)\n\n## File Navigator\n\nThe [guides/recipes/file-navigator-simple] walks through building a simple navigation\nwidget where you can open and close folders.\n\nThe [guides/recipes/file-navigator-advanced] walks through a navigation widget that uses\n[can-connect] to load the data for a folder from a simulated service layer.\n\n![File Navigator](https://cloud.githubusercontent.com/assets/78602/22888969/273617ca-f1cd-11e6-922f-28bd5514b3dd.jpeg)\n\n## TodoMVC with StealJS\n\nThe [guides/recipes/todomvc-with-steal] guide builds the TodoMVC application, like the [guides/todomvc], but using [StealJS](https://stealjs.com) to load modules.  It is designed to be done in a classroom-like setting and includes links\nto keynote and powerpoint presentations for each section.\n\n\n## Weather Report\n\nThe [guides/recipes/weather-report-simple] walks through building a 10 day forecast widget\nusing YQL. The [guides/recipes/weather-report-advanced] extends the simple widget to\nremove imperative code and automatically lookup the users location using the\nbrowser's [geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation) with\nevent streams.\n\n![Weather Report](../../docs/can-guides/commitment/recipes/weather-report/weather-report.png)\n\n## Playlist Editor\n\nThe [guides/recipes/playlist-editor] shows how to use YouTube's API to search for videos and make a playlist.  This\nmakes authenticated requests with OAuth2. It uses [jQuery++](https://jquerypp.com) for\ndrag/drop events. It shows using custom attributes and custom events.  \n\n![Playlist Editor](https://user-images.githubusercontent.com/78602/27451781-ea3ed3d6-5755-11e7-8dd8-c4e83bc8aa90.png)\n\n",
    "description": "A listing of small examples that are useful for learning CanJS.\n\n",
    "name": "guides/recipes",
    "title": "recipes",
    "type": "page",
    "parent": "guides",
    "order": 3,
    "comment": " "
  },
  "guides/recipes/file-navigator-simple": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/file-navigator-simple.md"
    },
    "body": "\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/faraval/embed?js,output\">JS Bin on jsbin.com</a>\n\nClick `ROOT/` to see its files and folders.\n\n> Note: If you don't see any files show up, run the JS Bin again. This\n> JS Bin uses randomly generated files so it's possible nothing shows up.\n\n__Start this tutorial by cloning the following JS Bin__:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/caquxa/embed?html,output\">JS Bin on jsbin.com</a>\n\nThis JS Bin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\nThe following sections are broken down into:\n\n- Problem - A description of what the section is trying to accomplish.\n- Things to know - Information about CanJS that is useful for solving the problem.\n- Solution - The solution to the problem.\n- Test it (uncommon) - How to make sure the solution works.\n\n\n## Understand the data\n\nThere is a randomly generated `rootEntityData` variable that contains a nested structure of\nfolders and files.  It looks like:\n\n\n```js\n{\n  \"id\": \"0\",\n  \"name\": \"ROOT/\",\n  \"hasChildren\": true,\n  \"type\": \"folder\",\n  \"children\": [\n    {\n      \"id\": \"1\", \"name\": \"File 1\",\n      \"parentId\": \"0\",\n      \"type\": \"file\",\n      \"hasChildren\": false\n    },\n    {\n      \"id\": \"2\", \"name\": \"File 2\",\n      \"parentId\": \"0\",\n      \"type\": \"file\",\n      \"hasChildren\": false\n    },\n    {\n      \"id\": \"3\", \"name\": \"Folder 3\",\n      \"parentId\": \"0\",\n      \"type\": \"folder\",\n      \"hasChildren\": true,\n      \"children\": [\n        {\n          \"id\": \"4\", \"name\": \"File 4\",\n          \"parentId\": \"3\",\n          \"type\": \"file\",\n          \"hasChildren\": false\n        },\n        {\n          \"id\": \"5\", \"name\": \"File 5\",\n          \"parentId\": \"3\",\n          \"type\": \"file\",\n          \"hasChildren\": false\n        },\n        {\n          \"id\": \"6\", \"name\": \"File 6\",\n          \"parentId\": \"3\",\n          \"type\": \"file\",\n          \"hasChildren\": false\n        },\n        {\n          \"id\": \"7\", \"name\": \"File 7\",\n          \"parentId\": \"3\",\n          \"type\": \"file\",\n          \"hasChildren\": false\n        },\n        {\n          \"id\": \"8\", \"name\": \"Folder 8\",\n          \"parentId\": \"3\",\n          \"type\": \"folder\",\n          \"hasChildren\": false,\n          \"children\": []\n        }\n      ]\n    },\n    {\n      \"id\": \"9\", \"name\": \"File 9\",\n      \"parentId\": \"0\",\n      \"type\": \"file\",\n      \"hasChildren\": false\n    }\n  ]\n}\n```\nNotice that entities have the following properties:\n\n- __id__ - a unique id\n- __name__ - the name of the file or folder\n- __type__ - if this entity a \"file\" or \"folder\"\n- __hasChildren__ - if this entity has children\n- __children__ - An array of the child file and folder entities for this folder\n\n## Render the root folder and its contents\n\n### The problem\n\nLet’s render `rootEntityData` in the page with its immediate children.\n\n### What you need to know\n\n- CanJS uses [can-stache] to render data in a template\n  and keep it live.  Templates can be authored in `<script>` tags like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-template\">\n    TEMPLATE CONTENT\n  </script>\n  ```\n\n  A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] magic tags to insert data into\n  the HTML output like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-template\">\n    {{something.name}}\n  </script>\n  ```\n\n- Load a template from a `<script>` tag with [can-stache.from can.stache.from] like:\n  ```js\n  var template = can.stache.from(SCRIPT_ID);\n  ```\n\n- Render the template with data into a documentFragment like:\n\n  ```js\n  var frag = template({\n    something: {name: \"Derek Brunson\"}\n  });\n  ```\n\n- Insert a fragment into the page with:\n\n  ```\n  document.body.appendChild(frag);\n  ```\n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n- Use [can-stache.helpers.each {{#each value}}] to do looping in `can-stache`.\n- Use [can-stache.helpers.is {{#eq value1 value2}}] to test equality in `can-stache`.\n- [can-stache/keys/current {{./key}}] only returns the value in the current scope.\n- Write a `<ul>` to contain all the files.  Within the `<ul>` there should be:\n  - An `<li>` with a className that includes `file` or `folder` and `hasChildren` if the folder has children.\n  - The `<li>` should have `📝 <span>{{FILE_NAME}}</span>` if a file and `📁 <span>{{FOLDER_NAME}}</span>` if a folder.\n\n### The solution\n\nUpdate the __HTML__ tab to:\n\n```html\n<script type=\"text/stache\" id=\"entities-template\">\n  <span>{{name}}</span>\n  <ul>\n    {{#each ./children}}\n      <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n        {{#eq type 'file'}}\n          📝 <span>{{name}}</span>\n        {{else}}\n          📁 <span>{{name}}</span>\n        {{/eq}}\n      </li>\n    {{/each}}\n  </ul>\n</script>\n```\n\nUpdate the __JavaScript__ tab to:\n\n```js\nvar template = can.stache.from(\"entities-template\");\n\nvar frag = template( rootEntityData );  \n\ndocument.body.appendChild( frag );\n```\n\n## Render all the files and folders\n\n### The Problem\n\nNow lets render all of the files and folders!  This means we want to render the files and folders recursively.  Every time we\nfind a folder, we need to render its contents.\n\n### Things to know\n\n- A template can call out to another registered _partial_ template with with [can-stache.tags.partial {{>PARTIAL_NAME}}] like the following:\n\n  ```html\n  {{>PARTIAL_NAME}}\n  ```\n\n- You can register partial templates with [can-stache.registerPartial can.stache.registerPartial] like the following:\n\n  ```js\n  var template = can.stache.from(\"TEMPLATE_ID\");\n  can.stache.registerPartial( \"PARTIAL_NAME\", template );\n  ```\n\n### The Solution\n\nUpdate the __HTML__ tab to:\n\n- Call to an `{{>entities}}` partial.\n\n```html\n<script type=\"text/stache\" id=\"entities-template\">\n  <span>{{name}}</span>\n  <ul>\n    {{#each ./children}}\n      <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n        {{#eq type 'file'}}\n          📝 <span>{{name}}</span>\n        {{else}}\n          📁 {{>entities}}\n        {{/eq}}\n      </li>\n    {{/each}}\n  </ul>\n</script>\n```\n<span line-highlight='9'></span>\nUpdate the __JavaScript__ tab to:\n\n - Register the `entities-template` as a partial:\n\n```js\nvar template = can.stache.from(\"entities-template\");\ncan.stache.registerPartial(\"entities\", template );\n\nvar frag = template(rootEntityData);\n\ndocument.body.appendChild( frag );\n```\n<span line-highlight='2'></span>\n## Make the data observable\n\n### The problem\n\nFor rich behavior, we need to convert the raw JS data into typed observable data.  When\nwe change the data, the UI will automatically change.\n\n### Things to know\n\n- [can-define/map/map.extend DefineMap.extend] allows you to define a type by defining the type's\n  properties and the properties' types like:\n\n  ```js\n  Person = can.DefineMap.extend(\"Person\",{\n    name: \"string\",\n    age: \"number\"\n  })\n  ```\n\n  This lets you create instances of that type and listen to changes like:\n\n  ```js\n  var person = new Person({\n    name: \"Justin\",\n    age: 34\n  });\n\n  person.on(\"name\", function(ev, newName){\n    console.log(\"person name changed to \", newName);\n  });\n\n  person.name = \"Kevin\" //-> logs \"entity name changed to Kevin\"\n  ```\n\n- `can.DefineMap` supports an [can-define.types.propDefinition#Array Array shorthand] that allows one to specify a [can-define/list/list can.DefineList] of typed instances like:\n\n  ```js\n  Person = can.DefineMap.extend(\"Person\",{\n    name: \"string\",\n    age: \"number\",\n    addresses: [Address]\n  });\n  ```\n\n  However, if `Address` wasn't immediately available, you could do the same thing like:\n\n  ```js\n  Person = can.DefineMap.extend(\"Person\",{\n    name: \"string\",\n    age: \"number\",\n    addresses: [{\n      type: function(rawData){\n        return new Address(rawData);\n      }\n    }]\n  });\n  ```\n\n\n### The solution\n\nUpdate the __JavaScript__ tab to:\n\n- Define an `Entity` type and the type of its properties.\n- Create an instance of the `Entity` type called `rootEntity`\n- Use `rootEntity` to render the template\n\n```js\nvar Entity = can.DefineMap.extend(\"Entity\",{  \n  id: \"string\",\n  name: \"string\",\n  parentId: \"string\",\n  hasChildren: \"boolean\",\n  type: \"string\",\n  children: [{\n    type: function(entity){\n      return new Entity(entity)\n    }\n  }]\n});\n\nvar rootEntity = new Entity(rootEntityData);\n\n\nvar template = can.stache.from(\"entities-template\");\ncan.stache.registerPartial(\"entities\", template );\n\nvar frag = template(rootEntity);\n\ndocument.body.appendChild( frag );\n```\n<span line-highlight='1-14,18'></span>\n### Test it\n\nRun the following the `console` tab:\n\n```js\nrootEntity.name= \"Something New\";\nrootEntity.children.pop();\n```\n\nYou should see the page change automatically.\n\n\n## Make the folders open and close\n\n### The problem\n\nWe want to be able to toggle if a folder is open or closed.\n\n### Things to know\n\n- `can.DefineMap` can specify a default value and a type:\n  ```js\n  var Person = can.DefineMap.extend({\n    address: Address,\n    age: {value: 33, type: \"number\"}\n  });\n  ```\n\n- `can.DefineMap` can also have methods:\n\n  ```js\n  var Person = can.DefineMap.extend({\n    address: Address,\n    age: {value: 33, type: \"number\"},\n    birthday: function(){\n      this.age++;\n    }\n  });\n  ```\n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n\n- Use [can-stache-bindings.event on:EVENT] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked.\n\n   ```html\n   <div on:click=\"doSomething()\"> ... </div>\n   ```\n\n### The solution\n\nUpdate the __JavaScript__ tab to:\n\n- Add an `isOpen` property to `Entity`.\n- Add a `toggleOpen` method to `Entity`.\n\n```js\nvar Entity = can.DefineMap.extend(\"Entity\",{\n  id: \"string\",\n  name: \"string\",\n  parentId: \"string\",\n  hasChildren: \"boolean\",\n  type: \"string\",\n  children: [{\n    type: function(entity){\n      return new Entity(entity)\n    }\n  }],\n  isOpen: {type: \"boolean\", value: false},\n  toggleOpen: function(){      \n    this.isOpen = !this.isOpen;\n  }\n});\n\nvar rootEntity = new Entity(rootEntityData);\n\nvar template = can.stache.from(\"entities-template\");\ncan.stache.registerPartial(\"entities\", template );\n\nvar frag = template(rootEntity);              \n\ndocument.body.appendChild( frag );\n```\n<span line-highlight='12-15'></span>\nUpdate the __HTML__ tab to:\n\n- Call `toggleOpen()` when clicked.\n- Only show the children `{{#if isOpen}}` is true.\n\n```html\n<script type=\"text/stache\" id=\"entities-template\">\n<span on:click=\"toggleOpen()\">{{name}}</span>\n{{#if isOpen}}              \n  <ul>\n    {{#each ./children}}\n      <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n        {{#eq type 'file'}}\n          📝 <span>{{name}}</span>\n        {{else}}\n          📁 {{>entities}}      \n        {{/eq}}\n      </li>\n    {{/each}}\n  </ul>\n{{/if}}                        \n</script>\n```\n<span line-highlight='2,3,15'></span>\nWhen complete, you should have a working file-navigation widget\nlike the completed JS Bin above.\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "This guide walks you through building a simple file navigation widget.  It takes about 25 minutes to complete.  It was written with\nCanJS 3.4. Checkout the [guides/recipes/file-navigator-advanced]\nfor an example that makes AJAX requests for its data and uses [can-component].\n\n\n",
    "name": "guides/recipes/file-navigator-simple",
    "title": "File Navigator Guide (Simple)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/atm": {
    "src": {
      "path": "docs/can-guides/experiment/atm/atm.md"
    },
    "body": "\n\n## Overview\n\nCheck out the final app:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/daroce/2/embed?js,output\">JS Bin on jsbin.com</a>\n\nNotice it has tests at the bottom of the `Output` tab.\n\n## Setup\n\nThe easiest way to get started is to clone the following JS&nbsp;Bin by clicking the __JS&nbsp;Bin__ button on the top left:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/meziyu/3/edit?html,js,output\">JS Bin on jsbin.com</a>\n\nThe JS Bin is designed to run both the application and its tests in the `OUTPUT`\ntab.  To set this up, the __HTML__ tab:\n\n - Loads QUnit for its testing library.  It also includes the `<div id=\"qunit\"></div>`\n   element where QUnit’s test results will be written to.\n\n - Loads [can.all.js](https://unpkg.com/can@3/dist/global/can.all.js), which\n   is a script that includes all of CanJS core under a single global `can` namespace.\n\n   Generally speaking, you should not use the global `can` script, but instead you\n   should import things directly with a module loader like [StealJS](https://stealjs.com),\n   WebPack or Browserify.  Read [guides/setup] for instructions on how to set up CanJS in a real app.\n\n - Includes the content for an `app-template` [can-stache] template. This template\n   provides the title for the ATM app and uses the `<atm-machine>` custom [can-component]\n   element that will eventually provide the ATM functionality.\n\nThe `JavaScript` tab is split into two sections:\n\n - `CODE` - The ATM’s models, view-models and component code will go here.\n - `TESTS` - The ATM’s tests will go here.\n\nNormally, your application’s code and tests will be in separate files and loaded\nby different html pages, but we combine them here to fit within JS&nbsp;Bin’s limitations.\n\nThe `CODE` section renders the `app-template` with:\n\n```js\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n```\n\nThe `TESTS` section labels which module will be tested:\n\n```js\nQUnit.module(\"ATM system\", {});\n```\n\n## Mock out switching between pages\n\nIn this section, we will mock out which pages will be shown as the `state`\nof the `ATM` changes.  \n\nUpdate the __HTML__ tab to:\n\n - Switch between different pages of the application as the `ATM` view-model’s `state` property changes\n   with [can-stache.helpers.switch].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"https://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='12-60,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Create the `ATM` view-model with a `state` property initialized to `readingCard` with [can-define/map/map].\n - Create an `<atm-machine>` custom element with [can-component].\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {});\n\n```\n<span line-highlight='5-13,only'></span>\nWhen complete, you should see the __“Reading Card”__ title.\n\nThis step includes all the potential pages the `state`\nproperty can transition between:\n\n- readingCard\n- readingPin\n- choosingTransaction\n- pickingAccount\n- depositInfo\n- withdrawalInfo\n- successfulTransaction\n- printingReceipt\n\nEach of those states are present in the following state diagram:\n\n<img height=\"693\" src=\"../../docs/can-guides/experiment/atm/1-pages-template/state-diagram.png\" width=\"808\">\n\nWe’ll build out these pages once we build the `Card` and `Transaction` sub-models that will make building the ATM view model easier.\n\n## Card tests\n\nIn this section, we will:\n\n - Design an API for an ATM `Card`\n - Write out tests for the card.\n\nAn ATM `Card` will take a card `number` and `pin`. It will start out as\nhaving a `state` of  `\"unverified\"`. It will have a `verify` method\nthat will change the `state` to `\"verifying\"`, and if the response is successful,\n`state` will change to `\"verified\"`.\n\nUpdate the `JavaScript` tab to:\n\n- Make the fake data request delay `1ms` by setting [can-fixture.delay] to `1` before every test and\n  restoring it to `2s` after every test runs.\n- Write a test that creates a valid card, calls `.verify()`, and asserts the `state` is `\"verified\"`.\n- Write a test that creates an invalid card, calls `.verify()`, and asserts the `state` is `\"invalid\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\n```\n<span line-highlight='24-70,only'></span>\nWhen complete, you should have a breaking test.  Now let’s make it pass.\n\n## Card model\n\nIn this section, we will:\n\n- Implement the `Card` model so that all the tests pass.\n\nUpdate the `JavaScript` tab to:\n\n- Simulate the `/verifyCard` with [can-fixture]. It will return a successful response if\n  the request body has a `number` and `pin`, or a `400` if not.\n- Use [can-define/map/map] to define the `Card` model, including:\n  - a `number` and a `pin` property.\n  - a `state` property initialized to `unverified` that is not part of the card’s [can-define.types.serialize]d  data.\n  - a `verify` method that posts the card’s data to `/verifyCard` and updates the `state`\n    accordingly.\n\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\n```\n<span line-highlight='5-42,only'></span>\nWhen complete, all tests should pass.\n\nIn this step, you implemented a `Card` model that encapsulates the behavior of its own state.\n\n## Deposit test\n\nIn this section, we will:\n\n - Design an API retrieving `Account`s.\n - Design an API for a `Deposit` type.\n - Write out tests for the `Deposit` type.\n\nAn `Account` will have an `id`, `name`, and `balance`.  We’ll use [can-connect] to add a\n[can-connect/can/map/map.getList] method that retrieves an account given a `card`.\n\nA `Deposit` will take a `card`, an `amount`, and an `account`.  Deposits will start out having\na `state` of `\"invalid\"`.  When the deposit has a `card`, `amount` and `account`, the `state`\nwill change to `\"ready\"`.  Once the deposit is ready, the `.execute()` method will change the state\nto `\"executing\"` and then to `\"executed\"` once the transaction completes.\n\nUpdate the `JavaScript` tab to:\n\n- Create a `deposit` with an `amount` and a `card`.\n- Check that the `state` is `\"invalid\"` because there is no `account`.\n- Use `Account.getList` to get the accounts for the card and:\n  - set the `deposit.accounts` to the first account.\n  - remember the starting `balance`.\n- Use [can-define/map/map.prototype.on] to listen for `state` changes. When `state` is:\n  - `\"ready\"`, `.execute()` the transaction.\n  - `\"executed\"`, verify the new account balance.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='111-151,only'></span>\nWhen complete, the __Deposit__ test should run, but error because _Deposit is not defined_.\n\n> __Optional:__ Challenge yourself by writing the __Withdrawal__ test on your own.  How is it different than the __Deposit__ test?\n\n## Transaction, Deposit, and Withdrawal models\n\nIn this section, we will:\n\n- Implement the `Account` model.\n- Implement a base `Transaction` model and extend it into `Deposit` and\n`Withdrawal` models.\n- Get the __Deposit__ test to pass.\n\nUpdate the `JavaScript` tab to:\n\n- Simulate `/accounts` to return `Account` data with [can-fixture].\n- Simulate `/deposit` to always return a successful result.\n- Simulate `/withdrawal` to always return a successful result.\n- Define the `Account` model to:\n\t- have an `id` property.\n\t- have a `balance` property.\n\t- have a `name` property.\n- Define an `Account.List` type with [can-define/list/list].\n- Connect `Account` and `Account.List` types to the RESTful `/accounts` endpoint using [can-connect/can/base-map/base-map].\n- Define the `Transaction` model to:\n  - have `account` and `card` properties.\n  - have `executing` and `executed` properties that track if the transaction is executing or has executed.\n  - have a `rejected` property that stores the error given for a failed transaction.\n  - have an __abstract__ `ready` property that `Deposit` and `Withdrawal` will implement to return `true`\n    when the transaction is in an executable state.\n  - have a `state` property that reads other stateful properties and returns a string representation\n    of the state.\n  - have an __abstract__ `executeStart` method that `Deposit` and `Withdrawal` will implement to\n    execute the transaction and return a `Promise` that resolves when the transaction is complete.\n  - have an __abstract__ `executeEnd` method that `Deposit` and `Withdrawal` will implement to\n    update the transactions values (typically the `account` balance) if the transaction is successfully completed.\n  - have an `execute` method that calls `.executeStart()` and `executeEnd()` and keeps the stateful\n    properties updated correctly.\n- Define the `Deposit` model to:\n  - have an `amount` property.\n  - implement `ready` to return `true` when the amount is greater than `0` and there’s an `account`\n    and `card`.\n  - implement `executeStart` to `POST` the deposit information to `/deposit`\n  - implement `executeEnd` to update the account balance.\n- Define the `Withdrawal` model to behave in the same way as `Deposit` except that\n  it `POST`s the withdrawal information to `/withdrawal`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='13-31,63-187,only'></span>\nWhen complete, the __Deposit__ tests will pass.\n\n## Reading Card page and test\n\nIn this section, we will:\n\n - Allow the user to enter a card number and go to the __Reading Pin__ page.\n - Add tests to the __ATM Basics__ test.\n\nUpdate the __HTML__ tab to:\n\n- Allow a user to call `cardNumber` with the `<input>`’s `value`.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" on:enter=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"https://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='20-26,only'></span>\nUpdate the `JavaScript` tab to:\n\n- Declare a `card` property.\n- Derive a `state` property that changes to `\"readingPin\"` when `card` is defined.\n- Add a `cardNumber` that creates a `card` with the provided `number`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\n\t// derived properties\n\tget state(){\n\t\tif(this.card) {\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tQUnit.start();\n});\n\n```\n<span line-highlight='190-205,313-325,only'></span>\nWhen complete, you should be able to enter a card number and see the __Reading Pin__\npage.\n\n## Reading Pin page and test\n\nIn this section, we will:\n\n- Allow the user to enter a pin number and go to the __Choosing Transaction__ page.\n- Add tests to the __ATM Basics__ test.\n\nUpdate the __HTML__ tab to:\n\n- Call `pinNumber` with the `<input>`’s `value`.\n- Disable the `<input>` while the pin is being verified.\n- Show a loading icon while the pin is being verified.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" on:enter=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\ton:enter=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" on:click=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"https://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='31-47,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Define an `accountsPromise` property that will contain a list of accounts for the `card`.\n- Define a `transactions` property that will contain a list of transactions for this session.\n- Update `state` to be in the `\"choosingTransaction\"` state when the `card` is verified.\n- Define a `pinNumber` method that updates the `card`’s `pin`, calls `.verify()`,\n  and initializes the `accountsPromise` and `transactions` properties.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Test whether calling `pinNumber` moves the `state` to `\"choosingTransaction\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\n\t// derived properties\n\tget state(){\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null\n\t\t});\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tQUnit.start();\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='192-193,198-200,212-228,346-356,only'></span>\nWhen complete, you should be able to enter a card and pin number and see the __Choosing Transaction__\npage.\n\n## Choosing Transaction page and test\n\nIn this section, we will:\n\n- Allow the user to pick a transaction type and go to the __Picking Account__ page.\n- Add tests to the __ATM Basics__ test.\n\nUpdate the __HTML__ tab to:\n\n- Have buttons for choosing a deposit, withdrawal, or print a receipt and exit.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" on:enter=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\ton:enter=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" on:click=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li on:click=\"chooseDeposit()\">Deposit</li>\n                <li on:click=\"chooseWithdraw()\">Withdraw</li>\n                <li on:click=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"https://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='52-59,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Define a `currentTransaction` property that when set, adds the previous `currentTransaction`\n  to the list of `transactions`.\n- Update the `state` property to `\"pickingAccount\"` when there is a `currentTransaction`.\n- Update the `exit` method to clear the `currentTransaction` property.\n- Define `chooseDeposit` that creates a `Deposit` and sets it as the `currentTransaction`.\n- Define `chooseWithdraw` that creates a `Withdraw` and sets it as the `currentTransaction`.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Call `.chooseDeposit()` and verify that the state moves to `\"pickingAccount\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\n\t// derived properties\n\tget state(){\n\n\t\tif (this.currentTransaction) {\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null\n\t\t});\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='194-204,209-211,243,246-255,363,382-389,only'></span>\n\n> __Note:__ We will define `printReceiptAndExit` later!\n\n## Picking Account page and test\n\nIn this section, we will:\n\n- Allow the user to pick an account and go to either the  __Deposit Info__ or\n  __Withdrawal Info__ page.\n- Add tests to the __ATM Basics__ test.\n\nUpdate the __HTML__ tab to:\n\n- Write out a _“Loading Accounts…”_ message while the accounts are loading.\n- Write out the accounts when loaded.\n- Call `chooseAccount()` when an account is clicked.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" on:enter=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\ton:enter=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" on:click=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li on:click=\"chooseDeposit()\">Deposit</li>\n                <li on:click=\"chooseWithdraw()\">Withdraw</li>\n                <li on:click=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"https://canjs.com/docs/images/loader.gif\"/>\n                    Loading Accounts…\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li on:click=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"https://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='64-78,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Change `state` to check if the `currentTransaction` has an `account` and update the\n  value to `\"depositInfo\"` or `\"withdrawalInfo\"`, depending on the `currentTransaction`’s type.\n- Add a `chooseAccount` method that sets the `currentTransaction`’s `account`.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Call `.chooseAccount()` with the first account loaded.\n- Verify the state changes to `\"depositInfo\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\n\t// derived properties\n\tget state(){\n\n\t\tif (this.currentTransaction) {\n\t\t\tif (this.currentTransaction.account) {\n\t\t\t\tif (this.currentTransaction instanceof Deposit) {\n\t\t\t\t\treturn \"depositInfo\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"withdrawalInfo\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null\n\t\t});\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseAccount: function(account) {\n\t\tthis.currentTransaction.account = account;\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tatm.accountsPromise.then(function(accounts){\n\t\t\t\tatm.chooseAccount(accounts[0]);\n\t\t\t});\n\n\t\t} else if (newVal === \"depositInfo\") {\n\n\t\t\tQUnit.ok(true, \"in depositInfo state\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='210-216,264-266,398-407,only'></span>\n## Deposit Info page and test\n\nIn this section, we will:\n\n- Allow the user to enter the amount of a deposit and go to the __Successful Transaction__ page.\n- Add tests to the __ATM Basics__ test.\n\nUpdate the __HTML__ tab to:\n\n- Ask the user how much they would like to deposit into the account.\n- Update `currentTransaction.amount` with an `<input>`’s `value`.\n- If the transaction is executing, show a spinner.\n- If the transaction is not executed:\n  - show a __Deposit__ button that will be\n    active only once the transaction has a value.\n  - show a __cancel__ button that will clear this transaction.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" on:enter=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\ton:enter=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" on:click=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li on:click=\"chooseDeposit()\">Deposit</li>\n                <li on:click=\"chooseWithdraw()\">Withdraw</li>\n                <li on:click=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"https://canjs.com/docs/images/loader.gif\"/>\n                    Loading Accounts…\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li on:click=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" value:bind=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button on:click=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" on:click=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"https://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='83-104,only'></span>\nUpdate the `ATM` view model in the `JavaScript` tab to:\n\n - Change `state` to `\"successfulTransaction\"` if the `currentTransaction` was executed.\n - Add a `removeTransaction` method that removes the `currentTransaction`, which will revert state\n   to `\"choosingTransaction\"`.\n\nUpdate the `ATM basics` test in the `JavaScript` tab to:\n\n- Add an `amount` to the `currentTransaction`.\n- Make sure the `currentTransaction` is `ready` to be executed.\n- Execute the `currentTransaction` and make sure that the `state` stays as `\"depositInfo\"` until\n  the transaction is successful.\n- Verify the state changed to `\"successfulTransaction\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\n\t// derived properties\n\tget state(){\n\n\t\tif (this.currentTransaction) {\n\t\t\tif (this.currentTransaction.state === \"executed\") {\n\t\t\t\treturn \"successfulTransaction\";\n\t\t\t}\n\n\t\t\tif (this.currentTransaction.account) {\n\t\t\t\tif (this.currentTransaction instanceof Deposit) {\n\t\t\t\t\treturn \"depositInfo\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"withdrawalInfo\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null\n\t\t});\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseAccount: function(account) {\n\t\tthis.currentTransaction.account = account;\n\t},\n\tremoveTransaction: function() {\n\t\tthis.currentTransaction = null;\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tatm.accountsPromise.then(function(accounts){\n\t\t\t\tatm.chooseAccount(accounts[0]);\n\t\t\t});\n\n\t\t} else if (newVal === \"depositInfo\") {\n\n\t\t\tQUnit.ok(true, \"in depositInfo state\");\n\t\t\tvar currentTransaction = atm.currentTransaction;\n\t\t\tcurrentTransaction.amount = 120;\n\t\t\tQUnit.ok(currentTransaction.ready, \"we are ready to execute\");\n\t\t\tcurrentTransaction.execute();\n\t\t\tQUnit.equal(atm.state, \"depositInfo\", \"in deposit state until successful\");\n\n\t\t} else if (newVal === \"successfulTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in successfulTransaction state\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='189,210-212,271-273,381,412-423,only'></span>\nWhen complete, you should be able to enter a deposit amount and see that\nthe transaction was successful.\n\n## Withdrawal Info page\n\nIn this section, we will:\n\n- Allow the user to enter the amount of a withdrawal and go to the __Successful Transaction__ page.\n\nUpdate the __HTML__ tab to:\n\n - Add a __Withdraw__ page that works very similar to the __Deposit__ page.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" on:enter=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\ton:enter=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" on:click=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li on:click=\"chooseDeposit()\">Deposit</li>\n                <li on:click=\"chooseWithdraw()\">Withdraw</li>\n                <li on:click=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"https://canjs.com/docs/images/loader.gif\"/>\n                    Loading Accounts…\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li on:click=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" value:bind=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button on:click=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" on:click=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n        <h2>Withdraw</h2>\n    \t<p>\n    \t\tHow much would you like to withdraw\n    \t\tfrom {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"withdrawl\" value:bind=\"currentTransaction.amount\"/>\n    \t</p>\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button on:click=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tWithdraw\n    \t\t</button>\n    \t\t<a href=\"javascript://\" on:click=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"https://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='109-129,only'></span>\nWhen complete, you should be able to enter a withdrawal amount and see that\nthe transaction was successful.\n\n> __Optional:__ Challenge yourself by adding a test for the `withdrawalInfo` state of an `atm` instance.  Consider the progression of states needed to make it to the `withdrawalInfo` state.  How is it different from the __ATM basics__ test we already have?\n\n## Transaction Successful page\n\nIn this section, we will:\n\n- Show the result of the transaction.\n\nUpdate the __HTML__ tab to:\n\n- List out the account balance.\n- Add buttons to:\n  - start another transaction, or\n  - print a receipt and exit the ATM (`printReceiptAndExit` will be implemented in the next section).\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" on:enter=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\ton:enter=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" on:click=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li on:click=\"chooseDeposit()\">Deposit</li>\n                <li on:click=\"chooseWithdraw()\">Withdraw</li>\n                <li on:click=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"https://canjs.com/docs/images/loader.gif\"/>\n                    Loading Accounts…\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li on:click=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" value:bind=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button on:click=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" on:click=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n        <h2>Withdraw</h2>\n    \t<p>\n    \t\tHow much would you like to withdraw\n    \t\tfrom {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"withdrawl\" value:bind=\"currentTransaction.amount\"/>\n    \t</p>\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button on:click=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tWithdraw\n    \t\t</button>\n    \t\t<a href=\"javascript://\" on:click=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n        <p>\n    \t\t{{currentTransaction.account.name}} has\n    \t\t${{currentTransaction.account.balance}}.\n    \t</p>\n    \t<p>What would you like to do?</p>\n    \t<nav>\n    \t\t<ul>\n    \t\t\t<li on:click=\"removeTransaction()\">Another transaction</li>\n    \t\t\t<li on:click=\"printReceiptAndExit()\">Exit</li>\n    \t\t</ul>\n    \t</nav>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"https://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='134-144,only'></span>\nWhen complete, you should be able to make a deposit or withdrawal, see the updated account balance,\nthen start another transaction.\n\n## Printing Recipe page and test\n\nIn this section, we will make it possible to:\n\n - See a receipt of all transactions\n - Exit the ATM.  \n\nUpdate the __HTML__ tab to:\n\n - List out all the transactions the user has completed.\n - List out the final value of all accounts.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" on:enter=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\ton:enter=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" on:click=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li on:click=\"chooseDeposit()\">Deposit</li>\n                <li on:click=\"chooseWithdraw()\">Withdraw</li>\n                <li on:click=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"https://canjs.com/docs/images/loader.gif\"/>\n                    Loading Accounts…\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li on:click=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" value:bind=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button on:click=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" on:click=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n        <h2>Withdraw</h2>\n    \t<p>\n    \t\tHow much would you like to withdraw\n    \t\tfrom {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"withdrawl\" value:bind=\"currentTransaction.amount\"/>\n    \t</p>\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button on:click=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tWithdraw\n    \t\t</button>\n    \t\t<a href=\"javascript://\" on:click=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n        <p>\n    \t\t{{currentTransaction.account.name}} has\n    \t\t${{currentTransaction.account.balance}}.\n    \t</p>\n    \t<p>What would you like to do?</p>\n    \t<nav>\n    \t\t<ul>\n    \t\t\t<li on:click=\"removeTransaction()\">Another transaction</li>\n    \t\t\t<li on:click=\"printReceiptAndExit()\">Exit</li>\n    \t\t</ul>\n    \t</nav>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    \t<h3>Transactions</h3>\n    \t<ul>\n    \t\t{{#if transactions.length}}\n    \t\t\t{{#each transactions}}\n    \t\t\t\t<li>{{actionName(this)}} ${{amount}} {{actionPrep(this)}} {{account.name}}</li>\n    \t\t\t{{/each}}\n    \t\t{{else}}\n    \t\t\t<li>None</li>\n    \t\t{{/if}}\n    \t</ul>\n    \t<h3>Accounts</h3>\n    \t<ul>\n    \t\t{{#each accountsPromise.value}}\n    \t\t\t<li on:click=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n    \t\t{{/each}}\n    \t</ul>\n    \t<div class='warn'>\n    \t\t<p>\n    \t\t\t<img src=\"https://canjs.com/docs/images/loader.gif\"/>\n    \t\t\tprinting\n    \t\t</p>\n    \t</div>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"https://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='149-170,only'></span>\nUpdate the `ATM` view model in the `JavaScript` tab to:\n\n - Add a `printingReceipt` and `receiptTime` property.\n - Change the `state` to `\"printingReceipt\"` when `printingReceipt` is true.\n - Make `.exit` set `printingReceipt` to `null`.\n - Add a `printReceiptAndExit` method that:\n   - clears the current transaction, which will add the currentTransaction to the list of transactions.\n   - sets `printingReceipt` to `true` for `printingReceipt` time.\n\n\nUpdate the `ATM basics` test in the `JavaScript` tab to:\n\n- Shorten the default `receiptTime` so the tests move quickly.\n- Call `printReceiptAndExit` and make sure that the `state` changes to `\"printingReceipt\"` and\n  then to `\"readingCard\"` and ensure that sensitive information is cleared from the ATM.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\tprintingReceipt: \"boolean\",\n\treceiptTime: {\n\t\tvalue: 5000,\n\t\ttype: \"number\"\n\t},\n\n\t// derived properties\n\tget state(){\n\t\tif (this.printingReceipt) {\n\t\t\treturn \"printingReceipt\";\n\t\t}\n\t\tif (this.currentTransaction) {\n\t\t\tif (this.currentTransaction.state === \"executed\") {\n\t\t\t\treturn \"successfulTransaction\";\n\t\t\t}\n\n\t\t\tif (this.currentTransaction.account) {\n\t\t\t\tif (this.currentTransaction instanceof Deposit) {\n\t\t\t\t\treturn \"depositInfo\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"withdrawalInfo\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null,\n\t\t\tprintingReceipt: null\n\t\t});\n\t},\n\tprintReceiptAndExit: function() {\n\t\tthis.currentTransaction = null;\n\t\tthis.printingReceipt = true;\n\t\tvar self = this;\n\t\tsetTimeout(function() {\n\t\t\tself.exit();\n\t\t}, this.receiptTime);\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseAccount: function(account) {\n\t\tthis.currentTransaction.account = account;\n\t},\n\tremoveTransaction: function() {\n\t\tthis.currentTransaction = null;\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tatm.accountsPromise.then(function(accounts){\n\t\t\t\tatm.chooseAccount(accounts[0]);\n\t\t\t});\n\n\t\t} else if (newVal === \"depositInfo\") {\n\n\t\t\tQUnit.ok(true, \"in depositInfo state\");\n\t\t\tvar currentTransaction = atm.currentTransaction;\n\t\t\tcurrentTransaction.amount = 120;\n\t\t\tQUnit.ok(currentTransaction.ready, \"we are ready to execute\");\n\t\t\tcurrentTransaction.execute();\n\t\t\tQUnit.equal(atm.state, \"depositInfo\", \"in deposit state until successful\");\n\n\t\t} else if (newVal === \"successfulTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in successfulTransaction state\");\n\t\t\tatm.receiptTime = 100;\n\t\t\tatm.printReceiptAndExit();\n\n\t\t} else if (newVal === \"printingReceipt\") {\n\n\t\t\tQUnit.ok(true, \"in printingReceipt state\");\n\n\t\t} else if (newVal === \"readingCard\") {\n\n\t\t\tQUnit.ok(true, \"in readingCard state\");\n\t\t\tQUnit.ok(!atm.card, \"card is removed\");\n\t\t\tQUnit.ok(!atm.transactions, \"transactions removed\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='189,205-209,213-215,263,266-273,397,437-451,only'></span>\nWhen complete, you have a working ATM!  Cha-ching!\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "\nThis guide will walk you through __building__ and __testing__ an Automated Teller Machine (ATM) application with CanJS’s\n[can-core Core libraries].  You’ll learn how to do test driven development (TDD)\nand manage complex state.  It takes about 2 hours to complete.\n",
    "name": "guides/atm",
    "title": "ATM Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 3,
    "comment": " "
  },
  "guides/todomvc": {
    "src": {
      "path": "docs/can-guides/experiment/todomvc/todomvc.md"
    },
    "body": "\n## Setup\n\nThe easiest way to get started is to clone the following JS&nbsp;Bin by clicking the __JS&nbsp;Bin__ button on the top left:\n\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/sasuje/11/embed?html,output\">JS Bin on jsbin.com</a>\n\nThe JS Bin starts\nwith the static HTML and CSS a designer might turn over to a JS developer. We will be\nadding all the JavaScript functionality.\n\nThe JS Bin also loads [can.all.js](https://unpkg.com/can@3/dist/global/can.all.js), which is a script that includes all of CanJS core, ecosystem, legacy and infrastructure libraries under a\nsingle global `can` namespace.\n\nGenerally speaking, you should not use the global `can` script, but instead you\nshould import things directly with a module loader like [StealJS](https://stealjs.com),\nWebPack or Browserify.  In a real app, your code will look like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({ ... });\nTodo.List = DefineList.extend({ ... });\n```\n\nNot:\n\n```js\nvar Todo = can.DefineMap.extend({ ... });\nTodo.List = can.DefineList.extend({ ... });\n```\n\nRead [guides/setup] for instructions on how to set up CanJS in a real app.\n\n## Create and render the template\n\nIn this section, we will render the markup in a [can-stache] live-bound template.  \n\nUpdate the __HTML__ tab to have a `<script>` tag around the html content.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 Start\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n\t\t\t<li class=\"todo\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Do the dishes</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Do the dishes\">\n\t\t\t</li>\n\t\t\t<li class=\"todo completed\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Mow the lawn</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Mow the lawn\">\n\t\t\t</li>\n\t\t\t<li class=\"todo editing\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Pick up dry cleaning</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Pick up dry cleaning\">\n\t\t\t</li>\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>2</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed (1)\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='11,67,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Use [can-stache.from can-stache.from] to load the contents of the `<script>` tag as\n a [can-stache.renderer template renderer function].\n - Render the template with an empty object into a [document fragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment).\n - Insert the fragment into the document’s `<body>` element.\n\nTo load, render, and add this template to the\nbody, add the following to the `JavaScript` tab:\n\n\n```js\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-3,only'></span>\n\nWhen complete, you should see the same content as before.  Only now, it’s\nrendered with a live-bound stache template.  The live binding means that\nwhen the template’s data is changed, it will update automatically. We’ll see\nthat in the next step.\n\n\n## Define the todos type and show the active and complete count\n\nIn this section, we will:\n\n - Create a list of todos and show them.\n - Show the number of active (`complete === true`) and complete todos.\n - Connect a todo’s `complete` property to a checkbox so that when\n   we toggle the checkbox the number of active and complete todos changes.\n\n\nUpdate the `JavaScript` tab to:\n\n - Define a `Todo` type with [can-define/map/map].\n - Define a `Todo.List` type along with an `active` and `complete` property with [can-define/list/list].\n - Create a list of todos and pass those to the template.\n\n\n```js\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\nvar todos = new Todo.List([\n  { id: 5, name: \"mow lawn\", complete: false },\n  { id: 6, name: \"dishes\", complete: true },\n  { id: 7, name: \"learn canjs\", complete: false }\n]);\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todos: todos});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-21,24,only'></span>\nUpdate the __HTML__ tab to:\n\n- Use [can-stache.helpers.each `{{#each todos}}`] to loop through every todo.\n- Add `completed` to the `<li>`’s `className` if the `<li>`’s todo is complete.\n- Use [can-stache-bindings.twoWay `checked:bind`] to two-way bind the checkbox’s `checked` property to its todo’s `complete` property.  \n- Use [can-stache.tags.escaped `{{name}}`] to insert the value todo’s `name` as the content of the `<label>` and\n  `value` of the text `<input/>`.\n- Insert the active and complete number of todos.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create and render the template\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todos}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" checked:bind=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todos.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todos.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='21-30,35,49,only'></span>\nWhen complete, you should be able to toggle the checkboxes and see the number of\nitems left and the completed count change automatically.  This is because\n[can-stache] is able to listen for changes in observables like [can-define/map/map],\n[can-define/list/list] and [can-compute].\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/2-items-left/completed.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/2-items-left/completed.webm\" type=\"video/webm\">\n</video>\n\n\n## Get todos from the server\n\nIn this section, we will:\n\n - Load todos from a RESTful service.\n - Fake that RESTful service.\n\n\nUpdate the `JavaScript` tab to:\n\n- Define what the RESTful service layer’s parameters are with [can-set.Algebra can-set.Algebra].\n- Create a fake data store that is initialized with data for 3 todos with [can-fixture.store].\n- Trap AJAX requests to `\"/api/todos\"` and provide responses with the data from the fake data store with [can-fixture].\n- Connect the `Todo` and `Todo.List` types to the RESTful `\"/api/todos\"` endpoint using [can-connect/can/super-map/super-map].  This allows you to load, create, update, and destroy todos\non the server.\n- Use [can-connect/can/map/map.getList] to load a list of all todos on the server. The result\n  of `getList` is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves to a `Todo.List` with the todos returned from the fake data store.  That `Promise`\n  is passed to the template as `todosPromise`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-15,33-39,42,only'></span>\nUpdate the __HTML__ tab to:\n\n - Use [can-stache.helpers.each `{{#each todosPromise.value}}`] to loop through the promise’s resolved value, which\n   is the list of todos returned by the server.\n - Read the active and completed number of todos from the promise’s resolved value.\n\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create the todos type and get items left working\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" checked:bind=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='21,35,49,only'></span>\nWhen complete, you’ll notice a 1 second delay before seeing the list of todos as\nthey load for the first time from the fixtured data store. On future page reloads, the\nlist of todos will load immediately.  This is because [can-connect/can/super-map/super-map] adds the [can-connect/fall-through-cache/fall-through-cache] behavior.  The\n[can-connect/fall-through-cache/fall-through-cache] behavior stores loaded data in\n`localStorage`.  Future requests will hit `localStorage` for data first and present that data\nto the user before making a request to the server and updating the original data with\nany changes.  Use `localStorage.clear()` to see the difference.\n\n\n## Destroy todos\n\nIn this section, we will:\n\n - Delete a todo on the server when its destroy button is clicked.\n - Remove the todo from the page after it’s deleted.\n\nUpdate the __HTML__ tab to:\n\n - Add `destroying` to the `<li>`’s `className` if the `<li>`’s todo is being destroyed using [can-connect/can/map/map.prototype.isDestroying].\n - Call the `todo`’s [can-connect/can/map/map.prototype.destroy] method when the `<button>` is clicked using [can-stache-bindings.event `on:click`].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Destroy todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\n                    {{#if isDestroying}}destroying{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" checked:bind=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\" on:click=\"destroy()\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='22-23,27,only'></span>\nWhen complete, you should be able to delete a todo by clicking its delete button.  After\nclicking the todo, its name will turn red and italic.  Once deleted, the todo will be\nautomatically removed from the page.  \n\nThe deleted todo is automatically removed from the page because [can-connect/can/super-map/super-map] adds the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically updates lists (like `Todo.List`) when instances\nare created, updated or destroyed.  If you’ve created the right [can-set.Algebra], you\nshouldn’t have to manage lists yourself.\n\nFinally, if you click “Run with JS” after deleting a todo, you’ll notice the page temporarily shows fewer items.\nThis is because the fall-through cache’s data is shown before the response from fixtured data store\nis used.\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/4-destroy/completed.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/4-destroy/completed.webm\" type=\"video/webm\">\n</video>\n\n## Create todos\n\nIn this section, we will:\n\n - Create a custom element that can create todos on the server.\n - Use that custom element.\n\nUpdate the `JavaScript` tab to:\n\n - Use [can-define/map/map] to create a `TodoCreateVM` view model with:\n   - A `todo` property that holds a new `Todo` instance.\n   - A `createTodo` method that [can-connect/can/map/map.prototype.save]s the `Todo` instance\n     and replaces it with a new one once saved.\n - Use [can-component] to create a custom `<todo-create>` component that renders the `todo-create-template` template with an instance of the `TodoCreateVM`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n    todo: {Value: Todo},\n    createTodo: function(){\n        this.todo.save().then(function(){\n            this.todo = new Todo();\n        }.bind(this));\n    }\n});\n\ncan.Component.extend({\n    tag: \"todo-create\",\n    view: can.stache.from(\"todo-create-template\"),\n    ViewModel: TodoCreateVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='42-55,only'></span>\nUpdate the __HTML__ tab to:\n\n - Create the `todo-create-template` that:\n   - Updates the `todo`’s `name` with the `<input>`’s `value` using [can-stache-bindings.twoWay `value:bind`].\n   - Calls `createTodo` when the `enter` key is pressed using [can-stache-bindings.event `on:enter`].\n - Use `<todo-create/>`\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    value:bind=\"todo.name\"\n    on:enter=\"createTodo()\"/>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\n                    {{#if isDestroying}}destroying{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" checked:bind=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\" on:click=\"destroy()\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='11-16,22,only'></span>\nWhen complete, you will be able to create a todo by typing the name of the todo and pressing\n`enter`. Notice that the new todo automatically appears in the list of todos. This\nis also because [can-connect/can/super-map/super-map] adds the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically inserts newly created items into\nlists that they belong within.\n\n\n## List todos\n\nIn this section, we will:\n\n - Define a custom element for showing a list of todos.\n - Use that custom element by passing it the list of fetched todos.\n\nUpdate the `JavaScript` tab to:\n\n - Create a `TodoListVM` view model type which has a `todos` property of type `Todo.List`.\n - Use [can-component] to define a `<todo-list>` element.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List\n});\n\ncan.Component.extend({\n    tag: \"todo-list\",\n    view: can.stache.from(\"todo-list-template\"),\n    ViewModel: TodoListVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='56-64,only'></span>\nUpdate the __HTML__ tab to:\n\n - Create the `todo-list-template` that loops through a list of `todos` (instead of `todosPromise.value`).\n - Create a `<todo-list>` element and set its `todos` property to the resolved value of `todosPromise`\n   using [can-stache-bindings.toChild `{todos}`].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - List todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\">\n    value:bind=\"todo.name\"\n    on:enter=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\">\n      <div class=\"view\">\n        <input class=\"toggle\" type=\"checkbox\" checked:bind=\"complete\">\n        <label>{{name}}</label>\n        <button class=\"destroy\" on:click=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list todos:from=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='18-32,43,only'></span>\nWhen complete, everything should work the same. We didn’t add any new functionality, we\njust moved code around to make it more isolated, potentially reusable, and more maintainable.\n\n\n## Edit todos\n\nIn this section, we will:\n\n - Make it possible to edit a todo’s `name` and save that change to the server.\n\nUpdate the `JavaScript` tab to:\n\n - Update the `TodoListVM` to include the methods and properties needed to edit a todo’s name, including:\n   - An `editing` property of type `Todo` that stores which todo is being edited.\n   - A `backupName` property that stores the todo’s name before being edited.\n   - An `edit` method that sets up the editing state.\n   - A `cancelEdit` method that undos the editing state if in the editing state.\n   - An `updateName` method that updates the editing todo and [can-connect/can/map/map.prototype.save saves] it to the server.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='58-76,only'></span>\n\nUpdate the __HTML__ tab to:\n\n - Use the `isEditing` method to add `editing` to the `className` of the `<li>` being edited.\n - When the checkbox changes, update the todo on the server with [can-connect/can/map/map.prototype.save],\n - Call `edit` with the current context using [can-stache/keys/this].\n - Set up the edit input to:\n   - Two-way bind its value to the current todo’s `name` using [can-stache-bindings.twoWay `value:bind`].\n   - Call `updateName` when the enter key is pressed using [can-stache-bindings.event `on:enter`].\n   - Focus the input when `isEditing` is true using the special [can-util/dom/attr/attr.special.focused] attribute.\n   - Call `cancelEdit` if the input element loses focus.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - List todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    value:bind=\"todo.name\"\n    on:enter=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   checked:bind=\"complete\" on:change=\"save()\">\n        <label on:dblclick=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" on:click=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        value:bind=\"name\"\n        on:enter=\"updateName()\"\n        focused:from=\"isEditing(this)\"\n        on:blur=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list todos:from=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='22-23,25-27,30-34,only'></span>\nWhen complete, you should be able to edit a todo’s name.\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/7-edit/edit.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/7-edit/edit.webm\" type=\"video/webm\">\n</video>\n\n## Routing\n\nIn this section, we will:\n\n - Make it possible to use the browser’s forwards and backwards buttons to change\n between showing all todos, only active todos, or only completed todos.\n - Add links to change between showing all todos, only active todos, or only completed todos.\n - Make those links bold when the site is currently showing that link.\n\n\nUpdate the `JavaScript` tab to:\n\n - Create a `AppVM` view model type that will manage the behavior of the `todomvc-template` and\n   will update when the url changes.\n   - Define a `filter` property that will be updated when the route changes.\n   - Define a `route` property that will be updated when the route changes.\n   - Define a `todosPromise` property that uses `filter` to determine what data should be\n   loaded from the server.  \n     - If `filter` is falsey, all data will be loaded.  \n     - If `filter` is `\"complete\"`, only complete todos will be loaded.\n     - If `filter` is any other value, the active todos will be loaded.\n - Create an instance of the application view model (`appVM`).\n - Connect changes in the url to changes in the `appVM` with [can-route.data].\n - Create a pretty routing rule so if the url looks like `\"#!active\"`, the `filter` property of\n   `appVM` will be set to `filter` with [can-route].\n - Initialize the url’s values on `appVM` and set up the two-way connection with [can-route.ready].\n - Render the `todomvc-template` with the `appVM`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false})\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar AppVM = can.DefineMap.extend({\n  filter: \"string\",\n  get todosPromise(){\n    if(!this.filter) {\n      return Todo.getList({});\n    } else {\n      return Todo.getList({complete: this.filter === \"complete\"});\n    }\n  }\n});\n\nvar appVM = new AppVM();\ncan.route.data = appVM;\ncan.route(\"{filter}\");\ncan.route.ready();\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='85-99,102,only'></span>\nUpdate the __HTML__ tab to:\n\n - Set `href` to a url that will set the desired properties on `appVM` when clicked.\n - Add `class='selected'` to the link if the current route matches the current properties of the `appVM` using [can-stache.helpers.routeCurrent].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    value:bind=\"todo.name\"\n    on:enter=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   checked:bind=\"complete\" on:change=\"save()\">\n        <label on:dblclick=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" on:click=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        value:bind=\"name\"\n        on:enter=\"updateName()\"\n        focused:from=\"isEditing(this)\"\n        on:blur=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list todos:from=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter=undefined}}\"\n\t\t\t\t\t{{#routeCurrent filter=undefined}}class='selected'{{/routeCurrent}}>All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='active'}}\"\n\t\t\t\t\t{{#routeCurrent filter='active'}}class='selected'{{/routeCurrent}}>Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='complete'}}\"\n\t\t\t\t\t{{#routeCurrent filter='complete'}}class='selected'{{/routeCurrent}}>Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='57-58,61-62,65-66,only'></span>\nWhen complete, you should be able to click the `All`, `Active`, and `Completed` links and\nsee the right data.  When you click from `All` to `Active` or from `All` to `Completed`,\nyou’ll notice that the list of todos is updated immediately, despite a request being made.\nThis is because the [can-connect/fall-through-cache/fall-through-cache] is able to make use\nof the data loaded for the `All` todos page.  It’s able to filter out the `Active` and\n`Completed` data.\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/8-routing/routing.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/8-routing/routing.webm\" type=\"video/webm\">\n</video>\n\n## Toggle all and clear completed\n\nIn this section, we will:\n\n- Make the `toggle-all` button change all todos to complete or incomplete.\n- Make the `clear-completed` button delete all complete todos.\n\nUpdate the `JavaScript` tab to:\n\n- Add the following properties and methods to `Todo.List`:\n  - An `allComplete` property that returns `true` if every todo is complete.\n  - A `saving` property that returns todos that are being saved using [can-connect/can/map/map.prototype.isSaving].\n  - An `updateCompleteTo` method that updates every todo’s `complete` property to the specified value and updates the compute on the server with [can-connect/can/map/map.prototype.save].\n  - A `destroyComplete` method that deletes every complete todo with [can-connect/can/map/map.prototype.destroy].\n- Adds the following properties to `AppVM`:\n  - A `todosList` property that gets its value from the `todosPromise` using an [can-define.types.get asynchronous getter].\n  - An `allChecked` property that returns `true` if every todo is complete.  The property can also be set to `true` or `false` and it will set every todo to that value.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  },\n  get allComplete(){\n    return this.length === this.complete.length;\n  },\n  get saving(){\n    return this.filter(function(todo){\n      return todo.isSaving();\n    });\n  },\n  updateCompleteTo: function(value){\n    this.forEach(function(todo){\n      todo.complete = value;\n      todo.save();\n    });\n  },\n  destroyComplete: function(){\n    this.complete.forEach(function(todo){\n      todo.destroy();\n    });\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar AppVM = can.DefineMap.extend({\n  filter: \"string\",\n  get todosPromise(){\n    if(!this.filter) {\n      return Todo.getList({});\n    } else {\n      return Todo.getList({complete: this.filter === \"complete\"});\n    }\n  },\n  todosList: {\n    get: function(lastSetValue, resolve){\n      this.todosPromise.then(resolve);\n    }\n  },\n  get allChecked(){\n    return this.todosList && this.todosList.allComplete;\n  },\n  set allChecked(newVal){\n    this.todosList && this.todosList.updateCompleteTo(newVal);\n  }\n});\n\nvar appVM = new AppVM();\ncan.route.data = appVM;\ncan.route(\"{filter}\");\ncan.route.ready();\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='31-49,113-123,only'></span>\nUpdate the __HTML__ tab to:\n\n- Cross bind the `toggle-all`’s `checked` property to the `appVM`’s `allChecked` property.\n- Disable the `toggle-all` button while any todo is saving.\n- Call the `Todo.List`’s `destroyComplete` method when the `clear-completed` button is clicked on.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    value:bind=\"todo.name\"\n    on:enter=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if ./complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   checked:bind=\"complete\" on:change=\"save()\">\n        <label on:dblclick=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" on:click=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        value:bind=\"name\"\n        on:enter=\"updateName()\"\n        focused:from=\"isEditing(this)\"\n        on:blur=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\"\n          checked:bind=\"allChecked\"\n          disabled:from=\"todosList.saving.length\"/>\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list todos:from=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter=undefined}}\"\n\t\t\t\t\t{{#routeCurrent filter=undefined}}class='selected'{{/routeCurrent}}>All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='active'}}\"\n\t\t\t\t\t{{#routeCurrent filter='active'}}class='selected'{{/routeCurrent}}>Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='complete'}}\"\n\t\t\t\t\t{{#routeCurrent filter='complete'}}class='selected'{{/routeCurrent}}>Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\"\n            on:click=\"todosList.destroyComplete()\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='47-49,71-72,only'></span>\nWhen complete, you should be able to toggle all todos `complete` state and\ndelete the completed todos.  You should also have a really good idea how CanJS works!\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/9-toggle/toggle.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/9-toggle/toggle.webm\" type=\"video/webm\">\n</video>\n\n## Result\n\nWhen finished, you should see something like the following JS&nbsp;Bin:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/tibana/2/embed?html,js,output\">JS Bin on jsbin.com</a>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "This guide will walk you through building a slightly modified version of [TodoMVC](http://todomvc.com/) with CanJS’s [can-core Core libraries] and [can-fixture]. It takes about 1 hour to complete.\n\n",
    "name": "guides/todomvc",
    "title": "TodoMVC Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 2,
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "guides/chat": {
    "src": {
      "path": "docs/can-guides/experiment/chat/chat.md"
    },
    "body": "\n## Setup\n\nThe easiest way to get started is to clone the following JS&nbsp;Bin by clicking the __JS&nbsp;Bin__ button on the top left:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/weganur/1/edit?html,output\">JS Bin on jsbin.com</a>\n\nThe JS Bin loads [https://getbootstrap.com/ Bootstrap] for its styles and [https://socket.io/ socket.io] for a socket\nlibrary.  It will be connecting to a RESTful and real-time service layer at [https://chat.donejs.com/api/messages].\n\nThe JS Bin also loads [can.js](https://unpkg.com/can@3/dist/global/can.js), which is a script that includes all of CanJS core under a\nsingle global `can` namespace.\n\nGenerally speaking, you should not use the global `can` script, but instead you\nshould import things directly with a module loader like [StealJS](https://stealjs.com),\nWebPack or Browserify.  In a real app, your code will look like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Message = DefineMap.extend({ ... });\nMessage.List = DefineList.extend({ ... });\n```\n\nNot:\n\n```js\nvar Message = can.DefineMap.extend({ ... });\nMessage.List = can.DefineList.extend({ ... });\n```\n\nRead [guides/setup] for instructions on how to set up CanJS in a real app.\nCheck out [https://donejs.com/Guide.html the DoneJS version of this guide].\n\n\n\n## Hello World\n\nIn this section, we will:\n\n - Show a big “Chat Home” title within a Bootstrap container.\n - Make it so when “Chat Home” is clicked, an exclamation mark (“!”) is added to the end of the title.\n\nIn your JS Bin, update the __HTML__ tab to:\n\n - Create a `<script>` tag containing the contents of the `chat-template` template.\n - Have the content insert a `message` value within a responsive Bootstrap container using [can-stache.tags.escaped].\n - Listen for `click` events and call `addExcitement` with [can-stache-bindings.event].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Hello World\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  <h1 class=\"page-header text-center\" on:click=\"addExcitement()\">\n        {{message}}\n      </h1>\n    </div>\n  </div>\n</div>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='12-22,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Define an application view-model (`AppVM`) type by extending [can-define/map/map]. Its definition includes:\n   - A `message` property that is a [can-define.types string]\n     value [can-define.types.value initialized] to `\"Chat Home\"`.\n   - An `addExcitement` method that adds `\"!\"` to the end of the `message` property.\n - Create an instance of the `AppVM` type (`appVM`).\n - Compile a [can-stache] [can-stache.renderer template renderer] function from the contents of the `<script>` tag.\n - Render that template with `appVM` as a source of data into a [https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment document fragment].\n - Insert the document fragment into the `<body>` tag.\n\n\n```js\nvar AppVM = can.DefineMap.extend({\n\tmessage: {\n\t\ttype: \"string\",\n\t\tvalue: \"Chat Home\"\n\t},\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-15,only'></span>\nWhen complete, you should see a large “Chat Home” title in the `Output` panel.  Click on it and\nthings will get really exciting!\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/chat/1-hello-world/completed.webm\" type=\"video/webm\">\n   <source src=\"../../docs/can-guides/experiment/chat/1-hello-world/completed.ogg\" type=\"video/ogg\">\n</video>\n\nThis step sets up the essential basics of a CanJS application — a\n[can-stache] template rendered with an observable application view model instance.\n\nThe properties and methods the template uses are defined in the `AppVM`\ntype.  The `AppVM` type extends [can-define/map/map].  We\ndefined a `message` and an `addExcitement` method.\n\nWe then created an instance of the `appVM` with the `new` operator. This created\nan object with a `message` property and `addExcitement` method.  For example, adding:\n\n```\nconsole.log(appVM.message)\nappVM.addExcitement();\nconsole.log(appVM.message)\n```\n\nWill print out `\"Chat Home\"` and then `\"Chat Home!\"`.\n\n`DefineMap` instances are observable.  This is why when `message` changes,\nthe template updates automatically.\n\nThe templates are a dialect of [mustache](https://github.com/janl/mustache.js) and [handlebars](https://github.com/wycats/handlebars.js/) syntax.  The\nmustache syntax allows a very terse writing style for the most common\npatterns within templates:\n\n - inserting data with [can-stache.tags.escaped]\n - looping with [can-stache.helpers.each]\n - branching with [can-stache.helpers.if] or [can-stache.helpers.is]\n\n\n\n> __Key take-away:__ You define types like `AppVM` with method and property behaviors.\n> Instances of those types are observable by [can-stache] templates.\n\n\n## Route between two pages\n\nIn this section we will:\n\n - Create a __home page__ and __chat messages page__ that the user can navigate between\n   with links and the browser’s back and forward button.\n\nUpdate the __HTML__ tab to:\n\n - Check if the `appVM`’s `page` property is `\"home\"`.  If it is, render the __home\n   page__’s content.  If it’s not, it will render the __chat messages page__’s content with the [can-stache.helpers.else] helper.\n - Use [can-stache.helpers.routeUrl] to create the right link urls so that `page`\n   will be set on `appVM` to either `\"home\"` or `\"chat\"`.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" on:click=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t  \t <h1 class=\"page-header text-center\">\n\t\t \tChat Messages\n\t\t </h1>\n\t\t <h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='16-29,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Add a `page` property that will be updated when the browser’s URL changes.\n - Prevent the `message` property from becoming part of the URL changes by using `serialize: false`.\n - Connect changes in the url to changes in the `appVM` with [can-route.data].\n - Create a pretty routing rule so if the url looks like `\"#!chat\"`, the `page` property of\n   `appVM` will be set to `chat` with [can-route].  If there is nothing in the hash, `page`\n   will be set to `\"home\"`.\n - Initialize the url’s values on `appVM` and set up the two-way connection with [can-route.ready].\n\n\n```js\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\"{page}\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='2,6,15-17,only'></span>\nWhen complete, you should be able to toggle between the two pages.  If you type:\n\n```\nwindow.location.hash\n```\n\nin JS Bin’s console tab after clicking a new page, you will be able to see the hash change between `!#` and `#!chat`.\n\n\nThis step sets up basic routing between different “pages” in an application.\nCanJS’s routing is based on the properties in the application view model.  When\nthose properties change, different content is shown.  \n\nWe connected the application view model to the routing system with [can-route.data can-route.data]\nand initialized that connection with [can-route.ready can-route.ready].\n\nThis makes it so if the `page` property changes, the browser’s url will change.  If the\nbrowser’s url changes, the `page` property changes.  \n\n> __Key take-away:__  [can-route] two-way binds changes in the browser’s url to\nthe application view model and vice versa.  Use changes in\nthe application view model to control which content is shown.\n\n\n## Chat Messages Component\n\nIn this section, we will:\n\n- Define and use a custom `<chat-message>` element that contains the behavior of the __chat messages page__.\n\nUpdate the __HTML__ tab to:\n\n- Use the `<chat-messages/>` element.\n- Create a template for the `<chat-messages/>` element that contains the content of the\n  __chat messages page__.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Chat Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" on:click=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='25,32-37,only'></span>\nUpdate the `JavaScript` tab to:\n\n- Define a view model for the custom element (`ChatMessagesVM`).\n- Use [can-component] to define a custom element that will render its `view` template with\n  an instance of its `ViewModel`.\n\n\n```js\nvar ChatMessagesVM = can.DefineMap.extend({\n\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    route: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\"{page}\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-9,only'></span>\nWhen complete, you should see the same behavior as the previous step. You should\nbe able to click back and forth between the two different pages.\n\n\nThis step creates the `<chat-messages>` custom element.  Custom elements are used\nto represent some grouping of related (and typically visual) functionality such as:\n\n - Widgets like `<my-slider>` or `<acme-navigation>`.\n - Pages like `<chat-login>` or `<chat-messages>`.\n\nCustom elements are the macroscopic building blocks of an application.  They\nare the [orchestration pieces](https://en.wikipedia.org/wiki/Orchestration_(computing))\nused to assemble the application into a whole.  \n\nFor example, an application’s template might assemble many custom elements\nto work together like:\n\n```html\n{{#if session}}\n  <app-toolbar selectedFiles:bind=\"selectedFiles\"/>\n  <app-directory selectedFiles:bind=\"selectedFiles\"/>\n  <app-files selectedFiles:bind=\"selectedFiles\"/>\n  <app-file-details selectedFiles:bind=\"selectedFiles\"/>\n{{else}}\n  <app-login/>\n{{/if}}\n```\n\nBreaking down an application into many isolated and potentially reusable components\nis a critical piece of CanJS software architecture.\n\nCustom elements are defined with [can-component].  Components render their `view`\nwith a `ViewModel` instance.  By default, their `view` only\nhas access to the data in the `ViewModel`.  You can use [can-stache-bindings event and data bindings]\nlike [can-stache-bindings.toChild] and [can-stache-bindings.twoWay] to pass data\nbetween custom elements.\n\n> __Key take-away:__  [can-component] makes custom elements. Break down your application\ninto many bite-sized custom elements.\n\n## List Messages\n\nIn this section, we will:\n\n - Display messages from [https://chat.donejs.com/api/messages](https://chat.donejs.com/api/messages) when `messagesPromise.isResolved`.\n - Show a “Loading…” message while the messages are loading (`messagesPromise.isPending`).\n - Show an error if those messages fail to load (`messagesPromise.isRejected`).\n\nUpdate the __HTML__ tab to:\n\n - Check if the messages are in the process of loading and show a loading indicator.\n - Check if the messages failed to load and display the reason for the failure.\n - If messages successfully loaded, list each message’s name and body.  If there\n   are no messages, write out “No messages”.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - List Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" on:click=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\n{{#if messagesPromise.isPending}}\n  <div class=\"list-group-item list-group-item-info\">\n    <h4 class=\"list-group-item-heading\">Loading…</h4>\n  </div>\n{{/if}}\n{{#if messagesPromise.isRejected}}\n  <div class=\"list-group-item list-group-item-danger\">\n    <h4 class=\"list-group3--item-heading\">Error</h4>\n\t<p class=\"list-group-item-text\">{{messagesPromise.reason}}</p>\n  </div>\n{{/if}}\n{{#if messagesPromise.isResolved}}\n  {{#each messagesPromise.value}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group3--item-heading\">{{name}}</h4>\n  \t  <p class=\"list-group-item-text\">{{body}}</p>\n    </div>\n  {{else}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group-item-heading\">No messages</h4>\n    </div>\n  {{/each}}\n{{/if}}\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='38-60,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Define a `Message` type with [can-define/map/map].\n - Define a `Message.List` type that contains `Message` items.\n - Connect the `Message` and `Message.List` type to\n   the RESTful messages service at `https://chat.donejs.com/api/messages`\n   using [can-connect/can/super-map/super-map].\n - Create a `messagesPromise` property on `ChatMessagesVM` that’s\n   [can-define.types.value] is initialized to a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n   that represents the loading of all messages using [can-connect/can/map/map.getList].\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'https://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\"{page}\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-20,23-27,only'></span>\nWhen complete, you should see a list of messages in the __chat messages page__.\n\nThis step creates a `Message` model by first creating the `Message` type\nand then connecting it to a messages service at `https://chat.donejs.com/api/messages`.\n\n### Explanation\n\nThe [can-connect/can/super-map/super-map super-map module] adds [can-connect/can/map/map methods] to the `Message` type that let you:\n\n - Get a list of messages:\n   ```js\n   Message.getList({}).then(function(messages){})\n   ```\n\n - Get a single message:\n   ```js\n   Message.get({id: 5}).then(function(message){})\n   ```\n - Create a message on the server:\n   ```js\n   message = new Message({name: \"You\", body: \"Hello World\"})\n   message.save()\n   ```\n - Update a message on the server:\n   ```js\n   message.body = \"Welcome Earth!\";\n   message.save();\n   ```\n - Delete message on the server:\n   ```js\n   message.destroy();\n   ```\n\nThere are also methods to let you know when a message\n[can-connect/can/map/map.prototype.isNew],\n[can-connect/can/map/map.prototype.isSaving], and\n[can-connect/can/map/map.prototype.isDestroying].\n\nWith the message model created, it’s used to load and list messages on the server.\n\n\n> __Key take-away:__ Create a model for your data’s schema and use it to communicate with a backend server.\n\n## Create Messages\n\nIn this section, we will:\n\n- Add the ability to create messages on the server and have them added to the list of messages.\n\n\nUpdate the __HTML__ tab to:\n\n - Create a form to enter a message’s `name` and `body`.\n - When the form is submitted, call `send` on the `ChatMessagesVM` with [can-stache-bindings.event].\n - Connect the first `<input>`’s `value` to the `ChatMessagesVM`’s `name` property with [can-stache-bindings.twoWay].\n - Connect the second `<input>`’s `value` to the `ChatMessagesVM`’s `body` property with [can-stache-bindings.twoWay].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Create Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" on:click=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\n{{#if messagesPromise.isPending}}\n  <div class=\"list-group-item list-group-item-info\">\n    <h4 class=\"list-group-item-heading\">Loading…</h4>\n  </div>\n{{/if}}\n{{#if messagesPromise.isRejected}}\n  <div class=\"list-group-item list-group-item-danger\">\n    <h4 class=\"list-group3--item-heading\">Error</h4>\n\t<p class=\"list-group-item-text\">{{messagesPromise.reason}}</p>\n  </div>\n{{/if}}\n{{#if messagesPromise.isResolved}}\n  {{#each messagesPromise.value}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group3--item-heading\">{{name}}</h4>\n  \t  <p class=\"list-group-item-text\">{{body}}</p>\n    </div>\n  {{else}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group-item-heading\">No messages</h4>\n    </div>\n  {{/each}}\n{{/if}}\n\n<form class=\"row\" on:submit=\"send(%event)\">\n\t<div class=\"col-sm-3\">\n\t  <input type=\"text\" class=\"form-control\" placeholder=\"Your name\"\n\t\t\t value:bind=\"name\"/>\n\t</div>\n\t<div class=\"col-sm-6\">\n\t  <input type=\"text\" class=\"form-control\" placeholder=\"Your message\"\n\t\t\t value:bind=\"body\"/>\n\t</div>\n\t<div class=\"col-sm-3\">\n\t  <input type=\"submit\" class=\"btn btn-primary btn-block\" value=\"Send\"/>\n\t</div>\n</form>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='62-74,only'></span>\nUpdate the `JavaScript` tab to:\n\n- Define a `name` and `body` property on `ChatMessagesVM`.\n- Define a `send` method on `ChatMessagesVM` that creates a new `Message` and sends it to the server.\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'https://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t},\n\tname: \"string\",\n\tbody: \"string\",\n\tsend: function(event) {\n\t    event.preventDefault();\n\n\t\tnew Message({\n\t\t\tname: this.name,\n\t\t\tbody: this.body\n\t\t}).save().then(function(){\n\t\t\tthis.body = \"\";\n\t\t}.bind(this));\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\"{page}\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='28-39,only'></span>\nWhen complete, you will be able to create messages and have them appear in the list.\n\nThis step sets up a form to create a `Message` on the server.\nNotice that the new `Message` automatically appears in the list of messages. This\nis because [can-connect/can/super-map/super-map] adds the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically inserts newly created messages into\nlists that they belong within.  This is one of CanJS’s best features — automatic list management.\n\n> __Key take-away:__ CanJS will add, remove, and update lists for you automatically.\n\n## Real Time\n\nIn this section, we will:\n\n - Listen to messages created by other users and add them to the list of messages.\n\nUpdate the `JavaScript` tab to:\n\n- Create a [https://socket.io/] connection (`socket`).\n- Listen for when messages are created, updated, and destroyed, and call the\n  corresponding [can-connect/real-time/real-time] methods.\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'https://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar socket = io('https://chat.donejs.com');\n\nsocket.on('messages created', function(message){\n\tMessage.connection.createInstance(message);\n});\nsocket.on('messages updated', function(message){\n\tMessage.connection.updateInstance(message);\n});\nsocket.on('messages removed', function(message){\n\tMessage.connection.destroyInstance(message);\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t},\n\tname: \"string\",\n\tbody: \"string\",\n\tsend: function(event) {\n\t    event.preventDefault();\n\n\t\tnew Message({\n\t\t\tname: this.name,\n\t\t\tbody: this.body\n\t\t}).save().then(function(){\n\t\t\tthis.body = \"\";\n\t\t}.bind(this));\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\"{page}\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='22-32,only'></span>\nWhen complete, you can open up the same JS&nbsp;Bin in another window, create a\nmessage, and it will appear in the first JS&nbsp;Bin’s messages list.\n\nThis step connects to a [https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API WebSocket API]\nthat pushes messages when `Message`s are created, updated or destroyed. By calling the\n[can-connect/real-time/real-time] methods when these events happen, CanJS will automatically\nupdate the messages list.\n\n> __Key take-away:__ CanJS will add, remove, and update lists for you automatically.  It’s\nawesome!\n\n## Result\n\nWhen finished, you should see something like the following JS&nbsp;Bin:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/yexezu/5/embed?html,js,output\">JS Bin on jsbin.com</a>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.1\"></script>\n\n",
    "description": "This guide will walk you through building a real-time chat application with CanJS’s [can-core Core libraries].  It takes about 30 minutes to complete.\n\n",
    "name": "guides/chat",
    "title": "Chat Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 1,
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "can-connect-feathers/service/service.data-methods.destroyData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/data-methods.destroy-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-connect-feathers/service/service.data-methods.destroyData",
    "type": "function",
    "parent": "can-connect-feathers/service/service.data-methods",
    "signatures": [
      {
        "code": "destroyData(instanceData)",
        "description": "\n\nCalls the [can-connect-feathers/service/service.options.feathersService feathersService] `remove` method with the provided serialized `instanceData`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the deleted instance data.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the deleted instance data.\n"
    }
  },
  "can-connect-feathers/service/service.data-methods.getData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/data-methods.get-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-connect-feathers/service/service.data-methods.getData",
    "type": "function",
    "parent": "can-connect-feathers/service/service.data-methods",
    "signatures": [
      {
        "code": "getData(params)",
        "description": "\n\nCalls the [can-connect-feathers/service/service.options.feathersService feathersService] `get` method to retrieve instance data for the provided `params`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "A object that represents the set of data needed to be loaded."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance data."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "A object that represents the set of data needed to be loaded."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance data."
    }
  },
  "can-connect-feathers/service/service.data-methods.getListData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/data-methods.get-list-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "getListData",
    "name": "can-connect-feathers/service/service.data-methods.getListData",
    "type": "function",
    "parent": "can-connect-feathers/service/service.data-methods",
    "signatures": [
      {
        "code": "getListData(set)",
        "description": "\n\nCalls the [can-connect-feathers/service/service.options.feathersService feathersService] `find` method to retrieve list data for a particular `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded.  The `set` object is passed to the Feathers service's `find` method as the query params: `.find({query: set})`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the ListData format."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded.  The `set` object is passed to the Feathers service's `find` method as the query params: `.find({query: set})`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the ListData format."
    }
  },
  "can-connect-feathers/service/service.data-methods.createData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/data-methods.create-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-connect-feathers/service/service.data-methods.createData",
    "type": "function",
    "parent": "can-connect-feathers/service/service.data-methods",
    "signatures": [
      {
        "code": "createData(instanceData, cid)",
        "description": "\n\nUses the [can-connect-feathers/service/service.options.feathersService feathersService] `create` method with the provided serialized `instanceData`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "A unique id that represents the instance that is being created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the newly created instance data.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "A unique id that represents the instance that is being created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the newly created instance data.\n"
    }
  },
  "can-connect-feathers/service/service.data-methods.updateData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/data-methods.update-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "updateData",
    "name": "can-connect-feathers/service/service.data-methods.updateData",
    "type": "function",
    "parent": "can-connect-feathers/service/service.data-methods",
    "signatures": [
      {
        "code": "updateData(instanceData)",
        "description": "\n\nCalls the [can-connect-feathers/service/service.options.feathersService feathersService] `update` method with the provided serialized `instanceData`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the updated instance data.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the updated instance data.\n"
    }
  },
  "can-connect-feathers/service/service.options.feathersService": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/options.feathers-service.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "FeathersService",
        "description": "\n\nSpecifies a [FeathersClient](https://docs.feathersjs.com/clients/feathers.html) Service instance to use for the data connection.  See the [can-connect-feathers] page for an example Feathers Client configuration.\n\n```js\n// Bring in the feathersClient instance and setup a service.\nvar feathersClient = require('./feathers');\nvar todoService = feathersClient.service('/api/todos');\n\nconnect([\n  feathersService,\n  realtime\n], {\n  // Pass the service as the `feathersService` property\n  feathersService: todoService\n});\n```\n\nSee [can-connect-feathers/service/service] for a complete Todo Model example."
      }
    ],
    "title": "feathersService",
    "name": "can-connect-feathers/service/service.options.feathersService",
    "type": "property",
    "parent": "can-connect-feathers/service/service.options"
  },
  "can-connect-feathers/service/service.options": {
    "name": "can-connect-feathers/service/service.options",
    "title": "options",
    "type": "group",
    "parent": "can-connect-feathers/service/service",
    "description": "",
    "order": 0
  },
  "can-connect-feathers/service/service.data-methods": {
    "name": "can-connect-feathers/service/service.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect-feathers/service/service",
    "description": "",
    "order": 0
  },
  "can-connect-feathers/service/service": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/service.md"
    },
    "body": "\nThe `feathers-service` behavior maps can-connect's [can-connect/DataInterface] methods to FeathersJS's [Service Interface](https://docs.feathersjs.com/services/readme.html#service-methods) methods.\n\n``` \n| DataInterface method | Feathers method | HTTP method | Example Path |\n|----------------------|-----------------|-------------|--------------|\n| .getListData()       | .find()         | GET         | /todos       |\n| .getData()           | .get()          | GET         | /todos/{id}  |\n| .createData()        | .create()       | POST        | /todos       |\n| .updateData()        | .update()       | PUT         | /todos/{id}  |\n| not yet implemented  | .patch()        | PATCH       | /todos/{id}  |\n| .destroyData()       | .remove()       | DELETE      | /todos/{id}  | \n```\n\n## Use\n\nSetting up the Feathers Client is a prerequisite for using this behavior.  See the [can-connect-feathers] page for an example of a basic Feathers Client configuration.  With the Feathers client setup, it can be used with the `feathers-service` behavior as demonstrated in the example, below.  Also note that the [can-connect/real-time/real-time real-time] behavior is included to receive real-time push events from the server. \n\n```js\n// models/todo.js\nvar connect = require('can-connect');\nvar DefineMap = require('can-define/map/');\nvar DefineList = require('can-define/list/list');\nvar set = require(\"can-set\");\n\n// Bring in the feathers service behavior\nvar feathersServiceBehavior = require('can-connect-feathers/service');\nvar dataParse = require('can-connect/data/parse/');\nvar constructor = require('can-connect/constructor/');\nvar constructorStore = require('can-connect/constructor/store/');\nvar constructorCallbacksOnce = require('can-connect/constructor/callbacks-once/');\nvar canMap = require('can-connect/can/map/');\nvar canRef = require('can-connect/can/ref/');\nvar dataCallbacks = require('can-connect/data/callbacks/');\nvar realtime = require('can-connect/real-time/');\n\n// Bring in the feathersClient instance.\nvar feathersClient = require('./feathers');\n\n// Use feathersClient.service(url) to create a service\nvar todoService = feathersClient.service('/api/todos');\n\nvar Todo = DefineMap.extend('Todo', {\n  _id: 'string',\n  description: 'string',\n  complete: 'boolean'\n});\n\nTodo.algebra = new set.Algebra(\n  set.comparators.id('_id')\n);\n\nTodo.List = DefineList.extend({'*': Todo});\n\nTodo.connection = connect([\n  // Include the feathers service behavior in the behaviors list.\n  feathersServiceBehavior,\n  dataParse,\n  constructor,\n  constructorStore,\n  constructorCallbacksOnce,\n  canMap,\n  canRef,\n\t// Include both the dataCallbacks and realtime behaviors.\n  dataCallbacks,\n  realtime\n], {\n  idProp: '_id',\n  Map: Todo,\n  List: Todo.List,\n  // Pass the service as the `feathersService` property.\n  feathersService: todoService,\n  name: 'todos',\n  algebra: Todo.algebra\n});\n\nmodule.exports = Todo;\n```\n\nIn the above example, both `Todo` and `Todo.connection` will have methods for handling data, as described in the [can-connect basic use] section.\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect-feathers/service/service",
    "parent": "can-connect-feathers.behaviors",
    "signatures": [
      {
        "code": "feathersService(baseConnect)",
        "description": "\n\nConnects the [can-connect/DataInterface] methods to the Feathers [Service Interface](https://docs.feathersjs.com/services/readme.html#service-methods) methods.\n\n```js\nconnect([\n  feathersService,\n  realtime\n], {\n  feathersService: feathersClient.service('/api/todos')\n});\n```\n\nFor can-connect's real-time functionality to work with this behavior, the [can-connect/real-time/real-time real-time behavior] must also be included as shown in the examples. \n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect-feathers/session/session.data-methods.createData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/session/data-methods.create-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-connect-feathers/session/session.data-methods.createData",
    "type": "function",
    "parent": "can-connect-feathers/session/session.data-methods",
    "signatures": [
      {
        "code": "createData(sessionData)",
        "description": "\n\nUses the [can-connect-feathers/session/session.options.feathersClient feathersClient] `authenticate` method to authenticate with a Feathers server.  See the [Feathers Authentication Client documentation](https://docs.feathersjs.com/authentication/client.html) for details about Feathers authentication.  Upon successful authentication, the Feathers server will return a JSON Web Token (JWT) containing information about the current \"session\".  Note that Feathers uses JWT instead of server sessions.\n\nFor Socket.io connections, the current socket connection's state will be marked as authenticated on the server side.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "sessionData",
            "description": "The serialized data for creating a session.  The `sessionData` payload will vary depending on which authentication strategy is used on the server.  For example, [feathers-authentication-local](https://github.com/feathersjs/feathers-authentication-local) requires an `email` and `password`, but another strategy may have different requirements."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the server's response.  On success, a JSON Web Token created by the server will be returned.  On error, a [feathers-errors](https://github.com/feathersjs/feathers-errors) instance will be returned.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "sessionData",
      "description": "The serialized data for creating a session.  The `sessionData` payload will vary depending on which authentication strategy is used on the server.  For example, [feathers-authentication-local](https://github.com/feathersjs/feathers-authentication-local) requires an `email` and `password`, but another strategy may have different requirements."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the server's response.  On success, a JSON Web Token created by the server will be returned.  On error, a [feathers-errors](https://github.com/feathersjs/feathers-errors) instance will be returned.\n"
    }
  },
  "can-connect-feathers/session/session.data-methods.destroyData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/session/data-methods.destroy-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-connect-feathers/session/session.data-methods.destroyData",
    "type": "function",
    "parent": "can-connect-feathers/session/session.data-methods",
    "signatures": [
      {
        "code": "destroyData()",
        "description": "\n\nUses the [can-connect-feathers/session/session.options.feathersClient feathersClient] `logout` method to remove the current JSON Web Token from the client.  See the [Feathers Authentication Client documentation](https://docs.feathersjs.com/authentication/client.html) for details about Feathers authentication.\n\nFor Socket.io connections, the current socket connection's state will be marked as unauthenticated on the server side.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to a success message.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to a success message.\n"
    }
  },
  "can-connect-feathers/session/session.data-methods.getData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/session/data-methods.get-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-connect-feathers/session/session.data-methods.getData",
    "type": "function",
    "parent": "can-connect-feathers/session/session.data-methods",
    "signatures": [
      {
        "code": "getData()",
        "description": "\n\nUses the [can-connect-feathers/session/session.options.feathersClient feathersClient] `getJWT` method to retrieve and verify the current JSON Web Token (JWT).\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the JWT payload if the token was valid.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the JWT payload if the token was valid.\n"
    }
  },
  "can-connect-feathers/service/service.options.feathersClient": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/session/options.feathers-client.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "FeathersClient",
        "description": "\n\nSpecifies a FeathersClient instance to use for authentication.  The [feathers-authentication-client plugin](https://github.com/feathersjs/feathers-authentication-client) is required.  See the [can-connect-feathers] page for an example Feathers Client configuration.\n\n```js\n// Bring in the feathers client instance.\nvar feathersClient = require('./feathers');\n\nconnect([\n  feathersSession\n], {\n  // Pass the feathers client as the `feathersClient` property.\n  feathersClient: feathersClient\n});\n```\n\nSee [can-connect-feathers/session/session] for a complete Session Model example."
      }
    ],
    "title": "feathersClient",
    "name": "can-connect-feathers/service/service.options.feathersClient",
    "type": "property",
    "parent": "can-connect-feathers/session/session.options"
  },
  "can-connect-feathers/session/session.options": {
    "name": "can-connect-feathers/session/session.options",
    "title": "options",
    "type": "group",
    "parent": "can-connect-feathers/session/session",
    "description": "",
    "order": 0
  },
  "can-connect-feathers/session/session.data-methods": {
    "name": "can-connect-feathers/session/session.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect-feathers/session/session",
    "description": "",
    "order": 0
  },
  "can-connect-feathers/session/session": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/session/session.md"
    },
    "body": "\nThe `feathers-session` behavior uses the [feathers-authentication-client](https://github.com/feathersjs/feathers-authentication-client) to authenticate with a Feathers server.  Three of the [can-connect/DataInterface DataInterface] methods are used:\n\n - [can-connect-feathers/session/session.data-methods.createData createData] attempts to authenticate with the Feathers server, which upon success returns a JSON Web Token (JWT).  The JWT contains a payload with information about the current session.  That payload is returned as the session object.\n - [can-connect-feathers/session/session.data-methods.getData] validates a stored JWT and returns its payload if the token hasn't expired.\n - [can-connect-feathers/session/session.data-methods.destroyData] unauthenticates from the server and discards the JWT token on the client.\n\n## Use\n\nSetting up the Feathers Client is a prerequisite for using this behavior.  See the [can-connect-feathers] page for an example of a basic Feathers Client configuration.  With the Feathers client setup, it can be used with the `feathers-session` behavior as demonstrated in the example, below.\n\n```js\n// models/session.js\nvar connect = require('can-connect');\nvar DefineMap = require('can-define/map/');\n\nvar feathersSessionBehavior = require('can-connect-feathers/session');\nvar dataParse = require('can-connect/data/parse/');\nvar construct = require('can-connect/constructor/');\nvar constructStore = require('can-connect/constructor/store/');\nvar constructCallbacksOnce = require('can-connect/constructor/callbacks-once/');\nvar canMap = require('can-connect/can/map/');\nvar canRef = require('can-connect/can/ref/');\nvar dataCallbacks = require('can-connect/data/callbacks/');\n// Bring in your user model to setup the relation in your DefineMap.\nvar User = require('./user');\n\n// Bring in the feathersClient instance.\nvar feathersClient = require('./feathers');\n\nexport const Session = DefineMap.extend('Session', {\n  seal: false\n}, {\n  exp: 'any',\n  userId: 'any',\n  user: {\n    Type: User,\n    // Automatically populate the user data when a userId is received.\n    get (lastSetVal, resolve) {\n      if (lastSetVal) {\n        return lastSetVal;\n      }\n      if (this.userId) {\n        User.get({_id: this.userId}).then(resolve);\n      }\n    }\n  }\n});\n\nconnect([\n  // Include the feathers session behavior in the behaviors list.\n  feathersSession,\n  dataParse,\n  canMap,\n  canRef,\n  construct,\n  constructStore,\n  constructCallbacksOnce,\n  // Include the realtime behavior.\n  realtime,\n  dataCallbacks\n], {\n  // Pass the feathers client as the `feathersClient` property.\n  feathersClient: feathersClient,\n  idProp: 'exp',\n  Map: Session,\n  name: 'session'\n});\n```\n\n### Obtaining current session data\n\nOnce authentication has been established, the Map or DefineMap provided as the `Map` option on the can-connect Model will have a new `current` property defined.  So, if you passed a `Session` object, `Session.current` will always hold the current session data.  This greatly simplifies the session property in your application ViewModel.  Here's an abbreviated example.\n\n```js\nimport Session from 'my-app/models/session';\n\nconst AppViewModel = DefineMap.extend({\n  session: {\n    get () {\n      return Session.current;\n    }\n  }\n});\n```\n\nThat's it!  The `session` property in the above example will automatically populate when the user authenticates.\n\n### Handling OAuth Logins\n\nThe `feathers-session` behavior is preconfigured to listen to `login` messages coming in over the [feathers-authentication-popups](https://github.com/feathersjs/feathers-authentication-popups) `authAgent`.  When any message is received through the `authAgent`, its validity is checked.  If it's a valid JWT token, a Session instance will be created automatically.  This will both populate `Session.current` and dispatch a `created` event on the connected Session Map.\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect-feathers/session/session",
    "parent": "can-connect-feathers.behaviors",
    "signatures": [
      {
        "code": "feathersSession(baseConnect)",
        "description": "\n\nConnects [can-connect/DataInterface] methods to the [feathers-authentication-client](https://github.com/feathersjs/feathers-authentication-client) plugin methods for authentication.\n\n```js\nconnect([\n  feathersSession,\n  realtime\n], {\n  feathersClient: feathersClient,\n  Map: SessionMap\n});\n``` \n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/base-map/base-map": {
    "src": {
      "path": "node_modules/can-connect/can/base-map/base-map.md"
    },
    "body": "\n\n## Use\n\nThe `can-connect/can/base-map` module exports a helper function that creates a connection\nwith the \"standard\" behaviors in can-connect and hooks it up to a\n[can-define/map/map] and [can-define/list/list].\n\nIf you are using CanJS, this is an easy way to create a connection that can be useful and\nfast in most circumstances.\n\nTo use it, first define a Map and List constructor function:\n\n```js\nvar Todo = DefineMap.extend({ ... });\nvar TodoList = DefineList.extend({\n\t\"#\": Todo,\n\t...\n});\n```\n\nNext, call `baseMap` with all of the options needed by the behaviors that `baseMap` adds:\n\n```\nvar todoConnection = baseMap({\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nAs, [can-connect/can/map/map] adds CRUD methods to the `Map` option, you can use those to create,\nread, update and destroy todos:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.attr({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nCreate connection with many of the best behaviors in can-connect and hook it up to\na [can-define/map/map].\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect/can/base-map/base-map",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "baseMap(options)",
        "description": "\n\n  Creates a connection with the following behaviors: [can-connect/constructor/constructor],\n  [can-connect/can/map/map],\n  [can-connect/constructor/store/store],\n  [can-connect/data/callbacks/callbacks],\n  [can-connect/data/callbacks-cache/callbacks-cache],\n  [can-connect/data/parse/parse],\n  [can-connect/data/url/url],\n  [can-connect/real-time/real-time],\n  [can-connect/constructor/callbacks-once/callbacks-once].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/constructor-hydrate/constructor-hydrate": {
    "name": "can-connect/can/constructor-hydrate/constructor-hydrate",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 93,
      "path": "node_modules/can-connect/can/constructor-hydrate/constructor-hydrate.js"
    },
    "body": "\n\n## Use\n\nDuring all initializations of the connection [can-connect/can/map/map._Map Map type], if an id property exists then\nthe `constructor-hydrate` behavior will check the connection [can-connect/constructor/store/store.instanceStore] for\na matching instance. If one is found it will be returned instead of a new object.\n\nFor example, this behavior is useful if [can-define.types.propDefinition `Type` converters] of\n[can-define/map/map DefineMap] are used in your app.\n\nLet's say we have a page state type, two properties of which are of type `Student`:\n```js\nvar myPage = new (DefineMap.extend({\n  student: { Type: Student },\n  teamLead: { Type: Student },\n  loadTeamLead: function() {...}\n}));\n```\n\nThe type `Student` is a DefineMap that has had a `can-connect` connection attached:\n```js\nvar dataUrl = require(\"can-connect/data/url/\");\nvar constructor = require(\"can-connect/constructor/\");\nvar store = require(\"can-connect/constructor/store/\");\nvar canMap = require(\"can-connect/can/map/\");\nvar constructorHydrate = require(\"can-connect/can/constructor-hydrate/\");\n\nvar Student = DefineMap.extend({...});\nStudent.List = DefineList.extend({\n    '#': { Type: Student }\n});\n\nStudent.connection = connect(\n  [dataUrl, constructor, store, canMap, constructorHydrate], {\n\t   Map: Student,\n\t   List: Student.List,\n\t   url: \"api/students\"\n  }\n);\n```\n\nNow lets say your page loads `myPage.student` via the connection using `Student.get()`, and then it gets data for\n`teamLead` without the connection via `myPage.loadTeamLead()`. In this example it so happens that the team lead is\nthe same person as the student:\n\n```js\nStudent.get({id: 1}).then(function(person) {\n  // loaded via can-connect, person.id === 1\n  myPage.student = person;\n\n  // not loaded via can-connect, person.id === 1\n  myPage.loadTeamLead(myPage.student.teamId).then(function(person){ myPage.teamLead = person; });\n});\n```\n\nWithout `constructor-hydrate` we would end up with two different instances of `Student` with the same id. Additionally,\n`teamLead` would not be an instance that is stored in the connection's `instanceStore`, and thus would not benefit\nfrom the real-time updates offered by the [can-connect/real-time/real-time real-time] behavior.\n\n`constructor-hydrate` solves this problem by checking `instanceStore` before creating a new instance. So, in our\nexample it will return the existing instance from `myPage.loadTeamLead()`. Now both `myPage.student` and\n`myPage.teamLead` are referencing the same instance:\n\n```js\nvar instanceStore = Student.connection.instanceStore;\nmyPage.student === myPage.teamLead;                           // => true\nmyPage.teamLead === instanceStore.get( myPage.teamLead.id );  // => true\n```\n\n",
    "description": "\nCheck the [can-connect/constructor/store/store.instanceStore] when creating new instances of the connected\n[can-connect/can/map/map._Map] type. Return an existing instance if a match is found. Prevents duplication of\ninstances when instances are created outside of the `can-connect` connection.\n",
    "title": "constructor-hydrate",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructorHydrate( baseConnection )",
        "description": "\n\nOverrides [can-define/map/map DefineMaps]'s `setup` method and checks whether a newly created instance already\nexists in the [can-connect/constructor/store/store.instanceStore]. If an instance exists in the\n[can-connect/constructor/store/store.instanceStore] that instance will be returned instead of a new object.\n\nThis behavior expects to be used with the [can-connect/constructor/store/store] and [can-connect/can/map/map can/map]\nbehaviors.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "`can-connect` connection object that is having the `constructor-hydrate` behavior added\n  on to it.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a `can-connect` connection containing the methods provided by `constructor-hydrate`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "`can-connect` connection object that is having the `constructor-hydrate` behavior added\n  on to it.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a `can-connect` connection containing the methods provided by `constructor-hydrate`.\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.id": {
    "type": "function",
    "name": "can-connect/can/map/map.id",
    "parent": "can-connect/can/map/map.identifiers",
    "src": {
      "line": 41,
      "codeLine": 54,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nReturns an observable identifier value for an instance.\n",
    "title": "id",
    "signatures": [
      {
        "code": "connection.id(instance)",
        "description": "\n\nReads the instance's id (in the same manner as [can-connect/base/base.id `base.id()`]) but as an observable value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance to get an identifier of"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "an identifier value\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "the instance to get an identifier of"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "an identifier value\n\t "
    }
  },
  "can-connect/can/map/map.serializeInstance": {
    "type": "function",
    "name": "can-connect/can/map/map.serializeInstance",
    "parent": "can-connect/can/map/map.serializers",
    "src": {
      "line": 79,
      "codeLine": 92,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nReturns the properties of an instance that should be sent to the data source when saving. Done by calling\n[can-define/map/map.prototype.serialize `instance.serialize()`].\n",
    "title": "serializeInstance",
    "signatures": [
      {
        "code": "connection.serializeInstance(instance)",
        "description": "\nSimply calls [can-define/map/map.prototype.serialize] on the `instance` argument.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/can/map/map._Map"
              }
            ],
            "name": "instance",
            "description": "the instance to serialize"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "the result of calling [can-define/map/map.prototype.serialize `instance.serialize()`]\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/can/map/map._Map"
        }
      ],
      "name": "instance",
      "description": "the instance to serialize"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "the result of calling [can-define/map/map.prototype.serialize `instance.serialize()`]\n\t "
    }
  },
  "can-connect/can/map/map.serializeList": {
    "type": "function",
    "name": "can-connect/can/map/map.serializeList",
    "parent": "can-connect/can/map/map.serializers",
    "src": {
      "line": 95,
      "codeLine": 108,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nReturns the properties of a list that should be sent to the data source when saving. Done by calling\n[can-define/list/list.prototype.serialize `list.serialize()`].\n",
    "title": "serializeList",
    "signatures": [
      {
        "code": "connection.serializeList(list)",
        "description": "\nSimply calls [can-define/list/list.prototype.serialize] on the `list` argument.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/can/map/map._List"
              }
            ],
            "name": "list",
            "description": "the list to serialize"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "the result of calling [can-define/list/list.prototype.serialize `list.serialize()`]\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/can/map/map._List"
        }
      ],
      "name": "list",
      "description": "the list to serialize"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "the result of calling [can-define/list/list.prototype.serialize `list.serialize()`]\n\t "
    }
  },
  "can-connect/can/map/map._Map": {
    "body": "\n",
    "description": "\nSpecify the type of the `[can-define/map/map DefineMap]` that should be instantiated by the connection.\n",
    "types": [
      {
        "type": "connection.Map",
        "description": "Defaults to [can-types.DefaultMap] if this option is not specified.\n\n**Usage:**\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar canMap = require(\"can-connect/can/map/map\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  complete: function(){\n    this.completed = true\n  }\n});\n\nvar todoConnection = connect([dataUrl, constructor, canMap], {\n  Map: Todo,\n  url: \"/todos\"\n});\n\ntodoConnect.get({id:1}).then(function(item) {\n  item instanceof Todo // true\n});\n```\n\t "
      }
    ],
    "title": "Map",
    "name": "can-connect/can/map/map._Map",
    "type": "property",
    "parent": "can-connect/can/map/map.options"
  },
  "can-connect/can/map/map._List": {
    "body": "\n",
    "description": "\nSpecify the type of the `[can-define/list/list DefineList]` that should be instantiated by the connection.\n",
    "types": [
      {
        "type": "connection.List",
        "description": "If this option is not specified it defaults to the [can-connect/can/map/map._Map Map].List\nproperty and then [can-types.DefaultList].\n\n**Usage:**\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\nvar canMap = require(\"can-connect/can/map/map\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  complete: function(){\n    this.completed = true\n  }\n});\n\nvar Todo.List = DefineList.extend({\n  \"*\": Todo,\n  completed: function(){\n    this.filter(function(todo){\n      return todo.completed;\n    });\n  }\n});\n\nvar todoConnection = connect([dataUrl, constructor, canMap],{\n  Map: Todo,\n  List: Todo.List,\n  url: \"/todos\"\n});\n\ntodoConnection.getList({}).then(function(list) {\n  list instanceOf Todo.List // true\n})\n```\n\t "
      }
    ],
    "title": "List",
    "name": "can-connect/can/map/map._List",
    "type": "property",
    "parent": "can-connect/can/map/map.options"
  },
  "can-connect/can/map/map.instance": {
    "type": "function",
    "name": "can-connect/can/map/map.instance",
    "parent": "can-connect/can/map/map.hydrators",
    "src": {
      "line": 191,
      "codeLine": 205,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCreates a [can-connect/can/map/map._Map] instance given raw data.\n",
    "title": "instance",
    "signatures": [
      {
        "code": "connection.instance(props)",
        "description": "\n\n  Create an instance of [can-connect/can/map/map._Map] if available, otherwise creates an instance of\n  [can-types.DefaultMap].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the raw instance data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/can/map/map._Map"
            }
          ],
          "description": "a [can-connect/can/map/map._Map] instance containing the `props`.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the raw instance data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/can/map/map._Map"
        }
      ],
      "description": "a [can-connect/can/map/map._Map] instance containing the `props`.\n\t "
    }
  },
  "can-connect/can/map/map.list": {
    "type": "function",
    "name": "can-connect/can/map/map.list",
    "parent": "can-connect/can/map/map.hydrators",
    "src": {
      "line": 210,
      "codeLine": 235,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCreates a [can-connect/can/map/map._List] instance given raw data.\n",
    "title": "list",
    "signatures": [
      {
        "code": "connection.list(listData, set)",
        "description": "\n\n  Creates an instance of [can-connect/can/map/map._List] if available, otherwise creates\n  [can-connect/can/map/map._Map].List if available, and then finally defaulting to [can-types.DefaultList].\n\n  This will add properties on the raw `listData` array to the created list instance. e.g:\n  ```js\n  var listData = [{id: 1, name:\"do dishes\"}, ...];\n  listData.loadedFrom; // \"shard 5\"\n\n  var todoList = todoConnection.list(listData, {});\n  todoList.loadedFrom; // \"shard 5\"\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "the raw list data."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "the set the data belongs to."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "a [can-connect/can/map/map._List] instance containing instances of\n[can-connect/can/map/map._Map] built from the list items in `listData`.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "the set the data belongs to."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "a [can-connect/can/map/map._List] instance containing instances of\n[can-connect/can/map/map._Map] built from the list items in `listData`.\n\t "
    }
  },
  "can-connect/can/map/map.updatedList": {
    "type": "function",
    "name": "can-connect/can/map/map.updatedList",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "src": {
      "line": 248,
      "codeLine": 263,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nImplements the [can-connect/constructor/constructor.updatedList] callback so it updates the list and it's items\nduring a single [can-event/batch/batch batched event].\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedList(list, listData, set)",
        "description": "\n\n  Updates the list and the items within it during a single [can-event/batch/batch batched event].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "the list to be updated."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "raw list data."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "the set of the list being updated.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "the set of the list being updated.\n\t "
    }
  },
  "can-connect/can/map/map.createdInstance": {
    "src": {
      "line": 294,
      "codeLine": 312,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nImplements the [can-connect/constructor/constructor.createdInstance] callback so it dispatches an event and\nupdates the instance.\n",
    "title": "createdInstance",
    "name": "can-connect/can/map/map.createdInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.createdInstance(instance, props)",
        "description": "\n\n  Updates the instance with `props` and dispatches a \"created\" event on the instance and the instances's\n  constructor function ([can-connect/can/map/map._Map]).\n\n  Calls [can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore] to ensure new instances\n  are moved into the [can-connect/constructor/store/store.instanceStore] after being saved.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/can/map/map._Map"
              }
            ],
            "name": "instance",
            "description": "a [can-connect/can/map/map._Map] instance"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the data in the response from [can-connect/connection.createData]\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the data in the response from [can-connect/connection.createData]\n\t "
    }
  },
  "can-connect/can/map/map.updatedInstance": {
    "src": {
      "line": 313,
      "codeLine": 328,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nImplements the [can-connect/constructor/constructor.updatedInstance] callback so it dispatches an event and\nupdates the instance.\n",
    "title": "updatedInstance",
    "name": "can-connect/can/map/map.updatedInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.updatedInstance(instance, props)",
        "description": "\n\n  Updates the instance with `props` and dispatches an \"updated\" event on the instance and the instances's\n  constructor function ([can-connect/can/map/map._Map]).\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/can/map/map._Map"
              }
            ],
            "name": "instance",
            "description": "a [can-connect/can/map/map._Map] instance"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the data in the response from [can-connect/connection.updateData]\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the data in the response from [can-connect/connection.updateData]\n\t "
    }
  },
  "can-connect/can/map/map.destroyedInstance": {
    "src": {
      "line": 329,
      "codeLine": 344,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nImplements the [can-connect/constructor/constructor.destroyedInstance] callback so it dispatches an event and\nupdates the instance.\n",
    "title": "destroyedInstance",
    "name": "can-connect/can/map/map.destroyedInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.destroyedInstance(instance, props)",
        "description": "\n\n  Updates the instance with `props` and dispatches a \"destroyed\" event on the instance and the instances's\n  constructor function ([can-connect/can/map/map._Map]).\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/can/map/map._Map"
              }
            ],
            "name": "instance",
            "description": "a [can-connect/can/map/map._Map] instance"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the data in the response from [can-connect/connection.destroyData]\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the data in the response from [can-connect/connection.destroyData]\n\t "
    }
  },
  "can-connect/can/map/map.callbackInstanceEvents": {
    "type": "function",
    "name": "can-connect/can/map/map.callbackInstanceEvents",
    "parent": "can-connect/can/map/map.static",
    "src": {
      "line": 372,
      "codeLine": 396,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nUtility function to dispatch events for instance callbacks, e.g. [can-connect/can/map/map.updatedInstance].\n",
    "title": "callbackInstanceEvents",
    "signatures": [
      {
        "code": "connection.callbackInstanceEvents(cbName, instance)",
        "description": "\n\n  Used to dispatch events as part of instance callbacks implementations. This method could be useful in other\n  behaviors that implement instance callbacks. E.g. a behavior overriding the\n  [can-connect/can/map/map.updatedInstance `updatedInstance`] callback:\n\n  ```\n  connect([canMap, {\n      updatedInstance: function(instance, props) {\n          instance = smartMerge(instance, props);\n          canMapBehavior.callbackInstanceEvents(\"updated\", instance);\n      }\n  }], {})\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "name of the the event to be triggered"
          },
          {
            "types": [
              {
                "type": "can-connect/can/map/map._Map"
              }
            ],
            "name": "instance",
            "description": "a [can-connect/can/map/map._Map] instance.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/can/map/map._Map"
        }
      ],
      "name": "instance",
      "description": "a [can-connect/can/map/map._Map] instance.\n"
    }
  },
  "can-connect/can/map/map.getList": {
    "type": "function",
    "name": "can-connect/can/map/map.getList",
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 419,
      "codeLine": 463,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nMethod added to the configured [can-connect/can/map/map._Map] type. Retrieves a [can-connect/can/map/map._List] of\n[can-connect/can/map/map._Map] instances via the connection.\n",
    "title": "getList",
    "signatures": [
      {
        "code": "Map.getList(set)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "set definition of the list being retrieved"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Map"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` returning the [can-connect/can/map/map._List] of instances being retrieved\n\n### Usage\n\n```\n// import connection plugins\nvar canMap = require(\"can-connect/can/map/map\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\n// define connection types\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nTodo.List = DefineList.extend({\n  completed: function() {\n    return this.filter(function(item) { return item.completed; });\n  }\n});\n\n// create connection\nconnect([canMap, constructor, dataUrl],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\n// retrieve instances\nTodo.getList({due: \"today\"}).then(function(todos){\n  ...\n});\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "set definition of the list being retrieved"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Map"
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` returning the [can-connect/can/map/map._List] of instances being retrieved\n\n### Usage\n\n```\n// import connection plugins\nvar canMap = require(\"can-connect/can/map/map\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\n// define connection types\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nTodo.List = DefineList.extend({\n  completed: function() {\n    return this.filter(function(item) { return item.completed; });\n  }\n});\n\n// create connection\nconnect([canMap, constructor, dataUrl],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\n// retrieve instances\nTodo.getList({due: \"today\"}).then(function(todos){\n  ...\n});\n```\n "
    }
  },
  "can-connect/can/map/map.findAll": {
    "type": "function",
    "name": "can-connect/can/map/map.findAll",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "connection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 468,
      "codeLine": 475,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": " \n",
    "description": "\nAlias of [can-connect/can/map/map.getList]. You should use `.getList()`.\n",
    "title": "findAll",
    "hide": true
  },
  "can-connect/can/map/map.get": {
    "type": "function",
    "name": "can-connect/can/map/map.get",
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 480,
      "codeLine": 518,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nMethod added to the configured [can-connect/can/map/map._Map] type. Retrieves an instance of the\n[can-connect/can/map/map._Map] type via the connection.\n",
    "title": "get",
    "signatures": [
      {
        "code": "Map.get(params)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "identifying parameters of the instance to retrieve"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Map"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` returning the [can-connect/can/map/map._Map] instance being retrieved\n\n### Usage\n\n```js\n// import connection plugins\nvar canMap = require(\"can-connect/can/map/map\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\n// define connection type\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\n// create connection\nconnect([canMap, constructor, dataUrl],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\n// retrieve instance\nTodo.get({id: 5}).then(function(todo){\n  ...\n});\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "identifying parameters of the instance to retrieve"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Map"
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` returning the [can-connect/can/map/map._Map] instance being retrieved\n\n### Usage\n\n```js\n// import connection plugins\nvar canMap = require(\"can-connect/can/map/map\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\n// define connection type\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\n// create connection\nconnect([canMap, constructor, dataUrl],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\n// retrieve instance\nTodo.get({id: 5}).then(function(todo){\n  ...\n});\n```\n "
    }
  },
  "can-connect/can/map/map.findOne": {
    "type": "function",
    "name": "can-connect/can/map/map.findOne",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "connection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 524,
      "codeLine": 531,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": " \n",
    "description": "\nAlias of [can-connect/can/map/map.get]. You should use `.get()`.\n",
    "title": "findOne",
    "hide": true
  },
  "can-connect/can/map/map.prototype.isNew": {
    "src": {
      "line": 575,
      "codeLine": 584,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the instance has not been loaded from or saved to the data source.\n",
    "title": "isNew",
    "name": "can-connect/can/map/map.prototype.isNew",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "instance.isNew()",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if [can-connect/base/base.id] is `null` or `undefined`\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if [can-connect/base/base.id] is `null` or `undefined`\n\t "
    }
  },
  "can-connect/can/map/map.prototype.isSaving": {
    "src": {
      "line": 590,
      "codeLine": 611,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the instance is currently being saved.\n",
    "title": "isSaving",
    "name": "can-connect/can/map/map.prototype.isSaving",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "instance.isSaving()",
        "description": "\n\nObserves if a promise returned by [can-connect/connection.save `connection.save`] is in progress for this\ninstance.  This is often used in a template like:\n\n```\n<button ($click)=\"todo.save()\"\n   {{#todo.isSaving}}disabled{{/todo.isSaving}}>\n  Save Changes\n</button>\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if [can-connect/connection.save `connection.save`] has been called for this\ninstance but the returned promise has not yet resolved.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if [can-connect/connection.save `connection.save`] has been called for this\ninstance but the returned promise has not yet resolved.\n\t "
    }
  },
  "can-connect/can/map/map.prototype.isDestroying": {
    "src": {
      "line": 618,
      "codeLine": 639,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the instance is currently being destroyed.\n",
    "title": "isDestroying",
    "name": "can-connect/can/map/map.prototype.isDestroying",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "instance.isDestroying()",
        "description": "\n\nObserves if a promise returned by [can-connect/connection.destroy `connection.destroy`] is in progress for this\ninstance.  This is often used in a template like:\n\n```\n<button ($click)=\"todo.destroy()\"\n   {{#todo.isDestroying}}disabled{{/todo.isDestroying}}>\n  Delete\n</button>\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if [can-connect/connection.destroy `connection.destroy`] has been called for this\ninstance but the returned promise has not resolved.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if [can-connect/connection.destroy `connection.destroy`] has been called for this\ninstance but the returned promise has not resolved.\n\t "
    }
  },
  "can-connect/can/map/map.prototype.save": {
    "src": {
      "line": 646,
      "codeLine": 684,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nSave the instance's data to the service via the connection.\n",
    "title": "save",
    "name": "can-connect/can/map/map.prototype.save",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "instance.save(success, error)",
        "description": "\n\n  Calls [can-connect/connection.save].\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "success",
            "description": "A function that is called if the save is successful."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "error",
            "description": "A function that is called if the save is rejected."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance if successful.\n\n### Usage\n\n```\n// import connection plugins\nvar canMap = require(\"can-connect/can/map/map\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\n// define connection types\nvar Todo = DefineMap.extend({\nid: \"number\",\ncomplete: \"boolean\",\nname: \"string\"\n});\n\n// create connection\nconnect([canMap, constructor, dataUrl], {\nMap: Todo,\nurl: \"/todos\"\n})\n\nnew Todo({name: \"dishes\"}).save();\n```\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "error",
      "description": "A function that is called if the save is rejected."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance if successful.\n\n### Usage\n\n```\n// import connection plugins\nvar canMap = require(\"can-connect/can/map/map\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\n// define connection types\nvar Todo = DefineMap.extend({\nid: \"number\",\ncomplete: \"boolean\",\nname: \"string\"\n});\n\n// create connection\nconnect([canMap, constructor, dataUrl], {\nMap: Todo,\nurl: \"/todos\"\n})\n\nnew Todo({name: \"dishes\"}).save();\n```\n\t "
    }
  },
  "can-connect/can/map/map.prototype.destroy": {
    "src": {
      "line": 693,
      "codeLine": 736,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nDelete an instance from the service via the connection.\n",
    "title": "destroy",
    "name": "can-connect/can/map/map.prototype.destroy",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "instance.destroy(success, error)",
        "description": "\n\nCalls [can-connect/connection.destroy] for the `instance`.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "success",
            "description": "a function that is called if the [can-connect/connection.destroy] call is successful."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "error",
            "description": "a function that is called if the [can-connect/connection.destroy] call is rejected."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "a promise that resolves to the instance if successful\n\n### Usage\n```\n// import connection plugins\nvar canMap = require(\"can-connect/can/map/map\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\n// define connection types\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\n// create connection\nconnect([canMap, constructor, dataUrl],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\n// read instance\nTodo.get({id: 5}).then(function(todo){\n  if (todo.complete) {\n    // delete instance\n    todo.destroy();\n  }\n});\n```\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "error",
      "description": "a function that is called if the [can-connect/connection.destroy] call is rejected."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "a promise that resolves to the instance if successful\n\n### Usage\n```\n// import connection plugins\nvar canMap = require(\"can-connect/can/map/map\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\n// define connection types\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\n// create connection\nconnect([canMap, constructor, dataUrl],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\n// read instance\nTodo.get({id: 5}).then(function(todo){\n  if (todo.complete) {\n    // delete instance\n    todo.destroy();\n  }\n});\n```\n\t "
    }
  },
  "can-connect/can/map/map.options": {
    "name": "can-connect/can/map/map.options",
    "title": "behavior options",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 0
  },
  "can-connect/can/map/map.map-static": {
    "name": "can-connect/can/map/map.map-static",
    "title": "map static methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 1
  },
  "can-connect/can/map/map.map": {
    "name": "can-connect/can/map/map.map",
    "title": "map instance methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 2
  },
  "can-connect/can/map/map.hydrators": {
    "name": "can-connect/can/map/map.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 3
  },
  "can-connect/can/map/map.serializers": {
    "name": "can-connect/can/map/map.serializers",
    "title": "serializers",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 4
  },
  "can-connect/can/map/map.identifiers": {
    "name": "can-connect/can/map/map.identifiers",
    "title": "identifiers",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 5
  },
  "can-connect/can/map/map.instance-callbacks": {
    "name": "can-connect/can/map/map.instance-callbacks",
    "title": "instance callbacks",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 6
  },
  "can-connect/can/map/map.static": {
    "name": "can-connect/can/map/map.static",
    "title": "behavior static methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 7
  },
  "can-connect/can/map/map": {
    "src": {
      "path": "node_modules/can-connect/can/map/map.md"
    },
    "body": "\n\n\n## Use\n\nThe `can/map` behavior links a connection to a [can-define/map/map DefineMap] and [can-define/list/list DefineList] type. \nThe connection will create those types of instances from the data it receives. It also adds convenient methods and \nobservable values to the [can-connect/can/map/map._Map] that offer connection functionality (e.g \n[can-connect/can/map/map.prototype.save `instance.save`]) and the status of the instance (e.g\n[can-connect/can/map/map.prototype.isSaving `instance.isSaving`]).\n\nTo use the `can/map` behavior, first create a Map and List constructor function:\n\n```\nvar Todo = DefineMap.extend({\n  allowComplete: function(ownerId) {\n    return this.ownerId === ownerId;\n  }\n});\n\nvar TodoList = DefineList.extend({\n  \"#\": Todo,\n  incomplete: function(){\n    return this.filter({complete: false});\n  }\n});\n```\n\nNext, pass the Map and List constructor functions to `connect` as options. The following creates connects the `Todo` \nand `TodoList` types to a RESTful data service via the connection:\n\n```js\nvar connect = require(\"can-connect\");\nvar dataUrl = require(\"can-connect/data/url/url\"),\nvar constructor = require(\"can-connect/constructor/constructor\"),\nvar canMap = require(\"can-connect/can/map/map\")\n\nvar todoConnection = connect([dataUrl, constructor, canMap],{\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\"\n});\n```\n\nThe connection itself can be used to create, read, update & delete `Todo` and `TodoList`s:\n\n```js\ntodoConnection.getList({}).then(function(todos){\n  var incomplete = todos.incomplete();\n  incomplete[0].allowComplete( 5 ) //-> true\n});\n```\n\n... or instead of how it's done above, because `can/map` adds methods to the [can-connect/can/map/map._Map] type, you \ncan use `Todo` to retrieve `Todo` and `TodoList`s:\n\n```js\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n```\n\nYou can also create, update, and [can-connect/can/map/map.prototype.destroy] `Todo` instances. Notice that\n[can-connect/can/map/map.prototype.save] is used to create and update:\n\n```js\n// create an instance\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.set({\n    name: \"Do the dishes\"\n  })\n  .save() // update an instance\n  .then(function(todo){\n    todo.destroy(); // destroy an instance\n  });\n});\n```\n\nThere's also methods that let you know if an instance is in the process of being\n[can-connect/can/map/map.prototype.isSaving saved] or [can-connect/can/map/map.prototype.isDestroying destroyed]:\n\n```js\nvar savePromise = new Todo({name: \"dishes\"}).save();\ntodo.isSaving() //-> true\n\nsavePromise.then(function(){\n\ttodo.isSaving() //-> false\n\n\tvar destroyPromise = todo.destroy();    \n\ttodo.isDestroying() //-> true\n\n\tdestroyPromise.then(function(){\n        todo.isDestroying() //-> false\n\t})\n})\n```\n\n",
    "description": "\nIntegrate a `can-connect` connection with a [can-define/map/map DefineMap] type.  \n",
    "type": "module",
    "title": "can/map",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect/can/map/map",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "canMap( baseConnection )",
        "description": "\n\nExtends the functionality of the [can-connect/constructor/constructor constructor] behavior so it integrates tightly \nwith [can-define/map/map DefineMap] and [can-define/list/list DefineList] types:\n- adds methods to [can-connect/can/map/map.get read], [can-connect/can/map/map.prototype.destroy destroy], \n[can-connect/can/map/map.prototype.save create and update] instances (via the connection) to the \n[can-connect/can/map/map._Map] type\n- adds observable values to instances indicating if they are being [can-connect/can/map/map.prototype.isSaving saved], \n[can-connect/can/map/map.prototype.isDestroying deleted] or have \n[can-connect/can/map/map.prototype.isNew not yet been saved]\n- updates instances with the data from the response bodies of create, update and delete requests\n- triggers events on the [can-connect/can/map/map._Map] type and instances when instances are created, destroyed or updated\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "`can-connect` connection object that is having the `can/map` behavior added on to it. Expects\nthe [can-connect/constructor/constructor] behavior to already be added to this base connection. If the `connect` helper \nis used to build the connection, the behaviors will automatically be ordered as required.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a `can-connect` connection containing the methods provided by `can/map`.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "`can-connect` connection object that is having the `can/map` behavior added on to it. Expects\nthe [can-connect/constructor/constructor] behavior to already be added to this base connection. If the `connect` helper \nis used to build the connection, the behaviors will automatically be ordered as required.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a `can-connect` connection containing the methods provided by `can/map`.\n\n"
    },
    "comment": " "
  },
  "can-connect/can/merge/merge.createdInstance": {
    "type": "function",
    "name": "can-connect/can/merge/merge.createdInstance",
    "parent": "can-connect/can/merge/merge.instance-callbacks",
    "src": {
      "line": 7,
      "codeLine": 24,
      "path": "node_modules/can-connect/can/merge/merge.js"
    },
    "body": "",
    "description": "Makes minimal updates to an instance's properties and its nested properties using [can-connect/helpers/map-deep-merge].\n\n",
    "title": "createdInstance",
    "signatures": [
      {
        "code": "connection.createdInstance(instance, props)",
        "description": "\n\n  Calls [can-connect/helpers/map-deep-merge] and triggers the `'created'` event on the instance and it's type\n  within a [can-event/batch/batch batch].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance that was just created whose\nproperties will be updated."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the new data the instance and children of the\ninstance should be updated to look like.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the new data the instance and children of the\ninstance should be updated to look like.\n\t "
    }
  },
  "can-connect/can/merge/merge.destroyedInstance": {
    "type": "function",
    "name": "can-connect/can/merge/merge.destroyedInstance",
    "parent": "can-connect/can/merge/merge.instance-callbacks",
    "src": {
      "line": 30,
      "codeLine": 47,
      "path": "node_modules/can-connect/can/merge/merge.js"
    },
    "body": "",
    "description": "Makes minimal updates to an instance's properties and its nested properties using [can-connect/helpers/map-deep-merge].\n\n",
    "title": "destroyedInstance",
    "signatures": [
      {
        "code": "connection.destroyedInstance(instance, props)",
        "description": "\n\n  Calls [can-connect/helpers/map-deep-merge] and triggers the `'destroyed'` event on the instance and it's type\n  within a [can-event/batch/batch batch].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance that was just destroyed whose\nproperties will be updated."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The new data the instance and children of the\ninstance should be updated to look like.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The new data the instance and children of the\ninstance should be updated to look like.\n\t "
    }
  },
  "can-connect/can/merge/merge.updatedInstance": {
    "type": "function",
    "name": "can-connect/can/merge/merge.updatedInstance",
    "parent": "can-connect/can/merge/merge.instance-callbacks",
    "src": {
      "line": 53,
      "codeLine": 70,
      "path": "node_modules/can-connect/can/merge/merge.js"
    },
    "body": "",
    "description": "Makes minimal updates to an instance's properties and its nested properties using [can-connect/helpers/map-deep-merge].\n\n",
    "title": "updatedInstance",
    "signatures": [
      {
        "code": "connection.updatedInstance(instance, props)",
        "description": "\n\n  Calls [can-connect/helpers/map-deep-merge] and triggers the `'updated'` event on the instance and it's type\n  within a [can-event/batch/batch batch].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance that was just updated whose\nproperties will be updated."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the new data the instance and children of the\ninstance should be updated to look like.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the new data the instance and children of the\ninstance should be updated to look like.\n\t "
    }
  },
  "can-connect/can/merge/merge.updatedList": {
    "type": "function",
    "name": "can-connect/can/merge/merge.updatedList",
    "parent": "can-connect/can/merge/merge.instance-callbacks",
    "src": {
      "line": 76,
      "codeLine": 91,
      "path": "node_modules/can-connect/can/merge/merge.js"
    },
    "body": "",
    "description": "Makes minimal updates to an list's items and those items' nested properties using [can-connect/helpers/map-deep-merge].\n\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedList(list, listData)",
        "description": "\n\n  Calls [can-connect/helpers/map-deep-merge] on the list within a [can-event/batch/batch batch].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "the list that will be updated."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "the new data the list and items in the\nlist should be updated to look like.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "name": "listData",
      "description": "the new data the list and items in the\nlist should be updated to look like.\n\t "
    }
  },
  "can-connect/can/merge/merge.instance-callbacks": {
    "name": "can-connect/can/merge/merge.instance-callbacks",
    "title": "instance callbacks",
    "type": "group",
    "parent": "can-connect/can/merge/merge",
    "description": "",
    "order": 5
  },
  "can-connect/can/merge/merge": {
    "src": {
      "path": "node_modules/can-connect/can/merge/merge.md"
    },
    "body": "\n\n## Use\n\nTo use the `can/merge` behavior, you have to:\n\n1. Add the behavior after [can-connect/can/map/map], and\n2. Make sure all types, especially [can-connect/can/map/map._List] type is properly configured.\n\nAdding the `can/merge` behavior after [can-connect/can/map/map] is pretty straightforward. \nWhen you create a custom connection, create it as follows:\n\n```js\nvar canMergeBehavior = require(\"can-connect/can/merge/merge\");\nvar canMapBehavior = require(\"can-connect/can/map/map\");\n\nvar ClassRoom = DefineMap.extend({\n\t...\n});\n\nClassRoom.List = DefineList.extend({\n\t\"#\": ClassRoom\n});\n\nClassRoom.algebra = new set.Algebra({...})\n\nClassRoom.connection = connect([..., canMapBehavior, canMergeBehavior, ...],{\n\tMap: ClassRoom,\n\tList: ClassRoom.List\n});\n```\n\nFor [can-connect/helpers/map-deep-merge] to merge correctly, it needs to know how to uniquely identify an instance and\nbe able to convert raw data to instances and lists. \n`map-deep-merge` looks for this configuration on the `.algebra` and `.connection` properties of the\n[can-define.types.TypeConstructor] setting on [can-define] types.\n\nThis is more easily understood in an example. \nIf the `ClassRoom` has a `students` property that is a list of `Student` instances like:\n\n```js\nvar ClassRoom = DefineMap.extend({\n\tstudents: Student.List\n});\n```\n\nTo be able to uniquely identify `Student` instances within that list, make sure `Student` has an `algebra` property \nthat is configured with the identifier property:\n\n```js\nStudent = DefineMap.extend({ ... });\n\nStudent.algebra = new set.Algebra(set.props.id(\"_id\"))\n```\n\nAlso make sure that `Student.List` points its [can-define/list/list.prototype.wildcardItems] definition to `Student`\nlike the following:\n\n```js\nStudent.List = DefineList.extend({\n    \"#\": Student\n});\n```\n\n**Note:** the typical method used to create a `Student` is `new Student(props)`. \nHowever, if `Student`s have a `.connection`, [can-connect/helpers/map-deep-merge] will use \n`Student.connection.[can-connect/constructor/constructor.hydrateInstance](props)`. \nThis is useful if `Student`s should be looked up in the connection [can-connect/constructor/store/store.instanceStore].\n\nFor example, `Student` might have a connection that has an [can-connect/constructor/store/store.instanceStore], like:\n\n```js\nStudent.connection = baseMap({\n\tMap: Student,\n\tList: Student.List,\n\turl: \"/services/students\",\n\tname: \"students\"\n});\n```\n\n",
    "description": "\nMinimally update nested data structures with the response from the server.\n",
    "type": "module",
    "title": "can/merge",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect/can/merge/merge",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "canMergeBehavior( baseConnection )",
        "description": "\n\nOverwrites [can-connect/can/map/map]'s instance callbacks so they use [can-connect/helpers/map-deep-merge].\n[can-connect/helpers/map-deep-merge] is able to make minimal changes to the nested properties of [can-define] instances \nand lists given raw data. \nE.g:\n\n```js\nvar existingStudent;\nvar classroom = ClassRoom.get({id: 505}).then(function(instance) {\n  instance.id; // 505\n  instance.students[0].id; // 15\n  instance.students[0].name; // 'Samantha Jones'\n  existingStudent = instance;\n});\n\n... // later in the program new information for the classroom is retrieved\n\nClassRoom.get({id:505}).then(function(instance) {\n    instance.id; // 505\n    instance.students[0].id; // 15\n    instance.students[0].name; // 'Samantha Jones-Baker'\n    \n    // true, if can-merge behavior is used. \n    // a new nested instance isn't created, instead it was updated with the changed fields\n    existingStudent === instance.students[0]; \n});\n\n```\n\nTo use `can/merge`, the connection's [can-connect/can/map/map._Map], [can-connect/can/map/map._List] and any of their \nnested types must be properly configured.  That configuration is discussed in the \n[can-connect/can/merge/merge#Use \"Use\" section] below.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "`can-connect` connection object that is having the `can/merge` behavior added on to it. Expects\nthe [can-connect/can/map/map] behavior to already be added to this base connection. If the `connect` helper \nis used to build the connection, the behaviors will automatically be ordered as required.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a `can-connect` connection containing the methods provided by `can/merge`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "`can-connect` connection object that is having the `can/merge` behavior added on to it. Expects\nthe [can-connect/can/map/map] behavior to already be added to this base connection. If the `connect` helper \nis used to build the connection, the behaviors will automatically be ordered as required.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a `can-connect` connection containing the methods provided by `can/merge`.\n"
    },
    "comment": " "
  },
  "can-connect/can/model/model": {
    "src": {
      "path": "node_modules/can-connect/can/model/model.md"
    },
    "body": "\n## Use\n\n`can-connect/can/model` is for backwards compatibility\nwith `can.Model` so that developers can migrate\nto `can-connect` without having to rewrite their models immediately.\n\nHowever, use of `can.Model` will be deprecated in CanJS 3.0. Instead of extending `can.Model`,\nextend [can-map] and [can-list] and use the [can-connect/can/map/map] behavior to connect your Map and List to a connection:\n\n```js\nvar CanMap = require(\"can-map\");\nvar CanList = require(\"can-list\");\n\nvar Todo = CanMap.extend({ ... });\n\nvar TodoList = CanList.extend({\n  Map: Todo\n},{ ... });\n\nvar todoConnection = connect([\"data-url\",\"constructor\",\"can/map\"],{\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\"\n});\n```\n\nOr, use the [can-connect/can/super-map/super-map] function to create a connection with the \"super\" behaviors:\n\n```\nvar todoConnection = superMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nFor your legacy code, you should just need to import \"can-connect/can/model/\" instead of \"can/model/\" like:\n\n```js\nimport Model from \"can-connect/can/model/\";\n\nTodo = Model.extend({\n  findAll: \"/todos\"\n},{});\n\nTodo.findAll({}).then(function(todos){\n\n});\n```\n\n## Upgrading can.Models to can-connect\n\nThis section walks through making the necessary changes to upgrade a legacy can.Model to use `can-connect` and its\nbehaviors.  We'll convert a `can.Model` and `can.Model.List` that looks like:\n\n```\nTodo = can.Model.extend({\n  resource: \"/\",\n  destroy: \"POST /todos/{id}/delete\",\n  findOne: function(params){\n    return $.get(\"/todos/\"+params._id);\n  },\n\n  parseModels: function(data){\n    return data.todos;\n  },\n  parseModel: \"todo\",\n\n  id: \"_id\",\n},{\n  method: function(){ ... },\n  define: { ... }\n});\n\nTodo.List = Todo.List.extend({ ... });\n```\n\nConverting this to use `can-connect` looks like:\n\n```js\nvar CanMap = require(\"can-map\"),\n\tCanList = require(\"can-list\");\n\nTodo = CanMap.extend({\n  method: function(){ ... },\n  define: { ... }\n});\nTodo.List = CanList.extend({\n  Map: Todo\n},{ ... })\n\nconnect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/data/parse/parse\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\"),\n\trequire(\"can-connect/can/map/map\")\n  ],\n  {\n    Map: Todo,\n    List: Todo.List,\n\n    url: {\n      resource: \"/\",\n      destroyData: \"POST /todos/{id}/delete\",\n      getData: function(params){\n        return $.get(\"/todos/\"+params._id);\n      }\n    },\n\n    parseListData: function(data){\n      return data.todos;\n    },\n    parseInstanceProp: \"todo\",\n\n    idProp: \"_id\"\n  });\n```\n\nInstead of `Todo.findAll` and `Todo.findOne`, use `Todo.getList` and `Todo.get`.\n\nLets break this down in the following sections.\n\n### Defining the Map and List\n\nThe first step is to pull out the parts of the Model and Model.List that define the\nobservable Map and List's behavior into a [can-map] and [can-list]:\n\n```js\nvar CanMap = require(\"can-map\"),\n\tCanList = require(\"can-list\");\n\nTodo = CanMap.extend({\n  method: function(){ ... },\n  define: { ... }\n});\nTodo.List = CanList.extend({\n  Map: Todo\n},{ ... })\n```\n\nOne of the main advantageous of `can-connect` is that it lets separate persistence behavior\nfrom property behavior.\n\n### Connecting the Map and List to behaviors\n\nThe next step is to connect the Map and List to the right behaviors.  The following\nadds behaviors with similar functionality to legacy `can.Map` and uses the [can-connect/can/map/map] behavior\n(which makes use of [can-connect/constructor/constructor]) to connect the connection to the provided Map and List types:\n\n```\nconnect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/data/parse/parse\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\"),\n\trequire(\"can-connect/can/map/map\")\n  ],\n  {\n    Map: Todo,\n    List: Todo.List,\n    ...\n  })\n```\n\n### Connecting to urls\n\nThe [can-connect/data/url/url] behavior supports CRUDing data from urls.  It can be configured like:\n\n```\nconnect([\"data-url\", ...],\n  {\n    ...\n    url: {\n      resource: \"/\",\n      destroyData: \"POST /todos/{id}/delete\",\n      getData: function(params){\n        return $.get(\"/todos/\"+params._id);\n      }\n    },\n    ...\n  });\n```\n\n### Correcting response data\n\nThe [can-connect/data/parse/parse] behavior supports correcting response data.  It can be configured like:\n\n```\nconnect([..., \"data-parse\", ...],\n  {\n    ...\n    parseListData: function(data){\n      return data.todos;\n    },\n    parseInstanceProp: \"todo\",\n    ...\n  });\n```\n\n### Specifying the id\n\nThe id of a model is used in a variety of ways.  It's part of the [can-connect/base/base] behavior\nadded to every connection.  You can customize which property represents the id with [can-connect/base/base.idProp].\n\n```\nconnect([...],\n  {\n    idProp: \"_id\"\n  });\n```\n\n### Retrieving data\n\nThe [can-connect/can/map/map] behavior adds a `getList` and `get` method to the `Map` option.  Use them in\nplace of `findAll` and `findOne`:\n\n```\nTodo.findAll({}).then(function(todosList){ ... });\nTodo.findOne({id: 5}).then(function(todo){ ... });\n```\n\n## Differences from can.Model\n\nModel's produced from `can-connect/can/model`:\n\n - Do not support `makeFindAll` or `makeFindOne`.  If your legacy code did this, you can probably add it as a custom behavior.\n - Has the instance store at `Model.store`, but items should be retrieved like `Model.store.get(id)`.\n - Should not use `Model.models` or `Model.model` to correct Ajax data and should instead use `Models.parseModel` and `Model.parseModels`.\n - Uses a Promise polyfill, not jQuery's promises.\n\n",
    "description": "Exports a constructor that works very similar to [can.Model](http://canjs.com/docs/can.Model.html). \n",
    "type": "module",
    "title": "",
    "name": "can-connect/can/model/model",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "Model.extend( static, prototype )",
        "description": "\n\n  Defines a [can-map] that has almost all of the functionality of\n  `can.Model`.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/super-map/super-map": {
    "src": {
      "path": "node_modules/can-connect/can/super-map/super-map.md"
    },
    "body": "\n\n## Use\n\nThe `can-connect/can/super-map` module exports a helper function that creates a connection\nwith the \"advanced\" behaviors in can-connect and hooks it up to a [can-define/map/map]\nand [can-define/list/list].\n\nIf you are using CanJS, this is an easy way to create a connection that can be useful and\nfast in most circumstances.\n\nTo use it, first define a Map and List constructor function:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({ ... });\nvar TodoList = DefineList.extend({\n\t\"#\": Todo\n});\n```\n\nNext, call `superMap` with all of the options needed by the behaviors that `superMap` adds:\n\n```\nvar todoConnection = superMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\n[can-connect/can/map/map] adds CRUD methods to the `Map` option, you can use those to create,\nread, update and destroy todos:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.set({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nCreate connection with many of the best behaviors in can-connect and hook it up to\na [can-define/map/map].\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect/can/super-map/super-map",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "superMap(options)",
        "description": "\n\n  Creates a connection with the following behaviors: [can-connect/constructor/constructor],\n  [can-connect/can/map/map],\n  [can-connect/constructor/store/store],\n  [can-connect/data/callbacks/callbacks],\n  [can-connect/data/callbacks-cache/callbacks-cache],\n  [can-connect/data/combine-requests/combine-requests],\n  [can-connect/data/parse/parse],\n  [can-connect/data/url/url],\n  [can-connect/real-time/real-time],\n  [can-connect/fall-through-cache/fall-through-cache],\n  [can-connect/constructor/callbacks-once/callbacks-once].\n\n  And creates a [can-connect/data/localstorage-cache/localstorage-cache] to use as a [can-connect/base/base.cacheConnection].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/ref/ref.hydrators": {
    "name": "can-connect/can/ref/ref.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/can/ref/ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.methods": {
    "name": "can-connect/can/ref/ref.methods",
    "title": "methods",
    "type": "group",
    "parent": "can-connect/can/ref/ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref": {
    "name": "can-connect/can/ref/ref",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 155,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n## Use\n\n`can/ref` is useful when the server might return either a reference to\na value or the value itself.  For example, in a MongoDB setup,\na request like `GET /game/5` might return:\n\n```\n{\n  id: 5,\n  teamRef: 7,\n  score: 21\n}\n```\n\nBut a request like `GET /game/5?$populate=teamRef` might return:\n\n```\n{\n  id: 5,\n  teamRef: {id: 7, name: \"Cubs\"},\n  score: 21\n}\n```\n\n`can/ref` can handle this ambiguity and even make lazy loading possible.\n\nTo use `can/ref`, first create a Map and a connection for the referenced type:\n\n```\nvar Team = DefineMap.extend({\n  id: 'string'\n});\n\nconnect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/constructor/store/store\"),\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/can/ref/ref\")\n],{\n    Map: Team,\n    List: Team.List,\n    ...\n})\n```\n\nThe connection is necessary because it creates an instance store which will\nhold instances of `Team` that the `Team.Ref` type will be able to access.\n\nNow we can create a reference to the Team within a Game map and the Game's connection:\n\n```\nvar Game = DefineMap.extend({\n  id: 'string',\n  teamRef: {type: Team.Ref.type},\n  score: \"number\"\n});\n\nsuperMap({\n  Map: Game,\n  List: Game.List\n})\n```\n\nNow, `teamRef` is a [can-connect/can/ref/ref.Map.Ref] type, which will\nhouse the id of the reference no matter how the server returns data, e.g.\n`game.teamRef.id`.\n\nFor example, without populating the team data:\n\n```\nGame.get({id: 5}).then(function(game){\n  game.teamRef.id //-> 7\n});\n```\n\nWith populating the team data:\n\n```\nGame.get({id: 5, $populate: \"teamRef\"}).then(function(game){\n  game.teamRef.id //-> 7\n});\n```\n\nThe values of other properties and methods on the [can-connect/can/ref/ref.Map.Ref] type\nare determined by if the reference was populated or the referenced item already exists\nin the [can-connect/constructor/store/store.instanceStore].\n\nFor example, `value`, which points to the referenced instance, will be populated if the reference was populated:\n\n```\nGame.get({id: 5, $populate: \"teamRef\"}).then(function(game){\n  game.teamRef.value.name //-> 5\n});\n```\n\nOr, it will be populated if that instance had been loaded through another means and\nit’s in the instance store:\n\n```\nTeam.get({id: 7}).then(function(team){\n  // binding adds things to the store\n  team.on(\"name\", function(){})\n}).then(function(){\n  Game.get({id: 5}).then(function(game){\n    game.teamRef.value.name //-> 5\n  });\n})\n```\n\n`value` is an [can-define.types.get asynchronous getter], which means that even if\nthe referenced value isn't populated or loaded through the store, it can be lazy loaded. This\nis generally most useful in a template.\n\nThe following will make an initial request for game `5`, but when the template\ntried to read and listen to `game.teamRef.value.name`, a request for team `7`\nwill be made.\n\n```\nvar template = stache(\"{{game.teamRef.value.name}} scored {{game.score}} points\");\nGame.get({id: 5}).then(function(game){\n  template({game: game});\n});\n```\n\n\n\n",
    "description": "Handle references to instances in the data returned by the server. Allows several means of loading referenced instances, determined on-the-fly.\n\n",
    "title": "can/ref",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "canRef( baseConnection )",
        "description": "\n\nAdds a reference type to [can-connect/can/map/map._Map `connection.Map`] that loads the related type or holds onto\nan existing one. This handles circular references and loads relevant data as needed. The reference type can be loaded\nby:\n- it's data being included in the response for the referencing instance\n- having an existing instance available in the [can-connect/constructor/store/store.instanceStore]\n- lazy loading via the connection for the reference type\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "`can-connect` connection object that is having the `can/ref` behavior added on to it.\nExpects the [can-connect/can/map/map] behavior to already be added to this base connection. If the `connect` helper\nis used to build the connection, the behaviors will automatically be ordered as required.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a connection with the [can-connect/can/map/map._Map `Map`] having the reference type property\n(`Map.Ref.type`) created by `can/ref`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "`can-connect` connection object that is having the `can/ref` behavior added on to it.\nExpects the [can-connect/can/map/map] behavior to already be added to this base connection. If the `connect` helper\nis used to build the connection, the behaviors will automatically be ordered as required.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a connection with the [can-connect/can/map/map._Map `Map`] having the reference type property\n(`Map.Ref.type`) created by `can/ref`.\n"
    },
    "comment": " "
  },
  "can-connect/can/ref/ref.Map.Ref.static": {
    "name": "can-connect/can/ref/ref.Map.Ref.static",
    "title": "static",
    "type": "group",
    "parent": "can-connect/can/ref/ref.Map.Ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.Map.Ref.prototype": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-connect/can/ref/ref.Map.Ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.Map.Ref": {
    "type": "property",
    "name": "can-connect/can/ref/ref.Map.Ref",
    "parent": "can-connect/can/ref/ref.hydrators",
    "src": {
      "line": 164,
      "codeLine": 178,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n",
    "description": "\nA reference type with `instanceRef.value` primed to return an existing instance of the\n[can-connect/can/map/map._Map] type, if available, or lazy load an instance upon accessing `instanceRef.value`.\n",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "title": "Map.Ref",
    "signatures": [
      {
        "code": "new Map.Ref(id, value)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "string"
              }
            ],
            "name": "id",
            "description": "string representing the record id"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "value",
            "description": "properties to be loaded / hydrated"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Map.Ref"
            }
          ],
          "description": "instance reference object for the id\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "value",
      "description": "properties to be loaded / hydrated"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Map.Ref"
        }
      ],
      "description": "instance reference object for the id\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.store": {
    "name": "can-connect/can/ref/ref.Map.Ref.store",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.static",
    "src": {
      "line": 217,
      "codeLine": 223,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": " \n",
    "description": "A WeakReferenceMap that contains instances being created by their `._cid` property.\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map"
      }
    ],
    "title": "store",
    "hide": true
  },
  "can-connect/can/ref/ref.Map.Ref.type": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.type",
    "parent": "can-connect/can/ref/ref.Map.Ref.static",
    "src": {
      "line": 225,
      "codeLine": 236,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n",
    "description": "\nReturns a new instance of `Map.Ref`.\n",
    "title": "type",
    "signatures": [
      {
        "code": "Map.Ref.type(reference)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "name": "reference",
            "description": "either data or an id for an instance of [can-connect/can/map/map._Map]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/can/ref/ref.Map.Ref"
            }
          ],
          "description": "reference instance for the passed data or identifier.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "String"
        },
        {
          "type": "Number"
        }
      ],
      "name": "reference",
      "description": "either data or an id for an instance of [can-connect/can/map/map._Map]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/can/ref/ref.Map.Ref"
        }
      ],
      "description": "reference instance for the passed data or identifier.\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.promise": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.promise",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 246,
      "codeLine": 257,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n",
    "description": "\nReturns a resolved promise if the referenced instance is already available, if not, returns a new promise\nto retrieve the instance by the id.\n",
    "types": [
      {
        "type": "Promise"
      }
    ],
    "title": "promise",
    "hide": true,
    "signatures": [
      {
        "code": "ref.promise",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Promise resolving the instance referenced\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Promise resolving the instance referenced\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.value": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.value",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 283,
      "codeLine": 293,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n",
    "description": "\nReturns the actual instance the reference points to. Returns `undefined` if the instance is still being loaded.\nAccessing this property will start lazy loading if the instance isn't already available.\n",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "value",
    "signatures": [
      {
        "code": "ref.value",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "object"
            }
          ],
          "description": "actual instance referenced or `undefined` if lazy loading ongoing\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "object"
        }
      ],
      "description": "actual instance referenced or `undefined` if lazy loading ongoing\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.reason": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.reason",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 305,
      "codeLine": 315,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n",
    "description": "\nReturns the failure message from the lazy loading promise. Returns `undefined` if the referenced instance is\navailable or loading is ongoing.\n",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "reason",
    "signatures": [
      {
        "code": "ref.reason",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "error message if the promise is rejected\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "error message if the promise is rejected\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isResolved": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isResolved",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 339,
      "codeLine": 348,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n",
    "description": "\nObservable property typically for use in templates to indicate to the user if lazy loading has succeeded.\n",
    "title": "isResolved",
    "signatures": [
      {
        "code": "ref.isResolved",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "`true` if the lazy loading promise was resolved.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "`true` if the lazy loading promise was resolved.\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isRejected": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isRejected",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 351,
      "codeLine": 360,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n",
    "description": "\nObservable property typically for use in templates to indicate to the user if lazy loading has failed.\n",
    "title": "isRejected",
    "signatures": [
      {
        "code": "ref.isRejected",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "`true` if the lazy loading promise was rejected.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "`true` if the lazy loading promise was rejected.\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isPending": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isPending",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 364,
      "codeLine": 373,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n",
    "description": "\nObservable property typically for use in templates to indicate to the user if lazy loading is ongoing.\n",
    "title": "isPending",
    "signatures": [
      {
        "code": "ref.isPending",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "`true` if the lazy loading promise state is not resolved or rejected.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "`true` if the lazy loading promise state is not resolved or rejected.\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.serialize": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.serialize",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 377,
      "codeLine": 387,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n",
    "description": "\nReturn the id of the referenced instance when serializing. Prevents the referenced instance from\nbeing entirely serialized when serializing the referencing instance.\n",
    "title": "serialize",
    "signatures": [
      {
        "code": "ref.serialize",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "string"
            }
          ],
          "description": "id the id of the referenced instance\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "string"
        }
      ],
      "description": "id the id of the referenced instance\n "
    }
  },
  "can-connect/can/tag/tag": {
    "src": {
      "line": 0,
      "codeLine": 32,
      "path": "node_modules/can-connect/can/tag/tag.js"
    },
    "type": "module",
    "body": "\n## Use\n\n```\nconnect.tag(\"order-model\", connection);\n```\n\n```\n<order-model get-list=\"{type=orderType}\">\n  <ul>\n  {{#isPending}}<li>Loading</li>{{/isPending}}\n  {{#isResolved}}\n    {{#each value}}\n      <li>{{name}}</li>\n    {{/each}}\n  {{/isResolved}}\n  </ul>\n</order-model>\n```\n\n\n",
    "description": "\nMakes either getList or getInstance\n",
    "title": "",
    "name": "can-connect/can/tag/tag",
    "parent": "can-connect.modules",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "tagName",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "connection",
        "description": "\n"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "connection",
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/constructor/callbacks-once/callbacks-once": {
    "name": "can-connect/constructor/callbacks-once/callbacks-once",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 19,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "body": "\n",
    "description": "\nPrevents duplicate calls to the instance callback methods.\n",
    "title": "constructor/callbacks-once",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "callbacksOnce( baseConnection )",
        "description": "\n\n  Prevents duplicate calls to the instance callback methods by tracking the last data the methods were called with.\n  If called with the same data again, it does not call the base connection's instance callback.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "`can-connect` connection object that is having the `callbacks-once` behavior added\non to it. Should already contain the behaviors that provide the Instance Callbacks\n(e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the\nbehaviors will automatically be ordered as required.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A `can-connect` connection containing the methods provided by `callbacks-once`.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "`can-connect` connection object that is having the `callbacks-once` behavior added\non to it. Should already contain the behaviors that provide the Instance Callbacks\n(e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the\nbehaviors will automatically be ordered as required.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A `can-connect` connection containing the methods provided by `callbacks-once`.\n\n"
    }
  },
  "can-connect/constructor/callbacks-once/callbacks-once.createdInstance": {
    "src": {
      "line": 25,
      "codeLine": 38,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\n`createdInstance` callback handler that prevents sequential calls with the same arguments.\n",
    "title": "createdInstance",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.createdInstance",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once",
    "signatures": [
      {
        "code": "createdInstance(instance, data)",
        "description": "\nCalled with the instance created by [can-connect/constructor/constructor.save `connection.save`] and the response data of the\nunderlying request. Prevents sequential calls to the underlying `createdInstance` handlers with the same arguments.\n",
        "params": [
          {
            "name": "instance",
            "description": "the instance created by `connection.save`"
          },
          {
            "name": "data",
            "description": "the response data returned during `connection.save`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "name": "data",
      "description": "the response data returned during `connection.save`\n "
    }
  },
  "can-connect/constructor/callbacks-once/callbacks-once.updatedInstance": {
    "src": {
      "line": 39,
      "codeLine": 52,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\n`updatedInstance` callback handler that prevents sequential calls with the same arguments.\n",
    "title": "updatedInstance",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.updatedInstance",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once",
    "signatures": [
      {
        "code": "updatedInstance(instance, data)",
        "description": "\nCalled with the instance updated by [can-connect/constructor/constructor.save`connection.save`] and the response data of the\nunderlying request. Prevents sequential calls to the underlying `updatedInstance` handlers with the same arguments.\n",
        "params": [
          {
            "name": "instance",
            "description": "the instance created by `connection.save`"
          },
          {
            "name": "data",
            "description": "the response data returned during `connection.save`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "name": "data",
      "description": "the response data returned during `connection.save`\n "
    }
  },
  "can-connect/constructor/callbacks-once/callbacks-once.destroyedInstance": {
    "src": {
      "line": 53,
      "codeLine": 66,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\n`destroyedInstance` callback handler that prevents sequential calls with the same arguments.\n",
    "title": "destroyedInstance",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.destroyedInstance",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once",
    "signatures": [
      {
        "code": "destroyedInstance(instance, data)",
        "description": "\nCalled with the instance created by [can-connect/constructor/constructor.destroy `connection.destroy`] and the response data of the\nunderlying request. Prevents sequential calls to the underlying `destroyedInstance` handlers with the same arguments.\n",
        "params": [
          {
            "name": "instance",
            "description": "the instance created by `connection.destroy`"
          },
          {
            "name": "data",
            "description": "the response data returned during `connection.destroy`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "name": "data",
      "description": "the response data returned during `connection.destroy`\n "
    }
  },
  "can-connect/constructor/store/store.stores": {
    "name": "can-connect/constructor/store/store.stores",
    "title": "stores",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 0
  },
  "can-connect/constructor/store/store.callbacks": {
    "name": "can-connect/constructor/store/store.callbacks",
    "title": "CRUD callbacks",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 1
  },
  "can-connect/constructor/store/store.crud": {
    "name": "can-connect/constructor/store/store.crud",
    "title": "CRUD methods",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 2
  },
  "can-connect/constructor/store/store.hydrators": {
    "name": "can-connect/constructor/store/store.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 3
  },
  "can-connect/constructor/store/store": {
    "name": "can-connect/constructor/store/store",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 89,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n\n## Use\n\nThe `constructor-store` behavior is used to:\n - provide a store of instances and lists in use by the client\n - prevent multiple instances from being generated for the same [can-connect/base/base.id] or multiple\n   lists for the same [can-connect/base/base.listSet].\n\nThe store provides access to an instance by its [can-connect/base/base.id] or a list by its\n[can-connect/base/base.listSet]. This is used by other behaviors to lookup instances that should have changes applied.\nTwo examples, when there is a new instance that should be added to a list ([can-connect/real-time/real-time]) or\nwhen newer data is available for a cached instance that is used in the page\n([can-connect/fall-through-cache/fall-through-cache]).\n\nBelow you can see how `constructor-store`'s behavior be used to prevent multiple instances from being generated. This\nexample allows you to create multiple instances of a `todoEditor` that loads and edits a todo instance:\n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/constructor-store.html'></div>\n\nYou can see in this example that you can edit one todo and the other todos update.  This is because each `todoEditor`\nis acting on same instance in memory. When it updates the todo's name here:\n\n```\nvar updateData = function(newName) {\n  todo.name = newName; // update name on todo instance\n  ...\n};\n```\n\nThe other widgets update because they are bound to the same instance:\n\n```\ntodo.on(\"name\", updateElement); // when todo name changes update input element\ntodosConnection.addInstanceReference(todo); // previous line is a new usage of todo, so increase reference count\n```\n\nEach `todoEditor` receives the same instance because it was added to the\n[can-connect/constructor/store/store.instanceStore connnection.instanceStore] by\n[can-connect/constructor/store/store.addInstanceReference]. During all instance retrievals, a connection using the\n`constructor/store` behavior checks the [can-connect/constructor/store/store.instanceStore] for an instance with a\nmatching `id` and return that if it exists. This example always requests `id: 5`, so all the `todoEditor`s use the\nsame instance held in the [can-connect/constructor/store/store.instanceStore].\n\nThis widget cleans itself up when it is removed by removing the listener on the `todo` instance and\n[can-connect/constructor/store/store.deleteInstanceReference reducing the instance reference count]:\n\n```\ntodo.off(\"name\", updateElement); // stop listening to todo name change\ntodosConnection.deleteInstanceReference(todo); // previous line removed a usage of todo, so reduce reference count\n```\nThis is done to prevent a memory leak produced by keeping instances in the `instanceStore` when they are no longer\nneeded by the application.\n\n**Note:** a hazard of sharing the same instance is that if new instance data is loaded from the server during\non-going editing of the instance, the new server data will replace the data that is edited but not yet saved.\nThis is because whenever data is loaded from the server, it is passed to\n[can-connect/constructor/constructor.updatedInstance] which updates the shared instance properties with the new\nserver data.\n\n",
    "description": "\nAdds support for keeping references to active lists and instances. Prevents different copies of an instance from\nbeing used by the application at once. Allows other behaviors to look up instances currently active in the\napplication.\n",
    "title": "constructor/store",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructorStore( baseConnection )",
        "description": "\n\nOverwrites `baseConnection` so it contains a store for instances and lists.  This behavior:\n- extends the [can-connect/constructor/store/store.hydrateInstance] and\n[can-connect/constructor/store/store.hydrateList] methods to return instances or lists from the store, if available\n- overwrites \"CRUD\" methods to make sure that while requests are pending, new lists and instances have references\nkept in the store. This prevents duplicated instances from being created during concurrent requests.\n- provides methods to add and remove items in the store by counting references\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "`can-connect` connection object that is having the `constructor/store` behavior added\non to it. Should already contain a behavior that provides the InstanceInteface\n(e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the behaviors\nwill automatically be ordered as required.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a `can-connect` connection containing the method implementations provided by `constructor/store`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "`can-connect` connection object that is having the `constructor/store` behavior added\non to it. Should already contain a behavior that provides the InstanceInteface\n(e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the behaviors\nwill automatically be ordered as required.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a `can-connect` connection containing the method implementations provided by `constructor/store`.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.instanceStore": {
    "name": "can-connect/constructor/store/store.instanceStore",
    "type": "property",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 122,
      "codeLine": 140,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nA mapping of instances keyed by their [can-connect/base/base.id].\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "\n\nStores instances by their [can-connect/base/base.id]. Holds instances based on reference counts which\nare incremented by [can-connect/constructor/store/store.addInstanceReference] and decremented by\n[can-connect/constructor/store/store.deleteInstanceReference]. Once a reference count is 0, the instance is no\nlonger held in the store. Once a reference count is greater than 0, the instance is added to the store.\n\n```js\nconnection.addInstanceReference(todo5);\nconnection.instanceStore.get(\"5\") //-> todo5\n```\n\t "
      }
    ],
    "title": "instanceStore"
  },
  "can-connect/constructor/store/store.listStore": {
    "name": "can-connect/constructor/store/store.listStore",
    "type": "property",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 144,
      "codeLine": 162,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nA mapping of lists keyed by their [can-connect/base/base.listSet].\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "\n\nStores lists by their [can-connect/base/base.listSet]. Hold lists based on reference counts which are incremented\nby [can-connect/constructor/store/store.addListReference] and decremented by\n[can-connect/constructor/store/store.deleteListReference]. Once a reference count is 0, the list is no\nlonger held in the store. Once a reference count is greater than 0, the list is added to the store.\n\n```js\nconnection.addInstanceReference(allTodos, {});\nconnection.instanceStore.get({}) //-> allTodos\n```\n\t "
      }
    ],
    "title": "listStore"
  },
  "can-connect/constructor/store/store.addInstanceReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.addInstanceReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 180,
      "codeLine": 238,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe [can-connect/constructor/store/store.instanceStore] contains a mapping of instances keyed by their\n[can-connect/base/base.id]. The [can-connect/constructor/store/store.instanceStore] is used to prevent creating\nthe same instance multiple times, and for finding active instance for a given id.  Instances need to be added to\nthis store for this to work.  To do this, call `addInstanceReference`:\n\n```\n// a basic connection\nvar constructorStore = require(\"can-connect/constructor/store/\");\nvar constructor = require(\"can-connect/constructor/\");\nvar dataUrl = require(\"can-connect/data/url/\");\nvar todoConnection = connect([dataUrl, constructorStore, constructor], {\n  url: \"/todos\"\n});\n\nvar originalTodo;\n\n// get a todo\ntodoConnection.get({id: 5}).then(function( todo ){\n  // add it to the store\n  todoConnection.addInstanceReference(todo);\n  originalTodo = todo;\n});\n```\n\nNow, if you were to retrieve the same data sometime later, it would be the same instance:\n\n```\ntodoConnection.get({id: 5}).then(function( todo ){\n  todo === originalTodo // true\n});\n```\n\nThe `.getData` response data (underlying the call to `todoConnection.get`) is passed, along with the existing todo\ninstance (`originalTodo`) to [can-connect/constructor/constructor.updatedInstance]. That updates the shared\ninstance with the newly retrieved data.\n\nAll the referenced instances are held in memory.  Use\n[can-connect/constructor/store/store.deleteInstanceReference] to remove them.\n\nTypically, `addInstanceReference` is called when something expresses interest in the instance, such\nas an event binding, and `deleteInstanceReference` is called when the interest is removed.\n\t \n",
    "description": "\nAdd a reference to the [can-connect/constructor/store/store.instanceStore] so an instance can be easily looked up.\n",
    "title": "addInstanceReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\nAdds a reference to an instance by [can-connect/base/base.id] to the [can-connect/constructor/store/store.instanceStore].\nKeeps a count of the number of references, removing the instance from the store when the count reaches 0.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance to add\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "the instance to add\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.callbacks.createdInstance": {
    "type": "function",
    "name": "can-connect/constructor/store/store.callbacks.createdInstance",
    "parent": "can-connect/constructor/store/store.callbacks",
    "src": {
      "line": 249,
      "codeLine": 263,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nCalls `createdInstance` on the underlying behavior and moves the new instance from the `newInstanceStore` to\n`instanceStore` if needed.\n",
    "title": "createdInstance",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\nCalls the base behavior. Then calls [can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore]\nto move any pre-creation instance references to the standard instance reference store.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance that was created"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the data returned from [can-connect/connection.createData]\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the data returned from [can-connect/connection.createData]\n\t "
    }
  },
  "can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore": {
    "type": "function",
    "name": "can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 270,
      "codeLine": 289,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nMoves recently created instances into the [can-connect/constructor/store/store.instanceStore].\n",
    "title": "moveCreatedInstanceToInstanceStore",
    "signatures": [
      {
        "code": "moveCreatedInstanceToInstanceStore( instance )",
        "description": "\nChecks if an instance has an `id` and is in the `newInstanceStore`. If so, it adds it into the\n[can-connect/constructor/store/store.instanceStore] and removes it from the `newInstanceStore`.\n\nA new instances may have been added to the `newInstanceStore` if [can-connect/constructor/store/store.addInstanceReference]\nis called on is before the instance has been saved. This is done so we can keep track of references for unsaved\ninstances and update the references to be keyed by `id` when one is available. Without this a request for a\ncurrently referenced instance that was just saved for the first time will erroneously result in a new instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "an instance.  If it was \"referenced\" (bound to) prior to\nbeing created, this will check for that condition and move this instance into the\n[can-connect/constructor/store/store.instanceStore].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "an instance.  If it was \"referenced\" (bound to) prior to\nbeing created, this will check for that condition and move this instance into the\n[can-connect/constructor/store/store.instanceStore].\n\t "
    }
  },
  "can-connect/constructor/store/store.deleteInstanceReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.deleteInstanceReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 314,
      "codeLine": 343,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nRemove a reference from the [can-connect/constructor/store/store.instanceStore] so an instance can be garbage\ncollected.\n",
    "title": "deleteInstanceReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\nDecrements the number of references to an instance in the [can-connect/constructor/store/store.instanceStore].\nRemoves the instance if there are no longer any references.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the instance to remove\n\n### Usage\n\n`deleteInstanceReference` is called to remove references to instances in the\n[can-connect/constructor/store/store.instanceStore] so that instances maybe garbage collected.  It's usually\ncalled when the application or some part of the application no longer is interested in an instance.\n\n[can-connect/constructor/store/store.addInstanceReference] has an example of adding an instance to the store.\nThe following continues that example to remove the `originalTodo` instance from the store:\n\n```\ntodoConnection.deleteInstanceReference(originalTodo);\n```\n\nAlso see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete\nexample of the lifecycle of a reference.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "the instance to remove\n\n### Usage\n\n`deleteInstanceReference` is called to remove references to instances in the\n[can-connect/constructor/store/store.instanceStore] so that instances maybe garbage collected.  It's usually\ncalled when the application or some part of the application no longer is interested in an instance.\n\n[can-connect/constructor/store/store.addInstanceReference] has an example of adding an instance to the store.\nThe following continues that example to remove the `originalTodo` instance from the store:\n\n```\ntodoConnection.deleteInstanceReference(originalTodo);\n```\n\nAlso see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete\nexample of the lifecycle of a reference.\n\t "
    }
  },
  "can-connect/constructor/store/store.addListReference": {
    "type": "property",
    "name": "can-connect/constructor/store/store.addListReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 353,
      "codeLine": 414,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe [can-connect/constructor/store/store.listStore] contains a mapping of lists keyed by their `set`. The\n[can-connect/constructor/store/store.listStore] is used to prevent creating the same list multiple times and for\nidentifying a list for a given set. Lists need to be added to this store for this to work.  To do this, call\n`addListReference`:\n\n```\n// A basic connection:\nvar constructorStore = require(\"can-connect/constructor/store/\");\nvar constructor = require(\"can-connect/constructor/\");\nvar dataUrl = require(\"can-connect/data/url/\");\nvar todoConnection = connect([dataUrl, constructorStore, constructor], {\n  url: \"/todos\"\n});\n\nvar dueToday;\n\n// get a todo list\ntodoConnection.getList({due: \"today\"}).then(function( todos ){\n  // add it to the store\n  todoConnection.addListReference(todos, {due: \"today\"});\n  dueToday = todos;\n});\n```\n\nNow, if you were to retrieve the same set of data sometime later, it would be the same list instance:\n\n```\ntodoConnection.get({due: \"today\"}).then(function( todos ){\n  todos === dueToday //-> true\n});\n```\n\nThe `.getListData`  response data (underlying the call to `todoConnection.getList`) is passed, along with the\nexisting list (`dueToday`) to [can-connect/constructor/constructor.updatedList]. That updates the shared list\ninstance with the newly retrieved data.\n\nAll the referenced lists stay in memory.  Use [can-connect/constructor/store/store.deleteListReference]\nto remove them.\n\nTypically, `addListReference` is called when something expresses interest in the list, such\nas an event binding, and `deleteListReference` is called when interest is removed.\n\n\t \n",
    "description": "\nAdd a reference to the [can-connect/constructor/store/store.listStore] so a list can be easily looked up.\n",
    "types": [
      {
        "type": "WeakReferenceMap"
      }
    ],
    "title": "addListReference",
    "signatures": [
      {
        "code": "connection.addListReference( list[, set] )",
        "description": "\nAdds a reference to a list by `set` (or by [can-connect/base/base.listSet]) to the\n[can-connect/constructor/store/store.listStore].  Keeps a count of the number of references, removing the list\nfrom the store when the count reaches 0.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "the list to add"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "optional": true,
            "name": "set",
            "description": "the set this list represents if it can't be identified with [can-connect/base/base.listSet]\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "optional": true,
      "name": "set",
      "description": "the set this list represents if it can't be identified with [can-connect/base/base.listSet]\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.deleteListReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.deleteListReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 420,
      "codeLine": 449,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nRemoves a reference from the [can-connect/constructor/store/store.listStore] so a list can can be garbage\ncollected.\n",
    "title": "deleteListReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\nDecrements the number of references to a list in the [can-connect/constructor/store/store.listStore].\nRemoves the list if there are no longer any references.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "list",
            "description": "the list to remove\n\n### Usage\n\n`deleteListReference` is called to remove references to instances in the\n[can-connect/constructor/store/store.listStore] so that lists maybe garbage collected.  It's usually called when\nthe application or some part of the application no longer is interested in a list.\n\n[can-connect/constructor/store/store.addListReference] has an example of adding a list to the store.  The\nfollowing continues that example to remove the `dueToday` list from the store:\n\n```\ntodoConnection.deleteListReference(dueToday);\n```\n\nAlso see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete\nexample of the lifecycle of a reference.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "list",
      "description": "the list to remove\n\n### Usage\n\n`deleteListReference` is called to remove references to instances in the\n[can-connect/constructor/store/store.listStore] so that lists maybe garbage collected.  It's usually called when\nthe application or some part of the application no longer is interested in a list.\n\n[can-connect/constructor/store/store.addListReference] has an example of adding a list to the store.  The\nfollowing continues that example to remove the `dueToday` list from the store:\n\n```\ntodoConnection.deleteListReference(dueToday);\n```\n\nAlso see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete\nexample of the lifecycle of a reference.\n\t "
    }
  },
  "can-connect/constructor/store/store.hydratedInstance": {
    "src": {
      "line": 455,
      "codeLine": 469,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nKeeps new instances in the [can-connect/constructor/store/store.instanceStore] for the lifetime of any\nconcurrent requests.\n",
    "title": "hydratedInstance",
    "name": "can-connect/constructor/store/store.hydratedInstance",
    "parent": "can-connect/constructor/store/store.hydrators",
    "signatures": [
      {
        "code": "hydratedInstance(instance)",
        "description": "\nAdds a reference for new instances for the lifetime of any concurrent requests. Called when a new instance is\ncreated during [can-connect/constructor/store/store.hydrateInstance hydration]. This prevents concurrent requests\nfor the same data from returning different instances.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "the newly hydrated instance\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "the newly hydrated instance\n\t "
    }
  },
  "can-connect/constructor/store/store.hydrateInstance": {
    "type": "function",
    "name": "can-connect/constructor/store/store.hydrateInstance",
    "parent": "can-connect/constructor/store/store.hydrators",
    "src": {
      "line": 481,
      "codeLine": 497,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nReturns an instance given raw data, returning it from the [can-connect/constructor/store/store.instanceStore] if\navailable.\n",
    "title": "hydrateInstance",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\nOverwrites the base `hydrateInstance` so that if a matching instance is in the\n[can-connect/constructor/store/store.instanceStore], that instance will be\n[can-connect/constructor/constructor.updatedInstance updated] with `props` and returned.  If there isn't a\nmatching instance, the base `hydrateInstance` will be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the raw data used to create an instance"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "a typed instance either created or updated with the data from `props`.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the raw data used to create an instance"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "a typed instance either created or updated with the data from `props`.\n\t "
    }
  },
  "can-connect/constructor/store/store.hydratedList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.hydratedList",
    "parent": "can-connect/constructor/store/store.hydrators",
    "src": {
      "line": 510,
      "codeLine": 524,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nKeeps new lists in the [can-connect/constructor/store/store.listStore] for the lifetime of any concurrent\nrequests.\n",
    "title": "hydratedList",
    "signatures": [
      {
        "code": "hydratedList(list)",
        "description": "\nAdds a reference for new lists for the lifetime of any concurrent requests. Called when a new list is\ncreated during [can-connect/constructor/store/store.hydrateList hydration]. This prevents concurrent requests\nfor the same data from returning different instances.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "the newly hydrated list\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "the newly hydrated list\n\t "
    }
  },
  "can-connect/constructor/store/store.hydrateList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.hydrateList",
    "parent": "can-connect/constructor/store/store.hydrators",
    "src": {
      "line": 536,
      "codeLine": 554,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nReturns a list given raw data, returning it from the [can-connect/constructor/store/store.listStore] if\navailable.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList( listData, set )",
        "description": "\n\n  Overwrites the base `hydrateList` so that if a matching list is in the\n  [can-connect/constructor/store/store.listStore], that list will be\n  [can-connect/constructor/constructor.updatedList updated] with `listData` and returned.\n  If there isn't a matching list, the base `hydrateList` will be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "raw list data to hydrate into a list type"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "the parameters that represent the set of data in `listData`"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "List"
            }
          ],
          "description": "a typed list from either created or updated with the data from `listData`\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "the parameters that represent the set of data in `listData`"
    },
    "_curReturn": {
      "types": [
        {
          "type": "List"
        }
      ],
      "description": "a typed list from either created or updated with the data from `listData`\n\t "
    }
  },
  "can-connect/constructor/store/store.getList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.getList",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 568,
      "codeLine": 584,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nExtends the underlying [can-connect/connection.getList] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\nor [can-connect/constructor/store/store.hydrateList lists hydrated] during this request are kept in the store until\nall the concurrent requests complete.\n",
    "title": "getList",
    "signatures": [
      {
        "code": "connection.getList( set )",
        "description": "\nIncrements an internal request counter so instances hydrated during this request will be stored, and then\ndecrements the counter after the request is complete. This prevents concurrent requests for the same data from\nreturning different instances.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "listSet",
            "description": "parameters specifying the list to retrieve"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect/Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` returned by the underlying behavior's [can-connect/connection.getList]\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "listSet",
      "description": "parameters specifying the list to retrieve"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` returned by the underlying behavior's [can-connect/connection.getList]\n\t "
    }
  },
  "can-connect/constructor/store/store.get": {
    "type": "function",
    "name": "can-connect/constructor/store/store.get",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 597,
      "codeLine": 612,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nExtends the underlying [can-connect/connection.get] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\nduring this request are kept in the store until all the concurrent requests complete.\n",
    "title": "get",
    "signatures": [
      {
        "code": "connection.get( params )",
        "description": "\nIncrements an internal request counter so instances hydrated during this request will be stored, and then\ndecrements the counter after the request is complete. This prevents concurrent requests for the same data from\nreturning different instances.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "params used to specify which instance to retrieve."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect/Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` returned by the underlying behavior's [can-connect/connection.get]\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "params used to specify which instance to retrieve."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` returned by the underlying behavior's [can-connect/connection.get]\n\t "
    }
  },
  "can-connect/constructor/store/store.save": {
    "type": "function",
    "name": "can-connect/constructor/store/store.save",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 625,
      "codeLine": 641,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nExtends the underlying [can-connect/connection.save] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\nduring this request are kept in the store until all the concurrent requests complete.\n",
    "title": "save",
    "signatures": [
      {
        "code": "connection.save( instance )",
        "description": "\n\nIncrements an internal request counter so instances hydrated during this request will be stored, and then\ndecrements the counter after the request is complete. This prevents concurrent requests for the same data from\nreturning different instances.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "a typed instance being saved"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect/Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` returned by the underlying behavior's [can-connect/connection.save]\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "a typed instance being saved"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` returned by the underlying behavior's [can-connect/connection.save]\n\t "
    }
  },
  "can-connect/constructor/store/store.destroy": {
    "type": "function",
    "name": "can-connect/constructor/store/store.destroy",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 662,
      "codeLine": 677,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nExtends the underlying [can-connect/connection.destroy] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\nduring this request are kept in the store until all the concurrent requests complete.\n",
    "title": "destroy",
    "signatures": [
      {
        "code": "connection.destroy( instance )",
        "description": "\nIncrements an internal request counter so instances hydrated during this request will be stored, and then\ndecrements the counter after the request is complete. This prevents concurrent requests for the same data from\nreturning different instances.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "a typed instance being deleted"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect/Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` returned by the underlying behavior's [can-connect/connection.destroy]\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "a typed instance being deleted"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` returned by the underlying behavior's [can-connect/connection.destroy]\n\t "
    }
  },
  "can-connect/connection.clear": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/clear.md"
    },
    "body": "\n## Use\n\nImplement `clear` to remove all data in a connection.\n\n```js\nconnect.behavior(\"my-behavior\", function(baseConnection){\n\treturn {\n\t\tclear: function(){\n\t\t\t// delete tabs, or clear localStorage, etc\n\t\t}\n\t}\n})\n```\n\n",
    "description": "Deletes all records on a connection. \n",
    "type": "typedef",
    "title": "clear",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Returns a promise that resolves when all data is cleared.\n"
        },
        "params": [],
        "description": "\n\nDeletes all records on a connection.\n"
      }
    ],
    "name": "can-connect/connection.clear",
    "parent": "can-connect/DataInterface",
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Returns a promise that resolves when all data is cleared.\n"
    },
    "comment": " "
  },
  "can-connect/connection.createData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/createData.md"
    },
    "body": "",
    "description": "Creates a new record in the connection. \n",
    "type": "typedef",
    "title": "createData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise resolved with the _created_ data of the newly created instance. The _created_\ndata __must__ have the [can-connect/base/base.id] of the created record.  \n\nBy default, [can-connect/constructor/constructor.createdInstance] only adds the data in `createdInstanceData` to\n`myInstance`, it does not remove it.  To remove \"missing\" properties on `myInstance` that are not in `createdInstanceData`, overwrite\n[can-connect/constructor/constructor.createdInstance].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "cid",
            "description": "A unique id that represents the instance that is being created.  Given this value,\nthe instance can be retrieved in the [can-connect/constructor/constructor.cidStore].\n"
          }
        ],
        "description": "\n\nCreates a new record given the serialized form of the data. Resolves to a promise with any additional\nproperties that should be added to the\ninstance. A [can-util/js/cid/cid client ID] is passed of the instance that is\nbeing created.\n\nThe following shows how [can-connect/constructor/constructor] calls `createData`\nand what it does with the response:\n\n```js\nvar CID = require(\"can-util/js/cid/cid\");\n\n// Create an instance of a special type\nvar myInstance = new MyType({ ... });\n\n// get its CID\nvar cid = CID(myInstance);\n\n// get its raw data\nvar instanceData = connection.serializeInstance(myInstance);\n\nconnection.createData(instanceData, cid).then(function(createdInstanceData){\n\tconnection.createdInstance(myInstance, createdInstanceData);\n})\n```\n\n"
      }
    ],
    "name": "can-connect/connection.createData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "cid",
      "description": "A unique id that represents the instance that is being created.  Given this value,\nthe instance can be retrieved in the [can-connect/constructor/constructor.cidStore].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise resolved with the _created_ data of the newly created instance. The _created_\ndata __must__ have the [can-connect/base/base.id] of the created record.  \n\nBy default, [can-connect/constructor/constructor.createdInstance] only adds the data in `createdInstanceData` to\n`myInstance`, it does not remove it.  To remove \"missing\" properties on `myInstance` that are not in `createdInstanceData`, overwrite\n[can-connect/constructor/constructor.createdInstance].\n"
    }
  },
  "can-connect/DataInterface": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/data_interface.md"
    },
    "body": "",
    "description": "The most common __raw__ data methods. \n",
    "type": "typedef",
    "title": "DataInterface",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-connect/DataInterface",
    "parent": "can-connect.types",
    "signatures": [
      {
        "code": "DataInterface",
        "description": "\n\nThe `DataInterface` methods are the methods most used most commonly\nby `can-connect` behaviors to get or mutate information in some form of\npersisted storage.  The `DataInterface` methods only operate on __raw__\ndata comprised of plain JavaScript Objects, Arrays and primitive types.\nThis is in contrast to the [can-connect/InstanceInterface] methods that\noperate on typed data.\n\nThose methods are:\n\n- [can-connect/connection.clear] - Remove all records.\n- [can-connect/connection.createData] - Create a new record.\n- [can-connect/connection.destroyData] - Destroy a record.\n- [can-connect/connection.getData] - Get a single record.\n- [can-connect/connection.getListData] - Get multiple records.\n- [can-connect/connection.getSets] - Get the [can-set/Set]s available within the persisted storage.\n- [can-connect/connection.updateData] - Update a single record.\n- [can-connect/connection.updateListData] - Update multiple records.\n\nBehaviors either implement these methods or overwrite these methods to perform some\nextra functionality.  \n\nFor example, [can-connect/data/url/url] implements these behaviors to\nmake an Ajax request like:\n\n```js\nconnect.behavior(\"data/url\", function(baseConnection) {\n\treturn {\n\t\tgetListData: function(set){\n\t\t\treturn ajax({\n\t\t\t\ttype: \"GET\",\n\t\t\t\turl: this.url,\n\t\t\t\tdata: set\n\t\t\t});\n\t\t},\n\t\tgetData: function(){ ... },\n\t\t...\n\t}\n});\n```\n\nThe [can-connect/data/parse/parse] behavior overwrites the `baseConnection`’s methods to\nperform cleanup on the response data:\n\n```js\nconnect.behavior(\"data/parse\", function(baseConnection) {\n\treturn {\n\t\tgetListData: function(set){\n\t\t\tvar self = this;\n\t\t\treturn baseConnection.getListData(set).then(function(response){\n\t\t\t\treturn self.parseListData(response);\n\t\t\t});\n\t\t},\n\t\tgetData: function(){ ... },\n\t\t...\n\t}\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-connect/connection.destroyData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/destroyData.md"
    },
    "body": "",
    "description": "Destroys a record in the collection. \n",
    "type": "typedef",
    "title": "destroyData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise resolved with the _destroyed_ data of the instance. The _destroyed_\ndata.  \n\nBy default, [can-connect/constructor/constructor.destroyedInstance] deletes properties in `myInstance` that are not in `destroyedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.destroyedInstance].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          }
        ],
        "description": "\n\nDestroys an instance given the serialized form of the\ndata. Returns any additional properties that should be added to the instance.\n\nThe following shows how [can-connect/constructor/constructor] calls `destroyData` and\nwhat it does with the response:\n\n```js\n// get its raw data\nvar instanceData = connection.serializeInstance(myInstance);\n\nconnection.destroyData(instanceData).then(function(destroyedInstanceData){\n\tconnection.destroyedInstance(myInstance, createdInstanceData);\n});\n```\n"
      }
    ],
    "name": "can-connect/connection.destroyData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise resolved with the _destroyed_ data of the instance. The _destroyed_\ndata.  \n\nBy default, [can-connect/constructor/constructor.destroyedInstance] deletes properties in `myInstance` that are not in `destroyedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.destroyedInstance].\n"
    }
  },
  "can-connect/connection.getData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getData.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/url/url] implement `getData`  but implementing it yourself can be as simple as:\n\n```js\nvar behavior = connect([],{\n  getData: function(params){\n    return new Promise(function(resolve, reject){\n\t\t$.get(\"/api/todo\",params).then(resolve, reject)\n\t});\n  }\n})\n```\n\n",
    "description": "Retrieves a record. \n",
    "type": "typedef",
    "title": "getData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the properties of a record.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "A object that represents the set of data needed to be loaded.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to the instance data for particular parameters.\n\n  The following shows how [can-connect/constructor/constructor] calls `getData`\n  and what it does with the response:\n\n  ```js\n  connection.getData({id: 1}).then(function(instanceData){\n  \tconnection.hydrateInstance(instanceData);\n  });\n  ```\n"
      }
    ],
    "name": "can-connect/connection.getData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "A object that represents the set of data needed to be loaded.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the properties of a record.\n"
    },
    "comment": " "
  },
  "can-connect/connection.getListData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getListData.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/url/url] make it easy to implement `getListData`, but it can be as simple as:\n\n```js\nvar connection = connect([],{\n  getListData: function(set){\n    return new Promise(function(resolve, reject){\n\t\t$.get(\"/api/todos\",set).then(resolve, reject)\n\t});\n  }\n})\n```\n\n",
    "description": "Retrieves list of records for the given set. \n",
    "type": "typedef",
    "title": "getListData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the [can-connect.listData] format like:\n\n```js\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ],\n  count: 1000\n}\n```\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded.  For example, `{complete: true}`\nmight represent the set of all completed records.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to a [can-connect.listData] for a particular set.  \n\n  ```js\n  connection.getListData({complete: true}).then(function(listData){\n\t  connection.hydrateList(listData);\n  });\n  ```\n"
      }
    ],
    "name": "can-connect/connection.getListData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded.  For example, `{complete: true}`\nmight represent the set of all completed records.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the [can-connect.listData] format like:\n\n```js\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ],\n  count: 1000\n}\n```\n"
    },
    "comment": " "
  },
  "can-connect/connection.getSets": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getSets.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/localstorage-cache/localstorage-cache] implement\n`.getSets` to provide the sets they contain.\n\n",
    "description": "Gets the sets that are available in the connection. \n",
    "type": "typedef",
    "title": "getSets",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "can-set/Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to an an array of sets.\n"
        },
        "params": [],
        "description": "\n\n  Returns a promise that resolves to a list of [can-set/Set] objects contained in the\n  connection.  This is useful for querying a [can-connect/base/base.cacheConnection]\n  if it will be able to satisfy a request.\n\n  An example response might look like:\n\n  ```js\n  connection.getSets().then(function(sets){\n\t  sets //-> [\n\t  //   {complete: true},\n\t  //   {userId: 5, start: 10, end: 20}\n\t  //]\n  })\n  ```\n"
      }
    ],
    "name": "can-connect/connection.getSets",
    "parent": "can-connect/DataInterface",
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can-set/Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to an an array of sets.\n"
    },
    "comment": " "
  },
  "can-connect/connection.updateData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/updateData.md"
    },
    "body": "",
    "description": "Updates a record in the collection. \n",
    "type": "typedef",
    "title": "updateData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise resolved with the _updated_ data of the newly created instance.  \n\nBy default, [can-connect/constructor/constructor.updatedInstance] deletes properties in `myInstance` that are not in `updatedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.updatedInstance].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          }
        ],
        "description": "\n\nUpdates a record given the serialized form of the data. Returns a promise\nthat resolves to a object that contains the new properties and values\nof the record.\n\nAn example request and response might look like:\n\n```js\nconnection.updateData({\n\tid: 5,\n\tname: \"do dishes\",\n\tcreatedAt: 1477104548997\n}).then(function(instanceData){\n\tinstanceData //-> {\n\t//\tid: 5,\n\t//\tname: \"do dishes\",\n\t//\tcreatedAt: 1477104540000,\n\t//\tupdatedAt: 1477104580000\n\t//}\n})\n```\n\nThe following shows how [can-connect/constructor/constructor] calls `updateData`\nand what it does with the response:\n\n```js\n// get its raw data\nvar instanceData = connection.serializeInstance(myInstance);\n\nconnection.updateData(instanceData).then(function(updatedInstanceData){\n  connection.updatedInstance(myInstance, updatedInstanceData);\n})\n```\n"
      }
    ],
    "name": "can-connect/connection.updateData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise resolved with the _updated_ data of the newly created instance.  \n\nBy default, [can-connect/constructor/constructor.updatedInstance] deletes properties in `myInstance` that are not in `updatedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.updatedInstance].\n"
    }
  },
  "can-connect/connection.updateListData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/updateListData.md"
    },
    "body": "\n",
    "description": "Updates records for a particular set in the connection. \n",
    "type": "typedef",
    "title": "updateListData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the updated [can-connect.listData].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "A object that represents the set of data needed to be loaded.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "set",
            "description": "The set of data that is updating.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to the list data for a particular set.\n\n  ```js\n  connection.updateListData({\n\t  data: [\n\t\t  {id: 1, name: \"dishes\", createdAt: 1477104548997}\n\t  ]\n  }, {}).then(function(listData){\n\t  listData //-> {\n\t  //\t  data: [\n\t  //\t\t  {id: 1, name: \"dishes\",\n\t  //\t\t   createdAt: 1477104548997, updatedAt: 1477104580000}\n\t  //\t  ]\n\t  //}\n  })\n  ```\n"
      }
    ],
    "name": "can-connect/connection.updateListData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "set",
      "description": "The set of data that is updating.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the updated [can-connect.listData].\n"
    },
    "comment": " "
  },
  "can-connect/connection.destroy": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/destroy.md"
    },
    "body": "\n",
    "description": "\nDestroy an instance.\n",
    "title": "destroy",
    "name": "can-connect/connection.destroy",
    "type": "function",
    "parent": "can-connect/InstanceInterface",
    "signatures": [
      {
        "code": "connection.destroy( instance )",
        "description": "\n\nDestroys an instance using the `connection` by calling\n[can-connect/connection.destroyData].\n\n```js\n// get an instance\nconnection.get({id: 5}).then(function( instance ){\n\n\t// destroy it\n\tconnection.destroy( instance );\n})\n```\n\nNote that [can-connect/can/map/map] adds `destroy` to the `instance`\ntype's prototype.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "A typed instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect/Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that\nresolve with destroyed instance if [can-connect/connection.destroyData] is resolved.  The promise is rejected if [can-connect/connection.destroyData] is rejected.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "A typed instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that\nresolve with destroyed instance if [can-connect/connection.destroyData] is resolved.  The promise is rejected if [can-connect/connection.destroyData] is rejected.\n"
    }
  },
  "can-connect/connection.get": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/get.md"
    },
    "body": "\nGets a [can-connect/Instance].\n\n",
    "description": "\n",
    "title": "get",
    "name": "can-connect/connection.get",
    "type": "function",
    "parent": "can-connect/InstanceInterface",
    "signatures": [
      {
        "code": "connection.get( params )",
        "description": "\n\nGet a single [can-connect/Instance] using the `connection` by calling\n[can-connect/connection.getData].\n\n```js\nconnection.get({id: 5}).then(function(instance){\n\n});\n```\n\nNote that [can-connect/can/map/map] adds `get` to the `instance`'s\nconstructor function.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that specifies an instance to retrieve.  Typically, the object contains the `id` property and the `id` value of the\ninstance that should be retrieved like `{_id: \"saq232la8kjsa\"}`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.List"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that\nresolve with a `List` if [can-connect/connection.getData] is resolved.  The promise is rejected if [can-connect/connection.getData] is rejected.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that specifies an instance to retrieve.  Typically, the object contains the `id` property and the `id` value of the\ninstance that should be retrieved like `{_id: \"saq232la8kjsa\"}`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.List"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that\nresolve with a `List` if [can-connect/connection.getData] is resolved.  The promise is rejected if [can-connect/connection.getData] is rejected.\n"
    }
  },
  "can-connect/connection.save": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/save.md"
    },
    "body": "\n",
    "description": "\nCreate or update an instance.\n",
    "title": "save",
    "name": "can-connect/connection.save",
    "type": "function",
    "parent": "can-connect/InstanceInterface",
    "signatures": [
      {
        "code": "connection.save( instance )",
        "description": "\n\nCreates or updates an instance using the `connection` by calling\n[can-connect/connection.createData] or [can-connect/connection.updateData].\n\n```js\n// create an instance\nvar instance = new Type();\n\n// create it with the connection\nconnection.save( instance ).then(function(instance){\n\n\t// change the instance\n\tinstance.prop = \"NEW VALUE\";\n\n\t// update it with the connection\n\tconnection.save( instance ).then(function(instance){\n\n\t});\n\n});\n```\n\nThe choice of [can-connect/connection.createData] or [can-connect/connection.updateData] is made by the result of\n[can-connect/constructor/constructor.isNew].\n\n\n\nNote that [can-connect/can/map/map] adds `save` to the `instance`\ntype's prototype.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "A typed instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect/Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that\nresolve with created or updated instance if [can-connect/connection.createData] or [can-connect/connection.updateData] is resolved.  The promise is rejected if [can-connect/connection.createData] or [can-connect/connection.updateData] is rejected.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "A typed instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that\nresolve with created or updated instance if [can-connect/connection.createData] or [can-connect/connection.updateData] is resolved.  The promise is rejected if [can-connect/connection.createData] or [can-connect/connection.updateData] is rejected.\n"
    }
  },
  "can-connect/connection.getList": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/getList.md"
    },
    "body": "\n",
    "description": "\nGets a [can-connect.List] of instances.\n",
    "title": "getList",
    "name": "can-connect/connection.getList",
    "type": "function",
    "parent": "can-connect/InstanceInterface",
    "signatures": [
      {
        "code": "connection.getList( set )",
        "description": "\n\nGets a [can-connect.List] of instances using the `connection` by calling\n[can-connect/connection.getListData].\n\n```js\nconnection.getList({parentId: 5}).then(function(list){\n\n});\n```\n\nNote that [can-connect/can/map/map] adds `getList` to the `instance`'s\nconstructor function.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A set object that represents the list of data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.List"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that\nresolve with a `List` if [can-connect/connection.getListData] is resolved.  The promise is rejected if [can-connect/connection.getListData] is rejected.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A set object that represents the list of data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.List"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that\nresolve with a `List` if [can-connect/connection.getListData] is resolved.  The promise is rejected if [can-connect/connection.getListData] is rejected.\n"
    }
  },
  "can-connect/data/callbacks/callbacks": {
    "name": "can-connect/data/callbacks/callbacks",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 41,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "\n",
    "description": "\nExtend [can-connect/DataInterface] methods to call callbacks with the raw response data.\n",
    "title": "data/callbacks",
    "signatures": [
      {
        "code": "dataCallbacks( baseConnection )",
        "description": "\n\nExtends the [can-connect/DataInterface] create, update, read & delete methods to call 'callback' methods following\ntheir execution. Callbacks are called with the data returned from the underlying behavior's [can-connect/DataInterface]\nimplementation.\n\nFor example:\n```\nvar dataUrl = require(\"can-connect/data/url/\");\nvar dataCallbacks = require(\"can-connect/data/url\");\nvar logging = {\n  createdData: function(responseData) {\n    console.log('New Todo Saved: ', responseData);\n    return responseData;\n  }\n};\nvar todoConnection = connect([dataUrl, dataCallbacks, logging}],  {\n  url: '/todos'\n});\n\n// create a new todo\ntodoConnection.createData({name: \"do the dishes\", completed: false}).then(function(responseData) {\n  responseData; // {id: 5}\n});\n\n// after create request is completed, following is logged by the \"logging\" createdData callback:\n// > New Todo Saved: {id: 5}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "`can-connect` connection object that is having the `data/callbacks` behavior added\non to it. Should already contain a behavior that provides the DataInterface (e.g [can-connect/data/url/url]). If\nthe `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a `can-connect` connection containing the method implementations provided by `data/callbacks`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "`can-connect` connection object that is having the `data/callbacks` behavior added\non to it. Should already contain a behavior that provides the DataInterface (e.g [can-connect/data/url/url]). If\nthe `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a `can-connect` connection containing the method implementations provided by `data/callbacks`.\n"
    }
  },
  "can-connect/data/callbacks/callbacks.getListData": {
    "name": "can-connect/data/callbacks/callbacks.getListData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 46,
      "codeLine": 61,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "\n",
    "description": "\nCall `gotListData` with the data returned from underlying behavior's implementation of\n[can-connect/connection.gotListData].\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "getListData(listSet)",
        "description": "\n\n  Extends the underlying behavior's [can-connect/connection.getListData] to call `gotListData` with the returned\n  response data. The result of the call to `gotListData` will be used as the new response data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "listSet",
            "description": "an object that represents the set of data to be loaded"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` resolving the raw response data, possibly modified by `gotListData`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "listSet",
      "description": "an object that represents the set of data to be loaded"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` resolving the raw response data, possibly modified by `gotListData`.\n "
    }
  },
  "can-connect/data/callbacks/callbacks.createData": {
    "name": "can-connect/data/callbacks/callbacks.createData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 63,
      "codeLine": 79,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "\n",
    "description": "\nCall `createdData` with the data returned from underlying behavior's implementation of\n[can-connect/connection.createData].\n",
    "title": "createData",
    "signatures": [
      {
        "code": "createData(instanceData, cid)",
        "description": "\n\n  Extends the underlying behavior's [can-connect/connection.createData] to call `createdData` with the returned\n  response data. The result of the call to `createdData` will be used as the new response data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "the raw data of an instance"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "unique id that represents the instance that is being created"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` resolving the raw response data, possibly modified by `createdData`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "unique id that represents the instance that is being created"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` resolving the raw response data, possibly modified by `createdData`.\n "
    }
  },
  "can-connect/data/callbacks/callbacks.updateData": {
    "name": "can-connect/data/callbacks/callbacks.updateData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 81,
      "codeLine": 96,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "\n",
    "description": "\nCall `updatedData` with the data returned from underlying behavior's implementation of\n[can-connect/connection.updateData].\n",
    "title": "updatedData",
    "signatures": [
      {
        "code": "updateData(instanceData)",
        "description": "\n\n  Extends the underlying behavior's [can-connect/connection.updateData] to call `updatedData` with the returned\n  response data. The result of the call to `updatedData` will be used as the new response data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "the raw data of an instance"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` resolving the raw response data, possibly modified by `updatedData`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "the raw data of an instance"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` resolving the raw response data, possibly modified by `updatedData`.\n "
    }
  },
  "can-connect/data/callbacks/callbacks.destroyData": {
    "name": "can-connect/data/callbacks/callbacks.destroyData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 98,
      "codeLine": 113,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "\n",
    "description": "\nCall `destroyedData` with the data returned from underlying behavior's implementation of\n[can-connect/connection.destroyData].\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "destroyData(params, cid)",
        "description": "\n\n  Extends the underlying behavior's [can-connect/connection.destroyData] to call `destroyedData` with the returned\n  response data. The result of the call to `destroyedData` will be used as the new response data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "the raw data of an instance"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` resolving the raw response data, possibly modified by `destroyedData`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "the raw data of an instance"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` resolving the raw response data, possibly modified by `destroyedData`.\n "
    }
  },
  "can-connect/InstanceInterface": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/instance_interface.md"
    },
    "body": "",
    "description": "The methods used to create, retrieve, update and destroy typed instances with a connection. \n",
    "type": "typedef",
    "title": "InstanceInterface",
    "name": "can-connect/InstanceInterface",
    "parent": "can-connect.types",
    "signatures": [
      {
        "code": "InstanceInterface",
        "description": "\n\nThe [can-connect/constructor/constructor] behavior is typically\nused to implement the core instance interface methods:\n\n - [can-connect/connection.getList] - Get a list of instances.\n - [can-connect/connection.get] - Get a single instance.\n - [can-connect/connection.save] - Create or update an instance.\n - [can-connect/connection.destroy] - Destroy an instance.\n",
        "params": []
      }
    ]
  },
  "can-connect/Instance": {
    "src": {
      "path": "node_modules/can-connect/docs/types/instance.md"
    },
    "body": "",
    "description": "An instance of some JavaScript type. \n",
    "type": "typedef",
    "title": "Instance",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n  `can-connect` is primarily used to connect some form of __typed data__ to\n  a service layer.  For example, the typed data might be a `Todo` with methods\n  like `todo.complete()` and the service layer might be a RESTful URL like\n  `https://myapp.com/todos`.\n\n  __Typed data__, with methods, validation, type coercion, and other logic is\n  very useful to a client side developer.  However, a service layer\n  doesn't provide this functionality, instead it just provides raw data.\n\n  `can-connect` is used to bridge the gap between __typed data__ and the\n  raw data provided by the server.  \n\n  An `Instance` represents some form of typed data. For example,\n  an `Instance` might represent an instance of the `Todo` type in the example above.\n\n  The [can-connect/constructor/constructor] behavior is primarily responsible for\n  providing methods that go [can-connect/constructor/constructor.hydrateInstance back] and\n  [can-connect/constructor/constructor.serializeInstance forth] between\n  instances and raw data.  Other behaviors like [can-connect/can/map/map]\n  extend this functionality. \n"
      }
    ],
    "name": "can-connect/Instance",
    "parent": "can-connect.types"
  },
  "can-connect.listData": {
    "src": {
      "path": "node_modules/can-connect/docs/types/listData.md"
    },
    "body": "\n\n",
    "description": "\nThe data format used to create typed lists.  \n",
    "type": "typedef",
    "title": "ListData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "data",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "The ListData object must have a `data` property that is an array of objects.  Each\nobject is used to [can-connect/constructor/constructor.hydrateInstance hydrate] typed instances.\n"
          }
        ],
        "description": "A plain JavaScript object used to [can-connect/constructor/constructor.hydrateList hydrate] \na typed list.  This is the data format resolved by [can-connect/connection.getListData].\n\nA `ListData` object should look like:\n\n```js\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ]\n}\n```\n\nThe object must have a `data` property that is an `Array` of\ninstance data used to [can-connect/constructor/constructor.hydrateInstance hydrate] typed instances.  \n\nThe ListData object can have other meta information related to the data\nthat has been loaded.  For example, `count` might be the total\nnumber of items the server has:\n\n```\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ],\n  count: 1000\n}\n```\n\nThe [can-connect/data/parse/parse] behavior can be used to convert request responses to the `ListData` format.\n"
      }
    ],
    "name": "can-connect.listData",
    "parent": "can-connect.types",
    "comment": " "
  },
  "can-connect.List": {
    "src": {
      "path": "node_modules/can-connect/docs/types/list.md"
    },
    "body": "",
    "description": "A list type. \n",
    "type": "typedef",
    "title": "List",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "The `List` type is a JavaScript type, typically\na constructor function, that is used to contain a list of typed [can-connect/Instance instances].  `List` types usually are\n`Array`-like.  An instance of type `List` is what's returned by\n[can-connect/constructor.hydrateList] to convert raw data into\nwhat's returned by [can-connect/connection.getList].\n\n```js\nvar list = connection.hydrateList({\n  data: [{id: 1, name: \"raw data\"}]\n});\n\nlist //-> an instance of List\n```\n\nThe `List` type often has special methods used to interact with\nthe collection of [can-connect/Instance] instances.\n\n```js\nvar list = connection.hydrateList({\n  data: [{id: 1, name: \"raw data\"}]\n});\n\nlist.someSpecialMethod();\n```\n\nThe [can-connect/constructor/constructor.list] option is used\nto convert an Array of instances into the final `List` type.\n"
      }
    ],
    "name": "can-connect.List",
    "parent": "can-connect.types"
  },
  "connection.algebra": {
    "src": {
      "path": "node_modules/can-connect/docs/options/algebra.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Algebra"
      }
    ],
    "title": "algebra",
    "name": "connection.algebra",
    "type": "property",
    "parent": "can-connect.options",
    "hide": true
  },
  "connection.cacheConnection": {
    "src": {
      "path": "node_modules/can-connect/docs/options/cacheConnection.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "connection"
      }
    ],
    "title": "cacheConnection",
    "name": "connection.cacheConnection",
    "type": "property",
    "parent": "can-connect.options",
    "hide": true
  },
  "connection.id": {
    "src": {
      "path": "node_modules/can-connect/docs/options/id.md"
    },
    "body": "",
    "description": "\n",
    "title": "id",
    "name": "connection.id",
    "type": "function",
    "parent": "can-connect.options",
    "hide": true
  },
  "connection.instance": {
    "src": {
      "path": "node_modules/can-connect/docs/options/instance.md"
    },
    "body": "",
    "description": "\n",
    "title": "instance",
    "name": "connection.instance",
    "type": "function",
    "parent": "can-connect.options",
    "hide": true
  },
  "connection.idProp": {
    "src": {
      "path": "node_modules/can-connect/docs/options/idProp.md"
    },
    "body": "",
    "description": "\n",
    "title": "idProp",
    "name": "connection.idProp",
    "type": "property",
    "parent": "can-connect.options",
    "hide": true
  },
  "connection.list": {
    "src": {
      "path": "node_modules/can-connect/docs/options/list.md"
    },
    "body": "",
    "description": "\n",
    "title": "list",
    "name": "connection.list",
    "type": "function",
    "parent": "can-connect.options",
    "hide": true,
    "signatures": [
      {
        "code": "connection.list( instancesData, set )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": [
                  {
                    "name": "data",
                    "types": [
                      {
                        "type": "Array",
                        "template": [
                          {
                            "types": [
                              {
                                "type": "Object",
                                "options": []
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "instancesData",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "data",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "name": "instancesData",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "\n"
    }
  },
  "connection.listSet": {
    "src": {
      "path": "node_modules/can-connect/docs/options/listSet.md"
    },
    "body": "",
    "description": "\n",
    "title": "listSet",
    "name": "connection.listSet",
    "type": "function",
    "parent": "can-connect.options",
    "hide": true
  },
  "can-connect/data/combine-requests.options": {
    "name": "can-connect/data/combine-requests.options",
    "title": "behavior options",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 1
  },
  "can-connect/data/combine-requests.types": {
    "name": "can-connect/data/combine-requests.types",
    "title": "types",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 2
  },
  "can-connect/data/combine-requests.data-methods": {
    "name": "can-connect/data/combine-requests.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 3
  },
  "can-connect/data/combine-requests.algebra": {
    "name": "can-connect/data/combine-requests.algebra",
    "title": "algebra methods",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 4
  },
  "can-connect/data/combine-requests/combine-requests": {
    "type": "module",
    "name": "can-connect/data/combine-requests/combine-requests",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 7,
      "codeLine": 81,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n\n## Use\n\nCreate a connection with the `combine-requests` plugin:\n\n```\nvar combineRequests = require(\"can-connect/data/combine-requests/\");\nvar dataUrl = require(\"can-connect/data/url/\");\nvar todosConnection = connect([dataUrl, combineRequests], {\n  url: \"/todos\"\n});\n```\nSince the configuration above doesn't include the [can-connect/data/combine-requests.time] option, the following\nwill only make a single request if all requests are made during the same \"thread of execution\" (i.e before the\nbrowser takes a break from executing the current JavaScript):\n\n```\ntodosConnection.getListData({})\ntodosConnection.getListData({userId: 5});\ntodosConnection.getListData({userId: 5, type: \"critical\"});\n```\n\nThe above requests can all be joined since [can-set] intuitively knows that\n`{userId: 5, type: \"critical\"}` and `{userId: 5}` are subsets of the complete set of todos, `{}`.\n\nFor more advanced combining, a [can-set.Algebra set algebra] must be configured. This allows [can-set] to understand\nwhat certain parameters of a set mean, and how they might be combined.\n\nThe following connection supports combining ranges:\n\n```\nvar set = require(\"can-set\");\nvar combineRequests = require(\"can-connect/data/combine-requests/\");\nvar dataUrl = require(\"can-connect/data/url/\");\nvar todosConnection = connect([dataUrl, combineRequests], {\n  url: \"/todos\",\n  algebra: new set.Algebra(set.props.rangeInclusive(\"start\",\"end\"))\n});\n```\n\nNow the following will also be unified to make single request:\n\n```\ntodosConnection.getListData({start: 0, end: 49})\ntodosConnection.getListData({start: 0, end: 5});\ntodosConnection.getListData({start: 50, end: 99});\n```\n\n\n",
    "description": "\nCombines multiple incoming lists requests into a single list request when possible.\n",
    "title": "combine-requests",
    "signatures": [
      {
        "code": "combineRequests( baseConnection )",
        "description": "\n\nImplements [can-connect/data/combine-requests.getListData] to collect the requested sets for some\n[can-connect/data/combine-requests.time].  Once the configured amount of time has passed, it tries to take the\n[can-connect/data/combine-requests.unionPendingRequests union] of the requested sets. It then makes requests with\nthose unified sets. Once the unified set requests have returned, the original requests are resolved by taking\n[can-connect/data/combine-requests.getSubset subsets] of the unified response data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "`can-connect` connection object that is having the `combine-requests` behavior added\non to it. Should already contain a behavior that provides `getListData` (e.g [can-connect/data/url/url]). If\nthe `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a `can-connect` connection containing the method implementations provided by `combine-requests`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "`can-connect` connection object that is having the `combine-requests` behavior added\non to it. Should already contain a behavior that provides `getListData` (e.g [can-connect/data/url/url]). If\nthe `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a `can-connect` connection containing the method implementations provided by `combine-requests`.\n"
    },
    "comment": " "
  },
  "can-connect/data/combine-requests.unionPendingRequests": {
    "type": "function",
    "name": "can-connect/data/combine-requests.unionPendingRequests",
    "parent": "can-connect/data/combine-requests.algebra",
    "src": {
      "line": 85,
      "codeLine": 136,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nGroup pending requests by the request that they are a subset of.\n",
    "title": "unionPendingRequests",
    "signatures": [
      {
        "code": "connection.unionPendingRequests( pendingRequests )",
        "description": "\n\nThis is called by [can-connect/data/combine-requests.getListData] to determine which pending requests can be unified\ninto a broader request. This produces a grouping of 'parent' sets to 'child' requests whose data will be\nderived from the data retrieved by the parent.\n\nAfter this grouping is returned, [can-connect/data/combine-requests.getListData] executes requests for the parent\nsets. After a parent request succeeds, the child requests will have their data calculated from the parent data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-connect/data/combine-requests.PendingRequest"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "pendingRequests",
            "description": "\nan array of objects, each containing:\n  - `set` - the requested set\n  - `deferred` - a wrapper around a `Promise` that will be resolved with this sets data\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": [
                        {
                          "name": "set",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        },
                        {
                          "name": "pendingRequests",
                          "types": [
                            {
                              "type": "can-connect/data/combine-requests.PendingRequest"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\nan array of each of the unified requests to be made.  Each unified request should have:\n  - `set` - the set to request\n  - `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the `set` satisfies\n\n### Example\n\nThis function converts something like:\n\n```\n[\n  {set: {completed: false}, deferred: def1},\n  {set: {completed: true}, deferred: def2}\n]\n```\n\nto:\n\n```\n[\n  {\n   set: {},\n   pendingRequests: [\n     {set: {completed: false}, deferred: def1},\n     {set: {completed: true}, deferred: def2}\n   ]\n  }\n]\n```\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/data/combine-requests.PendingRequest"
                }
              ]
            }
          ]
        }
      ],
      "name": "pendingRequests",
      "description": "\nan array of objects, each containing:\n  - `set` - the requested set\n  - `deferred` - a wrapper around a `Promise` that will be resolved with this sets data\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": [
                    {
                      "name": "set",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    },
                    {
                      "name": "pendingRequests",
                      "types": [
                        {
                          "type": "can-connect/data/combine-requests.PendingRequest"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\nan array of each of the unified requests to be made.  Each unified request should have:\n  - `set` - the set to request\n  - `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the `set` satisfies\n\n### Example\n\nThis function converts something like:\n\n```\n[\n  {set: {completed: false}, deferred: def1},\n  {set: {completed: true}, deferred: def2}\n]\n```\n\nto:\n\n```\n[\n  {\n   set: {},\n   pendingRequests: [\n     {set: {completed: false}, deferred: def1},\n     {set: {completed: true}, deferred: def2}\n   ]\n  }\n]\n```\n\n\t "
    }
  },
  "can-connect/data/combine-requests.time": {
    "name": "can-connect/data/combine-requests.time",
    "type": "property",
    "parent": "can-connect/data/combine-requests.options",
    "src": {
      "line": 185,
      "codeLine": 205,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nSpecifies the amount of time to wait to combine requests.\n",
    "types": [
      {
        "type": "Number",
        "description": "Defaults to `1`, meaning only requests made within the same \"thread of execution\" will be\ncombined (i.e requests made before the browser takes a break from the ongoing JavaScript execution).\n\nIncreasing this number will mean that requests are delayed that length of time in case other requests\nare made. In general, we advise against increasing this amount of time except in cases where loads take a\nsignificant amount of time and the increased delay is unlikely to be noticed.\n\n```\nvar combineRequests = require(\"can-connect/data/combine-requests/\");\nconnect([... combineRequests, ...],{\n  time: 100\n})\n```\n\t "
      }
    ],
    "title": "time"
  },
  "can-connect/data/combine-requests.getListData": {
    "type": "function",
    "name": "can-connect/data/combine-requests.getListData",
    "parent": "can-connect/data/combine-requests.data-methods",
    "src": {
      "line": 207,
      "codeLine": 226,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nCombines multiple list data requests into a single request, when possible.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData( set )",
        "description": "\n\nExtension of [can-connect/connection.getListData `getListData`] that tries to combine calls to it into a single\ncall. The calls are fulfilled by an underlying behavior's `getListData` implementation.\n\nWaits for a configured [can-connect/data/combine-requests.time] then tries to unify the sets requested during it.\nAfter unification, calls for the unified sets are made to the underlying `getListData`. Once the unified\ndata has returned, the individual calls to `getListData` are resolved with a\n[can-set.Algebra.prototype.getSubset calculated subset] of the unified data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "the parameters of the requested set of data"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "`Promise` resolving the data of the requested set\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "the parameters of the requested set of data"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "`Promise` resolving the data of the requested set\n\t "
    }
  },
  "can-connect/data/combine-requests.PendingRequest": {
    "src": {
      "line": 288,
      "codeLine": 303,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "type": "typedef",
    "body": "",
    "description": "Type to keep track of the multiple requests that were unified into a single request. \n",
    "title": "PendingRequest",
    "types": [
      {
        "type": "PendingRequest",
        "description": "Record of an individual request that has been unified as part of the combined request. After\nthe unified request completes instances of these types are processed to complete the individual requests with the\nsubset of the unified data.\n",
        "options": [
          {
            "name": "set",
            "description": "a requested [can-set/Set set] of data that has been unified into the combined request",
            "types": [
              {
                "type": "can-set/Set"
              }
            ]
          },
          {
            "name": "deferred",
            "description": "a type that keeps track of the individual [can-connect/data/combine-requests.getListData]\npromise that will be resolved after the unified request completes\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can-connect/data/combine-requests.PendingRequest",
    "parent": "can-connect/data/combine-requests.types"
  },
  "can-connect/data/callbacks-cache/callbacks-cache": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 43,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": "\n",
    "description": "\nImplements the data interface callbacks to call the [can-connect/base/base.cacheConnection]\n[can-connect/DataInterface]. These calls keep the [can-connect/base/base.cacheConnection] contents\nup to date.\n",
    "title": "data/callbacks-cache",
    "signatures": [
      {
        "code": "dataCallbacksCache( baseConnection )",
        "description": "\nImplements the data interface callbacks so that a corresponding [can-connect/DataInterface] method is called on the\n[can-connect/base/base.cacheConnection]. This updates the [can-connect/base/base.cacheConnection] contents whenever\ndata is updated on the primary connection.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "`can-connect` connection object that is having the `data/callbacks-cache` behavior added\non to it.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a `can-connect` connection containing the method implementations provided by `data/callbacks-cache`.\n\n### Example\nShows synchronization between primary connection and cacheConnection data when using this behavior:\n```\nimport dataUrl from \"can-connect/data/url/\";\nimport dataCallbacks from \"can-connect/data/callbacks/\";\nimport cacheCallbacks from \"can-connect/data/callbacks-cache/\";\nimport memoryCache from \"can-connect/data/memory-cache/\";\n\nvar cacheConnection = connect([memoryCache], {});\nvar todoConnection = connect([dataUrl, dataCallback, cacheCallbacks], {\n  cacheConnection,\n  url: \"/todo\"\n});\n\ntodoConnection.createData({name:'do the dishes', completed: false}).then(function(data) {\n  todoConnection.cacheConnection.getData({id: data.id}).then(function(cachedData) {\n    // data returned from connection and data returned from cache have the same contents\n    data.id === cachedData.id; // true\n    data.name === cachedData.name; // true\n    data.completed === cachedData.completed; // true\n    data === cachedData; // false, since callbacks-cache creates a copy of the data when adding it to the cache\n  })\n});\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "`can-connect` connection object that is having the `data/callbacks-cache` behavior added\non to it.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a `can-connect` connection containing the method implementations provided by `data/callbacks-cache`.\n\n### Example\nShows synchronization between primary connection and cacheConnection data when using this behavior:\n```\nimport dataUrl from \"can-connect/data/url/\";\nimport dataCallbacks from \"can-connect/data/callbacks/\";\nimport cacheCallbacks from \"can-connect/data/callbacks-cache/\";\nimport memoryCache from \"can-connect/data/memory-cache/\";\n\nvar cacheConnection = connect([memoryCache], {});\nvar todoConnection = connect([dataUrl, dataCallback, cacheCallbacks], {\n  cacheConnection,\n  url: \"/todo\"\n});\n\ntodoConnection.createData({name:'do the dishes', completed: false}).then(function(data) {\n  todoConnection.cacheConnection.getData({id: data.id}).then(function(cachedData) {\n    // data returned from connection and data returned from cache have the same contents\n    data.id === cachedData.id; // true\n    data.name === cachedData.name; // true\n    data.completed === cachedData.completed; // true\n    data === cachedData; // false, since callbacks-cache creates a copy of the data when adding it to the cache\n  })\n});\n```\n"
    }
  },
  "can-connect/data/callbacks-cache/callbacks-cache.createdData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.createdData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 49,
      "codeLine": 68,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": "\n",
    "description": "\nData callback that updates the [can-connect/base/base.cacheConnection cache] when a new data record is created.\n",
    "title": "createdData",
    "signatures": [
      {
        "code": "connection.createdData(responseData, requestData, cid)",
        "description": "\n\nCalls `createData` on the [can-connect/base/base.cacheConnection] to add a newly created data record to the cache.\nCalls and returns the response from any underlying behavior's `createdData` callback.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "the data returned by the data creation request"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "requestData",
            "description": "the data that was passed to the data creation request"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "the unique identifier for this data. Used before data has a [can-connect/base/base.id] added\nat creation time.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "the data returned from an underlying behavior's `createdData` callback, if one exists. Otherwise\nreturns the `responseData`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "the unique identifier for this data. Used before data has a [can-connect/base/base.id] added\nat creation time.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "the data returned from an underlying behavior's `createdData` callback, if one exists. Otherwise\nreturns the `responseData`.\n "
    }
  },
  "can-connect/data/callbacks-cache/callbacks-cache.updatedData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.updatedData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 70,
      "codeLine": 87,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": "\n",
    "description": "\nData callback that updates the [can-connect/base/base.cacheConnection cache] when a data record is modified.\n",
    "title": "updatedData",
    "signatures": [
      {
        "code": "connection.updatedData(responseData, requestData)",
        "description": "\n\nCalls `updateData` on the [can-connect/base/base.cacheConnection] to modify a data record stored in the cache.\nCalls and returns the response from any underlying behavior's `updatedData` callback.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "the data returned by the data update request"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "requestData",
            "description": "the data that was passed to the data update request\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "the data returned from an underlying behavior's `updatedData` callback, if one exists. Otherwise\nreturns the `responseData`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "requestData",
      "description": "the data that was passed to the data update request\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "the data returned from an underlying behavior's `updatedData` callback, if one exists. Otherwise\nreturns the `responseData`.\n "
    }
  },
  "can-connect/data/callbacks-cache/callbacks-cache.destroyedData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.destroyedData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 89,
      "codeLine": 106,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": "\n",
    "description": "\nData callback that updates the [can-connect/base/base.cacheConnection cache] when a data record is deleted.\n",
    "title": "destroyedData",
    "signatures": [
      {
        "code": "connection.destroyedData(responseData, requestData)",
        "description": "\n\nCalls `destroyData` on the [can-connect/base/base.cacheConnection] to remove a data record stored in the cache.\nCalls and returns the response from any underlying behavior's `destroyedData` callback.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "the data returned by the data destroy request"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "requestData",
            "description": "the data that was passed to the data destroy request\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "the data returned from an underlying behavior's `destroyedData` callback, if one exists. Otherwise\nreturns the `responseData`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "requestData",
      "description": "the data that was passed to the data destroy request\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "the data returned from an underlying behavior's `destroyedData` callback, if one exists. Otherwise\nreturns the `responseData`.\n "
    }
  },
  "can-connect/data/memory-cache/memory-cache.data-methods": {
    "name": "can-connect/data/memory-cache/memory-cache.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/memory-cache/memory-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/memory-cache/memory-cache": {
    "name": "can-connect/data/memory-cache/memory-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 43,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n\n## Use\n\n`data/memory-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n[can-connect/cache-requests/cache-requests].\n\n```js\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/fall-through-cache/fall-through-cache\")\n],\n{\n  url: \"/services/todos\",\n  cacheConnection: cacheConnection\n});\n```\n\n",
    "description": "\nSaves raw data in JavaScript memory that disappears when the page refreshes.\n",
    "title": "memory-cache",
    "signatures": [
      {
        "code": "memoryCache( baseConnection )",
        "description": "\n\n  Creates a cache of instances and a cache of sets of instances that is\n  accessible to read via [can-connect/data/memory-cache/memory-cache.getSets],\n  [can-connect/data/memory-cache/memory-cache.getData], and [can-connect/data/memory-cache/memory-cache.getListData].\n  The caches are updated via [can-connect/data/memory-cache/memory-cache.createData],\n  [can-connect/data/memory-cache/memory-cache.updateData], [can-connect/data/memory-cache/memory-cache.destroyData],\n  and [can-connect/data/memory-cache/memory-cache.updateListData].\n\n  [can-connect/data/memory-cache/memory-cache.createData],\n  [can-connect/data/memory-cache/memory-cache.updateData],\n  [can-connect/data/memory-cache/memory-cache.destroyData] are able to move items in and out\n  of sets.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/memory-cache/memory-cache.getSets": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getSets",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 162,
      "codeLine": 183,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n\n## Use\n\n```\nconnection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n```\n\n\t \n",
    "description": "\nReturns the sets contained within the cache.\n",
    "title": "getSets",
    "signatures": [
      {
        "code": "connection.getSets()",
        "description": "\n\n  Returns the sets added by [can-connect/data/memory-cache/memory-cache.updateListData].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "can-set/Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the list of sets.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can-set/Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the list of sets.\n"
    },
    "comment": " "
  },
  "can-connect/data/memory-cache/memory-cache.clear": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.clear",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 188,
      "codeLine": 215,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nResets the memory cache so it contains nothing.\n",
    "title": "clear",
    "signatures": [
      {
        "code": "connection.clear()",
        "description": "\n\n  Removes all instances and lists being stored in memory.\n\n  ```\n  var cacheConnection = connect([\n    require(\"can-connect/data/memory-cache/memory-cache\")\n  ],{});\n\n  cacheConnection.updateInstance({id: 5, name: \"justin\"});\n\n  cacheConnection.getData({id: 5}).then(function(data){\n    data //-> {id: 5, name: \"justin\"}\n    cacheConnection.clear();\n    cacheConnection.getData({id: 5}).catch(function(err){\n      err -> {message: \"no data\", error: 404}\n    });\n  });\n  ```\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getListData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 219,
      "codeLine": 236,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nGets a set of data from the memory cache.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Goes through each set add by [can-connect/data/memory-cache/memory-cache.updateListData]. If\n  `set` is a subset, uses [can-connect/base/base.algebra] to get the data for the requested `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "An object that represents the data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "An object that represents the data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
    }
  },
  "can-connect/data/memory-cache.getListDataSync": {
    "type": "function",
    "name": "can-connect/data/memory-cache.getListDataSync",
    "parent": "can-connect/data/memory-cache.data-methods",
    "src": {
      "line": 245,
      "codeLine": 254,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n\t \n",
    "description": "\nSynchronously gets a set of data from the memory cache.\n",
    "title": "getListDataSync",
    "signatures": [
      {
        "code": "connection.getListDataSync(set)",
        "description": "",
        "params": []
      }
    ],
    "hide": true
  },
  "can-connect/data/memory-cache/memory-cache.updateListData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.updateListData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 270,
      "codeLine": 285,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nSaves a set of data in the cache.\n",
    "title": "updateListData",
    "signatures": [
      {
        "code": "connection.updateListData(listData, set)",
        "description": "\n\n  Tries to merge this set of data with any other saved sets of data. If\n  unable to merge this data, saves the set by itself.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The data that belongs to `set`."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set `listData` belongs to."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Promise resolves if and when the data has been successfully saved.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set `listData` belongs to."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Promise resolves if and when the data has been successfully saved.\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.getData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 311,
      "codeLine": 327,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nGet an instance's data from the memory cache.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Looks in the instance store for the requested instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A promise that resolves to the item if the memory cache has this item.\nIf the memory cache does not have this item, it rejects the promise.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A promise that resolves to the item if the memory cache has this item.\nIf the memory cache does not have this item, it rejects the promise.\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.createData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.createData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 339,
      "codeLine": 350,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is created and should be added to cache.\n",
    "title": "createData",
    "signatures": [
      {
        "code": "connection.createData(props)",
        "description": "\n\n  Adds `props` to the stored list of instances. Then, goes\n  through every set and adds props the sets it belongs to.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.updateData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.updateData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 363,
      "codeLine": 374,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is updated.\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "connection.updateData(props)",
        "description": "\n\n  Overwrites the stored instance with the new props. Then, goes\n  through every set and adds or removes the instance if it belongs or not.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.destroyData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.destroyData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 408,
      "codeLine": 419,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance should be removed from the cache.\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "connection.destroyData(props)",
        "description": "\n\n  Goes through each set of data and removes any data that matches\n  `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.identifiers": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache.identifiers",
    "title": "identifiers",
    "type": "group",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/localstorage-cache/localstorage-cache.data-methods": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache",
    "description": "",
    "order": 1
  },
  "can-connect/data/localstorage-cache/localstorage-cache": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 47,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n\n## Use\n\n`data/localstorage-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n[can-connect/cache-requests/cache-requests].  Make sure you configure the connection's [can-connect/data/localstorage-cache/localstorage-cache.name].\n\n```\nvar cacheConnection = connect([\n  require(\"can-connect/data/localstorage-cache/localstorage-cache\")\n],{\n  name: \"todos\"\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/fall-through-cache/fall-through-cache\")\n],\n{\n  url: \"/services/todos\",\n  cacheConnection: cacheConnection\n});\n```\n\n\n",
    "description": "\nSaves raw data in localStorage.\n",
    "title": "localstorage-cache",
    "signatures": [
      {
        "code": "localStorage( baseConnection )",
        "description": "\n\n  Creates a cache of instances and a cache of sets of instances that is\n  accessible to read via [can-connect/data/localstorage-cache/localstorage-cache.getSets],\n  [can-connect/data/localstorage-cache/localstorage-cache.getData], and [can-connect/data/localstorage-cache/localstorage-cache.getListData].\n  The caches are updated via [can-connect/data/localstorage-cache/localstorage-cache.createData],\n  [can-connect/data/localstorage-cache/localstorage-cache.updateData], [can-connect/data/localstorage-cache/localstorage-cache.destroyData],\n  and [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n\n  [can-connect/data/localstorage-cache/localstorage-cache.createData],\n  [can-connect/data/localstorage-cache/localstorage-cache.updateData],\n  [can-connect/data/localstorage-cache/localstorage-cache.destroyData] are able to move items in and out\n  of sets.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.name": {
    "src": {
      "line": 212,
      "codeLine": 234,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```\nvar cacheConnection = connect([\"data-localstorage-cache\"],{\n  name: \"todos\"\n});\n```\n\t \n",
    "description": "\nSpecify a name to use when saving data in localstorage.\n",
    "types": [
      {
        "type": "String",
        "description": "This name is used to find and save data in\nlocalstorage. Instances are saved in `{name}/instance/{id}`\nand sets are saved in `{name}/set/{set}`.\n"
      }
    ],
    "title": "name",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.name",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.identifiers",
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.clear": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.clear",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 236,
      "codeLine": 245,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nResets the memory cache so it contains nothing.\n",
    "title": "clear",
    "signatures": [
      {
        "code": "connection.clear()",
        "description": "\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getSets": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getSets",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 270,
      "codeLine": 291,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n\n## Use\n\n```\nconnection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n```\n\n\t \n",
    "description": "\nReturns the sets contained within the cache.\n",
    "title": "getSets",
    "signatures": [
      {
        "code": "connection.getSets(set)",
        "description": "\n\n  Returns the sets added by [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the list of sets.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the list of sets.\n"
    },
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getListData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 294,
      "codeLine": 311,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nGets a set of data from localstorage.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Goes through each set add by [can-connect/data/memory-cache.updateListData]. If\n  `set` is a subset, uses [can-connect/base/base.algebra] to get the data for the requested `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "An object that represents the data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "An object that represents the data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
    }
  },
  "can-connect/data/localstorage-cache.getListDataSync": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache.getListDataSync",
    "parent": "can-connect/data/localstorage-cache.data-methods",
    "src": {
      "line": 319,
      "codeLine": 328,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n\t \n",
    "description": "\nSynchronously gets a set of data from localstorage.\n",
    "title": "getListDataSync",
    "signatures": [
      {
        "code": "connection.getListDataSync(set)",
        "description": "",
        "params": []
      }
    ],
    "hide": true
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 350,
      "codeLine": 366,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nGet an instance's data from localstorage.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Looks in localstorage for the requested instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A promise that resolves to the item if the memory cache has this item.\nIf localstorage does not have this item, it rejects the promise.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A promise that resolves to the item if the memory cache has this item.\nIf localstorage does not have this item, it rejects the promise.\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.updateListData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.updateListData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 376,
      "codeLine": 391,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nSaves a set of data in the cache.\n",
    "title": "updateListData",
    "signatures": [
      {
        "code": "connection.updateListData(listData, set)",
        "description": "\n\n  Tries to merge this set of data with any other saved sets of data. If\n  unable to merge this data, saves the set by itself.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Promise resolves if and when the data has been successfully saved.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Promise resolves if and when the data has been successfully saved.\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.createData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.createData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 413,
      "codeLine": 424,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is created and should be added to cache.\n",
    "title": "createData",
    "signatures": [
      {
        "code": "connection.createData(props)",
        "description": "\n\n  Adds `props` to the stored list of instances. Then, goes\n  through every set and adds props the sets it belongs to.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.updateData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.updateData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 436,
      "codeLine": 447,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is updated.\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "connection.updateData(props)",
        "description": "\n\n  Overwrites the stored instance with the new props. Then, goes\n  through every set and adds or removes the instance if it belongs or not.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.destroyData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.destroyData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 479,
      "codeLine": 490,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance should be removed from the cache.\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "connection.destroyData(props)",
        "description": "\n\n  Goes through each set of data and removes any data that matches\n  `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/url/url.data-methods": {
    "name": "can-connect/data/url/url.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/url/url",
    "description": "",
    "order": 0
  },
  "can-connect/data/url/url.option": {
    "name": "can-connect/data/url/url.option",
    "title": "options",
    "type": "group",
    "parent": "can-connect/data/url/url",
    "description": "",
    "order": 0
  },
  "can-connect/data/url/url": {
    "name": "can-connect/data/url/url",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 96,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "\n## Use\n\nThe `data/url` behavior implements many of the [can-connect/DataInterface]\nmethods to send instance data to a URL.\n\nFor example, the following `todoConnection`:\n\n```js\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: {\n    getListData: \"GET /todos\",\n    getData: \"GET /todos/{id}\",\n    createData: \"POST /todos\",\n    updateData: \"PUT /todos/{id}\",\n    destroyData: \"DELETE /todos/{id}\"\n  }\n});\n```\n\nWill make the following request when the following\nmethods are called:\n\n```\n// GET /todos?due=today\ntodoConnection.getListData({due: \"today\"});\n\n// GET /todos/5\ntodosConnection.getData({id: 5})\n\n// POST /todos \\\n// name=take out trash\ntodosConnection.createData({\n  name: \"take out trash\"\n});\n\n// PUT /todos/5 \\\n// name=do the dishes\ntodosConnection.updateData({\n  name: \"do the dishes\",\n  id: 5\n});\n\n// DELETE /todos/5\ntodosConnection.destroyData({\n  id: 5\n});\n```\n\nThere's a few things to notice:\n\n1. URL values can include simple templates like `{id}`\n   that replace that part of the URL with values in the data\n   passed to the method.\n2. GET and DELETE request data is put in the URL using [can-util/js/param/param].\n3. POST and PUT requests put data that is not templated in the URL in POST or PUT body\n   as JSON-encoded data.  To use form-encoded requests instead, add the property\n   `contentType:'application/x-www-form-urlencoded'` to your [can-connect/data/url/url.url].\n4. If a provided URL doesn't include the method, the following default methods are provided:\n   - `getListData` - `GET`\n   - `getData` - `GET`\n   - `createData` - `POST`\n   - `updateData` - `PUT`\n   - `destroyData` - `DELETE`\n\nIf [can-connect/data/url/url.url] is provided as a string like:\n\n```js\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\"\n});\n```\n\nThis does the same thing as the first `todoConnection` example.\n\n",
    "description": "\n",
    "title": "data/url",
    "types": [
      {
        "type": "connect.Behavior",
        "description": "\n\nUses the [can-connect/data/url/url.url] option to implement the behavior of\n[can-connect/connection.getListData],\n[can-connect/connection.getData],\n[can-connect/connection.createData],\n[can-connect/connection.updateData], and\n[can-connect/connection.destroyData] to make an AJAX request\nto urls.\n"
      }
    ],
    "comment": " "
  },
  "can-connect/data/url/url.url": {
    "body": "\n",
    "description": "\nSpecify the url and methods that should be used for the \"Data Methods\".\n",
    "types": [
      {
        "type": "String",
        "description": "If a string is provided, it's assumed to be a RESTful interface. For example,\nif the following is provided:\n\n```\nurl: \"/services/todos\"\n```\n\n... the following methods and requests are used:\n\n - `getListData` - `GET /services/todos`\n - `getData` - `GET /services/todos/{id}`\n - `createData` - `POST /services/todos`\n - `updateData` - `PUT /services/todos/{id}`\n - `destroyData` - `DELETE /services/todos/{id}`\n"
      },
      {
        "type": "Object",
        "options": [],
        "description": "If an object is provided, it can customize each method and URL directly\nlike:\n\n```\nurl: {\n  getListData: \"GET /services/todos\",\n  getData: \"GET /services/todo/{id}\",\n  createData: \"POST /services/todo\",\n  updateData: \"PUT /services/todo/{id}\",\n  destroyData: \"DELETE /services/todo/{id}\"\n}\n```\n\nYou can provide a `resource` property that works like providing `url` as a string, but overwrite\nother values like:\n\n```\nurl: {\n  resource: \"/services/todo\",\n  getListData: \"GET /services/todos\"\n}\n```\n\nFinally, you can provide your own method to totally control how the request is made:\n\n```\nurl: {\n  resource: \"/services/todo\",\n  getListData: \"GET /services/todos\",\n  getData: function(param){\n    return new Promise(function(resolve, reject){\n      $.get(\"/services/todo\", {identifier: param.id}).then(resolve, reject);\n    });\n  }\n}\n```\n"
      }
    ],
    "title": "url",
    "name": "can-connect/data/url/url.url",
    "type": "property",
    "parent": "can-connect/data/url/url.option"
  },
  "can-connect/data/url/url.ajax": {
    "src": {
      "line": 213,
      "codeLine": 236,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "type": "property",
    "body": "\n",
    "description": "\nSpecify the ajax functionality that should be used to make the request.\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that resolves to the data.\n "
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "settings",
            "description": "Configuration options for the AJAX request."
          }
        ],
        "description": "Provides an alternate function to be used to make\najax requests.  By default [can-util/dom/ajax/ajax] provides the ajax\nfunctionality. jQuery's ajax method can be substituted as follows:\n\n```js\nconnect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/things\",\n  ajax: $.ajax\n});\n```\n"
      }
    ],
    "title": "ajax",
    "name": "can-connect/data/url/url.ajax",
    "parent": "can-connect/data/url/url.option",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "settings",
      "description": "Configuration options for the AJAX request."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that resolves to the data.\n "
    }
  },
  "can-connect/data/url/url.getListData": {
    "name": "can-connect/data/url/url.getListData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 239,
      "codeLine": 253,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "getListData(set)",
        "description": "\n\n  Retrieves list data for a particular set given the [can-connect/data/url/url.url] settings.\n  If `url.getListData` is a function, that function will be called.  If `url.getListData` is a\n  string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n  `url`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the ListData format.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the ListData format.\n "
    }
  },
  "can-connect/data/url/url.getData": {
    "name": "can-connect/data/url/url.getData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 254,
      "codeLine": 268,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "signatures": [
      {
        "code": "getData(params)",
        "description": "\n\n  Retrieves raw instance data given the [can-connect/data/url/url.url] settings.\n  If `url.getData` is a function, that function will be called.  If `url.getData` is a\n  string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "A object that represents the set of data needed to be loaded."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "A object that represents the set of data needed to be loaded."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance data.\n "
    }
  },
  "can-connect/data/url/url.createData": {
    "name": "can-connect/data/url/url.createData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 269,
      "codeLine": 285,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "signatures": [
      {
        "code": "createData(instanceData, cid)",
        "description": "\n\n  Creates instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.createData` is a function, that function will be called.  If `url.createData` is a\n  string, a request to that string will be made. If `url` is a string, a `POST` request is made to\n  `url`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "A unique id that represents the instance that is being created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the newly created instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "A unique id that represents the instance that is being created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the newly created instance data.\n "
    }
  },
  "can-connect/data/url/url.updateData": {
    "name": "can-connect/data/url/url.updateData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 286,
      "codeLine": 301,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "updateData(instanceData)",
        "description": "\n\nUpdates instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.updateData` is a function, that function will be called.  If `url.updateData` is a\n  string, a request to that string will be made. If `url` is a string, a `PUT` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the updated instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the updated instance data.\n "
    }
  },
  "can-connect/data/url/url.destroyData": {
    "name": "can-connect/data/url/url.destroyData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 302,
      "codeLine": 317,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "destroyData(instanceData)",
        "description": "\n\nDeletes instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.destroyData` is a function, that function will be called.  If `url.destroyData` is a\n  string, a request to that string will be made. If `url` is a string, a `DELETE` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the deleted instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the deleted instance data.\n "
    }
  },
  "can-connect/data/parse/parse": {
    "name": "can-connect/data/parse/parse",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 55,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n\n## Use\n\n`data/parse` is used to modify the response data of \"data interface\" methods to comply with what\nis expected by \"instance interface\" methods.  For example, if a service was returning list data\nat the `/services/todos` url like:\n\n```\n{\n  todos: [\n    {todo: {id: 0, name: \"dishes\"}},\n    {todo: {id: 2, name: \"lawn\"}}\n  ]\n}\n```\n\nThat service does not return [can-connect.listData] in the right format which should look like:\n\n```\n{\n  data: [\n    {id: 0, name: \"dishes\"},\n    {id: 2, name: \"lawn\"}\n  ]\n}\n```\n\nTo correct this, you can configure `data-parse` to use the [can-connect/data/parse/parse.parseListProp] and [connection.parseInstanceProp]\nas follows:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n parseListProp: \"todos\",\n parseInstanceProp: \"todo\"\n})\n```\n\n\n",
    "description": "\nExtract response data into a format needed for other extensions.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "dataParse( baseConnection )",
        "description": "\n\n  Overwrites the [can-connect/DataInterface] methods to run their results through\n  either [can-connect/data/parse/parse.parseInstanceData] or [can-connect/data/parse/parse.parseListData].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "The base connection.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "The base connection.\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseListData": {
    "type": "function",
    "name": "can-connect/data/parse/parse.parseListData",
    "parent": "can-connect/data/parse/parse",
    "src": {
      "line": 63,
      "codeLine": 130,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n## Use\n\n`parseListData` comes in handy when dealing with an irregular API\nthat can be improved with data transformation.\n\nSuppose an endpoint responds with a status of 200 OK, even when the\nrequest generates an empty result set. Worse yet, instead of representing\nan emtpy set with an empty list, it removes the property.\n\nA request to `/services/todos` may return:\n\n```\n{\n  todos: [\n    {todo: {id: 0, name: \"dishes\"}},\n    {todo: {id: 2, name: \"lawn\"}}\n  ]\n}\n```\n\nWhat if a request for `/services/todos?filterName=bank` responds with\n200 OK:\n\n```\n{\n}\n```\n\nThis response breaks its own schema. One way to bring it in line\nwith a format compatible with [can-connect.listData] is:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  parseListProp: \"todos\",\n  parseListData(responseData) {\n    if (responseData && !responseData.todos) {\n      responseData = { todos: [] };\n    }\n\n    return responseData;\n  }\n})\n```\n    \n",
    "description": "Given a response from [can-connect/connection.getListData] returns its data in the proper [can-connect.listData] format.\n\n",
    "title": "parseListData",
    "signatures": [
      {
        "code": "connection.parseListData(responseData)",
        "description": "\n\n  This function uses [can-connect/data/parse/parse.parseListProp] to find the array\n  containing the data for each instance.  Then it uses [can-connect/data/parse/parse.parseInstanceData]\n  on each item in the array  Finally, it returns data in the\n  [can-connect.listData] format.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "The response data from the AJAX request.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "An object like `{data: [props, props, ...]}`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "responseData",
      "description": "The response data from the AJAX request.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "An object like `{data: [props, props, ...]}`.\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseInstanceData": {
    "type": "function",
    "name": "can-connect/data/parse/parse.parseInstanceData",
    "parent": "can-connect/data/parse/parse",
    "src": {
      "line": 160,
      "codeLine": 230,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n## Use\n\n`parseInstanceData` comes in handy when dealing with an irregular API\nthat can be improved with data transformation.\n\nSuppose a request to `/services/todos` returns:\n```\n{\n  baseUrl: \"/proxy/share\",\n  todo: {\n    id: 0,\n    name: \"dishes\",\n    friendFaceUrl: \"friendface?id=0\",\n    fiddlerUrl: \"fiddler?id=0\"\n  }\n}\n```\n\nThe baseUrl property is meta-data that needs to be incorporated into the\ninstance data. One way to deal with this is:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  parseInstanceProp: \"todo\",\n  parseInstanceData(responseData) {\n    ['friendFaceUrl', 'fiddlerUrl'].map(urlProp => {\n      responseData.todo[urlProp] = [\n        responseData.baseUrl,\n        responseData.todo[urlProp]\n      ].join('/');\n    });\n\n    return responseData;\n  }\n})\n```\n\nThis results in an object like:\n\n```js\n{\n  id: 0,\n  name: \"dishes\",\n  friendFaceUrl: \"/proxy/share/friendface?id=0\",\n  fiddlerUrl: \"/proxy/share/fiddler?id=0\"\n}\n```\n    \n",
    "description": "Returns the properties that should be used to [can-connect/constructor/constructor.hydrateInstance make an instance] given the results of [can-connect/connection.getData], [can-connect/connection.createData], [can-connect/connection.updateData],\nand [can-connect/connection.destroyData].\n\n",
    "title": "parseInstanceData",
    "signatures": [
      {
        "code": "connection.parseInstanceData(responseData)",
        "description": "\n\n  This function will use [connection.parseInstanceProp] to find the data object\n  representing the instance that will be created.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "responseData",
      "description": "The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseListProp": {
    "body": "\n\n## Use\n\nSet `parseListProp` if your response data does not look like: `{data: [props, props]}`.\n\nFor example, if [can-connect/connection.getListData] returns data like:\n\n```\n{\n\t  todos: [{id: 1, name: \"dishes\"}, {id: 2, name: \"lawn\"}]\n}\n```\n\nSet `parseListProp` to `\"todos\"` like:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url : \"/todos\",\n  parseListProp: \"todos\"\n});\n```\n\n\t \n",
    "description": "\nThe property to find the array-like data that represents each instance item.\n",
    "types": [
      {
        "type": "String",
        "description": "[can-connect/data/parse/parse.parseListData] uses this property to find an array-like data struture\non the result of [can-connect/connection.getListData].\n"
      }
    ],
    "title": "parseListProp",
    "name": "can-connect/data/parse/parse.parseListProp",
    "type": "property",
    "parent": "can-connect/data/parse/parse",
    "comment": " "
  },
  "connection.parseInstanceProp": {
    "src": {
      "line": 275,
      "codeLine": 317,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\nSet `parseInstanceData` if your response data does not directly contain the data you would like to pass to\n[connection.hydrateInstance].\n\nFor example, if [can-connect/connection.getData] returns data like:\n\n```\n{\n  todo: {\n\t   id: 1,\n    name: \"dishes\"\n  }\n}\n```\n\nSet `parseInstanceProp` to `\"todo\"` like:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url : \"/todos\",\n  parseInstanceProp: \"todo\"\n});\n```\n\t \n",
    "description": "\nThe property to find the data that represents an instance item.\n",
    "types": [
      {
        "type": "String",
        "description": "[can-connect/data/parse/parse.parseInstanceData] uses this property's value to\n[can-connect/constructor/constructor.hydrateInstance make an instance].\n"
      }
    ],
    "title": "parseInstanceProp",
    "name": "connection.parseInstanceProp",
    "parent": "can-connect/data/parse/parse",
    "comment": " "
  },
  "can-connect/data/worker/worker.identifiers": {
    "name": "can-connect/data/worker/worker.identifiers",
    "title": "options",
    "type": "group",
    "parent": "can-connect/data/worker/worker",
    "description": "",
    "order": 0
  },
  "can-connect/data/worker/worker.data": {
    "name": "can-connect/data/worker/worker.data",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/worker/worker",
    "description": "",
    "order": 0
  },
  "can-connect/data/worker/worker": {
    "src": {
      "path": "node_modules/can-connect/data/worker/worker.md"
    },
    "body": "\n\n## Use\n\nThe best way to use `data/worker` is to create a connection module that works when loaded in\neither the `window` or in a [Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers).\nThis pattern tends to work even if workers are not supported.\n\nThe following creates a connection that does the work of [can-connect/cache-requests/cache-requests],\n[can-connect/data/url/url], and [can-connect/data/memory-cache/memory-cache] in a worker thread.  \n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/data-worker.html'></div>\n\nThe `todo_connection` module can be found [here](https://github.com/canjs/can-connect/blob/master/src/data/worker/demo/todo_connection.js)\nand looks like the following:\n\n\n```js\nvar connect = require(\"can-connect\");\nvar fixture = require(\"can-fixture\");\n\n// If we are in the main thread, see if we can load this same\n// connection in a worker thread.\nvar worker;\nif(typeof document !== \"undefined\") {\n\tworker = new Worker( System.stealURL+\"?main=can-connect/data/worker/demo/todo_connection\" );\n}\n\n\n// create cache connection\nvar cache = connect([\n\trequire(\"can-connect/data/memory-cache/\")\n],{\n\tname: \"todos\"\n});\n\n// Create the main connection with everything you need.  If there is a worker,\n// all data interface methods will be sent to the worker.\nvar todosConnection = connect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/cache-requests/cache-requests\"),\n\trequire(\"can-connect/data/worker/worker\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\")\n],{\n    url: \"/todos\",\n    cacheConnection: cache,\n    worker: worker,\n    name: \"todos\"\n});\n\n\nfixture.delay = 1000;\nfixture({\n\t\"GET /todos\": function(request){\n\t\treturn {data: [\n\t\t\t{id: 1, name: \"wash dishes\"},\n\t\t\t{id: 2, name: \"mow lawn\"},\n\t\t\t{id: 3, name: \"do laundry\"}\n\t\t]};\n\t}\n});\n\nmodule.exports = todosConnection;\n```\n\n\n\nThe things to notice:\n\n1. A `Worker` should be passed as the [can-connect/data/worker/worker.worker] option\nthat loads a connection with the same name as the connection in the `window`.  In thise case, the same\nconnection module is loaded so everything works.\n\n2. A single `Worker` could load multiple connection modules and perform other behaviors.  \n\n### Split Connection Logic\n\nTHe previous example used a single module that was loaded by both the window and the worker.\nThis doesn't have to be the case.  Two different modules could be used.  For example, `todo-window.js` and\n`todo-worker.js`.  Each might look like:\n\n```js\n// todo-window.js\nvar workerURL = System.stealURL+\"?main=app/models/todo-worker\";\n\nvar todoConnection = connect([\n\trequire(\"can-connect/data/worker/worker\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\"),\n  {\n    worker: new Worker( workerURL ),\n    name: \"todos\"\n  });\n```\n\n```js\n// todo-worker.js\nvar cache = connect([\n\trequire(\"can-connect/data/memory-cache/memory-cache\")\n],{\n\tname: \"todos-cache\"\n});\n\nvar todoConnection = connect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/cache-requests/cache-requests\"),\n\trequire(\"can-connect/data/worker/worker\")\n],{\n    url: \"/todos\",\n    cacheConnection: cache,\n    name: \"todos\"\n  });\n```\n\nHowever, the problem with the two-module approach is that it will not work\nif Workers are not supported by your browser.\n\n",
    "description": "\nConnects a connection to another connection in a worker thread.\n",
    "type": "module",
    "title": "",
    "name": "can-connect/data/worker/worker",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "dataWorker( baseConnection )",
        "description": "\n\nIf a [Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)\nis provided, overwrites the \"data interface methods\" to package the arguments and send them as\npart of a `postMessage` to the Worker.\n\n\nIf a `Worker` is not provided, it is assumed \"data-worker\" is being added\nwithin a worker thread.  It listens to messages sent to the Worker, calls the specified \"data interface method\"\nand sends a message back with the result.\n\nAny data methods called on the `window` connection will wait until the `worker` connection\nhas established a handshake.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/worker/worker.getListData": {
    "src": {
      "line": 64,
      "codeLine": 76,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getListData",
    "name": "can-connect/data/worker/worker.getListData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getListData(set)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getListData` is overwritten\nto forward calling [can-connect/connection.getListData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getListData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.updateListData": {
    "src": {
      "line": 77,
      "codeLine": 89,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "updateListData",
    "name": "can-connect/data/worker/worker.updateListData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".updateListData(listData, set)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `updateListData` is overwritten\nto forward calling [can-connect/connection.updateListData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.updateListData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.getSets": {
    "src": {
      "line": 90,
      "codeLine": 102,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getSets",
    "name": "can-connect/data/worker/worker.getSets",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getSets()",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getSets` is overwritten\nto forward calling [can-connect/connection.getSets] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getSets] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.clear": {
    "src": {
      "line": 103,
      "codeLine": 115,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "clear",
    "name": "can-connect/data/worker/worker.clear",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".clear()",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `clear` is overwritten\nto forward calling [can-connect/connection.clear] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.clear] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.getData": {
    "src": {
      "line": 116,
      "codeLine": 128,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-connect/data/worker/worker.getData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getData(params)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getData` is overwritten\nto forward calling [can-connect/connection.getData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.createData": {
    "src": {
      "line": 129,
      "codeLine": 141,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-connect/data/worker/worker.createData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".createData(instanceData, cid)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `createData` is overwritten\nto forward calling [can-connect/connection.createData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.createData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.updateData": {
    "src": {
      "line": 142,
      "codeLine": 154,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "updateData",
    "name": "can-connect/data/worker/worker.updateData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".updateData(instanceData)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `updateData` is overwritten\nto forward calling [can-connect/connection.updateData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.updateData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.destroyData": {
    "src": {
      "line": 155,
      "codeLine": 167,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-connect/data/worker/worker.destroyData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".destroyData(instanceData)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `destroyData` is overwritten\nto forward calling [can-connect/connection.destroyData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.destroyData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.name": {
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "String",
        "description": "The connection must be provided a unique name. This\nmakes sure the connections in both windows are linked.\n\n```js\nconnect([...],{\n  name: \"todos\"\n})\n```\n\t\t "
      }
    ],
    "title": "name",
    "name": "can-connect/data/worker/worker.name",
    "type": "property",
    "parent": "can-connect/data/worker/worker.identifiers"
  },
  "can-connect/data/worker/worker.worker": {
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Worker",
        "description": "A [web-worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) that \"data instance\" methods will be sent to.  This\nweb-worker should include a connection that matches the name of the window's\nconnection. If a worker isn't provided, the connection behaves as if the `data/worker` behavior\nwas not added.\n\n```js\nvar worker = new Worker(\"path/to/script.js\");\nconnect([...],{\n  worker: worker\n})\n```\n\t\t "
      }
    ],
    "title": "worker",
    "name": "can-connect/data/worker/worker.worker",
    "type": "property",
    "parent": "can-connect/data/worker/worker.identifiers"
  },
  "can-define/list/list/AddEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.add.md"
    },
    "body": "\n",
    "description": "\nEvent fired when items are added to the list.\n",
    "type": "typedef",
    "title": "add",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/AddEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, added, index)",
        "description": "\n\nHandlers registered with [can-event] methods on `list` will be called back when\nitems are added to a list.\n\n```\nlist.on(\"add\", function(event, added, index){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "added",
            "description": "An array of the items added to the list."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The location where the items were added.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "index",
      "description": "The location where the items were added.\n"
    }
  },
  "can-define/list/list/events": {
    "name": "can-define/list/list/events",
    "title": "events",
    "type": "group",
    "parent": "can-define/list/list",
    "description": "",
    "order": 0
  },
  "can-define/list/list/LengthEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.length.md"
    },
    "body": "\n",
    "description": "\nEvent fired when items are added or removed from the list.\n",
    "type": "typedef",
    "title": "length",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/LengthEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, length)",
        "description": "\n\nHandlers registered on \"length\" events will be called\nback as follows.\n\n```\nlist.on(\"length\", function(event, length){ ... });\n```\n\nIt's possible that the length was not changed, but an item was [can-define/list/list::set] on the list.\nIn this case, a `length` event will still be fired.\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "length",
            "description": "The new length of the list.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "length",
      "description": "The new length of the list.\n"
    }
  },
  "can-define/list/list.prototype.on": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.on.md"
    },
    "body": "",
    "description": "Add event handlers to a list. \n",
    "title": "on",
    "name": "can-define/list/list.prototype.on",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "signatures": [
      {
        "code": "list.on(eventType, handler)",
        "description": "\n\nListens to `eventType` on `list` and calls `handler` when the event is dispatched.  This is simply\na reference to [can-event.on can-event.on] as all of [can-event] methods are available on `DefineMap`.\n\n```js\nvar list = new DefineList([\"CanJS\",\"StealJS\"])\nlist.on(\"add\", function(ev, added, index){ ... });\nlist.push(\"DoneJS\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of event to bind this handler to.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event"
                  },
                  {
                    "variable": true,
                    "name": "args"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Event"
                }
              ],
              "name": "event"
            },
            {
              "variable": true,
              "name": "args"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "This list, for chaining.\n"
    }
  },
  "can-define/list/list/RemoveEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.remove.md"
    },
    "body": "\n",
    "description": "\nEvent fired when items are removed from the list.\n",
    "type": "typedef",
    "title": "remove",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/RemoveEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, removed, index)",
        "description": "\n\nHandlers registered with [can-event] methods on `list` will be called back when\nitems are removed to a list.\n\n```\nlist.on(\"remove\", function(event, removed, index){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "removed",
            "description": "An array of the items removed from the list."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The location where the items were removed.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "index",
      "description": "The location where the items were removed.\n"
    }
  },
  "can-define/list/list/PropertyNameEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.propertyName.md"
    },
    "body": "\n",
    "description": "\nEvent fired when a property on the list changes values.\n",
    "type": "typedef",
    "title": "propertyName",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/PropertyNameEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, newValue, oldValue)",
        "description": "\n\nHandlers registered on `propertyName` events will be called\nback as follows.\n\n```\nlist.set(\"totalCount\", 500);\nlist.on(\"totalCount\", function(event, newVal, oldVal){\n  newVal //-> 5\n  oldVal //-> 500\n});\nlist.set(\"totalCount\", 5);\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newVal",
            "description": "The new value of the `propertyName` property."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "oldVal",
            "description": "The old value of the `propertyName` property.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "oldVal",
      "description": "The old value of the `propertyName` property.\n"
    }
  },
  "can-define/list/list.extend": {
    "src": {
      "path": "node_modules/can-define/list/docs/static.extend.md"
    },
    "body": "\n",
    "description": "Define a custom list type. \n",
    "title": "extend",
    "name": "can-define/list/list.extend",
    "type": "function",
    "parent": "can-define/list/list.static",
    "signatures": [
      {
        "code": "DefineList.extend([name,] [static,] prototype)",
        "description": "\n\nExtends DefineList, or constructor functions derived from DefineList,\nto create a new constructor function.\n\n```js\nvar DefineList = require(\"can-define/list/list\");\n\nvar TodoList = DefineList.extend(\n  \"TodoList\",\n  {\n    \"#\": {type: {complete: \"boolean\", name: \"string\"}}\n    availableCount: \"number\",\n    completedCount: {\n      get: function(){\n        return this.filter({complete: true}).length;\n      }\n    },\n    completeAll: function(){\n      this.forEach(function(todo){\n        todo.complete = true;\n      })\n    }\n  });\n\nvar todos = new TodoList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: false}\n]);\ntodos.availableCount = 100;\n\ntodos.completeAll();\ntodos.completeCount //-> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Provides an optional name for this type that will\nshow up nicely in debuggers.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "static",
            "description": "Static properties that are set directly on the\nconstructor function.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      },
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "prototype",
            "description": "A definition of the properties or methods on this type.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A DefineList constructor function.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                },
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "prototype",
      "description": "A definition of the properties or methods on this type.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A DefineList constructor function.\n\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.wildcardItems": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.wildcardItems.md"
    },
    "body": "",
    "description": "Define default behavior for items in the list. \n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\nBy defining a wildcard property (`\"#\"`) on the prototype, this will supply a\ndefault behavior for items in the list.  The default wildcard (`\"#\"`) definition\nmakes every item run through the \"observable\" [can-define.types] converter.\nIt looks like:\n\n```js\n\"#\": {\n  type: \"observable\"\n}\n```\n\nSetting the wildcard is useful when items should be converted to a particular type.\n\n```js\nvar Person = DefineMap.extend({ ... });\n\nvar People = DefineList.extend({\n  \"#\": Person\n});\n```\n\nThe wildcard property has optional `added` and `removed` functions that will be called after\nan item is added or removed from the list with `this` being the list.\n\n```js\nvar People = DefineList.extend({\n  \"#\": {\n  \tadded: function(itemsAdded, index) { ... },\n  \tremoved: function(itemsRemoved, index) { ... }\n  }\n});\n```\n"
      }
    ],
    "title": "#",
    "name": "can-define/list/list.prototype.wildcardItems",
    "type": "property",
    "parent": "can-define/list/list.prototype"
  },
  "can-define/list/list.prototype.wildcard": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.wildcard.md"
    },
    "body": "",
    "description": "Define default behavior for all properties and items in the list. Use [can-define/list/list.prototype.wildcardItems] to define the default type of items in the list.\n\n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\nBy defining a wildcard property (`\"*\"`) on the prototype, this will supply a\ndefault behavior for every property in the list.  The default wildcard `\"*\"` definition\nmakes every property run through the \"observable\" [can-define.types] converter.\nIt looks like:\n\n```js\n\"*\": {\n  type: \"observable\"\n}\n```\n\nSetting the wildcard is useful when all properties should be converted to a particular type.\n\n```js\nvar Person = DefineList.extend({ ... });\n\nvar People = DefineList.extend({\n  \"*\": \"string\"\n  \"#\": Person\n});\n\nvar people = new People();\n\npeople.set(\"age\", 21);\npeople.age //-> \"21\"\n```\n"
      }
    ],
    "title": "*",
    "name": "can-define/list/list.prototype.wildcard",
    "type": "property",
    "parent": "can-define/list/list.prototype"
  },
  "can-define/map/map/PropertyNameEvent": {
    "src": {
      "path": "node_modules/can-define/map/docs/events.propertyName.md"
    },
    "body": "\n",
    "description": "\nEvent fired when a property on the map changes values.\n",
    "type": "typedef",
    "title": "propertyName",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/map/map/PropertyNameEvent",
    "parent": "can-define/map/map/events",
    "signatures": [
      {
        "code": "handler(event, newValue, oldValue)",
        "description": "\n\nHandlers registered on `propertyName` events will be called\nback as follows.\n\n```\nvar person = new DefineMap({name: \"Justin\"});\nlist.on(\"name\", function(event, newVal, oldVal){\n  newVal //-> \"Brian\"\n  oldVal //-> \"Justin\"\n});\nperson.name = \"Brian\";\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newVal",
            "description": "The new value of the `propertyName` property."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "oldVal",
            "description": "The old value of the `propertyName` property.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "oldVal",
      "description": "The old value of the `propertyName` property.\n"
    }
  },
  "can-define/map/map.prototype.forEach": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.forEach.md"
    },
    "body": "\n## Use\n\nExample\n\n```\nvar names = [];\nnew DefineMap({a: 'Alice', b: 'Bob', e: 'Eve'}).forEach(function(value, key) {\n    names.push(value);\n});\n\nnames; // ['Alice', 'Bob', 'Eve']\n\nnames = [];\nnew DefineMap({a: 'Alice', b: 'Bob', e: 'Eve'}).forEach(function(value, key) {\n    names.push(value);\n    if(key === 'b') {\n        return false;\n    }\n});\n\nnames; // ['Alice', 'Bob']\n```\n\n",
    "description": "Call a function on each property of a DefineMap. \n",
    "title": "forEach",
    "name": "can-define/map/map.prototype.forEach",
    "type": "function",
    "parent": "can-define/map/map.prototype",
    "signatures": [
      {
        "code": "map.forEach( callback(value, propName ) )",
        "description": "\n\n`forEach` iterates through the map instance, calling a function\nfor each property value and key.\n\n```js\nmap.forEach(function(value, propName){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "value"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "propName"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "The function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns `false`,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "value"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "propName"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "The function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns `false`,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "The map instance for chaining.\n"
    },
    "comment": " "
  },
  "can-define/map/map.prototype": {
    "name": "can-define/map/map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map.static": {
    "name": "can-define/map/map.static",
    "title": "static",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map/events": {
    "name": "can-define/map/map/events",
    "title": "events",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map": {
    "src": {
      "path": "node_modules/can-define/map/docs/define-map.md"
    },
    "body": "\n## Use\n\n`can-define/map/map` is used to create easily extensible observable types with well defined\nbehavior.\n\nFor example, a `Todo` type, with a `name` property, `completed` property, and a `toggle` method, might be defined like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Todo = DefineMap.extend({\n\tname: \"string\",\n\tcompleted: {type: \"boolean\", value: false},\n\ttoggle: function(){\n\t\tthis.completed = !this.completed;\n\t}\n})\n```\n\nThe _Object_ passed to `.extend` defines the properties and methods that will be\non _instances_ of a `Todo`.  There are a lot of ways to define properties.  The\n[can-define.types.propDefinition] type lists them all.  Here, we define:\n\n - `name` as a property that will be type coerced into a `String`.\n - `completed` as a property that will be type coerced into a `Boolean`\n   with an initial value of `false`.\n\nThis also defines a `toggle` method that will be available on _instances_ of `Todo`.\n\n`Todo` is a constructor function.  This means _instances_ of `Todo` can be be created by\ncalling `new Todo()` as follows:\n\n```js\nvar myTodo = new Todo();\nmyTodo.name = \"Do the dishes\";\nmyTodo.completed //-> false\n\nmyTodo.toggle();\nmyTodo.completed //-> true\n```  \n\nYou can also pass initial properties and their values when initializing a `DefineMap`:\n\n```js\nvar anotherTodo = new Todo({name: \"Mow lawn\", completed: true});\nmyTodo.name = \"Mow lawn\";\nmyTodo.completed //-> true\n```  \n\n## Declarative properties\n\nArguably `can-define`'s most important ability is its support of declarative properties\nthat functionally derive their value from other property values.  This is done by\ndefining [can-define.types.get getter] properties like `fullName` as follows:\n\n```js\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\",\n\tfullName: {\n\t\tget : function(){\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n});\n```\n\n`fullName` can also be defined with the ES5 shorthand getter syntax:\n\n```js\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\",\n\tget fullName(){\n\t\treturn this.first + \" \" + this.last;\n\t}\n});\n```\n\nNow, when a `person` is created, there is a `fullName` property available like:\n\n```js\nvar me = new Person({first: \"Harry\", last: \"Potter\"});\nme.fullName //-> \"Harry Potter\"\n```\n\nThis property can be bound to like any other property:\n\n```js\nme.on(\"fullName\", function(ev, newValue, oldValue){\n\tnewValue //-> Harry Henderson\n\toldValue //-> Harry Potter\n});\n\nme.last = \"Henderson\";\n```\n\n`getter` properties use [can-compute] internally.  This means that when bound,\nthe value of the `getter` is cached and only updates when one of its source\nobservables change.  For example:\n\n```js\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\",\n\tget fullName(){\n\t\tconsole.log(\"calculating fullName\");\n\t\treturn this.first + \" \" + this.last;\n\t}\n});\n\nvar hero = new Person({first: \"Wonder\", last: \"Woman\"});\n\n// console.logs \"calculating fullName\"\nhero.fullName //-> Wonder Woman\n\n// console.logs \"calculating fullName\"\nhero.fullName //-> Wonder Woman\n\n// console.logs \"calculating fullName\"\nhero.on(\"fullName\", function(){});\n\nhero.fullName //-> \"Wonder Woman\"\n\n// console.logs \"calculating fullName\"\nhero.first = \"Bionic\"\n\n// console.logs \"calculating fullName\"\nhero.last = \"Man\"\n\nhero.fullName //-> \"Bionic Man\"\n```\n\nIf you want to prevent repeat updates, use [can-event/batch/batch]:\n\n```js\nhero.fullName //-> \"Bionic Man\"\n\nvar canBatch = require(\"can-event/batch/batch\");\n\ncanBatch.start();\nhero.first = \"Silk\";\nhero.last = \"Spectre\";\n\n// console.logs \"calculating fullName\"\ncanBatch.stop();\n```\n\n### Asynchronous getters\n\n`getters` can also be asynchronous.  These are very useful when you have a type\nthat requires data from the server.  This is very common in [can-component]\nview-models.  For example, a `view-model` might take a `todoId` value, and want\nto make a `todo` property available:\n\n```js\nvar ajax = require(\"can-util/dom/ajax/ajax\");\n\nvar TodoViewModel = DefineMap.extend({\n\ttodoId: \"number\",\n\ttodo: {\n\t\tget: function(lastSetValue, resolve){\n\t\t\t\tajax({url: \"/todos/\"+this.todoId}).then(resolve)\n\t\t\t}\n\t}\n});\n```\n\nAsynchronous getters only are passed a `resolve` argument when bound.  Typically in an application,\nyour template will automatically bind on the `todo` property.  But to use it in a test might\nlook like:\n\n```js\nvar fixture = require(\"can-fixture\");\nfixture(\"GET /todos/5\", function(){\n\treturn {id: 5, name: \"take out trash\"}\n});\n\nvar todoVM = new TodoViewModel({id: 5});\ntodoVM.on(\"todo\", function(ev, newVal){\n\tassert.equal(newVal.name, \"take out trash\");\n});\n```\n\n### Getter limitations\n\nThere's some functionality that a getter or an async getter can not describe\ndeclaratively.  For these situations, you can use [can-define.types.set] or\neven better, use the [can-define-stream] plugin.\n\nFor example, consider a __state__ and __city__ locator where you pick a United States\n__state__ like _Illinois_ and then a __city__ like _Chicago_.  In this example,\nwe want to clear the choice of __city__ whenever the __state__ changes.\n\nThis can be implemented with [can-define.types.set] like:\n\n```js\nLocator = DefineMap.extend({\n\tstate: {\n\t\ttype: \"string\",\n\t\tset: function(){\n\t\t\tthis.city = null;\n\t\t}\n\t},\n\tcity: \"string\"\n});\n\nvar locator = new Locator({\n\tstate: \"IL\",\n\tcity: \"Chicago\"\n});\n\nlocator.state = \"CA\";\nlocator.city //-> null;\n```\n\nThis isn't declarative anymore because changing state imperatively changes\nthe value of `city`. The [can-define-stream] plugin can make this functionality\nentirely declarative.\n\n```js\nvar Locator = DefineMap.extend({\n     state: \"string\",\n     city: {\n         type: \"string\",\n         stream: function(setStream) {\n             return this.stream(\".state\").map(function(){\n                 return null;\n             }).merge(setStream);\n         }\n     }\n});\n\nvar locator = new Locator({\n\tstate: \"IL\",\n\tcity: \"Chicago\"\n});\n\nlocator.on(\"city\", function(){});\n\nlocator.state = \"CA\";\nlocator.city //-> null;\n```\n\nNotice, in the `can-define-stream` example, `city` must be bound for it to work.  \n\n## Sealed instances and strict mode\n\nBy default, `DefineMap` instances are [can-define/map/map.seal sealed].  This\nmeans that setting properties that are not defined when the constructor is defined\nwill throw an error in files that are in [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode). For example:\n\n```js\n\"use strict\";\n\nvar DefineMap = require(\"can-define/map/map\");\n\nvar MyType = DefineMap.extend({\n    myProp: \"string\"\n});\n\nvar myType = new MyType();\n\nmyType.myProp = \"value\"; // no error thrown\n\nmyType.otherProp = \"value\" // throws Error!\n```\n\nRead the [can-define/map/map.seal] documentation for more information on this behavior.\n\n",
    "description": "Create observable objects. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define/map/map",
    "parent": "can-observables",
    "collection": "can-core",
    "alias": "can.DefineMap",
    "inherits": "can.Construct",
    "signatures": [
      {
        "code": "new DefineMap([props])",
        "description": "\n\nThe `can-define/map/map` module exports the `DefineMap` constructor function.  \n\nCalling `new DefineMap(props)` creates a new instance of DefineMap or an [can-define/map/map.extend extended] DefineMap. Then, assigns every property on `props` to the new instance.  If props are passed that are not defined already, those property definitions are created.  If the instance should be sealed, it is sealed.\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar person = new DefineMap({\n  first: \"Justin\",\n  last: \"Meyer\"\n})\n```\n\n  Custom `DefineMap` types, with special properties and behaviors, can be defined with [can-define/map/map.extend].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the map with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "An instance of `DefineMap` with the properties from _props_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "props",
      "description": "Properties and values to seed the map with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "An instance of `DefineMap` with the properties from _props_.\n"
    },
    "comment": " "
  },
  "can-define/map/map/KeysEvent": {
    "src": {
      "path": "node_modules/can-define/map/docs/events.keys.md"
    },
    "body": "\n",
    "description": "\nEvent fired when a property is added.\n",
    "type": "typedef",
    "title": "__keys",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/map/map/KeysEvent",
    "parent": "can-define/map/map/events",
    "signatures": [
      {
        "code": "handler(event)",
        "description": "\n\nHandlers registered on `__keys` events will be called\nback as follows.\n\n```\nvar person = new DefineMap({name: \"Justin\"});\nlist.on(\"__keys\", function(event){ ... });\nperson.set(\"age\", 33);\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Event"
        }
      ],
      "name": "event",
      "description": "An event object.\n"
    }
  },
  "can-define/map/map.seal": {
    "src": {
      "path": "node_modules/can-define/map/docs/static.seal.md"
    },
    "body": "\n",
    "description": "Defines if instances of the map should be [sealed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal) in development. \n",
    "types": [
      {
        "type": "Boolean",
        "description": "If `true`, in development, instances of this object will be [sealed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal).  In  [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) errors will be thrown when undefined properties are set.  This is the default\nbehavior of [can-define/map/map.extend extended DefineMaps]:\n\n```js\n\"use strict\";\nvar Person = DefineMap.extend({});\nvar me = new Person();\nme.age = 33 //-> throws \"TypeError: Can't add property age, object is not extensible\"\n```\n\nIf `false`, the object will not be sealed.  This is the default behavior of\nunextended [can-define/map/map DefineMaps].  Use [can-define/map/map.prototype.get] and [can-define/map/map.prototype.set] to get and set values:\n\n```js\nvar person = new DefineMap();\nperson.set(\"first\",\"Justin\");\nperson.set(\"last\",\"Meyer\");\n\nperson.get(\"first\") //-> \"Justin\"\nperson.get(\"last\") //-> \"Meyer\"\n```\n\nIt is also possible to extend a sealed object and unseal it:\n\n```js\n\"use strict\";\nvar Person = DefineMap.extend({});\nvar Programmer = Person.extend({seal: false}, {})\nvar me = new Programmer();\nme.age = 33; // no error thrown\n```\n\nSet `seal` to `false` on objects that have an indeterminate number of properties:\n\n```js\nvar Style = DefineMap.extend({\n  seal: false\n},{\n  cssText: {\n    get: function(){\n      return _.map(this.get(), function(val, prop){\n        return prop+\": \"+val;\n      }).join(\";\")\n    }\n  }\n});\nvar style = new Style();\nstyle.set(\"color\",\"green\");\nstyle.set(\"font\",\"awesome\");\nstyle.cssText //-> \"color:green; font: awesome;\"\n```\n"
      }
    ],
    "title": "seal",
    "name": "can-define/map/map.seal",
    "type": "property",
    "parent": "can-define/map/map.static"
  },
  "can-define/map/map.prototype.wildcard": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.wildcard.md"
    },
    "body": "",
    "description": "Define default behavior for a Map instance. \n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\nBy defining a wildcard property like `\"*\"` on the prototype, this will supply a\ndefault behavior for every property.  The default wildcard `\"*\"` definition\nmakes every property run through the \"observable\" [can-define.types] converter.\nIt looks like:\n\n```\n\"*\": {\n  type: \"observable\"\n}\n```\n\nSetting the wildcard is useful when every property on a\nmap instance should behave in a particular way.  For example, for map types used\nwith [can-route]:\n\n```\nvar MyMap = DefineMap.extend({\n  \"*\": {\n    type: \"stringOrObservable\"\n  }\n})\n```\n\nOr if you want to turn off implicit conversion of Objects and Arrays to DefineMap and DefineLists:\n\n```\nvar MyMap = DefineMap.extend({\n  \"*\": {\n    type: \"*\"\n  }\n})\n```\n"
      }
    ],
    "title": "*",
    "name": "can-define/map/map.prototype.wildcard",
    "type": "property",
    "parent": "can-define/map/map.prototype"
  },
  "can-define/map/map.prototype.on": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.on.md"
    },
    "body": "\n## Use\n\n`on` binds event handlers to property changes on `DefineMap`s. When you change\na property value, a _property name_ event is fired, allowing other parts\nof your application to map the changes to the object.\n\nThis event is useful for noticing changes to a specific property.\n\n\n    var o = new DefineMap({name: \"Justin\"});\n    o.on('name', function(ev, newVal, oldVal) {\n        console.log('The value of a changed.');\n    });\n\n\nThe parameters of the event handler for the _property name_ event are:\n\n- _ev_ The event object.\n- _newVal_ The value of the property after the change. `\n- _oldVal_ The value of the property before the change.\n\nHere is a concrete tour through the _property name_ event handler's arguments:\n\n\n    var o = new DefineMap({a: undefined, b: undefined});\n    o.on('a', function(ev, newVal, oldVal) {\n        console.log(newVal + ', ' + oldVal);\n    });\n\n    o.a = 'Alexis';       // Alexis, undefined\n    o.set('a', 'Adam');   // Adam, Alexis\n    o.set({\n        'a': 'Alice',     // Alice, Adam\n        'b': 'Bob'\n    });\n    o.a = undefined;      // undefined, Alice\n\n",
    "description": "Add event handlers to a map. \n",
    "title": "on",
    "name": "can-define/map/map.prototype.on",
    "type": "function",
    "parent": "can-define/map/map.prototype",
    "signatures": [
      {
        "code": "map.on(eventType, handler)",
        "description": "\n\nListens to `eventType` on `map` and calls `handler` when the event is dispatched.  This is simply\na reference to [can-event.on can-event.on] as all of [can-event] methods are available on `DefineMap`.\n\n```js\nvar map = new DefineMap({name: \"Justin\"})\nmap.on(\"name\", function(ev, newVal, oldVal){\n    newVal //-> \"Brian\"\n    oldVal //-> \"Justin\"\n});\nmap.name = \"Brian\";\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of event to bind this handler to.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event"
                  },
                  {
                    "variable": true,
                    "name": "args"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "This map, for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Event"
                }
              ],
              "name": "event"
            },
            {
              "variable": true,
              "name": "args"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "This map, for chaining.\n"
    },
    "comment": " "
  },
  "can-define/map/map.extend": {
    "src": {
      "path": "node_modules/can-define/map/docs/static.extend.md"
    },
    "body": "",
    "description": "Define a custom map type. \n",
    "title": "extend",
    "name": "can-define/map/map.extend",
    "type": "function",
    "parent": "can-define/map/map.static",
    "signatures": [
      {
        "code": "DefineMap.extend([name,] [static,] prototype)",
        "description": "\n\nExtends DefineMap, or constructor functions derived from DefineMap,\nto create a new constructor function.\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Person = DefineMap.extend(\n  \"Person\",\n  {seal: true},\n  {\n    first: \"string\",\n    last: {type: \"string\"},\n    fullName: {\n      get: function(){\n        return this.first+\" \"+this.last;\n      }\n    },\n    age: {value: 0},\n  });\n\nvar me = new Person({first: \"Justin\", last: \"Meyer\"})\nme.fullName //-> \"Justin Meyer\"\nme.age      //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Provides an optional name for this type that will\nshow up nicely in debuggers.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "static",
            "description": "Static properties that are set directly on the\nconstructor function.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      },
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "prototype",
            "description": "A definition of the properties or methods on this type.\n\nIf the property definition is a __plain function__, it's considered a method.\n\n```js\nvar Person = DefineMap.extend({\n  sayHi: function(){ console.log(\"hi\"); }\n});\n\nvar me = new Person();\nme.sayHi();\n```\n\nIf the property definition is a __string__, it's considered a `type` setting to be looked up in [can-define.types can-define.types].\n\n```js\nvar Person = DefineMap.extend({\n  age: 'number',\n  isCool: 'boolean',\n  hobbies: 'observable'\n});\n\nvar me = new Person({age: '33', isCool: 'false', hobbies: ['js','bball']});\nme.age    //-> 33\nme.isCool //-> false\nme.hobbies instanceof DefineList //-> true\n```\n\n\nIf the property definition is a Constructor function, it's considered a `Type` setting.\n\n```js\nvar Address = DefineMap.extend({\n  zip: 'number'\n});\nvar Person = DefineMap.extend({\n  address: Address\n});\n\nvar me = new Person({address: {zip: '60048'}});\nme.address.zip //-> 60048\n```\n\nIf the property is an __object__, it's considered to be a [can-define.types.propDefinition].\n\n```js\nvar Person = DefineMap.extend({\n  fullName: {\n    get: function() {\n      return this.first+\" \"+this.last;\n    },\n    set: function(newVal) {\n      var parts = newVal.split(\" \");\n      this.first = parts[0];\n      this.last = parts[1];\n    }\n  },\n  // slick way of creating an 'inline' type.\n  address: {\n    Type: {\n      zip: \"number\"\n    }\n  }\n});\n\nvar me = new Person({fullName: \"Rami Myer\", address: {zip: '60048'}});\nme.first       //-> \"Rami\"\nme.address.zip //-> 60048\n```\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "A DefineMap constructor function.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                },
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "prototype",
      "description": "A definition of the properties or methods on this type.\n\nIf the property definition is a __plain function__, it's considered a method.\n\n```js\nvar Person = DefineMap.extend({\n  sayHi: function(){ console.log(\"hi\"); }\n});\n\nvar me = new Person();\nme.sayHi();\n```\n\nIf the property definition is a __string__, it's considered a `type` setting to be looked up in [can-define.types can-define.types].\n\n```js\nvar Person = DefineMap.extend({\n  age: 'number',\n  isCool: 'boolean',\n  hobbies: 'observable'\n});\n\nvar me = new Person({age: '33', isCool: 'false', hobbies: ['js','bball']});\nme.age    //-> 33\nme.isCool //-> false\nme.hobbies instanceof DefineList //-> true\n```\n\n\nIf the property definition is a Constructor function, it's considered a `Type` setting.\n\n```js\nvar Address = DefineMap.extend({\n  zip: 'number'\n});\nvar Person = DefineMap.extend({\n  address: Address\n});\n\nvar me = new Person({address: {zip: '60048'}});\nme.address.zip //-> 60048\n```\n\nIf the property is an __object__, it's considered to be a [can-define.types.propDefinition].\n\n```js\nvar Person = DefineMap.extend({\n  fullName: {\n    get: function() {\n      return this.first+\" \"+this.last;\n    },\n    set: function(newVal) {\n      var parts = newVal.split(\" \");\n      this.first = parts[0];\n      this.last = parts[1];\n    }\n  },\n  // slick way of creating an 'inline' type.\n  address: {\n    Type: {\n      zip: \"number\"\n    }\n  }\n});\n\nvar me = new Person({fullName: \"Rami Myer\", address: {zip: '60048'}});\nme.first       //-> \"Rami\"\nme.address.zip //-> 60048\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "A DefineMap constructor function.\n"
    }
  },
  "can-fixture/StoreType.prototype.createData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.createData.md"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-fixture/StoreType.prototype.createData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.createData(request, response)",
        "description": "\n\nA `requestHandler` that creates an item in the store.\n\n```js\nfixture(\"POST /api/todos\", todoStore.createData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.get": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.get.md"
    },
    "body": "",
    "description": "\n",
    "title": "get",
    "name": "can-fixture/StoreType.prototype.get",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.get(params)",
        "description": "\n\nReturns a single item's data from the store.\n\n```js\ntodoStore.get({id: 1}) //-> {id: 1, name: \"dishes\"}\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.getData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getData.md"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-fixture/StoreType.prototype.getData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getData(request, response)",
        "description": "\n\nA `requestHandler` that gets a single item from the store.\n\n```js\nfixture(\"GET /api/todos/{_id}\", todoStore.getData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.destroyData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.destroyData.md"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-fixture/StoreType.prototype.destroyData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.destroyData(request, response)",
        "description": "\n\nA `requestHandler` that removes an item from the store.\n\n```js\nfixture(\"DELETE /api/todos/{_id}\", todoStore.destroyData)\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.reset": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.reset.md"
    },
    "body": "",
    "description": "\n",
    "title": "reset",
    "name": "can-fixture/StoreType.prototype.reset",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.reset([baseItems])",
        "description": "\n\nSets the items in the store to their original state or to `baseItems` if it's passed as an argument.\n\n```js\n// Creates a store with one item.\nvar todoStore = fixture.store(\n    [{id: 1, name: \"dishes\"}],\n    new set.Algebra());\nfixture(\"/todos/{id}\", todoStore)\ntodoStore.getList({}).length //-> 1\n\n// delete that item\n$.ajax({url: \"todos/1\", method: \"delete\"}).then(function(){\n    return todoStore.getList({}).length //-> 0\n}).then(function(){\n    // calling reset adds it back\n    todoStore.reset();\n    todoStore.getList({}).length //-> 1\n});\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "baseItems",
            "description": "If provided, adds these items to the store.  \nThis can be useful for setting up particular testing scenarios.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "baseItems",
      "description": "If provided, adds these items to the store.  \nThis can be useful for setting up particular testing scenarios.\n"
    }
  },
  "can-fixture/StoreType.prototype.getListData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getListData.md"
    },
    "body": "",
    "description": "\n",
    "title": "getListData",
    "name": "can-fixture/StoreType.prototype.getListData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getListData(request, response)",
        "description": "\n\nA `requestHandler` that gets multiple items from the store.\n\n```js\nfixture(\"GET /api/todos\", todoStore.getListData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.updateData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.updateData.md"
    },
    "body": "",
    "description": "\n",
    "title": "updateData",
    "name": "can-fixture/StoreType.prototype.updateData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.updateData(request, response)",
        "description": "\n\nA `requestHandler` that updates an item in the store.\n\n```js\nfixture(\"PUT /api/todos/{_id}\", todoStore.updateData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.getList": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getList.md"
    },
    "body": "",
    "description": "\n",
    "title": "getList",
    "name": "can-fixture/StoreType.prototype.getList",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getList(set)",
        "description": "\n\nReturns the matching items from the store like: `{data: [...]}`.\n\n```js\ntodoStore.get({name: \"dishes\"}) //-> {data: [{id: 1, name: \"dishes\"}]}\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype": {
    "name": "can-fixture/StoreType.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-fixture/StoreType",
    "description": "",
    "order": 0
  },
  "can-fixture/StoreType": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/StoreType.md"
    },
    "body": "",
    "description": "\n",
    "title": "Store",
    "name": "can-fixture/StoreType",
    "type": "function",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "Store",
        "description": "\n\nThe following documents the methods on a store object returned by [can-fixture.store].\n",
        "params": []
      }
    ]
  },
  "can-fixture/types/ajaxSettings": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/ajaxSettings.md"
    },
    "body": "\n",
    "description": "\nAn object used to match incoming [can-fixture/types/request] objects.\n",
    "type": "typedef",
    "title": "ajaxSettings",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "url",
            "description": "The requested url with anything after the querystring taken off in `GET` and `DESTROY` method requests.  For example, you can't match:\n\n```\nfixture({method: \"GET\", url: \"/things?name=Justin\"});\n```\n\nInstead write:\n\n```\nfixture({method: \"GET\", url: \"/things\", data: {name: \"Justin\"}});\n```\n\nThe `url` can have templates like:\n\n```\nfixture({method: \"GET\", url: \"/things/{id}\"})\n```\n\nThe templated values get added to the [can-fixture/types/request] object's `data`.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "method",
            "description": "The method of the request. Ex: `GET`, `PUT`, `POST`, etc. Capitalization is ignored.",
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true
          },
          {
            "name": "data",
            "description": "Match the data of the request. The data of the querystring or the data to `XMLHTTPRequest.prototype.send` is converted to a JavaScript objects with either `JSON.stringify` or [can-util/js/deparam/deparam].  The data must match part of the `request`'s data.",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true
          },
          {
            "name": "async",
            "description": "Write `true` to match asynchronous requests only.  \n",
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true
          }
        ],
        "description": "\n\nThis object is used to match values on [can-fixture/types/request] objects.\nIf there's a match, the fixture handler provided with the\n[can-fixture/types/ajaxSettings] will be invoked.\n\nIf a property on an `ajaxSettings` is not provided, all request values\nwill be matched for that property.\n\nFor example,\nyou can match all `GET` requests, no matter what `url` is passed like:\n\n```\nfixture({method: \"GET\"}, function(){ ... });\n```\n\n"
      }
    ],
    "name": "can-fixture/types/ajaxSettings",
    "parent": "can-fixture.types"
  },
  "can-fixture/types/request": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/request.md"
    },
    "body": "\n",
    "description": "\nAn object with easily digestible values derived from the mock XHR\nobject.  \n",
    "type": "typedef",
    "title": "request",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "url",
            "description": "The requested url with anything after the querystring taken off in `GET` and `DESTROY` method requests.",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "method",
            "description": "The method of the request. Ex: `GET`, `PUT`, `POST`, etc.",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "data",
            "description": "The data of the querystring or the data to `XMLHTTPRequest.prototype.send` converted back to JavaScript objects with either `JSON.stringify` or [can-util/js/deparam/deparam].",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "headers",
            "description": "Headers added to the XHR object with `XMLHTTPRequest.prototype.setRequestHeader`.",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "async",
            "description": "`true` if the request was a synchronous request.",
            "types": [
              {
                "type": "Boolean"
              }
            ]
          },
          {
            "name": "xhr",
            "description": "The mock xhr request.\n",
            "types": [
              {
                "type": "XMLHTTPRequest"
              }
            ]
          }
        ],
        "description": "\n\nThis object is passed to a [can-fixture.requestHandler]\nand can be used to determine the response.\n\n```js\nfixture(\"GET /todos/{id}\", function(request, response){\n    request.url     //-> \"todos/5\"\n    request.method  //-> \"get\"\n    request.data    //-> {id: \"5\", include: [\"owner\"]}\n    request.headers //-> {}\n    request.async   //-> false\n});\n\n$.get(\"/todos/5?include[]=owner\");\n```\n"
      }
    ],
    "name": "can-fixture/types/request",
    "parent": "can-fixture.types"
  },
  "can-fixture.requestHandler": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/requestHandler.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "requestHandler",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/request"
              }
            ],
            "name": "request"
          },
          {
            "types": [
              {
                "type": "can-fixture.response"
              }
            ],
            "name": "response"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "requestHeaders"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "ajaxSettings"
          }
        ]
      }
    ],
    "name": "can-fixture.requestHandler",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "requestHandler(request, response(...), requestHeaders, ajaxSettings)",
        "description": "\n\nDefines the XHR response for a given trapped request.\n\n```js\nfixture({method: \"get\", url: \"/todos\"},\n  function(request, response, headers, ajaxSettings){\n    request //-> {\n            //    method: \"get\",\n            //    url: \"/todos\",\n            //    data: {complete: true}\n            //   }\n\n  }\n});\n\n$.ajax({ method: \"get\", url: \"/todos?complete=true\" })\n```\n\nTemplated `url` data will be added to the `requestHandler`'s `request` argument's `data` property:\n\n```js\nfixture({url: \"/todos/{action}\"},\n  function(request, response, headers, ajaxSettings){\n    request //-> {\n            //    method: \"post\",\n            //    url: \"/todos\",\n            //    data: {action: delete}\n            //   }\n  }\n});\n\n$.post(\"/todos/delete\");\n```",
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/request"
              }
            ],
            "name": "request",
            "description": "Information about the request. The request's data property will contain data from the request's querystring or request body. Also\nany templated values in the [can-fixture/types/ajaxSettings]'s `url` will be added. "
          },
          {
            "types": [
              {
                "type": "can-fixture.response"
              }
            ],
            "name": "response",
            "description": "A callback function that provides response information."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "requestHeaders",
            "description": "Headers used to make the request."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "ajaxSettings",
            "description": "The settings object used to match this request.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "ajaxSettings",
      "description": "The settings object used to match this request.\n"
    }
  },
  "can-fixture.response": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/response.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "response",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-fixture.response",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "response(status, body, headers, statusText)",
        "description": "\n\nUsed to detail a response.\n\nExample:\n\n```js\nfixture({url: \"/todos/{action}\"},\n  function(request, response, headers, ajaxSettings){\n    response(\n        401,\n        { message: \"Unauthorized\"},\n        { \"WWW-Authenticate\": 'Basic realm=\"myRealm\"'},\n        \"unauthorized\");\n  }\n});\n\n$.post(\"/todos/delete\");\n```\n\nYou don't have to provide every argument to `response`. It can be called like:\n\n```js\n// Just body\nresponse({ message: \"Hello World\"});\n// status and body\nresponse(401, { message: \"Unauthorized\"});\n// body and headers\nresponse('{\"message\":\"Unauthorized\"}',{\"WWW-Authenticate\":'Basic realm=\"myRealm\"'});\n// status, body statusText\nresponse(401, '{\"message\":\"Unauthorized\"}','unauthorized');\n```\n\nThe default `statusText` will be `ok` for `200 <= status < 300, status === 304` and `error`\nfor everything else.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "status",
            "description": "The [HTTP response code](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html). Ex: `200`."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "body",
            "description": "A JS object that will be serialized and set as the responseText of the XHR object, or\nthe raw string text that will be set as the responseText of the XHR object."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "headers",
            "description": "An object of HTTP response headers and values."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "statusText",
            "description": "The status text of the response. Ex: ``\"ok\"`` for 200.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "statusText",
      "description": "The status text of the response. Ex: ``\"ok\"`` for 200.\n"
    }
  },
  "can-reflect/call.call": {
    "type": "function",
    "name": "can-reflect/call.call",
    "parent": "can-reflect/call",
    "src": {
      "line": 4,
      "codeLine": 29,
      "path": "node_modules/can-reflect/reflections/call/call.js"
    },
    "body": "",
    "description": "Call a callable, with a context object and parameters \n",
    "title": "call",
    "signatures": [
      {
        "code": "call(func, context, ...rest)",
        "description": "\n\nCall the callable `func` as if it were a function, bound to `context` and with any additional parameters\noccurring after `context` set to the positional parameters.\n\nNote that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@can.apply],\nor have a callable `apply` property to work with `canReflect.call`\n\n```\nvar compute = canCompute(\"foo\");\n\ncanReflect.call(compute, null, \"bar\");\ncanReflect.call(compute, null); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "variable": true
                  }
                ]
              }
            ],
            "name": "func",
            "description": "the function to call with the supplied arguments"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "the context object to set as `this` on the function call"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "rest",
            "description": "any arguments after `context` will be passed to the function call"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "return types and values are determined by the call to `func`\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "rest",
      "description": "any arguments after `context` will be passed to the function call"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "return types and values are determined by the call to `func`\n "
    }
  },
  "can-reflect/call.apply": {
    "type": "function",
    "name": "can-reflect/call.apply",
    "parent": "can-reflect/call",
    "src": {
      "line": 38,
      "codeLine": 63,
      "path": "node_modules/can-reflect/reflections/call/call.js"
    },
    "body": "",
    "description": "Call a callable, with a context object and a list of parameters \n",
    "title": "apply",
    "signatures": [
      {
        "code": "apply(func, context, args)",
        "description": "\n\nCall the callable `func` as if it were a function, bound to `context` and with any additional parameters\ncontained in the Array-like `args`\n\nNote that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@can.apply],\nor have a callable `apply` property to work with `canReflect.apply`\n\n```\nvar compute = canCompute(\"foo\");\n\ncanReflect.apply(compute, null, [\"bar\"]);\ncanReflect.apply(compute, null, []); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "variable": true
                  }
                ]
              }
            ],
            "name": "func",
            "description": "the function to call"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "the context object to set as `this` on the function call"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "arguments to be passed to the function call"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "return types and values are determined by the call to `func`\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "arguments to be passed to the function call"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "return types and values are determined by the call to `func`\n "
    }
  },
  "can-reflect/call.new": {
    "type": "function",
    "name": "can-reflect/call.new",
    "parent": "can-reflect/call",
    "src": {
      "line": 71,
      "codeLine": 92,
      "path": "node_modules/can-reflect/reflections/call/call.js"
    },
    "body": "",
    "description": "Construct a new instance of a callable constructor \n",
    "title": "new",
    "signatures": [
      {
        "code": "new(func, ...rest)",
        "description": "\n\nCall the callable `func` as if it were a function, bound to a new instance of `func`, and with any additional\nparameters occurring after `func` set to the positional parameters.\n\nNote that `func` *must* either implement [can-symbol/symbols/new @@can.new],\nor have a callable `apply` property *and* a prototype to work with `canReflect.new`\n\n```\ncanReflect.new(DefineList, [\"foo\"]); // -> [\"foo\"]<DefineList>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "variable": true
                  }
                ]
              }
            ],
            "name": "func",
            "description": "a constructor"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "rest",
            "description": "arguments to be passed to the constructor"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "if `func` returns an Object, that returned Object; otherwise a new instance of `func`\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "rest",
      "description": "arguments to be passed to the constructor"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "if `func` returns an Object, that returned Object; otherwise a new instance of `func`\n "
    }
  },
  "can-reflect/observe.onKeyValue": {
    "name": "can-reflect/observe.onKeyValue",
    "type": "function",
    "parent": "can-reflect/observe",
    "src": {
      "line": 27,
      "codeLine": 52,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "",
    "description": "Register an event handler on a MapLike object, based on a key change \n",
    "title": "onKeyValue",
    "signatures": [
      {
        "code": "onKeyValue(obj, key, handler)",
        "description": "\n\nRegister a handler on the Map-like object `obj` to trigger when the property key `key` changes.\n`obj` *must* implement [can-symbol/symbols/onKeyValue @@can.onKeyValue] to be compatible with\ncan-reflect.onKeyValue.  The function passed as `handler` will receive the new value of the property\nas the first argument, and the previous value of the property as the second argument.\n\n```\nvar obj = new DefineMap({ foo: \"bar\" });\ncanReflect.onKeyValue(obj, \"foo\", function(newVal, oldVal) {\n\tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n});\n\nobj.foo = \"baz\";  // -> logs \"foo is now baz , was bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "an observable MapLike that can listen to changes in named properties."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the key to listen to"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "a callback function that recieves the new value\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "a callback function that recieves the new value\n "
    }
  },
  "can-reflect/observe.offKeyValue": {
    "name": "can-reflect/observe.offKeyValue",
    "type": "function",
    "parent": "can-reflect/observe",
    "src": {
      "line": 53,
      "codeLine": 80,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "",
    "description": "Unregister an event handler on a MapLike object, based on a key change \n",
    "title": "offKeyValue",
    "signatures": [
      {
        "code": "offKeyValue(obj, key, handler)",
        "description": "\n\nUnregister a handler from the Map-like object `obj` that had previously been registered with\n[can-reflect/observe.onKeyValue onKeyValue]. The function passed as `handler` will no longer be called\nwhen the value of `key` on `obj` changes.\n\n```\nvar obj = new DefineMap({ foo: \"bar\" });\nvar handler = function(newVal, oldVal) {\n\tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n};\n\ncanReflect.onKeyValue(obj, \"foo\", handler);\ncanReflect.offKeyValue(obj, \"foo\", handler);\n\nobj.foo = \"baz\";  // -> nothing is logged\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "an observable MapLike that can listen to changes in named properties."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the key to stop listening to"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "the callback function that should be removed from the event handlers for `key`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "the callback function that should be removed from the event handlers for `key`\n "
    }
  },
  "can-reflect/observe.onKeys": {
    "src": {
      "line": 82,
      "codeLine": 106,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "type": "function",
    "body": "",
    "description": "Register an event handler on a MapLike object, triggered on the key set changing \n",
    "title": "onKeys",
    "name": "can-reflect/observe.onKeys",
    "parent": "can-reflect/observe",
    "signatures": [
      {
        "code": "onKeys(obj, handler)",
        "description": "\n\nRegister an event handler on the Map-like object `obj` to trigger when `obj`'s keyset changes.\n`obj` *must* implement [can-symbol/symbols/onKeys @@can.onKeys] to be compatible with\ncan-reflect.onKeys.  The function passed as `handler` will receive an Array of object diffs (see\n[can-util/js/diff-object/diff-object diffObject] for the format) as its one argument.\n\n```\nvar obj = new DefineMap({ foo: \"bar\" });\ncanReflect.onKeys(obj, function(diffs) {\n\tconsole.log(diffs);\n});\n\nobj.set(\"baz\", \"quux\");  // -> logs '[{\"property\": \"baz\", \"type\": \"add\", \"value\": \"quux\"}]'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "an observable MapLike that can listen to changes in named properties."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "the callback function to receive the diffs in the key set\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "the callback function to receive the diffs in the key set\n "
    }
  },
  "can-reflect/observe.onKeysAdded": {
    "name": "can-reflect/observe.onKeysAdded",
    "type": "function",
    "parent": "can-reflect/observe",
    "src": {
      "line": 108,
      "codeLine": 132,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "",
    "description": "Register an event handler on a MapLike object, triggered on new keys being added. \n",
    "title": "onKeysAdded",
    "signatures": [
      {
        "code": "onKeysAdded(obj, handler)",
        "description": "\n\nRegister an event handler on the Map-like object `obj` to trigger when a new key or keys are set on\n`obj`. `obj` *must* implement [can-symbol/symbols/onKeysAdded @@can.onKeysAdded] to be compatible with\ncan-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of Strings as its one\nargument.\n\n```\nvar obj = new DefineMap({ foo: \"bar\" });\ncanReflect.onKeysAded(obj, function(newKeys) {\n\tconsole.log(newKeys);\n});\n\nfoo.set(\"baz\", \"quux\");  // -> logs '[\"baz\"]'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "an observable MapLike that can listen to changes in named properties."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "the callback function to receive the array of added keys\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "the callback function to receive the array of added keys\n "
    }
  },
  "can-reflect/observe.onKeysRemoved": {
    "name": "can-reflect/observe.onKeysRemoved",
    "type": "function",
    "parent": "can-reflect/observe",
    "src": {
      "line": 134,
      "codeLine": 158,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "",
    "description": "Register an event handler on a MapLike object, triggered on keys being deleted. \n",
    "title": "onKeysRemoved",
    "signatures": [
      {
        "code": "onKeysRemoved(obj, handler)",
        "description": "\n\nRegister an event handler on the Map-like object `obj` to trigger when a key or keys are removed from\n`obj`'s keyset. `obj` *must* implement [can-symbol/symbols/onKeysRemoved @@can.onKeysRemoved] to be\ncompatible with can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of\nStrings as its one argument.\n\n```\nvar obj = new CanMap({ foo: \"bar\" });\ncanReflect.onKeys(obj, function(diffs) {\n\tconsole.log(JSON.stringify(diffs));\n});\n\nfoo.removeAttr(\"foo\");  // -> logs '[\"foo\"]'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "an observable MapLike that can listen to changes in named properties."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "the callback function to receive the array of removed keys\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "the callback function to receive the array of removed keys\n "
    }
  },
  "can-reflect/observe.getKeyDependencies": {
    "name": "can-reflect/observe.getKeyDependencies",
    "type": "function",
    "parent": "can-reflect/observe",
    "src": {
      "line": 160,
      "codeLine": 194,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "",
    "description": "Return the observable objects that compute to the value of a named property on an object \n",
    "title": "getKeyDependencies",
    "signatures": [
      {
        "code": "getKeyDependencies(obj, key)",
        "description": "\n\nReturn the observable objects that provide input values to generate the computed value of the\nproperty `key` on Map-like object `obj`.  If `key` does not have dependencies on `obj`, returns `undefined`.\nOtherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that\nmaps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a\n[can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.\n\n`obj` *must* implement [can-symbol/symbols/getKeyDependencies @@can.getKeyDependencies] to work with\n`canReflect.getKeyDependencies`.\n\n\n```\nvar foo = new DefineMap({ \"bar\": \"baz\" })\nvar obj = new (DefineMap.extend({\n\t baz: {\n\t   get: function() {\n\t     return foo.bar;\n\t   }\n\t }\n}))();\n\ncanReflect.getKeyDependencies(obj, \"baz\");  // -> { valueDependencies: CIDSet }\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to check for key dependencies"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the key on the object to check"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "the observable values that this keyed value depends on\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "the key on the object to check"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "the observable values that this keyed value depends on\n "
    }
  },
  "can-reflect/observe.keyHasDependencies": {
    "name": "can-reflect/observe.keyHasDependencies",
    "type": "function",
    "parent": "can-reflect/observe",
    "src": {
      "line": 196,
      "codeLine": 235,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "",
    "description": "Determine whether the value for a named property on an object is bound to other events \n",
    "title": "keyHasDependencies",
    "signatures": [
      {
        "code": "keyHasDependencies(obj, key)",
        "description": "\n\nReturns `true` if the computed value of the property `key` on Map-like object `obj` derives from other values.\nReturns `false` if `key` is computed on `obj` but does not have dependencies on other objects. If `key` is not\na computed value on `obj`, returns `undefined`.\n\n`obj` *must* implement [can-symbol/symbols/keyHasDependencies @@can.keyHasDependencies] to work with\n`canReflect.keyHasDependencies`.\n\n```\nvar foo = new DefineMap({ \"bar\": \"baz\" })\nvar obj = new (DefineMap.extend({\n\t baz: {\n\t   get: function() {\n\t     return foo.bar;\n\t   }\n\t },\n\t quux: {\n\t \t get: function() {\n\t \t   return \"thud\";\n\t \t }\n\t }\n}))();\n\ncanReflect.keyHasDependencies(obj, \"baz\");  // -> true\ncanReflect.keyHasDependencies(obj, \"quux\");  // -> false\ncanReflect.keyHasDependencies(foo, \"bar\");  // -> undefined\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to check for key dependencies"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the key on the object to check"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if there are other objects that may update the keyed value; `false` otherwise\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "the key on the object to check"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if there are other objects that may update the keyed value; `false` otherwise\n\n "
    }
  },
  "can-reflect/observe.onValue": {
    "name": "can-reflect/observe.onValue",
    "type": "function",
    "parent": "can-reflect/observe",
    "src": {
      "line": 239,
      "codeLine": 263,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "",
    "description": "Register an event handler on an observable ValueLike object, based on a change in its value \n",
    "title": "onValue",
    "signatures": [
      {
        "code": "onValue(handler)",
        "description": "\n\nRegister an event handler on the Value-like object `obj` to trigger when its value changes.\n`obj` *must* implement [can-symbol/symbols/onValue @@can.onValue] to be compatible with\ncan-reflect.onKeyValue.  The function passed as `handler` will receive the new value of `obj`\nas the first argument, and the previous value of `obj` as the second argument.\n\n```\nvar obj = canCompute(\"foo\");\ncanReflect.onValue(obj, function(newVal, oldVal) {\n\tconsole.log(\"compute is now\", newVal, \", was\", oldVal);\n});\n\nobj(\"bar\");  // -> logs \"compute is now bar , was foo\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "any object implementing @@can.onValue"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "a callback function that receives the new and old values\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "a callback function that receives the new and old values\n "
    }
  },
  "can-reflect/observe.offValue": {
    "name": "can-reflect/observe.offValue",
    "type": "function",
    "parent": "can-reflect/observe",
    "src": {
      "line": 402,
      "codeLine": 429,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "",
    "description": "Unregister an event handler on a MapLike object, based on a key change \n",
    "title": "offEvent",
    "signatures": [
      {
        "code": "offKeyValue(obj, eventName, callback)",
        "description": "\n\nUnregister an event handler from the object `obj` that had previously been registered with\n[can-reflect/observe.onEvent onEvent]. The function passed as `callback` will no longer be called\nwhen the event named `eventName` is dispatched on `obj`.\n\n```\nvar obj = new DefineMap({ foo: \"bar\" });\nvar handler = function(ev, newVal, oldVal) {\n\tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n};\n\ncanReflect.onEvent(obj, \"foo\", handler);\ncanReflect.offKeyValue(obj, \"foo\", handler);\n\ncanEvent.dispatch.call(obj, \"foo\", [\"baz\", \"quux\"]);  // -> nothing is logged\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to unbind an event handler from"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "the name of the event to unbind the handler from"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the handler function to unbind from the event\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the handler function to unbind from the event\n "
    }
  },
  "can-reflect/observe.getValueDependencies": {
    "name": "can-reflect/observe.getValueDependencies",
    "type": "function",
    "parent": "can-reflect/observe",
    "src": {
      "line": 292,
      "codeLine": 323,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "",
    "description": "Return all the events that bind to the value of an observable, Value-like object \n",
    "title": "getValueDependencies",
    "signatures": [
      {
        "code": "getValueDependencies(obj)",
        "description": "\n\nReturn the observable objects that provide input values to generate the computed value of the\nValue-like object `obj`.  If `obj` does not have dependencies, returns `undefined`.\nOtherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that\nmaps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a\n[can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.\n\n`obj` *must* implement [can-symbol/symbols/getValueDependencies @@can.getValueDependencies] to work with\n`canReflect.getValueDependencies`.\n\n\n```\nvar foo = new DefineMap({ \"bar\": \"baz\" })\nvar obj = canCompute(function() {\n\t return foo.bar;\n});\n\ncanReflect.getValueDependencies(obj);  // -> { valueDependencies: CIDSet } because `obj` is internally backed by\na [can-observation]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to check for value dependencies"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "the observable objects that `obj`'s value depends on\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "the object to check for value dependencies"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "the observable objects that `obj`'s value depends on\n\n "
    }
  },
  "can-reflect/observe.valueHasDependencies": {
    "name": "can-reflect/observe.valueHasDependencies",
    "type": "function",
    "parent": "can-reflect/observe",
    "src": {
      "line": 325,
      "codeLine": 361,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "",
    "description": "Determine whether the value of an observable object is bound to other events \n",
    "title": "valueHasDependencies",
    "signatures": [
      {
        "code": "valueHasDependencies(obj)",
        "description": "\n\nReturns `true` if the computed value of the Value-like object `obj` derives from other values.\nReturns `false` if `obj` is computed but does not have dependencies on other objects. If `obj` is not\na computed value, returns `undefined`.\n\n`obj` *must* implement [can-symbol/symbols/valueHasDependencies @@can.valueHasDependencies] to work with\n`canReflect.valueHasDependencies`.\n\n```\nvar foo = canCompute( \"bar\" );\nvar baz = canCompute(function() {\n\t return foo();\n});\nvar quux = \"thud\";\nvar jeek = canCompute(function(plonk) {\n\t if(argument.length) {\n\t \t  quux = plonk;\n\t }\n\t return quux;\n});\n\ncanReflect.valueHasDependencies(baz);  // -> true\ncanReflect.valueHasDependencies(jeek);  // -> false\ncanReflect.valueHasDependencies(foo);  // -> undefined\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to check for dependencies"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if there are other dependencies that may update the object's value; `false` otherwise\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "the object to check for dependencies"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if there are other dependencies that may update the object's value; `false` otherwise\n\n "
    }
  },
  "can-reflect/observe.onEvent": {
    "type": "function",
    "name": "can-reflect/observe.onEvent",
    "parent": "can-reflect/observe",
    "src": {
      "line": 366,
      "codeLine": 392,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "",
    "description": "Register a named event handler on an observable object \n",
    "title": "onEvent",
    "signatures": [
      {
        "code": "onEvent(obj, eventName, callback)",
        "description": "\n\n\nRegister an event handler on the object `obj` to trigger when the event `eventName` is dispatched.\n`obj` *must* implement [can-symbol/symbols/onKeyValue @@can.onEvent] or `.addEventListener()` to be compatible\nwith can-reflect.onKeyValue.  The function passed as `callback` will receive the event descriptor as the first\nargument, and any data passed to the event dispatch as subsequent arguments.\n\n```\nvar obj = new DefineMap({ foo: \"bar\" });\ncanReflect.onEvent(obj, \"foo\", function(ev, newVal, oldVal) {\n\tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n});\n\ncanEvent.dispatch.call(obj, \"foo\", [\"baz\", \"quux\"]);  // -> logs \"foo is now baz , was quux\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to bind a new event handler to"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "the name of the event to bind the handler to"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the handler function to bind to the event\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the handler function to bind to the event\n "
    }
  },
  "can-reflect/setPriority": {
    "type": "function",
    "name": "can-reflect/setPriority",
    "parent": "can-reflect/observe",
    "src": {
      "line": 440,
      "codeLine": 499,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "\n## Use\n\nThere's often a need to specify the order of re-evaluation for\n__observables__ that derive (or compute) their value from other observables.\n\nThis is needed by templates to avoid unnecessary re-evaluation.  Say we had the following template:\n\n```js\n{{#if value}}\n  {{value}}\n{{/if}}\n```\n\nIf `value` became falsey, we'd want the `{{#if}}` to be aware of it before\nthe `{{value}}` magic tags updated. We can do that by setting priorities:\n\n```js\ncanReflect.setPriority(magicIfObservable, 0);\ncanReflect.setPriority(magicValueObservable,1);\n```\n\nInternally, those observables will use that `priority` to register their\nre-evaluation with the `derive` queue in [can-queues].\n\n \n",
    "description": "Provide a priority for when an observable that derives its value should be re-evaluated.\n\n",
    "title": "setPriority",
    "signatures": [
      {
        "code": "setPriority(obj, priority)",
        "description": "\n\nCalls an underlying `@can.setPriority` symbol on `obj` if it exists with `priorty`.\nReturns `true` if a priority was set, `false` if otherwise.\n\nLower priorities (`0` being the lowest), will be an indication to run earlier than\nhigher priorities.\n\n```js\nvar obj = canReflect.assignSymbols({},{\n  \"can.setPriority\": function(priority){\n    return this.priority = priority;\n  }\n});\n\ncanReflect.setPriority(obj, 0) //-> true\nobj.priority //-> 0\n\ncanReflect.setPriority({},20) //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An observable that will update its priority."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "priority",
            "description": "The priority number.  Lower priorities (`0` being the lowest),\nindicate to run earlier than higher priorities."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if a priority was able to be set, `false` if otherwise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "priority",
      "description": "The priority number.  Lower priorities (`0` being the lowest),\nindicate to run earlier than higher priorities."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if a priority was able to be set, `false` if otherwise.\n"
    },
    "comment": " "
  },
  "can-reflect/getPriority": {
    "type": "function",
    "name": "can-reflect/getPriority",
    "parent": "can-reflect/observe",
    "src": {
      "line": 509,
      "codeLine": 530,
      "path": "node_modules/can-reflect/reflections/observe/observe.js"
    },
    "body": "\n \n",
    "description": "Read the priority for an observable that derives its value.\n\n",
    "title": "getPriority",
    "signatures": [
      {
        "code": "getPriority(obj)",
        "description": "\n\nCalls an underlying `@can.getPriority` symbol on `obj` if it exists\nand returns its value. Read [can-reflect/setPriority] for more information.\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An observable."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Undefined"
            },
            {
              "type": "Number"
            }
          ],
          "description": "Returns the priority number if\navailable, undefined if this object does not support the `can.getPriority`\nsymbol.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An observable."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Undefined"
        },
        {
          "type": "Number"
        }
      ],
      "description": "Returns the priority number if\navailable, undefined if this object does not support the `can.getPriority`\nsymbol.\n"
    },
    "comment": " "
  },
  "can-reflect/shape.each": {
    "type": "function",
    "name": "can-reflect/shape.each",
    "parent": "can-reflect/shape",
    "src": {
      "line": 220,
      "codeLine": 247,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Iterate a List-like or Map-like, calling `callback` on each keyed or indexed property \n",
    "title": "each",
    "signatures": [
      {
        "code": "each(obj, callback, context)",
        "description": "\n\nIf `obj` is a List-like or an Iterator-like, `each` functions as [can-reflect/shape.eachIndex eachIndex],\niterating over numeric indexes from 0 to `obj.length - 1` and calling `callback` with each property and\nindex, optionally with `context` as `this` (defaulting to `obj`).  If not, `each` functions as\n[can-reflect/shape.eachKey eachKey],\niterating over every key on `obj` and calling `callback` on each one.\n\n```\nvar foo = new DefineMap({ bar: \"baz\" });\nvar quux = new DefineList([ \"thud\", \"jeek\" ]);\n\ncanReflect.each(foo, console.log, console); // -> logs 'baz bar {foo}'\ncanReflect.each(quux, console.log, console); // -> logs 'thud 0 {quux}'; logs 'jeek 1 {quux}'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "The object to iterate over"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "ValueLike"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "a function that receives each item in the ListLike or MapLike"
          },
          {
            "types": [
              {
                "type": "["
              }
            ],
            "name": "context",
            "description": "an optional `this` context for calling the callback"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the result of calling [can-reflect/shape.eachIndex `eachIndex`] if `obj` is a ListLike,\nor [can-reflect/shape.eachKey `eachKey`] if a MapLike.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "["
        }
      ],
      "name": "context",
      "description": "an optional `this` context for calling the callback"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the result of calling [can-reflect/shape.eachIndex `eachIndex`] if `obj` is a ListLike,\nor [can-reflect/shape.eachKey `eachKey`] if a MapLike.\n "
    }
  },
  "can-reflect/shape.eachIndex": {
    "type": "function",
    "name": "can-reflect/shape.eachIndex",
    "parent": "can-reflect/shape",
    "src": {
      "line": 257,
      "codeLine": 279,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Iterate a ListLike calling `callback` on each numerically indexed element \n",
    "title": "eachIndex",
    "signatures": [
      {
        "code": "eachIndex(list, callback, context)",
        "description": "\n\nFor each numeric index from 0 to `list.length - 1`, call `callback`, passing the current\nproperty value, the current index, and `list`, and optionally setting `this` as `context`\nif specified (otherwise use the current property value).\n\n```\nvar foo = new DefineList([ \"bar\", \"baz\" ]);\n\ncanReflect.eachIndex(foo, console.log, console); // -> logs 'bar 0 {foo}'; logs 'baz 1 {foo}'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "ListLike"
              }
            ],
            "name": "list",
            "description": "The list to iterate over"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "a function that receives each item"
          },
          {
            "types": [
              {
                "type": "["
              }
            ],
            "name": "context",
            "description": "an optional `this` context for calling the callback"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "ListLike"
            }
          ],
          "description": "the original list\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "["
        }
      ],
      "name": "context",
      "description": "an optional `this` context for calling the callback"
    },
    "_curReturn": {
      "types": [
        {
          "type": "ListLike"
        }
      ],
      "description": "the original list\n "
    }
  },
  "can-reflect/shape.toArray": {
    "type": "function",
    "name": "can-reflect/shape.toArray",
    "parent": "can-reflect/shape",
    "src": {
      "line": 327,
      "codeLine": 348,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "convert the values of any MapLike or ListLike into an array \n",
    "title": "toArray",
    "signatures": [
      {
        "code": "toArray(obj)",
        "description": "\n\nConvert the values of any Map-like or List-like into a JavaScript Array.  If a Map-like,\nkey data is discarded and only value data is preserved.\n\n```\nvar foo = new DefineList([\"bar\", \"baz\"]);\nvar quux = new DefineMap({ thud: \"jeek\" });\n```\n\ncanReflect.toArray(foo); // -> [\"bar\", \"baz\"]\ncanReflect.toArray(quux): // -> [\"jeek\"]\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "Any object, whether MapLike or ListLike"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "an array of the values of `obj`\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "Any object, whether MapLike or ListLike"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "an array of the values of `obj`\n "
    }
  },
  "can-reflect/shape.eachKey": {
    "type": "function",
    "name": "can-reflect/shape.eachKey",
    "parent": "can-reflect/shape",
    "src": {
      "line": 355,
      "codeLine": 378,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Iterate over a MapLike, calling `callback` on each enumerable property \n",
    "title": "eachKey",
    "signatures": [
      {
        "code": "eachKey(obj, callback, context)",
        "description": "\n\nIterate all own enumerable properties on Map-like `obj`\n(using [can-reflect/shape/getOwnEnumerableKeys canReflect.getOwnEnumerableKeys]), and call\n`callback` with the property value, the property key, and `obj`, and optionally setting\n`this` on the callback as `context` if provided, `obj` otherwise.\n\n```\nvar foo = new DefineMap({ bar: \"baz\" });\n\ncanReflect.eachKey(foo, console.log, console); // logs 'baz bar {foo}'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "The object to iterate over"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "The callback to call on each enumerable property value"
          },
          {
            "types": [
              {
                "type": "["
              }
            ],
            "name": "context",
            "description": "an optional `this` context for calling `callback`"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the enumerable keys of `obj` as an Array\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "["
        }
      ],
      "name": "context",
      "description": "an optional `this` context for calling `callback`"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the enumerable keys of `obj` as an Array\n "
    }
  },
  "can-reflect/shape.hasOwnKey": {
    "type": "function",
    "name": "can-reflect/shape.hasOwnKey",
    "parent": "can-reflect/shape",
    "src": {
      "line": 394,
      "codeLine": 419,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Determine whether an object contains a key on itself, not only on its prototype chain \n",
    "title": "hasOwnKey",
    "signatures": [
      {
        "code": "hasOwnKey(obj, key)",
        "description": "\n\nReturn `true` if an object's own properties include the property key `key`, `false` otherwise.\nAn object may implement [can-symbol/symbols/hasOwnKey @@can.hasOWnKey] to override default behavior.\nBy default, `canReflect.hasOwnKey` will first look for\n[can-symbol/symbols/getOwnKey @@can.getOwnKey] on `obj`. If present, it will call `@@can.getOwnKey` and\ntest `key` against the returned Array of keys.  If absent, `Object.prototype.hasOwnKey()` is used.\n\n```\nvar foo = new DefineMap({ \"bar\": \"baz\" });\n\ncanReflect.hasOwnKey(foo, \"bar\"); // -> true\ncanReflect.hasOwnKey(foo, \"each\"); // -> false\nfoo.each // -> function each() {...}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "Any MapLike object"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key to look up on `obj`"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `obj`'s key set contains `key`, `false` otherwise\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key to look up on `obj`"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `obj`'s key set contains `key`, `false` otherwise\n "
    }
  },
  "can-reflect/shape.getOwnEnumerableKeys": {
    "type": "function",
    "name": "can-reflect/shape.getOwnEnumerableKeys",
    "parent": "can-reflect/shape",
    "src": {
      "line": 439,
      "codeLine": 471,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Return the list of keys which can be iterated over on an object \n",
    "title": "getOwnEnumerableKeys",
    "signatures": [
      {
        "code": "getOwnEnumerableKeys(obj)",
        "description": "\n\nReturn all keys on `obj` which have been defined as enumerable, either from explicitly setting\n`enumerable` on the property descriptor, or by using `=` to set the value of the property without\na key descriptor, but excluding properties that only exist on `obj`'s prototype chaing.  The\ndefault behavior can be overridden by implementing\n[can-symbol/symbols/getOwnEnumerableKeys @@can.getOwnEnumerableKeys] on `obj`.  By default,\n`canReflect.getOwnEnumerableKeys` will use [can-symbol/symbols/getOwnKeys @@can.getOwnKeys] to\nretrieve the set of keys and [can-symbol/symbols/getOwnKeyDescriptor @@can.getOwnKeyDescriptor]\nto filter for those which are enumerable.  If either symbol is absent from `obj`, `Object.keys`\nis used.\n\n```\nvar foo = new DefineMap({ bar: \"baz\", [canSymbol.for(\"quux\")]: \"thud\" });\nObject.defineProperty(foo, \"jeek\", {\n  enumerable: true,\n  value: \"plonk\"\n});\n\ncanReflect.getOwnEnumerableKeys(foo); // -> [\"bar\", \"jeek\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "Any Map-like object"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the Array of all enumerable keys from the object, either using\n[can-symbol/symbols/getOwnEnumerableKeys `@@can.getOwnEnumerableKeys`] from `obj`, or filtering\n`obj`'s own keys for those which are enumerable.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "Any Map-like object"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the Array of all enumerable keys from the object, either using\n[can-symbol/symbols/getOwnEnumerableKeys `@@can.getOwnEnumerableKeys`] from `obj`, or filtering\n`obj`'s own keys for those which are enumerable.\n "
    }
  },
  "can-reflect/shape.getOwnKeys": {
    "type": "function",
    "name": "can-reflect/shape.getOwnKeys",
    "parent": "can-reflect/shape",
    "src": {
      "line": 507,
      "codeLine": 531,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Return the list of keys on an object, whether or not they can be iterated over \n",
    "title": "getOwnKeys",
    "signatures": [
      {
        "code": "getOwnKeys(obj)",
        "description": "\n\nReturn the Array of all String (not Symbol) keys from `obj`, whether they are enumerable or not.  If\n[can-symbol/symbols/getOwnKeys @@can.getOwnKeys] exists on `obj`, it is called to return\nthe keys; otherwise, `Object.getOwnPropertyNames()` is used.\n\n```\nvar foo = new DefineMap({ bar: \"baz\", [canSymbol.for(\"quux\")]: \"thud\" });\nObject.defineProperty(foo, \"jeek\", {\n  enumerable: false,\n  value: \"plonk\"\n});\n\ncanReflect.getOwnKeys(foo); // -> [\"bar\", \"jeek\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "Any MapLike object"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the Array of all String keys from the object.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "Any MapLike object"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the Array of all String keys from the object.\n "
    }
  },
  "can-reflect/shape.getOwnKeyDescriptor": {
    "type": "function",
    "name": "can-reflect/shape.getOwnKeyDescriptor",
    "parent": "can-reflect/shape",
    "src": {
      "line": 540,
      "codeLine": 564,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Return a property descriptor for a named property on an object. \n",
    "title": "getOwnKeyDescriptor",
    "signatures": [
      {
        "code": "getOwnKeyDescriptor(obj, key)",
        "description": "\n\nReturn the key descriptor for the property key `key` on the Map-like object `obj`. A key descriptor\nis specified in ECMAScript 5 and contains keys for the property's `configurable` and `enumerable` states,\nas well as either `value` and `writable` for value properties, or `get` and `set` for getter/setter properties.\n\nThe default behavior can be overridden by implementing [can-symbol/symbols/getOwnKeyDescriptor @@can.getOwnKeyDescriptor]\non `obj`; otherwise the default is to call `Object.getOwnKeyDescriptor()`.\n\n```\nvar foo = new DefineMap({ bar: \"baz\" });\n\ngetOwnKeyDescriptor(foo, \"bar\"); // -> {configurable: true, writable: true, enumerable: true, value: \"baz\"}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "Any object with named properties"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The property name to look up on `obj`"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A key descriptor object\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The property name to look up on `obj`"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A key descriptor object\n "
    }
  },
  "can-reflect/shape.assign": {
    "type": "function",
    "name": "can-reflect/shape.assign",
    "parent": "can-reflect/shape",
    "src": {
      "line": 594,
      "codeLine": 627,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Assign one objects values to another \n",
    "title": "assign",
    "signatures": [
      {
        "code": ".assign(target, source)",
        "description": "\n\nCopies the values (and properties if map-like) from `source` onto `target`.\n\nFor map-like objects, every enumerable property on `target` is copied:\n\n```js\nvar target = {};\nvar source = {key : \"value\"};\nvar restult = canReflect.assign(target, source);\nresult === target //-> true\ntarget //-> {key : \"value\"}\n```\n\nFor Arrays, enumerated values are copied over, but the length of the array will not be\ntrunkated.  Use [can-reflect.update] for trunkating.\n\n```js\nvar target = [\"a\",\"b\",\"c\"];\nvar source = [\"A\",\"B\"];\ncanReflect.assign(target, source);\ntarget //-> [\"A\",\"B\",\"c\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The value that will be updated with `source`'s values."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "A source of values to copy to `target`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The target.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "A source of values to copy to `target`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The target.\n "
    }
  },
  "can-reflect/shape.assignDeep": {
    "type": "function",
    "name": "can-reflect/shape.assignDeep",
    "parent": "can-reflect/shape",
    "src": {
      "line": 664,
      "codeLine": 689,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Assign one objects values to another, and performs the same action for all child values. \n",
    "title": "assignDeep",
    "signatures": [
      {
        "code": ".assignDeep(target, source)",
        "description": "\n\nCopies the values (and properties if map-like) from `source` onto `target` and repeates for all child\nvalues.\n\nFor map-like objects, every enumerable property on `target` is copied:\n\n```js\nvar target = {name: {first: \"Justin\"}};\nvar source = {name: {last: \"Meyer\"}};\nvar restult = canReflect.assignDeep(target, source);\ntarget //->  {name: {first: \"Justin\", last: \"Meyer\"}}\n```\n\nAn object can control the behavior of `assignDeep` using the [can-symbol/symbols/assignDeep] symbol.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The value that will be updated with `source`'s values."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "A source of values to copy to `target`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The target.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "A source of values to copy to `target`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The target.\n "
    }
  },
  "can-reflect/shape.update": {
    "type": "function",
    "name": "can-reflect/shape.update",
    "parent": "can-reflect/shape",
    "src": {
      "line": 736,
      "codeLine": 768,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Updates the values of an object match the values of an other object. \n",
    "title": "update",
    "signatures": [
      {
        "code": ".update(target, source)",
        "description": "\n\nUpdates the values (and properties if map-like) of `target` to match the values of `source`. This does\nnot recursively update.  For that, use [can-reflect/shape.updateDeep].\n\nFor map-like objects, every enumerable property on `target` is copied:\n\n```js\nvar target = {name: {first: \"Justin\"}, age: 34};\nvar source = {name: {last: \"Meyer\"}};\nvar restult = canReflect.assignDeep(target, source);\ntarget //->  {name: {last: \"Meyer\"}}\n```\n\nWith Arrays all items of the source will be replaced with the new items.\n\n```js\nvar target = [\"a\",\"b\",\"c\"];\nvar source = [\"A\",\"B\"];\ncanReflect.assign(target, source);\ntarget //-> [\"A\",\"B\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The value that will be updated with `source`'s values."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "A source of values to copy to `target`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The target.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "A source of values to copy to `target`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The target.\n "
    }
  },
  "can-reflect/shape.updateDeep": {
    "type": "function",
    "name": "can-reflect/shape.updateDeep",
    "parent": "can-reflect/shape",
    "src": {
      "line": 811,
      "codeLine": 837,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Makes the values of an object match the values of an other object including all children values. \n",
    "title": "updateDeep",
    "signatures": [
      {
        "code": ".updateDeep(target, source)",
        "description": "\n\nUpdates the values (and properties if map-like) of `target` to match the values of `source`.\n\nFor map-like objects, every enumerable property on `target` is copied:\n\n```js\nvar target = {name: {first: \"Justin\"}, age: 34};\nvar source = {name: {last: \"Meyer\"}};\nvar restult = canReflect.assignDeep(target, source);\ntarget //->  {name: {last: \"Meyer\"}}\n```\n\nAn object can control the behavior of `assignDeep` using the [can-symbol/symbols/updateDeep] symbol.\n\nFor list-like objects, a diff and patch strategy is used.  This attempts to limit the number of changes.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The value that will be updated with `source`'s values."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "A source of values to copy to `target`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The target.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "A source of values to copy to `target`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The target.\n "
    }
  },
  "can-reflect/shape.assignSymbols": {
    "type": "function",
    "name": "can-reflect/shape.assignSymbols",
    "parent": "can-reflect/shape",
    "src": {
      "line": 854,
      "codeLine": 886,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Assign well known symbols and values to an object. \n",
    "title": "assignSymbols",
    "signatures": [
      {
        "code": ".assignSymbols(target, source)",
        "description": "\n\nConverts each property name on the `source` object to a [can-symbol.for well known symbol]\nand uses that symbol to set the corresponding value on target.\n\nThis is used to easily set symbols correctly even when symbol isn't natively supported.\n\n```js\ncanReflect.assignSymbols(Map.prototype, {\n  \"can.getKeyValue\": Map.prototype.get\n})\n```\n\nIf a `source` property name matches a symbol on `Symbol` (like `iterator` on `Symbol.iterator`),\nthat symbol will be used:\n\n```js\ncanReflect.assignSymbols(ArrayLike.prototype, {\n  \"iterator\": function() { ... }\n})\nArrayLike.prototype[Symbol.iterator] = function(){ ... }\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The value that will be updated with `source`'s symbols and values."
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "name"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "value"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "source",
            "description": "A source of symbol names and values to copy to `target`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The target.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "name"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "value"
                }
              ]
            }
          ]
        }
      ],
      "name": "source",
      "description": "A source of symbol names and values to copy to `target`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The target.\n "
    }
  },
  "can-reflect/shape.size": {
    "type": "function",
    "name": "can-reflect/shape.size",
    "parent": "can-reflect/shape",
    "src": {
      "line": 894,
      "codeLine": 924,
      "path": "node_modules/can-reflect/reflections/shape/shape.js"
    },
    "body": "",
    "description": "Return the number of items in the collection. \n",
    "title": "size",
    "signatures": [
      {
        "code": ".size(target)",
        "description": "\n\nReturns the number of items contained in `target`. Target can\nprovide the size using the [can-symbol/symbols/size] symbol.\n\nIf the `target` has a numeric `length` property that is greater than or equal to 0, that\n`length` will be returned.\n\n```js\ncanReflect.size([1,2,3]) //-> 3\n```\n\nIf the `target` is [can-reflect.isListLike], the values of the list will be counted.\n\nIf the `target` is a plain JS object, the number of enumerable properties will be returned.\n\n```js\ncanReflect.size({foo:\"bar\"}) //-> 1\n```\n\nIf the `target` is anything else, `undefined` is returned.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The container object."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of values in the target.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "target",
      "description": "The container object."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of values in the target.\n "
    }
  },
  "can-reflect.setName": {
    "type": "function",
    "name": "can-reflect.setName",
    "parent": "can-reflect/shape",
    "src": {
      "line": 5,
      "codeLine": 22,
      "path": "node_modules/can-reflect/reflections/get-name/get-name.js"
    },
    "body": "",
    "description": "Set a human-readable name of an object. \n",
    "title": "setName",
    "signatures": [
      {
        "code": "setName(obj, value)",
        "description": "\n\n```\nvar f = function() {};\n\ncanReflect.setName(f, \"myFunction\")\nf.name //-> \"myFunction\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to set on"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "the value to set for the object\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "the value to set for the object\n"
    }
  },
  "can-reflect.getName": {
    "type": "function",
    "name": "can-reflect.getName",
    "parent": "can-reflect/shape",
    "src": {
      "line": 35,
      "codeLine": 51,
      "path": "node_modules/can-reflect/reflections/get-name/get-name.js"
    },
    "body": "",
    "description": "Get the name of an object. \n",
    "title": "getName",
    "signatures": [
      {
        "code": "getValue(obj)",
        "description": "\n\n```\nvar map = new DefineMap();\n\ncanReflect.getName(map); //-> \"DefineMap{}\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to get from"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The human-readable name of the object\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "the object to get from"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The human-readable name of the object\n"
    }
  },
  "can-reflect.setKeyValue": {
    "type": "function",
    "name": "can-reflect.setKeyValue",
    "parent": "can-reflect/get-set",
    "src": {
      "line": 9,
      "codeLine": 30,
      "path": "node_modules/can-reflect/reflections/get-set/get-set.js"
    },
    "body": "",
    "description": "Set the value of a named property on a MapLike object. \n",
    "title": "setKeyValue",
    "signatures": [
      {
        "code": "setKeyValue(obj, key, value)",
        "description": "\n\nSet the property on Map-like `obj`, identified by the String, Symbol or Object value `key`, to the value `value`.\nThe default behavior can be overridden on `obj` by implementing [can-symbol/symbols/setKeyValue @@can.setKeyValue],\notherwise native named property access is used for string keys, and `Object.defineProperty` is used to set symbols.\n\n```\nvar foo = new DefineMap({ bar: \"baz\" });\n\ncanReflect.setKeyValue(foo, \"bar\", \"quux\");\nfoo[bar]; // -> \"quux\"\n```",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to set on"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the key for the property to set"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "the value to set on the object\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "the value to set on the object\n "
    }
  },
  "can-reflect.getKeyValue": {
    "type": "function",
    "name": "can-reflect.getKeyValue",
    "parent": "can-reflect/get-set",
    "src": {
      "line": 51,
      "codeLine": 71,
      "path": "node_modules/can-reflect/reflections/get-set/get-set.js"
    },
    "body": "",
    "description": "Get the value of a named property on a MapLike object. \n",
    "title": "getKeyValue",
    "signatures": [
      {
        "code": "getKeyValue(obj, key)",
        "description": "\n\nRetrieve the property on Map-like `obj` identified by the String or Symbol value `key`.  The default behavior\ncan be overridden on `obj` by implementing [can-symbol/symbols/getKeyValue @@can.getKeyValue],\notherwise native named property access is used.\n\n```\nvar foo = new DefineMap({ bar: \"baz\" });\n\ncanReflect.getKeyValue(foo, \"bar\"); // -> \"baz\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to get from"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the key of the property to get\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "the key of the property to get\n "
    }
  },
  "can-reflect.deleteKeyValue": {
    "type": "function",
    "name": "can-reflect.deleteKeyValue",
    "parent": "can-reflect/get-set",
    "src": {
      "line": 78,
      "codeLine": 107,
      "path": "node_modules/can-reflect/reflections/get-set/get-set.js"
    },
    "body": "",
    "description": "Delete a named property from a MapLike object. \n",
    "title": "deleteKeyValue",
    "signatures": [
      {
        "code": "deleteKeyValue(obj, key)",
        "description": "\n\nRemove the property identified by the String or Symbol `key` from the Map-like object `obj`, if possible.\nProperty definitions may interfere with deleting key values; the behavior on `obj` if `obj[key]` cannot\nbe deleted is undefined.  The default use of the native `delete` keyword can be overridden by `obj` if it\nimplements [can-symbol/symbols/deleteKeyValue @@can.deleteKeyValue].\n\n```\nvar foo = new DefineMap({ bar: \"baz\" });\nvar quux = new CanMap({ thud: \"jeek\" });\n\ncanReflect.deleteKeyValue(foo, \"bar\");\ncanReflect.deleteKeyValue(quux, \"thud\");\n\n\"bar\" in foo; // ->  true  -- DefineMaps use property defs which cannot be un-defined\nfoo.bar // -> undefined    --  but set values to undefined when deleting\n\n\"thud\" in quux; // -> false\nquux.thud; // -> undefined\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to delete on"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the key for the property to delete\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "the key for the property to delete\n "
    }
  },
  "can-reflect.getValue": {
    "type": "function",
    "name": "can-reflect.getValue",
    "parent": "can-reflect/get-set",
    "src": {
      "line": 114,
      "codeLine": 137,
      "path": "node_modules/can-reflect/reflections/get-set/get-set.js"
    },
    "body": "",
    "description": "Get the value of an object with a gettable value \n",
    "title": "getValue",
    "signatures": [
      {
        "code": "getValue(obj)",
        "description": "\n\nReturn the value of the Value-like object `obj`.  Unless `obj` implements\n[can-symbol/symbols/getValue @@can.getValue], the result of `getValue` on\n`obj` will always be `obj`.  Observable Map-like objects may want to implement\n`@@can.getValue` to return non-observable or plain representations of themselves.\n\n```\nvar compute = canCompute(\"foo\");\nvar primitive = \"bar\";\n\ncanReflect.getValue(compute); // -> \"foo\"\ncanReflect.getValue(primitive); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to get from"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value of the object via `@@can.getValue`, or the value itself.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "the object to get from"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value of the object via `@@can.getValue`, or the value itself.\n "
    }
  },
  "can-reflect.setValue": {
    "type": "function",
    "name": "can-reflect.setValue",
    "parent": "can-reflect/get-set",
    "src": {
      "line": 147,
      "codeLine": 172,
      "path": "node_modules/can-reflect/reflections/get-set/get-set.js"
    },
    "body": "",
    "description": "Set the value of a mutable object. \n",
    "title": "setValue",
    "signatures": [
      {
        "code": "setValue(obj, value)",
        "description": "\n\nSet the value of a Value-like object `obj` to the value `value`.  `obj` *must* implement\n[can-symbol/symbols/setValue @@can.setValue] to be used with `canReflect.setValue`.\nMap-like objects may want to implement `@@can.setValue` to merge objects of properties\ninto themselves.\n\n```\nvar compute = canCompute(\"foo\");\nvar plain = {};\n\ncanReflect.setValue(compute, \"bar\");\ncompute(); // -> bar\n\ncanReflect.setValue(plain, { quux: \"thud\" }); // throws \"can-reflect.setValue - Can not set value.\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to set on"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "the value to set for the object\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "the value to set for the object\n "
    }
  },
  "can-reflect.get": {
    "name": "can-reflect.get",
    "type": "function",
    "parent": "node_modules/can-reflect/reflections/get-set/get-set.js",
    "src": {
      "line": 226,
      "codeLine": 231,
      "path": "node_modules/can-reflect/reflections/get-set/get-set.js"
    },
    "body": "",
    "description": "an alias for [can-reflect.getKeyValue getKeyValue] \n",
    "title": "get",
    "hide": true
  },
  "can-reflect.set": {
    "name": "can-reflect.set",
    "type": "function",
    "parent": "node_modules/can-reflect/reflections/get-set/get-set.js",
    "src": {
      "line": 232,
      "codeLine": 237,
      "path": "node_modules/can-reflect/reflections/get-set/get-set.js"
    },
    "body": "",
    "description": "an alias for [can-reflect.setKeyValue setKeyValue] \n",
    "title": "set",
    "hide": true
  },
  "can-reflect.delete": {
    "src": {
      "line": 238,
      "codeLine": 243,
      "path": "node_modules/can-reflect/reflections/get-set/get-set.js"
    },
    "type": "function",
    "body": "",
    "description": "an alias for [can-reflect.deleteKeyValue deleteKeyValue] \n",
    "title": "delete",
    "name": "can-reflect.delete",
    "hide": true
  },
  "can-stache/expressions/bracket": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/bracket.md"
    },
    "body": "\n## Use\n\nA bracket expression can be used to look up a dynamic property in the [can-view-scope scope]. This looks like:\n\n```\nTemplate:\n\t<h1>{{[key]}}</h1>\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tname: \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nThis can be useful for looking up values using keys containing non-alphabetic characters:\n\n```\nTemplate:\n\t<h1>{{[\"person:name\"]}}</h1>\n\nData:\n\t{\n\t\t\"person:name\": \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nBracket expressions can also be used to look up a value in the result of another expression:\n\n```\nTemplate:\n{{getPerson()[key]}}\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tgetPerson: function() {\n\t\t\treturn {\n\t\t\t\tname: \"Kevin\"\n\t\t\t};\n\t\t}\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Bracket Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/bracket",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "[key]",
        "description": "\n\nEvaluates `key` and looks up the result in the [can-view-scope scope].\n\n```\n{{[key]}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the [can-view-scope scope].\n"
          }
        ]
      },
      {
        "code": "CALL_EXPRESSION[key]",
        "description": "\n\nEvaluates `key` and looks up the result in the return value of `CALL_EXPRESSION`.\n\n```\n{{method()[key]}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A [can-stache/expressions/call Call], [can-stache/expressions/helper Helper], or [can-stache/expressions/key-lookup KeyLookup] expression that may or may not return a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the result of `CALL_EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the result of `CALL_EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache/expressions/call": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/call.md"
    },
    "body": "\n\n## Use\n\nA call expression calls a function looked up in the [can-view-scope scope] followed by\nthe [can-view-scope.Options helpers scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize(type,ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return type+(count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nCall expression arguments are comma (,) separated.  If a Hash expression is an argument,\nan object with the hash properties and values will be passed. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize(word=type count=ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(options){\n\t    return options.word+(options.count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Call Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/call",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "{{ method( [EXPRESSION...] ) }}",
        "description": "\n\nCalls `method` with zero or many arguments where each argument\nis a comma separated\n`EXPRESSION`.\n\n```\nmethod(1,key,hashProp=hashValue,call(),helper expression)\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/hash"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be passed as an argument\nto `method`.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/hash"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be passed as an argument\nto `method`.\n\n"
    },
    "comment": " "
  },
  "can-stache/expressions/helper": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/helper.md"
    },
    "body": "\n## Use\n\nA helpers expression calls a function looked up in the [can-view-scope.Options helpers scope] followed by\nthe [can-view-scope scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize type ages.length}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return \"data-pluralize\"\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(type, count){\n\t    return type+(count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nHelper expression arguments that are observable are passed a compute.  This is\nin contrast to Call expressions that get passed the value.\n\nHelper expression arguments are space seperated.  If a Hash expression is an argument,\nthe hash properties and values will be added to the helper options object. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize word=type count=ages.length}}</h1>\n\nData:\n\t{\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(helperOptions){\n\t    return helperOptions.hash.type+(helperOptions.hash.count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Helper Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/helper",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "method [EXPRESSION...]",
        "description": "\n\nCalls `method` with zero or many arguments where each argument\nis a space separated\n`EXPRESSION`.  \n\n\n\n```\n{{method 1 key call() hashProp=hashValue}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/hash"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be passed as an argument\nto `method`.\n\n\nAll [can-stache/expressions/hash]s will be collectively\nadded to the [can-stache.helperOptions]'s `hash` object.\n\nIf an `EXPRESSION` reads an observable, a\n[can-compute.computed] will be passed to `method`.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/hash"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be passed as an argument\nto `method`.\n\n\nAll [can-stache/expressions/hash]s will be collectively\nadded to the [can-stache.helperOptions]'s `hash` object.\n\nIf an `EXPRESSION` reads an observable, a\n[can-compute.computed] will be passed to `method`.\n\n\n"
    },
    "comment": " "
  },
  "can-stache.expressions": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/expressions.md"
    },
    "body": "\n```\n{{helper key1 \"string\" method(key2, 1, prop1=key3) prop2=key4}}\n```\n\nThere are 6 expression types stache supports:\n\n - Literal expressions like `{{\"string\"}}`\n - KeyLookup expressions like `{{key}}`\n - Hash expressions like `{{prop=key}}`\n - Call expressions like `{{method(arg)}}`\n - Helper expressions like `{{helper arg}}`\n - Bracket expressions like `{{[key]}}`\n\n## Literal expressions\n\nA [can-stache/expressions/literal] specifies JS primitive values like:\n\n- Strings `\"strings\"`\n- Numbers `5`\n- Booleans `true` or `false`\n- And `null` or `undefined`\n\nThey are usually passed as arguments to Call or Helper expressions like:\n\n```\n{{pluralize \"dog\" 2}}\n{{task.filter(\"completed\", true)}}\n```\n\n## KeyLookup expressions\n\nA [can-stache/expressions/key-lookup] specifies a value in the [can-view-scope scope] or\n[can-view-scope.Options HelperOptions scope] that will be looked up. KeyLookup expressions\ncan be the entire stache expression like:\n\n```\n{{key}}\n```\n\nOr they can make up the method, helper, arguments, and hash value parts of\nCall, Helper, and Hash expressions:\n\n```\n{{method(arg1,arg2}}          Call\n{{helper arg1 arg2}}          Helper\n{{method( prop=hashValue )}}  Hash\n```\n\nThe value returned up by a KeyLookup depends on what the [can-stache.key] looks like, and\nwhat expression type the KeyLookup is within.\n\nFor example, `{{method(~./key)}}` will call `method` with\na [can-compute.computed compute] that looks up the value of `key` only in the top of the [can-view-scope scope].\n\nThe rules are as follows:\n\n - __call expression arguments__ `{{method(key)}}` - values are passed.\n - __helper expression arguments__ `{{helper key}}` - computes are passed.\n - __hash value in call expression__ `{{method(hash=key)}}` - values are set as property values.\n - __hash value in helper expression__ `{{method hash=key}}` - computes are set as property values.\n - __special operator__ `{{%index}}` - lookup values in a special context provided by some helpers.\n - __compute operator__ `{{method(~key)}}` - pass a compute instead of a value.\n - __at operator__ `{{method(@key}}` - pass a function instead of trying to read the value of the function.\n - __current context__ `{{./key}}` - only lookup key at the top of the scope.\n - __parent context__ `{{../key}}` - lookup the value in the parent context.\n - __context__ `{{.}}` - return the current context/top of the scope.\n\n## Hash expressions\n\nA [can-stache/expressions/hash] specifies a property value on a object argument in a call expression\nand property value on the the hash object in a helper expression's [can-stache.helperOptions] argument.\n\nFor example, in a call expression:\n\n```\nTemplate:\n\t{{methodA(prop=key)}}\n    {{methodB(propX=key propY='literal', propZ=5)}}\nData:\n\t{\n\t  methodA: function(arg){},\n      methodB: function(arg1, arg2),\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: \"value\"}` as `arg`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal'}` as `arg1` and `{propZ: 5}` as `arg2`\n\nIn a helper expression:\n\n```\nTemplate:\n\t{{methodA prop=key}}\n    {{methodB(propX=key propY='literal' propZ=5)}}\nData:\n\t{\n\t  methodA: function(options){},\n      methodB: function(options){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: compute(\"value\")}` as `options.hash`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal', propZ: 5}` as `options.hash`.\n\n## Call expressions\n\nA [can-stache/expressions/call] calls a function looked up in the [can-view-scope scope] followed by\nthe [can-view-scope.Options helpers scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize(type, ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return type+(count === 1 ? \"\" : \"s\")\n\t  },\n\t  ages: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nCall expression arguments are comma (,) separated.  If a Hash expression is an argument,\nan object with the hash properties and values will be passed. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize(word=type count=ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(options){\n\t    return options.word+(options.count === 1 ? \"\" : \"s\")\n\t  },\n\t  ages: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n\n## Helper expressions\n\nA [can-stache/expressions/helper] calls a function looked up in the [can-view-scope.Options helpers scope] followed by\nthe [can-view-scope scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize type ages.length}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return \"data-pluralize\"\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(type, count){\n\t    return type+(count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nHelper expression arguments that are observable are passed a compute.  This is\nin contrast to Call expressions that get passed the value.\n\nHelper expression arguments are space seperated.  If a Hash expression is an argument,\nthe hash properties and values will be added to the helper options object. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize word=type count=ages.length}}</h1>\n\nData:\n\t{\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(helperOptions){\n\t    return helperOptions.hash.type+(helperOptions.hash.count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n## Bracket expressions\n\nA [can-stache/expressions/bracket] can be used to look up a dynamic property in the [can-view-scope scope]. This looks like:\n\n```\nTemplate:\n\t<h1>{{[key]}}</h1>\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tname: \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nThis can be useful for looking up values using keys containing non-alphabetic characters:\n\n```\nTemplate:\n\t<h1>{{[\"person:name\"]}}</h1>\n\nData:\n\t{\n\t\t\"person:name\": \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nBracket expressions can also be used to look up a value in the result of another expression:\n\n```\nTemplate:\n{{getPerson()[key]}}\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tgetPerson: function() {\n\t\t\treturn {\n\t\t\t\tname: \"Kevin\"\n\t\t\t};\n\t\t}\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\n",
    "description": "\nIn addition to different magic tag types, stache supports different expression\ntypes.  These can be used in various combinations to call [can-stache.registerHelper helper methods]\nor [can-component.prototype.ViewModel viewModel methods].  The following is an example of all the expressions\ncombined:\n",
    "name": "can-stache.expressions",
    "title": "Expressions",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 2
  },
  "can-stache/expressions/hash": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/hash.md"
    },
    "body": "\n## Use\n\nA hash expression specifies a property value on a object argument in a call expression\nand property value on the the hash object in a helper expression's [can-stache.helperOptions] argument.\n\nFor example, in a call expression:\n\n```\nTemplate:\n\t{{methodA(prop=key)}}\n    {{methodB(propX=key propY='literal', propZ=5)}}\nData:\n\t{\n\t  methodA: function(arg){},\n      methodB: function(arg1, arg2){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: \"value\"}` as `arg`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal'}` as `arg1` and `{propZ: 5}` as `arg2`\n\nIn a helper expression:\n\n```\nTemplate:\n\t{{methodA prop=key}}\n    {{methodB(propX=key propY='literal' propZ=5)}}\nData:\n\t{\n\t  methodA: function(options){},\n      methodB: function(options){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: compute(\"value\")}` as `options.hash`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal', propZ: 5}` as `options.hash`.\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Hash Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/hash",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "[PROPERTY_NAME=EXPRESSION ]+",
        "description": "\n\nA sequence of one or more property names and their values as another expression like:\n\n```\nprop1=1 prop2=key prop3=callExpression()\n```\n\nIn a [can-stache/expressions/call], `Hash` expressions\ncreate an object argument with the specified `PROPERTY_NAME` properties\nand `EXPRESSION` values.\n\nThe following template:\n\n```js\n{{ method( age=5 first=person.firstName last=person.getLastName() ) }}\n```\n\nMight call `method` with:\n\n```js\n{age: 5, first: \"Justin\", last: \"Meyer\"}\n```\n\nIn a [can-stache/expressions/helper], `Hash` expressions\nadd to the [can-stache.helperOptions]'s `hash` object with the specified `PROPERTY_NAME` properties\nand `EXPRESSION` values.\n\nThe following template:\n\n```js\n{{ method age=5 first=person.firstName last=person.getLastName() }}\n```\n\nMight call `method` with:\n\n```js\n{\n\thash: {age: 5, first: compute(\"Justin\"), last: compute(\"Meyer\")}\n}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "PROPERTY_NAME",
            "description": "The property name on the call expression\nargument object or [can-stache.helperOptions]'s `hash` object.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that provides a\nvalue for the property name.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that provides a\nvalue for the property name.\n"
    },
    "comment": " "
  },
  "can-reflect.isConstructorLike": {
    "type": "function",
    "name": "can-reflect.isConstructorLike",
    "parent": "can-reflect/type",
    "src": {
      "line": 5,
      "codeLine": 30,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value looks like a constructor function. \n",
    "title": "isConstructorLike",
    "signatures": [
      {
        "code": "isConstructorLike(func)",
        "description": "\n\nReturn `true` if `func` is a function and has a non-empty prototype, or implements\n [can-symbol/symbols/new `@@can.new`]; `false` otherwise.\n\n```\ncanReflect.isConstructorLike(function() {}); // -> false\n\nfunction Construct() {}\nConstruct.prototype = { foo: \"bar\" };\ncanReflect.isConstructorLike(Construct); // -> true\n\ncanReflect.isConstructorLike({}); // -> false\n!!canReflect.isConstructorLike({ [canSymbol.for(\"can.new\")]: function() {} }); // -> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "func",
            "description": "maybe a function"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if a constructor; `false` if otherwise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "func",
      "description": "maybe a function"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if a constructor; `false` if otherwise.\n"
    }
  },
  "can-reflect.isFunctionLike": {
    "name": "can-reflect.isFunctionLike",
    "type": "function",
    "parent": "can-reflect/type",
    "src": {
      "line": 66,
      "codeLine": 84,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value looks like a function. ",
    "title": "isFunctionLike",
    "signatures": [
      {
        "code": "isFunctionLike(obj)",
        "description": "\n\n Return `true` if `func` is a function, or implements\n [can-symbol/symbols/new `@@can.new`] or [can-symbol/symbols/apply `@@can.apply`]; `false` otherwise.\n\n```\ncanReflect.isFunctionLike(function() {}); // -> true\ncanReflect.isFunctionLike({}); // -> false\ncanReflect.isFunctionLike({ [canSymbol.for(\"can.apply\")]: function() {} }); // -> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "maybe a function"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "maybe a function"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-reflect.isPrimitive": {
    "type": "function",
    "name": "can-reflect.isPrimitive",
    "parent": "can-reflect/type",
    "src": {
      "line": 101,
      "codeLine": 123,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value is a JavaScript primitive. ",
    "title": "isPrimitive",
    "signatures": [
      {
        "code": "isPrimitive(obj)",
        "description": "\n\nReturn `true` if `obj` is not a function nor an object via `typeof`, or is null; `false` otherwise.\n\n```\ncanReflect.isPrimitive(null); // -> true\ncanReflect.isPrimitive({}); // -> false\ncanReflect.isPrimitive(undefined); // -> true\ncanReflect.isPrimitive(1); // -> true\ncanReflect.isPrimitive([]); // -> false\ncanReflect.isPrimitive(function() {}); // -> false\ncanReflect.isPrimitive(\"foo\"); // -> true\n\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "maybe a primitive value"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "maybe a primitive value"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-reflect.isBuiltIn": {
    "type": "function",
    "name": "can-reflect.isBuiltIn",
    "parent": "can-reflect/type",
    "src": {
      "line": 133,
      "codeLine": 160,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value is a JavaScript built-in type. ",
    "title": "isBuiltIn",
    "signatures": [
      {
        "code": "isBuiltIn(obj)",
        "description": "\n\nReturn `true` if `obj` is some type of JavaScript native built-in; `false` otherwise.\n\n```\ncanReflect.isBuiltIn(null); // -> true\ncanReflect.isBuiltIn({}); // -> true\ncanReflect.isBuiltIn(1); // -> true\ncanReflect.isBuiltIn([]); // -> true\ncanReflect.isBuiltIn(function() {}); // -> true\ncanReflect.isBuiltIn(\"foo\"); // -> true\ncanReflect.isBuiltIn(new Date()); // -> true\ncanReflect.isBuiltIn(/[foo].[bar]/); // -> true\ncanReflect.isBuiltIn(new DefineMap); // -> false\n\n```\n\nNot supported in browsers that have implementations of Map/Set where\n`toString` is not properly implemented to return `[object Map]`/`[object Set]`.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "maybe a built-in value"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "maybe a built-in value"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-reflect.isValueLike": {
    "type": "function",
    "name": "can-reflect.isValueLike",
    "parent": "can-reflect/type",
    "src": {
      "line": 177,
      "codeLine": 201,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value represents a single value (as opposed to several values). \n",
    "title": "isValueLike",
    "signatures": [
      {
        "code": "isValueLike(obj)",
        "description": "\n\nReturn `true` if `obj` is a primitive or implements [can-symbol/symbols/getValue `@can.getValue`],\n`false` otherwise.\n\n```\ncanReflect.isValueLike(null); // -> true\ncanReflect.isValueLike({}); // -> false\ncanReflect.isValueLike(function() {}); // -> false\ncanReflect.isValueLike({ [canSymbol.for(\"can.isValueLike\")]: true}); // -> true\ncanReflect.isValueLike({ [canSymbol.for(\"can.getValue\")]: function() {} }); // -> true\ncanReflect.isValueLike(canCompute()); // -> true\ncanReflect.isValueLike(new DefineMap()); // -> false\n\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "maybe a primitive or an object that yields a value"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "maybe a primitive or an object that yields a value"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-reflect.isMapLike": {
    "type": "function",
    "name": "can-reflect.isMapLike",
    "parent": "can-reflect/type",
    "src": {
      "line": 216,
      "codeLine": 245,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value represents multiple values. \n",
    "title": "isMapLike",
    "signatures": [
      {
        "code": "isMapLike(obj)",
        "description": "\n\nReturn `true` if `obj` is _not_ a primitive, does _not_ have a falsy value for\n[can-symbol/symbols/isMapLike `@@can.isMapLike`], or alternately implements\n[can-symbol/symbols/getKeyValue `@@can.getKeyValue`]; `false` otherwise.\n\n```\ncanReflect.isMapLike(null); // -> false\ncanReflect.isMapLike(1); // -> false\ncanReflect.isMapLike(\"foo\"); // -> false\ncanReflect.isMapLike({}); // -> true\ncanReflect.isMapLike(function() {}); // -> true\ncanReflect.isMapLike([]); // -> false\ncanReflect.isMapLike({ [canSymbol.for(\"can.isMapLike\")]: false }); // -> false\ncanReflect.isMapLike({ [canSymbol.for(\"can.getKeyValue\")]: null }); // -> false\ncanReflect.isMapLike(canCompute()); // -> false\ncanReflect.isMapLike(new DefineMap()); // -> true\n\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "maybe a Map-like"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "maybe a Map-like"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-reflect.isObservableLike": {
    "name": "can-reflect.isObservableLike",
    "type": "function",
    "parent": "can-reflect/type",
    "src": {
      "line": 261,
      "codeLine": 287,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value (or its keys) can be observed for changes. \n",
    "title": "isObservableLike",
    "signatures": [
      {
        "code": "isObservableLike(obj)",
        "description": "\n\nReturn  `true` if `obj` is _not_ a primitive and implements any of\n[can-symbol/symbols/onValue `@@can.onValue`], [can-symbol/symbols/onKeyValue `@@can.onKeyValue`],\n[can-symbol/symbols/onKeys `@@can.onKeys`],\nor [can-symbol/symbols/onKeysAdded `@@can.onKeysAdded`]; `false` otherwise.\n\n```\ncanReflect.isObservableLike(null); // -> false\ncanReflect.isObservableLike({}); // -> false\ncanReflect.isObservableLike([]); // -> false\ncanReflect.isObservableLike(function() {}); // -> false\ncanReflect.isObservableLike({ [canSymbol.for(\"can.onValue\")]: function() {} }); // -> true\ncanReflect.isObservableLike({ [canSymbol.for(\"can.onKeyValue\")]: function() {} }); // -> true\ncanReflect.isObservableLike(canCompute())); // -> true\ncanReflect.isObservableLike(new DefineMap())); // -> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "maybe an observable"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "maybe an observable"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-reflect.isListLike": {
    "type": "function",
    "name": "can-reflect.isListLike",
    "parent": "can-reflect/type",
    "src": {
      "line": 299,
      "codeLine": 329,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value looks like a constructor function. \n",
    "title": "isListLike",
    "signatures": [
      {
        "code": "isListLike(list)",
        "description": "\n\nReturn `true` if `list` is a `String`, <br>OR `list` is _not_ a primitive and implements `@@iterator`,\n<br>OR `list` is _not_ a primitive and returns `true` for `Array.isArray()`, <br>OR `list` is _not_ a primitive and has a\nnumerical length and is either empty (`length === 0`) or has a last element at index `length - 1`; <br>`false` otherwise\n\n```\ncanReflect.isListLike(null); // -> false\ncanReflect.isListLike({}); // -> false\ncanReflect.isListLike([]); // -> true\ncanReflect.isListLike(\"foo\"); // -> true\ncanReflect.isListLike(1); // -> false\ncanReflect.isListLike({ [canSymbol.for(\"can.isListLike\")]: true }); // -> true\ncanReflect.isListLike({ [canSymbol.iterator]: function() {} }); // -> true\ncanReflect.isListLike({ length: 0 }); // -> true\ncanReflect.isListLike({ length: 3 }); // -> false\ncanReflect.isListLike({ length: 3, \"2\": true }); // -> true\ncanReflect.isListLike(new DefineMap()); // -> false\ncanReflect.isListLike(new DefineList()); // -> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "list",
            "description": "maybe a List-like"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "list",
      "description": "maybe a List-like"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-reflect.isSymbolLike": {
    "name": "can-reflect.isSymbolLike",
    "type": "function",
    "parent": "can-reflect/type",
    "src": {
      "line": 352,
      "codeLine": 378,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value is a symbol or a [can-symbol]. \n",
    "title": "isSymbolLike",
    "signatures": [
      {
        "code": "isSymbolLike(symbol)",
        "description": "\n\nReturn `true` if `symbol` is a native Symbol, or evaluates to a String with a prefix\nequal to that of CanJS's symbol polyfill; `false` otherwise.\n\n```\n/* ES6 *\\/ canReflect.isSymbolLike(Symbol.iterator); // -> true\ncanReflect.isSymbolLike(canSymbol.for(\"foo\")); // -> true\ncanReflect.isSymbolLike(\"@symbol.can.isSymbol\"); // -> true (due to polyfill for non-ES6)\ncanReflect.isSymbolLike(\"foo\"); // -> false\ncanReflect.isSymbolLike(null); // -> false\ncanReflect.isSymbolLike(1); // -> false\ncanReflect.isSymbolLike({}); // -> false\ncanReflect.isSymbolLike({ toString: function() { return \"@symbol.can.isSymbol\"; } }); // -> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "symbol",
            "description": "maybe a symbol"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "symbol",
      "description": "maybe a symbol"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-reflect.isMoreListLikeThanMapLike": {
    "type": "function",
    "name": "can-reflect.isMoreListLikeThanMapLike",
    "parent": "can-reflect/type",
    "src": {
      "line": 426,
      "codeLine": 449,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value should be treated as a list instead of a map. \n",
    "title": "isMoreListLikeThanMapLike",
    "signatures": [
      {
        "code": "isMoreListLikeThanMapLike(obj)",
        "description": "\n\nReturn  `true` if `obj` is an Array, declares itself to be more ListLike with\n`@@can.isMoreListLikeThanMapLike`, or self-reports as ListLike but not as MapLike; `false` otherwise.\n\n```\ncanReflect.isMoreListLikeThanMapLike([]); // -> true\ncanReflect.isMoreListLikeThanMapLike(null); // -> undefined\ncanReflect.isMoreListLikeThanMapLike({}); // -> false\ncanReflect.isMoreListLikeThanMapLike(new DefineList()); // -> true\ncanReflect.isMoreListLikeThanMapLike(new DefineMap()); // -> false\ncanReflect.isMoreListLikeThanMapLike(function() {}); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to test for ListLike against MapLike traits."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "the object to test for ListLike against MapLike traits."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-reflect.isIteratorLike": {
    "type": "function",
    "name": "can-reflect.isIteratorLike",
    "parent": "can-reflect/type",
    "src": {
      "line": 465,
      "codeLine": 485,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value looks like an iterator. ",
    "title": "isIteratorLike",
    "signatures": [
      {
        "code": "isIteratorLike(obj)",
        "description": "\n\nReturn `true` if `obj` has a key `\"next\"` pointing to a zero-argument function; `false` otherwise\n\n```\ncanReflect.isIteratorLike([][Symbol.iterator]()); // -> true\ncanReflect.isIteratorLike(new DefineList()[canSymbol.iterator]()); // -> true\ncanReflect.isIteratorLike(new DefineMap()[canSymbol.iterator]()); // -> true\ncanReflect.isIteratorLike(null); // -> false\ncanReflect.isIteratorLike({ next: function() {} }); // -> true\ncanReflect.isIteratorLike({ next: function(foo) {} }); // -> false (iterator nexts do not take arguments)\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to test for Iterator traits"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "the object to test for Iterator traits"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-reflect.isPromise": {
    "type": "function",
    "name": "can-reflect.isPromise",
    "parent": "can-reflect/type",
    "src": {
      "line": 491,
      "codeLine": 507,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value is a promise. \n",
    "title": "isPromise",
    "signatures": [
      {
        "code": "isPromise(obj)",
        "description": "\n\nReturn `true` if `obj` is an instance of promise or `.toString` returns `\"[object Promise]\"`.\n\n```\ncanReflect.isPromise(Promise.resolve()); // -> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "the object to test for Promise traits."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "the object to test for Promise traits."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-reflect.isPlainObject": {
    "name": "can-reflect.isPlainObject",
    "type": "function",
    "parent": "can-reflect/type",
    "src": {
      "line": 510,
      "codeLine": 543,
      "path": "node_modules/can-reflect/reflections/type/type.js"
    },
    "body": "",
    "description": "Test if a value is an object created with `{}` or `new Object()`. \n",
    "title": "isPlainObject",
    "signatures": [
      {
        "code": "isPlainObject(obj)",
        "description": "\n\nAttempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:\n\n1. Objects with prototypes (created using the `new` keyword).\n2. Booleans.\n3. Numbers.\n4. NaN.\n\n```js\nvar isPlainObject = require(\"can-reflect\").isPlainObject;\n\n// Created with {}\nconsole.log(isPlainObject({})); // -> true\n\n// new Object\nconsole.log(isPlainObject(new Object())); // -> true\n\n// Custom object\nvar Ctr = function(){};\nvar obj = new Ctr();\n\nconsole.log(isPlainObject(obj)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to test."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "the object to test."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-stache/expressions/literal": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/literal.md"
    },
    "body": "\n\n## Use\n\nLiteral expressions are usually passed as arguments to [can-stache/expressions/call] or [can-stache/expressions/helper]s like:\n\n```js\n{{task.filter(\"completed\", true)}}\n{{pluralize \"dog\" 2}}\n```\n\n",
    "description": "\nSpecify a JavaScript primitive type.\n",
    "type": "typedef",
    "title": "Literal Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/literal",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "\"string\" | 'string'",
        "description": "\n\nSpecifies a string.\n\n```\n{{myHelper( \"this is a string\" )}}\n```\n",
        "params": []
      },
      {
        "code": "\\-[0-9]+\\.?[0-9]*",
        "description": "\n\nSpecifies a number.\n\n```\n{{myHelper( 5.2 )}}\n```\n",
        "params": []
      },
      {
        "code": "null | undefined | true | false",
        "description": "\n\nSpecifies a JavaScript `null`, `undefined`, `true`, or `false` value.\n\n```\n{{myHelper( false )}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/helpers/route": {
    "src": {
      "path": "node_modules/can-stache/docs/route/route.md"
    },
    "body": "\n",
    "description": "\nAdds stache helpers that use [can-route].\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-stache/helpers/route",
    "parent": "can-views",
    "collection": "can-core"
  },
  "can-stache/expressions/key-lookup": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/key-lookup.md"
    },
    "body": "\n## Use\n\n\n\nThe value returned up by a KeyLookup depends on what the [can-stache.key] looks like, and\nwhat expression type the KeyLookup is within.\n\nFor example, `{{method(~./key)}}` will call `method` with\na [can-compute.computed compute] that looks up the value of `key` only in the top of the [can-view-scope scope].\n\nThe rules are as follows:\n\n - __[can-stache/expressions/call] arguments__ `{{method(key)}}` - values are passed.\n - __[can-stache/expressions/helper] arguments__ `{{helper key}}` - computes are passed.\n - __hash value in [can-stache/expressions/call]__ `{{method(hash=key)}}` - values are set as property values.\n - __hash value in [can-stache/expressions/helper]__ `{{method hash=key}}` - computes are set as property values.\n - __[can-stache/keys/special special operator]__ `{{%index}}` - lookup values in a special context provided by some helpers.\n - __[can-stache/keys/compute compute operator]__ `{{method(~key)}}` - pass a compute instead of a value.\n - __[can-stache/keys/at at operator]__ `{{method(@key}}` - pass a function instead of trying to read the value of the function.\n - __[can-stache/keys/current current operator]__ `{{./key}}` - only lookup key at the top of the scope.\n - __[can-stache/keys/parent parent operator]__ `{{../key}}` - lookup the value in the parent context.\n - __[can-stache/keys/this context key]__ `{{this}}` - return the current context/top of the scope.\n\n\n## Default key return values by expression and data types\n\nKeys can have slightly different default behavior depending if they are used in:\n\n - [can-stache/expressions/helper helper arguments] like: `{{helper some.key}}`\n\nwhen compared to the other places they are used:\n\n - [can-stache.tags.escaped insertion tags] like: `{{some.key}}`\n - [can-stache/expressions/call call-expression arguments] like: `{{helper(some.key)}}`\n - [can-stache-bindings.event event bindings] like: `($click)=\"method(some.key)\"`\n - [can-stache-bindings data bindings] like: `{some-attr}=\"some.key\"`\n\nFurthermore keys return different values depending on the data type.\n\nIn general:\n\n - Functions are called to get their return value. (Use the [can-stache/keys/at `@` operator] to prevent this).\n - Keys in helper expression arguments that find observable data return\n   a [can-compute.computed] that represents the value.\n - Keys in other expressions return the value.\n - If no observable data is found, the key's value is returned in all expressions.\n\nThe following illustrates what `some.key` would return given\ndifferent data structures as a [can-stache/expressions/helper] and in all other expressions.\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}};\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A non-observable JS object with intermeidate functions:\n{some: function(){ return {key: \"value\"}}}\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A observable can-map\n{some: new Map({key: \"value\"})}\n   // Helper -> canCompute(\"value\")\n   // Other  -> \"value\"\n\n// A method on an observable can-map that reads observables\nvar Some = Map.extend({key: function(){ return this.attr(\"value\")}})\n{some: new Some({value: \"value\"})}\n   // Helper -> canCompute(\"value\")\n   // Other  -> \"value\"\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "KeyLookup Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/key-lookup",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "key",
        "description": "\n\nA [can-stache.key KeyLookup expression] specifies a value in the [can-view-scope scope] or\n[can-view-scope.Options HelperOptions scope] that will be looked up.  KeyLookup expressions\ncan be the entire stache expression like:\n\n```\n{{key}}\n```\n\nOr they can makeup the method, helper, arguments and hash value parts of\n[can-stache/expressions/call],\n[can-stache/expressions/helper], and [can-stache/expressions/hash]s:\n\n```\n{{method(arg1,arg2}}          Call\n{{helper arg1 arg2}}          Helper\n{{method( prop=hashValue )}}  Hash\n```\n",
        "params": []
      },
      {
        "code": "CALL_EXPRESSION.key",
        "description": "\n\nLooks up `key` on the return value of `CALL_EXPRESSION`.\n\n```\n{{#each(Todo.getList(complete=completed).value)}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A\ncall expression that may or may not return a value.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A property value to look up on\nthe result of `CALL_EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A property value to look up on\nthe result of `CALL_EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.routeCurrent": {
    "src": {
      "path": "node_modules/can-stache/docs/route/routeCurrent.md"
    },
    "body": "\n\n## Use\n\nUse the `routeCurrent` helper like:\n\n```\n<li {{#routeCurrent(page=\"recipe\" id=5)}}class='active'{{/routeCurrent}}>\n  <a href='{{routeUrl(page=\"recipe\" id=5)}}'>{{recipe.name}}</a>\n</li>\n```\n\nWith default routes and a url like `#!&page=5&id=5`, this produces:\n\n```\n<li class='active'>\n  <a href='#!&page=5&id=5'>{{recipe.name}}</a>\n</li>\n```\n\nIt this functionality could use call expressions like:\n\n```\n<li {{#routeCurrent(page=\"recipe\" id=5)}}class='active'{{/routeCurrent}}>\n  <a href='{{ routeCurrent(page=\"recipe\" id=5) }}'>{{recipe.name}}</a>\n</li>\n```\n\n\nThe following demo uses `routeCurrent` and [can-stache.helpers.routeUrl] to\ncreate links that update [can-route]'s `page` attribute:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache/route-url.html'></div>\n\n",
    "description": "\nReturns if the hash values match the [can-route]'s current properties.\n",
    "title": "{{#routeCurrent(hash)}}",
    "name": "can-stache.helpers.routeCurrent",
    "type": "function",
    "parent": "can-stache/helpers/route",
    "signatures": [
      {
        "code": "routeCurrent( hashes... [,subsetMatch] )",
        "description": "\n\n  Calls [can-route.current route.current] with `hashes` and returns the result. This\n  can be used in conjunction with other helpers:\n\n```\n{{linkTo \"Todos\" routeCurrent(page='todos' id=todo.id)}}\n```\n\nOr on its own:\n\n```\n<a class=\"{{#routeCurrent(page='todos',true) }}active{{/routeCurrent}}\">Todos</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "name": "hashes",
            "description": "A hash expression like `page='edit' recipeId=id`.\n"
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If an optional `true` is passed, `routeCurrent` will\nreturn `true` if every value in `hashes` matches the current route data, even if\nthe route data has additional properties that are not matched.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Returns the result of calling [can-route.current route.current].\n"
        }
      },
      {
        "code": "{{#routeCurrent([subsetMatch], hashes...)}}FN{{else}}INVERSE{{/routeCurrent}}",
        "description": "\n\nRenders `FN` if the `hashes` passed to [can-route.current route.current] returns `true`.\nRenders the `INVERSE` if [can-route.current route.current] returns `false`.\n\n```\n<a class=\"{{#routeCurrent(true, page='todos')}}active{{/routeCurrent}}\">Todos</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If an optional `true` is passed, `routeCurrent` will\nreturn `true` if every value in `hashes` matches the current route data, even if\nthe route data has additional properties that are not matched.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "name": "hashes",
            "description": "A hash expression like `page='edit' recipeId=id`.\n\n\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered if the current route matches `hashes`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif the current route does not match `hashes`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The result of `SUBEXPRESSION` or `{{else}}` expression.\n\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The result of `SUBEXPRESSION` or `{{else}}` expression.\n\n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif the current route does not match `hashes`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.routeUrl": {
    "src": {
      "path": "node_modules/can-stache/docs/route/routeUrl.md"
    },
    "body": "\n\n## Use\n\nUse the `routeUrl` helper like:\n\n```\n<a href='{{routeUrl(page=\"recipe\" id=5)}}'>{{recipe.name}}</a>\n```\n\nThis produces (with no pretty routing rules):\n\n```\n<a href='#!&page=5&id=5'>{{recipe.name}}</a>\n```\n\nIt this functionality could also be written as:\n\n```\n<a href='{{ routeUrl(page=\"recipe\" id=5) }}'>{{recipe.name}}</a>\n```\n\nUsing call expressions/parenthesis lets you pass the `merge` option to `route`.  This\nlets you write a url that only changes specified properties:\n\n```\n<a href='{{ routeUrl(id=5, true) }}'>{{recipe.name}}</a>\n```\n\n\n\n\nThe following demo uses `routeUrl` and [can-stache.helpers.routeCurrent] to\ncreate links that update [can-route]'s `page` attribute:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache/route-url.html'></div>\n\nIt also writes out the current url like:\n\n```\n{{ routeUrl(undefined,true) }}\n```\n\nThis calls `route.url({}, true)` which has the effect of writing out\nthe current url.\n\n",
    "description": "\nReturns a url using [can-route.url route.url].\n",
    "title": "{{routeUrl(hashes)}}",
    "name": "can-stache.helpers.routeUrl",
    "type": "function",
    "parent": "can-stache/helpers/route",
    "signatures": [
      {
        "code": "routeUrl( hashes... [,merge] )",
        "description": "\n\nCalls [can-route.url] with  `hashes` as it's `data` argument and an\noptional `merge`.\n\nThis can be used on its own to create `<a>` `href`s like:\n\n```\n<a href=\"{{ routeUrl(page='todos' id=todo.id) }}\">details</a>\n```\n\nOr in conjunction with other helpers:\n\n```\n{{makeLink \"details\" routeUrl(page='todos', true)}}\n```\n",
        "params": []
      },
      {
        "code": "{{routeUrl([merge], hashes...)}}",
        "description": "\n\nPasses the hashes to `route.url` and returns the result.\n\n```\n<a href=\"{{routeUrl(page='todos' id=todo.id)}}\">details</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Pass `true` to create a url that merges `hashes` into the\ncurrent [can-route] properties.  \n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "optional": true,
            "name": "hashes",
            "variable": true,
            "description": "A hash expression like `page='edit' recipeId=id`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the result of calling `route.url`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/hash"
        }
      ],
      "optional": true,
      "name": "hashes",
      "variable": true,
      "description": "A hash expression like `page='edit' recipeId=id`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the result of calling `route.url`.\n"
    },
    "comment": " "
  },
  "can-stache/keys/compute": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/compute.md"
    },
    "body": "\n\n## Use\n\nThe following illustrates what `~some.key` would return given\ndifferent data structures:\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}}\n   //-> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   //-> \"value\"\n\n// A non-observable JS object with intermediate functions:\n{some: function(){ return {key: \"value\"}}}\n   //-> \"value\"\n\n// A observable can-map\n{some: new DefineMap({key: \"value\"})}\n   //-> canCompute(\"value\")\n\n// A method on an observable can-map that reads observables\nvar Some = DefineMap.extend({\n\tvalue: \"string\",\n\tkey: function(){ return this.value; }\n})\n{some: new Some({value: \"value\"})}\n   //-> compute(function(){ return this.value; })\n```\n\nNotice that `~` should only be used once in a value lookup expression.\n\n",
    "description": "\nPass a compute instead of a value if an observable is found within\n[can-stache/expressions/call].\n",
    "type": "typedef",
    "title": "~compute",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/compute",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "~key",
        "description": "\n\nThis makes non-helper expression arguments behave similarly to helper\nexpression arguments.\n\n```\n{{#each(~todos)}} ... {{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/at": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/at.md"
    },
    "body": "\nThe default behavior in Stache lookups is to execute functions to get their return values.  `@` before a token in a path `@A.B` prevents A from being called for its return value (so 'B' is evaluated from the properties of A itself). Likewise, `@` elsewhere in a path like `A@B` prevents B from being called for its return value and returns whatever B itself is on the return from A.\n\n\n## Use\n\nThe following illustrates what `some@key` would return given\ndifferent data structures:\n\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}}\n   //-> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   //-> function(){ return \"value\"; }\n\n// A non-observable JS object with intermediate functions:\n{some: function(){ return {key: \"value\"}}}\n   //-> \"value\"\n\n// A observable can-map\n{some: new Map({key: \"value\"})}\n   //-> \"value\"\n\n// A method on an observable can-map that reads observables\nvar Some = Map.extend({key: function(){ return this.attr(\"value\")}})\n{some: new Some({value: \"value\"})}\n   //-> function(){ return this.attr(\"value\")}\n```\n\nWhere `some@key` returns a function, that function is \"bound\" via `.bind(context)`\nto the parent object.  This means that calling the function will\nhave `this` set to what is expected.\n\nIf the AT key is used at the start of a key like:\n\n```\n{{method(@key)}}\n```\n\nThis will return whatever is at the `key` property on the first context in the scope\nto have a non-undefined `key` value.\n\nThe following illustrates what `@some.key` would return because `some` will not be executed if it's a function:\n\n```\n// A non-observable JS object with intermediate functions:\n{some: function(){ return {key: \"value\"}}}\n   //-> undefined\n\n// A non-observable JS object:\n{some: {key: \"value\"}}\n   //-> \"value\"\n```\n\nThe AT key can be used multiple times within a value lookup expression like:\n\n```\n{{method(models@Todo@getList)}}\n```\n\n",
    "description": "\nReturn whatever value is at a key, regardless\nif it's a function or a compute.\n",
    "type": "typedef",
    "title": "@at",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/at",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "@key",
        "description": "\n\nLookup a `key` value in the scope and return whatever is there.\n\n```\n<paginator {next}=\"@key\"/>\n<paginator {next}=\"@loadNextItem\"/>\n```\n",
        "params": []
      },
      {
        "code": "key@prop",
        "description": "\n\nLookup `prop` property on `key` and return whatever is there.\n\n```\n<grid {get-data}=\"key@prop\"/>\n<grid {get-data}=\"Todo@getList\"/>\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/current": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/current.md"
    },
    "body": "\n\n## Use\n\nSometimes, especially with recursive templates, you want to control which\ncontext is used to lookup.  Adding `./` before the key name will\nonly look up in the current context.\n\nThe following template:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{./last}}\n      {{/children}}\n\nRendered with:\n\n    {\n      first: \"Barry\", last: \"Meyer\",\n      children: [\n        {first: \"Kim\", last: \"Sully\"},\n        {first: \"Justin\"},\n      ]\n    }\n\nWrites out:\n\n    Barry Meyer\n        Kim Sully\n        Justin\n\nNotice that `{{./last}}` returns nothing because there's no `last` property\nin the `{first: \"Justin\"}` object.\n\n",
    "description": "\nLookup a value in only the current context.\n",
    "type": "typedef",
    "title": "./current",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/current",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "./key",
        "description": "\n\nOnly looks up `key` in the current context.  Returns `undefined` if\nnot found.\n\n```\n{{#each(todo)}}\n  <input {($checked)}=\"./complete\"/> {{./name}}\n{{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache.key": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/key.md"
    },
    "body": "\n\n## Use\n\nA key references a value within the [can-view-scope scope] of a\ntemplate being rendered. In the following example, the\nkey is `name`:\n\n    <h1>{{name}}</h1>\n\nIf this template is rendered with:\n\n    {\n      name: \"Austin\"\n    }\n\nThe template writes out:\n\n    <h1>Austin</h1>\n\nA scope is a collection of multiple contexts. By default, a\nkey walks up the scope to each context until it finds a value. For example,\na template like:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{last}}\n      {{/children}}\n\nRendered with:\n\n    {\n      first: \"Barry\", last: \"Meyer\",\n      children: [\n        {first: \"Kim\", last: \"Sully\"},\n        {first: \"Justin\"},\n      ]\n    }\n\nWrites out:\n\n    Barry Meyer\n        Kim Sully\n        Justin Meyer\n\nWhen `last` is looked up on the `{first: \"Justin\"}` object and not found,\nit will then try to read the parent context's `last` property.  This is\nwhy \"Justin Meyer\" is written out.\n\n",
    "description": "A named reference to a value in the [can-view-scope scope] or [can-view-scope.Options helper scope] in a template.\n\n",
    "type": "typedef",
    "title": "key",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache.key",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "key",
        "description": "\n\nLooks up a value in the [can-view-scope scope] or\n[can-view-scope.Options helper scope].  This results in a\n[can-stache/expressions/key-lookup]. [can-stache/expressions/key-lookup]\nexpressions can provide different values depending on what type of expression they\nare within.  These rules are detailed in [can-stache/expressions/key-lookup].\n\n```\n{{name}}\n{{#canVote(age)}}\n```\n",
        "params": []
      },
      {
        "code": "EXPRESSION.key",
        "description": "\n\nLooks up `key` on the result of a subexpression `EXPRESSION`.\n\n```\n{{person.first.name}}\n{{#if(tasks.completed().length)}} ... {{/if}}\n```\n",
        "params": []
      },
      {
        "code": "a\\\\.single\\\\.key",
        "description": "\n\nLooks up a value without reading intermediate properties.\n\n\n```\n{{meta\\\\.data}}\n```\n\nThis is deprecated.  If you do have properties with dots in them, use a [can-stache/expressions/bracket Bracket Expression]:\n\n```\n{{[\"meta.data\"]}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/parent": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/parent.md"
    },
    "body": "\n\n## Use\n\nAdding `../` before a key will lookup the key starting in the parent\ncontext.  By changing the previous template to:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{../last}}\n      {{/children}}\n\nIt will write out:\n\n    Barry Meyer\n        Kim Meyer\n        Justin Meyer\n\nYou can use `.././last` to lookup `last` _only_ in the parent context.\n\n",
    "description": "\nStart looking for values in the parent context.\n",
    "type": "typedef",
    "title": "../parent",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/parent",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "../key",
        "description": "\n\nLook for values starting in the parent context.\n\n```\n{{#each(todos)}}\n\t<div class='{{#if(../isEditing(this))}}editing{{/if}}'>\n\t\t{{./name}}\n\t</div>\n{{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/scope/scope.vars": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/scope.vars.md"
    },
    "body": "\n## Use\n\nTemplate variables are often used to pass data between\ncomponents. `<component-a>` exports its `propA` value to the\ntemplate variable `scope.vars.variable`.  This is, in turn, used to update\nthe value of `propB` in `<component-b>`.\n\n```\n<component-a propA:to=\"scope.vars.variable\"/>\n<component-b propB:from=\"scope.vars.variable\"/>\n```\n\nTemplate variables are global to the template. Similar to JavaScript `var`\nvariables, template variables do not have block level scope.  The following\ndoes not work:\n\n```\n{{#each something}}\n\t<component-a propA:to=\"scope.vars.variable\"/>\n\t<component-b propB:from=\"scope.vars.variable\"/>\n{{/each}}\n```\n\nTo work around this, an `localContext` helper could be created as follows:\n\n```\nstache.regsiterHelper(\"localContext\", function(options){\n  return options.fn(new Map());\n});\n```\n\nAnd used like:\n\n```\n{{#each something}}\n\t{{#localContext}}\n\t  <component-a propA:to=\"./variable\"/>\n\t  <component-b propB:from=\"./variable\"/>\n\t{{/localContext}}\n{{/each}}\n```\n\n",
    "description": "Used to reference variables specific to the template context \n",
    "type": "typedef",
    "title": "scope.vars",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/scope/scope.vars",
    "parent": "can-stache/keys/scope",
    "signatures": [
      {
        "code": "scope.vars",
        "description": "\n\nA placeholder for a value that is local to the template.\n\n```\n<drivers-licenses selected:to=\"scope.vars.selectedDriver\"/>\n<edit-driver driver:from=\"scope.vars.selectedDriver\"/>\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/scope": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/scope.md"
    },
    "body": "",
    "description": "The template context \n",
    "type": "typedef",
    "title": "scope",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/scope",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "scope.arguments",
        "description": "\n\nIn an event binding, `scope.arguments` references the arguments passed when the event was dispatched/triggered.\n\n    <input on:click=\"doSomething(scope.arguments)\"/>\n",
        "params": []
      },
      {
        "code": "scope.element",
        "description": "\n\nIn an event binding, `scope.element` references the DOM element the event happened on:\n\n    <input on:click=\"doSomething(scope.element.value)\"/>\n",
        "params": []
      },
      {
        "code": "scope.event",
        "description": "\n\nIn an event binding, `scope.event` references the dispatched event object:\n\n    <input on:click=\"doSomething(scope.event)/>\"\n",
        "params": []
      },
      {
        "code": "scope.filename",
        "description": "\n\nThe filename of the current template (only available in dev mode).\n\n    {{scope.filename}}\n",
        "params": []
      },
      {
        "code": "scope.index",
        "description": "\n\nWhen looping over an array, [can-define/list/list], or [can-list], you an use `scope.index` to write out the index of each property:\n\n    {{#each(tasks)}}\n      <li>{{scope.index}} {{name}}</li>\n    {{/each}}\n\nIndexes start at 0.  If you want to start at 1, you can create a helper like:\n\n    stache.registerHelper('scope.indexNum', function(options){\n      return options.scope.get(\"scope.index\")+1;\n    })\n\nAnd use it like:\n\n    {{#each(task)}}\n      <li>{{scope.indexNum}} {{name}}</li>\n    {{/each}}\n",
        "params": []
      },
      {
        "code": "scope.key",
        "description": "\n\nLike `scope.index`, but provides the key value when looping through an object:\n\n    {{#each(style)}}\n      {{scope.key}}: {{this}}\n    {{/each}}\n",
        "params": []
      },
      {
        "code": "scope.lineNumber",
        "description": "\n\nThe current line number that is being rendered (only available in dev mode).\n\n    {scope.lineNumber}}\n",
        "params": []
      },
      {
        "code": "scope.root",
        "description": "\n\nThe root scope. This can be used for reading data from the root when in another scope:\n\n```html\nvar view = stache(`\n{{#each(tasks)}}\n  <li>{{name}}{{scope.root.exclamation}}</li>\n{{/each}}\n`);\n\nvar data = new DefineMap({\n\ttask: [\"one\", \"two\"],\n\texclamation: \"!!!\"\n});\n\nvar frag = view(data);\n// renders:\n// <li>one!!!</li>\n// <li>two!!!</li>\n```\n",
        "params": []
      },
      {
        "code": "scope.vars",
        "description": "\n\nVariables local to the template. See [can-stache/keys/scope/scope.vars] for details.\n",
        "params": []
      },
      {
        "code": "scope.view",
        "description": "\n\nThe current template. See [can-stache/keys/scope/scope.view] for details.\n",
        "params": []
      },
      {
        "code": "scope.viewModel",
        "description": "\n\nIn an event binding, `scope.viewModel` references the view model of the current element:\n\n    <my-component on:closed=\"doSomething(scope.viewModel)\"/>\n",
        "params": []
      }
    ]
  },
  "can-stache/keys/special": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/special.md"
    },
    "body": "",
    "description": "[can-stache-bindings.event Event bindings] and some helpers like [can-stache.helpers.each] provide special values that start with `%` to prevent potential collisions with\nother values. Special values should not be confused with [can-stache/keys/variable template variables] like [can-stache/keys/variable/self *self]\n\n",
    "type": "typedef",
    "title": "%special",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/special",
    "parent": "can-stache/keys",
    "deprecated": [
      {
        "version": "4.0",
        "description": "The `%special` values have been deprecated in favor of [can-stache/keys/scope].\n"
      }
    ],
    "signatures": [
      {
        "code": "%index",
        "description": "\n\nWhen looping over an array, [can-define/list/list], or [can-list], you an use `%index` to write out the index of each property:\n\n    {{#each(tasks)}}\n      <li>{{%index}} {{name}}</li>\n    {{/each}}\n\nIndexes start at 0.  If you want to start at 1, you can create a helper like:\n\n    stache.registerHelper('%indexNum', function(options){\n      return options.scope.get(\"%index\")+1;\n    })\n\nAnd use it like:\n\n    {{#each(task)}}\n      <li>{{%indexNum}} {{name}}</li>\n    {{/each}}\n",
        "params": []
      },
      {
        "code": "%key",
        "description": "\n\nLike `%index`, but provides the key value when looping through an object:\n\n```\n{{#each(style)}}\n   {{%key}}: {{this}}\n{{/each}}\n```\n\n",
        "params": []
      },
      {
        "code": "%element",
        "description": "\n\nIn an event binding, `%element` references the DOM element the event happened on:\n\n```\n<input ($click)=\"doSomething(%element.value)\"/>\n```\n",
        "params": []
      },
      {
        "code": "%event",
        "description": "\n\nIn an event binding, `%event` references the dispatched event object:\n\n```\n<input ($click)=\"doSomething(%event)/>\"\n```\n",
        "params": []
      },
      {
        "code": "%viewModel",
        "description": "\n\nIn an event binding, `%viewModel` references the view model of the current element:\n\n```\n<my-component (closed)=\"doSomething(%viewModel)\"/>\n```\n",
        "params": []
      },
      {
        "code": "%arguments",
        "description": "\n\nIn an event binding, `%arguments` references the arguments passed when the event was dispatched/triggered.\n\n```\n<input ($click)=\"doSomething(%arguments)\"/>\n```\n",
        "params": []
      }
    ]
  },
  "can-stache/keys/scope/scope.view": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/scope.view.md"
    },
    "body": "\n## Use\n\nThis can be used to recursively render a template given a stop condition.\nNote that we use a key expression to set local scope. Also note it is\na dot slash on the child key expression.\nThe dot slash prevents walking up the scope. See [can-stache.tags.named-partial#TooMuchRecursion Too Much Recursion] for more details.\n\n```\nvar grandpaWorm = new DefineMap({\n\tname: \"Earthworm Jim\",\n\tchild: {\n\t\tname: \"Grey Worm\",\n\t\tchild: {\n\t\t\tname: \"MyDoom\"\n\t\t}\n\t}\n});\n\nvar renderer = stache(`\n\t<span>{{name}}</span>\n\t{{#./child}}\n\t\t<div>\n\t\t\t{{>scope.view}}\n\t\t</div>\n\t{{/child}}\n`);\n\nvar view = renderer(grandpaWorm);\n```\n\nThe view variable will be the document fragment:\n```\n<span>Earthworm Jim</span>\n<div>\n\t<span>Grey Worm</span>\n\t<div>\n\t\t<span>MyDoom</span>\n\t</div>\n</div>\n```\n\nA template variable can be passed in\n\n```\nvar grandpaWorm = new DefineMap({\n\tchild: {\n\t\tname: \"Earthworm Jim\",\n\t\thasArms: false,\n\t\tchild: {\n\t\t\tname: \"Grey Worm\",\n\t\t\tchild: {\n\t\t\t\tname: \"MyDoom\"\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar renderer = stache(`\n\t<p>{{name}}</p>\n\t<p>{{hasArms}}</p>\n\t{{#./child}}\n\t\t<div>\n\t\t\t{{>scope.view}}\n\t\t</div>\n\t{{/child}}\n`);\n\nvar view = renderer(granpaWorm);\n```\n\nThe view variable will be the document fragment:\n```\n<p>Earthworm Jim</p>\n<p>false</p>\n<div>\n\t<p>Grey Worm</p>\n\t<p>false</p>\n\t<div>\n\t\t<p>MyDoom</p>\n\t\t<p>false</p>\n\t</div>\n</div>\n```\n\nFor a more detailed explanation of using partials recursively see [can-stache.tags.named-partial#TooMuchRecursion Too Much Recursion]\n\n",
    "description": "Used to reference the current template \n",
    "type": "typedef",
    "title": "scope.view",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/scope/scope.view",
    "parent": "can-stache/keys/scope",
    "signatures": [
      {
        "code": "scope.view",
        "description": "\n\nThe entirety of the current template is always stored as a [can-stache.tags.named-partial named partial] `scope.view`\n\n```\n<div>\n\t{{>scope.view}}\n</div>\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/this": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/this.md"
    },
    "body": "\n\n## Use\n\n\nTo write out the current context, write `{{.}}` or `{{this}}`. For example,\na template like:\n\n    {{#each(names)}}{{this}} {{/each}}\n\nWith data like:\n\n    {names: [\"Jan\",\"Mark\",\"Andrew\"]}\n\nWill write out:\n\n    Jan Mark Andrew\n\n",
    "description": "\nWrite out or return the current context.\n",
    "type": "typedef",
    "title": "this",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/this",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "this",
        "description": "\n\nWrites out or returns the current context.\n\n```\n{{#each(names)}}{{this}} {{/each}}\n{{#each(names)}}\n\t{{sanitize(this)}}\n{{/each}}\n```\n\n",
        "params": []
      },
      {
        "code": ".",
        "description": "\n\n  The same as writing `this`, but with 3 fewer characters!\n\n  ```\n  {{#each(names)}}{{.}} {{/each}}\n  {{#each(names)}}\n  \t{{sanitize(.)}}\n  {{/each}}\n  ```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/variable": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/variable.md"
    },
    "body": "\n## Use  \n\nEvery template contains a context which is able to store values\nlocal to the template. Keys with `*` reference variables in that context.\n\nTemplate variables are often used to pass data between\ncomponents. `<component-a>` exports its `propA` value to the\ntemplate variable `*variable`.  This is, in turn, used to update\nthe value of `propB` in `<component-b>`.\n\n```\n<component-a {^prop-a}=\"*variable\"/>\n<component-b {prop-b}=\"*variable\"/>\n```\n\nTemplate variables are global to the template. Similar to JavaScript `var`\nvariables, template variables do not have block level scope.  The following\ndoes not work:\n\n```\n{{#each(something)}}\n\t<component-a {^prop-a}=\"*variable\"/>\n\t<component-b {prop-b}=\"*variable\"/>\n{{/each}}\n```\n\nTo work around this, an `localContext` helper could be created as follows:\n\n```\nstache.regsiterHelper(\"localContext\", function(options){\n  return options.fn(new Map());\n});\n```\n\nAnd used like:\n\n```\n{{#each(something)}}\n\t{{#localContext}}\n\t  <component-a {^prop-a}=\"./variable\"/>\n\t  <component-b {prop-b}=\"./variable\"/>\n\t{{/localContext}}\n{{/each}}\n```\n\n",
    "description": "Store a variable local to the template. \n",
    "type": "typedef",
    "title": "*variable",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/variable",
    "parent": "can-stache/keys",
    "deprecated": [
      {
        "version": "4.0",
        "description": "`{{*variable}}` is deprecated in favor of [can-stache/keys/scope/scope.vars `{{scope.vars.variable}}`]\n\n"
      }
    ],
    "signatures": [
      {
        "code": "*variable",
        "description": "\n\nA placeholder for a value that is local to the template.\n\n```\n<drivers-licenses {^selected}=\"*selectedDriver\"/>\n<edit-driver {driver}=\"*selectedDriver\"/>\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/variable/self": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/variable-self.md"
    },
    "body": "\n## Use\n\nThis can be used to recursively render a template given a stop condition. \nNote that we use a key expression to set local scope. Also note it is \na dot slash on the child key expression.\nThe dot slash prevents walking up the scope. See [can-stache.tags.named-partial#TooMuchRecursion Too Much Recursion] for more details.\n\n```\nvar grandpaWorm = new DefineMap({\n\tname: \"Earthworm Jim\",\n\tchild: {\n\t\tname: \"Grey Worm\",\n\t\tchild: {\n\t\t\tname: \"MyDoom\"\n\t\t}\n\t}\n});\n\nvar renderer = stache(`\n\t<span>{{name}}</span>\n\t{{#./child}}\n\t\t<div>\n\t\t\t{{>*self}}\n\t\t</div>\n\t{{/child}}\n`);\n\nvar view = renderer(grandpaWorm);\n```\n\nThe view variable will be the document fragment:\n```\n<span>Earthworm Jim</span>\n<div>\n\t<span>Grey Worm</span>\n\t<div>\n\t\t<span>MyDoom</span>\n\t</div>\n</div>\n```\n\nA template variable can be passed in\n\n```\nvar grandpaWorm = new DefineMap({\n\tchild: {\n\t\tname: \"Earthworm Jim\",\n\t\thasArms: false,\n\t\tchild: {\n\t\t\tname: \"Grey Worm\",\n\t\t\tchild: {\n\t\t\t\tname: \"MyDoom\"\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar renderer = stache(`\n\t<p>{{name}}</p>\n\t<p>{{hasArms}}</p>\n\t{{#./child}}\n\t\t<div>\n\t\t\t{{>*self}}\n\t\t</div>\n\t{{/child}}\n`);\n\nvar view = renderer(granpaWorm);\n```\n\nThe view variable will be the document fragment:\n```\n<p>Earthworm Jim</p>\n<p>false</p>\n<div>\n\t<p>Grey Worm</p>\n\t<p>false</p>\n\t<div>\n\t\t<p>MyDoom</p>\n\t\t<p>false</p>\n\t</div>\n</div>\n```\n\nFor a more detailed explaination of using partials recursively see [can-stache.tags.named-partial#TooMuchRecursion Too Much Recursion]\n\n",
    "description": "Used to reference the current template and recursively render it \n",
    "type": "typedef",
    "title": "*self",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/variable/self",
    "parent": "can-stache/keys",
    "deprecated": [
      {
        "version": "4.0",
        "description": "`{{>*self}}` is deprecated in favor of [can-stache/keys/scope/scope.view `{{>scope.view}}`]\n"
      }
    ],
    "signatures": [
      {
        "code": "{{>*self}}",
        "description": "\n\nThe entirety of the current template is always stored as a [can-stache.tags.named-partial named partial] `*self`\n\n```\n<div>\n\t{{>*self}}\n</div>\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache.helpers.debugger": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/debugger.md"
    },
    "body": "\n\n## Use\n\nThe `debugger` helper breaks at its place in the template.\n\nDuring a break, in the paused inspector there is a special `get(<path>)` function to help inspect the current scope. For example, `get(\"book.title\")` will attempt to locate `book` in the current scope and return its `title` property.\n\nUse the helper in development and debugging.\nIn production, the `debugger` never breaks and instead prints a warning.\n\n",
    "description": "\nIn development, breaks at the given point in the template to inspect the current scope in the console.\n",
    "title": "{{debugger()}}",
    "name": "can-stache.helpers.debugger",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 10,
    "signatures": [
      {
        "code": "{{debugger()}}",
        "description": "\nThe zero argument debugger breaks any time the helper evaluates.\n\n```\n<!-- break each render -->\n{{debugger()}}\n```\n",
        "params": []
      },
      {
        "code": "{{debugger(CONDITION)}}",
        "description": "\nThe one argument debugger breaks any time the helper evaluates and the argument evaluates to a truthy value.\n\n```\n<!-- break each render when value is truthy -->\n{{debugger(value)}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CONDITION",
            "description": "an EXPRESSION that if evaluates to a truthy value triggers the debugger.\n"
          }
        ]
      },
      {
        "code": "{{debugger(LEFT, RIGHT)}}",
        "description": "\nThe two argument debugger breaks any time the helper evaluates and the two evaluated arguments are equal to each other.\n\n```\n<!-- break each render when leftValue === rightValue -->\n{{debugger(leftValue, rightValue)}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "LEFT",
            "description": "an EXPRESSION which compares with RIGHT which if equal triggers the debugger.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "RIGHT",
            "description": "an EXPRESSION which compares with LEFT which if equal triggers the debugger.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "RIGHT",
      "description": "an EXPRESSION which compares with LEFT which if equal triggers the debugger.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.each": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/each.md"
    },
    "body": "\n## Use\n\nUse the `each` helper to iterate over a array\nof items and render the block between the helper and the slash. For example,\n\nThe template:\n\n    <ul>\n      {{#each(friends)}}\n        <li>{{name}}</li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    {friends: [{name: \"Austin\"},{name: \"Justin\"}]}\n\nRenders:\n\n    <ul>\n      <li>Austin</li>\n      <li>Justin</li>\n    </ul>\n\n## Object iteration\n\nWhen iterating over [can-map] it will only iterate over the\nmap's [can-map.keys] and none of the hidden properties of a Map. For example,\n\nThe template:\n\n    <ul>\n      {{#each(person)}}\n        <li>{{.}}</li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    {person: {name: 'Josh', age: 27}}\n\nRenders:\n\n    <ul>\n      <li>Josh</li>\n      <li>27</li>\n    </ul>\n\n## Understanding when to use #each with lists\n\n`{{#each(key)}}` iteration will do basic diffing and aim to only update the DOM where the change occurred. Whereas\n[can-stache.tags.section] default iteration will re-render the entire section for any change in the list.\n[can-stache.tags.section] iteration is the preferred method to use when a list is replaced or changing significantly.\nWhen doing single list item changes frequently, `{{#each(expression)}}` iteration is the faster choice.\n\nFor example, assuming \"list\" is a [can-define/list/list] instance:\n\n`{{#each(list)}}` and `{{#list}}` both iterate through an instance of [can-define/list/list], however we setup the bindings differently.\n\n`{{#each(list)}}` will setup bindings on every individual item being iterated through, while `{{#list}}` will not. This makes a difference in two scenarios:\n\n1) You have a large list, with minimal updates planned after initial render. In this case, `{{#list}}` might be more advantageous as there will be a faster initial render. However, if any part of the list changes, the entire `{{#list}}` area will be re-processed.\n\n2) You have a large list, with many updates planned after initial render. A grid with many columns of editable fields, for instance. In this case, you many want to use `{{#each(list)}}`, even though it will be slower on initial render(we're setting up more bindings), you'll have faster updates as there are now many sections.\n\n",
    "description": "\n",
    "title": "{{#each(expression)}}",
    "name": "can-stache.helpers.each",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 5,
    "deprecated": [
      {
        "version": "4.0",
        "description": "The `as` keyword signature, `{{#each EXPRESSION as KEY}}FN{{else}}INVERSE{{/each}}`, is deprecated in favor of [can-stache/expressions/hash].\n"
      }
    ],
    "signatures": [
      {
        "code": "{{#each(EXPRESSION)}}FN{{else}}INVERSE{{/each}}",
        "description": "\n\nRender `FN` for each item in `EXPRESSION`'s return value.  If `EXPRESSION`\nis falsey or an empty list, render `INVERSE`.\n\n```\n{{#each(todos)}}\n  <li>{{name}}</li>\n{{else}}\n  <li>No todos, rest easy!</li>\n{{/each}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An\nexpression that typically returns a list like data structure.\n\nIf the value of the EXPRESSION is a [can-define/list/list] or [can-list], the resulting HTML is updated when the list changes. When a change in the list happens, only the minimum amount of DOM\nelement changes occur.  The list itself can also change, and a [can-util/js/diff/diff]\nwill be performed, which also will perform a minimal set of updates. The [can-stache/keys/special special %key key] is available within `FN`.\n\nIf the value of the key is an object, `FN` will be\ncalled for each property on the object. The [can-stache/keys/special special %key key]\nis available within `FN`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered with each\nitem in `EXPRESSION` or property value in `EXPRESSION`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n"
          }
        ]
      },
      {
        "code": "{{#each(EXPRESSION, HASH_EXPRESSION)}}FN{{else}}INVERSE{{/each}}",
        "description": "\n\nLike a normal `{{#each(EXPRESSION)}}`, but uses [can-stache/expressions/hash] to\nadd the current `value`, `key`, or `index` to the current scope.\n\n```\n{{#each(todos, todo=value num=index)}}\n    <li data-index=\"{{num}}\">{{todo.name}}</li>\n{{/each}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An\nexpression that returns a list or object like data structure.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "name": "HASH_EXPRESSION",
            "description": "A hash expression that aliases special properties for each iteration:\n- `value`: The current value\n- `key`: The key of the current object item\n- `index`: The index of the current array item\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered with each\nitem in `EXPRESSION` or property value in `EXPRESSION`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n"
          }
        ]
      },
      {
        "code": "{{#each(EXPRESSION)}}FN{{else}}INVERSE{{/each}}",
        "description": "\n\nLike a normal `{{#each(EXPRESSION)}}`, but adds each item in `EXPRESSION` as\n`KEY` in `FN`'s [can-view-scope].\n\n```\n{{#each(todos, todo=value)}}\n    <li>{{todo.name}}</li>\n{{/each}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An\nexpression that returns a list or object like data structure.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "The name that:\n - each item in `EXPRESSION`'s list, or\n - each property value in `EXPRESSION`'s object\nshould take on in `FN`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered with each\nitem in `EXPRESSION` or property value in `EXPRESSION`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n\n"
    },
    "comment": " "
  },
  "can-stache.helpers.case": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/case.md"
    },
    "body": "\n## Use\n\nThe `case` helper is contextual inside of a [can-stache.helpers.switch] block. The parent switch contains an `expr` that will be matched against the case `expr` and if they are equal the block will be returned.\n\nFor more information on how `{{#case()}}` is used check:\n\n- [can-stache.helpers.switch]\n- [can-stache.helpers.default]\n\n",
    "description": "\n",
    "title": "{{#case(expression)}}",
    "name": "can-stache.helpers.case",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 14,
    "signatures": [
      {
        "code": "{{#case(EXPRESSION)}}BLOCK{{/case}}",
        "description": "\n\nRenders the `BLOCK` when `EXPRESSION` matches the `EXPRESSION` provided in the parent [can-stache.helpers.switch].\n\n```\n{{#switch(user.type)}}\n\t{{#case(\"admin\")}}\n\t\t<button value=\"edit\"/>\n\t{{/case}}\n\t{{#case(\"manager\")}}\n\t\t<button value=\"view\">\n\t{{/case}}\n\t{{#default()}}\n\t\tYou do not have permission!\n\t{{/default}}\n{{/switch}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression or key that references a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "A subsection that will be rendered if\nthe case `EXPRESSION` matches the switch's `EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "A subsection that will be rendered if\nthe case `EXPRESSION` matches the switch's `EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.default": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/default.md"
    },
    "body": "\n## Use\n\nThe `default` helper is contextual inside of a [can-stache.helpers.switch] block. It acts as a fall-through in case none of the [can-stache.helpers.case] helpers resolved.\n\nFor more information on how `{{#default()}}` is used check:\n\n- [can-stache.helpers.switch {{#switch(expr)}}]\n- [can-stache.helpers.case {{#case(expr)}}]\n\n",
    "description": "\n",
    "title": "{{#default()}}",
    "name": "can-stache.helpers.default",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 15,
    "signatures": [
      {
        "code": "{{#default()}}BLOCK{{/default}}",
        "description": "\n\nRenders `BLOCK` if no [can-stache.helpers.case] blocks within the [can-stache.helpers.switch] resolved.\n\n```\n{{#switch(user.type)}}\n\t{{#case(\"admin\")}}\n\t\t<button value=\"edit\"/>\n\t{{/case}}\n\t{{#case(\"manager\")}}\n\t\t<button value=\"view\">\n\t{{/case}}\n\t{{#default()}}\n\t\tYou do not have permission!\n\t{{/default}}\n{{/switch}}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "a template to be rendered.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "a template to be rendered.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.if": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/if.md"
    },
    "body": "\n## Use\n\n`{{#if(key)}}` provides explicit conditional truthy tests. For example,\n\nThe template:\n\n    {{#if(user.isFemale)}}\n      {{#if(user.isMarried)}}\n        Mrs\n      {{/if}}\n      {{#if(user.isSingle)}}\n        Miss\n      {{/if}}\n    {{/if}}\n\nRendered with:\n\n    {user: {isFemale: true, isMarried: true}}\n\nResults in:\n\n    Mrs\n\nIf can be used with [can-stache.helpers.else {{else}}] too. For example,\n\n    {{#if(user.isFemale)}}\n      {{#if(user.isMarried)}}\n        Mrs\n      {{else}}\n        Miss\n      {{/if}}\n    {{/if}}\n\nRendered with:\n\n    {user: {isFemale: true, isMarried: false}}\n\nResults in:\n\n    Miss\n\n",
    "description": "",
    "title": "{{#if(expression)}}",
    "name": "can-stache.helpers.if",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 2,
    "signatures": [
      {
        "code": "{{#if(EXPRESSION)}}FN{{else}}INVERSE{{/if}}",
        "description": "\n\nRenders `FN` if `EXPRESSION` is truthy or `INVERSE` if `EXPRESSION`\nis falsey. Both `FN` and `INVERSE` will be rendered with the\ncurrent scope.\n\n```\n{{#if(person.isAwake())}} Hello {{/if}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a truthy or falsey value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that can be optionally rendered.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey and [can-stache.helpers.else] is used.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey and [can-stache.helpers.else] is used.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.eq": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/eq.md"
    },
    "body": "",
    "description": "\n",
    "title": "{{#eq(expressions)}}",
    "name": "can-stache.helpers.eq",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 12,
    "signatures": [
      {
        "code": "{{#eq([EXPRESSION...])}}FN{{else}}INVERSE{{/eq}}",
        "description": "\n\nRender FN if two values are equal, otherwise render INVERSE.\n\n`eq` is an alias for [can-stache.helpers.is the `is` helper].\n\n\n",
        "params": []
      }
    ]
  },
  "can-stache.helpers.is": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/is.md"
    },
    "body": "\n\n## Use\n\nThe `is` helper compares expr1 and expr2 and renders the blocks accordingly.\n\n\t{{#eq(expr1, expr2)}}\n\t\t// truthy\n\t{{else}}\n\t\t// falsey\n\t{{/is}}\n\n",
    "description": "\nRender something if two values are equal.\n",
    "title": "{{#eq(expressions)}}",
    "name": "can-stache.helpers.is",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 12,
    "signatures": [
      {
        "code": "{{#eq([EXPRESSION...])}}FN{{else}}INVERSE{{/is}}",
        "description": "\n\nRenders the `FN` if every `EXPRESSION` argument is equal (`===`).\n\n```\n{{#eq(user.type, \"admin\")}} <button/> {{else}} Login {{/is}}\n{{#eq(task.ownerId, task.assignedId, user.id)}} Delegate! {{/is}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "Two or more expressions whose return values will be tested for equality.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered if each\n`EXPRESSION` argument is equal.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif one of the `EXPRESSION` arguments is not equal to one of the others.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif one of the `EXPRESSION` arguments is not equal to one of the others.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.joinBase": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/joinBase.md"
    },
    "body": "\nThe `joinBase` helper is used to create urls within your application for static resources, such as images. An example usage:\n\n    {{joinBase(\"hello/\", name, \".png\")}}\n\nWhere `name` is a scope value, this might return `http://example.com/app/hello/world.png` if the application is `http://example.com/app`.\n\nThe url to join with is determined by the following factors:\n\n* If attempting to load a relative url, such as `{{joinBase(\"../foo.png\")}}` and using StealJS the template's address will be used as a reference to look up the location.\n* If the `can.baseURL` string is set, this will be used.\n* If the `System.baseURL` is set, this will be used.\n* Lastly we fall back to `location.pathname`.\n\n",
    "description": "\n",
    "title": "{{joinBase(expressions)}}",
    "name": "can-stache.helpers.joinBase",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 16,
    "signatures": [
      {
        "code": "{{joinBase([EXPRESSION...])}}",
        "description": "\n\nReturn an application-relative url for a resource.\n\n```\n{{joinBase(\"hello/\", name, \".png\")}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "variable": true,
            "description": "Expression or key arguments that reference a value within the current or parent scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "variable": true,
      "description": "Expression or key arguments that reference a value within the current or parent scope.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.log": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/log.md"
    },
    "body": "",
    "description": "\n",
    "title": "{{log()}}",
    "name": "can-stache.helpers.log",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 9,
    "signatures": [
      {
        "code": "{{log([EXPRESSION])}}",
        "description": "\n\n`console.log`s the current context or the result of the provided expressions.\n\n```\n{{log()}}\n{{log(person.name, person.age)}}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "\nArguments to `console.log`.  If none are provided, the current context (the top of the [can-view-scope]) will be logged.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "description": "\nArguments to `console.log`.  If none are provided, the current context (the top of the [can-view-scope]) will be logged.\n"
    }
  },
  "can-stache.registerHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/registerHelper.md"
    },
    "body": "\n",
    "description": "Register a helper. \n",
    "title": "registerHelper",
    "name": "can-stache.registerHelper",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerHelper(name, helper)",
        "description": "\n\n\nRegisters a helper function.\nPass the name of the helper followed by the\nfunction to which stache should invoke. See [can-stache.Helpers] for more details on using helpers\nand [can-stache.registerSimpleHelper] to avoid converting computes;\n\n```js\nstache.registerHelper(\"upper\", function(str){\n\tif(str.isComputed) {\n\t\tstr = str();\n\t}\n\treturn str.toUpperCase();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the helper."
          },
          {
            "types": [
              {
                "type": "can-stache.helper"
              }
            ],
            "name": "helper",
            "description": "The helper function.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helper"
        }
      ],
      "name": "helper",
      "description": "The helper function.\n"
    },
    "comment": " "
  },
  "can-stache.registerSimpleHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/registerSimpleHelper.md"
    },
    "body": "\n",
    "description": "Register a helper that gets passed values. \n",
    "title": "registerSimpleHelper",
    "name": "can-stache.registerSimpleHelper",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerSimpleHelper(name, helper)",
        "description": "\n\nRegisters a helper with stache that always returns\nthe arguments value (instead of a compute).\nPass the name of the helper followed by the\nfunction to which Mustache should invoke.\n\nSee [can-stache.Helpers] for more details on using helpers\nand [can-stache.registerHelper] to get computes for observable values.\n\n```js\nstache.registerSimpleHelper(\"upper\", function(str){\n\treturn str.toUpperCase();\n});\n```\n\nSee [can-stache.Helpers] for more details on using helpers.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the helper."
          },
          {
            "types": [
              {
                "type": "can-stache.simpleHelper"
              }
            ],
            "name": "helper",
            "description": "The helper function.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.simpleHelper"
        }
      ],
      "name": "helper",
      "description": "The helper function.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.switch": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/switch.md"
    },
    "body": "\n## Use\n\nThe `switch` helper is used to render a block where one of several cases matches expr. It works just like a JavaScript switch.\n\n\n\t{{#switch(page)}}\n\t\t{{#case(\"cart\")}}\n\t\t\t<can-import from=\"cart\">\n\t\t\t\t<cart-page></cart-page>\n\t\t\t</can-import>\n\t\t{{/case}}\n\t\t{{#default()}}\n\t\t\t<can-import from=\"home\">\n\t\t\t\t<home-page></home-page>\n\t\t\t</can-import>\n\t\t{{/default}}\n\t{{/switch}}\n\n",
    "description": "\n",
    "title": "{{#switch(expression)}}",
    "name": "can-stache.helpers.switch",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 13,
    "signatures": [
      {
        "code": "{{#switch(EXPRESSION)}}BLOCK{{/switch}}",
        "description": "\n\nRenders the `BLOCK` with contextual [can-stache.helpers.case] and [can-stache.helpers.default] helpers.\n\n```\n{{#switch(user.type)}}\n\t{{#case(\"admin\")}}\n\t\t<button value=\"edit\"/>\n\t{{/case}}\n\t{{#case(\"manager\")}}\n\t\t<button value=\"view\">\n\t{{/case}}\n\t{{#default()}}\n\t\tYou do not have permission!\n\t{{/default}}\n{{/switch}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression or key that references a value that will be switched on.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "a template that is rendered, uses [can-stache.helpers.case] and [can-stache.helpers.default] helpers to match `EXPRESSION`.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "a template that is rendered, uses [can-stache.helpers.case] and [can-stache.helpers.default] helpers to match `EXPRESSION`.\n\n"
    },
    "comment": " "
  },
  "can-stache.helpers.unless": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/unless.md"
    },
    "body": "\n## Use\n\nThe `unless` helper evaluates the inverse of the value\nof the key and renders the block between the helper and the slash.\n\n    {{#unless(expr)}}\n      // unless\n    {{/unless}}\n\n",
    "description": "\n",
    "title": "{{#unless(expression)}}",
    "name": "can-stache.helpers.unless",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 4,
    "signatures": [
      {
        "code": "{{#unless(EXPRESSION)}}FN{{else}}INVERSE{{/unless}}",
        "description": "\n\nRenders `FN` if `EXPRESSION` is falsey or `INVERSE` if `EXPRESSION`\nis truthy. Both `FN` and `INVERSE` will be rendered with the\ncurrent scope.\n\n```\n{{#unless(person.isAwake())}} Shhhhh! {{/unless}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a truthy or falsey value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that can be optionally rendered.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is truthy and [can-stache.helpers.else] is used.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is truthy and [can-stache.helpers.else] is used.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.legacy-syntaxes": {
    "name": "can-stache-bindings.legacy-syntaxes",
    "title": "Deprecated Syntaxes",
    "type": "group",
    "parent": "deprecated {($^)} bindings",
    "description": "",
    "order": 0
  },
  "deprecated {($^)} bindings": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/legacy/bindings.md"
    },
    "body": "\n> Note: This syntax is **deprecated** and you should use the [can-stache-bindings new syntax] instead.\n\n\n## Use\n\nThe `can-stache-bindings` plugin provides useful [can-view-callbacks.attr custom attributes] for template declarative event, one-way bindings, and two-way\nbindings on element attributes, component [can-component::ViewModel ViewModels], and the [can-view-scope scope].\n\nThe deprecated bindings are as follows:\n\n- `(event)=\"key()\"` for event binding.\n- `{prop}=\"key\"` for one-way binding to a child.\n- `{^prop}=\"key\"` for one-way binding to a parent.\n- `{(prop)}=\"key\"` for two-way binding.\n\nPrepending `$` to a binding like `($event)=\"key()\"` changes the binding from the `ViewModel` to the element’s attributes or properties.\n\n> __Note:__ DOM attribute names are case-insensitive, use hypens (-) to in the attribute name to setup camelCase bindings.\n\nThe following are the deprecated bindings that can be used with [can-stache]:\n\n#### [can-stache-bindings.event event]\n\nBinds to `childEvent` on `<my-component>`'s [can-component::ViewModel ViewModel] and calls\n`method` on the [can-view-scope scope] with the specified arguments:\n\n```\n<my-component (child-event)=\"method('primitive', key, hash1=key1)\"/>\n```\n\nBinds to `domEvent` on `<my-component>` and calls\n`method` on the [can-view-scope scope] with the specified arguments.\n\n```\n<my-component ($dom-event)=\"method('primitive', key, hash1=key1)\"/>\n```\n\n#### [can-stache-bindings.toChild one-way to child]\n\nUpdates `childProp` in `<my-component>`’s [can-component::ViewModel ViewModel] with `value` in the [can-view-scope scope]:\n\n```\n<my-component {child-prop}=\"value\"/>\n```\n\nUpdates the `child-attr` attribute or property on `<my-component>` with `value`\nin the [can-view-scope scope]:\n\n```\n<my-component {$child-attr}=\"value\"/>\n```\n\n> __Note:__ If value being passed to the component is an object, changes to the objects properties will still be visible to the component. Objects are passed by reference. See [can-stache-bindings#OneWayBindingWithObjects One Way Binding With Objects].\n\n#### [can-stache-bindings.toParent one-way to parent]\n\nUpdates `value` in the [can-view-scope scope]  with `childProp`\nin `<my-component>`’s [can-component::ViewModel ViewModel]:\n\n```\n<my-component {^child-prop}=\"value\"/>\n```\n\nUpdates `value`\nin the [can-view-scope scope] with the `child-attr` attribute or property on `<my-component>`:\n\n```\n<my-component {^$child-attr}=\"value\"/>\n```\n\n> __Note:__ If value being passed to the component is an object, changes to the objects properties will still be visible to the component. Objects are passed by reference. See [can-stache-bindings#OneWayBindingWithObjects One Way Binding With Objects].\n\n#### [can-stache-bindings.twoWay two-way]\n\nUpdates `childProp` in `<my-component>`’s [can-component::ViewModel ViewModel] with `value` in the [can-view-scope scope] and vice versa:\n\n```\n<my-component {(child-prop)}=\"value\"/>\n```\n\nUpdates the `child-attr` attribute or property on `<my-component>` with `value`\nin the [can-view-scope scope] and vice versa:\n\n```\n<my-component {($child-attr)}=\"value\"/>\n```\n\n## One Way Binding With Objects\n\n`{child-prop}=\"key\"` ([can-stache-bindings.toChild one-way to child]) or `{^child-prop}=\"key\"` ([can-stache-bindings.toParent one-way to parent]) is used to pass values from the current scope to a component or vice versa, respectively.\n\nGenerally, this binding only observes changes in one direction, but when [can-stache.key] is an object (POJO, [can-define/map/map DefineMap], etc), it is passed as a reference, behaving in much the same way as the following snippet.\n\n```javascript\nfunction component(bar) {\n\t// changes to bar's properties are preserved\n\tbar.quux = 'barfoo';\n\n\t// but replacing bar is not\n\tbar = {\n\t\tquux: 'hello world'\n\t};\n}\n\nvar foo = {\n\tquux: 'foobar'\n};\ncomponent(foo);\n```\n\n",
    "description": "\nProvides template event, one-way bindings, and two-way bindings.\n",
    "type": "module",
    "title": "Deprecated Syntaxes",
    "name": "deprecated {($^)} bindings",
    "parent": "can-stache-bindings.syntaxes",
    "order": 5,
    "comment": " "
  },
  "can-stache.helpers.with": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/with.md"
    },
    "body": "\n\n## Use\n\n`{{#with()}}` renders a subsection with a new context added to the [can-view-scope].\nFor example:\n\n```\nTEMPLATE:\n\t{{#with(person.address)}}\n\t\tStreet: {{street}}\n\t\tCity: {{city}}\n\t{{/with}}\nDATA:\n\t{person: {address: {street: \"123 Evergreen\", city: \"Springfield\"}}}\n\nRESULT:\n\tStreet: 123 Evergreen\n\tCity: Springfield\n```\n\nThe new context can be a lookup expression, or a set of hashes which are taken together to be a new context.\n\n```\nTEMPLATE:\n\t{{#with(innerStreet=person.address.street innerCity=person.address.city)}}\n\t\tStreet: {{innerStreet}}\n\t\tCity: {{innerCity}}\n\t{{/with}}\nDATA:\n\t{person: {address: {street: \"123 Evergreen\", city: \"Springfield\"}}}\n\nRESULT:\n\tStreet: 123 Evergreen\n\tCity: Springfield\n```\n\n\nThe difference between `{{#with()}}` and the default [can-stache.tags.section]\nis that the subsection `BLOCK` is rendered no matter what:\n\n```\nTEMPLATE:\n\t{{#with(person.address)}}\n\t\tStreet: {{street}}\n\t\tCity: {{city}}\n\t{{/with}}\nDATA:\n\t{person: {}}\n\nRESULT:\n\tStreet:\n\tCity:\n```\n\n",
    "description": "\nChanges the context within a block.\n",
    "title": "{{#with(expression)}}",
    "name": "can-stache.helpers.with",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 6,
    "signatures": [
      {
        "code": "{{#with(EXPRESSION)}}BLOCK{{/with}}",
        "description": "\n\nRenders `BLOCK` with the result of `EXPRESSION` added to the top of the [can-view-scope].\n\n```\n{{#with(person.address)}}\n\tStreet: {{street}}\n\tCity: {{city}}\n{{/with}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "A template that is rendered\nwith the context of the `EXPRESSION`'s value.\n"
          }
        ]
      },
      {
        "code": "{{#with(HASHES)}}BLOCK{{/with}}",
        "description": "\n\nRenders `BLOCK` with the key-value pairs from a [can-stache/expressions/hash] added to the top of the [can-view-scope].\n\n```\n{{#with(innerStreet=person.address.street innerCity=person.address.city)}}\n    Street: {{innerStreet}}\n    City: {{innerCity}}\n{{/with}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "name": "HASHES",
            "description": "Any number of hash keys and values\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "A template that is rendered\nwith the hashes added to the context.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "A template that is rendered\nwith the hashes added to the context.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.legacy-toChild": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/legacy/to-child.md"
    },
    "body": "\n## Use\n\n`{child-prop}=\"key\"` is used to pass values from the scope to a component.  You can use CallExpressions like:\n\n```\n<player-scores {scores}=\"game.scoresForPlayer('Alison')\"/>\n<player-scores {scores}=\"game.scoresForPlayer('Jeff')\"/>\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-child.html'></div>\n\n",
    "description": "One-way bind a value in the parent scope to the [can-component.prototype.ViewModel ViewModel]. \n",
    "title": "{to-child}",
    "name": "can-stache-bindings.legacy-toChild",
    "type": "function",
    "parent": "can-stache-bindings.legacy-syntaxes",
    "order": 1,
    "signatures": [
      {
        "code": "{child-prop}=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` in [can-component.prototype.view-model viewModel]. It also updates `childProp` with the value of `key` when `key` changes.\n\n  ```\n  <my-component {some-prop}=\"value\"/>\n  ```\n\n  > __Note:__ If [can-stache.key] is an object, changes to the objects properties will still be visible to the component. Objects are passed by reference. See [can-stache-bindings#OneWayBindingWithObjects One Way Binding With Objects].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property to set in the\ncomponent’s viewmodel.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression whose resulting value is used to set as `childProp`.\n"
          }
        ]
      },
      {
        "code": "{$child-prop}=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` property or attribute on the element.\n\n  ```\n  <input {$value}=\"name\"/>\n  ```\n\n  This signature works, but the following should be used instead:\n\n  ```\n  <input value=\"{{name}}\"/>\n  ```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache-bindings.legacy-event": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/legacy/event.md"
    },
    "body": "\n## Use\n\nThe use of `(event)` bindings changes between listening on __DOM events__ and __viewModel events__.\n\n## DOM events\n\nTo listen for a DOM event, wrap the event name with `($event)` like:\n\n```\n<div ($click)=\"doSomething()\"/>\n```\n\nBy adding `($EVENT)='methodKey()'` to an element, the function pointed to\nby `methodKey` is bound to the element’s `EVENT` event. The function can be\npassed any number of arguments from the surrounding scope, or `name=value`\nattributes for named arguments. Direct arguments will be provided to the\nhandler in the order they were given.\n\nThe following uses `($click)=\"items.splice(%index,1)\"` to remove a\nitem from `items` when that item is clicked on.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/event-args.html'></div>\n\n### Special Event Types\n\n[can-stache-bindings] supports creating special event types\n(events that aren’t natively triggered by the DOM), which are\nbound by adding attributes like `($SPECIAL)='KEY'`. This is\nsimilar to [$.special](http://benalman.com/news/2010/03/jquery-special-events/).\n\n### ($enter)\n\n`($enter)` is a special event that calls its handler whenever the enter\nkey is pressed while focused on the current element. For example:\n\n\t<input type='text' ($enter)='save()' />\n\nThe above template snippet would call the save method\n(in the [can-view-scope scope]) whenever\nthe user hits the enter key on this input.\n\n## viewModel events\n\nTo listen on a [can-component Component’s] [can-component.prototype.ViewModel ViewModel], wrap the event name with `(event)` like:\n\n```\n<player-edit\n  \t(close)=\"removeEdit()\"\n  \t{player}=\"editingPlayer\"/>\n```\n\nViewModels can publish events on themselves. The following `<player-edit>` component\ndispatches a `\"close\"` event on itself when its `close` method is called:\n\n```\nComponent.extend({\n  tag: \"player-edit\",\n  template: can.view('player-edit-stache'),\n  viewModel: {\n    close: function(){\n      this.dispatch(\"close\");\n    }\n  }\n});\n```\n\nThe following demo uses this ability to create a close button that\nhides the player editor:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next_event.html'></div>\n\n",
    "description": "Respond to events on elements or component ViewModels. \n",
    "title": "(event)",
    "name": "can-stache-bindings.legacy-event",
    "type": "function",
    "parent": "can-stache-bindings.legacy-syntaxes",
    "order": 0,
    "signatures": [
      {
        "code": "($DOM_EVENT)='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on the element and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<div ($click)=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "DOM_EVENT",
            "description": "A DOM event name like `click`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression (e.g. `method(key)`) that is called when the `DOM_EVENT` is fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component’s [can-component::ViewModel ViewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n"
          }
        ]
      },
      {
        "code": "(VIEW_MODEL_EVENT)='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on the element’s [can-component::ViewModel ViewModel] and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<my-component (show)=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "VIEW_MODEL_EVENT",
            "description": "A view model event.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression like `method(key)` that is called when the `VIEW_MODEL_EVENT`\nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component’s [can-component::ViewModel ViewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.expressions"
        }
      ],
      "name": "CALL_EXPRESSION",
      "description": "A call expression like `method(key)` that is called when the `VIEW_MODEL_EVENT`\nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component’s [can-component::ViewModel ViewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n\n"
    },
    "comment": " "
  },
  "can-stache-bindings.legacy-toParent": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/legacy/to-parent.md"
    },
    "body": "\n## Use\n\nThe use of `{^to-parent}` bindings changes between exporting __viewModel properties__ or __DOM properties__.\n\n## Exporting ViewModel properties\n\n`{^child-prop}=\"key\"` can be used to export single values or the complete view model from a\nchild component into the parent scope. Typically, the values are exported to the references scope.\n\nIn the following example, it connects the __selected__ driver in `<drivers-list>` with an editable __plateName__ in\n`<edit-plate>`:\n\n    <drivers-list {^selected}=\"*editing\"/>\n    <edit-plate {(plate-name)}=\"*editing.licensePlate\"/>\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-parent.html'></div>\n\n## Exporting DOM properties\n\n`{^$child-prop}=\"key\"` can be used to export an attribute value into the scope.  For example:\n\n```\n<input {^$value}=\"name\"/>\n```\n\nUpdates `name` in the scope when the `<input>` element’s `value` changes.\n\n## Exporting Functions\n\nYou can export a function to the parent scope with a binding like:\n\n```\n<my-tabs {^@add-panel}=\"@*addPanel\">\n```\n\nAnd pass the method like:\n\n```\n<my-panel {add-panel}=\"@*addPanel\" title=\"CanJS\">CanJS Content</my-panel>\n```\n\nCheck it out in this demo:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-parent-function.html'></div>\n\nNotice that `@` is used to prevent reading the function.  \n\n",
    "description": "One-way bind a value in the current [can-component.prototype.view-model viewModel] to the parent scope. \n",
    "title": "{^to-parent}",
    "name": "can-stache-bindings.legacy-toParent",
    "type": "function",
    "parent": "can-stache-bindings.legacy-syntaxes",
    "order": 2,
    "signatures": [
      {
        "code": "{^child-prop}=\"key\"",
        "description": "\n\nExports `childProp` in the [can-component.prototype.ViewModel ViewModel] to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n`key` with the value of `childProp` when `childProp` changes.\n\n```\n<my-component {^some-prop}=\"value\"/>\n```\n\n> __Note:__ If [can-stache.key] is an object, changes to the objects properties will still be visible to the component. Objects are passed by reference. See [can-stache-bindings#OneWayBindingWithObjects One Way Binding With Objects].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property to export from the\nchild components viewmodel. Use `{^this}` or `{^.}` to export the entire viewModel.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression that will be used to set in the parent scope.\n"
          }
        ]
      },
      {
        "code": "{^$child-prop}=\"key\"",
        "description": "\n\n  Exports the element’s `childProp` property or attribute to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n  `key` with the value of `childProp` when `childProp` changes.\n\n  ```\n  <input {^$value}=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element’s property or attribute to export.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression whose resulting value with be used to set in the parent scope.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "An expression whose resulting value with be used to set in the parent scope.\n\n"
    },
    "comment": " "
  },
  "can-stache-bindings.legacy-twoWay": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/legacy/two-way.md"
    },
    "body": "\n## Use\n\n`{(child-prop)}=\"key\"` is used to two-way bind a value in a [can-component.prototype.ViewModel ViewModel] to\na value in the  [can-view-scope scope].  If one value changes, the other value is updated.\n\nThe following two-way binds the `<edit-plate>` element’s `plateName` to the `editing.licensePlate`\nvalue in the scope.  This allows `plateName` to update if `editing.licensePlate` changes and\n`editing.licensePlate` to update if `plateName` changes.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/two-way.html'></div>\n\nThis demo can be expressed a bit easier with the references scope:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/reference.html'></div>\n\n## Initialization\n\nWhen a binding is being initialized, the behavior of what the viewModel and scope properties\nare set to depends on their initial values.\n\nIf the viewModel value is `not undefined` and the scope is `undefined`, scope will be set to the viewModel value.\n\nIf the viewModel value is `undefined` and the scope is `not undefined`, viewModel will be set to the scope value.\n\nIf both the viewModel and scope are `not undefined`, viewModel will be set to the scope value.\n\n",
    "description": "Two-way bind a value in the [can-component.prototype.view-model viewModel] or the element to the parent scope. \n",
    "title": "{(two-way)}",
    "name": "can-stache-bindings.legacy-twoWay",
    "type": "function",
    "parent": "can-stache-bindings.legacy-syntaxes",
    "order": 3,
    "signatures": [
      {
        "code": "{(child-prop)}=\"key\"",
        "description": "\n\n  Two-way binds `childProp` in the  [can-component.prototype.ViewModel ViewModel] to\n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n\n  ```\n  <my-component {(some-prop)}=\"value\"/>\n  ```\n\n  When setting up the binding:\n\n  - If `childProp` is `undefined`, `key` will be set to `childProp`.\n  - If `key` is `undefined`, `childProp` will be set to `key`.\n  - If both `childProp` and `key` are defined, `key` will be set to `childProp`.\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property of the viewModel to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
          }
        ]
      },
      {
        "code": "{($child-prop)}=\"key\"",
        "description": "\n\n  Two-way binds the element’s `childProp` property or attribute to\n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n\n  ```\n  <input {($value)}=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element’s property or attribute to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
    },
    "comment": " "
  },
  "can-stache.tags.comment": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/comment.md"
    },
    "body": "\n",
    "description": "A comment that doesn't get inserted into the rendered result. \n",
    "title": "{{!expression}}",
    "name": "can-stache.tags.comment",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 7,
    "signatures": [
      {
        "code": "{{!EXPRESSION}}",
        "description": "\n\nThe comment tag operates similarly to a `<!-- -->` tag in HTML. It exists in your template but never shows up.\n\n```\n{{!getFoo()}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be ignored.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be ignored.\n"
    }
  },
  "can-stache.helpers.else": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/else.md"
    },
    "body": "\n## Use\n\nFor more information on how `{{else}}` is used checkout:\n\n - [can-stache.helpers.if]\n - [can-stache.tags.section]\n\n",
    "description": "\n",
    "title": "{{else}}",
    "name": "can-stache.helpers.else",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 4,
    "signatures": [
      {
        "code": "{{#helper()}}BLOCK{{else}}INVERSE{{/helper}}",
        "description": "\n\nCreates an `inverse` block for a [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "A partial stache template\nconverted into a function and set as the [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "INVERSE",
      "description": "A partial stache template\nconverted into a function and set as the [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n"
    },
    "comment": " "
  },
  "can-stache.tags.escaped": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/escaped.md"
    },
    "body": "\n\n## Use\n\nThe following breaks down the behavior of `{{expression}}`.  It groups\nthe behavior of [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s\nbecause their behavior works the same way.  It then details how [can-stache/expressions/helper]s\nwork.\n\n### Key and Call Expressions\n\n`{{key}}` insert data into the template. It most commonly references\nvalues within the current context. For example:\n\nRendering:\n\n    <h1>{{name}}</h1>\n\nWith:\n\n    {name: \"Austin\"}\n\nResults in:\n\n    <h1>Austin</h1>\n\nIf the key value is a String or Number, it is inserted into the template.\nIf it is `null` or `undefined`, nothing is added to the template.\n\n\n### Nested Properties\n\nStache supports nested paths, making it possible to\nlook up properties nested deep inside the current context. For example:\n\nRendering:\n\n    <h1>{{book.author}}</h1>\n\nWith:\n\n    {\n      book: {\n        author: \"Ernest Hemingway\"\n      }\n    }\n\nResults in:\n\n    <h1>Ernest Hemingway</h1>\n\n### Looking up values in parent contexts\n\nSections and block helpers can create their own contexts. If a key's value\nis not found in the current context, it will look up the key's value\nin parent contexts. For example:\n\nRendering:\n\n    {{#chapters}}\n       <li>{{title}} - {{name}}</li>\n    {{chapters}}\n\nWith:\n\n    {\n      title: \"The Book of Bitovi\"\n      chapters: [{name: \"Breakdown\"}]\n    }\n\nResults in:\n\n    <li>The Book of Bitovi - Breakdown</li>\n\n## Helper expressions\n\nThe `{{helper}}` syntax is used to call out to stache [can-stache.helper helper functions] functions\nthat may contain more complex functionality. `helper` is a [can-stache.key key] that must match either:\n\n - a [can-stache.registerHelper registered helper function], or\n - a function in the current or parent [can-stache.scopeAndContext contexts]\n\nThe following example shows both cases.\n\nThe Template:\n\n    <p>{{greeting}} {{user}}</p>\n\nRendered with data:\n\n    {\n      user: function(){ return \"Justin\" }\n    }\n\nAnd a with a registered helper like:\n\n    stache.registerHelper('greeting', function(){\n      return \"Hello\"\n    });\n\nResults in:\n\n    <p>Hello Justin</p>\n\n### Arguments\n\nArguments can be passed from the template to helper function by\nlisting space seperated strings, numbers or other [can-stache.key keys] after the\n`helper` name.  For example:\n\nThe template:\n\n    <p>{{madLib \"Lebron James\" verb 4}}</p>\n\nRendered with:\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements:\n\n    stache.registerHelper('madLib',\n      function(subject, verb, number, options){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n    });\n\nIf an argument `key` value is a [can-map] property, the Observe's\nproperty is converted to a getter/setter [can-compute.computed]. For example:\n\nThe template:\n\n    <p>What! My name is: {{mr user.name}}</p>\n\nRendered with:\n\n    {user: new Map({name: \"Slim Shady\"})}\n\nNeeds the helper to check if name is a function or not:\n\n    stache.registerHelper('mr',function(name){\n      return \"Mr. \"+ (typeof name === \"function\" ?\n                      name():\n                      name)\n    })\n\nThis behavior enables two way binding helpers and is explained in more detail\non the [can-stache.helper helper functions] docs.\n\n### Hash\n\nIf enumerated arguments isn't an appropriate way to configure the behavior\nof a helper, it's possible to pass a hash of key-value pairs to the\n[can-stache.helperOptions helper option argument]'s\nhash object.  Properties and values are specified\nas `hashProperty=hashValue`.  For example:\n\nThe template:\n\n    <p>My {{excuse who=pet how=\"shreded\"}}</p>\n`\nAnd the helper:\n\n    stache.registerHelper(\"excuse\",function(options){\n      return [\"My\",\n        options.hash.who || \"dog\".\n        options.hash.how || \"ate\",\n        \"my\",\n        options.hash.what || \"homework\"].join(\" \")\n    })\n\nRender with:\n\n    {pet: \"cat\"}\n\nResults in:\n\n    <p>My cat shareded my homework</p>\n\n### Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create stache tags that have rich behavior. Read about it\non the [can-stache.helper helper function] page.\n\n",
    "description": "Insert the value of the expression into the output of the template.\n\n",
    "title": "{{expression}}",
    "name": "can-stache.tags.escaped",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 0,
    "signatures": [
      {
        "code": "{{EXPRESSION}}",
        "description": "\n\nGets the value of `EXPRESSION` and inserts the result into the output of the\ntemplate.\n\nIf the expression is clearly of a particular expression type like: `{{myHelper arg}}` or\n`{{myMethod(arg)}}`, that expression's rules will be followed.\n\nAn ambiguous expression type like `{{keyOrHelper}}` will first treat `keyOrHelper`\nas a [can-stache/expressions/key-lookup] and if there is no value in the scope of\n`keyOrHelper`, it will be treated as a [can-stache/expressions/helper].\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "expression",
            "description": "The `expression` can be:\n\n - [can-stache/expressions/literal] - `{{5}}` - Inserts a string representation of the literal.\n - [can-stache/expressions/key-lookup] - `{{key}}` - Looks up the value of `key` in the [can-view-scope].\n - [can-stache/expressions/call] - `{{method()}}` - Calls `method` in the [can-view-scope].\n - [can-stache/expressions/helper] - `{{helper arg}}` - Calls `helper` in the [can-view-scope.Options] and passes it a [can-stache.helperOptions].\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "expression",
      "description": "The `expression` can be:\n\n - [can-stache/expressions/literal] - `{{5}}` - Inserts a string representation of the literal.\n - [can-stache/expressions/key-lookup] - `{{key}}` - Looks up the value of `key` in the [can-view-scope].\n - [can-stache/expressions/call] - `{{method()}}` - Calls `method` in the [can-view-scope].\n - [can-stache/expressions/helper] - `{{helper arg}}` - Calls `helper` in the [can-view-scope.Options] and passes it a [can-stache.helperOptions].\n\n\n"
    },
    "comment": " "
  },
  "can-stache.tags.close": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/close.md"
    },
    "body": "",
    "description": "\n",
    "title": "{{/expression}}",
    "name": "can-stache.tags.close",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 4,
    "signatures": [
      {
        "code": "{{/helperKeyOrMethod}}",
        "description": "\n\nEnds a [can-stache.tags.section] block.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "helperKeyOrMethod",
            "description": "A name that matches the opening key, method or helper name. It's also possible to simply write `{{/}}` to end a block.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "helperKeyOrMethod",
      "description": "A name that matches the opening key, method or helper name. It's also possible to simply write `{{/}}` to end a block.\n"
    }
  },
  "can-stache.tags.inverse": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/inverse.md"
    },
    "body": "\n## Use\n\nInverted sections match falsey values. An inverted section\nsyntax is similar to regular sections except it begins with a caret\nrather than a pound. If the value referenced is falsey, the section\nwill render. For example:\n\n\nThe template:\n\n    <ul>\n        {{#friends}}\n            </li>{{name}}</li>\n        {{/friends}}\n        {{^friends}}\n            <li>No friends.</li>\n        {{/friends}}\n    </ul>\n\nAnd data:\n\n    {\n        friends: []\n    }\n\nResults in:\n\n\n    <ul>\n        <li>No friends.</li>\n    </ul>\n\n",
    "description": "Like [can-stache.tags.section], but renders the opposite subsection depending on the type of expression\nor the expression's return value.\n\n",
    "title": "{{^expression}}",
    "name": "can-stache.tags.inverse",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 5,
    "signatures": [
      {
        "code": "{{^EXPRESSION}}FN{{else}}INVERSE{{/key}}",
        "description": "\n\nWorks just like [can-stache.tags.section], but renders `INVERSE`\nwhen it would have rendered the `FN` block and vice-versa.\n\nFor example:\n\n```\n{{^ isOver18(person) }} Can't Vote {{/isOver18}}\n```\n\nRenders `Can't Vote` if `isOver18(person)` returns `falsey`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression type. Behavior depends on the type of expression:\n\n - [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s:\n   - renders `FN` with falsey values and empty lists.\n   - renders `INVERSE` with truthy values or each item in a list.\n - [can-stache/expressions/helper]s: switch the `options.fn` and `options.inverse`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression type. Behavior depends on the type of expression:\n\n - [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s:\n   - renders `FN` with falsey values and empty lists.\n   - renders `INVERSE` with truthy values or each item in a list.\n - [can-stache/expressions/helper]s: switch the `options.fn` and `options.inverse`.\n"
    },
    "comment": " "
  },
  "can-stache.tags.partial": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/partial.md"
    },
    "body": "\n\n## Use\n\nPartials are templates embedded in other templates.  Partials begin with a greater than sign, like `{{>my_partial}}`.  Partials inherit the calling scope.  \n\n\nPartials render at runtime, so recursive partials are possible but make sure you avoid infinite loops.\n\nPartials are typically registered [can-stache.registerPartial] like:\n\n```\nstache.registerPartial(\"address.stache\", \"<p>{{street}} {{city}}</p>\");\n```\n\nAnd called within another template like:\n\n```\nvar template = stache(\"{{#person.address}} {{>address.stache}} {{/person.address}}\");\n```\n\nWith data like `{person: {address: {street: \"123 Evergreen\", city: \"Chicago\"}}}`,\nrendering `template` would produce:\n\n```\n<p>123 Evergreen Chicago</p>\n```\n\nThe 2nd argument to `{{>key}}` can specify a different context for the partial to be rendered\nwith.  The following example renders the same thing as above:\n\n```\nvar template = stache(\"{{#person}} {{>address.stache address}} {{/person}}\");\n```\n\n\n\n## Functions as partials\n\n`{{>key}}` can be used to call [can-stache.renderer] functions in the scope.  For example:\n\n\n```\nDATA\n\t{\n\t\titem: {name: \"Justin\"},\n\t\tmyPartial: stache(\"{{name}}\")\n\t}\n\nTEMPLATE:\n    {{#item}}{{>myPartial}}{{/item}}\n\nRESULT:\n\tJustin\n```\n\n## Script tags as partials\n\n`{{>key}}` can be used to render the contents of script tags.\n\nFor example, if you've embedded a partial like:\n\n```\n<script type='text/stache' id='todo-stache'>\n  <li>{{name}}</li>\n</script>\n```\n\nThis can be rendered like:\n\n```\n{{#each(todos)}}{{>todo-stache}}{{/each}}\n```\n\n",
    "description": "\nRender another template within the current template.\n",
    "title": "{{>key}}",
    "name": "can-stache.tags.partial",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 6,
    "signatures": [
      {
        "code": "{{>key [EXPRESSION]}}",
        "description": "\n\nLooks up another template with `key` and renders it with the current scope or\n`EXPRESSION` added on top of the current scope.\n\n```js\nstache.registerPartial(\"address.stache\", \"<p>{{street}} {{city}}</p>\");\nvar template = stache(\"{{#each(people)}} {{>address.stache address}} {{/each}}\")\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A key used to lookup a\n[can-stache.renderer stache renderer function].   \n\nThe behavior is determined by what the key returns.  \n\nIf the key returns\na `function`, that function is used as the __renderer function__.  The __renderer function__\nis called with the current scope (or a scope modified by `EXPRESSION`) and the\nresult is inserted in place of the magic tag.\n\nIf the key returns a `string`, that string is used as the __renderer function name__.\nIf the key returns `undefined`, the key itself is used as the __renderer function name__.\n\nOnce the __renderer function name__ is known, the __renderer function__ is looked for\nby the same name.  A __renderer function__ is looked for in the following places:\n\n 1. In [can-view-scope.Options]'s `partials` property.\n 2. In partials registered with [can-stache.registerPartial].\n 3. For an element whose `id` matches __renderer function name__.  Its `innerHTML` will be converted to a template.\n\nThe __renderer function__\nis called with the current scope (or a scope modified by `EXPRESSION`) and the\nresult is inserted in place of the magic tag.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "An\noptional expression that adds a new context to the [can-view-scope] the template is\nrendered with.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "description": "An\noptional expression that adds a new context to the [can-view-scope] the template is\nrendered with.\n\n\n"
    },
    "comment": " "
  },
  "can-stache.tags.named-partial": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/named-partial.md"
    },
    "body": "\n\n## Use\n\nNamed partials are sub-templates in a larger template that aren’t rendered until referenced by the [can-stache.tags.partial partial tag]. They can be referenced any number of times with different contexts.\n\nGiven this data:\n\n```js\n{\n\tbusiness: {\n\t\tname: \"Bitvoi\",\n\t\taddress: { street: \"Hello\", city: \"World\" }\n\t},\n\tpeople: [\n\t\t{\n\t\t\tfullName: \"James Atherton\",\n\t\t\taddress: {\n\t\t\t\tstreet: \"123 45th Street\",\n\t\t\t\tcity: \"Moline\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tfullName: \"Someone Else\",\n\t\t\taddress: {\n\t\t\t\tstreet: \"678 90th St\",\n\t\t\t\tcity: \"Chicago\"\n\t\t\t}\n\t\t}\n\t]\n}\n```\n\nThis template:\n\n```handlebars\n{{<addressTemplate}}\n\t<div>{{street}}, {{city}}</div>\n{{/addressTemplate}}\n\n<div>\n\t{{#with(business.address)}}\n\t\t{{>addressTemplate}}\n\t{{/with}}\n</div>\n<ul>\n\t{{#each(business.people)}}\n\t\t<li>\n\t\t\t{{fullName}}\n\t\t\t{{>addressTemplate address}}\n\t\t</li>\n\t{{/each}}\n</ul>\n```\n\nWould result in:\n\n```html\n<div>\n\t<div>Hello, World</div>\n</div>\n<ul>\n\t\t<li>\n\t\t\tJames Atherton\n\t\t\t<div>123 45th Street, Moline</div>\n\t\t</li>\n\t\t<li>\n\t\t\tSomeone Else\n\t\t\t<div>678 90th St, Chicago</div>\n\t\t</li>\n</ul>\n```\n\nNamed partials can also have a template block that references its own name in a [can-stache.tags.partial partial tag], which creates recursion. (So make sure you avoid infinite loops!)\n\nGiven this data:\n\n```js\n{\n\tyayRecursion: {\n\t\tname: \"Root\",\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tname: \"Leaf #1 in Root\",\n\t\t\t\tnodes: []\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Branch under Root\",\n\t\t\t\tnodes: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"Leaf in Branch\",\n\t\t\t\t\t\tnodes: []\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"Leaf #2 in Root\",\n\t\t\t\tnodes: []\n\t\t\t}\n\t\t]\n\t}\n}\n```\n\nThis template:\n\n```handlebars\n{{<recursive}}\n\t<div>{{./name}} <b>Type:</b> {{#if(./nodes.length)}}Branch{{else}}Leaf{{/if}}</div>\n\t{{#each(./nodes)}}\n\t\t{{>recursive .}}\n\t{{/each}}\n{{/recursive}}\n\n{{>recursive yayRecursion}}\n```\n\nWould result in:\n\n```html\n<div>Root <b>Type:</b> Branch</div>\n<div>Leaf #1 in Root <b>Type:</b> Leaf</div>\n<div>Branch under Root <b>Type:</b> Branch</div>\n<div>Leaf in Branch <b>Type:</b> Leaf</div>\n<div>Leaf #2 in Root <b>Type:</b> Leaf</div>\n```\n\n## Too Much Recursion\n\nWhen working with recursive named partials, be aware that by default, expressions will walk up the context chain if the property is not found in the current context.\n\nSo if your data and template looks like this:\n\nGiven this data:\n\n```js\n{\n\tyayRecursion: {\n\t\tname: \"Root\",\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tname: \"Branch #1 in Root\",\n\t\t\t\tnodes: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"Problem Child\",\n\t\t\t\t\t\tnodes: undefined\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t]\n\t}\n}\n```\n\nThis template:\n\n```handlebars\n{{<recursive}}\n\t<div>{{name}} <b>Type:</b> {{#if(nodes.length)}}Branch{{else}}Leaf{{/if}}</div>\n\t{{#each(nodes)}}\n\t\t{{>recursive}}\n\t{{/each}}\n{{/recursive}}\n\n{{>recursive yayRecursion}}\n```\n\nWill recurse on `nodes` and your output will be something like this:\n\n```html\n<div>Root <b>Type:</b> Branch</div>\n<div>Branch #1 in Root <b>Type:</b> Leaf</div>\n<div>Problem Child <b>Type:</b> Branch</div>\n<div>Problem Child <b>Type:</b> Branch</div>\n<div>Problem Child <b>Type:</b> Branch</div>\n<div>Problem Child <b>Type:</b> Branch</div>\n...\n<div>Problem Child <b>Type:</b> Branch</div>\n(hangs from too much recursion)\n```\n\nThis is because when it’s rendering that named partial with “Problem Child” as the context, the template sees `nodes` here: `{{#each(nodes)}}`, then it checks the current context (Problem Child), doesn't find anything called `nodes`, then moves up the scope to its parent context to check for `nodes`. Since `nodes` is on the parent (and contains the Problem Child), it uses that for the `#each()` and you’re stuck in infinite recursion.\n\nTo avoid that, it’s best practice to always be specific about the context for your expressions within a named partial:\n\n```handlebars\n{{<recursive}}\n\t<div>{{./name}} <b>Type:</b> {{#if(./nodes.length)}}Branch{{else}}Leaf{{/if}}</div>\n\t{{#each(./nodes)}}\n\t\t{{>recursive .}}\n\t{{/each}}\n{{/recursive}}\n\n{{>recursive yayRecursion}}\n```\n\nwhich prevents the default behavior for expressions to look up the context chain.\n\n",
    "description": "\nCreate an inline named partial within the current template.\n",
    "title": "{{<partialName}}",
    "name": "can-stache.tags.named-partial",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 6,
    "signatures": [
      {
        "code": "{{<partialName}}BLOCK{{/partialName}}",
        "description": "\n\nCreates a reusable sub-template from `BLOCK` named `partialName` that can be rendered recursively or in the current scope using [can-stache.tags.partial {{>partialName}}].\n\n```handlebars\n{{<addressTemplate}}\n\t<div>{{street}}, {{city}}</div>\n{{/addressTemplate}}\n\n<div>\n\t{{#with(business.address)}}\n\t\t{{>addressTemplate}}\n\t{{/with}}\n</div>\n<ul>\n\t{{#each(business.people)}}\n\t\t<li>\n\t\t\t{{fullName}}, {{birthday}}\n\t\t\t{{>addressTemplate address}}\n\t\t</li>\n\t{{/each}}\n</ul>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "partialName",
            "description": "The name of the partial.   \n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "a template to be captured and rendered later.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "a template to be captured and rendered later.\n\n\n"
    },
    "comment": " "
  },
  "can-stache.tags.unescaped2": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/unescaped_amp.md"
    },
    "body": "",
    "description": "Insert the unescaped value of the expression into the output of the template.\n\n",
    "title": "{{&key}}",
    "name": "can-stache.tags.unescaped2",
    "type": "function",
    "hide": true,
    "parent": "can-stache.tags",
    "order": 2,
    "signatures": [
      {
        "code": "{{&key}}",
        "description": "\n\nThe `{{&key}}` tag is an alias for [can-stache.tags.unescaped {{{key}}}].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            },
            {
              "type": "*"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        },
        {
          "type": "*"
        }
      ],
      "description": "\n"
    }
  },
  "can-stache.tags.section": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/section.md"
    },
    "body": "\n\n## Use\n\nThe following breaks down the behavior of `{{#expression}}`.  It groups\nthe behavior of [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s\nbecause their behavior works the same way.  It then details how [can-stache/expressions/helper]s\nwork.\n\n\n## KeyLookup and Call expressions\n\nSections contain text blocks and evaluate whether to render it or not.  If\nthe object evaluates to an array it will iterate over it and render the block\nfor each item in the array.  There are four different types of sections.\n\n### Falseys or Empty Arrays\n\nIf the value returns a `false`, `undefined`, `null`, `\"\"` or `[]` we consider\nthat a *falsey* value.\n\nIf the value is falsey, the section will **NOT** render the block.\n\n    {\n      friends: false\n    }\n\n    {{#friends}}\n      Never shown!\n    {{/friends}}\n\n\n### Arrays\n\nIf the value is a non-empty array, sections will iterate over the\narray of items, rendering the items in the block.\n\nFor example, a list of friends will iterate\nover each of those items within a section.\n\n    {\n        friends: [\n            { name: \"Austin\" },\n            { name: \"Justin\" }\n        ]\n    }\n\n    <ul>\n        {{#friends}}\n            <li>{{name}}</li>\n        {{/friends}}\n    </ul>\n\nwould render:\n\n    <ul>\n        <li>Austin</li>\n        <li>Justin</li>\n    </ul>\n\nReminder: Sections will reset the current context to the value for which it is iterating.\nSee the [basics of contexts](#Basics) for more information.\n\n### Truthys\n\nWhen the value is a non-falsey object but not a list, it is considered truthy and will be used\nas the context for a single rendering of the block.\n\n    {\n        friends: { name: \"Jon\" }\n    }\n\n    {{#friends}}\n        Hi {{name}}\n    {{/friends}}\n\nwould render:\n\n    Hi Jon!\n\n## Helper expression\n\n\nA helper like:\n\n```js\nstache.registerHelper('countTo', function(number, options){\n    var out = [];\n    if(number > 0) {\n        for(var i =1; i <= number; i++){\n          var docFrag = options.fn({num: i});\n          out.push( docFrag );\n        }\n        return out;\n    } else {\n        return options.inverse({num: i});\n    }\n});\n```\n\nCould be called like:\n\n```\n<p>\n  {{#countTo number}}\n    {{num}}\n  {{else}}\n    Can't count to {{num}}!\n  {{/countTo}}\n</p>\n```\n\nCalled with data like:\n\n```js\n{number: 3}\n```\n\nProduces:\n\n```\n<p> 1 2 3 </p>\n```\n\nCalled with data like:\n\n```\n{number: -5}\n```\n\nProduces:\n\n```\n<p> Can't count to -5! </p>\n```\n\nNotice how `options` has `.fn` and `.inverse`.\n\n",
    "description": "\nRenders a subsection one or more times depending on the type of expression\nor the expression's return value.\n",
    "title": "{{#expression}}",
    "name": "can-stache.tags.section",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 3,
    "signatures": [
      {
        "code": "{{#KEY_EXPRESSION}}FN{{else}}INVERSE{{/KEY_EXPRESSION}}",
        "description": "\n\nRenders the `FN` or `INVERSE` section one or many times depending on\nthe value in `KEY_EXPRESSION`.\n\nIf `KEY_EXPRESSION` returns an  [can-util/js/is-array-like/is-array-like array like object],\nthe `FN` section will be rendered for each item in the array.  If the array like object is\nempty, the `INVERSE` section will be rendered. The [can-stache.helpers.each] helper\nshould generally be used for observable array-like objects as it has some performance\nadvantages.  \n\n```\n{{#items}}<li>{{name}}</li>{{/items}}\n```\n\nIf `KEY_EXPRESSION` returns a truthy value, the `FN` section will be rendered with\nthe truthy value.\n\nIf `KEY_EXPRESSION` returns a fasley value, the `INVERSE` section will be rendered with\nthe fasley value.\n\n```\n{{#address}} {{street}} {{city}} {{/address}}\n```\n\nThe closing tag can end with `{{/}}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              }
            ],
            "name": "KEY_EXPRESSION",
            "description": "A key expression.\nIf there is no value in the scope of `keyOrHelper`, it will be treated as a [can-stache/expressions/helper]."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n\n"
          }
        ]
      },
      {
        "code": "{{#CALL_EXPRESSION}}FN{{else}}INVERSE{{/CALL_EXPRESSION}}",
        "description": "\n\nWorks like `{{#KEY_EXPRESSION}}`, but uses the return value of\nthe `CALL_EXPRESSION`.\n\n```\n{{#getTasksForPerson(person)}}<li>{{name}}</li>{{/getTasksForPerson}}\n```\n\nTypically, the closing tag only include the method name and not its parameters.\n\nThe closing tag can end with `{{/}}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A function that\nwill be called with any specified arguments."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n\n"
          }
        ]
      },
      {
        "code": "{{#HELPER_EXPRESSION}}FN{{else}}INVERSE{{/HELPER_EXPRESSION}}",
        "description": "\n\nCalls a [can-stache.registerHelper registered helper] or a function in the\n[can-view-scope] with an additional [can-stache.helperOptions] argument\nthat can call the `FN` or `INVERSE` helpers to build the content that\nshould replace these tags.\n\n```\n<p>{{#countTo(number)}}{{num}}{{/countTo}}</p>\n```\n\nHelpers, with their direct access to subsection renderers and scope\nhave more control over template flow.  However, they are harder to test\nthan methods in the view model or model.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "HELPER_EXPRESSION",
            "description": "Calls a helper method\nor function in the [can-view-scope] with specified arguments."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "INVERSE",
      "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n"
    },
    "comment": " "
  },
  "can-stache.tags.unescaped": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/unescaped.md"
    },
    "body": "\n",
    "description": "Insert the unescaped value of the expression into the output of the template.\n\n",
    "title": "{{{expression}}}",
    "name": "can-stache.tags.unescaped",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 1,
    "signatures": [
      {
        "code": "{{{EXPRESSION}}}",
        "description": "\n\nBehaves just like [can-stache.tags.escaped] but does not\nescape the result.\n\n```js\n<div> {{{ toMarkdown(content) }}} </div>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression whose unescaped result is inserted into the page.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression whose unescaped result is inserted into the page.\n"
    }
  },
  "can-util/js/ajax/ajax": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/dom/ajax/ajax.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-ajax] instead. \n",
    "title": "ajax",
    "name": "can-util/js/ajax/ajax",
    "parent": "can-util/js"
  },
  "can-util/dom/attr/attr.special.focused": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr-special.focused.md"
    },
    "body": "\n```js\ndomAttr.get(input, \"focused\"); // -> false\n\ndomAttr.set(input, \"focused\", true);\ndomAttr.get(input, \"focused\"); // -> true\n```\n\n\n## One-way binding to set focus\n\nUse `focused` in event bindings to have a way to set focus to an input. In this example we are one-way binding to `focused` to a function that will recompute:\n\n```handlebars\n<input type=\"text\" {$focused}=\"isEditing()\" />\n\n<button></button>\n```\n\n```js\nvar ViewModel = DefineMap.extend({\n\tediting: {\n\t\tvalue: false\n\t},\n\tisEditing: function(){\n\t\treturn this.editing;\n\t}\n});\n\n...\n```\n\nIn this example whenever the `editing` property changes to `true`, `isEditing` will be reevaluated to `true` when will set focus on the input. You can imagine there might be some other use, such as a button, that triggers the editing status to change.\n\n## Two-way binding to focused\n\nAnother scenario is that you would like to know when an element is focused, perhaps to show a message (such as a tooltip) somewhere else in the DOM. The example below two-way binds to a boolean property on the ViewModel. When focus is set, the property is updated.\n\n<div class='demo_wrapper' data-demo-src='demos/can-util/input-focused.html'></div>\n\n",
    "description": "\nSignifies if an element, usually an `<input>` is the focused element on the page.\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "focused",
    "name": "can-util/dom/attr/attr.special.focused",
    "type": "property",
    "parent": "can-util/dom/attr/attr.special",
    "comment": " "
  },
  "can-util/dom/attr/attr.special": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr-special.md"
    },
    "body": "\n```js\nattr.special.foo = {\n\tget: function(){\n\t\treturn this.foo;\n\t},\n\tset: function(val){\n\t\tthis.foo = val;\n\t},\n\taddEventListener: function(){\n\t\t// Listen to this property changing some how\n\t}\n};\n```\n\nCanJS comes with a couple of special properties that can be used in bindings:\n\n* [can-util/dom/attr/attr.special.values]\n* [can-util/dom/attr/attr.special.focused]\n\n",
    "description": "\nAn object used to set up special properties. Each key on `attr.special` is a name of a property/attribute that has special behaviors when being get, set, or bound to.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "special",
    "name": "can-util/dom/attr/attr.special",
    "type": "property",
    "parent": "can-util/dom/attr/attr"
  },
  "can-util/dom/attr/attr.special.values": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr.special.values.md"
    },
    "body": "\n\nBinding to `values` in your [can-stache] template is useful to get a list of the selected values:\n\n```handlebars\n<select multiple values:bind=\"colors\">\n\t<option value=\"red\">Red</option>\n\t<option value=\"green\">Green</option>\n\t<option value=\"blue\">Blue</option>\n</select>\n```\n\nThis will two-way bind to a \"colors\" property in the ViewModel.\n\n",
    "description": "\nA special property that represents the selected values in a `<select>` element, usually a `<select multiple>`. The special property is needed because the DOM's native `value` property on a multiple select only gives you one of the selected options' values.\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "values",
    "name": "can-util/dom/attr/attr.special.values",
    "type": "property",
    "parent": "can-util/dom/attr/attr.special",
    "comment": " "
  },
  "can-util/dom/attr/attr": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr.md"
    },
    "body": "\n",
    "description": "\nA module that makes it easy to access attributes and properties of elements.\n",
    "type": "module",
    "title": "attr",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-util/dom/attr/attr",
    "parent": "can-util/dom"
  },
  "can-util/dom/child-nodes/child-nodes": {
    "type": "module",
    "name": "can-util/dom/child-nodes/child-nodes",
    "parent": "can-util/dom",
    "src": {
      "line": 2,
      "codeLine": 22,
      "path": "node_modules/can-util/dom/child-nodes/child-nodes.js"
    },
    "body": "",
    "description": "",
    "title": "child-nodes",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "childNodes(node)",
        "description": "\n\nGet all of the childNodes of a given node.\n\n```js\nvar stache = require(\"can-stache\");\nvar childNodes = require(\"can-util/child-nodes/child-nodes\");\n\nvar html = \"<div><h1><span></span></h1></div>\";\nvar frag = stache(html)();\n\nconsole.log(childNodes(frag)[0].nodeName); // -> DIV\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "node",
            "description": "The Node that you want child nodes for.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "node",
      "description": "The Node that you want child nodes for.\n"
    }
  },
  "can-util/dom/events/events": {
    "name": "can-util/dom/events/events",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 14,
      "codeLine": 23,
      "path": "node_modules/can-util/dom/events/events.js"
    },
    "body": "",
    "description": "Allows you to listen to a domEvent and special domEvents as well as dispatch domEvents. \n```js\nvar domEvents = require(\"can-util/dom/events/events\");\n```\n\n",
    "title": "events",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/data/data": {
    "name": "can-util/dom/data/data",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 22,
      "codeLine": 32,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "Allows associating data as a key/value pair for a particular DOM Node.\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n```\n\n",
    "title": "data",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/data/data.getCid": {
    "name": "can-util/dom/data/data.getCid",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 33,
      "codeLine": 40,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.getCid",
    "signatures": [
      {
        "code": "domData.getCid.call(el)",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The value of the element's unique CID\n\nReturn the previously set unique identifier for the dom node.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The value of the element's unique CID\n\nReturn the previously set unique identifier for the dom node.\n "
    }
  },
  "can-util/dom/data/data.cid": {
    "name": "can-util/dom/data/data.cid",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 41,
      "codeLine": 55,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "\nIf a unique cid value has not yet been set for this element, set it\nusing the [can-util/dom/data/data.expando expando] property.  Return the\nunique cid whether or not it is newly set\n \n",
    "description": "",
    "title": "domData.cid",
    "signatures": [
      {
        "code": "domData.cid.call(el)",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The value of the element's unique CID\n\nSet a unique identifier for the dom node, using the\n[can-util/dom/data/data.expando expando] property.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The value of the element's unique CID\n\nSet a unique identifier for the dom node, using the\n[can-util/dom/data/data.expando expando] property.\n"
    },
    "comment": " "
  },
  "can-util/dom/data/data.expando": {
    "name": "can-util/dom/data/data.expando",
    "type": "property",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 56,
      "codeLine": 62,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": " \n",
    "description": "\nThe key in which elements' cids are stored\n",
    "types": [],
    "title": "domData.expando"
  },
  "can-util/dom/data/data.clean": {
    "name": "can-util/dom/data/data.clean",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 63,
      "codeLine": 76,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.clean",
    "signatures": [
      {
        "code": "domData.clean.call(el, key)",
        "description": "\n\nRemove data from an element previously added by [can-util/dom/data/data.set set]\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n\ndomData.clean.call(el, \"metadata\");\n```\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/data/data.get": {
    "name": "can-util/dom/data/data.get",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 77,
      "codeLine": 91,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.get",
    "signatures": [
      {
        "code": "domData.get.call(el, key)",
        "description": "\n\nGet data that was stored in a DOM Node using the specified `key`.\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n\nvar metadata = domData.get.call(el, \"metadata\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A string used as a unique key for storing data associated with this DOM Node.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A string used as a unique key for storing data associated with this DOM Node.\n "
    }
  },
  "can-util/dom/data/data.set": {
    "type": "function",
    "name": "can-util/dom/data/data.set",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 92,
      "codeLine": 109,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.set",
    "signatures": [
      {
        "code": "domData.set.call(el, name, value)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "the key to store the value under"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "the value to store under the key\n\nSet data to be associated with a DOM Node using the specified `key`. If data already exists for this key, it will be overwritten.\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n\ndomData.set.call(el, \"metadata\", {\n  foo: \"bar\"\n});\n```\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "the value to store under the key\n\nSet data to be associated with a DOM Node using the specified `key`. If data already exists for this key, it will be overwritten.\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n\ndomData.set.call(el, \"metadata\", {\n  foo: \"bar\"\n});\n```\n "
    }
  },
  "can-util/dom/data/data.delete": {
    "name": "can-util/dom/data/data.delete",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 118,
      "codeLine": 130,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.delete",
    "signatures": [
      {
        "code": "domData.delete.call(el)",
        "description": "\n\nRemove all data for an element previously added by [can-util/dom/data/data.set set]\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n\ndomData.delete.call(el);\n```\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/dispatch/dispatch": {
    "type": "module",
    "name": "can-util/dom/dispatch/dispatch",
    "parent": "can-util/dom",
    "src": {
      "line": 4,
      "codeLine": 16,
      "path": "node_modules/can-util/dom/dispatch/dispatch.js"
    },
    "body": "",
    "description": "",
    "title": "dispatch",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "dispatch.call(el, event, args, bubbles)",
        "description": "\n\nDispatch an event on an element.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "An object specifies options applied to this event."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Arguments passed into this event."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "bubbles",
            "defaultValue": "true",
            "description": "Specifies whether this event should bubble (by default it will).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "bubbles",
      "defaultValue": "true",
      "description": "Specifies whether this event should bubble (by default it will).\n"
    }
  },
  "can-util/dom/class-name/class-name": {
    "name": "can-util/dom/class-name/class-name",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 12,
      "codeLine": 25,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "Allows querying and manipulation of classes on HTML elements \n```js\nvar className = require(\"can-util/dom/class-name/class-name\");\n\nvar fooDiv = document.createElement(\"div\");\nclassName.add(fooDiv, \"foo\");\nfooDiv.outerHTML; //-> '<div class=\"foo\"></div>'\n```\n\n",
    "title": "class-name",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/class-name/class-name.has": {
    "name": "can-util/dom/class-name/class-name.has",
    "type": "function",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 26,
      "codeLine": 43,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.has",
    "signatures": [
      {
        "code": "className.has.call(el, cls)",
        "description": "\n\nDetermine wheter a DOM node has a given class name.\n\n```js\nvar className = require(\"can-util/dom/class-name/class-name\");\n\nvar isContainer = className.has.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "true if the element's class attribute contains the token, false otherwise.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "true if the element's class attribute contains the token, false otherwise.\n "
    }
  },
  "can-util/dom/class-name/class-name.add": {
    "type": "function",
    "name": "can-util/dom/class-name/class-name.add",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 44,
      "codeLine": 61,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.add",
    "signatures": [
      {
        "code": "className.add.call(el, cls)",
        "description": "\n\nAdd a class name to a DOM node if it is not already there.\n\n```js\nvar className = require(\"can-util/dom/class-name/class-name\");\n\nclassName.add.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "void"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "void"
        }
      ],
      "description": "\n "
    }
  },
  "can-util/dom/class-name/class-name.remove": {
    "type": "function",
    "name": "can-util/dom/class-name/class-name.remove",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 69,
      "codeLine": 86,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.remove",
    "signatures": [
      {
        "code": "className.remove.call(el, cls)",
        "description": "\n\nRemove a class name from a DOM node if it exists on the node\n\n```js\nvar className = require(\"can-util/dom/class-name/class-name\");\n\nclassName.remove.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "void"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "void"
        }
      ],
      "description": "\n "
    }
  },
  "can-util/dom/frag/frag": {
    "type": "module",
    "name": "can-util/dom/frag/frag",
    "parent": "can-util/dom",
    "src": {
      "line": 7,
      "codeLine": 40,
      "path": "node_modules/can-util/dom/frag/frag.js"
    },
    "body": "\n\n## Use\n\nContentArrays can be used to combine multiple HTMLElements into a single document fragment.  For example:\n\n    var frag = require(\"can-util/dom/frag/frag\");\n\n    var p = document.createElement(\"p\");\n    p.innerHTML = \"Welcome to <b>CanJS</b>\";\n    var contentArray = [\"<h1>Hi There</h1>\", p];\n    var fragment = frag( contentArray )\n\n`fragment` will be a documentFragment with the following elements:\n\n    <h1>Hi There</h1>\n    <p>Welcome to <b>CanJS</b></p>\n\n \n",
    "description": "\nConvert a String, HTMLElement, documentFragment, or contentArray into a documentFragment.\n",
    "title": "frag",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "frag: function(item, doc)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "HTMLElement"
              },
              {
                "type": "documentFragment"
              },
              {
                "type": "contentArray"
              }
            ],
            "name": "item",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Document"
              }
            ],
            "name": "doc",
            "description": "an optional DOM document in which to build the fragment\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Document"
        }
      ],
      "name": "doc",
      "description": "an optional DOM document in which to build the fragment\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-util/js/document/document": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/dom/document/document.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-globals] instead. \n",
    "title": "document",
    "name": "can-util/js/document/document",
    "parent": "can-util/js"
  },
  "can-util/js/location/localtion": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/dom/location/location.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-globals] instead. \n",
    "title": "location",
    "name": "can-util/js/location/localtion",
    "parent": "can-util/js"
  },
  "can-util/js/mutation-observer/mutation-observer": {
    "src": {
      "line": 5,
      "codeLine": 11,
      "path": "node_modules/can-util/dom/mutation-observer/mutation-observer.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-globals] instead. \n",
    "title": "mutation-observer",
    "name": "can-util/js/mutation-observer/mutation-observer",
    "parent": "can-util/js"
  },
  "can-util/js/assign/assign": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/assign/assign.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-assign] instead. \n",
    "title": "assign",
    "name": "can-util/js/assign/assign",
    "parent": "can-util/js"
  },
  "can-util/dom/mutate/mutate": {
    "name": "can-util/dom/mutate/mutate",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 96,
      "codeLine": 113,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "Mutate an element by appending, inserting, and removing DOM nodes. Use this so that on the server \"inserted\" will be fired. \n```js\nvar mutate = require(\"can-util/dom/mutate/mutate\");\n\nvar el = document.createElement(\"div\");\n\nel.addEventListener(\"inserted\", function(){\n  console.log(\"Inserted was fired!\");\n});\n\nmutate.appendChild.call(document.body, el);\n```\n\n",
    "title": "mutate",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.appendChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.appendChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 114,
      "codeLine": 119,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "appendChild",
    "signatures": [
      {
        "code": "mutate.appendChild.call(el, child)",
        "description": "\nUsed to append a node to an element and trigger the \"inserted\" event on all of the newly inserted children. Since `mutated` takes an array we convert the child to an array, or in the case of a DocumentFragment we first convert the childNodes to an array and call inserted on those.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.insertBefore": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.insertBefore",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 133,
      "codeLine": 138,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "insertBefore",
    "signatures": [
      {
        "code": "mutate.insertBefore.call(el, ref, child)",
        "description": "\nLike mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"inserted\" event.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.removeChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.removeChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 152,
      "codeLine": 157,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "removeChild",
    "signatures": [
      {
        "code": "mutate.removeChild.call(el, child)",
        "description": "\nLike mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"removed\" event.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.replaceChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.replaceChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 165,
      "codeLine": 170,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "replaceChild",
    "signatures": [
      {
        "code": "mutate.replaceChild.call(el, child)",
        "description": "\nLike mutate.appendChild and mutate.removeChild, used to replace a node with another node and trigger \"removed\" on the removed element and \"inserted\" on the inserted elements.\n ",
        "params": []
      }
    ]
  },
  "can-util/js/assign-non-enumerable/assign-non-enumerable": {
    "type": "module",
    "name": "can-util/js/assign-non-enumerable/assign-non-enumerable",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 28,
      "path": "node_modules/can-util/js/assign-non-enumerable/assign-non-enumerable.js"
    },
    "body": "",
    "description": "",
    "title": "assign-non-enumerable",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "assignNonEnumerable(target, source)",
        "description": "\n\nA simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument\nand makes all assigned properties non enumerable and writable.\n\n```js\nvar assignNonEnumerable = require(\"can-util/js/assign-non-enumerable/assign-non-enumerable\");\n\nvar obj = {};\n\nassignNonEnumerable(obj, {\n  foo: \"bar\"\n});\n\nconsole.log(obj.foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The destination object. This object's properties will be mutated based on the object provided as `source`."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "The source object whose own properties will be applied to `target`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the `target` argument.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "The source object whose own properties will be applied to `target`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the `target` argument.\n"
    }
  },
  "can-util/js/base-url/base-url": {
    "src": {
      "line": 5,
      "codeLine": 25,
      "path": "node_modules/can-util/js/base-url/base-url.js"
    },
    "type": "module",
    "body": "",
    "description": "",
    "title": "base-url",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/base-url/base-url",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "baseUrl(optionalBaseUrlToSet)",
        "description": "\n\nGet and/or set the \"base\" (containing path) of the document.\n\n```js\nvar baseUrl = require(\"can-util/js/base-url/base-url\");\n\nconsole.log(baseUrl());           // -> \"http://localhost:8080\"\nconsole.log(baseUrl(baseUrl() + \"/foo/bar\")); // -> \"http://localhost:8080/foo/bar\"\nconsole.log(baseUrl());           // -> \"http://localhost:8080/foo/bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "setUrl",
            "description": "An optional base url to override reading the base URL from the known path.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the set or computed base URL\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "setUrl",
      "description": "An optional base url to override reading the base URL from the known path.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the set or computed base URL\n"
    }
  },
  "can-util/js/cid/cid": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/cid/cid.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-cid] instead. \n",
    "title": "cid",
    "name": "can-util/js/cid/cid",
    "parent": "can-util/js"
  },
  "can-util/js/cid-set/cid-set": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/cid-set/cid-set.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-cid/set/set] instead. \n",
    "title": "cid-set",
    "name": "can-util/js/cid-set/cid-set",
    "parent": "can-util/js"
  },
  "can-util/js/cid-map/cid-map": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/cid-map/cid-map.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-cid/map/map] instead. \n",
    "title": "cid-map",
    "name": "can-util/js/cid-map/cid-map",
    "parent": "can-util/js"
  },
  "can-util/js/deep-assign/deep-assign": {
    "src": {
      "path": "node_modules/can-util/js/deep-assign/deep-assign.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "deep-assign",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/deep-assign/deep-assign",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "deepAssign(target, [ ... sources ])",
        "description": "\n\nAssign properties from a source object to a target object, deeply copying properties that are objects or arrays.\n\n```js\nvar deepAssign = require(\"can-util/js/deep-assign/deep-assign\");\n\nvar dest = deepAssign({}, {\n  obj: {\n\t\tfoo: \"bar\"\n\t}\n}, {\n  arr: [{ hello: \"world\" }]\n});\n\nconsole.log(dest.obj.foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The target object who's properties will be assigned from the source objects."
          },
          {
            "variable": true,
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "Source objects from which properties will be assigned to the `target` object. Sources will be copied deeply; meaning any object or array properties will be traversed and copied (like a clone).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "variable": true,
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "Source objects from which properties will be assigned to the `target` object. Sources will be copied deeply; meaning any object or array properties will be traversed and copied (like a clone).\n"
    }
  },
  "can-util/js/dev/dev": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-dev] instead. \n",
    "title": "dev",
    "name": "can-util/js/dev/dev",
    "parent": "can-util/js"
  },
  "can-util/js/deparam/deparam": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/deparam/deparam.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-deparam] instead. \n",
    "title": "deparam",
    "name": "can-util/js/deparam/deparam",
    "parent": "can-util/js"
  },
  "can-util/js/diff-object/diff-object": {
    "type": "module",
    "name": "can-util/js/diff-object/diff-object",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 30,
      "path": "node_modules/can-util/js/diff-object/diff-object.js"
    },
    "body": "",
    "description": "",
    "title": "diff-object",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "diffObject(oldObject, newObject)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "oldObject",
            "description": "the object to diff from"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "newObject",
            "description": "the object to diff to"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "an array of object-patch objects\n\nFind the differences between two objects, based on properties and values\n\nThe object-patch object format has the following keys:\n- **property**: the property key on the new object\n- **type**:     the type of operation on this property: add, remove, or set\n- **value**:    the new value (if type is \"add\" or \"set\")\n\n```js\nvar diffObject = require(\"can-util/js/diff-object/diff-object\");\n\nconsole.log(diffObject({a: 1, b: 2}, {b: 3, c: 4})); // ->\n  [{property: \"a\", type: \"remove\"},\n   {property: \"b\", type: \"set\": value: 3},\n   {property: \"c\", type: \"add\", \"value\": 4}]\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "newObject",
      "description": "the object to diff to"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "an array of object-patch objects\n\nFind the differences between two objects, based on properties and values\n\nThe object-patch object format has the following keys:\n- **property**: the property key on the new object\n- **type**:     the type of operation on this property: add, remove, or set\n- **value**:    the new value (if type is \"add\" or \"set\")\n\n```js\nvar diffObject = require(\"can-util/js/diff-object/diff-object\");\n\nconsole.log(diffObject({a: 1, b: 2}, {b: 3, c: 4})); // ->\n  [{property: \"a\", type: \"remove\"},\n   {property: \"b\", type: \"set\": value: 3},\n   {property: \"c\", type: \"add\", \"value\": 4}]\n```\n"
    }
  },
  "can-util/js/diff/diff": {
    "name": "can-util/js/diff/diff",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 40,
      "codeLine": 73,
      "path": "node_modules/can-util/js/diff/diff.js"
    },
    "body": "",
    "description": "",
    "title": "diff",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "diff( oldList, newList, [identity] )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "oldList",
            "description": "the array to diff from"
          },
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "newList",
            "description": "the array to diff to"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "identity",
            "description": "an optional identity function for comparing elements"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a list of Patch objects representing the differences\n\nReturns the difference between two ArrayLike objects (that have nonnegative\ninteger keys and the `length` property) as an array of patch objects.\n\nA patch object returned by this function has the following properties:\n- **index**:  the index of newList where the patch begins\n- **deleteCount**: the number of items deleted from that index in newList\n- **insert**: an Array of items newly inserted at that index in newList\n\n```js\nvar diff = require(\"can-util/js/diff/diff\");\n\nconsole.log(diff([1], [1, 2])); // -> [{index: 1, deleteCount: 0, insert: [2]}]\nconsole.log(diff([1, 2], [1])); // -> [{index: 1, deleteCount: 1, insert: []}]\n\n// with an optional identity function:\ndiff(\n    [{id:1},{id:2}],\n    [{id:1},{id:3}],\n    (a,b) => a.id === b.id\n); // -> [{index: 1, deleteCount: 1, insert: [{id:3}]}]\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "identity",
      "description": "an optional identity function for comparing elements"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a list of Patch objects representing the differences\n\nReturns the difference between two ArrayLike objects (that have nonnegative\ninteger keys and the `length` property) as an array of patch objects.\n\nA patch object returned by this function has the following properties:\n- **index**:  the index of newList where the patch begins\n- **deleteCount**: the number of items deleted from that index in newList\n- **insert**: an Array of items newly inserted at that index in newList\n\n```js\nvar diff = require(\"can-util/js/diff/diff\");\n\nconsole.log(diff([1], [1, 2])); // -> [{index: 1, deleteCount: 0, insert: [2]}]\nconsole.log(diff([1, 2], [1])); // -> [{index: 1, deleteCount: 1, insert: []}]\n\n// with an optional identity function:\ndiff(\n    [{id:1},{id:2}],\n    [{id:1},{id:3}],\n    (a,b) => a.id === b.id\n); // -> [{index: 1, deleteCount: 1, insert: [{id:3}]}]\n```\n"
    }
  },
  "can-util/js/defaults/defaults": {
    "type": "module",
    "name": "can-util/js/defaults/defaults",
    "parent": "can-util/js",
    "src": {
      "line": 3,
      "codeLine": 28,
      "path": "node_modules/can-util/js/defaults/defaults.js"
    },
    "body": "",
    "description": "",
    "title": "defaults",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "defaults(target, [ ... sources])",
        "description": "\n\nMimics [_.defaults](https://lodash.com/docs/4.16.2#defaults). Assigns first level properties in sources from left to\nright if they are not already defined.\n\n```js\nvar defaults = require(\"can-util/js/defaults/defaults\");\n\nvar obj = {a: 1, b: 2};\nvar src = {b: 3, c: 3};\n\nassign(obj, src, {a: 2, d: 4});\n\nconsole.log(obj); // -> {a: 1, b: 2, c: 3, d: 4}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The destination object. This object's properties will be mutated based on the objects provided as [ ... sources]."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "variable": true,
            "name": "sources",
            "description": "The source objects whose own properties will be applied to `target`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the `target` argument.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "variable": true,
      "name": "sources",
      "description": "The source objects whose own properties will be applied to `target`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the `target` argument.\n"
    }
  },
  "can-util/js/get/get": {
    "type": "module",
    "name": "can-util/js/get/get",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 23,
      "path": "node_modules/can-util/js/get/get.js"
    },
    "body": "",
    "description": "\n",
    "title": "get",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "get(obj, path)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to use as the root for property based navigation"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "path",
            "description": "a String of dot-separated keys, representing a path of properties"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value at the property path\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the object passed.\n\n```js\nvar get = require(\"can-util/js/get/get\");\nconsole.log(get({a: {b: {c: \"foo\"}}}, \"a.b.c\")); // -> \"foo\"\nconsole.log(get({a: {}}, \"a.b.c\")); // -> undefined\nconsole.log(get([{a: {}}, {a: {b: \"bar\"}}], \"a.b\")); // -> \"bar\"\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "path",
      "description": "a String of dot-separated keys, representing a path of properties"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value at the property path\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the object passed.\n\n```js\nvar get = require(\"can-util/js/get/get\");\nconsole.log(get({a: {b: {c: \"foo\"}}}, \"a.b.c\")); // -> \"foo\"\nconsole.log(get({a: {}}, \"a.b.c\")); // -> undefined\nconsole.log(get([{a: {}}, {a: {b: \"bar\"}}], \"a.b\")); // -> \"bar\"\n```\n"
    }
  },
  "can-util/js/global/global": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/global/global.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-globals] instead. \n",
    "title": "global",
    "name": "can-util/js/global/global",
    "parent": "can-util/js"
  },
  "can-util/js/import/import": {
    "type": "module",
    "name": "can-util/js/import/import",
    "parent": "can-util/js",
    "src": {
      "line": 5,
      "codeLine": 23,
      "path": "node_modules/can-util/js/import/import.js"
    },
    "body": "",
    "description": "",
    "title": "import",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "importModule(moduleName, parentName)",
        "description": "\n\n```js\nvar importModule = require(\"can-util/js/import/import\");\n\nimportModule(\"foo.stache\").then(function(){\n  // module was imported\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "moduleName",
            "description": "The module to be imported."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "parentName",
            "description": "A parent module that will be used as a reference for resolving relative module imports."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that will resolve when the module has been imported.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "parentName",
      "description": "A parent module that will be used as a reference for resolving relative module imports."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that will resolve when the module has been imported.\n"
    }
  },
  "can-util/js/each/each": {
    "src": {
      "path": "node_modules/can-util/js/each/each.md"
    },
    "body": "",
    "description": "\n",
    "type": "module",
    "title": "each",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/each/each",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "each(elements, callback, context)",
        "description": "\n\nA generic iterator function that can be used to iterate over both Array-Like and object data structure. Array-Like data structures are iterated by their numerical index. Objects are iterated by their named properties, i.e. in each stage of iteration the each function emits the key and its corresponding value.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "ArrayLike"
              }
            ],
            "optional": true,
            "name": "elements",
            "description": "the object or Array-Like elements to iterate over"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "element"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "key"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "elements"
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "callback",
            "description": "the function that would be executed in each iteration"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "the context object\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "ArrayLike"
            }
          ],
          "description": "the original elements\n\n```js\n var each = require(\"can-util/js/each/each\");\n \n each([2,1,0], function(i) { console.log(this[i]); }, [4,5,6]); // -> 6 \\n 5 \\n 4\n each({foo: 'bar', abc: 'xyz'}, function(val, key) {\n   console.log(key + ': ' + val);\n }); // -> \"foo: bar\" \\n \"abc: xyz\"\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "context",
      "description": "the context object\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "ArrayLike"
        }
      ],
      "description": "the original elements\n\n```js\n var each = require(\"can-util/js/each/each\");\n \n each([2,1,0], function(i) { console.log(this[i]); }, [4,5,6]); // -> 6 \\n 5 \\n 4\n each({foo: 'bar', abc: 'xyz'}, function(val, key) {\n   console.log(key + ': ' + val);\n }); // -> \"foo: bar\" \\n \"abc: xyz\"\n```\n"
    }
  },
  "can-util/js/is-browser-window/is-browser-window": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/is-browser-window/is-browser-window.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-globals] instead. \n",
    "title": "is-browser-window",
    "name": "can-util/js/is-browser-window/is-browser-window",
    "parent": "can-util/js"
  },
  "can-util/js/is-empty-object/is-empty-object": {
    "type": "module",
    "name": "can-util/js/is-empty-object/is-empty-object",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 29,
      "path": "node_modules/can-util/js/is-empty-object/is-empty-object.js"
    },
    "body": "",
    "description": "",
    "title": "is-empty-object",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isEmptyObject(obj)",
        "description": "\n\nUsed to determine if an object is an empty object (an object with no enumerable properties) such as `{}`.\n\n```js\nvar isEmptyObject = require(\"can-util/js/is-empty-object/is-empty-object\");\n\nconsole.log(isEmptyObject({})); // -> true\n\nconsole.log(isEmptyObject({ a: 1 })); // -> false\n\nvar obj = {};\nObject.defineProperty(obj, \"foo\", {\n    enumerable: false,\n    value: \"bar\"\n});\nconsole.log(isEmptyObject(obj)); // -> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "Any object."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is an object with no enumerable properties.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "Any object."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is an object with no enumerable properties.\n"
    }
  },
  "can-util/js/is-array-like/is-array-like": {
    "src": {
      "path": "node_modules/can-util/js/is-array-like/is-array-like.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "is-array-like",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-array-like/is-array-like",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isArrayLike(obj)",
        "description": "\n\nDetermines if an object is \"array like\", meaning it can be looped over. Any object with a `.length` property is array like.\n\n```js\nvar isArrayLike = require(\"can-util/js/is-array-like/is-array-like\");\n\n// Arrays\nconsole.log(isArrayLike([{ foo: \"bar\" }])); // -> true\n\n// Strings\nconsole.log(isArrayLike(\"some string\")); // -> true\n\n// Objects with .length property\nconsole.log(isArrayLike({ length: 11 })); // -> true\n\n// Numbers and Booleans are not.\nconsole.log(isArrayLike(true)); // -> false\nconsole.log(isArrayLike(13)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "Any object type."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True, if the object is similar to an array.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "Any object type."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True, if the object is similar to an array.\n"
    }
  },
  "can-util/js/is-function": {
    "type": "module",
    "name": "can-util/js/is-function",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 20,
      "path": "node_modules/can-util/js/is-function/is-function.js"
    },
    "body": "",
    "description": "\n",
    "title": "/is-function is-function",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isFunction(value)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "the item to test for being a function"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the provided argument is a function.\n\n```js\nvar isFunction = require(\"can-util/js/is-function/is-function\");\n\nconsole.log(isFunction(function(){})); // -> true\n\nconsole.log(isFunction({})); // -> false\n```\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "the item to test for being a function"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the provided argument is a function.\n\n```js\nvar isFunction = require(\"can-util/js/is-function/is-function\");\n\nconsole.log(isFunction(function(){})); // -> true\n\nconsole.log(isFunction({})); // -> false\n```\n\n"
    }
  },
  "can-util/js/is-promise/is-promise": {
    "type": "module",
    "name": "can-util/js/is-promise/is-promise",
    "parent": "can-util/js",
    "src": {
      "line": 3,
      "codeLine": 24,
      "path": "node_modules/can-util/js/is-promise/is-promise.js"
    },
    "body": "",
    "description": "",
    "title": "is-promise",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isPromise(obj)",
        "description": "\n\nDetermines if object is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar isPromise = require(\"can-util/js/is-promise/is-promise\");\n\nvar promise = new Promise(function(resolve){\n  resolve();\n});\n\nconsole.log(isPromise(promise)); // -> true\nconsole.log(isPromise(\"foo bar\")); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be tested."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be tested."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a Promise.\n"
    }
  },
  "can-util/js/is-plain-object/is-plain-object": {
    "src": {
      "path": "node_modules/can-util/js/is-plain-object/is-plain-object.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "is-plain-object",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-plain-object/is-plain-object",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isPlainObject(obj)",
        "description": "\n\nAttempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:\n\n1. Objects with prototypes (created using the `new` keyword).\n2. Booleans.\n3. Numbers.\n4. NaN.\n\n```js\nvar isPlainObject = require(\"can-util/js/is-plain-object/is-plain-object\");\n\n// Created with {}\nconsole.log(isPlainObject({})); // -> true\n\n// new Object\nconsole.log(isPlainObject(new Object())); // -> true\n\n// Custom object\nvar Ctr = function(){};\nvar obj = new Ctr();\n\nconsole.log(isPlainObject(obj)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-util/js/is-node/is-node": {
    "type": "module",
    "name": "can-util/js/is-node/is-node",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 20,
      "path": "node_modules/can-util/js/is-node/is-node.js"
    },
    "body": "",
    "description": "Determines if your code is running in [Node.js](https://nodejs.org). ",
    "title": "is-node",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isNode()",
        "description": "\n\n```js\nvar isNode = require(\"can-util/js/is-node/is-node\");\nvar GLOBAL = require(\"can-globals/global/global\");\n\nif(isNode()) {\n  console.log(GLOBAL() === global); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if running in Node.js\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if running in Node.js\n"
    }
  },
  "can-util/js/is-promise-like/is-promise-like": {
    "type": "module",
    "name": "can-util/js/is-promise-like/is-promise-like",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 24,
      "path": "node_modules/can-util/js/is-promise-like/is-promise-like.js"
    },
    "body": "",
    "description": "",
    "title": "is-promise-like",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isPromiseLike(obj)",
        "description": "\n\nDetermines if an object is \"Then-able\".\nAlso see `isPromise(obj)` which checks for a standard [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar isPromiseLike = require(\"can-util/js/is-promise-like/is-promise-like\");\n\nvar promise = new Promise(function(resolve){\n  resolve();\n});\n\nconsole.log(isPromiseLike(promise)); // -> true\nconsole.log(isPromiseLike(\"foo bar\")); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be tested."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be tested."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a Promise.\n"
    }
  },
  "can-util/js/is-web-worker/is-web-worker": {
    "body": "",
    "description": "Determines if the code is running with a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers). ",
    "type": "module",
    "title": "is-web-worker",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-web-worker/is-web-worker",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isWebWorker()",
        "description": "\n\n```js\nvar isWebWorker = require(\"can-util/js/is-web-worker/is-web-worker\");\nvar GLOBAL = require(\"can-globals/global/global\");\n\nif(isWebWorker()) {\n  console.log(GLOBAL() === self); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if running in a Web Worker.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if running in a Web Worker.\n"
    }
  },
  "can-util/js/is-string/is-string": {
    "type": "module",
    "name": "can-util/js/is-string/is-string",
    "parent": "can-util/js",
    "src": {
      "line": 5,
      "codeLine": 28,
      "path": "node_modules/can-util/js/is-string/is-string.js"
    },
    "body": "",
    "description": "",
    "title": "is-string",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isString(obj)",
        "description": "\n\n**Deprecated**:\nThis method is will be removed in can-util 4.0.\nUse `typeof obj === 'string'` instead of `isString(obj)`.\n\nDetermines if the provided argument is a string.\n\n```js\nvar isString = require(\"can-util/js/is-string/is-string\");\n\nconsole.log(isString(\"foo\")); // -> true\nconsole.log(isString(String(\"foo\")); // -> true\n\nconsole.log(isString({})); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "An object to test if is a string."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "An object to test if is a string."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a string.\n"
    }
  },
  "can-util/js/make-map/make-map": {
    "type": "module",
    "name": "can-util/js/make-map/make-map",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 19,
      "path": "node_modules/can-util/js/make-map/make-map.js"
    },
    "body": "",
    "description": "",
    "title": "make-map",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeMap( string )",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "string",
            "description": "A comma separated list of values"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A JavaScript object with the same keys as the passed-in comma-separated values\n\nmakeMap takes a comma-separated string (can-list, NodeList, etc.) and converts it to a JavaScript object\n\n```\nvar makeMap = require(\"can-util/js/make-map/make-map\");\n\nmakeMap(\"a,b,c\"); //-> { a: true, b: true, c: true }\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "string",
      "description": "A comma separated list of values"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A JavaScript object with the same keys as the passed-in comma-separated values\n\nmakeMap takes a comma-separated string (can-list, NodeList, etc.) and converts it to a JavaScript object\n\n```\nvar makeMap = require(\"can-util/js/make-map/make-map\");\n\nmakeMap(\"a,b,c\"); //-> { a: true, b: true, c: true }\n```\n"
    }
  },
  "can-util/js/join-uris/join-uris": {
    "src": {
      "path": "node_modules/can-util/js/join-uris/join-uris.md"
    },
    "body": "",
    "description": "Join together a URI path to a base. ",
    "type": "module",
    "title": "join-uris",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/join-uris/join-uris",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "joinURIs(base, href)",
        "description": "\n\nProvides a convenient way to join together URIs handling relative paths.\n\n```js\nvar joinURIs = require(\"can-util/js/join-uris\");\n\nvar base = \"http://example.com/some/long/path\";\nvar href = \"../../images/foo.png\";\n\nvar res = joinURIs(base, href);\n\nconsole.log(res); // -> http://example.com/images/foo.png\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "base",
            "description": ""
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "href",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The result of joining the two parts.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "href",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The result of joining the two parts.\n"
    }
  },
  "can-util/js/log/log": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/log/log.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-log] instead. \n",
    "title": "log",
    "name": "can-util/js/log/log",
    "parent": "can-util/js"
  },
  "can-util/js/make-array/make-array": {
    "type": "module",
    "name": "can-util/js/make-array/make-array",
    "parent": "can-util/js",
    "src": {
      "line": 5,
      "codeLine": 21,
      "path": "node_modules/can-util/js/make-array/make-array.js"
    },
    "body": "",
    "description": "",
    "title": "make-array",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeArray(element)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "element",
            "description": "any array-like or object data structure"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a JavaScript array object with the same elements as the passed-in ArrayLike\n\nmakeArray takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array\n\n```\nvar makeArray = require(\"can-util/js/make-array/make-array\");\n\nmakeArray({0: \"a\", length: 1}); //-> [\"a\"]\n\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ArrayLike"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "element",
      "description": "any array-like or object data structure"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a JavaScript array object with the same elements as the passed-in ArrayLike\n\nmakeArray takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array\n\n```\nvar makeArray = require(\"can-util/js/make-array/make-array\");\n\nmakeArray({0: \"a\", length: 1}); //-> [\"a\"]\n\n```\n"
    }
  },
  "can-util/js/make-promise/make-promise": {
    "name": "can-util/js/make-promise/make-promise",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 22,
      "path": "node_modules/can-util/js/make-promise/make-promise.js"
    },
    "body": "",
    "description": "",
    "title": "make-promise",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makePromise(obj)",
        "description": "\n\nWill make isPromiseLike object into [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar makePromise = require(\"can-util/js/make-promise/make-promise\");\n\nvar obj = {};\nvar promise = makePromise(obj);\n\nconsole.log(isPromise(promise)); // -> true\nconsole.log(isPromise(obj)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be made into Promise."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "the object as a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be made into Promise."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "the object as a Promise.\n"
    }
  },
  "can-util/js/omit/omit": {
    "type": "module",
    "name": "can-util/js/omit/omit",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 24,
      "path": "node_modules/can-util/js/omit/omit.js"
    },
    "body": "",
    "description": "",
    "title": "omit",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "omit(source, propsToOmit)",
        "description": "\n\nOmit properties from an object.\n\n```js\nvar omit = require(\"can-util/js/omit/omit\");\n\nvar obj = { a: 1, b: 2, c: 3, d: 4};\n\nvar newObj = omit(obj, [ 'b', 'd' ]);\n\nconsole.log(newObj); // -> { a: 1, c: 3 }\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "The source object whose non-omitted properties will be uses to source the result."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "propsToOmit",
            "description": "List of properties to omit from the result.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns a new object with all of the properties from `source` that were not omitted.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "propsToOmit",
      "description": "List of properties to omit from the result.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns a new object with all of the properties from `source` that were not omitted.\n"
    }
  },
  "can-util/js/param/param": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/param/param.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-param] instead. \n",
    "title": "param",
    "name": "can-util/js/param/param",
    "parent": "can-util/js"
  },
  "can-util/js/parse-uri/parse-uri": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/parse-uri/parse-uri.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-parse-uri] instead. \n",
    "title": "parse-uri",
    "name": "can-util/js/parse-uri/parse-uri",
    "parent": "can-util/js"
  },
  "can-util/js/set-immediate/set-immediate": {
    "type": "module",
    "name": "can-util/js/set-immediate/set-immediate",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 12,
      "path": "node_modules/can-util/js/set-immediate/set-immediate.js"
    },
    "body": "",
    "description": "",
    "title": "set-immediate",
    "signatures": [
      {
        "code": "setImmediate(function())",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "cb",
            "description": "\n\nPolyfill for setImmediate() if it doesn't exist in the global context\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "cb",
      "description": "\n\nPolyfill for setImmediate() if it doesn't exist in the global context\n"
    }
  },
  "can-util/js/string/string": {
    "name": "can-util/js/string/string",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 12,
      "codeLine": 18,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "String utilities used by CanJS libraries \n",
    "title": "string",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/js/string/string.esc": {
    "type": "function",
    "name": "can-util/js/string/string.esc",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 50,
      "codeLine": 62,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.esc",
    "signatures": [
      {
        "code": "string.esc(content)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "content",
            "description": "a string"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the string safely HTML-escaped\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nstring.esc(\"<div>&nbsp;</div>\"); //-> \"&lt;div&gt;&amp;nbsp;&lt;/div&gt;\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "content",
      "description": "a string"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the string safely HTML-escaped\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nstring.esc(\"<div>&nbsp;</div>\"); //-> \"&lt;div&gt;&amp;nbsp;&lt;/div&gt;\"\n```\n "
    }
  },
  "can-util/js/string/string.getObject": {
    "type": "function",
    "name": "can-util/js/string/string.getObject",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 70,
      "codeLine": 97,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.getObject",
    "signatures": [
      {
        "code": "string.getObject(name, roots)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "a String of dot-separated keys, representing a path of properties"
          },
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "roots",
            "description": "the object to use as the root for property based navigation"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value at the property path descending from `roots`\n\nReturn the result of descending the path `name` through the properties of the object or objects\n`roots`\n\nIf `roots` is an Array, each element of the array is evaluated, in order, until\nthe path is found in an element's properties (and properties-of-properties, etc.).  Otherwise\n`roots` is evaluated as the root object, returning either the object at the property path\ndescended from `roots` or `undefined` if any subpath is not found.\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the first object in `roots`\nif it's an array, `roots` itself otherwise.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.getObject(\"a.b.c\", {a: {b: {c: \"foo\"}}})); // -> \"foo\"\nconsole.log(string.getObject(\"a.b.c\", {a: {}})); // -> undefined\nconsole.log(string.getObject(\"a.b\", [{a: {}}, {a: {b: \"bar\"}}])); // -> \"bar\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "roots",
      "description": "the object to use as the root for property based navigation"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value at the property path descending from `roots`\n\nReturn the result of descending the path `name` through the properties of the object or objects\n`roots`\n\nIf `roots` is an Array, each element of the array is evaluated, in order, until\nthe path is found in an element's properties (and properties-of-properties, etc.).  Otherwise\n`roots` is evaluated as the root object, returning either the object at the property path\ndescended from `roots` or `undefined` if any subpath is not found.\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the first object in `roots`\nif it's an array, `roots` itself otherwise.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.getObject(\"a.b.c\", {a: {b: {c: \"foo\"}}})); // -> \"foo\"\nconsole.log(string.getObject(\"a.b.c\", {a: {}})); // -> undefined\nconsole.log(string.getObject(\"a.b\", [{a: {}}, {a: {b: \"bar\"}}])); // -> \"bar\"\n```\n "
    }
  },
  "can-util/js/string/string.capitalize": {
    "type": "function",
    "name": "can-util/js/string/string.capitalize",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 114,
      "codeLine": 127,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.capitalize",
    "signatures": [
      {
        "code": "string.capitalize(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "s",
            "description": "the string to capitalize"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with the first character uppercased if it is a letter\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.capitalize(\"foo\")); // -> \"Foo\"\nconsole.log(string.capitalize(\"123\")); // -> \"123\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "s",
      "description": "the string to capitalize"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with the first character uppercased if it is a letter\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.capitalize(\"foo\")); // -> \"Foo\"\nconsole.log(string.capitalize(\"123\")); // -> \"123\"\n```\n "
    }
  },
  "can-util/js/string/string.camelize": {
    "type": "function",
    "name": "can-util/js/string/string.camelize",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 132,
      "codeLine": 145,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.camelize",
    "signatures": [
      {
        "code": "string.camelize(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "the string to camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with hyphens removed and following letters capitalized.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\nconsole.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "the string to camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with hyphens removed and following letters capitalized.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\nconsole.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n```\n "
    }
  },
  "can-util/js/string/string.hyphenate": {
    "type": "function",
    "name": "can-util/js/string/string.hyphenate",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 151,
      "codeLine": 164,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.hyphenate",
    "signatures": [
      {
        "code": "string.hyphenate(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string in camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with camelCase converted to hyphen-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\nconsole.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "a string in camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with camelCase converted to hyphen-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\nconsole.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n```\n "
    }
  },
  "can-util/js/string/string.underscore": {
    "type": "function",
    "name": "can-util/js/string/string.underscore",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 171,
      "codeLine": 184,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.underscore",
    "signatures": [
      {
        "code": "string.underscore(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string in camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with camelCase converted to underscore-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\nconsole.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "a string in camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with camelCase converted to underscore-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\nconsole.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n```\n "
    }
  },
  "can-util/js/string/string.sub": {
    "type": "function",
    "name": "can-util/js/string/string.sub",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 191,
      "codeLine": 208,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.sub",
    "signatures": [
      {
        "code": "string.sub(str, data, remove)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string with {curly brace} delimited property names"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "an object from which to read properties"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "null"
            }
          ],
          "description": "the supplied string with delimited properties replaced with their values\n                      if all properties exist on the object, null otherwise\n\nIf `remove` is true, the properties found in delimiters in `str` are removed from `data`.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.sub(\"foo_{bar}\", {bar: \"baz\"}})); // -> \"foo_baz\"\nconsole.log(string.sub(\"foo_{bar}\", {})); // -> null\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "data",
      "description": "an object from which to read properties"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "null"
        }
      ],
      "description": "the supplied string with delimited properties replaced with their values\n                      if all properties exist on the object, null otherwise\n\nIf `remove` is true, the properties found in delimiters in `str` are removed from `data`.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.sub(\"foo_{bar}\", {bar: \"baz\"}})); // -> \"foo_baz\"\nconsole.log(string.sub(\"foo_{bar}\", {})); // -> null\n```\n "
    }
  },
  "can-util/js/string/string.strReplacer": {
    "name": "can-util/js/string/string.strReplacer",
    "type": "property",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 232,
      "codeLine": 237,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": " \n",
    "description": "\nThe regex used to find replacement sections in [can-util/js/string/string.sub string.sub]\n",
    "types": [
      {
        "type": "RegExp"
      }
    ],
    "title": "string.strReplacer"
  },
  "can-util/js/string/string.strUndHash": {
    "name": "can-util/js/string/string.strUndHash",
    "type": "property",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 238,
      "codeLine": 243,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": " \n",
    "description": "\nA regex which matches an underscore or hyphen character\n",
    "types": [
      {
        "type": "RegExp"
      }
    ],
    "title": "string.strUndHash"
  },
  "_validate": {
    "type": "function",
    "name": "_validate",
    "params": [],
    "parent": "node_modules/can-validate-legacy/map/validate/validate.js",
    "src": {
      "line": 151,
      "codeLine": 157,
      "path": "node_modules/can-validate-legacy/map/validate/validate.js"
    },
    "body": "",
    "description": "Runs validation on the entire map instance. Actual behavior of \"validate all\" is defined by the registered shim (`validate`).\n\n",
    "title": "_Validate",
    "hide": true
  },
  "_validateOne": {
    "type": "function",
    "name": "_validateOne",
    "params": [
      {
        "types": [
          {
            "type": "object"
          }
        ],
        "name": "item",
        "description": "A key/value object"
      },
      {
        "types": [
          {
            "type": "object"
          }
        ],
        "name": "opts",
        "description": "Object that contains validation config."
      }
    ],
    "parent": "node_modules/can-validate-legacy/map/validate/validate.js",
    "src": {
      "line": 176,
      "codeLine": 192,
      "path": "node_modules/can-validate-legacy/map/validate/validate.js"
    },
    "body": "",
    "description": "Main method used by `Map.define` setter when a property changes.  Runs validation on a property. Actual behavior of \"validate one\" is defined\n by the registered shim (`once`).\n\n It also handles setting the errors property on the map instance and then\nmanages the errors for the current property within the errors object.\n\n",
    "title": "Validate One",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "object"
        }
      ],
      "name": "opts",
      "description": "Object that contains validation config."
    },
    "returns": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "True if method found that the property can be saved; if\n validation fails and the property must validate (`mustValidate` property),\n this will be `false`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "True if method found that the property can be saved; if\n validation fails and the property must validate (`mustValidate` property),\n this will be `false`.\n"
    }
  },
  "_processValidateOpts": {
    "type": "function",
    "name": "_processValidateOpts",
    "params": [
      {
        "types": [
          {
            "type": "object"
          }
        ],
        "name": "itemObj",
        "description": "Property to validate"
      },
      {
        "types": [
          {
            "type": "object"
          }
        ],
        "name": "opts",
        "description": "Map of validation options\n"
      }
    ],
    "parent": "node_modules/can-validate-legacy/map/validate/validate.js",
    "src": {
      "line": 223,
      "codeLine": 235,
      "path": "node_modules/can-validate-legacy/map/validate/validate.js"
    },
    "body": "",
    "description": "Allows the ability to pass computes in validation properties, this allows for things like making a property required based on the value on\nanother property.\n\nProcesses validation options, creates computes from functions and adds\nlisteners to computes.\n",
    "title": "Process Validate Opts",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "object"
        }
      ],
      "name": "opts",
      "description": "Map of validation options\n"
    }
  },
  "can-util/js/string-to-any/string-to-any": {
    "src": {
      "path": "node_modules/can-util/js/string-to-any/string-to-any.md"
    },
    "body": "",
    "description": "Turns a string representation of a primitive type back into the associated primitive. \n",
    "type": "module",
    "title": "string-to-any",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/string-to-any/string-to-any",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "stringToAny(string)",
        "description": "\n\nExamines the provided string to see if it can be converted to a primitive type. Supported arguments are:\n\n* \"true\"\n* \"false\"\n* \"null\"\n* \"undefined\"\n* \"NaN\"\n* \"Infinity\"\n* Any [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)\n* Any [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)\n\n```js\nvar stringToAny = require(\"can-util/js/string-to-any/string-to-any\");\n\nstringToAny(\"NaN\"); // -> NaN\nstringToAny(\"44.4\"); // -> 44.4\nstringToAny(\"false\"); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "string",
            "description": "A string to convert back to its primitive type.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The primitive representation of the provided string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "string",
      "description": "A string to convert back to its primitive type.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The primitive representation of the provided string.\n"
    }
  },
  "can-util/js/types/types": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-types] instead. \n",
    "title": "types",
    "name": "can-util/js/types/types",
    "parent": "can-util/js"
  },
  "can-zone/debug.DebugInfo": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/debuginfo.md"
    },
    "body": "",
    "description": "An array of objects containing information useful for debugging. Gives you the name of the **task** that failed to complete and a **stack** trace of where the error occured. \nEach object has a shape of:\n\n```js\n{\n\t\"task\": \"setTimeout\",\n\t\"stack\": Error ....\"\n}\n```\n\n",
    "type": "typedef",
    "title": "DebugInfo",
    "types": [
      {
        "type": "Array",
        "template": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ],
        "options": [
          {
            "name": "task",
            "description": "An identifier of the task that failed to complete. This can be any of the [asynchronous tasks](https://github.com/canjs/can-zone#tasks) supported by can-zone like `setTimeout` or `Promise`.\n\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "stack",
            "description": "A stack trace taken as a snapshot when the task was called. This allows you t see the source of the call to help debug why the task never completed.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/debug.DebugInfo",
    "parent": "can-zone/debug"
  },
  "can-zone/debug": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/debug.md"
    },
    "body": "\n## Use\n\nThe **debug** zone gives you information about which tasks failed to complete in case of a timeout. It is to be used with [./timeout.md](can-zone/timeout).\n\nWhen a timeout occurs the debug Zone will appending debug information to the Zone's [data](https://github.com/canjs/can-zone/blob/master/docs/data.md) property, which can be retrieved when the Zone's promise is rejected:\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nvar zone = new Zone(debug(5000);\n\nzone.run(function(){\n\n\tsetTimeout(function(){}, 10000);\n\n}).catch(err){\n\n\tvar debugInfo = zone.data.debugInfo;\n\n});\n```\n\n## DebugInfo\n\nThe **DebugInfo** is an array of objects that contain information about which tasks failed to complete. Each object has a shape of:\n\n```js\n{\n\t\"task\": \"setTimeout\",\n\t\"stack\": Error ....\"\n}\n```\n\n### DebugInfo[].task\n\nA *string* identifier of the task that failed to complete. This can be any of the [asynchronous tasks](https://github.com/canjs/can-zone#tasks) supported by can-zone like `setTimeout` or `Promise`.\n\n### DebugInfo[].stack\n\nA *string* stack trace taken as a snapshot when the task was called. This allows you t see the source of the call to help debug why the task never completed.\n\n## debug(timeout)\n\nCreate a debug Zone by passing the debug function a timeout in milliseconds:\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nnew Zone({\n\tplugins: [\n\t\tdebug(5000)\n\t]\n});\n```\n\n## debug(timeoutZone)\n\nCreate a debug Zone by passing in a timeout Zone that was already created:\n\n```js\nvar timeout = require(\"can-zone/timeout\");\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nvar timeoutZone = timeout(5000);\nvar debugZone = debug(timeoutZone);\n\nnew Zone({\n\tplugins: [\n\t\ttimeoutZone,\n\t\tdebugZone\n\t]\n});\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-zone/debug",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone/debug",
    "parent": "can-zone.plugins",
    "signatures": [
      {
        "code": "debug(ms)",
        "description": "\n\nCreates a new [can-zone.ZoneSpec] that can be provided to your Zone, timing out in `ms` (milliseconds).\n\n```js\nvar Zone = require(\"can-zone\");\nvar debug = require(\"can-zone/debug\");\n\nvar zone = new Zone({\n\tplugins: [debug(5000)]\n})\n.catch(function(err){\n\tvar info = zone.data.debugInfo;\n});\n```\n\nSee the [can-zone/debug.DebugInfo] type for a list of properties \n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "ms",
            "description": "The timeout, in milliseconds, before the [can-zone Zone] will be rejected and debug information attached to the [can-zone.prototype.data zone's data] object.\n"
          }
        ]
      },
      {
        "code": "debug(timeoutZone)",
        "description": "\n\nLike the previous signature, but directly pass it a [can-zone/timeout timeout ZoneSpec] object that you create yourself.\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar timeoutZone = timeout(5000);\nvar debugZone = debug(timeoutZone):\n\n...\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-zone/timeout"
              }
            ],
            "name": "timeoutZone",
            "description": "A [can-zone.ZoneSpec] created using the timeout plugin.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-zone/timeout"
        }
      ],
      "name": "timeoutZone",
      "description": "A [can-zone.ZoneSpec] created using the timeout plugin.\n"
    },
    "comment": " "
  },
  "can-zone/timeout": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/timeout.md"
    },
    "body": "\n## Use\n\nThe timeout zone allows you to specify a timeout for your Zone. If the Zone promise doesn't resolve before timing out, the Zone promise will be rejected by the plugin.\n\nThe **timeout** zone is a function that takes a timeout in milliseconds.\n\nThe Promise will reject with a special type of Error, a [can-zone/timeout.TimeoutError].\n\n```js\nvar Zone = require(\"can-zone\");\nvar timeout = require(\"can-zone/timeout\");\nvar TimeoutError = timeout.TimeoutError;\n\nvar zone = new Zone({\n\tplugins: [\n\t\ttimeout(2000)\n\t]\n});\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\n\t}, 5000);\n\n}).then(null, function(err){\n\n\t// err.timeout -> 2000\n\n});\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-zone/timeout",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "ms"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/timeout",
    "parent": "can-zone.plugins",
    "signatures": [
      {
        "code": "timeout(ms)",
        "description": "\n\nCreates a [can-zone.ZoneSpec] that you can use as a plugin for your [can-zone Zone] in order to timeout after a certain length of time (as `ms`).\n\nIf the Zone times out it's [can-zone.prototype.run run promise] will be rejected with a [can-zone/timeout.TimeoutError], a special error that also includes the number of milliseconds waited before timing out.\n\n```js\nvar Zone = require(\"can-zone\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar zone = new Zone({\n\tplugins: [ timeout(5000) ]\n});\n\nzone.run(function(){\n\tsetTimeout(function(){\n\n\t}, 10000); // waiting over 5 sec\n})\n.catch(function(err){\n\t// Called because we exceeded the timeout.\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "ms",
            "description": "The number of milliseconds to wait before timing out the [can-zone Zone].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-zone.ZoneSpec"
            }
          ],
          "description": "A ZoneSpec that can be passed as a plugin.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "ms",
      "description": "The number of milliseconds to wait before timing out the [can-zone Zone].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        }
      ],
      "description": "A ZoneSpec that can be passed as a plugin.\n"
    },
    "comment": " "
  },
  "can-zone/timeout.TimeoutError": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/timeouterror.md"
    },
    "body": "\n",
    "description": "A special type of Error that also includes the number of milliseconds that were waited before timing out. \nThe error object is included with the timeout module:\n\n```js\nvar timeout = require(\"can-zone/timeout\");\n\nvar TimeoutError = timeout.TimeoutError;\n// Maybe use this to check `instanceof`.\n```\n\n",
    "type": "typedef",
    "title": "TimeoutError",
    "types": [
      {
        "type": "Error",
        "options": [
          {
            "name": "timeout",
            "description": "Specifies the timeout that was exceeded.\n",
            "types": [
              {
                "type": "Number"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/timeout.TimeoutError",
    "parent": "can-zone/timeout"
  },
  "guides/recipes/credit-card-advanced": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/credit-card-advanced/credit-card-advanced.md"
    },
    "body": "\nIn this guide you will learn how to:\n\n- Use Kefir streams.\n- Use the event-reducer pattern.\n- Handle promises (and side-effects) with streams.\n\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/riyuzuh/1/embed?output\">JS Bin on jsbin.com</a>\n\nTo use the widget:\n\n1. __Enter__ a _Card Number_, _Expiration Date_, and _CVC_.\n2. __Click__ on the form so those inputs lose focus.  The\n   _Pay_ button should become enabled.\n3. __Click__ the _Pay_ button to see the __Pay__ button disabled for 2 seconds.\n4. __Change__ the inputs to invalid values.  An error message should appear,\n   the invalid inputs should be highlighted red, and the _Pay_\n   button should become disabled.\n\n__START THIS TUTORIAL BY CLONING THE FOLLOWING JS Bin__:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/socozi/2/embed?output\">JS Bin on jsbin.com</a>\n\nThis JS Bin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\nThe following sections are broken down into:\n\n- __The problem__ — A description of what the section is trying to accomplish.\n- __What you need to know__ — Information about CanJS that is useful for solving the problem.\n- __The solution__ — The solution to the problem.\n\n\nThe following video walks through the entire guide:\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/UA4606-W3Sg\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n## Setup\n\n### The problem\n\nWe are going to try an alternate form of the basic CanJS setup.  We\nwill still have a [can-stache] `payment-view` and render it with a\n`viewModel`.  But the `viewModel` should be a plain JavaScript object\nwhose properties are all [Kefir.js](https://rpominov.github.io/kefir/)\nstreams.\n\nWe will render the static content in a template, but use a\nconstant stream to hold the `amount` value.\n\n\n### What you need to know\n\n- [Kefir.js](https://rpominov.github.io/kefir/) allows you to create streams\n  of events and transform those streams into other streams. For example,\n  the following `numbers` stream produces three numbers with interval of 100 milliseconds:\n\n  ```js\n  var numbers = Kefir.sequentially(100, [1, 2, 3]);\n  ```\n\n  Now let's create another stream based on the first one. As you might guess, it will produce 2, 4, and 6.\n\n  ```js\n  var numbers2 = numbers.map(x => x * 2);\n  ```\n- Kefir supports both streams and properties.  It's worth reading [Kefir's documentation on the difference between streams and properties](https://rpominov.github.io/kefir/#about-observables).  In short:\n  - Properties retain their value\n  - Streams do not\n- [Kefir.constant](https://rpominov.github.io/kefir/#constant) creates a property with the specified value:\n  ```\n  var property = Kefir.constant(1);\n  ```\n\n- [can-kefir] integrates streams into CanJS, including [can-stache]\n  templates.  Output the value of a stream like:\n\n  ```\n  {{stream.value}}\n  ```\n\n  Or the error like:\n\n  ```\n  {{stream.error}}\n  ```\n\n### The solution\n\nUpdate the __HTML__ tab to:\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Credit Card Form\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n<script type='text/stache' id=\"app-view\">\n<form>\n\n  <input type='text' name='number' placeholder='Card Number'/>\n\n  <input type='text' name='expiry' placeholder='MM-YY'/>\n\n  <input type='text' name='cvc' placeholder='CVC'/>\n\n  <button>Pay ${{amount.value}}</button>\n\n</form>\n</script>\n\n<script src=\"https://rpominov.github.io/kefir/dist/kefir.min.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.stripe.com/v2/\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='10-22,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar viewModel = {\n\tamount: Kefir.constant(1000)\n};\n\nvar view = can.stache.from(\"app-view\");\n\ndocument.body.appendChild( view(viewModel) );\n\n```\n<span line-highlight='1-7,only'></span>\n\n\n## Read the card number\n### The problem\n\nUsers will be able to enter a card number like `1234-1234-1234-1234`.\n\nLets read the card number entered by the user, print it back,\nand also print back the cleaned card number (the entered number with no dashes).\n\n### What you need to know\n\n- [can-kefir] adds a [can-kefir/emitterProperty] method that returns a\n  Kefir property, but also adds an `emitter` object with with `.value()` and `.error()` methods. The end result is a single object that has methods of a stream and property access to its emitter methods.\n\n  ```js\n  var Kefir = require(\"can-kefir\");\n\n  var age = Kefir.emitterProperty();\n\n  age.onValue(function(age){\n    console.log(age)\n  });\n\n  age.emitter.value(20) //-> logs 20\n\n  age.emitter.value(30) //-> logs 30\n  ```\n\n  `emitterProperty` property streams are useful data sinks when getting\n  user data.\n\n- Kefir streams and properties have a [map](https://rpominov.github.io/kefir/#map) method\n  that maps values on one stream to values in a new stream:\n\n  ```js\n  var source = Kefir.sequentially(100, [1, 2, 3]);\n  var result = source.map(x => x + 1);\n  // source: ---1---2---3X\n  // result: ---2---3---4X\n  ```\n\n- `<input on:input:value:to=\"KEY\"/>` Listens to the `input` events produced\n  by the `<input>` element and writes the `<input>`'s value to `KEY`.\n- [can-kefir] allows you to write to a `emitterProperty`'s with:\n  ```\n  <input value:to=\"emitterProperty.value\"/>\n  ```\n\n### The solution\n\nUpdate the view in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n<form>\n\n  User Entered: {{userCardNumber.value}},\n  Card Number: {{cardNumber.value}}\n\n  <input type='text' name='number' placeholder='Card Number'\n    on:input:value:to=\"userCardNumber.value\"/>\n\n  <input type='text' name='expiry' placeholder='MM-YY'/>\n\n  <input type='text' name='cvc' placeholder='CVC'/>\n\n  <button>Pay ${{amount.value}}</button>\n\n</form>\n</script>\n\n```\n<span line-highlight='4-8,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar viewModel = {\n\tamount: Kefir.constant(1000),\n\n\tuserCardNumber: Kefir.emitterProperty()\n};\n\nviewModel.cardNumber = viewModel.userCardNumber.map((card) => {\n\tif (card) {\n\t\treturn card.replace(/[\\s-]/g, \"\");\n\t}\n});\n\nvar view = can.stache.from(\"app-view\");\n\ndocument.body.appendChild( view(viewModel) );\n\n```\n<span line-highlight='4,7-11,only'></span>\n\n\n\n## Output the card error ##\n### The problem\n\nAs someone types a card number, lets show the user a warning message\nabout what they need to enter for the card number. It should go away\nif the card number is 16 characters.\n\n\n### What you need to know\n\n- Add the `cardError` message above the input like:\n  ```html\n  <div class=\"message\">{{cardError.value}}</div>\n  ```\n\n- Validate a card with:\n  ```js\n  function validateCard(card) {\n    if (!card) {\n        return \"There is no card\"\n    }\n    if (card.length !== 16) {\n        return \"There should be 16 characters in a card\";\n    }\n  }\n  ```\n\n### The solution\n\nUpdate the view in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n<form>\n\n  <div class=\"message\">{{cardError.value}}</div>\n\n  <input type='text' name='number' placeholder='Card Number'\n    on:input:value:to=\"userCardNumber.value\"/>\n\n  <input type='text' name='expiry' placeholder='MM-YY'/>\n\n  <input type='text' name='cvc' placeholder='CVC'/>\n\n  <button>Pay ${{amount.value}}</button>\n\n</form>\n</script>\n\n```\n<span line-highlight='4,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar viewModel = {\n\tamount: Kefir.constant(1000),\n\n\tuserCardNumber: Kefir.emitterProperty()\n};\n\nviewModel.cardNumber = viewModel.userCardNumber.map((card) => {\n\tif (card) {\n\t\treturn card.replace(/[\\s-]/g, \"\");\n\t}\n});\nviewModel.cardError = viewModel.cardNumber.map(validateCard);\n\nvar view = can.stache.from(\"app-view\");\n\ndocument.body.appendChild( view(viewModel) );\n\n// HELPER FUNCTIONS\nfunction validateCard(card) {\n\tif (!card) {\n\t\treturn \"There is no card\"\n\t}\n\tif (card.length !== 16) {\n\t\treturn \"There should be 16 characters in a card\";\n\t}\n}\n\n```\n<span line-highlight='12,19-26,only'></span>\n\n\n## Only show the card error when blurred ##\n### The problem\n\nLets only show the cardNumber error if the user blurs the\ncard number input. Once the user blurs, we will update the card number error,\nif there is one, on every keystroke.\n\nWe should also add `class='is-error'` to the input when it has an error.\n\nFor this to work, we will need to track if the user has blurred\nthe input in a `userCardNumberBlurred` `emitterProperty`.\n\n### What you need to know\n\n- We can call an `emitterProperty`'s value in the template when something happens like:\n  ```html\n  <div on:click=\"emitterProperty.emitter.value(true)\">\n  ```\n- One of the most useful patterns in constructing streams is the event-reducer\n  pattern. On a high-level it involves making streams events, and using those\n  events to update a stateful object.\n\n  For example, we might have a `first` and a `last` stream:\n\n  ```js\n  var first = Kefir.sequentially(100, [\"Justin\", \"Ramiya\"])\n  var last = Kefir.sequentially(100, [\"Shah\", \"Meyer\"]).delay(50);\n  // first: ---Justin---RamiyaX\n  // last:  ------Shah__---Meyer_X\n  ```\n\n  We can promote these to event-like objects with `.map`:\n\n  ```js\n  var firstEvents = first.map( (first) => {\n      return {type: \"first\", value: first}\n  })\n  var lastEvents = first.map( (last) => {\n      return {type: \"last\", value: last}\n  })\n  // firstEvents: ---{t:\"f\"}---{t:\"f\"}X\n  // lastEvents:  ------{t:\"l\"}---{t:\"l\"}X\n  ```\n\n  Next, we can merge these into a single stream:\n\n  ```js\n  var merged = Kefir.merge([firstEvents,lastEvents])\n  // merged: ---{t:\"f\"}-{t:\"l\"}-{t:\"f\"}-{t:\"l\"}X\n  ```\n\n  We can \"reduce\" (or `.scan`) these events based on a previous\n  state. The following copies the old state and updates it using the event\n  data:\n\n  ```js\n  var state = merged.scan((previous, event) => {\n    var copy = Object.assign({}, previous);\n    copy[event.type] = event.value;\n\t return copy;\n  }, {first: \"\", last: \"\"});\n  // state: ---{first:\"Justin\", last:\"\"}\n  //          -{first:\"Justin\", last:\"Shah\"}\n  //          -{first:\"Ramiya\", last:\"Shah\"}\n  //          -{first:\"Ramiya\", last:\"Meyer\"}X\n  ```\n\n  The following is a more common structure for the reducer pattern:\n\n  ```js\n  var state = merged.scan((previous, event) => {\n      switch( event.type ) {\n        case \"first\":\n          return Object.assign({}, previous,{\n            first: event.value\n          });\n        case \"last\":\n          return Object.assign({}, previous,{\n            last: event.value\n          });\n        default:\n          return previous;\n      }\n  }, {first: \"\", last: \"\"})\n  ```\n\n  Finally, we can map this state to another value:\n\n  ```js\n  var fullName = state.map( (state) => state.first +\" \"+ state.last );\n  // fullName: ---Justin\n  //             -Justin Shah\n  //             -Ramiya Shah\n  //             -Ramiya MeyerX\n  ```\n\n  > NOTE: `fullName` can be derived more simply from `Kefir.combine`. The reducer\n  > pattern is used here for illustrative purposes. It is able to support a larger\n  > set of stream transformations than `Kefir.combine`.\n\n- On any stream, you can call `stream.toProperty()` to return a property that\n  will retain its values. This can be useful if you want a stream's immediate value.\n\n### The solution\n\nUpdate the view in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n<form>\n\n  {{#if showCardError.value}}\n    <div class=\"message\">{{cardError.value}}</div>\n  {{/if}}\n\n  <input type='text' name='number' placeholder='Card Number'\n\ton:input:value:to=\"userCardNumber.value\"\n    on:blur=\"userCardNumberBlurred.emitter.value(true)\"\n\t{{#if showCardError.value}}class='is-error'{{/if}}/>\n\n  <input type='text' name='expiry' placeholder='MM-YY'/>\n\n  <input type='text' name='cvc' placeholder='CVC'/>\n\n  <button>Pay ${{amount.value}}</button>\n\n</form>\n</script>\n\n```\n<span line-highlight='4-11,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar viewModel = {\n\tamount: Kefir.constant(1000),\n\n\tuserCardNumber: Kefir.emitterProperty(),\n\tuserCardNumberBlurred: Kefir.emitterProperty()\n};\n\nviewModel.cardNumber = viewModel.userCardNumber.map((card) => {\n\tif (card) {\n\t\treturn card.replace(/[\\s-]/g, \"\");\n\t}\n});\nviewModel.cardError = viewModel.cardNumber.map(validateCard).toProperty();\nviewModel.showCardError = showOnlyWhenBlurredOnce(viewModel.cardError, viewModel.userCardNumberBlurred);\n\nvar view = can.stache.from(\"app-view\");\n\ndocument.body.appendChild( view(viewModel) );\n\n// HELPER FUNCTIONS\nfunction validateCard(card) {\n\tif (!card) {\n\t\treturn \"There is no card\"\n\t}\n\tif (card.length !== 16) {\n\t\treturn \"There should be 16 characters in a card\";\n\t}\n}\n\nfunction showOnlyWhenBlurredOnce(errorStream, blurredStream) {\n\tvar errorEvent = errorStream.map((error) => {\n\t\tif (!error) {\n\t\t\treturn {\n\t\t\t\ttype: \"valid\"\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"invalid\",\n\t\t\t\tmessage: error\n\t\t\t}\n\t\t}\n\t});\n\n\tvar focusEvents = blurredStream.map((isBlurred) => {\n\t\tif (isBlurred === undefined) {\n\t\t\treturn {};\n\t\t}\n\t\treturn isBlurred ? {\n\t\t\ttype: \"blurred\"\n\t\t} : {\n\t\t\ttype: \"focused\"\n\t\t};\n\t});\n\n\treturn Kefir.merge([errorEvent, focusEvents])\n\t\t.scan((previous, event) => {\n\t\t\tswitch (event.type) {\n\t\t\t\tcase \"valid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: true,\n\t\t\t\t\t\tshowCardError: false\n\t\t\t\t\t});\n\t\t\t\tcase \"invalid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: false,\n\t\t\t\t\t\tshowCardError: previous.hasBeenBlurred\n\t\t\t\t\t});\n\t\t\t\tcase \"blurred\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\thasBeenBlurred: true,\n\t\t\t\t\t\tshowCardError: !previous.isValid\n\t\t\t\t\t});\n\t\t\t\tdefault:\n\t\t\t\t\treturn previous;\n\t\t\t}\n\t\t}, {\n\t\t\thasBeenBlurred: false,\n\t\t\tshowCardError: false,\n\t\t\tisValid: false\n\t\t}).map((state) => {\n\t\t\treturn state.showCardError\n\t\t});\n}\n\n```\n<span line-highlight='5,13-14,30-83,only'></span>\n\n\n## Read, validate, and show the error of the expiry ##\n### The problem\n\nLets make the `expiry` input element just like the `cardNumber`\nelement.  The expiry should be entered like `12-17` and be stored as an\narray like `[\"12\",\"16\"]`.  Make sure to:\n\n- validate the expiry\n- show a warning validation message in a `<div class=\"message\">` element\n- add `class='is-error'` to the element if we should show the `expiry` error.\n\n### What you need to know\n\n- Use `expiry.split(\"-\")` to convert what a user typed into an array of numbers.\n- To validate the expiry use:\n  ```js\n  function validateExpiry(expiry) {\n    if (!expiry) {\n        return \"There is no expiry. Format  MM-YY\";\n    }\n    if (expiry.length !== 2 || expiry[0].length !== 2 || expiry[1].length !== 2) {\n        return \"Expirty must be formatted like MM-YY\";\n    }\n  }\n  ```\n\n\n\n### The solution\n\nUpdate the view in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n<form>\n\n  {{#if showCardError.value}}\n    <div class=\"message\">{{cardError.value}}</div>\n  {{/if}}\n\n  {{#if showExpiryError.value}}\n    <div class=\"message\">{{expiryError.value}}</div>\n  {{/if}}\n\n  <input type='text' name='number' placeholder='Card Number'\n\ton:input:value:to=\"userCardNumber.value\"\n    on:blur=\"userCardNumberBlurred.emitter.value(true)\"\n\t{{#if showCardError.value}}class='is-error'{{/if}}/>\n\n  <input type='text' name='expiry' placeholder='MM-YY'\n    on:input:value:to=\"userExpiry.value\"\n  \ton:blur=\"userExpiryBlurred.emitter.value(true)\"\n  \t{{#if showExpiryError.value}}class='is-error'{{/if}}/>\n\n  <input type='text' name='cvc' placeholder='CVC'/>\n\n  <button>Pay ${{amount.value}}</button>\n\n</form>\n</script>\n\n```\n<span line-highlight='8-10,17-20,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar viewModel = {\n\tamount: Kefir.constant(1000),\n\n\tuserCardNumber: Kefir.emitterProperty(),\n\tuserCardNumberBlurred: Kefir.emitterProperty(),\n\n\tuserExpiry: Kefir.emitterProperty(),\n\tuserExpiryBlurred: Kefir.emitterProperty()\n};\n\nviewModel.cardNumber = viewModel.userCardNumber.map((card) => {\n\tif (card) {\n\t\treturn card.replace(/[\\s-]/g, \"\");\n\t}\n});\nviewModel.cardError = viewModel.cardNumber.map(validateCard).toProperty();\nviewModel.showCardError = showOnlyWhenBlurredOnce(viewModel.cardError, viewModel.userCardNumberBlurred);\n\n// EXPIRY\nviewModel.expiry = viewModel.userExpiry.map((expiry) => {\n\tif (expiry) {\n\t\treturn expiry.split(\"-\")\n\t}\n});\nviewModel.expiryError = viewModel.expiry.map(validateExpiry).toProperty();\nviewModel.showExpiryError = showOnlyWhenBlurredOnce(viewModel.expiryError, viewModel.userExpiryBlurred);\n\nvar view = can.stache.from(\"app-view\");\n\ndocument.body.appendChild( view(viewModel) );\n\n// HELPER FUNCTIONS\nfunction validateCard(card) {\n\tif (!card) {\n\t\treturn \"There is no card\"\n\t}\n\tif (card.length !== 16) {\n\t\treturn \"There should be 16 characters in a card\";\n\t}\n}\n\nfunction validateExpiry(expiry) {\n\tif (!expiry) {\n\t\treturn \"There is no expiry. Format  MM-YY\";\n\t}\n\tif (expiry.length !== 2 || expiry[0].length !== 2 || expiry[1].length !== 2) {\n\t\treturn \"Expirty must be formatted like MM-YY\";\n\t}\n}\n\nfunction showOnlyWhenBlurredOnce(errorStream, blurredStream) {\n\tvar errorEvent = errorStream.map((error) => {\n\t\tif (!error) {\n\t\t\treturn {\n\t\t\t\ttype: \"valid\"\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"invalid\",\n\t\t\t\tmessage: error\n\t\t\t}\n\t\t}\n\t});\n\n\tvar focusEvents = blurredStream.map((isBlurred) => {\n\t\tif (isBlurred === undefined) {\n\t\t\treturn {};\n\t\t}\n\t\treturn isBlurred ? {\n\t\t\ttype: \"blurred\"\n\t\t} : {\n\t\t\ttype: \"focused\"\n\t\t};\n\t});\n\n\treturn Kefir.merge([errorEvent, focusEvents])\n\t\t.scan((previous, event) => {\n\t\t\tswitch (event.type) {\n\t\t\t\tcase \"valid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: true,\n\t\t\t\t\t\tshowCardError: false\n\t\t\t\t\t});\n\t\t\t\tcase \"invalid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: false,\n\t\t\t\t\t\tshowCardError: previous.hasBeenBlurred\n\t\t\t\t\t});\n\t\t\t\tcase \"blurred\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\thasBeenBlurred: true,\n\t\t\t\t\t\tshowCardError: !previous.isValid\n\t\t\t\t\t});\n\t\t\t\tdefault:\n\t\t\t\t\treturn previous;\n\t\t\t}\n\t\t}, {\n\t\t\thasBeenBlurred: false,\n\t\t\tshowCardError: false,\n\t\t\tisValid: false\n\t\t}).map((state) => {\n\t\t\treturn state.showCardError\n\t\t});\n}\n\n```\n<span line-highlight='7-8,19-26,42-49,only'></span>\n\n\n## Read, validate, and show the error of the CVC\n### The problem\n\nLets make the `CVC` input element just like the `cardNumber` and `expiry`\nelement.  Make sure to:\n\n- validate the cvc\n- show a warning validation message in a `<div class=\"message\">` element\n- add `class='is-error'` to the element if we should show the `CVC` error.\n\n### What you need to know\n\n- The `cvc` can be saved as whatever the user entered. No special processing necessary.\n- To validate CVC:\n  ```js\n  function validateCVC(cvc) {\n    if (!cvc) {\n        return \"There is no CVC code\";\n    }\n    if (cvc.length !== 3) {\n        return \"The CVC must be at least 3 numbers\";\n    }\n    if (isNaN(parseInt(cvc))) {\n        return \"The CVC must be numbers\";\n    }\n  }\n  ```\n\n### The solution\n\nUpdate the view in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n<form>\n\n  {{#if showCardError.value}}\n    <div class=\"message\">{{cardError.value}}</div>\n  {{/if}}\n\n  {{#if showExpiryError.value}}\n    <div class=\"message\">{{expiryError.value}}</div>\n  {{/if}}\n\n  {{#if showCVCError.value}}\n    <div class=\"message\">{{cvcError.value}}</div>\n  {{/if}}\n\n  <input type='text' name='number' placeholder='Card Number'\n\ton:input:value:to=\"userCardNumber.value\"\n    on:blur=\"userCardNumberBlurred.emitter.value(true)\"\n\t{{#if showCardError.value}}class='is-error'{{/if}}/>\n\n  <input type='text' name='expiry' placeholder='MM-YY'\n    on:input:value:to=\"userExpiry.value\"\n  \ton:blur=\"userExpiryBlurred.emitter.value(true)\"\n  \t{{#if showExpiryError.value}}class='is-error'{{/if}}/>\n\n  <input type='text' name='cvc' placeholder='CVC'\n    on:input:value:to=\"userCVC.value\"\n  \ton:blur=\"userCVCBlurred.emitter.value(true)\"\n  \t{{#if showCVCError.value}}class='is-error'{{/if}}/>\n\n  <button>Pay ${{amount.value}}</button>\n\n</form>\n</script>\n\n```\n<span line-highlight='12-14,26-29,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar viewModel = {\n\tamount: Kefir.constant(1000),\n\n\tuserCardNumber: Kefir.emitterProperty(),\n\tuserCardNumberBlurred: Kefir.emitterProperty(),\n\n\tuserExpiry: Kefir.emitterProperty(),\n\tuserExpiryBlurred: Kefir.emitterProperty(),\n\n\tuserCVC: Kefir.emitterProperty(),\n\tuserCVCBlurred: Kefir.emitterProperty()\n};\n\nviewModel.cardNumber = viewModel.userCardNumber.map((card) => {\n\tif (card) {\n\t\treturn card.replace(/[\\s-]/g, \"\");\n\t}\n});\nviewModel.cardError = viewModel.cardNumber.map(validateCard).toProperty();\nviewModel.showCardError = showOnlyWhenBlurredOnce(viewModel.cardError, viewModel.userCardNumberBlurred);\n\n// EXPIRY\nviewModel.expiry = viewModel.userExpiry.map((expiry) => {\n\tif (expiry) {\n\t\treturn expiry.split(\"-\")\n\t}\n});\nviewModel.expiryError = viewModel.expiry.map(validateExpiry).toProperty();\nviewModel.showExpiryError = showOnlyWhenBlurredOnce(viewModel.expiryError, viewModel.userExpiryBlurred);\n\n// CVC\nviewModel.cvc = viewModel.userCVC;\nviewModel.cvcError = viewModel.cvc.map(validateCVC).toProperty();\nviewModel.showCVCError = showOnlyWhenBlurredOnce(viewModel.cvcError, viewModel.userCVCBlurred);\n\nvar view = can.stache.from(\"app-view\");\n\ndocument.body.appendChild( view(viewModel) );\n\n// HELPER FUNCTIONS\nfunction validateCard(card) {\n\tif (!card) {\n\t\treturn \"There is no card\"\n\t}\n\tif (card.length !== 16) {\n\t\treturn \"There should be 16 characters in a card\";\n\t}\n}\n\nfunction validateExpiry(expiry) {\n\tif (!expiry) {\n\t\treturn \"There is no expiry. Format  MM-YY\";\n\t}\n\tif (expiry.length !== 2 || expiry[0].length !== 2 || expiry[1].length !== 2) {\n\t\treturn \"Expirty must be formatted like MM-YY\";\n\t}\n}\n\nfunction validateCVC(cvc) {\n\tif (!cvc) {\n\t\treturn \"There is no CVC code\";\n\t}\n\tif (cvc.length !== 3) {\n\t\treturn \"The CVC must be at least 3 numbers\";\n\t}\n\tif (isNaN(parseInt(cvc))) {\n\t\treturn \"The CVC must be numbers\";\n\t}\n}\n\nfunction showOnlyWhenBlurredOnce(errorStream, blurredStream) {\n\tvar errorEvent = errorStream.map((error) => {\n\t\tif (!error) {\n\t\t\treturn {\n\t\t\t\ttype: \"valid\"\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"invalid\",\n\t\t\t\tmessage: error\n\t\t\t}\n\t\t}\n\t});\n\n\tvar focusEvents = blurredStream.map((isBlurred) => {\n\t\tif (isBlurred === undefined) {\n\t\t\treturn {};\n\t\t}\n\t\treturn isBlurred ? {\n\t\t\ttype: \"blurred\"\n\t\t} : {\n\t\t\ttype: \"focused\"\n\t\t};\n\t});\n\n\treturn Kefir.merge([errorEvent, focusEvents])\n\t\t.scan((previous, event) => {\n\t\t\tswitch (event.type) {\n\t\t\t\tcase \"valid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: true,\n\t\t\t\t\t\tshowCardError: false\n\t\t\t\t\t});\n\t\t\t\tcase \"invalid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: false,\n\t\t\t\t\t\tshowCardError: previous.hasBeenBlurred\n\t\t\t\t\t});\n\t\t\t\tcase \"blurred\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\thasBeenBlurred: true,\n\t\t\t\t\t\tshowCardError: !previous.isValid\n\t\t\t\t\t});\n\t\t\t\tdefault:\n\t\t\t\t\treturn previous;\n\t\t\t}\n\t\t}, {\n\t\t\thasBeenBlurred: false,\n\t\t\tshowCardError: false,\n\t\t\tisValid: false\n\t\t}).map((state) => {\n\t\t\treturn state.showCardError\n\t\t});\n}\n\n```\n<span line-highlight='10-11,32-34,59-69,only'></span>\n\n\n## Disable the pay button if any part of the card has an error ##\n### The problem\n\nLets disable the __Pay__ button until the card, exiry, and cvc are valid.\n\n### What you need to know\n\n- `Kefir.combine` can combine several values into a single value:\n  ```js\n  var first = Kefir.sequentially(100, [\"Justin\", \"Ramiya\"])\n  var last = Kefir.sequentially(100, [\"Shah\", \"Meyer\"]).delay(50);\n  // first: ---Justin---RamiyaX\n  // last:  ------Shah__---Meyer_X\n  var fullName = Kefir.combine([first, last], (first, last) => { return first +\" \"+ last; })\n  // fullName: ---Justin Shah\n  //             -Ramiya Shah\n  //             -Ramiya MeyerX\n  ```\n- [can-stache-bindings.toChild childProp:from] can set a property from another value:\n  ```js\n  <input checked:from=\"someKey\"/>\n  ```\n\n### The solution\n\nUpdate the view in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n<form>\n\n  {{#if showCardError.value}}\n    <div class=\"message\">{{cardError.value}}</div>\n  {{/if}}\n\n  {{#if showExpiryError.value}}\n    <div class=\"message\">{{expiryError.value}}</div>\n  {{/if}}\n\n  {{#if showCVCError.value}}\n    <div class=\"message\">{{cvcError.value}}</div>\n  {{/if}}\n\n  <input type='text' name='number' placeholder='Card Number'\n\ton:input:value:to=\"userCardNumber.value\"\n    on:blur=\"userCardNumberBlurred.emitter.value(true)\"\n\t{{#if showCardError.value}}class='is-error'{{/if}}/>\n\n  <input type='text' name='expiry' placeholder='MM-YY'\n    on:input:value:to=\"userExpiry.value\"\n  \ton:blur=\"userExpiryBlurred.emitter.value(true)\"\n  \t{{#if showExpiryError.value}}class='is-error'{{/if}}/>\n\n  <input type='text' name='cvc' placeholder='CVC'\n    on:input:value:to=\"userCVC.value\"\n  \ton:blur=\"userCVCBlurred.emitter.value(true)\"\n  \t{{#if showCVCError.value}}class='is-error'{{/if}}/>\n\n  <button disabled:from=\"isCardInvalid.value\">\n    Pay ${{amount.value}}\n  </button>\n\n</form>\n</script>\n\n```\n<span line-highlight='31-33,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar viewModel = {\n\tamount: Kefir.constant(1000),\n\n\tuserCardNumber: Kefir.emitterProperty(),\n\tuserCardNumberBlurred: Kefir.emitterProperty(),\n\n\tuserExpiry: Kefir.emitterProperty(),\n\tuserExpiryBlurred: Kefir.emitterProperty(),\n\n\tuserCVC: Kefir.emitterProperty(),\n\tuserCVCBlurred: Kefir.emitterProperty(),\n};\n\nviewModel.cardNumber = viewModel.userCardNumber.map((card) => {\n\tif (card) {\n\t\treturn card.replace(/[\\s-]/g, \"\");\n\t}\n});\nviewModel.cardError = viewModel.cardNumber.map(validateCard).toProperty();\nviewModel.showCardError = showOnlyWhenBlurredOnce(viewModel.cardError, viewModel.userCardNumberBlurred);\n\n// EXPIRY\nviewModel.expiry = viewModel.userExpiry.map((expiry) => {\n\tif (expiry) {\n\t\treturn expiry.split(\"-\")\n\t}\n});\nviewModel.expiryError = viewModel.expiry.map(validateExpiry).toProperty();\nviewModel.showExpiryError = showOnlyWhenBlurredOnce(viewModel.expiryError, viewModel.userExpiryBlurred);\n\n// CVC\nviewModel.cvc = viewModel.userCVC;\nviewModel.cvcError = viewModel.cvc.map(validateCVC).toProperty();\nviewModel.showCVCError = showOnlyWhenBlurredOnce(viewModel.cvcError, viewModel.userCVCBlurred);\n\nviewModel.isCardInvalid = Kefir.combine([viewModel.cardError, viewModel.expiryError, viewModel.cvcError],\n\tfunction(cardError, expiryError, cvcError) {\n\t\treturn !!(cardError || expiryError || cvcError)\n\t});\n\nvar view = can.stache.from(\"app-view\");\n\ndocument.body.appendChild( view(viewModel) );\n\n// HELPER FUNCTIONS\nfunction validateCard(card) {\n\tif (!card) {\n\t\treturn \"There is no card\"\n\t}\n\tif (card.length !== 16) {\n\t\treturn \"There should be 16 characters in a card\";\n\t}\n}\n\nfunction validateExpiry(expiry) {\n\tif (!expiry) {\n\t\treturn \"There is no expiry. Format  MM-YY\";\n\t}\n\tif (expiry.length !== 2 || expiry[0].length !== 2 || expiry[1].length !== 2) {\n\t\treturn \"Expirty must be formatted like MM-YY\";\n\t}\n}\n\nfunction validateCVC(cvc) {\n\tif (!cvc) {\n\t\treturn \"There is no CVC code\";\n\t}\n\tif (cvc.length !== 3) {\n\t\treturn \"The CVC must be at least 3 numbers\";\n\t}\n\tif (isNaN(parseInt(cvc))) {\n\t\treturn \"The CVC must be numbers\";\n\t}\n}\n\nfunction showOnlyWhenBlurredOnce(errorStream, blurredStream) {\n\tvar errorEvent = errorStream.map((error) => {\n\t\tif (!error) {\n\t\t\treturn {\n\t\t\t\ttype: \"valid\"\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"invalid\",\n\t\t\t\tmessage: error\n\t\t\t}\n\t\t}\n\t});\n\n\tvar focusEvents = blurredStream.map((isBlurred) => {\n\t\tif (isBlurred === undefined) {\n\t\t\treturn {};\n\t\t}\n\t\treturn isBlurred ? {\n\t\t\ttype: \"blurred\"\n\t\t} : {\n\t\t\ttype: \"focused\"\n\t\t};\n\t});\n\n\treturn Kefir.merge([errorEvent, focusEvents])\n\t\t.scan((previous, event) => {\n\t\t\tswitch (event.type) {\n\t\t\t\tcase \"valid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: true,\n\t\t\t\t\t\tshowCardError: false\n\t\t\t\t\t});\n\t\t\t\tcase \"invalid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: false,\n\t\t\t\t\t\tshowCardError: previous.hasBeenBlurred\n\t\t\t\t\t});\n\t\t\t\tcase \"blurred\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\thasBeenBlurred: true,\n\t\t\t\t\t\tshowCardError: !previous.isValid\n\t\t\t\t\t});\n\t\t\t\tdefault:\n\t\t\t\t\treturn previous;\n\t\t\t}\n\t\t}, {\n\t\t\thasBeenBlurred: false,\n\t\t\tshowCardError: false,\n\t\t\tisValid: false\n\t\t}).map((state) => {\n\t\t\treturn state.showCardError\n\t\t});\n}\n\n```\n<span line-highlight='36-39,only'></span>\n\n\n## Implement the payment button ##\n### The problem\n\nWhen the user submits the form, lets simulate making a 2 second AJAX\nrequest to create a payment.  While the request is being made,\nwe will change the __Pay__ button to say __Paying__.\n\n### What you need to know\n\n- Use the following to create a Promise that takes 2 seconds to resolve:\n  ```js\n  new Promise(function(resolve) {\n   setTimeout(function() {\n      resolve(1000);\n    }, 2000);\n  });\n  ```\n\n- Use [can-stache-bindings.event] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked:\n\n     ```html\n     <div on:click=\"doSomething(%event)\"> ... </div>\n     ```\n\n     Notice that it also passed the event object with `%event`.\n\n- To prevent a form from submitting, call `event.preventDefault()`.\n- [Kefir.fromPromise](https://rpominov.github.io/kefir/#from-promise) returns a stream from the resolved value of a promise.\n- [Kefir.combine](https://rpominov.github.io/kefir/#combine) takes a list of passive streams\n  where the combinator will not be called when the passive streams emit a value.\n- `Kefir.concat` concatenates streams so events are produced in order.\n  ```js\n  var a = Kefir.sequentially(100, [0, 1, 2]);\n  var b = Kefir.sequentially(100, [3, 4, 5]);\n  var abc = Kefir.concat([a, b]);\n  //a:    ---0---1---2X\n  //b:                ---3---4---5X\n  //abc:  ---0---1---2---3---4---5X\n  ```\n\n- [Kefir.flatMap](https://rpominov.github.io/kefir/#flat-map) flattens a stream of\n  streams to a single stream of values.\n  ```js\n  var count = Kefir.sequentially(100, [1, 2, 3]);\n  var streamOfStreams = count.map( (count) => {\n      return Kefir.interval(40, count).take(4)\n  });\n  var result = streamOfStreams.flatMap();\n  // source:      ----------1---------2---------3X\n  //\n  // spawned 1:             ---1---1---1---1X\n  // spawned 2:                       ---2---2---2---2X\n  // spawned 3:                                 ---3---3---3---3X\n  // result:      -------------1---1---1-2-1-2---2-3-2-3---3---3X\n  ```\n\n  I think of this like promises' ability to resolve when an \"inner\" promise\n  resolves.  For example, `resultPromise` below resolves with the `innerPromise`:\n\n  ```js\n  var outerPromise = new Promise((resolve) => {\n      setTimeout(() => { resolve(\"outer\") }, 100);\n  });\n  return innerPromise = new Promise((resolve) => {\n      setTimeout(() => { resolve(\"inner\") }, 200);\n  });\n  var resultPromise = outerPromise.then(function(value){\n     // value -> \"outer\"\n     return innerPromise;\n  });\n  resultPromise.then(function(value){\n     // value -> \"inner\"\n  })\n  ```\n\n  In some ways, `outerPromise` is a promise of promises.  Promises flatten\n  by default. With Kefir, you call `flatMap` to flatten streams.\n\n### The solution\n\nUpdate the view in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n<form on:submit=\"pay(%event)\">\n\n  {{#if showCardError.value}}\n    <div class=\"message\">{{cardError.value}}</div>\n  {{/if}}\n\n  {{#if showExpiryError.value}}\n    <div class=\"message\">{{expiryError.value}}</div>\n  {{/if}}\n\n  {{#if showCVCError.value}}\n    <div class=\"message\">{{cvcError.value}}</div>\n  {{/if}}\n\n  <input type='text' name='number' placeholder='Card Number'\n    on:input:value:to=\"userCardNumber.value\"\n\ton:blur=\"userCardNumberBlurred.emitter.value(true)\"\n    {{#if showCardError.value}}class='is-error'{{/if}}/>\n\n  <input type='text' name='expiry' placeholder='MM-YY'\n  \ton:input:value:to=\"userExpiry.value\"\n\ton:blur=\"userExpiryBlurred.emitter.value(true)\"\n\t{{#if showExpiryError.value}}class='is-error'{{/if}}/>\n\n  <input type='text' name='cvc' placeholder='CVC'\n    on:input:value:to=\"userCVC.value\"\n\ton:blur=\"userCVCBlurred.emitter.value(true)\"\n\t{{#if showCVCError.value}}class='is-error'{{/if}}/>\n\n  <button disabled:from=\"isCardInvalid.value\">\n  \t{{#eq paymentStatus.value.status \"pending\"}}Paying{{else}}Pay{{/eq}} ${{amount.value}}\n  </button>\n</form>\n</script>\n\n```\n<span line-highlight='2,32,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar viewModel = {\n\tamount: Kefir.constant(1000),\n\n\tuserCardNumber: Kefir.emitterProperty(),\n\tuserCardNumberBlurred: Kefir.emitterProperty(),\n\n\tuserExpiry: Kefir.emitterProperty(),\n\tuserExpiryBlurred: Kefir.emitterProperty(),\n\n\tuserCVC: Kefir.emitterProperty(),\n\tuserCVCBlurred: Kefir.emitterProperty(),\n\n\tpayClicked: Kefir.emitterProperty(),\n\n\tpay: function(event) {\n\t\tevent.preventDefault();\n\t\tthis.payClicked.emitter.value(true)\n\t}\n};\n\nviewModel.cardNumber = viewModel.userCardNumber.map((card) => {\n\tif (card) {\n\t\treturn card.replace(/[\\s-]/g, \"\");\n\t}\n});\nviewModel.cardError = viewModel.cardNumber.map(validateCard).toProperty(); // we’ll need this in the future\nviewModel.showCardError = showOnlyWhenBlurredOnce(viewModel.cardError, viewModel.userCardNumberBlurred);\n\n// EXPIRY\nviewModel.expiry = viewModel.userExpiry.map((expiry) => {\n\tif (expiry) {\n\t\treturn expiry.split(\"-\")\n\t}\n});\nviewModel.expiryError = viewModel.expiry.map(validateExpiry).toProperty();\nviewModel.showExpiryError = showOnlyWhenBlurredOnce(viewModel.expiryError, viewModel.userExpiryBlurred);\n\n// CVC\nviewModel.cvc = viewModel.userCVC;\nviewModel.cvcError = viewModel.cvc.map(validateCVC).toProperty();\nviewModel.showCVCError = showOnlyWhenBlurredOnce(viewModel.cvcError, viewModel.userCVCBlurred);\n\nviewModel.isCardInvalid = Kefir.combine([viewModel.cardError, viewModel.expiryError, viewModel.cvcError],\n\tfunction(cardError, expiryError, cvcError) {\n\t\treturn !!(cardError || expiryError || cvcError)\n\t});\n\nviewModel.card = Kefir.combine([viewModel.cardNumber, viewModel.expiry, viewModel.cvc],\n\tfunction(cardNumber, expiry, cvc) {\n\t\treturn {cardNumber , expiry , cvc};\n\t});\n\n// STREAM< Promise<Number> | undefined >\nvar paymentPromises = Kefir.combine([viewModel.payClicked], [viewModel.card], (payClicked, card) => {\n\tif (payClicked) {\n        console.log(\"Asking for token with\", card);\n\t\treturn new Promise(function(resolve) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tresolve(1000);\n\t\t\t}, 2000);\n\t\t})\n\t}\n});\n\n// STREAM< STREAM<STATUS> >\n// This is a stream of streams of status objects.\nvar paymentStatusStream = paymentPromises.map((promise) => {\n\tif (promise) {\n\t\t// STREAM<STATUS>\n\t\treturn Kefir.concat([\n\t\t\tKefir.constant({\n\t\t\t\tstatus: \"pending\"\n\t\t\t}),\n\t\t\tKefir.fromPromise(promise).map((value) => {\n\t\t\t\treturn {\n\t\t\t\t\tstatus: \"resolved\",\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\t\t\t})\n\t\t]);\n\t} else {\n\t\t// STREAM\n\t\treturn Kefir.constant({\n\t\t\tstatus: \"waiting\"\n\t\t});\n\t}\n});\n\n// STREAM<STATUS> //{status: \"waiting\"} | {status: \"resolved\"}\nviewModel.paymentStatus = paymentStatusStream.flatMap().toProperty();\n\nvar view = can.stache.from(\"app-view\");\n\ndocument.body.appendChild( view(viewModel) );\n\n// HELPER FUNCTIONS\nfunction validateCard(card) {\n\tif (!card) {\n\t\treturn \"There is no card\"\n\t}\n\tif (card.length !== 16) {\n\t\treturn \"There should be 16 characters in a card\";\n\t}\n}\n\nfunction validateExpiry(expiry) {\n\tif (!expiry) {\n\t\treturn \"There is no expiry. Format  MM-YY\";\n\t}\n\tif (expiry.length !== 2 || expiry[0].length !== 2 || expiry[1].length !== 2) {\n\t\treturn \"Expirty must be formatted like MM-YY\";\n\t}\n}\n\nfunction validateCVC(cvc) {\n\tif (!cvc) {\n\t\treturn \"There is no CVC code\";\n\t}\n\tif (cvc.length !== 3) {\n\t\treturn \"The CVC must be at least 3 numbers\";\n\t}\n\tif (isNaN(parseInt(cvc))) {\n\t\treturn \"The CVC must be numbers\";\n\t}\n}\n\nfunction showOnlyWhenBlurredOnce(errorStream, blurredStream) {\n\tvar errorEvent = errorStream.map((error) => {\n\t\tif (!error) {\n\t\t\treturn {\n\t\t\t\ttype: \"valid\"\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"invalid\",\n\t\t\t\tmessage: error\n\t\t\t}\n\t\t}\n\t});\n\n\tvar focusEvents = blurredStream.map((isBlurred) => {\n\t\tif (isBlurred === undefined) {\n\t\t\treturn {};\n\t\t}\n\t\treturn isBlurred ? {\n\t\t\ttype: \"blurred\"\n\t\t} : {\n\t\t\ttype: \"focused\"\n\t\t};\n\t});\n\n\treturn Kefir.merge([errorEvent, focusEvents])\n\t\t.scan((previous, event) => {\n\t\t\tswitch (event.type) {\n\t\t\t\tcase \"valid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: true,\n\t\t\t\t\t\tshowCardError: false\n\t\t\t\t\t});\n\t\t\t\tcase \"invalid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: false,\n\t\t\t\t\t\tshowCardError: previous.hasBeenBlurred\n\t\t\t\t\t});\n\t\t\t\tcase \"blurred\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\thasBeenBlurred: true,\n\t\t\t\t\t\tshowCardError: !previous.isValid\n\t\t\t\t\t});\n\t\t\t\tdefault:\n\t\t\t\t\treturn previous;\n\t\t\t}\n\t\t}, {\n\t\t\thasBeenBlurred: false,\n\t\t\tshowCardError: false,\n\t\t\tisValid: false\n\t\t}).map((state) => {\n\t\t\treturn state.showCardError\n\t\t});\n}\n\n```\n<span line-highlight='13-18,48-90,only'></span>\n\n\n\n## Disable the payment button while payments are pending ##\n### The problem\n\nLets prevent the __Pay__ button from being clicked while the payment is processing.\n\n### What you need to know\n\n- You know everything you need to know.\n\n### The solution\n\nUpdate the view in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n<form on:submit=\"pay(%event)\">\n\n  {{#if showCardError.value}}\n    <div class=\"message\">{{cardError.value}}</div>\n  {{/if}}\n\n  {{#if showExpiryError.value}}\n    <div class=\"message\">{{expiryError.value}}</div>\n  {{/if}}\n\n  {{#if showCVCError.value}}\n    <div class=\"message\">{{cvcError.value}}</div>\n  {{/if}}\n\n  <input type='text' name='number' placeholder='Card Number'\n    on:input:value:to=\"userCardNumber.value\"\n\ton:blur=\"userCardNumberBlurred.emitter.value(true)\"\n    {{#if showCardError.value}}class='is-error'{{/if}}/>\n\n  <input type='text' name='expiry' placeholder='MM-YY'\n  \ton:input:value:to=\"userExpiry.value\"\n\ton:blur=\"userExpiryBlurred.emitter.value(true)\"\n\t{{#if showExpiryError.value}}class='is-error'{{/if}}/>\n\n  <input type='text' name='cvc' placeholder='CVC'\n    on:input:value:to=\"userCVC.value\"\n\ton:blur=\"userCVCBlurred.emitter.value(true)\"\n\t{{#if showCVCError.value}}class='is-error'{{/if}}/>\n\n  <button disabled:from=\"disablePaymentButton.value\">\n  \t{{#eq paymentStatus.value.status \"pending\"}}Paying{{else}}Pay{{/eq}} ${{amount.value}}\n  </button>\n</form>\n</script>\n\n```\n<span line-highlight='31,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar viewModel = {\n\tamount: Kefir.constant(1000),\n\n\tuserCardNumber: Kefir.emitterProperty(),\n\tuserCardNumberBlurred: Kefir.emitterProperty(),\n\n\tuserExpiry: Kefir.emitterProperty(),\n\tuserExpiryBlurred: Kefir.emitterProperty(),\n\n\tuserCVC: Kefir.emitterProperty(),\n\tuserCVCBlurred: Kefir.emitterProperty(),\n\n\tpayClicked: Kefir.emitterProperty(),\n\n\tpay: function(event) {\n\t\tevent.preventDefault();\n\t\tthis.payClicked.emitter.value(true)\n\t}\n};\n\nviewModel.cardNumber = viewModel.userCardNumber.map((card) => {\n\tif (card) {\n\t\treturn card.replace(/[\\s-]/g, \"\");\n\t}\n});\nviewModel.cardError = viewModel.cardNumber.map(validateCard).toProperty(); // we’ll need this in the future\nviewModel.showCardError = showOnlyWhenBlurredOnce(viewModel.cardError, viewModel.userCardNumberBlurred);\n\n// EXPIRY\nviewModel.expiry = viewModel.userExpiry.map((expiry) => {\n\tif (expiry) {\n\t\treturn expiry.split(\"-\")\n\t}\n});\nviewModel.expiryError = viewModel.expiry.map(validateExpiry).toProperty();\nviewModel.showExpiryError = showOnlyWhenBlurredOnce(viewModel.expiryError, viewModel.userExpiryBlurred);\n\n// CVC\nviewModel.cvc = viewModel.userCVC;\nviewModel.cvcError = viewModel.cvc.map(validateCVC).toProperty();\nviewModel.showCVCError = showOnlyWhenBlurredOnce(viewModel.cvcError, viewModel.userCVCBlurred);\n\nviewModel.isCardInvalid = Kefir.combine([viewModel.cardError, viewModel.expiryError, viewModel.cvcError],\n\tfunction(cardError, expiryError, cvcError) {\n\t\treturn !!(cardError || expiryError || cvcError)\n\t});\n\nviewModel.card = Kefir.combine([viewModel.cardNumber, viewModel.expiry, viewModel.cvc],\n\tfunction(cardNumber, expiry, cvc) {\n\t\treturn {cardNumber , expiry , cvc};\n\t});\n\n// STREAM< Promise<Number> | undefined >\nvar paymentPromises = Kefir.combine([viewModel.payClicked], [viewModel.card], (payClicked, card) => {\n\tif (payClicked) {\n        console.log(\"Asking for token with\", card);\n\t\treturn new Promise(function(resolve) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tresolve(1000);\n\t\t\t}, 2000);\n\t\t})\n\t}\n});\n\n// STREAM< STREAM<STATUS> >\n// This is a stream of streams of status objects.\nvar paymentStatusStream = paymentPromises.map((promise) => {\n\tif (promise) {\n\t\t// STREAM<STATUS>\n\t\treturn Kefir.concat([\n\t\t\tKefir.constant({\n\t\t\t\tstatus: \"pending\"\n\t\t\t}),\n\t\t\tKefir.fromPromise(promise).map((value) => {\n\t\t\t\treturn {\n\t\t\t\t\tstatus: \"resolved\",\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\t\t\t})\n\t\t]);\n\t} else {\n\t\t// STREAM\n\t\treturn Kefir.constant({\n\t\t\tstatus: \"waiting\"\n\t\t});\n\t}\n});\n\n// STREAM<STATUS> //{status: \"waiting\"} | {status: \"resolved\"}\nviewModel.paymentStatus = paymentStatusStream.flatMap().toProperty();\n\nviewModel.disablePaymentButton = Kefir.combine([viewModel.isCardInvalid, viewModel.paymentStatus],\n\tfunction(isCardInvalid, paymentStatus) {\n\t\treturn (isCardInvalid === true) || !paymentStatus || paymentStatus.status === \"pending\";\n\t}).toProperty(function() {\n\treturn true;\n});\n\nvar view = can.stache.from(\"app-view\");\n\ndocument.body.appendChild( view(viewModel) );\n\n// HELPER FUNCTIONS\nfunction validateCard(card) {\n\tif (!card) {\n\t\treturn \"There is no card\"\n\t}\n\tif (card.length !== 16) {\n\t\treturn \"There should be 16 characters in a card\";\n\t}\n}\n\nfunction validateExpiry(expiry) {\n\tif (!expiry) {\n\t\treturn \"There is no expiry. Format  MM-YY\";\n\t}\n\tif (expiry.length !== 2 || expiry[0].length !== 2 || expiry[1].length !== 2) {\n\t\treturn \"Expirty must be formatted like MM-YY\";\n\t}\n}\n\nfunction validateCVC(cvc) {\n\tif (!cvc) {\n\t\treturn \"There is no CVC code\";\n\t}\n\tif (cvc.length !== 3) {\n\t\treturn \"The CVC must be at least 3 numbers\";\n\t}\n\tif (isNaN(parseInt(cvc))) {\n\t\treturn \"The CVC must be numbers\";\n\t}\n}\n\nfunction showOnlyWhenBlurredOnce(errorStream, blurredStream) {\n\tvar errorEvent = errorStream.map((error) => {\n\t\tif (!error) {\n\t\t\treturn {\n\t\t\t\ttype: \"valid\"\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"invalid\",\n\t\t\t\tmessage: error\n\t\t\t}\n\t\t}\n\t});\n\n\tvar focusEvents = blurredStream.map((isBlurred) => {\n\t\tif (isBlurred === undefined) {\n\t\t\treturn {};\n\t\t}\n\t\treturn isBlurred ? {\n\t\t\ttype: \"blurred\"\n\t\t} : {\n\t\t\ttype: \"focused\"\n\t\t};\n\t});\n\n\treturn Kefir.merge([errorEvent, focusEvents])\n\t\t.scan((previous, event) => {\n\t\t\tswitch (event.type) {\n\t\t\t\tcase \"valid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: true,\n\t\t\t\t\t\tshowCardError: false\n\t\t\t\t\t});\n\t\t\t\tcase \"invalid\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\tisValid: false,\n\t\t\t\t\t\tshowCardError: previous.hasBeenBlurred\n\t\t\t\t\t});\n\t\t\t\tcase \"blurred\":\n\t\t\t\t\treturn Object.assign({}, previous, {\n\t\t\t\t\t\thasBeenBlurred: true,\n\t\t\t\t\t\tshowCardError: !previous.isValid\n\t\t\t\t\t});\n\t\t\t\tdefault:\n\t\t\t\t\treturn previous;\n\t\t\t}\n\t\t}, {\n\t\t\thasBeenBlurred: false,\n\t\t\tshowCardError: false,\n\t\t\tisValid: false\n\t\t}).map((state) => {\n\t\t\treturn state.showCardError\n\t\t});\n}\n\n```\n<span line-highlight='92-97,only'></span>\n\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "This guide walks through building a simple credit card payment form with validations. It doesn't use\n[can-define]. Instead it uses `Kefir.js` streams to make a ViewModel.\n[can-kefir] is used to make the Kefir streams observable to [can-stache].\n\n\n",
    "name": "guides/recipes/credit-card-advanced",
    "title": "Credit Card Guide (Advanced)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes/credit-card-simple": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/credit-card-simple/credit-card-simple.md"
    },
    "body": "\nIn this guide you will learn how to:\n\n- Set up a basic CanJS application.\n- Collect form data and post it to a service\n  endpoint when the form is submitted.\n- Do basic validation.\n\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/konemoc/1/embed?output\">JS Bin on jsbin.com</a>\n\nTo use the widget:\n\n1. __Enter__ a _Card Number_, _Expiration Date_, and _CVC_.\n2. __Click__ on the form so those inputs lose focus.  The\n   _Pay_ button should become enabled.\n3. __Click__ the _Pay_ button to get a token from Stripe which\n   could be used to create a credit card payment.\n4. __Change__ the inputs to invalid values.  An error message should appear,\n   the invalid inputs should be highlighted red, and the _Pay_\n   button should become disabled.\n\n__START THIS TUTORIAL BY CLONING THE FOLLOWING JS Bin__:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/gafibor/3/embed?output\">JS Bin on jsbin.com</a>\n\nThis JS Bin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\nThe following sections are broken down into:\n\n- __The problem__ — A description of what the section is trying to accomplish.\n- __What you need to know__ — Information about CanJS that is useful for solving the problem.\n- __The solution__ — The solution to the problem.\n\n\n\n## Setup\n\n### The problem\n\nLet’s create a `payment-view` template and render it with\na ViewModel called `PaymentVM`, which will have\nan `amount` property that defaults to `9.99`.  When complete, we\nshould be able update the displayed “pay amount” by writing the\nfollowing in the console:\n\n```js\nviewModel.amount = 1000;\n```\n\n### What you need to know\n\n\n- To use Stripe, you must call [Stripe.setPublishableKey](https://stripe.com/docs/stripe.js/v2#setting-publishable-key).\n\n- A basic CanJS setup uses instances of a ViewModel to manage the\n  behavior of a View.  A ViewModel type is defined, an instance of it\n  is created and passed to a View as follows:\n\n  ```js\n  // Define the ViewModel type\n  var MyViewModel = can.DefineMap.extend(\"MyViewModel\",{\n   ...      \n  })\n  // Create an instance of the ViewModel\n  var viewModel = new MyViewModel();\n  // Get a View\n  var view = can.stache.from(\"my-view\");\n  // Render the View with the ViewModel instance\n  var frag = view(viewModel);\n  document.body.appendChild(frag);\n  ```\n\n- CanJS uses [can-stache] to render data in a template\n  and keep it live.  Templates can be authored in `<script>` tags like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-view\">\n    TEMPLATE CONTENT\n  </script>\n  ```\n\n  A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] magic tags to insert data into\n  the HTML output like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-view\">\n    {{something.name}}\n  </script>\n  ```\n\n- Load a template from a `<script>` tag with [can-stache.from can.stache.from] like:\n  ```js\n  var template = can.stache.from(SCRIPT_ID);\n  ```\n\n- Render the template with data into a documentFragment like:\n\n  ```js\n  var frag = template({\n    something: {name: \"Derek Brunson\"}\n  });\n  ```\n\n- Insert a fragment into the page with:\n\n  ```js\n  document.body.appendChild(frag);\n  ```\n\n- [can-define/map/map.extend DefineMap.extend] allows you to define a property with a default value like:\n\n  ```js\n  ProductVM = can.DefineMap.extend(\"ProductVM\",{\n    age: {value: 34}\n  })\n  ```\n\n  This lets you create instances of that type, get and set those properties and listen to changes like:\n\n  ```js\n  var productVM = new ProductVM({});\n\n  productVM.age //-> 34\n\n  productVM.on(\"age\", function(ev, newAge){\n    console.log(\"age changed to \", newAge);\n  });\n\n  productVM.age = 35 //-> logs \"person age changed to 35\"\n  ```\n\n\n\n### The solution\n\nUpdate the __HTML__ tab to:\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Credit Card Form\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n<script type='text/stache' id=\"payment-view\">\n  <form>\n\n    <input type='text' name='number' placeholder='Card Number'/>\n\n    <input type='text' name='expiry' placeholder='MM-YY'/>\n\n    <input type='text' name='cvc' placeholder='CVC'/>\n\n    <button>Pay ${{amount}}</button>\n\n  </form>\n</script>\n\n<script src=\"https://unpkg.com/can/dist/global/can.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.stripe.com/v2/\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='10,19,22'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nStripe.setPublishableKey('pk_test_zCC2JrO3KSMeh7BB5x9OUe2U');\n\nvar PaymentVM = can.DefineMap.extend({\n  amount: {value: 9.99}\n});\n\nvar viewModel = new PaymentVM();\n\nvar paymentView = can.stache.from(\"payment-view\");\nvar frag = paymentView( viewModel );\ndocument.body.appendChild( frag );\n\n```\n\n\n\n## Read form values\n\n### The problem\n\nLet’s send the form values to the ViewModel so we\ncan process and validate them.  In this step, we’ll\nsend the form values to the ViewModel and print out\nthe values to make sure the ViewModel has them correctly.\n\n\nPrint out the exported values like:\n\n```html\n<p>{{userCardNumber}}, {{userExpiry}}, {{userCVC}}</p>\n```\n\n### What you need to know\n\n- Use [can-stache-bindings.twoWay value:bind] to setup a two-way binding  \n  in `can-stache`.  For example, the following keeps `email` on the ViewModel and the input's `value` in sync:\n\n    ```html\n    <input value:bind=\"email\"/>\n    ```\n\n- [can-define/map/map.extend DefineMap.extend] allows you to define a property by defining its type like so:\n\n  ```js\n  Person = can.DefineMap.extend(\"Person\",{\n    name: \"string\",\n    age: \"number\"\n  })\n  ```\n\n### The solution\n\nUpdate the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id=\"payment-view\">\n  <form>\n\n\t<input type='text' name='number' placeholder='Card Number'\n\t  value:bind=\"userCardNumber\"/>\n\n\t<input type='text' name='expiry' placeholder='MM-YY'\n\t  value:bind=\"userExpiry\"/>\n\n\t<input type='text' name='cvc' placeholder='CVC'\n\t  value:bind=\"userCVC\"/>\n\n\t<button>Pay ${{amount}}</button>\n\n\t<p>{{userCardNumber}}, {{userExpiry}}, {{userCVC}}</p>\n  </form>\n</script>\n\n```\n<span line-highlight='4-11,15,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nStripe.setPublishableKey('pk_test_zCC2JrO3KSMeh7BB5x9OUe2U');\n\nvar PaymentVM = can.DefineMap.extend({\n  amount: {value: 9.99},\n\n  userCardNumber: \"string\",\n\n  userExpiry: \"string\",\n\n  userCVC: \"string\"\n});\n\nvar viewModel = new PaymentVM();\n\nvar paymentView = can.stache.from(\"payment-view\");\nvar frag = paymentView( viewModel );\ndocument.body.appendChild( frag );\n\n```\n<span line-highlight='6-10,only'></span>\n\n## Format form values\n\n### The problem\n\nOur data needs to be cleaned up before we pass it to the server.\nWe need to create the following properties, with associated behaviors:\n\n- `cardNumber` - The user's card number as a string without hyphens (`-`).\n- `expiryMonth` - A number for the month entered.\n- `expiryYear` - A number for the year entered.\n- `cvc` - A number for the cvc entered.\n\nSo that we can print out the values like:\n\n```html\n<p>{{cardNumber}}, {{expiryMonth}}-{{expiryYear}}, {{cvc}}</p>\n```\n\n### What you need to know\n\n- [ES5 Getter Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) can\n  be used to define a `DefineMap` property that changes when another property changes.  For example,\n  the following defines a `firstName` property that always has the\n  first word of the `fullName` property:\n\n  ```js\n  DefineMap.extend({\n    fullName: \"string\",\n    get firstName(){\n      return this.fullName.split(\" \")[0];\n    }\n  });\n  ```\n\n### The solution\n\nUpdate the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id=\"payment-view\">\n  <form>\n\n\t<input type='text' name='number' placeholder='Card Number'\n\t  value:bind=\"userCardNumber\"/>\n\n\t<input type='text' name='expiry' placeholder='MM-YY'\n\t  value:bind=\"userExpiry\"/>\n\n\t<input type='text' name='cvc' placeholder='CVC'\n\t  value:bind=\"userCVC\"/>\n\n\t<button>Pay ${{amount}}</button>\n\n\t<p>{{userCardNumber}}, {{userExpiry}}, {{userCVC}}</p>\n\t<p>{{cardNumber}}, {{expiryMonth}}-{{expiryYear}}, {{cvc}}</p>\n  </form>\n</script>\n\n```\n<span line-highlight='16,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nStripe.setPublishableKey('pk_test_zCC2JrO3KSMeh7BB5x9OUe2U');\n\nvar PaymentVM = can.DefineMap.extend({\n  amount: {value: 9.99},\n\n  userCardNumber: \"string\",\n  get cardNumber(){\n    return this.userCardNumber ? this.userCardNumber.replace(/-/g,\"\"): null;\n  },\n\n  userExpiry: \"string\",\n  get expiryParts() {\n    if(this.userExpiry) {\n      return this.userExpiry.split(\"-\").map(function(p){\n        return parseInt(p,10);\n\t  });\n    }\n  },\n  get expiryMonth() {\n    return this.expiryParts && this.expiryParts[0];\n  },\n  get expiryYear() {\n    return this.expiryParts && this.expiryParts[1];\n  },\n\n  userCVC: \"string\",\n  get cvc(){\n    return this.userCVC ?\n      parseInt(this.userCVC,10) : null;\n  }\n});\n\nvar viewModel = new PaymentVM();\n\nvar paymentView = can.stache.from(\"payment-view\");\nvar frag = paymentView( viewModel );\ndocument.body.appendChild( frag );\n\n```\n<span line-highlight='7-9,12-24,27-30,only'></span>\n\n\n\n## Validate individual form values\n\n### The problem\n\nWe need to add `class='is-error'` when a form value has a value that\nis not valid according to Stripe’s validators. To do that, we need to\ncreate the following properties that will return an error message for\ntheir respective form property:\n\n- `cardError` - “Invalid card number (ex: 4242-4242-4242).”\n- `expiryError` - “Invalid expiration date (ex: 01-22).”\n- `cvcError` - “Invalid CVC (ex: 123).”\n\n### What you need to know\n\n- Stripe has [validation methods](https://stripe.com/docs/stripe.js/v2#card-validation-helpers):\n  - `Stripe.card.validateCardNumber(number)`\n  - `Stripe.card.validateExpiry(month, year)`\n  - `Stripe.card.validateCVC(cvc)`\n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n  ```html\n  {{#if error}}class='is-error'{{/if}}\n  ```\n\n### The solution\n\nUpdate the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id=\"payment-view\">\n  <form>\n\n    <input type='text' name='number' placeholder='Card Number'\n\t  {{#if cardError}}class='is-error'{{/if}}\n\t  value:bind=\"userCardNumber\"/>\n\n    <input type='text' name='expiry' placeholder='MM-YY'\n\t  {{#if expiryError}}class='is-error'{{/if}}\n\t  value:bind=\"userExpiry\"/>\n\n    <input type='text' name='cvc' placeholder='CVC'\n\t  {{#if cvcError}}class='is-error'{{/if}}\n\t  value:bind=\"userCVC\"/>\n\n\t<button>Pay ${{amount}}</button>\n\n\t<p>{{userCardNumber}}, {{userExpiry}}, {{userCVC}}</p>\n\t<p>{{cardNumber}}, {{expiryMonth}}-{{expiryYear}}, {{cvc}}</p>\n  </form>\n</script>\n\n```\n<span line-highlight='5,9,13,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nStripe.setPublishableKey('pk_test_zCC2JrO3KSMeh7BB5x9OUe2U');\n\nvar PaymentVM = can.DefineMap.extend({\n  amount: {value: 9.99},\n\n  userCardNumber: \"string\",\n  get cardNumber(){\n    return this.userCardNumber ? this.userCardNumber.replace(/-/g,\"\"): null;\n  },\n  get cardError() {\n    if( this.cardNumber && !Stripe.card.validateCardNumber(this.cardNumber) ) {\n      return \"Invalid card number (ex: 4242-4242-4242).\";\n    }\n  },\n\n  userExpiry: \"string\",\n  get expiryParts() {\n    if(this.userExpiry) {\n      return this.userExpiry.split(\"-\").map(function(p){\n        return parseInt(p,10);\n\t  });\n    }\n  },\n  get expiryMonth() {\n    return this.expiryParts && this.expiryParts[0];\n  },\n  get expiryYear() {\n    return this.expiryParts && this.expiryParts[1];\n  },\n  get expiryError() {\n    if( (this.expiryMonth || this.expiryYear) &&\n       !Stripe.card.validateExpiry(this.expiryMonth, this.expiryYear) ) {\n      return \"Invalid expiration date (ex: 01-22).\";\n    }\n  },\n\n  userCVC: \"string\",\n  get cvc(){\n    return this.userCVC ?\n      parseInt(this.userCVC,10) : null;\n  },\n  get cvcError() {\n    if(this.cvc && !Stripe.card.validateCVC(this.cvc)) {\n      return \"Invalid CVC (ex: 123).\";\n    }\n  }\n});\n\nvar viewModel = new PaymentVM();\n\nvar paymentView = can.stache.from(\"payment-view\");\nvar frag = paymentView( viewModel );\ndocument.body.appendChild( frag );\n\n```\n<span line-highlight='10-14,30-35,42-46,only'></span>\n\n\n## Get payment token from Stripe\n\n### The problem\n\nWhen the user submits the form, we need to call stripe to get\na token that we may use to charge the credit card.\nWhen we get a token, we will simply alert it to the user like:\n\n```js\nalert(\"Token: \"+response.id);\n```\n\nAfter submitting the form, you should see an alert like:\n\n![Alert](../../../docs/can-guides/commitment/recipes/credit-card-simple/token-alert.png)\n\n### What you need to know\n\n- Use [can-stache-bindings.event] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked:\n\n   ```html\n   <div on:click=\"doSomething(%event)\"> ... </div>\n   ```\n\n   Notice that it also passed the event object with `%event`.\n\n- To prevent a form from submitting, call `event.preventDefault()`.\n\n- [Stripe.card.createToken](https://stripe.com/docs/stripe.js/v2#card-createToken) can be used to get a token that can be used to charge a card:\n\n  ```js\n  Stripe.card.createToken({\n    number: this.cardNumber,\n    cvc: this.cvc,\n    exp_month: this.expiryMonth,\n    exp_year: this.expiryYear\n  }, stripeResponseHandler(status, response) )\n  ```\n\n  - `stripeResponseHandler` gets called back with either:\n    - success: a status of `200` and a response with an `id` that is the token.\n    - failure: a status other than `200` and a response with an `error.message` value detailing what went wrong.\n\n\n### The solution\n\nUpdate the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id=\"payment-view\">\n  <form on:submit=\"pay(%event)\">\n\n\t<input type='text' name='number' placeholder='Card Number'\n\t  {{#if cardError}}class='is-error'{{/if}}\n\t  value:bind=\"userCardNumber\"/>\n\n\t<input type='text' name='expiry' placeholder='MM-YY'\n\t  {{#if expiryError}}class='is-error'{{/if}}\n\t  value:bind=\"userExpiry\"/>\n\n\t<input type='text' name='cvc' placeholder='CVC'\n\t  {{#if cvcError}}class='is-error'{{/if}}\n\t  value:bind=\"userCVC\"/>\n\n\t<button>Pay ${{amount}}</button>\n\t\n\t<p>{{userCardNumber}}, {{userExpiry}}, {{userCVC}}</p>\n\t<p>{{cardNumber}}, {{expiryMonth}}-{{expiryYear}}, {{cvc}}</p>\n\n  </form>\n</script>\n\n```\n<span line-highlight='2,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nStripe.setPublishableKey('pk_test_zCC2JrO3KSMeh7BB5x9OUe2U');\n\nvar PaymentVM = can.DefineMap.extend({\n  amount: {value: 9.99},\n\n  userCardNumber: \"string\",\n  get cardNumber(){\n    return this.userCardNumber ? this.userCardNumber.replace(/-/g,\"\"): null;\n  },\n  get cardError() {\n    if( this.cardNumber && !Stripe.card.validateCardNumber(this.cardNumber) ) {\n      return \"Invalid card number (ex: 4242-4242-4242).\";\n    }\n  },\n\n  userExpiry: \"string\",\n  get expiryParts() {\n    if(this.userExpiry) {\n      return this.userExpiry.split(\"-\").map(function(p){\n        return parseInt(p,10);\n\t  });\n    }\n  },\n  get expiryMonth() {\n    return this.expiryParts && this.expiryParts[0];\n  },\n  get expiryYear() {\n    return this.expiryParts && this.expiryParts[1];\n  },\n  get expiryError() {\n    if( (this.expiryMonth || this.expiryYear) &&\n       !Stripe.card.validateExpiry(this.expiryMonth, this.expiryYear) ) {\n      return \"Invalid expiration date (ex: 01-22).\";\n    }\n  },\n\n  userCVC: \"string\",\n  get cvc(){\n    return this.userCVC ?\n      parseInt(this.userCVC,10) : null;\n  },\n  get cvcError() {\n    if(this.cvc && !Stripe.card.validateCVC(this.cvc)) {\n      return \"Invalid CVC (ex: 123).\";\n    }\n  },\n\n  pay: function(event){\n    event.preventDefault();\n\n    Stripe.card.createToken({\n      number: this.cardNumber,\n      cvc: this.cvc,\n      exp_month: this.expiryMonth,\n      exp_year: this.expiryYear\n    }, function(status, response){\n      if(status === 200) {\n        alert(\"Token: \"+response.id);\n        // stripe.charges.create({\n        //   amount: this.amount,\n        //   currency: \"usd\",\n        //   description: \"Example charge\",\n        //   source: response.id,\n        // })\n      } else {\n        alert(\"Error: \"+response.error.message);\n      }\n    });\n  }\n});\n\nvar viewModel = new PaymentVM();\n\nvar paymentView = can.stache.from(\"payment-view\");\nvar frag = paymentView( viewModel );\ndocument.body.appendChild( frag );\n\n```\n<span line-highlight='48-69,only'></span>\n\n## Validate the form\n\n### The problem\n\nWe need to show a warning message when information\nis entered incorrectly and disable the form until\nthey have entered it correctly.\n\nTo do that, we’ll add the following properties to the ViewModel:\n\n- `isCardValid` - returns true if the card is valid\n- `isCardInvalid` - returns true if the card is invalid\n- `errorMessage` - returns the error for the first form value that\n  has an error.\n\n### What you need to know\n\n- Use [can-stache-bindings.toChild {$disabled}] to make an input disabled, like:\n\n  ```html\n  <button disabled:from=\"isCardInvalid\">...\n  ```\n\n### The solution\n\nUpdate the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id=\"payment-view\">\n  <form on:submit=\"pay(%event)\">\n\n    {{#if errorMessage}}\n       <div class=\"message\">{{errorMessage}}</div>\n    {{/if}}\n\n    <input type='text' name='number' placeholder='Card Number'\n      {{#if cardError}}class='is-error'{{/if}}\n      value:bind=\"userCardNumber\"/>\n\n    <input type='text' name='expiry' placeholder='MM-YY'\n      {{#if expiryError}}class='is-error'{{/if}}\n      value:bind=\"userExpiry\"/>\n\n    <input type='text' name='cvc' placeholder='CVC'\n      {{#if cvcError}}class='is-error'{{/if}}\n      value:bind=\"userCVC\"/>\n\n    <button disabled:from=\"isCardInvalid\">Pay ${{amount}}</button>\n\n  </form>\n</script>\n\n```\n<span line-highlight='4-6,20,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nStripe.setPublishableKey('pk_test_zCC2JrO3KSMeh7BB5x9OUe2U');\n\nvar PaymentVM = can.DefineMap.extend({\n  amount: {value: 9.99},\n\n  userCardNumber: \"string\",\n  get cardNumber(){\n    return this.userCardNumber ? this.userCardNumber.replace(/-/g,\"\"): null;\n  },\n  get cardError() {\n    if( this.cardNumber && !Stripe.card.validateCardNumber(this.cardNumber) ) {\n      return \"Invalid card number (ex: 4242-4242-4242).\";\n    }\n  },\n\n  userExpiry: \"string\",\n  get expiryParts() {\n    if(this.userExpiry) {\n      return this.userExpiry.split(\"-\").map(function(p){\n        return parseInt(p,10);\n\t  });\n    }\n  },\n  get expiryMonth() {\n    return this.expiryParts && this.expiryParts[0];\n  },\n  get expiryYear() {\n    return this.expiryParts && this.expiryParts[1];\n  },\n  get expiryError() {\n    if( (this.expiryMonth || this.expiryYear) &&\n       !Stripe.card.validateExpiry(this.expiryMonth, this.expiryYear) ) {\n      return \"Invalid expiration date (ex: 01-22).\";\n    }\n  },\n\n  userCVC: \"string\",\n  get cvc(){\n    return this.userCVC ?\n      parseInt(this.userCVC,10) : null;\n  },\n  get cvcError() {\n    if(this.cvc && !Stripe.card.validateCVC(this.cvc)) {\n      return \"Invalid CVC (ex: 123).\";\n    }\n  },\n\n  pay: function(event){\n    event.preventDefault();\n\n    Stripe.card.createToken({\n      number: this.cardNumber,\n      cvc: this.cvc,\n      exp_month: this.expiryMonth,\n      exp_year: this.expiryYear\n    }, function(status, response){\n      if(status === 200) {\n        alert(\"Token: \"+response.id);\n        // stripe.charges.create({\n        //   amount: this.amount,\n        //   currency: \"usd\",\n        //   description: \"Example charge\",\n        //   source: response.id,\n        // })\n      } else {\n        alert(\"Error: \"+response.error.message);\n      }\n    });\n  },\n\n  get isCardValid(){\n    return Stripe.card.validateCardNumber(this.cardNumber) &&\n      Stripe.card.validateExpiry(this.expiryMonth, this.expiryYear) &&\n      Stripe.card.validateCVC(this.cvc);\n  },\n  get isCardInvalid(){\n    return !this.isCardValid;\n  },\n  get errorMessage(){\n    return this.cardError || this.expiryError || this.cvcError;\n  }\n});\n\nvar viewModel = new PaymentVM();\n\nvar paymentView = can.stache.from(\"payment-view\");\nvar frag = paymentView( viewModel );\ndocument.body.appendChild( frag );\n\n```\n<span line-highlight='71-81,only'></span>\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "This guide walks through building a very simple credit card payment form.  It uses [Stripe.js v2 API](https://stripe.com/docs/stripe.js/v2) to create a token\nwhich can be used to create a charge.  It also performs\nsimple validation on the payment form values.\n\n\n",
    "name": "guides/recipes/credit-card-simple",
    "title": "Credit Card Guide (Simple)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes/cta-bus-map": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/cta-bus-map/cta-bus-map.md"
    },
    "body": "\nIn this guide you will learn how to:\n\n- Use `fetch` to request data.\n- Create a custom element that wraps a google map.\n- Add markers to the google map.\n\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/zewenov/4/embed?output&height=600px\">JS Bin on jsbin.com</a>\n\nTo use the widget:\n\n1. __Click__ a _Bus Route_.\n2. __Explore__ the markers added to the Google Map showing the bus locations for that route.\n3. __Click__ the _route name overlay_ to refresh the bus locations.\n\nThe following sections are broken down the following parts:\n\n- __The problem__ — A description of what the section is trying to accomplish.\n- __What you need to know__ — Information about CanJS that is useful for solving the problem.\n- __How to verify it works__ - How to make sure the solution works if it's not obvious.\n- __The solution__ — The solution to the problem.\n\n## Setup ##\n\n__START THIS TUTORIAL BY CLONING THE FOLLOWING JS Bin__:\n\n> Click the `JS Bin` button.  The JSBin will open in a new window. In that new window, under `File`, click `Clone`.\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/xumeboy/embed?html,js,output\">CanJS Bus Demo on jsbin.com</a>\n\nThis JS Bin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\n\n\n\n### What you need to know\n\nThere's nothing to do in this step. The JSBin is already setup with:\n\n- A _basic_ CanJS setup.\n- A promise that resolves when the Google Maps has loaded.\n- Some variables useful to make requests to get bus routes and locations.\n\nPlease read on to understand the setup.\n\n__A Basic CanJS Setup__\n\n- A basic CanJS setup uses instances of a ViewModel to manage the\n  behavior of a View.  A ViewModel type is defined, an instance of it\n  is created and passed to a View as follows:\n\n  ```js\n  // Define the ViewModel type\n  var MyViewModel = can.DefineMap.extend(\"MyViewModel\",{\n   ...      \n  })\n  // Create an instance of the ViewModel\n  var viewModel = new MyViewModel();\n  // Get a View\n  var view = can.stache.from(\"my-view\");\n  // Render the View with the ViewModel instance\n  var frag = view(viewModel);\n  document.body.appendChild(frag);\n  ```\n\n- CanJS uses [can-stache] to render data in a template\n  and keep it live.  Templates can be authored in `<script>` tags like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-view\">\n    TEMPLATE CONTENT\n  </script>\n  ```\n\n  A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] \"magic tags\" to insert data into\n  the HTML output like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-view\">\n    {{something.name}}\n  </script>\n  ```\n\n- Load a template from a `<script>` tag with [can-stache.from can.stache.from] like:\n  ```js\n  var template = can.stache.from(SCRIPT_ID);\n  ```\n\n- Render the template with data into a documentFragment like:\n\n  ```js\n  var frag = template({\n    something: {name: \"Derek Brunson\"}\n  });\n  ```\n\n- Insert a fragment into the page with:\n\n  ```js\n  document.body.appendChild(frag);\n  ```\n\n__Loading Google Maps API__\n\nThe following loads [Google Maps API](https://developers.google.com/maps/documentation/javascript/):\n\n```\n<script>\n  window.googleAPI = new Promise(function(resolve){\n    const script = document.createElement(\"script\");\n    script.src = \"https://maps.googleapis.com/maps/api/js?key=AIzaSyD7POAQA-i16Vws48h4yRFVGBZzIExOAJI\";\n    document.body.appendChild( script );\n    script.onload = resolve;\n  });\n</script>\n```\n\nIt creates a global `googleAPI` promise that resolves when Google Maps is ready.  You can use it like:\n\n```js\ngoogleAPI.then(function(){\n    new google.maps.Map( ... );\n})\n```\n\n__Loading CTA Bus Data__\n\nThis app needs to make requests to the [http://www.ctabustracker.com/](http://www.ctabustracker.com/) API.  The\n`ctabustracker` API is hosted at:\n\n```js\nvar apiRoot = \"http://www.ctabustracker.com/bustime/api/v2/\"\n```\n\nThe API needs a token as part of the request:\n\n```js\nvar token = \"?key=piRYHjJ5D2Am39C9MxduHgRZc&format=json\";\n```\n\nHowever, the API does __not__ support cross origin requests.  Therefore, we will request data using\na proxy hosted at:\n\n```js\nvar proxyUrl = \"https://can-cors.herokuapp.com/\"\n```\n\nWith that proxy, the requests for this app will look like:\n\n```js\nfetch(\"https://can-cors.herokuapp.com/\"+\n    \"http://www.ctabustracker.com/bustime/api/v2/\"+\n    \"getroutes\"+\n    \"?key=piRYHjJ5D2Am39C9MxduHgRZc&format=json\")\n```\n\n## Change the app title ##\n\n### The problem\n\nIn this section, we will:\n\n- Explore the relationship between ViewModel and View.\n- Make it so the title of the page changes from `<h1>YOUR TITLE HERE</h1>`\n  to `<h1>CHICAGO CTA BUS TRACKER</h1>`.\n- Let us adjust the title simply by changing the viewModel like:\n  ```js\n  viewModel.title = \"TITLE UPDATED\"\n  ```\n\n![YOUR TITLE HERE](../../../docs/can-guides/commitment/recipes/cta-bus-map/1-app-title.png)\n\n\n### What you need to know\n\n\n\n\n- A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] magic tags to insert data into\n  the HTML output like:\n\n  ```html\n  {{someValue}}\n  ```\n\n  These values come from a ViewModel or Model.\n\n- The [can-define.types.value] property definition can return the initial value of a property like:\n  ```js\n  var AppViewModel = can.DefineMap.extend({\n\tsomeValue: {\n\t  value: \"This string\"\n\t}  \n  });\n  new AppViewModel().someValue //-> \"This string\"\n  ```\n\n### How to verify it works\n\nRun the folowing in the `Console` tab:\n\n```js\nviewModel.title = \"TITLE UPDATED\"\n```\n\nYou should see the title update.\n\n### The solution\n\nUpdate the `view` in the __HTML__ tab to:\n\n\n```html\n<div class=\"top\">\n  <div class=\"header\">\n    <h1>{{title}}</h1>\n    <p>Loading routes…</p>\n  </div>\n  <ul class=\"routes-list\">\n    <li>\n      <span class=\"route-number\">1</span>\n      <span class=\"route-name\">Bronzeville/Union Station</span>\n      <span class=\"check\">✔</span>\n    </li>\n    <li class=\"active\">\n      <span class=\"route-number\">2</span>\n      <span class=\"route-name\">Hyde Park Express</span>\n      <span class=\"check\">✔</span>\n    </li>\n  </ul>\n</div>\n<div class=\"bottom\">\n  <div class=\"route-selected\">\n    <small>Route 2:</small> Hyde Park Express\n    <div class=\"error-message\">No vehicles available for this route</div>\n  </div>\n  <div class='gmap'>Google map will go here.</div>\n</div>\n\n```\n<span line-highlight='3,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar proxyUrl = \"https://can-cors.herokuapp.com/\";\nvar token = \"?key=piRYHjJ5D2Am39C9MxduHgRZc&format=json\";\nvar apiRoot = \"http://www.ctabustracker.com/bustime/api/v2/\"\nvar getRoutesEnpoint = apiRoot + \"getroutes\" + token;\nvar getVehiclesEndpoint = apiRoot + \"getvehicles\" + token;\n\nvar BusTrackerVM = can.DefineMap.extend({\n  title: {\n    value: \"Chicago CTA Bus Tracker\"\n  }\n});\n\nvar viewModel = new BusTrackerVM();\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='8-10,only'></span>\n\n\n\n## List bus routes ##\n\n### The problem\n\nIn this section, we will:\n\n- Load and list bus routes.\n- Show `<p>Loading routes…</p>` while loading routes.\n\n![List Bus Routes](../../../docs/can-guides/commitment/recipes/cta-bus-map/2-list-routes.png)\n\n\nWe will do this by:\n\n- Store the promise of bus routes in a `routesPromise` property.\n- `routesPromise` will resolve to an `Array` of the routes.\n- Loop through each route and add an `<li>` to the page.\n- Show the loading message while `routesPromise` is pending.\n\n\n### What you need to know\n\n- The [can-define.types.value] property definition can return the initial value of a property like:\n  ```js\n  var AppViewModel = can.DefineMap.extend({\n\tmyProperty: {\n\t  value: function(){\n\t\treturn new Promise( .... );\n\t  }\n\t}  \n  });\n  new AppViewModel().myProperty //-> Promise\n  ```\n- The [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) is an easy way to make requests\n  to a URL and get back JSON.  Use it like:\n\n  ```js\n  fetch(url).then(function(response){\n\t  return response.json();\n  }).then(function(data){\n\n  });\n  ```\n\n  You'll want to use the `proxyUrl` and `getRoutesEnpoint` variables to make a request for\n  CTA bus routes. The routes service returns data like:\n\n  ```js\n  {\n\t\"bustime-response\": {\n\t\t\"routes\": [\n\t\t\t{\n\t\t\t\t\"rt\": \"1\",\n\t\t\t\t\"rtnm\": \"Bronzeville/Union Station\",\n\t\t\t\t\"rtclr\": \"#336633\",\n\t\t\t\t\"rtdd\": \"1\"\n\t\t\t},\n            ...\n        ]\n    }\n  }\n  ```\n\n  Make sure that `routesPromise` will be a Promise that resolves to an array of routes.\n\n- Promises can transform data by returning new values.  For example if `outerPromise`\n  resolves to `{innerData: {name: \"inner\"}}`, `resultPromise` will resolve to\n  `{name: \"inner\"}`:\n  ```js\n  var resultPromise = outerPromise.then(function(data){\n      return data.innerData;\n  });\n  ```\n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n- Use [can-stache.helpers.each {{#each value}}] to do looping in `can-stache`.\n- `Promise`s are observable in [can-stache].  Given a promise `somePromise`, you can:\n  - Check if the promise is loading like: `{{#if somePromise.isPending}}`.\n  - Loop through the resolved value of the promise like: `{{#each somePromise.value}}`.\n\n### The solution\n\nUpdate the `view` in the __HTML__ tab to:\n\n\n```html\n<div class=\"top\">\n  <div class=\"header\">\n    <h1>{{title}}</h1>\n    {{#if routesPromise.isPending}}<p>Loading routes…</p>{{/if}}\n  </div>\n  <ul class=\"routes-list\">\n    {{#each routesPromise.value}}\n      <li>\n        <span class=\"route-number\">{{this.rt}}</span>\n        <span class=\"route-name\">{{this.rtnm}}</span>\n        <span class=\"check\">✔</span>\n      </li>\n    {{/each}}\n  </ul>\n</div>\n<div class=\"bottom\">\n  <div class=\"route-selected\">\n    <small>Route 2:</small> Hyde Park Express\n    <div class=\"error-message\">No vehicles available for this route</div>\n  </div>\n  <div class='gmap'>Google map will go here.</div>\n</div>\n\n```\n<span line-highlight='4,7-13,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar proxyUrl = \"https://can-cors.herokuapp.com/\";\nvar token = \"?key=piRYHjJ5D2Am39C9MxduHgRZc&format=json\";\nvar apiRoot = \"http://www.ctabustracker.com/bustime/api/v2/\"\nvar getRoutesEnpoint = apiRoot + \"getroutes\" + token;\nvar getVehiclesEndpoint = apiRoot + \"getvehicles\" + token;\n\nvar BusTrackerVM = can.DefineMap.extend({\n  title: {\n    value: \"Chicago CTA Bus Tracker\"\n  },\n  routesPromise: {\n    value() {\n      return fetch(proxyUrl + getRoutesEnpoint)\n        .then(response => response.json())\n        .then(data => data[\"bustime-response\"].routes);\n    }\n  }\n});\n\nvar viewModel = new BusTrackerVM();\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='11-17,only'></span>\n\n\n## Pick a route and log bus locations ##\n\n### The problem\n\nIn this section, we will:\n\n- Highlight the selected bus route after a user clicks it.\n- Log the bus (vehicle) locations for the selected route.\n\n<img src=\"../../../docs/can-guides/commitment/recipes/cta-bus-map/3-pick-route.png\" width=\"857px\"/>\n\nWe will do this by:\n\n- Listening to when a user clicks one of the bus routes.\n- Adding `active` to the class name of that route's `<li>` like: `<li class=\"active\">`.\n- Making the request for the vehicle locations of the selected route.\n\n### What you need to know\n\n- Use [can-stache-bindings.event] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked:\n\n  ```html\n  <div on:click=\"doSomething()\"> ... </div>\n  ```\n- Use the `\"any\"` type to define a property of indeterminate type:\n  ```js\n  var AppViewModel = can.DefineMap.extend({\n\tmyProperty: \"any\"  \n  });\n  var viewModel = new AppViewModel({});\n  viewModel.myProperty = ANYTHING;\n  ```\n  You'll want to store the selected bus route as `route`.\n- Use `fetch(proxyUrl + getVehiclesEndpoint + \"&rt=\" + route.rt)`\n  to get the vehicles for a particular route. If there is route data, it comes\n  back like:\n  ```js\n  {\n\t\"bustime-response\": {\n\t\t\"vehicle\": [\n\t\t\t{\n\t\t\t\t\"vid\": \"8026\",\n\t\t\t\t\"tmstmp\": \"20171004 09:18\",\n\t\t\t\t\"lat\": \"41.73921241760254\",\n\t\t\t\t\"lon\": \"-87.66306991577149\",\n\t\t\t\t\"hdg\": \"359\",\n\t\t\t\t\"pid\": 3637,\n\t\t\t\t\"rt\": \"9\",\n\t\t\t\t\"des\": \"74th\",\n\t\t\t\t\"pdist\": 6997,\n\t\t\t\t\"dly\": false,\n\t\t\t\t\"tatripid\": \"10002232\",\n\t\t\t\t\"tablockid\": \"X9  -607\",\n\t\t\t\t\"zone\": \"\"\n\t\t\t},\n            ...\n        ]\n    }\n  }\n  ```\n\n  If there is an error or no busses, the response looks like:\n\n  ```js\n  {\n\t\"bustime-response\": {\n\t\t\"error\": [\n\t\t\t{\n\t\t\t\t\"rt\": \"5\",\n\t\t\t\t\"msg\": \"No data found for parameter\"\n\t\t\t}\n\t\t]\n\t}\n  }\n  ```\n\n\n\n### How to verify it works\n\nIn the `Console` tab, when you click a bus route (like `Cottage Grove`), you should see\nan array of bus routes.\n\n### The solution\nUpdate the `view` in the __HTML__ tab to:\n\n\n```html\n<div class=\"top\">\n  <div class=\"header\">\n    <h1>{{title}}</h1>\n    {{#if routesPromise.isPending}}<p>Loading routes…</p>{{/if}}\n  </div>\n  <ul class=\"routes-list\">\n    {{#each routesPromise.value}}\n      <li on:click=\"pickRoute(this)\" {{#eq this route}}class=\"active\"{{/eq}}>\n        <span class=\"route-number\">{{this.rt}}</span>\n        <span class=\"route-name\">{{this.rtnm}}</span>\n        <span class=\"check\">✔</span>\n      </li>\n    {{/each}}\n  </ul>\n</div>\n<div class=\"bottom\">\n  {{#if route}}\n    <div class=\"route-selected\">\n      <small>Route {{route.rt}}:</small> {{route.rtnm}}\n      <div class=\"error-message\">No vehicles available for this route</div>\n    </div>\n  {{/if}}\n  <div class='gmap'>Google map will go here.</div>\n</div>\n\n```\n<span line-highlight='8,17-22,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar proxyUrl = \"https://can-cors.herokuapp.com/\";\nvar token = \"?key=piRYHjJ5D2Am39C9MxduHgRZc&format=json\";\nvar apiRoot = \"http://www.ctabustracker.com/bustime/api/v2/\"\nvar getRoutesEnpoint = apiRoot + \"getroutes\" + token;\nvar getVehiclesEndpoint = apiRoot + \"getvehicles\" + token;\n\nvar BusTrackerVM = can.DefineMap.extend({\n  title: {\n    value: \"Chicago CTA Bus Tracker\"\n  },\n  routesPromise: {\n    value() {\n      return fetch(proxyUrl + getRoutesEnpoint)\n        .then(response => response.json())\n        .then(data => data[\"bustime-response\"].routes);\n    }\n  },\n  route: 'any',\n  pickRoute(route) {\n    this.route = route;\n    fetch(proxyUrl + getVehiclesEndpoint + \"&rt=\" + route.rt)\n      .then(response => response.json())\n      .then(data => {\n        if (data[\"bustime-response\"].error) {\n          console.log(data[\"bustime-response\"].error);\n        } else {\n          console.log( data[\"bustime-response\"].vehicle );\n        }\n      });\n  }\n});\n\nvar viewModel = new BusTrackerVM();\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='18-30,only'></span>\n\n\n\n## Show when busses are loading and the number of buses ##\n### The problem\n\nIn this section, we will:\n\n- Show `<p>Loading vehicles…</p>` while bus data is being loaded.\n- Show `<div class=\"error-message\">No vehicles available for this route</div>` in the overlay\n  if the request for bus data failed.  \n- Show the number of busses inside the `<div class='gmap'>` like: `Bus count: 20`.\n\n<img src=\"../../../docs/can-guides/commitment/recipes/cta-bus-map/3b-bus-loading.png\" width=\"427px\"/>\n\n\nWe will do this by:\n\n- Defining and setting a `vehiclesPromise` property.\n\n### What you need to know\n\n- In stache, you can check if a promise was rejected like:\n  ```html\n  {{#if somePromise.isRejected}}<p>...</p>{{/if}}\n  ```\n- The [Promise.reject](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject) method returns a rejected promise with the provided `reason`:\n  ```js\n  var rejectedPromise = Promise.reject({message: \"something went wrong\"});\n  ```\n- Promises can transform data by returning new promises.  For example if `outerPromise`\n  resolves to `{innerData: {name: \"inner\"}}`, `resultPromise` will be a rejected promise\n  with the `reason` as `{name: \"inner\"}`:\n  ```js\n  var resultPromise = outerPromise.then(function(data){\n      return Promise.reject(data.innerData);\n  });\n  resultPromise.catch(function(reason){\n      reason.name //-> \"inner\"\n  });\n  ```\n\n### The solution\nUpdate the `view` in the __HTML__ tab to:\n\n\n```html\n<div class=\"top\">\n  <div class=\"header\">\n    <h1>{{title}}</h1>\n    {{#if routesPromise.isPending}}<p>Loading routes…</p>{{/if}}\n    {{#if vehiclesPromise.isPending}}<p>Loading vehicles…</p>{{/if}}\n  </div>\n  <ul class=\"routes-list\">\n    {{#each routesPromise.value}}\n      <li on:click=\"pickRoute(this)\" {{#eq this route}}class=\"active\"{{/eq}}>\n        <span class=\"route-number\">{{this.rt}}</span>\n        <span class=\"route-name\">{{this.rtnm}}</span>\n        <span class=\"check\">✔</span>\n      </li>\n    {{/each}}\n  </ul>\n</div>\n<div class=\"bottom\">\n  {{#if route}}\n    <div class=\"route-selected\">\n      <small>Route {{route.rt}}:</small> {{route.rtnm}}\n      {{#if vehiclesPromise.isRejected}}\n        <div class=\"error-message\">No vehicles available for this route</div>\n      {{/if}}\n    </div>\n  {{/if}}\n  <div class='gmap'>Bus count: {{vehiclesPromise.value.length}}</div>\n</div>\n\n```\n<span line-highlight='5,21-23,26,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar proxyUrl = \"https://can-cors.herokuapp.com/\";\nvar token = \"?key=piRYHjJ5D2Am39C9MxduHgRZc&format=json\";\nvar apiRoot = \"http://www.ctabustracker.com/bustime/api/v2/\"\nvar getRoutesEnpoint = apiRoot + \"getroutes\" + token;\nvar getVehiclesEndpoint = apiRoot + \"getvehicles\" + token;\n\nvar BusTrackerVM = can.DefineMap.extend({\n  title: {\n    value: \"Chicago CTA Bus Tracker\"\n  },\n  routesPromise: {\n    value() {\n      return fetch(proxyUrl + getRoutesEnpoint)\n        .then(response => response.json())\n        .then(data => data[\"bustime-response\"].routes);\n    }\n  },\n  route: 'any',\n  vehiclesPromise: 'any',\n  pickRoute(route) {\n    this.route = route;\n    this.vehiclesPromise = fetch(proxyUrl + getVehiclesEndpoint + \"&rt=\" + route.rt)\n      .then(response => response.json())\n      .then(data => {\n        if (data[\"bustime-response\"].error) {\n          return Promise.reject(data[\"bustime-response\"].error[0]);\n        } else {\n          return data[\"bustime-response\"].vehicle;\n        }\n      });\n  }\n});\n\nvar viewModel = new BusTrackerVM();\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='19,22,26,28,only'></span>\n\n\n## Initialize Google Maps to show Chicago ##\n\n### The problem\n\nIn this section, we will:\n\n- Create a custom `<google-map-view/>` element that adds a google\n  map.\n- The google map should be added to a `<div class='gmap'/>` element.\n- The google map should be centered on Chicago (latitude: `41.881`, longitude `-87.623`).\n\n<img src=\"../../../docs/can-guides/commitment/recipes/cta-bus-map/4-init-gmaps.png\" width=\"428px\"/>\n\nWe will do this by:\n\n- Creating a custom [can-component] element that adds the `<div class='gmap'/>` to its HTML.\n- Listens to when the element is in the page and creates a new google map.\n\n### What you need to know\n\n- Use [can-component] to create custom elements.  Start by [can-component.extend extending]\n  `Component` with the `tag` of the element:\n\n  ```js\n  can.Component.extend({\n    tag: \"google-map-view\"\n  });\n  ```\n\n  Next, provide the HTML [can-stache] template with the content you want to insert within\n  the element.\n\n  ```js\n  can.Component.extend({\n    tag: \"google-map-view\",\n    view: stache(`<div class='gmap'/>`)\n  });\n  ```\n\n  Any values you want the custom element to hold must be defined on the `ViewModel`. If the `ViewModel`\n  is a plain `Object`, that object will be used to extend [can-define/map/map DefineMap] and create a new\n  type.  The following specifies a `map` property that can be any value:\n\n  ```js\n  can.Component.extend({\n    tag: \"google-map-view\",\n    view: stache(`<div class='gmap'/>`),\n    ViewModel: {\n      map: \"any\"\n    }\n  });\n  ```\n\n  A component's [can-component.prototype.events] object can be used to listen to events on the\n  `ViewModel` or the `element`.  If you want to know when the custom element is [can-util/dom/events/inserted/inserted], you can do it as follows:\n\n  ```js\n  can.Component.extend({\n    tag: \"google-map-view\",\n    view: stache(`<div class='gmap'/>`),\n    ViewModel: {\n      map: \"any\"\n    },\n    events: {\n      \"{element} inserted\": function(){\n        this.viewModel //-> the ViewModel instance\n        this.element //-> the <google-map-view> element\n      }\n    }\n  });\n  ```\n\n- To create a google map, use [new google.map.Map(...)](https://developers.google.com/maps/documentation/javascript/reference) once the\n  `googleAPI` has completed loading:\n\n  ```js\n  new google.maps.Map(gmapDiv, {\n      zoom: 10,\n      center: {\n          lat: 41.881,\n          lng: -87.623\n      }\n  })\n  ```\n\n\n### The solution\nUpdate the `view` in the __HTML__ tab to:\n\n\n```html\n<div class=\"top\">\n  <div class=\"header\">\n    <h1>{{title}}</h1>\n    {{#if routesPromise.isPending}}<p>Loading routes…</p>{{/if}}\n    {{#if vehiclesPromise.isPending}}<p>Loading vehicles…</p>{{/if}}\n  </div>\n  <ul class=\"routes-list\">\n    {{#each routesPromise.value}}\n      <li on:click=\"pickRoute(this)\" {{#eq this route}}class=\"active\"{{/eq}}>\n        <span class=\"route-number\">{{this.rt}}</span>\n        <span class=\"route-name\">{{this.rtnm}}</span>\n        <span class=\"check\">✔</span>\n      </li>\n    {{/each}}\n  </ul>\n</div>\n<div class=\"bottom\">\n  {{#if route}}\n    <div class=\"route-selected\">\n      <small>Route {{route.rt}}:</small> {{route.rtnm}}\n      {{#if vehiclesPromise.isRejected}}\n        <div class=\"error-message\">No vehicles available for this route</div>\n      {{/if}}\n    </div>\n  {{/if}}\n  <google-map-view/>\n</div>\n\n```\n<span line-highlight='26,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar proxyUrl = \"https://can-cors.herokuapp.com/\";\nvar token = \"?key=piRYHjJ5D2Am39C9MxduHgRZc&format=json\";\nvar apiRoot = \"http://www.ctabustracker.com/bustime/api/v2/\"\nvar getRoutesEnpoint = apiRoot + \"getroutes\" + token;\nvar getVehiclesEndpoint = apiRoot + \"getvehicles\" + token;\n\nvar BusTrackerVM = can.DefineMap.extend({\n  title: {\n    value: \"Chicago CTA Bus Tracker\"\n  },\n  routesPromise: {\n    value() {\n      return fetch(proxyUrl + getRoutesEnpoint)\n        .then(response => response.json())\n        .then(data => data[\"bustime-response\"].routes);\n    }\n  },\n  route: 'any',\n  vehiclesPromise: 'any',\n  pickRoute(route) {\n    this.route = route;\n    this.vehiclesPromise = fetch(proxyUrl + getVehiclesEndpoint + \"&rt=\" + route.rt)\n      .then(response => response.json())\n      .then(data => {\n        if (data[\"bustime-response\"].error) {\n          return Promise.reject(data[\"bustime-response\"].error[0]);\n        } else {\n          return data[\"bustime-response\"].vehicle;\n        }\n      });\n  }\n});\n\ncan.Component.extend({\n  tag: \"google-map-view\",\n  view: can.stache(`<div class='gmap'></div>`),\n  ViewModel: {\n    map: 'any'\n  },\n  events: {\n    \"{element} inserted\": function() {\n      googleAPI.then(() => {\n        this.viewModel.map = new google.maps.Map(this.element.firstChild, {\n          zoom: 10,\n          center: {\n            lat: 41.881,\n            lng: -87.623\n          }\n        });\n      });\n    }\n  }\n});\n\nvar viewModel = new BusTrackerVM();\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='34-53,only'></span>\n\n\n\n\n## Set markers for vehicle locations ##\n\n### The problem\n\nIn this section, we will:\n\n- Show markers at bus locations when the user clicks a route.\n\nWe will do this by:\n\n- Passing the `vehicles` from `vehiclePromise` to `<google-map-view>`.\n- Listening when `vehicles` changes and creating google map `Marker`s.\n\n\n### What you need to know\n\n- [can-stache-bindings.toChild childProp:from] can set a component's ViewModel from another value:\n  ```js\n  <google-map-view viewModelProp:from=\"scopeValue\"/>\n  ```\n- The [can-component.prototype.events] can listen to changes in the `ViewModel` instance with:\n  `\"{viewModel} propertyName\"` like:\n\n  ```js\n  can.Component.extend({\n    ...\n    events: {\n      \"{viewModel} vehicles\": function(viewModel, event, newVehicles) {\n          // do stuff with the newVehicles\n      }      \n    }\n  })\n  ```\n\n- Use [new google.maps.Marker](https://developers.google.com/maps/documentation/javascript/reference#Marker) to\n  add a marker to a map like:\n\n  ```js\n  new google.maps.Marker({\n    position: {\n      lat: parseFloat(vehicle.lat),\n      lng: parseFloat(vehicle.lon)\n    },\n    map: this.viewModel.map\n  });\n  ```\n\n### The solution\nUpdate the `view` in the __HTML__ tab to:\n\n\n```html\n<div class=\"top\">\n  <div class=\"header\">\n    <h1>{{title}}</h1>\n    {{#if routesPromise.isPending}}<p>Loading routes…</p>{{/if}}\n    {{#if vehiclesPromise.isPending}}<p>Loading vehicles…</p>{{/if}}\n  </div>\n  <ul class=\"routes-list\">\n    {{#each routesPromise.value}}\n      <li on:click=\"pickRoute(this)\" {{#eq this route}}class=\"active\"{{/eq}}>\n        <span class=\"route-number\">{{this.rt}}</span>\n        <span class=\"route-name\">{{this.rtnm}}</span>\n        <span class=\"check\">✔</span>\n      </li>\n    {{/each}}\n  </ul>\n</div>\n<div class=\"bottom\">\n  {{#if route}}\n    <div class=\"route-selected\">\n      <small>Route {{route.rt}}:</small> {{route.rtnm}}\n      {{#if vehiclesPromise.isRejected}}\n        <div class=\"error-message\">No vehicles available for this route</div>\n      {{/if}}\n    </div>\n  {{/if}}\n  <google-map-view vehicles:from=\"vehiclesPromise.value\"/>\n</div>\n\n```\n<span line-highlight='26,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar proxyUrl = \"https://can-cors.herokuapp.com/\";\nvar token = \"?key=piRYHjJ5D2Am39C9MxduHgRZc&format=json\";\nvar apiRoot = \"http://www.ctabustracker.com/bustime/api/v2/\"\nvar getRoutesEnpoint = apiRoot + \"getroutes\" + token;\nvar getVehiclesEndpoint = apiRoot + \"getvehicles\" + token;\n\nvar BusTrackerVM = can.DefineMap.extend({\n  title: {\n    value: \"Chicago CTA Bus Tracker\"\n  },\n  routesPromise: {\n    value() {\n      return fetch(proxyUrl + getRoutesEnpoint)\n        .then(response => response.json())\n        .then(data => data[\"bustime-response\"].routes);\n    }\n  },\n  route: 'any',\n  vehiclesPromise: 'any',\n  pickRoute(route) {\n    this.route = route;\n    this.vehiclesPromise = fetch(proxyUrl + getVehiclesEndpoint + \"&rt=\" + route.rt)\n      .then(response => response.json())\n      .then(data => {\n        if (data[\"bustime-response\"].error) {\n          return Promise.reject(data[\"bustime-response\"].error[0]);\n        } else {\n          return data[\"bustime-response\"].vehicle;\n        }\n      });\n  }\n});\n\ncan.Component.extend({\n  tag: \"google-map-view\",\n  view: can.stache(`<div class='gmap'></div>`),\n  ViewModel: {\n    map: 'any',\n    vehicles: 'any'\n  },\n  events: {\n    \"{viewModel} vehicles\": function(vm, ev, newVehicles) {\n      if ( newVehicles ) {\n        newVehicles.map(vehicle => {\n          return new google.maps.Marker({\n            position: {\n              lat: parseFloat(vehicle.lat),\n              lng: parseFloat(vehicle.lon)\n            },\n            map: this.viewModel.map\n          });\n        });\n      }\n    },\n    \"{element} inserted\": function() {\n      googleAPI.then(() => {\n        this.viewModel.map = new google.maps.Map(this.element.firstChild, {\n          zoom: 10,\n          center: {\n            lat: 41.881,\n            lng: -87.623\n          }\n        });\n      });\n    }\n  }\n});\n\nvar viewModel = new BusTrackerVM();\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='39,42-54,only'></span>\n\n\n\n\n## Clean up markers when locations change ##\n\n### The problem\n\nIn this section we will:\n\n- Remove markers from previous routes.\n- Update marker locations when the user clicks the overlay.\n\nWe will do this by:\n\n- Storing the active list of markers on the `ViewModel`\n- Clearing the old active markers when the list of vehicles is updated.\n- Calling `pickRoute` when someone clicks on the `route-selected` overlay.\n\n### What you need to know\n\n\n- Use `marker.setMap(null)` to remove a marker from a map.\n\n\n### The solution\nUpdate the `view` in the __HTML__ tab to:\n\n\n```html\n<div class=\"top\">\n  <div class=\"header\">\n    <h1>{{title}}</h1>\n    {{#if routesPromise.isPending}}<p>Loading routes…</p>{{/if}}\n    {{#if vehiclesPromise.isPending}}<p>Loading vehicles…</p>{{/if}}\n  </div>\n  <ul class=\"routes-list\">\n    {{#each routesPromise.value}}\n      <li on:click=\"pickRoute(this)\" {{#eq this route}}class=\"active\"{{/eq}}>\n        <span class=\"route-number\">{{this.rt}}</span>\n        <span class=\"route-name\">{{this.rtnm}}</span>\n        <span class=\"check\">✔</span>\n      </li>\n    {{/each}}\n  </ul>\n</div>\n<div class=\"bottom\">\n  {{#if route}}\n    <div class=\"route-selected\" on:click=\"pickRoute(route)\">\n      <small>Route {{route.rt}}:</small> {{route.rtnm}}\n      {{#if vehiclesPromise.isRejected}}\n        <div class=\"error-message\">No vehicles available for this route</div>\n      {{/if}}\n    </div>\n  {{/if}}\n  <google-map-view vehicles:from=\"vehiclesPromise.value\"/>\n</div>\n\n```\n<span line-highlight='19,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar proxyUrl = \"https://can-cors.herokuapp.com/\";\nvar token = \"?key=piRYHjJ5D2Am39C9MxduHgRZc&format=json\";\nvar apiRoot = \"http://www.ctabustracker.com/bustime/api/v2/\"\nvar getRoutesEnpoint = apiRoot + \"getroutes\" + token;\nvar getVehiclesEndpoint = apiRoot + \"getvehicles\" + token;\n\nvar BusTrackerVM = can.DefineMap.extend({\n  title: {\n    value: \"Chicago CTA Bus Tracker\"\n  },\n  routesPromise: {\n    value() {\n      return fetch(proxyUrl + getRoutesEnpoint)\n        .then(response => response.json())\n        .then(data => data[\"bustime-response\"].routes);\n    }\n  },\n  route: 'any',\n  vehiclesPromise: 'any',\n  pickRoute(route) {\n    this.route = route;\n    this.vehiclesPromise = fetch(proxyUrl + getVehiclesEndpoint + \"&rt=\" + route.rt)\n      .then(response => response.json())\n      .then(data => {\n        if (data[\"bustime-response\"].error) {\n          return Promise.reject(data[\"bustime-response\"].error[0]);\n        } else {\n          return data[\"bustime-response\"].vehicle;\n        }\n      });\n  }\n});\n\ncan.Component.extend({\n  tag: \"google-map-view\",\n  view: can.stache(`<div class='gmap'></div>`),\n  ViewModel: {\n    map: 'any',\n    vehicles: 'any',\n    markers: 'any'\n  },\n  events: {\n    \"{viewModel} vehicles\": function(vm, ev, newVehicles) {\n      if (Array.isArray(this.markers)) {\n        this.markers.forEach(marker => {\n          marker.setMap(null);\n        });\n        this.markers = null;\n      }\n      if ( newVehicles ) {\n        this.markers = newVehicles.map(vehicle => {\n          return new google.maps.Marker({\n            position: {\n              lat: parseFloat(vehicle.lat),\n              lng: parseFloat(vehicle.lon)\n            },\n            map: this.viewModel.map\n          });\n        });\n      }\n    },\n    \"{element} inserted\": function() {\n      googleAPI.then(() => {\n        this.viewModel.map = new google.maps.Map(this.element.firstChild, {\n          zoom: 10,\n          center: {\n            lat: 41.881,\n            lng: -87.623\n          }\n        });\n      });\n    }\n  }\n});\n\nvar viewModel = new BusTrackerVM();\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='40,44-49,51,only'></span>\n\n\n\n<script src=\"//static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "This guide walks you through showing Chicago Transit Authority (CTA) bus locations on a Google Map.   \n\n",
    "name": "guides/recipes/cta-bus-map",
    "title": "CTA Bus Map (Medium)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes/playlist-editor": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/playlist-editor/playlist-editor.md"
    },
    "body": "\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/meqowis/3/embed?output\">JS Bin on jsbin.com</a>\n\nTo use the widget:\n\n1. _Click_ __Sign In__ to give access to the app to create playlists on your behalf.\n2. _Type_ search terms in __Search for videos__ and hit _enter_.\n3. _Drag_ and _drop_ those videos into the playlist area (__Drag video here__).\n4. _Click_ __Create Playlist__.\n5. _Enter_ a name in the popup.\n6. _Navigate_ to your [YouTube](https://www.youtube.com/) channel to verify the playlist was created.\n\n__Start this tutorial by cloning the following JS Bin__:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/ducabam/2/embed?html,output\">JS Bin on jsbin.com</a>\n\nThis JS Bin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\nThe following sections are broken down into:\n\n- Problem — A description of what the section is trying to accomplish.\n- Things to know — Information about CanJS that is useful for solving the problem.\n- Solution — The solution to the problem.\n\nThe following video goes through this recipe:\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/0GLa33tdDTg\" frameborder=\"0\" allowfullscreen></iframe>\n\n## Setup CanJS and Load Google API\n\n### The problem\n\nIn this section, we will:\n\n1. Load Google's JS API client, `gapi`, and initialize it to make requests on behalf of\n   the registered \"CanJS Playlist\" app.\n2. Setup a basic CanJS application.\n3. Use the basic CanJS application to show when Google's JS API has finished loading.\n\n### What you need to know\n\n- The preferred way of loading Google's JS API is with an `async` script tag like:\n\n  ```html\n  <script async defer src=\"https://apis.google.com/js/api.js\"\n    onload=\"this.onload=function(){}; googleScriptLoaded();\"\n    onreadystatechange=\"if (this.readyState === 'complete') this.onload();\">\n  </script>\n  ```\n\n  The `async` attribute allows other JS to execute while the `api.js` file is loading.\n  Once complete, this will call a `googleScriptLoaded` function.\n\n- Once `api.js` is loaded, it adds the   [gapi](https://developers.google.com/api-client-library/javascript/reference/referencedocs)\n  object to the window.  This is Google's JS API.  It can be used to load other APIs that extend the `gapi` library.\n\n  The following can be used to load the OAuth2 GAPI libraries:\n\n  ```js\n  gapi.load('client:auth2', completeCallback);\n  ```\n\n  Once this functionality is loaded, we can tell `gapi` to make requests on behalf of a registered\n  application.  In this case, the following keys enable this client to make requests on behalf of the\n  \"CanJS Playlist\" application:\n\n  ```js\n  gapi.client.init({\n\t  'apiKey': 'AIzaSyAbHbOuFtJRvTX731PQXGSTy59eh5rEiE0',\n      'clientId': '764983721035-85cbj35n0kmkmrba10f4jtte8fhpst84.apps.googleusercontent.com',\n      'discoveryDocs': [ 'https://www.googleapis.com/discovery/v1/apis/youtube/v3/rest' ],\n      'scope': 'https://www.googleapis.com/auth/youtube'\n  }).then( completeCallback )\n  ```\n\n  To use your own key, you can follow the instructions [here](https://developers.google.com/youtube/v3/getting-started). This is not required to complete this guide.\n\n- Instead of callbacks, CanJS favors [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) to manage\n  asynchronous behavior. A promise can be created like:\n\n  ```js\n  var messagePromise = new Promise(function(resolve, reject){\n    setTimeout(function(){\n\t\tresolve(\"Hello There\")\n\t},1000)\n  });\n  ```\n\n  `resolve` should be called once the promise has a value.  `reject` should be called\n  if something goes wrong (like an error).  We say the `messagePromise` _resolves_ with\n  `\"Hello There\"` after one second.\n\n  Anyone can listen to when `messagePromise` resolves with a value like:\n\n  ```js\n  messagePromise.then(function(messageValue){\n\t  messageValue //-> \"Hello There\"\n  });\n  ```\n\n  CanJS can use promises in its [can-stache] templates.  More on that below.\n\n- A basic CanJS application is a live-bound template (or view) rendered with a ViewModel.\n\n- A [can-stache] template is used to render data into a document fragment:\n\n  ```js\n  var template = can.stache(\"<h1>{{message}}</h1>\");\n  var frag = template({message: \"Hello World\"});\n  frag //-> <h1>Hello World</h1>\n  ```\n\n- Load a template from a `<script>` tag with [can-stach.from can.stache.from] like:\n\n  ```js\n  var template = can.stache.from(SCRIPT_ID);\n  ```  \n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n- `Promise`s are observable in `can-stache`.  Given a promise `somePromise`, you can:\n  - Check if the promise is loading like: `{{#if somePromise.isPending}}`.\n  - Loop through the resolved value of the promise like: `{{#each somePromise.value}}`.\n\n\n- [can-define/map/map can.DefineMap] can be used to define the behavior of observable objects like:\n\n  ```js\n  var Type = can.DefineMap.extend({\n\t  message: \"string\"\n  });\n  ```\n\n- Instances of these [can-define/map/map can.DefineMap] types are often used\n  as a ViewModel that controls the behavior of a [can-stache] template (or\n  [can-component]).\n\n  ```js\n  var PlaylistVM = can.DefineMap.extend({\n\t  message: \"string\"\n  });\n\n  var messageVM = new PlaylistVM();\n  var frag = template(messageVM)\n  ```\n\n- `can.DefineMap` can specify a default value and a type:\n  ```js\n  var PlaylistVM = can.DefineMap.extend({\n    count: {value: 33}\n  });\n  new PlaylistVM().count //-> 33\n  ```\n\n\n### The solution\n\nUpdate the __HTML__ tab to:\n\n> Note: Please use your own `clientId` if you use this code outside this guide.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.7 - Playlist Editor Final\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    <div>Loaded Google API</div>\n  {{/if}}\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/jquerypp@2/dist/global/jquerypp.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n\n<script>\nvar googleScriptLoaded;\nvar googleApiLoadedPromise = new Promise(function(resolve){\n  googleScriptLoaded = function(){\n    gapi.load('client:auth2', function() {\n\t\tgapi.client.init({\n\t\t\t'apiKey': 'AIzaSyBcnGGOryOnmjUC09T78VCFEqRQRgvPnAc',\n\t\t\t'clientId': '764983721035-85cbj35n0kmkmrba10f4jtte8fhpst84.apps.googleusercontent.com',\n\t\t\t'discoveryDocs': [ 'https://www.googleapis.com/discovery/v1/apis/youtube/v3/rest' ],\n\t\t\t'scope': 'https://www.googleapis.com/auth/youtube'\n\t\t}).then(resolve);\n\t});\n  }\n})\n</script>\n\n<script async defer src=\"https://apis.google.com/js/api.js\"\n\tonload=\"this.onload=function(){}; googleScriptLoaded();\"\n\tonreadystatechange=\"if (this.readyState === 'complete') this.onload();\">\n</script>\n\n</body>\n</html>\n\n```\n\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  }\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n\n\n\n\n\n## Sign in and out\n\n### The problem\n\nIn this section, we will:\n\n1. Show a `Sign In` button that signs a person into their google account.\n2. Show a `Sign Out` button that signs a person out of their google account.\n3. Automatically know via google's API when the user signs in and out, and update the\n   page accordingly.\n4. Show a welcome message with the user's given name.\n\n### What you need to know\n\n- Once the Google API has been fully loaded, information about the\n  currently authenticated user can be found in the `googleAuth` object.  This\n  can be retrieved like:\n\n  ```js\n  googleApiLoadedPromise.then(function(){\n\t  var googleAuth = gapi.auth2.getAuthInstance()\n  });\n  ```\n\n  With `googleAuth`, you can:\n\n  - Know if someone is signed in: `googleAuth.isSignedIn.get()`\n  - Sign someone in: `googleAuth.signIn()`\n  - Sign someone out: `googleAuth.signOut()`\n  - Listen to when someone's signedIn status changes: `googleAuth.isSignedIn.listen(callback)`\n  - Get the user's name: `googleAuth.currentUser.get().getBasicProfile().getGivenName()`\n\n\n\n\n- [ES5 Getter Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) can\n  be used to define a `DefineMap` property that changes when another property changes.  For example,\n  the following defines an `signedOut` property that is the opposite of the `signedIn` property:\n\n  ```js\n  DefineMap.extend({\n    signedIn: \"boolean\",\n    get signedOut(){\n      return !this.signedIn;\n    }\n  });\n  ```\n\n- Use [can-define.types.get asynchronous getters] to get data from asynchronous sources.  For example:\n\n  ```js\n  var PlaylistVM = can.DefineMap.extend({\n    property: {\n      get: function(lastSet, resolve) {\n        apiLoadedPromise.then(function(){\n\t\t\tresolve( api.getValue() );\n\t\t})\n      }\n    }\n  });\n  ```\n\n- DefineMap's `init` method can be used to perform initialization behavior.  For example,\n  the following might initialize `googleApiLoadedPromise`:\n\n  ```js\n  DefineMap.extend({\n\t  init: function(){\n\t\t  this.googleApiLoadedPromise = googleApiLoadedPromise;\n\t  },\n\t  googleApiLoadedPromise: \"any\"\n  })\n  ```\n\n- `DefineMap`'s on [can-define/map/map.prototype.on] lets you listen on changes in a DefineMap.\n  This can be used to change values when other values change.  The following will increment\n  `nameChange` everytime the `name` property changes:\n\n  ```js\n  DefineMap.extend({\n\t  init: function(){\n\t\t  var self = this;\n\t\t  self.on(\"name\", function(){\n\t\t      self.nameChange++;\t  \n\t\t  })\n\t  },\n\t  name: \"string\",\n\t  nameChange: \"number\"\n  })\n  ```\n\n  > NOTE: EventStreams provide a much better way of doing this.  Check out [can-define-stream-kefir].\n\n- Use [can-stache-bindings.event on:EVENT] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `sayHi()` when the `<div>` is clicked.\n\n   ```html\n   <div on:click=\"sayHi()\"> … </div>\n   ```\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n\t  Welcome {{givenName}}! <button on:click=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n\t  <button on:click=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n  {{/if}}\n</script>\n\n```\n<span line-highlight='5-9,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  }\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='2-11,15-26,only'></span>\n\n\n\n## Search for videos ##\n\n### The problem\n\nIn this section, we will:\n\n1. Create a search `<input>` where a user can type a search query.\n2. When the user types more than 2 characters, get a list of video search results and display\n   them to the user.\n\n### What you need to know\n\n- Use [can-stache-bindings.twoWay value:bind] to setup a two-way binding in `can-stache`.  For example, the following keeps `searchQuery` and the input's `value` in sync:\n\n   ```html\n   <input value:bind=\"searchQuery\"/>\n   ```\n\n- Use `gapi.client.youtube.search.list` to search YouTube like:\n\n  ```js\n  var googlePromise = gapi.client.youtube.search.list({\n    q: \"dogs\",\n    part: 'snippet',\n    type: 'video'\n  }).then(function(response){\n    response //-> {\n\t// result: {\n\t//   items: [\n\t//     {\n\t//       id: {videoId: \"ajsadfa\"},\n\t//       snippet: {\n\t//         title: \"dogs\",\n\t//         thumbnails: {default: {url: \"https://example.com/dog.png\"}}\n\t//       }\n\t//     }\n\t//   ]\n\t// }\t \n\t//}\n  });\n  ```\n\n- To convert a `googlePromise` to a native `Promise` use:\n\n  ```js\n  new Promise(function(resolve, reject){\n    googlePromise.then(resolve, reject);\t  \n  })\n  ```\n\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n      Welcome {{givenName}}! <button on:click=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n      <button on:click=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n\n    <div>\n      <input value:bind=\"searchQuery\" placeholder=\"Search for videos\"/>\n    </div>\n\n    {{#if searchResultsPromise.isPending}}\n      <div class=\"loading\">Loading videos...</div>\n    {{/if}}\n\n    {{#if searchResultsPromise.isResolved}}\n      <ul class='source'>\n      {{#each searchResultsPromise.value}}\n        <li>\n          <a href=\"https://www.youtube.com/watch?v={{./id.videoId}}\" target='_blank'>\n            <img src=\"{{./snippet.thumbnails.default.url}}\" width=\"50px\"/>\n          </a>\n          {{./snippet.title}}\n        </li>\n      {{/each}}\n      </ul>\n\n    {{/if}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='11-31,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  }\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='27-46,only'></span>\n\n## Drag videos ##\n\n### The problem\n\nIn this section, we will:\n\n1. Let a user drag around a cloned representation of the searched videos.\n\n### What you need to know\n\n- The [jQuery++](https://jquerypp.com/) library (which is already included on the page), supports\n  the following `drag` events:\n\n  - `dragdown` - the mouse cursor is pressed down\n  - `draginit` - the drag motion is started\n  - `dragmove` - the drag is moved\n  - `dragend` - the drag has ended\n  - `dragover` - the drag is over a drop point\n  - `dragout` - the drag moved out of a drop point\n\n  You can bind on them manually with jQuery like:\n\n  ```js\n  $(element).on('draginit', function(ev, drag) {\n    drag.limit($(this).parent());\n    drag.horizontal();\n  });\n  ```\n\n  Notice that `drag` is the 2nd argument to the event.  You can listen to\n  `drag` events in [can-stache] and pass the `drag` argument to a function like:\n\n  ```html\n  on:draginit=\"startedDrag(%arguments[1])\"\n  ```\n\n- The `drag.ghost()` method copies the elements being dragged and drags that\n  instead. The `.ghost()` method returns the copied elements\n  wrapped with jQuery.  Add the `ghost` className to style the ghost elements, like:\n\n  ```js\n  drag.ghost().addClass(\"ghost\");\n  ```\n\n- To add a method to a `DefineMap`, just add a function to one of the properties passed\n  to extend:\n\n  ```js\n  PlaylistVM = DefineMap.extend({\n\tstartedDrag: function(){\n\t  console.log(\"you did it!\")\n\t}\n  });\n  new PlaylistVM().startedDrag();\n  ```\n- Certain browsers have default drag behaviors for certain elements like `<a>` and `<img>`\n\tthat can be prevented with the `draggable=\"false\"` attribute.\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n      Welcome {{givenName}}! <button on:click=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n      <button on:click=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n\n    <div>\n      <input value:bind=\"searchQuery\" placeholder=\"Search for videos\"/>\n    </div>\n\n    {{#if searchResultsPromise.isPending}}\n      <div class=\"loading\">Loading videos...</div>\n    {{/if}}\n\n    {{#if searchResultsPromise.isResolved}}\n      <ul class='source'>\n      {{#each searchResultsPromise.value}}\n        <li on:draginit=\"videoDrag(%arguments[1])\">\n          <a draggable=\"false\" href=\"https://www.youtube.com/watch?v={{./id.videoId}}\" target='_blank'>\n            <img draggable=\"false\" src=\"{{./snippet.thumbnails.default.url}}\" width=\"50px\"/>\n          </a>\n          {{./snippet.title}}\n        </li>\n      {{/each}}\n      </ul>\n\n    {{/if}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='22-24,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  },\n  videoDrag: function(drag) {\n    drag.ghost().addClass(\"ghost\");\n  }\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='47-49,only'></span>\n\n## Drop videos\n### The problem\n\nIn this section, we will:\n\n1. Allow a user to drop videos on a playlist element.\n2. When the user drags a video over the playlist element, a placeholder of the\n   video will appear in the first position of the playlist.\n3. If the video is dragged out of the playlist element, the placeholder will be removed.\n4. If the video is dropped on the playlist element, it will be added to the playlist's\n   list of videos.\n5. Prepare for inserting the placeholder or video in any position in the list.\n\n### What you need to know\n\n- The `PlaylistVM` should maintain a list of playlist videos (`playlistVideos`) and\n  the placeholder video (`dropPlaceholderData`) separately.  It can combine these\n  two values into a single value (`videosWithDropPlaceholder`) of the videos to display to the\n  user.  On a high-level, this might look like:\n\n  ```js\n  PlaylistVM = DefineMap.extend({\n      ...\n      // {video: video, index: 0}\n\t  dropPlaceholderData: \"any\",\n\t  // [video1, video2, ...]\n\t  playlistVideos: {\n\t     Type: [\"any\"],\n\t     Value: can.DefineList\n\t  },\n\t  get videosWithDropPlaceholder() {\n         var copyOfPlaylistVideos = this.placeListVideos.map(...);\n\n         // insert this.dropPlaceholderData into copyOfPlaylistVideos\n\n\t\t return copyOfPlaylistVideos;\n\t  }\n  })\n  ```\n\n- The methods that add a placeholder (`addDropPlaceholder`) and\n  add video to the playlist (`addVideo`) should take an index like:\n\n  ```js\n  addDropPlaceholder: function(index, video) { ... }\n  addVideo: function(index, video) { ... }\n  ```\n\n  These functions will be called with `0` as the index for this section.  \n\n- jQuery++ supports the following [drop](https://jquerypp.com/#drop) events:\n\n  - dropinit - the drag motion is started, drop positions are calculated\n  - dropover - a drag moves over a drop element, called once as the drop is dragged over the element\n  - dropout - a drag moves out of the drop element\n  - dropmove - a drag is moved over a drop element, called repeatedly as the element is moved\n  - dropon - a drag is released over a drop element\n  - dropend - the drag motion has completed\n\n  You can bind on them manually with jQuery like:\n\n  ```js\n  $(element).on('dropon', function(ev, drop, drag) {...});\n  ```\n\n  Notice that `drop` is now the 2nd argument to the event.  You can listen to\n  `drop` events in [can-stache], and pass the `drag` argument to a function, like:\n\n  ```html\n  on:dropon=\"addVideo(%arguments[2])\"\n  ```\n\n- You will need to associate the drag objects with the video being dragged so\n  you know which video is being dropped when a `drop` happens. The following\n  utilities help create that association:\n\n  - The `drag.element` is the jQuery-wrapped element that the user initiated the\n    drag motion upon.\n\n  - CanJS's `{{data DATANAME}}` helper lets you associate custom data with an element. The following\n    saves the current `context` of the `<li>` as `\"dragData\"` on the `<li>`:\n\n    ```\n    <li ($draginit)=\"videoDrag(%arguments[1])\"\n              {{data \"dragData\"}}>\n    ```\n\n  - [can-util/dom/data/data.get can.data.get] can access this data like:\n\n    ```js\n    can.data.get.call(drag.element[0], \"dragData\");\n    ```\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n      Welcome {{givenName}}! <button on:click=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n      <button on:click=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n\n    <div>\n      <input value:bind=\"searchQuery\" placeholder=\"Search for videos\"/>\n    </div>\n\n    {{#if searchResultsPromise.isPending}}\n      <div class=\"loading\">Loading videos...</div>\n    {{/if}}\n\n    {{#if searchResultsPromise.isResolved}}\n      <ul class='source'>\n      {{#each searchResultsPromise.value}}\n        <li on:draginit=\"videoDrag(%arguments[1])\"\n            {{data \"dragData\"}}>\n          <a draggable=\"false\" href=\"https://www.youtube.com/watch?v={{./id.videoId}}\" target='_blank'>\n            <img draggable=\"false\" src=\"{{./snippet.thumbnails.default.url}}\" width=\"50px\"/>\n          </a>\n          {{./snippet.title}}\n        </li>\n      {{/each}}\n      </ul>\n\n      {{#if searchResultsPromise.value.length}}\n        <div class='new-playlist'>\n          <ul\n\t\t    on:dropover=\"addDropPlaceholder(0,getDragData(%arguments[2]))\"\n\t\t\ton:dropout=\"clearDropPlaceholder()\"\n\t\t\ton:dropon=\"addVideo(0,getDragData(%arguments[2]))\">\n\n            {{#each videosWithDropPlaceholder}}\n              <li class=\"{{#if isPlaceholder}}placeholder{{/if}}\">\n                <a href=\"https://www.youtube.com/watch?v={{./video.id.videoId}}\" target='_blank'>\n                  <img src=\"{{./video.snippet.thumbnails.default.url}}\" width=\"50px\"/>\n                </a>\n\n                {{./video.snippet.title}}\n              </li>\n            {{else}}\n              <div class=\"content\">Drag video here</div>\n            {{/each}}\n          </ul>\n        </div>\n      {{/if}}\n\n    {{/if}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='22-23,32-52,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  },\n  videoDrag: function(drag) {\n    drag.ghost().addClass(\"ghost\");\n  },\n  getDragData: function(drag){\n\treturn can.data.get.call(drag.element[0], \"dragData\");\n  },\n  dropPlaceholderData: \"any\",\n  playlistVideos: {\n    Type: [\"any\"],\n    Value: can.DefineList\n  },\n  addDropPlaceholder: function(index, video) {\n    this.dropPlaceholderData = {\n      index: index,\n      video: video\n    };\n  },\n  clearDropPlaceholder: function() {\n    this.dropPlaceholderData = null;\n  },\n  addVideo: function(index, video) {\n    this.dropPlaceholderData = null;\n    if (index >= this.playlistVideos.length) {\n      this.playlistVideos.push(video);\n    } else {\n      this.playlistVideos.splice(index, 0, video);\n    }\n  },\n  get videosWithDropPlaceholder() {\n    var copy = this.playlistVideos.map(function(video) {\n      return {\n        video: video,\n        isPlaceholder: false\n      };\n    });\n    if (this.dropPlaceholderData) {\n      copy.splice(this.dropPlaceholderData.index, 0, {\n        video: this.dropPlaceholderData.video,\n        isPlaceholder: true\n      });\n    }\n    return copy;\n  }\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='50-89,only'></span>\n\n\n## Drop videos in order ##\n### The problem\n\nIn this section, we will:\n\n1. Allow a user to drop videos in order they prefer.\n\n### What you need to know\n\n- ViewModels are best left knowing very little about the DOM. This makes them more\n  easily unit-testable.  To make this interaction, we need to know where the mouse\n  is in relation to the playlist's videos.  This requires a lot of DOM interaction\n  and is best done outside the ViewModel.\n\n  Specifically, we'd like to translate the `dropmove` and `dropon` events\n  into other events that let people know where the `dropmove` and `dropon` events\n  are happening in relationship to the __drop target__'s child elements.\n\n  Our goal is to:\n\n  - Translate `dropmove` into `sortableplaceholderat` events\n    that dispatch events with the `index` where a placeholder should be inserted\n    and the `dragData` of what is being dragged.\n\n  - Translate `dropon` into `sortableinsertat` events\n    that dispatch events with the `index` where the dragged item should be inserted\n    and the `dragData` of what is being dragged.  \n\n- [can-control can.Control] is useful for listening to events on an element in a memory-safe\n  way.  Use [can-control.extend] to define a `can.Control` type, as follows:\n\n  ```js\n  var Sortable = can.Control.extend({\n\t  ... event handlers and methods ...\n  });\n  ```\n\n  To listen to events (like `dragmove`) on a control, use an event handler with `{element} EVENTNAME`,\n  as follows:\n\n  ```js\n  var Sortable = can.Control.extend({\n\t\"{element} dropmove\": function(el, ev, drop, drag) {\n      // do stuff on dropmove like call method:\n      this.method();\n    },\n\tmethod: function(){\n\t  // do something\n\t}\n  });\n  ```\n\n  Use `new Control(element)` to create a control on an element.  The following\n  would setup the `dropmove` binding on `el`:\n\n  ```js\n  new Sortable(el);\n  ```\n\n- [can-view-callbacks.attr can.view.callbacks.attr] can listen to when a custom attribute is\n  found in a [can-stache] template like:\n\n  ```js\n  can.view.callbacks.attr(\"sortable\", function(el, attrData) {});\n  ```\n\n  This can be useful to create controls on an element with that attribute.  For example, if a user has:\n\n  ```html\n  <ul sortable>...</ul>\n  ```\n\n  The following will create the `Sortable` control on that `<ul>`:\n\n  ```js\n  can.view.callbacks.attr(\"sortable\", function(el) {\n    new Sortable(el);\n  });\n  ```\n\n- Use [$.trigger](https://api.jquery.com/trigger/) to fire custom events with jQuery:\n\n  ```js\n  $(element).trigger({\n    type: \"sortableinsertat\",\n    index: 0,\n    dragData: dragData\n  });\n  ```\n\n- Access the event object in a [can-stache-bindings.event] with `%event`, like:\n\n  ```html\n  on:sortableinsertat=\"addVideo(%event.index, %event.dragData)\"\n  ```\n\n- Mouse events like `click` and `dropmove` and `dropon` have a `pageY` property that\n  tells how many pixels down the page a user's mouse is.\n- [jQuery.offset](https://api.jquery.com/offset/) returns an element's position on the page.\n- [jQuery.height](https://api.jquery.com/height/) returns an element's height.\n- If the mouse position is below an element's center, the placeholder should be inserted\n  after the element.  If the mouse position is above an element's center, it should be inserted\n  before the element.\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n      Welcome {{givenName}}! <button on:click=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n      <button on:click=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n\n    <div>\n      <input value:bind=\"searchQuery\" placeholder=\"Search for videos\"/>\n    </div>\n\n    {{#if searchResultsPromise.isPending}}\n      <div class=\"loading\">Loading videos...</div>\n    {{/if}}\n\n    {{#if searchResultsPromise.isResolved}}\n      <ul class='source'>\n      {{#each searchResultsPromise.value}}\n        <li on:draginit=\"videoDrag(%arguments[1])\"\n            {{data \"dragData\"}}>\n          <a draggable=\"false\" href=\"https://www.youtube.com/watch?v={{./id.videoId}}\" target='_blank'>\n            <img draggable=\"false\" src=\"{{./snippet.thumbnails.default.url}}\" width=\"50px\"/>\n          </a>\n          {{./snippet.title}}\n        </li>\n      {{/each}}\n      </ul>\n\n      {{#if searchResultsPromise.value.length}}\n        <div class='new-playlist'>\n          <ul sortable\n            on:sortableplaceholderat=\"addDropPlaceholder(%event.index, %event.dragData)\"\n            on:sortableinsertat=\"addVideo(%event.index, %event.dragData)\"\n            on:dropout=\"clearDropPlaceholder()\">\n\n            {{#each videosWithDropPlaceholder}}\n              <li class=\"{{#if isPlaceholder}}placeholder{{/if}}\">\n                <a href=\"https://www.youtube.com/watch?v={{./video.id.videoId}}\" target='_blank'>\n                  <img src=\"{{./video.snippet.thumbnails.default.url}}\" width=\"50px\"/>\n                </a>\n\n                {{./video.snippet.title}}\n              </li>\n            {{else}}\n              <div class=\"content\">Drag video here</div>\n            {{/each}}\n          </ul>\n        </div>\n      {{/if}}\n\n    {{/if}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='34-37,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  },\n  videoDrag: function(drag) {\n    drag.ghost().addClass(\"ghost\");\n  },\n  getDragData: function(drag){\n\treturn can.data.get.call(drag.element[0], \"dragData\");\n  },\n  dropPlaceholderData: \"any\",\n  playlistVideos: {\n    Type: [\"any\"],\n    Value: can.DefineList\n  },\n  addDropPlaceholder: function(index, video) {\n    this.dropPlaceholderData = {\n      index: index,\n      video: video\n    };\n  },\n  clearDropPlaceholder: function() {\n    this.dropPlaceholderData = null;\n  },\n  addVideo: function(index, video) {\n    this.dropPlaceholderData = null;\n    if (index >= this.playlistVideos.length) {\n      this.playlistVideos.push(video);\n    } else {\n      this.playlistVideos.splice(index, 0, video);\n    }\n  },\n  get videosWithDropPlaceholder() {\n    var copy = this.playlistVideos.map(function(video) {\n      return {\n        video: video,\n        isPlaceholder: false\n      };\n    });\n    if (this.dropPlaceholderData) {\n      copy.splice(this.dropPlaceholderData.index, 0, {\n        video: this.dropPlaceholderData.video,\n        isPlaceholder: true\n      });\n    }\n    return copy;\n  }\n});\n\nvar Sortable = can.Control.extend({\n  \"{element} dropmove\": function(el, ev, drop, drag) {\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableplaceholderat\");\n  },\n  \"{element} dropon\": function(el, ev, drop, drag) {\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableinsertat\");\n  },\n  fireEventForDropPosition: function(ev, drop, drag, eventName) {\n    var dragData = can.data.get.call(drag.element[0], \"dragData\");\n\n    var sortables = $(this.element).children();\n\n    for (var i = 0; i < sortables.length; i++) {\n      //check if cursor is past 1/2 way\n      var sortable = $(sortables[i]);\n      if (ev.pageY < Math.floor(sortable.offset().top + sortable.height() / 2)) {\n        // index at which it needs to be inserted before\n        $(this.element).trigger({\n          type: eventName,\n          index: i,\n          dragData: dragData\n        });\n        return;\n      }\n    }\n    if (!sortables.length) {\n      $(this.element).trigger({\n        type: eventName,\n        index: 0,\n        dragData: dragData\n      });\n    } else {\n      $(this.element).trigger({\n        type: eventName,\n        index: i,\n        dragData: dragData\n      });\n    }\n  }\n});\n\ncan.view.callbacks.attr(\"sortable\", function(el) {\n  new Sortable(el);\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='92-135,only'></span>\n\n\n\n## Revert videos not dropped on playlist ##\n\n### The problem\n\nIn this section, we will:\n\n1. Revert videos not dropped on the playlist. If a user drags a video, but does not drop it on the playlist, show\n  an animation returning the video to its original place.\n\n### What you need to know\n\n- If you call `drag.revert()`, the drag element will animate back to its original position.\n\n### The solution\n\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  },\n  videoDrag: function(drag) {\n    drag.ghost().addClass(\"ghost\");\n  },\n  getDragData: function(drag){\n\treturn can.data.get.call(drag.element[0], \"dragData\");\n  },\n  dropPlaceholderData: \"any\",\n  playlistVideos: {\n    Type: [\"any\"],\n    Value: can.DefineList\n  },\n  addDropPlaceholder: function(index, video) {\n    this.dropPlaceholderData = {\n      index: index,\n      video: video\n    };\n  },\n  clearDropPlaceholder: function() {\n    this.dropPlaceholderData = null;\n  },\n  addVideo: function(index, video) {\n    this.dropPlaceholderData = null;\n    if (index >= this.playlistVideos.length) {\n      this.playlistVideos.push(video);\n    } else {\n      this.playlistVideos.splice(index, 0, video);\n    }\n  },\n  get videosWithDropPlaceholder() {\n    var copy = this.playlistVideos.map(function(video) {\n      return {\n        video: video,\n        isPlaceholder: false\n      };\n    });\n    if (this.dropPlaceholderData) {\n      copy.splice(this.dropPlaceholderData.index, 0, {\n        video: this.dropPlaceholderData.video,\n        isPlaceholder: true\n      });\n    }\n    return copy;\n  }\n});\n\nvar Sortable = can.Control.extend({\n  \"{element} dropinit\": function() {\n    this.droppedOn = false;\n  },\n  \"{element} dropmove\": function(el, ev, drop, drag) {\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableplaceholderat\");\n  },\n  \"{element} dropon\": function(el, ev, drop, drag) {\n    this.droppedOn = true;\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableinsertat\");\n  },\n  \"{element} dropend\": function(el, ev, drop, drag) {\n    if (!this.droppedOn) {\n      drag.revert();\n    }\n  },\n  fireEventForDropPosition: function(ev, drop, drag, eventName) {\n    var dragData = can.data.get.call(drag.element[0], \"dragData\");\n\n    var sortables = $(this.element).children();\n\n    for (var i = 0; i < sortables.length; i++) {\n      //check if cursor is past 1/2 way\n      var sortable = $(sortables[i]);\n      if (ev.pageY < Math.floor(sortable.offset().top + sortable.height() / 2)) {\n        // index at which it needs to be inserted before\n        $(this.element).trigger({\n          type: eventName,\n          index: i,\n          dragData: dragData\n        });\n        return;\n      }\n    }\n    if (!sortables.length) {\n      $(this.element).trigger({\n        type: eventName,\n        index: 0,\n        dragData: dragData\n      });\n    } else {\n      $(this.element).trigger({\n        type: eventName,\n        index: i,\n        dragData: dragData\n      });\n    }\n  }\n});\n\ncan.view.callbacks.attr(\"sortable\", function(el) {\n  new Sortable(el);\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='93-95,100,103-107,only'></span>\n\n\n## Create a playlist ##\n### The problem\n\nIn this section, we will:\n\n1. Add a `Create Playlist` button that prompts the user for the playlist name.\n2. After the user enters the name, the playlist is saved.\n3. Disable the button while the playlist is being created.\n4. Empty the playlist after it is created.\n\n### What you need to know\n\n- Use [https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt] to prompt a user for a simple string value.\n\n- YouTube _only_ allows you to create a playlist and add items to it.\n\n  To create a playlist:\n\n  ```js\n  var lastPromise = gapi.client.youtube.playlists.insert({\n\tpart: 'snippet,status',\n\tresource: {\n\t  snippet: {\n\t\ttitle: PLAYLIST_NAME,\n\t\tdescription: 'A private playlist created with the YouTube API and CanJS'\n\t  },\n\t  status: {\n\t\tprivacyStatus: 'private'\n\t  }\n\t}\n  }).then(function(response) {\n\tresponse //->{} response.result.id\n\t// result: {\n\t//   id: \"lk2asf8o\"\n\t// }\n  });\n  ```\n\n  To insert something onto the end of it:\n\n  ```js\n  gapi.client.youtube.playlistItems.insert({\n    part: 'snippet',\n    resource: {\n      snippet: {\n        playlistId: playlistId,\n        resourceId: video.id\n      }\n    }\n  }).then();\n  ```\n\n- These requests must run in order.  You can make one request run after another, like:\n\n  ```js\n  lastPromise = makeRequest(1);\n\n  lastPromise = lastPromise.then(function(){\n    return makeRequest(2);\t  \n  })\n\n  lastPromise = lastPromise.then(function(){\n    return makeRequest(3);\t  \n  })\n  ```\n\n  When a callback to `.then` returns a promise, `.then` returns a promise that resolves\n  after the _inner_ promise has been resolved.\n\n- Use [can-stache-bindings.toChild {$disabled}] to make an input disabled, like:\n\n  ```html\n  <button disabled:from=\"createPlaylistPromise.isPending()\">...\n  ```\n\n- When the promise has finished, set the `playlistVideos` property back to an empty list. This\n  can be done by listening to `createPlaylistPromise`:\n\n  ```js\n  this.on(\"createPlaylistPromise\", function(ev, promise) { ... })\n  ```\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n      Welcome {{givenName}}! <button on:click=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n      <button on:click=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n\n    <div>\n      <input value:bind=\"searchQuery\" placeholder=\"Search for videos\"/>\n    </div>\n\n    {{#if searchResultsPromise.isPending}}\n      <div class=\"loading\">Loading videos...</div>\n    {{/if}}\n\n    {{#if searchResultsPromise.isResolved}}\n      <ul class='source'>\n      {{#each searchResultsPromise.value}}\n        <li on:draginit=\"videoDrag(%arguments[1])\"\n            {{data \"dragData\"}}>\n          <a draggable=\"false\" href=\"https://www.youtube.com/watch?v={{./id.videoId}}\" target='_blank'>\n            <img draggable=\"false\" src=\"{{./snippet.thumbnails.default.url}}\" width=\"50px\"/>\n          </a>\n          {{./snippet.title}}\n        </li>\n      {{/each}}\n      </ul>\n\n      {{#if searchResultsPromise.value.length}}\n        <div class='new-playlist'>\n          <ul sortable\n            on:sortableplaceholderat=\"addDropPlaceholder(%event.index, %event.dragData)\"\n            on:sortableinsertat=\"addVideo(%event.index, %event.dragData)\"\n            on:dropout=\"clearDropPlaceholder()\">\n\n            {{#each videosWithDropPlaceholder}}\n              <li class=\"{{#if isPlaceholder}}placeholder{{/if}}\">\n                <a href=\"https://www.youtube.com/watch?v={{./video.id.videoId}}\" target='_blank'>\n                  <img src=\"{{./video.snippet.thumbnails.default.url}}\" width=\"50px\"/>\n                </a>\n\n                {{./video.snippet.title}}\n              </li>\n            {{else}}\n              <div class=\"content\">Drag video here</div>\n            {{/each}}\n          </ul>\n          {{#if playlistVideos.length}}\n            <button on:click=\"createPlaylist()\"\n              disabled:from=\"createPlaylistPromise.isPending()\">\n                Create Playlist\n            </button>\n          {{/if}}\n        </div>\n      {{/if}}\n\n    {{/if}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='51-56,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n\n    self.on(\"createPlaylistPromise\", function(ev, promise) {\n      if (promise) {\n        promise.then(function() {\n          self.playlistVideos = [];\n          self.createPlaylistPromise = null;\n        });\n      }\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  },\n  videoDrag: function(drag) {\n    drag.ghost().addClass(\"ghost\");\n  },\n  getDragData: function(drag){\n\treturn can.data.get.call(drag.element[0], \"dragData\");\n  },\n  dropPlaceholderData: \"any\",\n  playlistVideos: {\n    Type: [\"any\"],\n    Value: can.DefineList\n  },\n  addDropPlaceholder: function(index, video) {\n    this.dropPlaceholderData = {\n      index: index,\n      video: video\n    };\n  },\n  clearDropPlaceholder: function() {\n    this.dropPlaceholderData = null;\n  },\n  addVideo: function(index, video) {\n    this.dropPlaceholderData = null;\n    if (index >= this.playlistVideos.length) {\n      this.playlistVideos.push(video);\n    } else {\n      this.playlistVideos.splice(index, 0, video);\n    }\n  },\n  get videosWithDropPlaceholder() {\n    var copy = this.playlistVideos.map(function(video) {\n      return {\n        video: video,\n        isPlaceholder: false\n      };\n    });\n    if (this.dropPlaceholderData) {\n      copy.splice(this.dropPlaceholderData.index, 0, {\n        video: this.dropPlaceholderData.video,\n        isPlaceholder: true\n      });\n    }\n    return copy;\n  },\n  createPlaylistPromise: \"any\",\n  createPlaylist: function() {\n    var playlistName = prompt(\"What would you like to name your playlist?\");\n    if (!playlistName) {\n      return;\n    }\n\n    var playlistId;\n    var lastPromise = gapi.client.youtube.playlists.insert({\n      part: 'snippet,status',\n      resource: {\n        snippet: {\n          title: playlistName,\n          description: 'A private playlist created with the YouTube API and CanJS'\n        },\n        status: {\n          privacyStatus: 'private'\n        }\n      }\n    }).then(function(response) {\n      playlistId = response.result.id;\n    });\n\n\n    var playlistVideos = this.playlistVideos.slice();\n    playlistVideos.forEach(function(video) {\n      lastPromise = lastPromise.then(function() {\n        return gapi.client.youtube.playlistItems.insert({\n          part: 'snippet',\n          resource: {\n            snippet: {\n              playlistId: playlistId,\n              resourceId: video.id\n            }\n          }\n        }).then();\n      });\n    });\n\n    this.createPlaylistPromise = new Promise(function(resolve, reject) {\n      lastPromise.then(resolve, reject);\n    });\n  }\n});\n\nvar Sortable = can.Control.extend({\n  \"{element} dropinit\": function() {\n    this.droppedOn = false;\n  },\n  \"{element} dropmove\": function(el, ev, drop, drag) {\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableplaceholderat\");\n  },\n  \"{element} dropon\": function(el, ev, drop, drag) {\n    this.droppedOn = true;\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableinsertat\");\n  },\n  \"{element} dropend\": function(el, ev, drop, drag) {\n    if (!this.droppedOn) {\n      drag.revert();\n    }\n  },\n  fireEventForDropPosition: function(ev, drop, drag, eventName) {\n    var dragData = can.data.get.call(drag.element[0], \"dragData\");\n\n    var sortables = $(this.element).children();\n\n    for (var i = 0; i < sortables.length; i++) {\n      //check if cursor is past 1/2 way\n      var sortable = $(sortables[i]);\n      if (ev.pageY < Math.floor(sortable.offset().top + sortable.height() / 2)) {\n        // index at which it needs to be inserted before\n        $(this.element).trigger({\n          type: eventName,\n          index: i,\n          dragData: dragData\n        });\n        return;\n      }\n    }\n    if (!sortables.length) {\n      $(this.element).trigger({\n        type: eventName,\n        index: 0,\n        dragData: dragData\n      });\n    } else {\n      $(this.element).trigger({\n        type: eventName,\n        index: i,\n        dragData: dragData\n      });\n    }\n  }\n});\n\ncan.view.callbacks.attr(\"sortable\", function(el) {\n  new Sortable(el);\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='12-19,99-141,only'></span>\nCongrats! _You now have your very own YouTube Playlist Editor_.\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "Learn how to use YouTube's API to search for videos and make a playlist.  This makes authenticated requests with OAuth2. It uses [jQuery++](https://jquerypp.com) for\ndrag/drop events. It shows using custom attributes and custom events.  This guide takes\nan hour to complete.\n\n",
    "name": "guides/recipes/playlist-editor",
    "title": "Playlist Editor (Advanced)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes/signup-simple": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/signup-simple/signup.md"
    },
    "body": "\nIn this guide you will learn how to:\n\n- Set up a basic CanJS application.\n- Collect form data and post it to a service\n  endpoint when the form is submitted.\n\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/cejuwah/1/embed?js,output\">JS Bin on jsbin.com</a>\n\nTo use the widget:\n\n1. __Click__ the _Sign up_ link.\n2. __Enter__ an _email_ and _password_ and __Click__ _SIGN UP_.  You will be logged in.\n3. __Click__ the _log out_ link. You will be presented with the _Sign Up_ form.\n4. __Click__ the _Log in_ link.  __Enter__ the same _email_ and _password_ you used to sign up.  __Click__ the _LOG IN_ button.  You will be logged in.\n\n__START THIS TUTORIAL BY CLONING THE FOLLOWING JS Bin__:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/namowob/2/embed?js,output\">JS Bin on jsbin.com</a>\n\nThis JS Bin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\nThe following sections are broken down into:\n\n- __The problem__ — A description of what the section is trying to accomplish.\n- __What you need to know__ — Information about CanJS that is useful for solving the problem.\n- __The solution__ — The solution to the problem.\n\n## Understanding the service API\n\nThis JSBin comes with a mock service layer provided\nby [can-fixture can.fixture].  It supplies:\n\n- `POST /api/session` for creating sessions (log in).\n- `GET /api/session` for returning if there is a session.\n- `DELETE /api/session` for deleting a session (log out).\n- `POST /api/users` for creating users.\n\nTo tell if the current client is logged in:\n\n```\n=>\nGET /api/session\n\n<=\nSTATUS: 200\n{user: {email: \"someone@email.com\"}}\n```\n\nIf someone is logged out:\n\n```\n=>\nGET /api/session\n\n<=\nSTATUS: 404\n{message: \"No session\"}\n```\n\nTo log someone in:\n\n```\n=>\nPOST /api/session\n{user: {email: \"someone@email.com\", password: \"123\"}}\n\n<=\nSTATUS: 200\n{user: {email: \"someone@email.com\"}}\n```\n\nIf someone logs in with invalid credentials:\n\n```\n=>\nPOST /api/session\n{user: {email: \"WRONG\", password: \"WRONG\"}}\n\n<=\nSTATUS: 401 unauthorized\n{ message: \"Unauthorized\"}\n```\n\nTo log someone out:\n\n```\n=>\nDELETE /api/session\n\n<=\nSTATUS: 200\n{}\n```\n\nTo create a user:\n\n```\n=>\nPOST /api/users\n\n{email: \"someone@email.com\", password: \"123\"}\n\n<=\nSTATUS: 200\n{email: \"someone@email.com\"}\n```\n\n## Setup\n\n### The problem\n\nLet’s create a `app-view` template with all the HTML content and render it with\na ViewModel called `AppViewModel`.\n\n\n### What you need to know\n\n- CanJS uses [can-stache] to render data in a template\n  and keep it live.  Templates can be authored in `<script>` tags like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-view\">\n    TEMPLATE CONTENT\n  </script>\n  ```\n\n  A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] magic tags to insert data into\n  the HTML output like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-view\">\n    {{something.name}}\n  </script>\n  ```\n\n- Load a template from a `<script>` tag with [can-stache.from can.stache.from] like:\n  ```js\n  var view = can.stache.from(SCRIPT_ID);\n  ```\n\n- Render the template with data into a documentFragment like:\n\n  ```js\n  var frag = view({\n    something: {name: \"Derek Brunson\"}\n  });\n  ```\n\n- Insert a fragment into the page with:\n\n  ```js\n  document.body.appendChild(frag);\n  ```\n\n- [can-define/map/map.extend DefineMap.extend] allows you to define a property with a default value like:\n\n  ```js\n  AppViewModel = can.DefineMap.extend(\"AppViewModel\",{\n    isLoggedIn: {value: false}\n  })\n  ```\n\n  This lets you create instances of that type, get and set those properties and listen to changes like:\n\n  ```js\n  var viewModel = new AppViewModel({});\n\n  viewModel.isLoggedIn //-> false\n\n  viewModel.on(\"isLoggedIn\", function(ev, newValue){\n    console.log(\"isLoggedIn changed to \", newValue);\n  });\n\n  viewModel.isLoggedIn = true //-> logs \"isLoggedIn changed to true\"\n  ```\n\n### The solution\n\nWrap the __HTML__ content in the body with the following script tags:\n\n\n```html\n<script type='text/stache' id='app-view'>\n  <p class=\"welcome-message\">\n    Welcome Someone.\n    <a href=\"javascript://\">log out</a>\n  </p>\n\n  <form>\n    <h2>Sign Up</h2>\n\n    <input placeholder='email'/>\n\n    <input type='password'\n         placeholder='password'/>\n\n    <button>Sign Up</button>\n\n    <aside>\n      Have an account?\n      <a href=\"javascript://\">Log in</a>\n    </aside>\n  </form>\n\n  <form>\n    <h2>Log In</h2>\n\n    <input placeholder='email'/>\n\n    <input type='password'\n       placeholder='password'/>\n\n    <button>Log In</button>\n\n    <div class='error'>error message</div>\n\n    <aside>\n      Don't have an account?\n      <a href=\"javascript://\">Sign up</a>\n    </aside>\n  </form>\n</script>\n\n```\n<span line-highlight='1,40'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar AppViewModel = can.DefineMap.extend({\n\n});\n\nvar viewModel = new AppViewModel({});\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\n\ndocument.body.appendChild(frag);\n\n```\n\n\n\n\n\n\n## Check if the user is logged in\n\n### The problem\n\nLets make a request to `GET /api/session` to know if there is a\nsession.  If there is a session, we will print out the user's email address.  If there\nis not a session, we will show the _Sign Up_ form.\n\nWe'll keep the session data within a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) on\nthe `sessionPromise` property. The following simulates a logged in user:\n\n```js\nviewModel.sessionPromise = Promise.resolve({user: {email: \"someone@email.com\"}})\n```\n\n### What you need to know\n\n- The [can-define.types.value] property definition can return the initial value of a property like:\n  ```js\n  var AppViewModel = can.DefineMap.extend({\n\tmyProperty: {\n\t  value: function(){\n\t\treturn \"This string\"\n\t  }\n\t}  \n  });\n  new AppViewModel().myProperty //-> \"This string\"\n  ```\n- [can-util/dom/ajax/ajax can.ajax] can make requests to a url like:\n  ```js\n  ajax({\n    url: \"http://query.yahooapis.com/v1/public/yql\",\n    data: {\n      format: \"json\",\n      q: 'select * from geo.places where text=\"sunnyvale, ca\"'\n    }\n  }) //-> Promise\n  ```\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in [can-stache].\n- Promises are observable in `can-stache`. For a promise `myPromise`:\n    - `myPromise.value` is the resolved value of the promise\n\t- `myPromise.isPending` is true if the promise has not resolved\n\t- `myPromise.isResolved` is true if the promise has resolved\n\t- `myPromise.isRejected` is true if the promise was rejected\n\t- `myPromise.reason` is the rejected value of the promise\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n  {{#if sessionPromise.value}}\n\n    <p class=\"welcome-message\">\n      Welcome {{sessionPromise.value.user.email}}.\n      <a href=\"javascript://\">log out</a>\n    </p>\n\n  {{else}}\n\n    <form>\n      <h2>Sign Up</h2>\n\n      <input placeholder='email'/>\n\n      <input type='password'\n           placeholder='password'/>\n\n      <button>Sign Up</button>\n\n      <aside>\n        Have an account?\n        <a href=\"javascript://\">Log in</a>\n      </aside>\n    </form>\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='2,5,9,27,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar AppViewModel = can.DefineMap.extend({\n  sessionPromise: {\n    value: function(){\n      return can.ajax({\n        url: \"/api/session\"\n\t  });\n    }\n  }\n});\n\nvar viewModel = new AppViewModel({});\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\n\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='2-8,only'></span>\n\n\n\n## Signup form\n\n### The problem\n\nLets allow the user to enter an _email_ and _password_ and click _Sign Up_.  When this happens\nwe'll `POST` this data to `/api/users`.  Once the user is created, we'll want to update the `sessionPromise`\nproperty to have a promise with a _session-like_ object.\n\nA promise with a _session-like_ object looks like:\n\n```js\n{user: {email: \"someone@email.com\"}}\n```\n\n### What you need to know\n\n- [can-define/map/map.extend DefineMap.extend] allows you to define a property by defining its type like so:\n\n  ```js\n  AppViewModel = can.DefineMap.extend(\"AppViewModel\",{\n    name: \"string\",\n    password: \"number\"\n  });\n  ```\n\n- The [can-stache-bindings.toParent] can set an input’s `value` to\n  a ViewModel property like:\n  ```html\n  <input value:to=\"name\"/>\n  ```\n\n- Use [can-stache-bindings.event ($EVENT)] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked:\n\n   ```html\n   <div on:click=\"doSomething(%event)\"> ... </div>\n   ```\n\n   Notice that it also passed the event object with `%event`.\n\n- To prevent a form from submitting, call `event.preventDefault()`.\n\n- Use `.then` on a promise to map the source promise to another promise value.\n\n  ```js\n  var source = Promise.resolve({email: \"justin@bitovi.com\"})\n\n  var result = source.then(function(userData){\n\treturn {user: userData}\n  });\n  ```\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n  {{#if sessionPromise.value}}\n\n    <p class=\"welcome-message\">\n      Welcome {{sessionPromise.value.user.email}}.\n      <a href=\"javascript://\">log out</a>\n    </p>\n\n  {{else}}\n\n    <form on:submit=\"signUp(%event)\">\n      <h2>Sign Up</h2>\n\n      <input placeholder='email' value:to=\"email\"/>\n\n      <input type='password'\n           placeholder='password' value:to=\"password\"/>\n\n      <button>Sign Up</button>\n\n      <aside>\n        Have an account?\n        <a href=\"javascript://\">Log in</a>\n      </aside>\n    </form>\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='11,14,17,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar AppViewModel = can.DefineMap.extend({\n  sessionPromise: {\n    value: function(){\n      return can.ajax({\n        url: \"/api/session\"\n\t  });\n    }\n  },\n\n  email: \"string\",\n  password: \"string\",\n  signUp: function(event){\n    event.preventDefault();\n    this.sessionPromise = can.ajax({\n      url: \"/api/users\",\n      type: \"post\",\n      data: {\n        email: this.email,\n        password: this.password\n      }\n    }).then(function(user){\n      return {user: user};\n    });\n  }\n});\n\nvar viewModel = new AppViewModel({});\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\n\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='10-24,only'></span>\n\n\n\n## Log out button\n\n### The problem\n\nLets update the app to log the user out when the _log out_ button is clicked.  We can\ndo this by making a `DELETE` request to `/api/session` and updating the `sessionPromise`\nproperty to have a rejected value.\n\n### What you need to know\n\n- Use `.then` and `Promise.reject` to map a source promise to a rejected promise.\n\n  ```js\n  var source = Promise.resolve({})\n\n  var result = source.then(function(userData){\n\treturn Promise.reject({message: \"Unauthorized\"});\n  });\n\n  result.catch(function(reason){\n\t  reason.message //-> \"Unauthorized\";\n  });\n  ```\n\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n  {{#if sessionPromise.value}}\n\n    <p class=\"welcome-message\">\n      Welcome {{sessionPromise.value.user.email}}.\n      <a href=\"javascript://\" on:click=\"logOut()\">log out</a>\n    </p>\n\n  {{else}}\n\n    <form on:submit=\"signUp(%event)\">\n      <h2>Sign Up</h2>\n\n      <input placeholder='email' value:to=\"email\"/>\n\n      <input type='password'\n           placeholder='password' value:to=\"password\"/>\n\n      <button>Sign Up</button>\n\n      <aside>\n        Have an account?\n        <a href=\"javascript://\">Log in</a>\n      </aside>\n    </form>\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='6,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar AppViewModel = can.DefineMap.extend({\n  sessionPromise: {\n    value: function(){\n      return can.ajax({\n        url: \"/api/session\"\n\t  });\n    }\n  },\n\n  email: \"string\",\n  password: \"string\",\n  signUp: function(event){\n    event.preventDefault();\n    this.sessionPromise = can.ajax({\n      url: \"/api/users\",\n      type: \"post\",\n      data: {\n        email: this.email,\n        password: this.password\n      }\n    }).then(function(user){\n      return {user: user};\n    });\n  },\n\n  logOut: function(){\n    this.sessionPromise = can.ajax({\n      url: \"/api/session\",\n      type: \"delete\"\n    }).then(function(){\n      return Promise.reject({message: \"Unauthorized\"});\n    });\n  }\n});\n\nvar viewModel = new AppViewModel({});\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\n\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='26-33,only'></span>\n\n\n## Login form\n\n### The problem\n\nLets allow the user to go back and forth between the _Sign Up_ page and the _Log In_\npage. We'll do this by changing a `page` property to `\"signup\"` or `\"login\"`.\n\nWe'll also implement the _Log In_ form's functionality.  When a session is created,\nwe'll want to `POST` session data to `/api/session` and update `sessionPromise` accordingly.\n\n### What you need to know\n\n- Use [can-stache.helpers.is {{#eq value1 value2}}] to test equality in `can-stache`.\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n  {{#if sessionPromise.value}}\n\n    <p class=\"welcome-message\">\n      Welcome {{sessionPromise.value.user.email}}.\n      <a href=\"javascript://\" on:click=\"logOut()\">log out</a>\n    </p>\n\n  {{else}}\n    {{#eq page \"signup\"}}\n\n      <form on:submit=\"signUp(%event)\">\n        <h2>Sign Up</h2>\n\n        <input placeholder='email' value:to=\"email\"/>\n\n        <input type='password'\n             placeholder='password' value:to=\"password\"/>\n\n        <button>Sign Up</button>\n\n        <aside>\n          Have an account?\n          <a href=\"javascript://\" on:click=\"gotoLogIn()\">Log in</a>\n        </aside>\n      </form>\n\n    {{else}}\n\n      <form on:submit=\"logIn(%event)\">\n        <h2>Log In</h2>\n\n        <input placeholder='email' value:to=\"email\"/>\n\n        <input type='password'\n           placeholder='password' value:to=\"password\"/>\n\n        <button>Log In</button>\n\n        <aside>\n          Don't have an account?\n          <a href=\"javascript://\" on:click=\"gotoSignUp()\">Sign up</a>\n        </aside>\n      </form>\n\n    {{/eq}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='10,24,28-46,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar AppViewModel = can.DefineMap.extend({\n  sessionPromise: {\n    value: function(){\n      return can.ajax({\n        url: \"/api/session\"\n\t  });\n    }\n  },\n\n  email: \"string\",\n  password: \"string\",\n  signUp: function(event){\n    event.preventDefault();\n    this.sessionPromise = can.ajax({\n      url: \"/api/users\",\n      type: \"post\",\n      data: {\n        email: this.email,\n        password: this.password\n      }\n    }).then(function(user){\n      return {user: user};\n    });\n  },\n\n  logOut: function(){\n    this.sessionPromise = can.ajax({\n      url: \"/api/session\",\n      type: \"delete\"\n    }).then(function(){\n      return Promise.reject({message: \"Unauthorized\"});\n    });\n  },\n\n  page: {value: \"login\"},\n  gotoSignUp: function(){\n    this.page = \"signup\";\n  },\n  gotoLogIn: function(){\n    this.page = \"login\";\n  },\n  logIn: function(event){\n    event.preventDefault();\n    this.sessionPromise = can.ajax({\n      url: \"/api/session\",\n      type: \"post\",\n      data: {\n        user: {\n          email: this.email,\n          password: this.password\n        }\n      }\n    });\n  }\n});\n\nvar viewModel = new AppViewModel({});\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\n\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='35-54,only'></span>\n\n\n## Login errors\n\n### The problem\n\nIf the user tried to login, but the server responded with an error message, let's\ndisplay that error message.  We'll do this by `catch`ing the create-session request. If\nthe request failed we will set a `logInError` property with the server's response data.\n\n### What you need to know\n\n- Use `.catch` to handle when a promise is rejected:\n  ```js\n  var source = Promise.reject({responseText: '{\"message\": \"foo\"}'})\n  source.catch(function(reason){\n\t  reason.responseText //->  '{\"message\": \"foo\"}'\n  })\n  ```\n- Use `JSON.parse` to convert text to JavaScript objects:\n  ```js\n  JSON.parse('{\"message\": \"foo\"}') //-> {message: \"foo\"}\n  ```\n- Use the `\"any\"` type to define a property of indeterminate type:\n  ```\n  var AppViewModel = can.DefineMap.extend({\n\tmyProperty: \"any\"  \n  });\n  var viewModel = new AppViewModel({});\n  viewModel.myProperty = ANYTHING;\n  ```\n\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n\n```html\n<script type='text/stache' id='app-view'>\n  {{#if sessionPromise.value}}\n\n    <p class=\"welcome-message\">\n      Welcome {{sessionPromise.value.user.email}}.\n      <a href=\"javascript://\" on:click=\"logOut()\">log out</a>\n    </p>\n\n  {{else}}\n    {{#eq page \"signup\"}}\n\n      <form on:submit=\"signUp(%event)\">\n        <h2>Sign Up</h2>\n\n        <input placeholder='email' value:to=\"email\"/>\n\n        <input type='password'\n             placeholder='password' value:to=\"password\"/>\n\n        <button>Sign Up</button>\n\n        <aside>\n          Have an account?\n          <a href=\"javascript://\" on:click=\"gotoLogIn()\">Log in</a>\n        </aside>\n      </form>\n\n    {{else}}\n\n      <form on:submit=\"logIn(%event)\">\n        <h2>Log In</h2>\n\n        <input placeholder='email' value:to=\"email\"/>\n\n        <input type='password'\n           placeholder='password' value:to=\"password\"/>\n\n        <button>Log In</button>\n\n\t\t{{#if logInError}}\n          <div class='error'>{{logInError.message}}</div>\n        {{/if}}\n\n        <aside>\n          Don't have an account?\n          <a href=\"javascript://\" on:click=\"gotoSignUp()\">Sign up</a>\n        </aside>\n      </form>\n\n    {{/eq}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='40-42,only'></span>\nUpdate the __JavaScript__ tab to:\n\n\n```js\nvar AppViewModel = can.DefineMap.extend({\n  sessionPromise: {\n    value: function(){\n      return can.ajax({\n        url: \"/api/session\"\n\t  });\n    }\n  },\n\n  email: \"string\",\n  password: \"string\",\n  signUp: function(event){\n    event.preventDefault();\n    this.sessionPromise = can.ajax({\n      url: \"/api/users\",\n      type: \"post\",\n      data: {\n        email: this.email,\n        password: this.password\n      }\n    }).then(function(user){\n      return {user: user};\n    });\n  },\n\n  logOut: function(){\n    this.sessionPromise = can.ajax({\n      url: \"/api/session\",\n      type: \"delete\"\n    }).then(function(){\n      return Promise.reject({message: \"Unauthorized\"});\n    });\n  },\n\n  page: {value: \"login\"},\n  gotoSignUp: function(){\n    this.page = \"signup\";\n  },\n  gotoLogIn: function(){\n    this.page = \"login\";\n  },\n  logIn: function(event){\n    event.preventDefault();\n    this.sessionPromise = can.ajax({\n      url: \"/api/session\",\n      type: \"post\",\n      data: {\n        user: {\n          email: this.email,\n          password: this.password\n        }\n      }\n    });\n\n\tthis.logInError = null;\n    this.sessionPromise.catch(function(xhr){\n      this.logInError = JSON.parse(xhr.responseText);\n    }.bind(this));\n  },\n  logInError: \"any\"\n});\n\nvar viewModel = new AppViewModel({});\n\nvar view = can.stache.from(\"app-view\");\nvar frag = view(viewModel);\n\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='55-60,only'></span>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "This guide walks through building simple signup, login forms and a logout button.   \n\n",
    "name": "guides/recipes/signup-simple",
    "title": "Signup and Login (Simple)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes/todomvc-with-steal": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/todomvc-with-steal/todomvc-with-steal.md"
    },
    "body": "\n## Setup (Framework Overview)\n\n### The problem\n\n- Setup steal to load a basic CanJS application.  A basic CanJS application has:\n  - A [can-define/map/map] ViewModel and an instance of that ViewModel.\n  - A [can-stache] view that is rendered with the instance of the ViewModel.\n- In addition, this application should load the [can-todomvc-test](https://www.npmjs.com/package/can-todomvc-test) module version 1.0 and\n  pass it the application’s `ViewModel` instance. You will need to declare the version explicitly as different versions of this guide depend on different versions of this package.\n\n### What you need to know\n\n- To create a new project with StealJS, run:\n\n  ```\n  npm init\n  npm install steal steal-tools steal-css --save-dev\n  ```\n\n- To host static files, install `http-server` and run it like:\n\n  ```\n  npm install http-server -g\n  http-server -c-1\n  ```\n\n- If you load StealJS plugins, add them to your _package.json_ configuration like:\n\n  ```\n  \"steal\": {\n    \"plugins\": [\n      \"steal-css\"\n    ]\n  }\n  ```\n\n- Define a ViewModel type with [can-define/map/map]:\n\n  ```js\n  var DefineMap = require(\"can-define/map/\");\n  var Type = DefineMap.extend({ ... });\n  ```\n\n- Create an instance of a ViewModel by using `new Type(props)`:\n\n  ```js\n  var instance = new Type({ ... });\n  ```\n\n- Load a view with the [steal-stache] plugin like:\n\n  ```js\n  var view = require(\"./path/to/template.stache\");\n  ```\n\n  Note that [steal-stache] is a StealJS plugin and needs to be configured as such.\n\n- Render a view (or `template`) by passing it data.  It returns a document fragment that can  \n  be inserted into the page like:\n\n  ```js\n  var frag = view(appVM);\n  document.body.appendChild(frag);\n  ```\n\n- Use the following HTML that a designer might have provided:\n\n  ```html\n  <section id=\"todoapp\">\n      <header id=\"header\">\n          <h1>Todos</h1>\n          <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n      </header>\n      <section id=\"main\" class=\"\">\n          <input id=\"toggle-all\" type=\"checkbox\">\n          <label for=\"toggle-all\">Mark all as complete</label>\n          <ul id=\"todo-list\">\n              <li class=\"todo\">\n                  <div class=\"view\">\n                      <input class=\"toggle\" type=\"checkbox\">\n                      <label>Do the dishes</label>\n                      <button class=\"destroy\"></button>\n                  </div>\n                  <input class=\"edit\" type=\"text\" value=\"Do the dishes\">\n              </li>\n              <li class=\"todo completed\">\n                  <div class=\"view\">\n                      <input class=\"toggle\" type=\"checkbox\">\n                      <label>Mow the lawn</label>\n                      <button class=\"destroy\"></button>\n                  </div>\n                  <input class=\"edit\" type=\"text\" value=\"Mow the lawn\">\n              </li>\n              <li class=\"todo editing\">\n                  <div class=\"view\">\n                      <input class=\"toggle\" type=\"checkbox\">\n                      <label>Pick up dry cleaning</label>\n                      <button class=\"destroy\"></button>\n                  </div>\n                  <input class=\"edit\" type=\"text\" value=\"Pick up dry cleaning\">\n              </li>\n          </ul>\n      </section>\n      <footer id=\"footer\" class=\"\">\n          <span id=\"todo-count\">\n              <strong>2</strong> items left\n          </span>\n          <ul id=\"filters\">\n              <li>\n                  <a class=\"selected\" href=\"#!\">All</a>\n              </li>\n              <li>\n                  <a href=\"#!active\">Active</a>\n              </li>\n              <li>\n                  <a href=\"#!completed\">Completed</a>\n              </li>\n          </ul>\n          <button id=\"clear-completed\">\n              Clear completed (1)\n          </button>\n      </footer>\n  </section>\n  ```\n\n- Use [can-todomvc-test](https://www.npmjs.com/package/can-todomvc-test) to load the application’s\n  styles and run its tests:\n\n  ```js\n  require(\"can-todomvc-test\")(appVM);\n  ```\n\n\n\n### The solution\n\nCreate a folder:\n\n```cmd\nmkdir todomvc\ncd todomvc\n```\n\nHost it:\n\n```\nnpm install http-server -g\nhttp-server -c-1\n```\n\n\nCreate a new project:\n\n```cmd\nnpm init -y\n```\n\nInstall `steal`, `steal-tools`, and CanJS’s core modules:\n\n```cmd\nnpm install steal steal-tools steal-css --save-dev\nnpm install can-define can-stache steal-stache --save\n```\n\n\n\nAdd __steal.plugins__ to _package.json_:\n\n\n```json\n{\n  \"name\": \"todomvc\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"steal\": \"^1.3.0\",\n    \"steal-css\": \"^1.2.1\",\n    \"steal-tools\": \"^1.2.0\"\n  },\n  \"dependencies\": {\n    \"can-define\": \"^1.0.16\",\n    \"can-stache\": \"^3.0.20\",\n    \"steal-stache\": \"^3.0.5\"\n  },\n  \"steal\": {\n    \"plugins\": [\n      \"steal-stache\", \"steal-css\"\n    ]\n  }\n}\n\n```\n<span line-highlight='21-25'></span>\n\nCreate the starting HTML page:\n\n```html\n<!-- index.html -->\n<script src=\"./node_modules/steal/steal.js\"></script>\n```\n\nCreate the application template:\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>{{appName}}</h1>\n\t\t<input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n\t\t\t<li class=\"todo\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Do the dishes</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Do the dishes\">\n\t\t\t</li>\n\t\t\t<li class=\"todo completed\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Mow the lawn</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Mow the lawn\">\n\t\t\t</li>\n\t\t\t<li class=\"todo editing\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Pick up dry cleaning</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Pick up dry cleaning\">\n\t\t\t</li>\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>2</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed (1)\n\t\t</button>\n\t</footer>\n</section>\n\n```\n\nInstall the test harness:\n\n```cmd\nnpm install can-todomvc-test@1.0 --save-dev\n```\n\nCreate the main app\n\n\n```js\n// index.js\nvar view = require(\"./index.stache\");\nvar DefineMap = require(\"can-define/map/\");\n\nvar AppViewModel = DefineMap.extend(\"AppViewModel\",{\n\tappName: \"string\"\n});\n\nvar appVM = window.appVM = new AppViewModel({\n\tappName: \"TodoMVC\"\n});\n\nvar frag = view(appVM);\ndocument.body.appendChild(frag);\n\nrequire(\"can-todomvc-test\")(appVM);\n\n```\n\n## Define Todo type (DefineMap basics)\n\n### The problem\n\n- Define a `Todo` type as the export of  _models/todo.js_, where:\n  - It is a [can-define/map/map] type.\n  - The id or name property values are coerced into a string.\n  - Its `complete` property is a `Boolean` that defaults to `false`.\n  - It has a `toggleComplete` method that flips `complete` to the opposite value.\n\nExample test code:\n\n```js\nvar todo = new Todo({id: 1, name: 2});\nQUnit.equal(todo.id, \"1\", \"id is a string\");\nQUnit.equal(todo.name, \"2\", \"name is a string\");\nQUnit.equal(todo.complete, false, \"complete defaults to false\");\ntodo.toggleComplete();\nQUnit.equal(todo.complete, true, \"toggleComplete works\");\n```\n\n### What you need to know\n\n- [DefineMap Basics Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeUmlrN2p0Yi1qUzg)\n- [can-define/map/map.extend DefineMap.extend] defines a new `Type`.\n- The [can-define.types.type type] behavior defines a property’s type like:\n\n  ```js\n  DefineMap.extend({\n      propertyName: {type: \"number\"}\n  })\n  ```\n\n- The [can-define.types.value] behavior defines a property’s initial value like:\n\n  ```js\n  DefineMap.extend({\n      propertyName: {value: 3}\n  })\n  ```\n\n- Methods can be defined directly on the prototype like:\n\n  ```js\n  DefineMap.extend({\n      methodName: function(){}\n  })\n  ```\n\n### The solution\n\nCreate _models/todo.js_ as follows:\n\n\n```js\n// models/todo.js\nvar DefineMap = require(\"can-define/map/\");\n\nvar Todo = DefineMap.extend(\"Todo\", {\n\tid: \"string\",\n\tname: \"string\",\n\tcomplete: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\ttoggleComplete: function() {\n\t\tthis.complete = !this.complete;\n\t}\n});\n\nmodule.exports = Todo;\n\n```\n\n## Define Todo.List type (DefineList basics)\n\n### The problem\n\n- Define a `Todo.List` type on the export of  _models/todo.js_, where:\n  - It is a [can-define/list/list] type.\n  - The enumerable indexes are coerced into `Todo` types.\n  - Its `.active` property returns a filtered `Todo.List` of the todos that are __not__ complete.\n  - Its `.complete` property returns a filtered `Todo.List` of the todos that are complete.\n  - Its `.allComplete` property true if all the todos are complete.\n\nExample test code:\n\n```js\nQUnit.ok(Todo.List, \"Defined a List\");\nvar todos = new Todo.List([{complete: true},{},{complete: true}]);\nQUnit.ok(todos[0] instanceof Todo, \"each item in a Todo.List is a Todo\");\nQUnit.equal(todos.active.length, 1);\nQUnit.equal(todos.complete.length, 2);\nQUnit.equal(todos.allComplete, false, \"not allComplete\");\ntodos[1].complete = true;\nQUnit.equal(todos.allComplete, true, \"allComplete\");\n```\n\n### What you need to know\n\n- [DefineList Basics Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeRFUzclNhTlRjMDg)\n- [can-define/list/list.extend DefineList.extend] defines a new `ListType`.\n- The [can-define/list/list.prototype.wildcardItems] property defines the behavior of items in a list like:\n\n  ```js\n  DefineList.extend({\n      #: {type: ItemType}\n  })\n  ```\n\n- The [can-define.types.get] behavior defines observable computed properties like:\n\n  ```js\n  DefineMap.extend({\n      propertyName: {\n          get: function(){\n              return this.otherProperty;\n          }\n      }\n  })\n  ```\n\n- [can-define/list/list.prototype.filter] can be used to filter a list into a new list:\n\n  ```js\n  list = new ListType([...]);\n  list.filter(function(item){\n      return test(item);\n  })\n  ```\n\n### The solution\n\nUpdate _models/todo.js_ to the following:\n\n\n```js\n// models/todo.js\nvar DefineMap = require(\"can-define/map/\");\nvar DefineList = require(\"can-define/list/\");\n\nvar Todo = DefineMap.extend(\"Todo\", {\n\tid: \"string\",\n\tname: \"string\",\n\tcomplete: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\ttoggleComplete: function() {\n\t\tthis.complete = !this.complete;\n\t}\n});\n\nTodo.List = DefineList.extend(\"TodoList\", {\n\t\"#\": Todo,\n\tget active() {\n\t\treturn this.filter({\n\t\t\tcomplete: false\n\t\t});\n\t},\n\tget complete() {\n\t\treturn this.filter({\n\t\t\tcomplete: true\n\t\t});\n\t},\n\tget allComplete() {\n\t\treturn this.length === this.complete.length;\n\t}\n});\n\nmodule.exports = Todo;\n\n```\n<span line-highlight='3,17-32,only'></span>\n## Render a list of todos (can-stache)\n\n### The problem\n\n- Add a `todosList` property to the `AppViewModel` whose default\n  value will be a `Todo.List` with the following data:\n\n  ```js\n  [\n    { name: \"mow lawn\", complete: false, id: 5 },\n    { name: \"dishes\", complete: true, id: 6 },\n    { name: \"learn canjs\", complete: false, id: 7 }\n  ]\n  ```\n\n- Write out an `<li>` for each todo in `todosList`, including:\n  - write the todo’s name in the  `<label>`\n  - add `completed` in the `<li>`’s `class` if the todo is `complete`.\n  - check the todo’s checkbox if the todo is `complete`.\n\n- Write out the number of items left and completed count in the “Clear completed” button.\n\n### What you need to know\n\n- [Stache Basics Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeSjVJMTRJdXRXcWs)\n- CanJS uses [can-stache] to render data in a template\n  and keep it live. Templates can be loaded with [steal-stache].\n\n  A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] magic tags to insert data into\n  the HTML output like:\n\n  ```html\n    {{something.name}}\n  ```\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n- Use [can-stache.helpers.each {{#each value}}] to do looping in `can-stache`.\n\n### The solution\n\nUpdate _index.js_ to the following:\n\n\n```js\n// index.js\nvar view = require(\"./index.stache\");\nvar DefineMap = require(\"can-define/map/\");\nvar Todo = require(\"~/models/todo\");\n\nvar AppViewModel = DefineMap.extend(\"AppViewModel\",{\n\tappName: \"string\",\n    todosList: {\n\t\tvalue: function(){\n\t\t\treturn new Todo.List([\n\t\t\t\t{ name: \"mow lawn\", complete: false, id: 5 },\n\t\t\t\t{ name: \"dishes\", complete: true, id: 6 },\n\t\t\t\t{ name: \"learn canjs\", complete: false, id: 7 }\n\t\t\t]);\n\t\t}\n\t}\n});\n\nvar appVM = window.appVM = new AppViewModel({\n\tappName: \"TodoMVC\"\n});\n\nvar frag = view(appVM);\ndocument.body.appendChild(frag);\n\nrequire(\"can-todomvc-test\")(appVM);\n\n```\n<span line-highlight='4,8-16,only'></span>\nUpdate _index.stache_ to the following:\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        {{#if complete}}checked{{/if}}/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='11-21,26,40,only'></span>\n## Toggle a todo’s completed state (event bindings) ##\n\n### The problem\n\n- Call `toggleComplete` when a todo’s checkbox is clicked upon.\n\n### What you need to know\n\n- [The can-stache-bindings Presentation’s](https://drive.google.com/open?id=0Bx-kNqf-wxZeYUJ3ZVRxUlU2MjQ) _DOM Event Bindings_\n- Use [can-stache-bindings.event on:EVENT] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked.\n\n   ```html\n   <div on:click=\"doSomething()\"> ... </div>\n   ```\n\n### The solution\n\nUpdate _index.stache_ to the following:\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        {{#if complete}}checked{{/if}}\n                        on:click=\"toggleComplete()\"/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='14-16,only'></span>\n## Toggle a todo’s completed state (data bindings) ##\n\n### The problem\n\n- Update a todo’s `complete` property when the checkbox’s `checked` property changes with [can-stache-bindings.twoWay two-way bindings].\n\n### What you need to know\n\n- [The can-stache-bindings Presentation’s](https://drive.google.com/open?id=0Bx-kNqf-wxZeYUJ3ZVRxUlU2MjQ) _DOM Data Bindings_\n- Use [can-stache-bindings.twoWay value:bind] to setup a two-way binding in `can-stache`.  For example, the following keeps `name` and the input’s `value` in sync:\n\n   ```html\n   <input  value:bind=\"name\"/>\n   ```\n\n### The solution\n\nUpdate _index.stache_ to the following:\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        checked:bind=\"complete\"/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='14-15,only'></span>\n## Define Todo.algebra (can-set)\n\n### The problem\n\n- Create a `set.Algebra` that understand the parameters of the `/api/todos` service layer.  The `/api/todos` service\n  layer will support the following parameters:\n  - `complete` - Specifies a filter on todos' `complete` field.  Examples: `complete=true`, `complete=false`.\n  - `sort` - Specifies the sorted order the todos should be returned.  Examples: `sort=name`.\n  - `id` - Specifies the `id` property to use in `/api/todos/{id}`\n\n  Example:\n\n  ```\n  GET /api/todos?complete=true&sort=name\n  ```\n\nExample test code:\n\n```js\nQUnit.deepEqual( Todo.algebra.difference({}, {complete: true}), {complete: false} );\nQUnit.deepEqual( Todo.algebra.clauses.id, {id: \"id\"} );\n\nvar sorted = Todo.algebra.getSubset({sort: \"name\"}, {}, [\n    { name: \"mow lawn\", complete: false, id: 5 },\n    { name: \"dishes\", complete: true, id: 6 },\n    { name: \"learn canjs\", complete: false, id: 7 }\n]);\nQUnit.deepEqual(sorted, [\n    { name: \"dishes\", complete: true, id: 6 },\n    { name: \"learn canjs\", complete: false, id: 7 },\n    { name: \"mow lawn\", complete: false, id: 5 }\n]);\n```\n\n### What you need to know\n\n- [The can-set Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeV2lVNl9XanhHZ0k)\n- [can-set] provides a way to describe the parameters used in the service layer.  You use it to create\n  a [can-set.Algebra] like:\n\n  ```js\n  var todoAlgebra = new set.Algebra(\n    set.props.boolean(\"completed\"),\n    set.props.id(\"_id\"),\n    set.props.offsetLimit(\"offset\",\"limit\")\n  );\n  ```\n\n  The algebra can then be used to perform comparisons between parameters like:\n\n  ```js\n  todoAlgebra.difference({}, {completed: true}) //-> {completed: false}\n  ```\n\n- Use [can-set.props set.props] to describe the behavior of your set parameters.\n\n### The solution\n\n```\nnpm install can-set --save\n```\n\nUpdate _models/todo.js_ to the following:\n\n\n```js\n// models/todo.js\nvar DefineMap = require(\"can-define/map/\");\nvar DefineList = require(\"can-define/list/\");\nvar set = require(\"can-set\");\n\nvar Todo = DefineMap.extend(\"Todo\", {\n\tid: \"string\",\n\tname: \"string\",\n\tcomplete: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\ttoggleComplete: function() {\n\t\tthis.complete = !this.complete;\n\t}\n});\n\nTodo.List = DefineList.extend(\"TodoList\", {\n\t\"#\": Todo,\n\tget active() {\n\t\treturn this.filter({\n\t\t\tcomplete: false\n\t\t});\n\t},\n\tget complete() {\n\t\treturn this.filter({\n\t\t\tcomplete: true\n\t\t});\n\t},\n\tget allComplete() {\n\t\treturn this.length === this.complete.length;\n\t}\n});\n\nTodo.algebra = new set.Algebra(\n\tset.props.boolean(\"complete\"),\n\tset.props.id(\"id\"),\n\tset.props.sort(\"sort\")\n);\n\nmodule.exports = Todo;\n\n```\n<span line-highlight='4,35-39,only'></span>\n## Simulate the service layer (can-fixture) ##\n\n### The problem\n\nSimulate a service layer that handles the following requests and responses:\n\n__GET /api/todos__\n\n```\n-> GET /api/todos\n\n<- {\n    \"data\": [\n      { \"name\": \"mow lawn\", \"complete\": false, \"id\": 5 },\n      { \"name\": \"dishes\", \"complete\": true, \"id\": 6 },\n      { \"name\": \"learn canjs\", \"complete\": false, \"id\": 7 }\n    ]\n}\n```\n\nThis should also support a `sort` and `complete` params like:\n\n```\n-> GET /api/todos?sort=name&complete=true\n```\n\n\n__GET /api/todos/{id}__\n\n```\n-> GET /api/todos/5\n\n<- { \"name\": \"mow lawn\", \"complete\": false, \"id\": 5 }\n```\n\n__POST /api/todos__\n\n```\n-> POST /api/todos\n   {\"name\": \"learn can-fixture\", \"complete\": false}\n\n<- {\"id\": 8}\n```\n\n__PUT /api/todos/{id}__\n\n```\n-> PUT /api/todos/8\n   {\"name\": \"learn can-fixture\", \"complete\": true}\n\n<- {\"id\": 8, \"name\": \"learn can-fixture\", \"complete\": true}\n```\n\n__DELETE /api/todos/{id}__\n\n```\n-> DELETE /api/todos/8\n\n<- {}\n```\n\n### What you need to know\n\n- [The can-fixture Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeekROYmxvTnUtWmM)\n- [can-fixture] - is used to trap AJAX requests like:\n\n  ```js\n  fixture(\"/api/entities\", function(request){\n    request.data.folderId //-> \"1\"\n\n    return {data: [...]}\n  })\n  ```\n\n- [can-fixture.store can-fixture.store] - can be used to automatically filter records if given a [can-set.Algebra].\n\n  ```js\n  var entities = [ .... ];\n  var entitiesStore = fixture.store( entities, entitiesAlgebra );\n  fixture(\"/api/entities/{id}\", entitiesStore);\n\n### The solution\n\n```\nnpm install can-fixture --save\n```\n\nCreate _models/todos-fixture.js_ as follows:\n\n\n```js\n// models/todos-fixture.js\nvar fixture = require(\"can-fixture\");\nvar Todo = require(\"./todo\");\n\nvar todoStore = fixture.store([\n    { name: \"mow lawn\", complete: false, id: 5 },\n    { name: \"dishes\", complete: true, id: 6 },\n    { name: \"learn canjs\", complete: false, id: 7 }\n], Todo.algebra);\n\nfixture(\"/api/todos\", todoStore);\nfixture.delay = 500;\n\nmodule.exports = todoStore;\n\n```\n\n## Connect the Todo model to the service layer (can-connect) ##\n\n### The problem\n\n- Decorate `Todo` with methods so it can get, create, updated, and delete todos at the `/api/todos` service.  Specifically:\n  - `Todo.getList()` which calls `GET /api/todos`\n  - `Todo.get({id: 5})` which calls `GET /api/todos/5`\n  - `todo.save()` which calls `POST /api/todos` if `todo` doesn't have an `id` or `PUT /api/todos/{id}` if the `todo` has an id.\n  - `todo.destroy()` which calls `DELETE /api/todos/5`\n\n### What you need to know\n\n- [The can-connect Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZebHFWMElNOVEwSlE) up to and including _Migrate 2 can-connect_.\n- [can-connect/can/base-map/base-map] can decorate a `DefineMap` with methods that connect it to a restful URL like:\n\n  ```js\n  baseMap({\n    Map: Type,\n    url: \"URL\",\n    algebra: algebra\n  })\n  ```\n\n### The solution\n\n```\nnpm install can-connect --save\n```\n\nUpdate _models/todo.js_ to the following:\n\n\n```js\n// models/todo.js\nvar DefineMap = require(\"can-define/map/\");\nvar DefineList = require(\"can-define/list/\");\nvar set = require(\"can-set\");\nvar connectBaseMap = require(\"can-connect/can/base-map/\");\n\nvar Todo = DefineMap.extend(\"Todo\", {\n\tid: \"string\",\n\tname: \"string\",\n\tcomplete: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\ttoggleComplete: function() {\n\t\tthis.complete = !this.complete;\n\t}\n});\n\nTodo.List = DefineList.extend(\"TodoList\", {\n\t\"#\": Todo,\n\tget active() {\n\t\treturn this.filter({\n\t\t\tcomplete: false\n\t\t});\n\t},\n\tget complete() {\n\t\treturn this.filter({\n\t\t\tcomplete: true\n\t\t});\n\t},\n\tget allComplete() {\n\t\treturn this.length === this.complete.length;\n\t}\n});\n\nTodo.algebra = new set.Algebra(\n\tset.props.boolean(\"complete\"),\n\tset.props.id(\"id\"),\n\tset.props.sort(\"sort\")\n);\n\nTodo.connection = connectBaseMap({\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: Todo.List,\n\tname: \"todo\",\n\talgebra: Todo.algebra\n});\n\nmodule.exports = Todo;\n\n```\n<span line-highlight='5,42-48,only'></span>\n## List todos from the service layer (can-connect use) ##\n\n\n### The problem\n\nGet all `todos` from the service layer using the \"connected\" `Todo` type.\n\n### What you need to know\n\n- [The can-connect Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZebHFWMElNOVEwSlE) up to and including _Important Interfaces_.\n- [can-connect/can/map/map.getList Type.getList] gets data using the\n  [can-connect/connection.getList connection’s getList] and returns a\n  promise that resolves to the `Type.List` of instances:\n\n  ```js\n  Type.getList({}).then(function(list){\n\n  })\n  ```\n- An async [can-define.types.get getter] property behavior can be used\n  to \"set\" a property to an initial value:\n\n  ```js\n  property: {\n      get: function(lastSet, resolve) {\n          SOME_ASYNC_METHOD( function callback(data) {\n              resolve(data);\n          });\n      }\n  }\n  ```\n\n### The solution\n\nUpdate _index.js_ to the following:\n\n\n```js\n// index.js\nvar view = require(\"./index.stache\");\nvar DefineMap = require(\"can-define/map/\");\nvar Todo = require(\"~/models/todo\");\nrequire(\"~/models/todos-fixture\");\n\nvar AppViewModel = DefineMap.extend(\"AppViewModel\",{\n\tappName: \"string\",\n    todosList: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tTodo.getList({}).then(resolve);\n\t\t}\n\t}\n});\n\nvar appVM = window.appVM = new AppViewModel({\n\tappName: \"TodoMVC\"\n});\n\nvar frag = view(appVM);\ndocument.body.appendChild(frag);\n\nrequire(\"can-todomvc-test\")(appVM);\n\n```\n<span line-highlight='5,10-12,only'></span>\n## Toggling a todo’s checkbox updates service layer (can-connect use) ##\n\n\n### The problem\n\nUpdate the service layer when a todo’s completed status\nchanges. Also, disable the checkbox while the update is happening.\n\n### What you need to know\n\n- Call [can-connect/can/map/map.prototype.save] to update a \"connected\"\n  `Map` instance:\n\n  ```\n  map.save();\n  ```\n\n  `save()` can also be called by an [can-stache-bindings.event] binding.\n\n- [can-connect/can/map/map.prototype.isSaving] returns true when `.save()`\n  has been called, but has not resolved yet.\n\n  ```\n  map.isSaving()\n  ```\n\n\n### The solution\n\nUpdate _index.stache_ to the following:\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        checked:bind=\"complete\"\n                        on:change=\"save()\"\n                        disabled:from=\"isSaving()\"/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='16-17,only'></span>\n\n## Delete todos in the page (can-connect use) ##\n\n### The problem\n\nWhen a todo’s __destroy__ button is clicked, we need to delete the\ntodo on the server and remove the todo’s element from the page. While\nthe todo is being destroyed, add `destroying` to the todo’s `<li>`’s `class`\nattribute.\n\n### Things to know\n\n- The remaining parts of the [can-connect Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZebHFWMElNOVEwSlE), with an emphasis on how [can-connect/real-time/real-time] behavior works.\n- Delete a record on the server with [can-connect/can/map/map.prototype.destroy] like:\n  ```js\n  map.destroy()\n  ```\n\n- [can-connect/can/map/map.prototype.isDestroying] returns true when `.destroy()`\n  has been called, but has not resolved yet.\n\n  ```js\n  map.isDestroying()\n  ```\n\n### The solution\n\nUpdate _index.stache_ to the following:\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\n                {{#if isDestroying}}destroying{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        checked:bind=\"complete\"\n                        on:change=\"save()\"\n                        disabled:from=\"isSaving()\"/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\" on:click=\"destroy()\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='13,20,only'></span>\n## Create todos (can-component) ##\n\n### The problem\n\nMake it possible to create a todo, update the service layer\nand show the todo in the list of todos.\n\nThis functionality should be encapsulated by a `<todo-create/>`\ncustom element.\n\n### What you need to know\n\n- [The  can-component presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeMnlHZzB6ZERUSEk) up to and including how to _define a component_.\n- A [can-component] combines a custom tag name, [can-stache] view and a [can-define/map/map] ViewModel like:\n\n  ```js\n  var Component = require(\"can-component\");\n  var view = require(\"./template.stache\");\n  var ViewModel = DefineMap.extend({\n    ...      \n  });\n\n  Component.extend({\n      tag: \"some-component\",\n      view: view,\n      ViewModel: ViewModel\n  });\n  ```\n\n- You can use `on:enter` to listen to when the user hits the __enter__ key.\n- The [can-define.types.ValueConstructor] behavior creates a default value by using `new Value` to initialize the value when\na `DefineMap` property is read for the first time.\n\n  ```js\n  var SubType = DefineMap.extend({})\n  var Type = DefineMap.extend({\n      property: {Value: SubType}\n  })\n\n  var map = new Type();\n  map.property instanceof SubType //-> true\n  ```\n\n- Use [can-view-import] to import a module from a template like:\n\n  ```\n  <can-import from=\"~/components/some-component/\"/>\n  <some-component>\n  ```\n\n\n\n### The solution\n\n```\nnpm install can-component --save\n```\n\nCreate _components/todo-create/todo-create.stache_ as follows:\n\n\n```html\n<!-- components/todo-create/todo-create.stache -->\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    value:bind=\"todo.name\"\n    on:enter=\"createTodo()\"/>\n\n```\n\nCreate _components/todo-create/todo-create.js_ as follows:\n\n\n```js\n// components/todo-create/todo-create.js\nvar Component = require(\"can-component\"); // remember to install\nvar DefineMap = require(\"can-define/map/\");\nvar view = require(\"./todo-create.stache\");\nvar Todo = require(\"~/models/todo\");\n\nvar TodoCreateVM = DefineMap.extend({\n\ttodo: {\n\t\tValue: Todo\n\t},\n\tcreateTodo: function() {\n\t\tthis.todo.save().then(function() {\n\t\t\tthis.todo = new Todo();\n\t\t}.bind(this));\n\t}\n});\n\nmodule.exports = Component.extend({\n\ttag: \"todo-create\",\n\tview: view,\n\tViewModel: TodoCreateVM\n});\n\n```\n\nUpdate _index.stache_ to the following:\n\n\n```html\n<!-- index.stache -->\n<can-import from=\"~/components/todo-create/\"/>\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <todo-create/>\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\n                {{#if isDestroying}}destroying{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        checked:bind=\"complete\"\n                        on:change=\"save()\"\n                        disabled:from=\"isSaving()\"/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\" on:click=\"destroy()\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='2,6,only'></span>\n## Edit todo names (can-stache-bindings) ##\n\n### The problem\n\nMake it possible to edit a `todos` name by\ndouble-clicking its label which should reveal\na _focused_ input element.  If the user hits\nthe __enter__ key, the todo should be updated on the\nserver.  If the input loses focus, it should go\nback to the default list view.\n\nThis functionality should be encapsulated by a `<todo-list {todos}/>`\ncustom element.  It should accept a `todos` property that\nis the list of todos that will be managed by the custom element.\n\n\n### What you need to know\n\n- [The can-stache-bindings presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeYUJ3ZVRxUlU2MjQ) on _data bindings_.\n\n- The [can-util/dom/attr/attr.special.focused] custom attribute can be used to specify when an element should be focused:\n\n  ```html\n  focused:from=\"shouldBeFocused()\"\n  ```\n\n- Use [can-stache-bindings.toChild] to pass a value from the scope to a component:\n\n  ```\n  <some-component {name-in-component}=\"nameInScope\"/>\n  ```\n\n- [can-stache/keys/this] can be used to get the current context in stache:\n\n  ```html\n  <div on:click=\"doSomethingWith(this)\"/>\n  ```\n\n### The solution\n\nCreate _components/todo-list/todo-list.stache_ as follows:\n\n\n```html\n<!-- components/todo-list/todo-list.stache -->\n<ul id=\"todo-list\">\n\t{{#each todos}}\n    <li class=\"todo {{#if ./complete}}completed{{/if}}\n\t\t{{#if isDestroying}}destroying{{/if}}\n\t\t{{#if isEditing(this)}}editing{{/if}}\">\n\t\t<div class=\"view\">\n\t\t\t<input class=\"toggle\" type=\"checkbox\"\n\t\t\t\tchecked:bind=\"complete\"\n\t\t\t\ton:change=\"save()\"\n\t\t\t\tdisabled:from=\"isSaving()\"/>\n        \t<label on:dblclick=\"edit(this)\">{{name}}</label>\n        \t<button class=\"destroy\" on:click=\"destroy()\"></button>\n\t\t</div>\n\t\t<input class=\"edit\" type=\"text\"\n\t        value:bind=\"name\"\n\t        on:enter=\"updateName()\"\n\t        focused:from=\"isEditing(this)\"\n\t        on:blur=\"cancelEdit()\"/>\n    </li>\n\t{{/each}}\n</ul>\n\n```\n\nCreate _components/todo-list/todo-list.js_ as follows:\n\n\n```js\n// components/todo-list/todo-list.js\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/\");\nvar view = require(\"./todo-list.stache\");\nvar Todo = require(\"~/models/todo\");\n\nvar TodoListVM = DefineMap.extend({\n\ttodos: Todo.List,\n\tediting: Todo,\n\tbackupName: \"string\",\n\tisEditing: function(todo) {\n\t\treturn todo === this.editing;\n\t},\n\tedit: function(todo) {\n\t\tthis.backupName = todo.name;\n\t\tthis.editing = todo;\n\t},\n\tcancelEdit: function() {\n\t\tif (this.editing) {\n\t\t\tthis.editing.name = this.backupName;\n\t\t}\n\t\tthis.editing = null;\n\t},\n\tupdateName: function() {\n\t\tthis.editing.save();\n\t\tthis.editing = null;\n\t}\n});\n\nmodule.exports = Component.extend({\n\ttag: \"todo-list\",\n\tview: view,\n\tViewModel: TodoListVM\n});\n\n```\n\nUpdate _index.stache_ to the following:\n\n\n```html\n<!-- index.stache -->\n<can-import from=\"~/components/todo-create/\"/>\n<can-import from=\"~/components/todo-list/\"/>\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <todo-create/>\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <todo-list todos:from=\"todosList\"/>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='3,12,only'></span>\n## Toggle all todos complete state (DefineMap setter) ##\n\n### The problem\n\nMake the “toggle all” checkbox work.  It should be\nunchecked if a single todo is unchecked and checked\nif all todos are checked.\n\nWhen the “toggle all” checkbox is changed, the\napplication should update every todo to match\nthe status of the “toggle all” checkbox.\n\nThe “toggle all” checkbox should be disabled if a\nsingle todo is saving.\n\n### What you need to know\n\n- Using [can-define.types.set setters] and [can-define.types.get getters] a virtual property\ncan be simulated like:\n\n  ```js\n  DefineMap.extend({\n      first: \"string\",\n      last: \"string\",\n      get fullName(){\n          return this.first + \" \" + this.last;\n      },\n      set fullName(newValue){\n          var parts = newValue.split(\" \");\n          this.first = parts[0];\n          this.last = parts[1];\n      }\n  })\n  ```\n\n### The solution\n\nUpdate _models/todo.js_ to the following:\n\n\n```js\n// models/todo.js\nvar DefineMap = require(\"can-define/map/\");\nvar DefineList = require(\"can-define/list/\");\nvar set = require(\"can-set\");\nvar connectBaseMap = require(\"can-connect/can/base-map/\");\n\nvar Todo = DefineMap.extend(\"Todo\", {\n\tid: \"string\",\n\tname: \"string\",\n\tcomplete: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\ttoggleComplete: function() {\n\t\tthis.complete = !this.complete;\n\t}\n});\n\nTodo.List = DefineList.extend(\"TodoList\", {\n\t\"#\": Todo,\n\tget active() {\n\t\treturn this.filter({\n\t\t\tcomplete: false\n\t\t});\n\t},\n\tget complete() {\n\t\treturn this.filter({\n\t\t\tcomplete: true\n\t\t});\n\t},\n\tget allComplete() {\n\t\treturn this.length === this.complete.length;\n\t},\n\tget saving() {\n\t\treturn this.filter(function(todo) {\n\t\t\treturn todo.isSaving();\n\t\t});\n\t},\n\tupdateCompleteTo: function(value) {\n\t\tthis.forEach(function(todo) {\n\t\t\ttodo.complete = value;\n\t\t\ttodo.save();\n\t\t});\n\t}\n});\n\nTodo.algebra = new set.Algebra(\n\tset.props.boolean(\"complete\"),\n\tset.props.id(\"id\"),\n\tset.props.sort(\"sort\")\n);\n\nTodo.connection = connectBaseMap({\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: Todo.List,\n\tname: \"todo\",\n\talgebra: Todo.algebra\n});\n\nmodule.exports = Todo;\n\n```\n<span line-highlight='34-44,only'></span>\nUpdate _index.js_ to the following:\n\n\n```js\n// index.js\nvar view = require(\"./index.stache\");\nvar DefineMap = require(\"can-define/map/\");\nvar Todo = require(\"~/models/todo\");\nrequire(\"~/models/todos-fixture\");\n\nvar AppViewModel = DefineMap.extend(\"AppViewModel\",{\n\tappName: \"string\",\n    todosList: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tTodo.getList({}).then(resolve);\n\t\t}\n\t},\n\tget allChecked() {\n\t\treturn this.todosList && this.todosList.allComplete;\n\t},\n\tset allChecked(newVal) {\n\t\tthis.todosList && this.todosList.updateCompleteTo(newVal);\n\t}\n});\n\nvar appVM = window.appVM = new AppViewModel({\n\tappName: \"TodoMVC\"\n});\n\nvar frag = view(appVM);\ndocument.body.appendChild(frag);\n\nrequire(\"can-todomvc-test\")(appVM);\n\n```\n<span line-highlight='14-19,only'></span>\nUpdate _index.stache_ to the following:\n\n\n```html\n<!-- index.stache -->\n<can-import from=\"~/components/todo-create/\"/>\n<can-import from=\"~/components/todo-list/\"/>\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <todo-create/>\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\"\n            checked:bind=\"allChecked\"\n            disabled:from=\"todosList.saving.length\"/>\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <todo-list todos:from=\"todosList\"/>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='10-12,only'></span>\n## Clear completed todo’s (event bindings) ##\n\n### The problem\nMake the \"Clear completed\" button work. When the button is clicked, It should destroy each completed todo.\n\n### What you need to know\n\n- [The can-stache-bindings Presentation’s](https://drive.google.com/open?id=0Bx-kNqf-wxZeYUJ3ZVRxUlU2MjQ) _DOM Event Bindings_\n- Use [can-stache-bindings.event on:EVENT] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked.\n\n   ```html\n   <div on:click=\"doSomething()\"> ... </div>\n   ```\n\n### The solution\n\nUpdate _models/todo.js_ to the following:\n\n\n```js\n// models/todo.js\nvar DefineMap = require(\"can-define/map/\");\nvar DefineList = require(\"can-define/list/\");\nvar set = require(\"can-set\");\nvar connectBaseMap = require(\"can-connect/can/base-map/\");\n\nvar Todo = DefineMap.extend(\"Todo\", {\n\tid: \"string\",\n\tname: \"string\",\n\tcomplete: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\ttoggleComplete: function() {\n\t\tthis.complete = !this.complete;\n\t}\n});\n\nTodo.List = DefineList.extend(\"TodoList\", {\n\t\"#\": Todo,\n\tget active() {\n\t\treturn this.filter({\n\t\t\tcomplete: false\n\t\t});\n\t},\n\tget complete() {\n\t\treturn this.filter({\n\t\t\tcomplete: true\n\t\t});\n\t},\n\tget allComplete() {\n\t\treturn this.length === this.complete.length;\n\t},\n\tget saving() {\n\t\treturn this.filter(function(todo) {\n\t\t\treturn todo.isSaving();\n\t\t});\n\t},\n\tupdateCompleteTo: function(value) {\n\t\tthis.forEach(function(todo) {\n\t\t\ttodo.complete = value;\n\t\t\ttodo.save();\n\t\t});\n\t},\n\tdestroyComplete: function(){\n\t\tthis.complete.forEach(function(todo){\n\t\t\ttodo.destroy();\n\t\t});\n\t}\n});\n\nTodo.algebra = new set.Algebra(\n\tset.props.boolean(\"complete\"),\n\tset.props.id(\"id\"),\n\tset.props.sort(\"sort\")\n);\n\nTodo.connection = connectBaseMap({\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: Todo.List,\n\tname: \"todo\",\n\talgebra: Todo.algebra\n});\n\nmodule.exports = Todo;\n\n```\n<span line-highlight='45-49,only'></span>\nUpdate _index.stache_ to the following:\n\n\n```html\n<!-- index.stache -->\n<can-import from=\"~/components/todo-create/\"/>\n<can-import from=\"~/components/todo-list/\"/>\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <todo-create/>\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\"\n            checked:bind=\"allChecked\"\n            disabled:from=\"todosList.saving.length\"/>\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <todo-list todos:from=\"todosList\"/>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\"\n            on:click=\"allTodos.destroyComplete()\">\n            Clear completed ({{allTodos.complete.length}})\n        </button>>\n    </footer>\n</section>\n\n```\n<span line-highlight='31-32,only'></span>\n## Setup routing (can-route) ##\n\nMake it so that the following urls display the corresponding\ntodos:\n\n - `#!` or ` ` - All todos\n - `#!active` - Only the incomplete todos\n - `#!complete` - Only the completed todos\n\nAlso, the _All_, _Active_, and _Completed_ buttons should\nlink to those pages and a `class='selected'` property should\nbe added if they represent the current page.\n\n\n### What you need to know\n\n- [can-route] is used to connect a `DefineMap`’s properties\n  to the URL.  This is done with [can-route.data] like:\n\n  ```js\n  route.data = new AppViewModel();\n  ```\n\n- [can-route] can create pretty routing rules.  For example,\n  if `#!login` should set the `page` property of the\n  `AppViewModel` to `\"login\"`, use `route()` like:\n\n  ```js\n  route(\"{page}\");\n  ```\n\n- [can-route.ready] initializes the connection between the\n  url and the `AppViewModel`.  After you've created all\n  your application’s pretty routing rules, call it like:\n\n  ```js\n  route.ready()\n  ```\n\n- The [can-stache/helpers/route] module provides helpers\n  that use [can-route].  \n\n  [can-stache.helpers.routeCurrent]\n  returns truthy if the current route matches its first parameters properties.\n\n  ```html\n  {{#if routeCurrent(page='login',true)}}\n    You are on the login page.\n  {{/if}}\n  ```\n\n  [can-stache.helpers.routeUrl] returns a url that will\n  set its first parameters properties:\n\n  ```\n  <a href=\"{{routeUrl page='login'}}\">Login</a>\n  ```\n\n### The solution\n\n```\nnpm install can-route --save\n```\n\nUpdate _index.js_ to the following:\n\n\n```js\n// index.js\nvar view = require(\"./index.stache\");\nvar DefineMap = require(\"can-define/map/\");\nvar Todo = require(\"~/models/todo\");\nvar route = require(\"can-route\");\nrequire(\"~/models/todos-fixture\");\n\nvar AppViewModel = DefineMap.extend(\"AppViewModel\", {\n\tappName: {type: \"string\", serialize: false},\n\tfilter: \"string\",\n\tallTodos: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tTodo.getList({}).then(resolve);\n\t\t}\n\t},\n\tget todosList() {\n\t\tif(this.allTodos) {\n\t\t\tif(this.filter === \"complete\") {\n\t\t\t\treturn this.allTodos.complete;\n\t\t\t} else if(this.filter === \"active\") {\n\t\t\t\treturn this.allTodos.active;\n\t\t\t} else {\n\t\t\t\treturn this.allTodos;\n\t\t\t}\n\t\t}\n\t},\n\tget allChecked() {\n\t\treturn this.todosList && this.todosList.allComplete;\n\t},\n\tset allChecked(newVal) {\n\t\tthis.todosList && this.todosList.updateCompleteTo(newVal);\n\t}\n});\n\nvar appVM = window.appVM = new AppViewModel({\n\tappName: \"TodoMVC\"\n});\n\nroute.data = appVM;\nroute(\"{filter}\");\nroute.ready();\n\nvar frag = view(appVM);\ndocument.body.appendChild(frag);\n\nrequire(\"can-todomvc-test\")(appVM);\n\n```\n<span line-highlight='5,9-26,39-41,only'></span>\nUpdate _index.stache_ to the following:\n\n\n```html\n<!-- index.stache -->\n<can-import from=\"~/components/todo-create/\"/>\n<can-import from=\"~/components/todo-list/\"/>\n<can-import from=\"can-stache/helpers/route\"/>\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <todo-create/>\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\"\n          checked:bind=\"allChecked\"\n          disabled:from=\"todosList.saving.length\"/>\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <todo-list todos:from=\"todosList\"/>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{allTodos.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a href=\"{{routeUrl filter=undefined}}\"\n                    {{#routeCurrent filter=undefined}}class='selected'{{/routeCurrent}}>\n                    All\n                </a>\n            </li>\n            <li>\n                <a href=\"{{routeUrl filter='active'}}\"\n                    {{#routeCurrent filter='active'}}class='selected'{{/routeCurrent}}>\n                    Active\n                </a>\n            </li>\n            <li>\n                <a href=\"{{routeUrl filter='complete'}}\"\n                    {{#routeCurrent filter='complete'}}class='selected'{{/routeCurrent}}>\n                    Completed\n                </a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\"\n            on:click=\"allTodos.destroyComplete()\">\n            Clear completed ({{allTodos.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='4,23-26,29-32,35-38,only'></span>\n__Success!__ You’ve completed this guide. Have questions or comments? Let us know on [Gitter chat](https://gitter.im/canjs/canjs) or our [forums](https://forums.donejs.com/c/canjs)!\n\n",
    "description": "This guide walks through building TodoMVC with StealJS.\n\n",
    "name": "guides/recipes/todomvc-with-steal",
    "title": "TodoMVC with StealJS",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes/weather-report-advanced": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/weather-report/weather-report-advanced.md"
    },
    "body": "\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/jipevu/3/embed?html,js,output\">JS Bin on jsbin.com</a>\n\n__Start this tutorial by cloning the following JS Bin__:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/qowacac/3/embed?html,js,output\">JS Bin on jsbin.com</a>\n\nThis is the ending JS Bin for the [guides/recipes/weather-report-simple Simple Weather Report Guide] with [Kefir.js](https://rpominov.github.io/kefir/) added.\n\nThe following sections are broken down into:\n\n- Problem — A description of what the section is trying to accomplish.\n- Things to know — Information about CanJS that is useful for solving the problem.\n- Solution — The solution to the problem.\n\n## Removing Imperative Code\n\n### The problem\n\nCurrently, when a new `location` is set, the `place` property is set to `null`:\n\n```js\nvar WeatherViewModel = can.DefineMap.extend({\n  location: {\n    type: \"string\",\n    set: function(){\n      this.place = null;\n    }\n  },\n  ...\n});\n```\n\nThis is [imperative code](https://en.wikipedia.org/wiki/Imperative_programming).\nIt uses side-effects to change the value\nof `place` when `location` is changed.  The rules for how `place` behaves are not\ndefined in one place, which makes the code harder to follow.\n\nInstead, we want to completely define the behavior of `place` within the place definition, which looks like\nthis:\n\n```js\nvar WeatherViewModel = can.DefineMap.extend({\n  ...\n  place: {\n    type: \"any\",\n    get: function(lastSet){\n      if(lastSet) {\n        return lastSet;\n      } else {\n        if(this.places && this.places.length === 1) {\n          return this.places[0];\n        }\n      }\n    }\n  },\n  ...\n});\n```\n\nWe want to define the behavior of `place` so that it becomes `null` when `location` changes.\n\n### Things to know\n\n- `DefineMap` [can-define.types.get getters] can only derive a value from other values.  They can’t\n  derive a value from the change in other values.  However, event-stream libraries like [KefirJS](https://rpominov.github.io/kefir/)\n  can do this.\n\n  For example, we can create a `Kefir` stream that counts the number of times the following `person` map’s `name`\n  property changes using the [can-stream-kefir] module as follows:\n\n  ```js\n  var person = new can.DefineMap({name: \"Justin\"});\n\n  // Create a stream from person’s name\n  var nameStream = can.streamKefir.toStream(person,\".name\");\n\n  // Every time `.name` changes, increase the count 1.\n  var nameChangeCountStream = nameStream.scan(function(lastValue){\n\t  return lastValue + 1;\n  }, 0);\n\n  // Log the current nameChangeStream value\n  nameChangeStream.onValue(function(newValue){\n\t  console.log(newValue);\n  });\n\n  person.name = \"Ramiya\" // logs 1\n\n  person.name = \"Payal\"  // logs 2\n  ```\n\n- The `toStream` method can take an observable object and a property (or event) and create an event stream. The following creates a stream of the `person.name` property values:\n\n  ```js\n  var person = new can.DefineMap({name: \"Justin\"});\n  var nameStream = can.streamKefir.toStream(person,\".name\");\n\n  nameStream.onValue(function(newValue){\n\t  console.log(newValue);\n  });\n\n  person.name = \"Ramiya\" // logs \"Ramiya\"\n  person.name = \"Payal\" // logs \"Payal\"\n  ```\n\n- Kefir’s [map](https://rpominov.github.io/kefir/#map) method can be used to convert event-stream values into new values.  The following creates an event stream of upper-cased names:\n\n  ```js\n  var person = new can.DefineMap({name: \"Justin\"});\n  var capitalizedNameStream = can.streamKefir.toStream(person,\".name\")\n  \t.map(function(name){\n\t\treturn name.toUpperCase()\n\t});\n\n  nameStream.onValue(function(newValue){\n\t  console.log(newValue);\n  });\n\n  person.name = \"Ramiya\" // logs \"RAMIYA\"\n  person.name = \"Payal\" // logs \"PAYAL\"\n  ```\n\n- The [can-define-stream-kefir] module lets you define a property value using\n  a stream. For example, we can define a `nameChangeCount` property of a `Person` type using `stream` like:\n\n  ```js\n  Person = can.DefineMap.extend({\n\t  name: \"string\",\n\t  nameChangeCount: {\n\t\t  stream: function(){\n\t\t\t  return this.toStream(\".name\").scan(function(lastValue){\n\t\t\t\t  return lastValue + 1;\n\t\t\t  }, 0);\n\t\t  }\n\t  }\n  });\n  can.defineStreamKefir(Person);\n  ```\n\n  Notice that the [can-define-stream-kefir] module is used as a [mixin](https://developer.mozilla.org/en-US/docs/Glossary/Mixin). When called on a type (like `Person`), the mixin\n  looks for [can-define.types.propDefinition]s with `stream`\n  property definition functions.  It uses the stream instance returned by the `stream` property definition function as the value of the property.\n\n  Stream properties, like asynchronous getters, only have a value when\n  bound to.  To read the `nameChangeCount`, first use `.on` like:\n\n  ```js\n  var me = new Person({name: \"Justin\"});\n  me.on(\"nameChangeCount\", function(ev, newValue){\n\t  console.log(newValue);\n  });\n\n  me.nameChangeCount //-> 0\n\n  me.name = \"Ramiya\" // logs 1\n\n  me.nameChangeCount //-> 1\n  ```\n\n- The `stream` property definition function is passed `setStream` which is\n  a stream of values set on the property.  The following allows a\n  user to set `nameChangeCount` to reset the count at some new value:\n\n  ```js\n  Person = can.DefineMap.extend({\n\tname: \"string\",\n\tnameChangeCount: {\n\t\tstream: function(setStream){\n\t\t\tvar reset = setStream.map(function(value){\n\t\t\t\treturn {type: \"reset\", value: value};\n\t\t\t});\n\t\t\tvar increment = this.toStream(\".name\").map(function(){\n\t\t\t\treturn {type: \"increment\"}\n\t\t\t});\n\n\t\t\treturn reset.merge(increment).scan(function(lastValue, next){\n\t\t\t\tif(next.type === \"increment\") {\n\t\t\t\t\treturn lastValue + 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn next.value;\n\t\t\t\t}\n\t\t\t}, 0);\n\t\t}\n\t}\n  });\n  can.defineStreamKefir(Person);\n  ```\n\n  The following shows the behavior of this property:\n\n  ```js\n  var me = new Person({name: \"Justin\"});\n  me.on(\"nameChangeCount\", function(ev, newValue){\n\tconsole.log(newValue);\n  });\n\n  me.nameChangeCount = 10;\n\n  me.name = \"Ramiya\" // logs 11\n\n  me.nameChangeCount //-> 11\n  ```\n\n- The [can-define-stream-kefir] module adds a `map.toStream` method which is an alias for\n  `canStream.toStream`.  Use it to create streams from properties and events on a map instance like:\n\n  ```js\n  var Person = can.DefineMap.extend({\n\t  name: \"string\"\n  });\n\n  var me = new Person({name: \"Justin\"});\n\n  var nameStream = me.toStream(\".name\");\n\n  nameStream.onValue(function(){ ... })\n  ```\n\n### The solution\n\nUpdate the __JavaScript__ tab to:\n\n1. Remove the setter side-effects from `location`.\n2. Change `place` to derive its value from:\n   - changes in `location` -  `place` should be `null` if `location` changes.\n   - the `.places` value - `place` should be the one and only _place_ in `places` if there is only one _place_ in `places`.\n   - the set `.place` value.\n3. Mix [can-define-stream-kefir] into the `WeatherViewModel`.\n\n\n```js\nvar yqlURL = \"https://query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n\tlocation: \"string\",\n\tget placesPromise() {\n\t\tif (this.location && this.location.length > 2) {\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from geo.places where text=\"' + this.location + '\"',\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(data);\n\t\t\t\tif (Array.isArray(data.query.results.place)) {\n\t\t\t\t\treturn data.query.results.place;\n\t\t\t\t} else {\n\t\t\t\t\treturn [data.query.results.place];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tplaces: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tif (this.placesPromise) {\n\t\t\t\tthis.placesPromise.then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showPlacePicker() {\n\t\treturn !this.place && this.places && this.places.length > 1;\n\t},\n\tplace: {\n\t\tstream: function(setStream) {\n\t\t\tvar resetStream = this.toStream(\".location\").map(function() {\n\t\t\t\treturn null;\n\t\t\t});\n            var onePlaceResultStream = this.toStream(\".places\").map(function(places){\n                if(places.length === 1) {\n                    return places[0];\n                } else {\n                    return null;\n                }\n            });\n\n\t\t\treturn onePlaceResultStream\n\t\t\t\t.merge(setStream)\n\t\t\t\t.merge(resetStream);\n\t\t}\n\t},\n\tpickPlace: function(place) {\n\t\tthis.place = place;\n\t},\n\tget forecastPromise() {\n\t\tif (this.place) {\n            console.log(\"place\", this.place);\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from weather.forecast where woeid=' + this.place.woeid,\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(\"forecast data\", data);\n\t\t\t\tvar forecast = data.query.results.channel.item.forecast;\n\n\t\t\t\treturn forecast;\n\t\t\t});\n\t\t}\n\t},\n\ttoClassName: function(text) {\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n\t}\n});\ncan.defineStreamKefir(WeatherViewModel);\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='4,35-52,79,only'></span>\n## Get the geoLocation’s latitude and longitude\n\n### The problem\n\nInstead of requiring the user to search for their city,\nlet’s change the app to use the browser’s [geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation) API to look up their location.  For this step, we\nwill add the following behaviors:\n\n- If the user enables location services, we will write their latitude and longitude.\n- If the user disables location services or there is some other type of error,\n  we will print the error message.\n\nWe will do this by:\n\n- Creating a Kefir stream of the User’s position or error messages.\n- Using that stream to create the `geoLocation` and `geoLocationError` properties.\n- Displaying the data of those properties in the template.\n\n### What you need to know\n\n- The [geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation)\n  API allows you to _request_ the user’s position as follows:\n\n  ```js\n  navigator.geolocation.getCurrentPosition(\n      function(position){...},\n      function(err){...});\n  ```\n\n- The [geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation)\n  API allows you to _monitor changes_ in the user’s position as follows:\n\n  ```js\n  var watch = navigator.geolocation.watchPosition(\n      function(position){...},\n      function(err){...});\n  ```\n\n  To cancel watching, call:\n\n  ```js\n  navigator.geolocation.clearWatch(watch);\n  ```\n\n- To create a `Kefir` stream, call `Kefir.stream` as follows:\n\n  ```js\n  var myStream = Kefir.stream(function setup(emitter){\n\n      // INITIALIZATION CODE\n\n      return function teardown(){\n          // TEARDOWN CODE\n      }\n  });\n  ```\n\n  `Kefir.stream` is passed an event emitter which can emit values like:\n\n  ```js\n  emitter.value(123);\n  ```\n\n  or errors like:\n\n  ```js\n  emitter.error(\"something went wrong\");\n  ```\n\n  or end the stream of values like:\n\n  ```js\n  emitter.end();\n  ```\n\n  Typically, you listen to sources and emit values in the `setup` function\n  and stop listening to sources in the `teardown` function.  For example,\n  the following might listen to where the user’s mouse is on the page:\n\n  ```js\n  var cursorPosition = Kefir.stream(function(emitter){\n      var handler = function(ev){\n          emitter.emit({pageX: ev.pageX, pageY: pageY});\n      };\n      document.documentElement.addEventListener(\"mousemove\",handler);\n\n      return function(){\n          document.documentElement.removeEventListener(\"mousemove\",handler);\n      }\n  })\n  ```\n\n- Kefir’s `stream.withHandler( handler(emitter, event) )` is able to convert one stream’s events to another stream. All other stream methods like `stream.map` and `stream.scan` can be implemented with `stream.withHandler`. For example, the following maps the `cursorPosition` stream to a `cursorDistance` stream:\n\n  ```js\n  cursorDistance = cursorPosition.withHandler(function(emitter, event){\n      if (event.type === 'end') {\n        emitter.end();\n      }\n      if (event.type === 'error') {\n        emitter.error(event.value);\n      }\n      if (event.type === 'value') {\n        var pageX = event.value.pageX;\n        var pageY = event.value.pageY;\n        emitter.value( Math.sqrt(pageX*pageX + pageY*pageY) );\n      }\n  });\n  ```\n\n  Notice how `withHandler` is called with the emitter of `cursorDistance`\n  and the events of `cursorPosition`.  \n\n### The solution\n\nUpdate the __JavaScript__ tab:\n\n\n```js\nvar yqlURL = \"https://query.yahooapis.com/v1/public/yql?\";\n\nvar geoLocationStream = Kefir.stream(function(emitter) {\n\tnavigator.geolocation.getCurrentPosition(function(position){\n\t  emitter.value(position);\n\t}, function(err){\n\t\tconsole.log(\"getCurrentPositionErr\",err);\n\t\temitter.error(err);\n\t});\n\n\n\t var watch = navigator.geolocation.watchPosition(function(position){\n\t   emitter.value(position);\n\t }, function(err){\n\t     emitter.error(err);\n     });\n\n\treturn function() {\n\t\tnavigator.geolocation.clearWatch(watch);\n\t};\n});\n\nvar WeatherViewModel = can.DefineMap.extend({\n\tgeoLocation: {\n\t\tstream: function() {\n\t\t\treturn geoLocationStream;\n\t\t}\n\t},\n    geoLocationError: {\n        stream: function() {\n\t\t\treturn geoLocationStream.withHandler(function(emitter, event){\n                if (event.type === 'end') {\n                    emitter.end();\n                }\n                if (event.type === 'error') {\n                    emitter.value(event.value);\n                }\n            });\n\t\t}\n    },\n\tlocation: \"string\",\n\tget placesPromise() {\n\t\tif (this.location && this.location.length > 2) {\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from geo.places where text=\"' + this.location + '\"',\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(data);\n\t\t\t\tif (Array.isArray(data.query.results.place)) {\n\t\t\t\t\treturn data.query.results.place;\n\t\t\t\t} else {\n\t\t\t\t\treturn [data.query.results.place];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tplaces: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tif (this.placesPromise) {\n\t\t\t\tthis.placesPromise.then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showPlacePicker() {\n\t\treturn !this.place && this.places && this.places.length > 1;\n\t},\n\tplace: {\n\t\tstream: function(setStream) {\n\t\t\tvar resetStream = this.toStream(\".location\").map(function() {\n\t\t\t\treturn null;\n\t\t\t});\n            var onePlaceResultStream = this.toStream(\".places\").map(function(places){\n                if(places.length === 1) {\n                    return places[0];\n                } else {\n                    return null;\n                }\n            });\n\n\t\t\treturn onePlaceResultStream\n\t\t\t\t.merge(setStream)\n\t\t\t\t.merge(resetStream);\n\t\t}\n\t},\n\tpickPlace: function(place) {\n\t\tthis.place = place;\n\t},\n\tget forecastPromise() {\n\t\tif (this.place) {\n            console.log(\"place\", this.place);\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from weather.forecast where woeid=' + this.place.woeid,\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(\"forecast data\", data);\n\t\t\t\tvar forecast = data.query.results.channel.item.forecast;\n\n\t\t\t\treturn forecast;\n\t\t\t});\n\t\t}\n\t},\n\ttoClassName: function(text) {\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n\t}\n});\ncan.defineStreamKefir(WeatherViewModel);\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='3-21,24-40,only'></span>\nUpdate the __HTML__ tab:\n\n\n```html\nLatitude: {{geoLocation.coords.latitude}},\nLongitude: {{geoLocation.coords.longitude}},\nError: {{geoLocationError.message}}\n\n<div class=\"weather-widget\">\n\n  <div class=\"location-entry\">\n    <label for=\"location\">Enter Your location:</label>\n    <input id=\"location\" value:to=\"location\" type=\"text\"/>\n  </div>\n\n  {{#if placesPromise.isPending}}\n    <p class=\"loading-message\">\n      Loading places…\n    </p>\n  {{/if}}\n\n  {{#if showPlacePicker}}\n    <div class=\"location-options\">\n      <label>Pick your place:</label>\n      <ul>\n        {{#each placesPromise.value}}\n          <li on:click=\"../pickPlace(this)\">{{name}}, {{admin1.content}},\n              {{country.code}} ({{placeTypeName.content}})</li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n  {{#if place}}\n    <div class=\"forecast\">\n      <h1>10 day {{place.name}} Weather Forecast</h1>\n      <ul>\n        {{#each forecastPromise.value}}\n          <li>\n            <span class='date'>{{date}}</span>\n            <span class='description {{toClassName(text)}}'>{{text}}</span>\n            <span class='high-temp'>{{high}}<sup>&deg;</sup></span>\n            <span class='low-temp'>{{low}}<sup>&deg;</sup></span>\n          </li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n</div>\n\n```\n<span line-highlight='1-3,only'></span>\n## Find the user’s place by latitude and longitude\n\n### The problem\n\nWe need to get which place the user is in by their\nlatitude and longitude. We will save this place as the\n`geoPlace` property and use it in the `place` property definition.\n\n### What you need to know\n\nFlickr has an API that can get a place that is recognized by\nYahoo’s weather APIs.  It can be retrieved with `fetch` like:\n\n```js\nfetch(\"https://api.flickr.com/services/rest/?\"+\n    can.param({\n        method: \"flickr.places.findByLatLon\",\n        api_key: \"df0a221bb43ecbc2abb03426bd84e598\",\n        lat: LATITUDE,\n        lon: LONGITUDE,\n        format: \"json\",\n        nojsoncallback: 1\n    })\n).then(function(response){\n    return response.json()\n}).then(function(responseJSON){\n    return responseJSON.places.place[0];\n});\n```\n\n### The solution\n\nUpdate the __JavaScript__ tab:\n\n\n```js\nvar yqlURL = \"https://query.yahooapis.com/v1/public/yql?\";\n\nvar geoLocationStream = Kefir.stream(function(emitter) {\n\tnavigator.geolocation.getCurrentPosition(function(position){\n\t  emitter.value(position);\n\t}, function(err){\n\t\tconsole.log(\"getCurrentPositionErr\",err);\n\t\temitter.error(err);\n\t});\n\n\n\t var watch = navigator.geolocation.watchPosition(function(position){\n\t   emitter.value(position);\n\t }, function(err){\n\t     emitter.error(err);\n     });\n\n\treturn function() {\n\t\tnavigator.geolocation.clearWatch(watch);\n\t};\n});\n\nvar WeatherViewModel = can.DefineMap.extend({\n\tgeoLocation: {\n\t\tstream: function() {\n\t\t\treturn geoLocationStream;\n\t\t}\n\t},\n    geoLocationError: {\n        stream: function() {\n\t\t\treturn geoLocationStream.withHandler(function(emitter, event){\n                if (event.type === 'end') {\n                    emitter.end();\n                }\n                if (event.type === 'error') {\n                    emitter.value(event.value);\n                }\n            });\n\t\t}\n    },\n\tgeoPlace: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tif (this.geoLocation) {\n\t\t\t\tfetch(\"https://api.flickr.com/services/rest/?\" +\n\t\t\t\t\tcan.param({\n\t\t\t\t\t\tmethod: \"flickr.places.findByLatLon\",\n\t\t\t\t\t\tapi_key: \"df0a221bb43ecbc2abb03426bd84e598\",\n\t\t\t\t\t\tlat: this.geoLocation.coords.latitude,\n\t\t\t\t\t\tlon: this.geoLocation.coords.longitude,\n\t\t\t\t\t\tformat: \"json\",\n\t\t\t\t\t\tnojsoncallback: 1\n\t\t\t\t\t})\n\t\t\t\t).then(function(response){\n\t\t\t\t    return response.json();\n\t\t\t\t}).then(function(responseJSON){\n\t\t\t\t    return responseJSON.places.place[0];\n\t\t\t\t}).then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tlocation: \"string\",\n\tget placesPromise() {\n\t\tif (this.location && this.location.length > 2) {\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from geo.places where text=\"' + this.location + '\"',\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(data);\n\t\t\t\tif (Array.isArray(data.query.results.place)) {\n\t\t\t\t\treturn data.query.results.place;\n\t\t\t\t} else {\n\t\t\t\t\treturn [data.query.results.place];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tplaces: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tif (this.placesPromise) {\n\t\t\t\tthis.placesPromise.then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showPlacePicker() {\n\t\treturn !this.place && this.places && this.places.length > 1;\n\t},\n\tplace: {\n\t\tstream: function(setStream) {\n\t\t\tvar resetStream = this.toStream(\".location\").map(function() {\n\t\t\t\treturn null;\n\t\t\t});\n            var onePlaceResultStream = this.toStream(\".places\").map(function(places){\n                if(places.length === 1) {\n                    return places[0];\n                } else {\n                    return null;\n                }\n            });\n\n\t\t\treturn onePlaceResultStream\n\t\t\t\t.merge(setStream)\n\t\t\t\t.merge(resetStream)\n                .merge(this.toStream(\".geoPlace\"));\n\t\t}\n\t},\n\tpickPlace: function(place) {\n\t\tthis.place = place;\n\t},\n\tget forecastPromise() {\n\t\tif (this.place) {\n            console.log(\"place\", this.place);\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from weather.forecast where woeid=' + this.place.woeid,\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(\"forecast data\", data);\n\t\t\t\tvar forecast = data.query.results.channel.item.forecast;\n\n\t\t\t\treturn forecast;\n\t\t\t});\n\t\t}\n\t},\n\ttoClassName: function(text) {\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n\t}\n});\ncan.defineStreamKefir(WeatherViewModel);\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='41-60,108,only'></span>\n## Add \"Enable Location Services\" message\n\n### The problem\n\nWhen a user first views the page, they will be prompted to enable location\nservices. While they are prompted, we will display a `Please Enable Location Services…` message.\n\n### What you need to know\n\nDisplay the message while `geoLocation` and `geoLocationError` are undefined.\n\n### The solution\n\nUpdate the __JavaScript__ tab:\n\n\n```js\nvar yqlURL = \"https://query.yahooapis.com/v1/public/yql?\";\n\nvar geoLocationStream = Kefir.stream(function(emitter) {\n\tnavigator.geolocation.getCurrentPosition(function(position){\n\t  emitter.value(position);\n\t}, function(err){\n\t\tconsole.log(\"getCurrentPositionErr\",err);\n\t\temitter.error(err);\n\t});\n\n\n\t var watch = navigator.geolocation.watchPosition(function(position){\n\t   emitter.value(position);\n\t }, function(err){\n\t     emitter.error(err);\n     });\n\n\treturn function() {\n\t\tnavigator.geolocation.clearWatch(watch);\n\t};\n});\n\nvar WeatherViewModel = can.DefineMap.extend({\n\tgeoLocation: {\n\t\tstream: function() {\n\t\t\treturn geoLocationStream;\n\t\t}\n\t},\n    geoLocationError: {\n        stream: function() {\n\t\t\treturn geoLocationStream.withHandler(function(emitter, event){\n                if (event.type === 'end') {\n                    emitter.end();\n                }\n                if (event.type === 'error') {\n                    emitter.value(event.value);\n                }\n            });\n\t\t}\n    },\n\tgeoPlace: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tif (this.geoLocation) {\n\t\t\t\tfetch(\"https://api.flickr.com/services/rest/?\" +\n\t\t\t\t\tcan.param({\n\t\t\t\t\t\tmethod: \"flickr.places.findByLatLon\",\n\t\t\t\t\t\tapi_key: \"df0a221bb43ecbc2abb03426bd84e598\",\n\t\t\t\t\t\tlat: this.geoLocation.coords.latitude,\n\t\t\t\t\t\tlon: this.geoLocation.coords.longitude,\n\t\t\t\t\t\tformat: \"json\",\n\t\t\t\t\t\tnojsoncallback: 1\n\t\t\t\t\t})\n\t\t\t\t).then(function(response){\n\t\t\t\t    return response.json();\n\t\t\t\t}).then(function(responseJSON){\n\t\t\t\t    return responseJSON.places.place[0];\n\t\t\t\t}).then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showEnableGeoLocationMessage(){\n        return !this.geoLocation && !this.geoLocationError;\n    },\n\tlocation: \"string\",\n\tget placesPromise() {\n\t\tif (this.location && this.location.length > 2) {\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from geo.places where text=\"' + this.location + '\"',\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(data);\n\t\t\t\tif (Array.isArray(data.query.results.place)) {\n\t\t\t\t\treturn data.query.results.place;\n\t\t\t\t} else {\n\t\t\t\t\treturn [data.query.results.place];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tplaces: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tif (this.placesPromise) {\n\t\t\t\tthis.placesPromise.then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showPlacePicker() {\n\t\treturn !this.place && this.places && this.places.length > 1;\n\t},\n\tplace: {\n\t\tstream: function(setStream) {\n\t\t\tvar resetStream = this.toStream(\".location\").map(function() {\n\t\t\t\treturn null;\n\t\t\t});\n            var onePlaceResultStream = this.toStream(\".places\").map(function(places){\n                if(places.length === 1) {\n                    return places[0];\n                } else {\n                    return null;\n                }\n            });\n\n\t\t\treturn onePlaceResultStream\n\t\t\t\t.merge(setStream)\n\t\t\t\t.merge(resetStream)\n                .merge(this.toStream(\".geoPlace\"));\n\t\t}\n\t},\n\tpickPlace: function(place) {\n\t\tthis.place = place;\n\t},\n\tget forecastPromise() {\n\t\tif (this.place) {\n            console.log(\"place\", this.place);\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from weather.forecast where woeid=' + this.place.woeid,\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(\"forecast data\", data);\n\t\t\t\tvar forecast = data.query.results.channel.item.forecast;\n\n\t\t\t\treturn forecast;\n\t\t\t});\n\t\t}\n\t},\n\ttoClassName: function(text) {\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n\t}\n});\ncan.defineStreamKefir(WeatherViewModel);\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='61-63,only'></span>\nUpdate the __HTML__ tab:\n\n\n```html\nLatitude: {{geoLocation.coords.latitude}},\nLongitude: {{geoLocation.coords.longitude}},\nError: {{geoLocationError.message}}\n\n<div class=\"weather-widget\">\n  {{#if showEnableGeoLocationMessage}}\n    <p class=\"loading-message\">\n      Please Enable Location Services…\n    </p>\n  {{/if}}\n\n  <div class=\"location-entry\">\n    <label for=\"location\">Enter Your location:</label>\n    <input id=\"location\" value:to=\"location\" type=\"text\"/>\n  </div>\n\n  {{#if placesPromise.isPending}}\n    <p class=\"loading-message\">\n      Loading places…\n    </p>\n  {{/if}}\n\n  {{#if showPlacePicker}}\n    <div class=\"location-options\">\n      <label>Pick your place:</label>\n      <ul>\n        {{#each placesPromise.value}}\n          <li on:click=\"../pickPlace(this)\">{{name}}, {{admin1.content}},\n              {{country.code}} ({{placeTypeName.content}})</li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n  {{#if place}}\n    <div class=\"forecast\">\n      <h1>10 day {{place.name}} Weather Forecast</h1>\n      <ul>\n        {{#each forecastPromise.value}}\n          <li>\n            <span class='date'>{{date}}</span>\n            <span class='description {{toClassName(text)}}'>{{text}}</span>\n            <span class='high-temp'>{{high}}<sup>&deg;</sup></span>\n            <span class='low-temp'>{{low}}<sup>&deg;</sup></span>\n          </li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n</div>\n\n```\n<span line-highlight='6-10,only'></span>\n\n## Allow user to enter location only if location services failed\n\n### The problem\n\nShow the location entry `<div>` only when geo location has failed.\n\n### What you need to know\n\nNothing, you’ve learned it all by this point.  Apply what you know!\n\n### The solution\n\nUpdate the __JavaScript__ tab:\n\n\n```js\nvar yqlURL = \"https://query.yahooapis.com/v1/public/yql?\";\n\nvar geoLocationStream = Kefir.stream(function(emitter) {\n\tnavigator.geolocation.getCurrentPosition(function(position){\n\t  emitter.value(position);\n\t}, function(err){\n\t\tconsole.log(\"getCurrentPositionErr\",err);\n\t\temitter.error(err);\n\t});\n\n\n\t var watch = navigator.geolocation.watchPosition(function(position){\n\t   emitter.value(position);\n\t }, function(err){\n\t     emitter.error(err);\n     });\n\n\treturn function() {\n\t\tnavigator.geolocation.clearWatch(watch);\n\t};\n});\n\nvar WeatherViewModel = can.DefineMap.extend({\n\tgeoLocation: {\n\t\tstream: function() {\n\t\t\treturn geoLocationStream;\n\t\t}\n\t},\n    geoLocationError: {\n        stream: function() {\n\t\t\treturn geoLocationStream.withHandler(function(emitter, event){\n                if (event.type === 'end') {\n                    emitter.end();\n                }\n                if (event.type === 'error') {\n                    emitter.value(event.value);\n                }\n            });\n\t\t}\n    },\n\tgeoPlace: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tif (this.geoLocation) {\n\t\t\t\tfetch(\"https://api.flickr.com/services/rest/?\" +\n\t\t\t\t\tcan.param({\n\t\t\t\t\t\tmethod: \"flickr.places.findByLatLon\",\n\t\t\t\t\t\tapi_key: \"df0a221bb43ecbc2abb03426bd84e598\",\n\t\t\t\t\t\tlat: this.geoLocation.coords.latitude,\n\t\t\t\t\t\tlon: this.geoLocation.coords.longitude,\n\t\t\t\t\t\tformat: \"json\",\n\t\t\t\t\t\tnojsoncallback: 1\n\t\t\t\t\t})\n\t\t\t\t).then(function(response){\n\t\t\t\t    return response.json();\n\t\t\t\t}).then(function(responseJSON){\n\t\t\t\t    return responseJSON.places.place[0];\n\t\t\t\t}).then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showEnableGeoLocationMessage(){\n        return !this.geoLocation && !this.geoLocationError;\n    },\n\tget showEnterLocation(){\n        return !!this.geoLocationError;\n    },\n\tlocation: \"string\",\n\tget placesPromise() {\n\t\tif (this.location && this.location.length > 2) {\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from geo.places where text=\"' + this.location + '\"',\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(data);\n\t\t\t\tif (Array.isArray(data.query.results.place)) {\n\t\t\t\t\treturn data.query.results.place;\n\t\t\t\t} else {\n\t\t\t\t\treturn [data.query.results.place];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tplaces: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tif (this.placesPromise) {\n\t\t\t\tthis.placesPromise.then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showPlacePicker() {\n\t\treturn !this.place && this.places && this.places.length > 1;\n\t},\n\tplace: {\n\t\tstream: function(setStream) {\n\t\t\tvar resetStream = this.toStream(\".location\").map(function() {\n\t\t\t\treturn null;\n\t\t\t});\n            var onePlaceResultStream = this.toStream(\".places\").map(function(places){\n                if(places.length === 1) {\n                    return places[0];\n                } else {\n                    return null;\n                }\n            });\n\n\t\t\treturn onePlaceResultStream\n\t\t\t\t.merge(setStream)\n\t\t\t\t.merge(resetStream)\n                .merge(this.toStream(\".geoPlace\"));\n\t\t}\n\t},\n\tpickPlace: function(place) {\n\t\tthis.place = place;\n\t},\n\tget forecastPromise() {\n\t\tif (this.place) {\n            console.log(\"place\", this.place);\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from weather.forecast where woeid=' + this.place.woeid,\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(\"forecast data\", data);\n\t\t\t\tvar forecast = data.query.results.channel.item.forecast;\n\n\t\t\t\treturn forecast;\n\t\t\t});\n\t\t}\n\t},\n\ttoClassName: function(text) {\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n\t}\n});\ncan.defineStreamKefir(WeatherViewModel);\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='64-66,only'></span>\nUpdate the __HTML__ tab:\n\n\n```html\nLatitude: {{geoLocation.coords.latitude}},\nLongitude: {{geoLocation.coords.longitude}},\nError: {{geoLocationError.message}}\n\n<div class=\"weather-widget\">\n  {{#if showEnableGeoLocationMessage}}\n    <p class=\"loading-message\">\n      Please Enable Location Services…\n    </p>\n  {{/if}}\n\n  {{#if showEnterLocation}}\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" value:to=\"location\" type=\"text\"/>\n    </div>\n  {{/if}}\n\n  {{#if placesPromise.isPending}}\n    <p class=\"loading-message\">\n      Loading places…\n    </p>\n  {{/if}}\n\n  {{#if showPlacePicker}}\n    <div class=\"location-options\">\n      <label>Pick your place:</label>\n      <ul>\n        {{#each placesPromise.value}}\n          <li on:click=\"../pickPlace(this)\">{{name}}, {{admin1.content}},\n              {{country.code}} ({{placeTypeName.content}})</li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n  {{#if place}}\n    <div class=\"forecast\">\n      <h1>10 day {{place.name}} Weather Forecast</h1>\n      <ul>\n        {{#each forecastPromise.value}}\n          <li>\n            <span class='date'>{{date}}</span>\n            <span class='description {{toClassName(text)}}'>{{text}}</span>\n            <span class='high-temp'>{{high}}<sup>&deg;</sup></span>\n            <span class='low-temp'>{{low}}<sup>&deg;</sup></span>\n          </li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n</div>\n\n```\n<span line-highlight='12,17,only'></span>\n## Result\n\nWhen finished, you should see something like the following JS Bin:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/jipevu/3/embed?html,js,output\">JS Bin on jsbin.com</a>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.0\"></script>\n\n",
    "description": "This guides you through extending the [guides/recipes/weather-report-simple Simple Weather Report Guide] to remove imperative code and automatically look up the user’s location using the\nbrowser’s [geolocation API](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation).  Both of these will be done with event streams.\n\nThis guide continues where the [guides/recipes/weather-report-simple Simple Weather Report Guide] left off.  It takes about 25 minutes to complete.  It was written with CanJS 3.8.\n\n",
    "name": "guides/recipes/weather-report-advanced",
    "title": "Weather Report Guide (Advanced)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes/weather-report-simple": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/weather-report/weather-report.md"
    },
    "body": "\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/vujugel/3/embed?html,js,output\">JS Bin on jsbin.com</a>\n\nTo use the widget:\n\n1. __Enter__ a location (example: _Chicago_)\n2. If the location name isn’t unique, __click__ on the intended location.\n3. See the 10-day forecast for your selected city.\n\n__Start this tutorial by cloning the following JS Bin__:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/fudakiz/1/embed?html,output\">JS Bin on jsbin.com</a>\n\nThis JS Bin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\nThe following sections are broken down into:\n\n- Problem — A description of what the section is trying to accomplish.\n- Things to know — Information about CanJS that is useful for solving the problem.\n- Solution — The solution to the problem.\n\n\n## Setup\n\n### The problem\n\nGet the basic setup for a CanJS app (in a JS Bin) setup by:\n\n1.  Creating a template that outputs the pre-constructed HTML.\n2.  Defining a `WeatherViewModel` constructor function.\n3.  Rendering the template with an instance of `WeatherViewModel`.\n4.  Inserting the result of the rendered template into the page.\n\n### Things to know\n\n- A [can-stache] template is used to render data into a document fragment:\n\n  ```js\n  var template = can.stache(\"<h1>{{message}}</h1>\");\n  var frag = template({message: \"Hello World\"});\n  frag //-> <h1>Hello World</h1>\n  ```\n\n- [can-define/map/map can.DefineMap] can be used to define the behavior of observable objects like:\n\n  ```js\n  var Type = can.DefineMap.extend({\n\t  message: \"string\"\n  });\n  ```\n\n- Instances of these [can-define/map/map can.DefineMap] types are often used\n  as a ViewModel that controls the behavior of a [can-stache] template (or\n  [can-component]).\n\n  ```js\n  var MessageViewModel = can.DefineMap.extend({\n\t  message: \"string\"\n  });\n\n  var messageVM = new MessageViewModel();\n  var frag = template(messageVM)\n  ```\n\n### The solution\n\nUpdate the __HTML__ tab to wrap the template in a `script` tag:\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  <div class=\"weather-widget\">\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" type='text'/>\n    </div>\n\n    <p class=\"loading-message\">\n      Loading places…\n    </p>\n\n    <div class=\"location-options\">\n      <label>Pick your place:</label>\n      <ul>\n        <li>Some Place</li>\n        <li>Another Place</li>\n      </ul>\n    </div>\n\n    <div class=\"forecast\">\n      <h1>10-day Chicago Weather Forecast</h1>\n      <ul>\n        <li>\n          <span class='date'>Today</span>\n          <span class='description scattered-showers'>Scattered Showers</span>\n          <span class='high-temp'>100<sup>&deg;</sup></span>\n          <span class='low-temp'>-10<sup>&deg;</sup></span>\n        </li>\n      </ul>\n    </div>\n  </div>\n</script>\n```\n<span line-highlight='1,32,only'></span>\nUpdate the __JavaScript__ tab to:\n\n- Define a ViewModel.\n- Create an instance of the ViewModel .\n- Load the `app-template` template.\n- Render the template with the ViewModel instance.\n- Insert the rendered result into the page.\n\n```js\nvar WeatherViewModel = can.DefineMap.extend({\n\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='1-9'></span>\n## Allow a user to enter a location\n\n### The problem\n\nWe want an `input` element to:\n\n- Allow a person to type a location to search for weather.\n- Show the user the location they typed.\n\n### Things to know\n\n- There are [can-define.types.propDefinition many ways] to define a property on\n  a `DefineMap`.  The simplest way is `propName: \"<TYPE>\"` like:\n\n  ```js\n  DefineMap.extend({\n    property: \"string\"\t  \n  })\n  ```\n- The [can-stache-bindings.toParent] can set an input’s `value` to\n  a ViewModel property like:\n\n  ```html\n  <input value:to=\"property\"/>\n  ```\n\n- A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] magic tags to insert data into\n  the HTML output like:\n\n  ```html\n  {{property}}\n  ```\n\n### The solution\n\nUpdate the __JavaScript__ tab to define a `location` property as a string.\n\n```js\nvar WeatherViewModel = can.DefineMap.extend({\n  location: \"string\"\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='2'></span>\nUpdate the template in the __HTML__ tab to:\n\n1. Update `location` on the ViewModel when the input changes.\n2. Show value of the ViewModel’s `location` property.\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  <div class=\"weather-widget\">\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" value:to=\"location\" type=\"text\"/>\n    </div>\n\n    <p class=\"loading-message\">\n      Loading places…\n    </p>\n\n    <div class=\"location-options\">\n      <label>Pick your place:</label>\n      <ul>\n        <li>Some Place</li>\n        <li>Another Place</li>\n      </ul>\n    </div>\n\n    <div class=\"forecast\">\n      <h1>10-day {{location}} Weather Forecast</h1>\n      <ul>\n        <li>\n          <span class='date'>Today</span>\n          <span class='description scattered-showers'>Scattered Showers</span>\n          <span class='high-temp'>100<sup>&deg;</sup></span>\n          <span class='low-temp'>-10<sup>&deg;</sup></span>\n        </li>\n      </ul>\n    </div>\n  </div>\n</script>\n```\n<span line-highlight='5,21,only'></span>\n## Get and display the places for the user’s location name\n\n### The problem\n\nOnce the user has entered a location name, we need to get which\n“place” it is.  For example, a user might enter Paris, but we don’t know if\nthey mean the Paris in France or the one in Illinois.  We need to get a\nlist of matching places for the location name and display the matching places\non the page.\n\n### Things to know\n\n- [ES5 Getter Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) can\n  be used to define a `DefineMap` property that changes when another property changes.  For example,\n  the following defines an `excitedMessage` property that always has a `!` after the `message` property:\n\n  ```js\n  DefineMap.extend({\n    message: \"string\",\n    get excitedMessage(){\n      return this.message+\"!\";\n    }\n  });\n  ```\n\n- [YQL](https://developer.yahoo.com/yql/console/) provides a service endpoint for\n  retrieving a list of places that match some text.  For example, the following requests all\n  places that match `Paris`:\n\n  ```\n  https://query.yahooapis.com/v1/public/yql?\n    format=json&\n\tq=select * from geo.places where text=\"Paris\"\n  ```\n\n  The list of matched places will be in the response data’s `data.query.results.place` property.\n  If there is only a single match, `place` will be an object instead of an array.\n\n- The [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) is an easy way to make requests\n  to a URL and get back JSON.  Use it like:\n\n  ```js\n  fetch(url).then(function(response){\n\t  return response.json();\n  }).then(function(data){\n\n  });\n  ```\n\n- [can-util/js/param/param can.param] is able to convert an object into a\n  query string format like:\n\n  ```js\n  can.param({format: \"json\", q: \"select\"}) //-> \"format=json&q=select\"\n  ```  \n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n- Use [can-stache.helpers.each {{#each value}}] to do looping in `can-stache`.\n- `Promise`s are observable in [can-stache].  Given a promise `somePromise`, you can:\n  - Check if the promise is loading like: `{{#if somePromise.isPending}}`.\n  - Loop through the resolved value of the promise like: `{{#each somePromise.value}}`.\n\n\n### The solution\n\n1. Show a “Loading places…” message while we wait on data.\n2. Once the places are resolved, list each place’s name, state, country and type.\n\nUpdate the template in the __HTML__ tab to:\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  <div class=\"weather-widget\">\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" value:to=\"location\" type=\"text\"/>\n    </div>\n\n    {{#if placesPromise.isPending}}\n      <p class=\"loading-message\">\n        Loading places…\n      </p>\n    {{/if}}\n\n    {{#if placesPromise.isResolved}}\n      <div class=\"location-options\">\n        <label>Pick your place:</label>\n        <ul>\n          {{#each placesPromise.value}}\n            <li>\n              {{name}}, {{admin1.content}}, {{country.code}} ({{placeTypeName.content}})\n            </li>\n          {{/each}}\n        </ul>\n      </div>\n    {{/if}}\n\n    <div class=\"forecast\">\n      <h1>10-day {{location}} Weather Forecast</h1>\n      <ul>\n        <li>\n          <span class='date'>Today</span>\n          <span class='description scattered-showers'>Scattered Showers</span>\n          <span class='high-temp'>100<sup>&deg;</sup></span>\n          <span class='low-temp'>-10<sup>&deg;</sup></span>\n        </li>\n      </ul>\n    </div>\n  </div>\n</script>\n```\n<span line-highlight='8,12,14,18,19,20,21,22,25,only'></span>\nUpdate the __JavaScript__ tab to:\n\n1. Define a `placesPromise` property that will represent the loading places.\n2. If the user has typed in at least two characters, we fetch the matching places.\n3. If only a single place is returned, we still convert it into an array so the data\n   stays consistent.  \n\n```js\nvar yqlURL = \"//query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n  location: \"string\",\n  get placesPromise(){\n    if(this.location && this.location.length > 2) {\n      return fetch(\n        yqlURL +\n        can.param({\n          q: 'select * from geo.places where text=\"'+this.location+'\"',\n          format: \"json\"\n        })\n      ).then(function(response){\n        return response.json();\n      }).then(function(data){\n        console.log(data);\n        if(Array.isArray(data.query.results.place)) {\n          return data.query.results.place;\n        } else {\n          return [data.query.results.place];\n        }\n      });\n    }\n  }\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='1,5-24,only'></span>\n## Allow a user to select a place\n\n### The problem\n\nWhen a user clicks on a place, we need to indicate their selection.\n\n### Things to know\n\n- Use [can-stache-bindings.event (on:EVENT)] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `sayHi()` when the `<div>` is clicked.\n\n   ```html\n   <div on:click=\"sayHi()\"> … </div>\n   ```\n\n- `this` in a stache template refers to the current context of a template or section.  \n\n  For example, the `this` in `this.name` refers to the `context` object:\n\n  ```javascript\n  var template = stache(\"{{this.name}}\");\n  var context = {name: \"Justin\"};\n  template(context);\n  ```\n\n  Or, when looping through a list of items, `this` refers to each item:\n\n  ```html\n  {{#each items}}\n    <li>{{this.name}}</li> <!-- this is each item in items -->\n  {{/each}}\n  ```\n\n\n- The [can-define.types “any” type] can be used to define a property as\n  accepting any data type like:\n\n  ```js\n  var MessageViewModel = can.DefineMap.extend({\n\t  message: \"string\",\n\t  metaData: \"any\"\n  })\n  ```\n\n- `can.DefineMap` can also have methods:\n\n  ```js\n  var MessageViewModel = can.DefineMap.extend({\n\t  message: \"string\",\n\t  metaData: \"any\",\n\t  sayHi: function(){\n\t    this.message = \"Hello\";\n\t  }\n  });\n  ```\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n1. When a `<li>` is clicked on, call `pickPlace` with the corresponding `place`.\n2. When a `place` has been set, write out the forecast header.\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  <div class=\"weather-widget\">\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" value:to=\"location\" type=\"text\"/>\n    </div>\n\n    {{#if placesPromise.isPending}}\n      <p class=\"loading-message\">\n        Loading places…\n      </p>\n    {{/if}}\n\n    {{#if placesPromise.isResolved}}\n      <div class=\"location-options\">\n        <label>Pick your place:</label>\n        <ul>\n          {{#each placesPromise.value}}\n            <li on:click=\"../pickPlace(this)\">\n              {{name}}, {{admin1.content}}, {{country.code}} ({{placeTypeName.content}})\n            </li>\n          {{/each}}\n        </ul>\n      </div>\n    {{/if}}\n\n    {{#if place}}\n      <div class=\"forecast\">\n        <h1>10-day {{place.name}} Weather Forecast</h1>\n        <ul>\n          <li>\n            <span class='date'>Today</span>\n            <span class='description scattered-showers'>Scattered Showers</span>\n            <span class='high-temp'>100<sup>&deg;</sup></span>\n            <span class='low-temp'>-10<sup>&deg;</sup></span>\n          </li>\n        </ul>\n      </div>\n    {{/if}}\n  </div>\n</script>\n```\n<span line-highlight='19,27,29,39,only'></span>\nUpdate the __JavaScript__ tab to:\n\n1.  Define a `place` property as taking any data type.\n2.  Define a `pickPlace` method that sets the place property.\n\n```js\nvar yqlURL = \"//query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n  location: \"string\",\n  get placesPromise(){\n    if(this.location && this.location.length > 2) {\n\t  return fetch(\n\t\t  yqlURL+\n\t\t  can.param({\n\t        q: 'select * from geo.places where text=\"'+this.location+'\"',\n\t        format: \"json\"\n\t      })\n\t  ).then(function(response){\n\t\t  return response.json();\n\t  }).then(function(data){\n\t\t  console.log(data);\n          if(Array.isArray(data.query.results.place)) {\n            return data.query.results.place;\n          } else {\n            return [data.query.results.place];\n          }\n\t  });\n    }\n  },\n  place: \"any\",\n  pickPlace: function(place){\n    this.place = place;\n  }\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='25-28,only'></span>\n## Get and display the forecast\n\n### The problem\n\nOnce we’ve selected a place, we need to get and display the forecast data for the\nselected place.  \n\n### Things to know\n\n- ViewModel methods can be [can-stache/expressions/call called] within a [can-stache] template like:\n\n  ```\n  {{myMethod(someValue)}}\n  ```\n\n- [YQL](https://developer.yahoo.com/yql/console/) provides a service endpoint for\n  retrieving a forecast that matches a `place`’s `woeid`.  For example, the following requests the forecast\n  for Paris, France’s `woeid`:\n\n  ```\n  https://query.yahooapis.com/v1/public/yql?\n    format=json&\n\tq=select * from weather.forecast where woeid=615702\n  ```\n\n- The stylesheet includes icons for classNames that match: `sunny`, `mostly-cloudy`, `scattered-thunderstorms`, etc.\n\n### The solution\n\nUpdate the template in the __HTML__ tab to:\n\n1. Display each forecast day’s details (date, text, high, and low).\n2. Use the `toClassName` method to convert the forecast’s `text` into a `className` value that\n   will be matched by the stylesheet.\n\n ```html\n <script id=\"app-template\" type=\"text/stache\">\n   <div class=\"weather-widget\">\n     <div class=\"location-entry\">\n       <label for=\"location\">Enter Your location:</label>\n       <input id=\"location\" value:to=\"location\" type=\"text\"/>\n     </div>\n\n     {{#if placesPromise.isPending}}\n       <p class=\"loading-message\">\n         Loading places…\n       </p>\n     {{/if}}\n\n     {{#if placesPromise.isResolved}}\n       <div class=\"location-options\">\n         <label>Pick your place:</label>\n         <ul>\n           {{#each placesPromise.value}}\n             <li on:click=\"../pickPlace(this)\">\n               {{name}}, {{admin1.content}}, {{country.code}} ({{placeTypeName.content}})\n             </li>\n           {{/each}}\n         </ul>\n       </div>\n     {{/if}}\n\n     {{#if place}}\n       <div class=\"forecast\">\n         <h1>10-day {{place.name}} Weather Forecast</h1>\n         <ul>\n           {{#each forecastPromise.value}}\n             <li>\n               <span class='date'>{{date}}</span>\n               <span class='description {{toClassName(text)}}'>{{text}}</span>\n               <span class='high-temp'>{{high}}<sup>&deg;</sup></span>\n               <span class='low-temp'>{{low}}<sup>&deg;</sup></span>\n             </li>\n           {{/each}}\n         </ul>\n       </div>\n     {{/if}}\n   </div>\n </script>\n ```\n<span line-highlight='31,33,34,35,36,38,only'></span>\nUpdate the __JavaScript__ tab to:\n\n1. Define a `forecastPromise` property that gets a list of promises.\n2. Define a `toClassName` method that lowercases and hyphenates any text passed in.\n\n```js\nvar yqlURL = \"//query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n  location: \"string\",\n  get placesPromise(){\n    if(this.location && this.location.length > 2) {\n\t  return fetch(\n\t\t  yqlURL+\n\t\t  can.param({\n\t        q: 'select * from geo.places where text=\"'+this.location+'\"',\n\t        format: \"json\"\n\t      })\n\t  ).then(function(response){\n\t\t  return response.json();\n\t  }).then(function(data){\n\t\t  console.log(data);\n          if(Array.isArray(data.query.results.place)) {\n            return data.query.results.place;\n          } else {\n            return [data.query.results.place];\n          }\n\t  });\n    }\n  },\n  place: \"any\",\n  pickPlace: function(place){\n    this.place = place;\n  },\n  get forecastPromise(){\n    if( this.place ) {\n\t  return fetch(\n  \t\t  yqlURL+\n  \t\t  can.param({\n  \t        q: 'select * from weather.forecast where woeid='+this.place.woeid,\n  \t        format: \"json\"\n  \t      })\n  \t  ).then(function(response){\n  \t\t  return response.json();\n  \t  }).then(function(data){\n        console.log(\"forecast data\", data);\n        var forecast = data.query.results.channel.item.forecast;\n\n        return forecast;\n      });\n    }\n  },\n  toClassName: function(text){\n\treturn text.toLowerCase().replace(/ /g, \"-\");\n  }\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='29-49,only'></span>\n## Hide the forecast if the user changes the entered location\n\n### The problem\n\nCurrently, if the user changes the entered location, the weather forecast for the\nother city is still visible.  Let’s hide it!\n\n### Things to know\n\n- `DefineMap` [can-define.types.set setter]'s can be used to add behavior when a property is set like:\n\n  ```js\n  var MessageViewModel = can.DefineMap.extend({\n    message: {\n\t  type: \"string\",\n\t  set: function(){\n\t    this.metaData = null;\n\t  }\n\t},\n    metaData: \"any\",\n  });\n  ```\n\n### The solution\n\nUpdate the __JavaScript__ tab to set the `place` property to null when the `location` changes.\n\n```js\nvar yqlURL = \"//query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n  location: {\n    type: \"string\",\n    set: function(){\n      this.place = null;\n    }\n  },\n  get placesPromise(){\n    if(this.location && this.location.length > 2) {\n\t  return fetch(\n\t\t  yqlURL+\n\t\t  can.param({\n\t        q: 'select * from geo.places where text=\"'+this.location+'\"',\n\t        format: \"json\"\n\t      })\n\t  ).then(function(response){\n\t\t  return response.json();\n\t  }).then(function(data){\n\t\t  console.log(data);\n          if(Array.isArray(data.query.results.place)) {\n            return data.query.results.place;\n          } else {\n            return [data.query.results.place];\n          }\n\t  });\n    }\n  },\n  place: \"any\",\n  pickPlace: function(place){\n    this.place = place;\n  },\n  get forecastPromise(){\n    if( this.place ) {\n\t  return fetch(\n  \t\t  yqlURL+\n  \t\t  can.param({\n  \t        q: 'select * from weather.forecast where woeid='+this.place.woeid,\n  \t        format: \"json\"\n  \t      })\n  \t  ).then(function(response){\n  \t\t  return response.json();\n  \t  }).then(function(data){\n        console.log(\"forecast data\", data);\n        var forecast = data.query.results.channel.item.forecast;\n\n        return forecast;\n      });\n    }\n  },\n  toClassName: function(text){\n\treturn text.toLowerCase().replace(/ /g, \"-\");\n  }\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='4-9,only'></span>\n## Skip selecting a place if only one place matches the entered location\n\n### The problem\n\nIf a single place is returned for the entered location, we can skip asking the\nuser to select their place; instead, we should show the forecast immediately.  \n\n### Things to know\n\n- `can.DefineMap` [can-define.types.get getters] are passed their last set value.  This way, the\n  property can be derived from either the set value or other properties.\n\n  ```js\n  var MessageVM = can.DefineMap.extend({\n    username: \"string\",\n    message: {\n      get: function(lastSet) {\n        if(lastSet) {\n          return lastSet;\n        } else {\n          return \"Hello \"+this.username;\n        }\n      }\n    }\n  });\n\n  var messageVM = new MessageVM({username: \"Hank\"});\n  messageVM.message //-> \"Hello Hank\";\n\n  messageVM.message = \"Welcome to Earth\";\n  messageVM.message //-> \"Welcome to Earth\"\n  ```\n\n- Use [can-define.types.get asynchronous getters] to derive data from asynchronous sources.  For example:\n\n  ```js\n  var MessageVM = can.DefineMap.extend({\n    messageId: \"string\",\n    message: {\n      get: function(lastSet, resolve) {\n        fetch(\"/message/\"+this.messageId)\n        .then(function(response){\n          return response.json();\n        }).then(resolve);\n      }\n    }\n  });\n  ```\n\n### The solution\n\nUpdate the template in the __HTML__ tab to use a `showPlacePicker` property to determine if we should show the `place` picker list.\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  <div class=\"weather-widget\">\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" value:to=\"location\" type=\"text\"/>\n    </div>\n\n    {{#if placesPromise.isPending}}\n      <p class=\"loading-message\">\n        Loading places…\n      </p>\n    {{/if}}\n\n    {{#if placesPromise.isResolved}}\n      {{#if showPlacePicker}}\n        <div class=\"location-options\">\n          <label>Pick your place:</label>\n          <ul>\n            {{#each placesPromise.value}}\n              <li on:click=\"../pickPlace(this)\">\n                {{name}}, {{admin1.content}}, {{country.code}} ({{placeTypeName.content}})\n              </li>\n            {{/each}}\n          </ul>\n        </div>\n      {{/if}}\n    {{/if}}\n\n    {{#if place}}\n      <div class=\"forecast\">\n        <h1>10-day {{place.name}} Weather Forecast</h1>\n        <ul>\n          {{#each forecastPromise.value}}\n            <li>\n              <span class='date'>{{date}}</span>\n              <span class='description {{toClassName(text)}}'>{{text}}</span>\n              <span class='high-temp'>{{high}}<sup>&deg;</sup></span>\n              <span class='low-temp'>{{low}}<sup>&deg;</sup></span>\n            </li>\n          {{/each}}\n        </ul>\n      </div>\n    {{/if}}\n  </div>\n</script>\n```\n<span line-highlight='15,26,only'></span>\nUpdate the __JavaScript__ tab to:\n\n1. Define a `places` property that will have the places list returned by the `YQL` service.\n2. Define a `showPlacePicker` property that is true if there’s more than one place in `places` and\n   the `place` property hasn’t been set yet.\n3. Update the `place` property to default to the first item in `places` if there is only one item.\n\n```js\nvar yqlURL = \"//query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n  location: {\n    type: \"string\",\n    set: function(){\n      this.place = null;\n    }\n  },\n  get placesPromise(){\n    if(this.location && this.location.length > 2) {\n\t  return fetch(\n\t\t  yqlURL+\n\t\t  can.param({\n\t        q: 'select * from geo.places where text=\"'+this.location+'\"',\n\t        format: \"json\"\n\t      })\n\t  ).then(function(response){\n\t\t  return response.json();\n\t  }).then(function(data){\n\t\t  console.log(data);\n          if(Array.isArray(data.query.results.place)) {\n            return data.query.results.place;\n          } else {\n            return [data.query.results.place];\n          }\n\t  });\n    }\n  },\n  places: {\n    get: function(lastSet, resolve) {\n      if(this.placesPromise) {\n        this.placesPromise.then(resolve)\n      }\n    }\n  },\n  get showPlacePicker(){\n    return !this.place && this.places && this.places.length > 1;\n  },\n  place: {\n    type: \"any\",\n    get: function(lastSet){\n      if(lastSet) {\n        return lastSet;\n      } else {\n        if(this.places && this.places.length === 1) {\n          return this.places[0];\n        }\n      }\n    }\n  },\n  pickPlace: function(place){\n    this.place = place;\n  },\n  get forecastPromise(){\n    if( this.place ) {\n\t  return fetch(\n  \t\t  yqlURL+\n  \t\t  can.param({\n  \t        q: 'select * from weather.forecast where woeid='+this.place.woeid,\n  \t        format: \"json\"\n  \t      })\n  \t  ).then(function(response){\n  \t\t  return response.json();\n  \t  }).then(function(data){\n        console.log(\"forecast data\", data);\n        var forecast = data.query.results.channel.item.forecast;\n\n        return forecast;\n      });\n    }\n  },\n  toClassName: function(text){\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n  }\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='30-51,only'></span>\n## Result\n\nWhen finished, you should see something like the following JS Bin:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/vujugel/3/embed?js,output\">JS Bin on jsbin.com</a>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.4\"></script>\n\n",
    "description": "This guide walks you through building a simple weather report widget.  It takes about 25 minutes to complete.  It was written with\nCanJS 3.5.\n\n",
    "name": "guides/recipes/weather-report-simple",
    "title": "Weather Report Guide (Simple)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "can-util/dom/events/attributes/attributes": {
    "type": "module",
    "name": "can-util/dom/events/attributes/attributes",
    "params": [
      {
        "name": "eventName",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 12,
      "codeLine": 33,
      "path": "node_modules/can-util/dom/events/attributes/attributes.js"
    },
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/attributes/attributes\");\nvar el = document.createElement(\"div\");\n\nfunction attributesHandler() {\n\tconsole.log(\"attributes event fired\");\n}\n\nevents.addEventListener.call(el, \"attributes\", attributesHandler, false);\n\nevents.removeEventListener.call(el, \"attributes\", attributesHandler);\n```\n\n",
    "description": "\nAdds a listenable \"attributes\" event to DOM nodes, which fires when\nthe node's attributes change.\n",
    "title": "attributes",
    "types": [
      {
        "type": "events"
      }
    ]
  },
  "can-util/dom/events/delegate/delegate": {
    "type": "module",
    "name": "can-util/dom/events/delegate/delegate",
    "params": [
      {
        "name": "ev",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 17,
      "codeLine": 43,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/delegate/delegate\");\nvar el = document.createElement(\"div\");\nvar sub = document.createElement(\"div\");\nsub.className = \"foo\"\nel.appendChild(sub);\n\nfunction delegateEventsHandler() {\n\tconsole.log(\"delegate event fired\");\n}\n\nevents.addDelegateListener.call(el, \"click\", \".foo\", delegateEventsHandler, false);\n\nevents.removeDelegateListener.call(el, \"click\", \".foo\", delegateEventsHandler);\n```\n\n",
    "description": "\nAdd delegate listeners to DOM events.  Delegated listeners use a selector on an\nancestor element to determine when to fire the event for an item.  This can help\ncases where large numbers of similar DOM nodes are added into a DOM subtree, since\nevent handlers do not have to be attached to each new node.\n",
    "title": "delegateEvents",
    "types": [
      {
        "type": "events"
      }
    ]
  },
  "can-util/dom/events/delegate/delegate.addDelegateListener": {
    "type": "function",
    "name": "can-util/dom/events/delegate/delegate.addDelegateListener",
    "parent": "can-util/dom/events/delegate/delegate",
    "src": {
      "line": 96,
      "codeLine": 109,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "",
    "description": "",
    "title": "events.addDelegateListener",
    "signatures": [
      {
        "code": "events.addDelegateListener(eventType, selector, handler)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of the event to virtually bind to delegates"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "A CSS selector that matches all intended delegates"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The function to call when the event is dispatched\n\nAdd an event as in [can-util/dom/events/events.addEventListener addEventListener] but with a selector\nmatching child nodes (\"delegates\") for which the event should fire.\n\nDelegate events are limited to firing in the bubble phase.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The function to call when the event is dispatched\n\nAdd an event as in [can-util/dom/events/events.addEventListener addEventListener] but with a selector\nmatching child nodes (\"delegates\") for which the event should fire.\n\nDelegate events are limited to firing in the bubble phase.\n"
    }
  },
  "can-util/dom/events/delegate/delegate.removeDelegateListener": {
    "type": "function",
    "name": "can-util/dom/events/delegate/delegate.removeDelegateListener",
    "parent": "can-util/dom/events/delegate/delegate",
    "src": {
      "line": 136,
      "codeLine": 146,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "",
    "description": "",
    "title": "events.removeDelegateListener",
    "signatures": [
      {
        "code": "events.removeDelegateListener(eventType, selector, handler)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of the event to unbind"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "A CSS selector that matches a delegate selector added for this event type"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The function bound as handler when the listener was added\n\nRemove a delegated event added by in [can-util/dom/delegate/delegate.addDelegateListener addDelegateListener]\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The function bound as handler when the listener was added\n\nRemove a delegated event added by in [can-util/dom/delegate/delegate.addDelegateListener addDelegateListener]\n"
    }
  },
  "can-util/dom/events/enter/enter": {
    "src": {
      "line": 5,
      "codeLine": 28,
      "path": "node_modules/can-util/dom/events/enter/enter.js"
    },
    "type": "module",
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nvar input = document.createElement(\"input\");\n\nfunction enterEventHandler() {\n\tconsole.log(\"enter key pressed\");\n}\n\nevents.addEventHandler.call(input, \"enter\", enterEventHandler);\nevents.dispatch.call(input, {\n  type: 'keyup',\n  keyCode: keyCode\n});\n\n\n\n",
    "description": "\nWatches for when enter keys are pressed on a given element\n",
    "title": "enter",
    "types": [
      {
        "type": "events"
      }
    ],
    "name": "can-util/dom/events/enter/enter",
    "parent": "can-util/dom/events/events"
  },
  "can-util/dom/events/radiochange/radiochange": {
    "src": {
      "line": 5,
      "codeLine": 28,
      "path": "node_modules/can-util/dom/events/radiochange/radiochange.js"
    },
    "type": "module",
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/radiochange/radiochange\");\nvar el = document.createElement(\"div\");\n\nfunction radiochangeHandler() {\n\tconsole.log(\"radiochange event fired\");\n}\n\nevents.addEventListener.call(el, \"radiochange\", radiochangeHandler, false);\n\nevents.removeEventListener.call(el, \"radiochange\", radiochangeHandler);\n```\n\n",
    "description": "\nAdds a listenable \"radiochange\" event to DOM nodes, which fires when\nany radio input changes.\n",
    "hide": true,
    "title": "radiochange",
    "types": [
      {
        "type": "events"
      }
    ],
    "name": "can-util/dom/events/radiochange/radiochange",
    "parent": "can-util/dom/events/events"
  },
  "can-util/dom/events/removed/removed": {
    "src": {
      "line": 4,
      "codeLine": 22,
      "path": "node_modules/can-util/dom/events/removed/removed.js"
    },
    "type": "module",
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/removed/removed\");\n\nvar foo = document.createElement(\"div\");\ndocument.body.appendChild(foo);\n\nvar log = function() { console.log(\"removed event fired\"); }\nevents.addEventListener.call(foo, \"removed\", log);\n\ndocument.body.removeChild(foo); // remove event fired\n\n",
    "description": " \nThis event fires when the bound element is detached or destroyed.\n",
    "title": "removed",
    "types": [
      {
        "type": "events"
      }
    ],
    "name": "can-util/dom/events/removed/removed",
    "parent": "can-util/dom/events/events"
  },
  "can-util/dom/events/inserted/inserted": {
    "src": {
      "line": 4,
      "codeLine": 21,
      "path": "node_modules/can-util/dom/events/inserted/inserted.js"
    },
    "type": "module",
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/inserted/inserted\");\n\nvar foo = document.createElement(\"div\");\n\nvar log = function() { console.log(\"inserted event fired\"); }\nevents.addEventListener.call(foo, \"inserted\", log);\n\ndocument.body.appendChild(foo); // inserted event fired\n\n",
    "description": " \nThis event fires when the bound element is added to the DOM.\n",
    "title": "inserted",
    "types": [
      {
        "type": "events"
      }
    ],
    "name": "can-util/dom/events/inserted/inserted",
    "parent": "can-util/dom/events/events"
  },
  "can-util/dom/events/make-mutation-event/make-mutation-event": {
    "type": "module",
    "name": "can-util/dom/events/make-mutation-event/make-mutation-event",
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 16,
      "codeLine": 28,
      "path": "node_modules/can-util/dom/events/make-mutation-event/make-mutation-event.js"
    },
    "body": "",
    "description": "\n",
    "title": "makeMutationEvent",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeMutationEvent(specialEventName, mutationNodesProperty)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "specialEventName",
            "description": "the event to handle as a mutation observer-based event"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "mutationNodesProperty",
            "description": "the property of interest in a DOM mutation\n\nThis function provides a simple interface to bind the DOM events interface to the mutation\nobserver interface, by firing an event when a matching mutation is generated by the client\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "mutationNodesProperty",
      "description": "the property of interest in a DOM mutation\n\nThis function provides a simple interface to bind the DOM events interface to the mutation\nobserver interface, by firing an event when a matching mutation is generated by the client\n"
    }
  }
}