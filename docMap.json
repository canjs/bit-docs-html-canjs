{
  "steal-stache": {
    "src": {
      "path": "node_modules/steal-stache/steal-stache.md"
    },
    "body": "\n\n## Use\n\nWith [StealJS](https://stealjs.com) being used from `node_modules` like this:\n\n```html\n<script src=\"node_modules/steal/steal.js\"></script>\n```\n\nStart by installing `steal-stache` with npm:\n\n```shell\nnpm install steal-stache --save\n```\n\nThen add the plugins configuration to your `package.json`:\n\n```json\n{\n  ...\n  \"steal\": {\n    ...\n    \"plugins\": [\"steal-stache\"]\n  }\n}\n```\n\nNow you can load [can-stache] modules like this:\n\n```js\nimport todosStache from \"todos.stache\"\ntodosStache([{name: \"dishes\"}]) //-> <documentFragment>\n```\n\n## Specifying Dependencies\n\nThis plugin allows [can-view-import <can-import>] elements that specify\ntemplate dependencies:\n\n\n```\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\n",
    "description": "\nA [StealJS](http://stealjs.com) extension that allows stache templates as dependencies.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "steal-stache",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": [
            "steal-stache"
          ]
        },
        "parent": "steal-stache"
      },
      "bugs": {
        "url": "https://github.com/canjs/steal-stache/issues"
      },
      "dependencies": {
        "can-stache": "^3.0.13",
        "can-stache-bindings": "^3.0.5",
        "can-view-import": "^3.0.3",
        "jquery": "2.x - 3.x"
      },
      "description": "Load can-stache templates with StealJS",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-view-nodelist": "^3.0.2",
        "done-serve": "^0.2.5",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.6",
        "jshint": "^2.9.4",
        "steal": "^1.0.5",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.4.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "stealjs",
        "donejs"
      ],
      "main": "steal-stache.js",
      "name": "steal-stache",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/steal-stache.git"
      },
      "scripts": {
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release"
      },
      "system": {
        "main": "steal-stache",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ],
        "npmAlgorithm": "flat",
        "ext": {
          "stache": "steal-stache"
        }
      },
      "version": "3.0.7"
    },
    "signatures": [
      {
        "code": "STACHE_MODULE_NAME!steal-stache",
        "description": "\n\nImport a [can-stache stache] module in your code and use it to render.\n\n```js\nvar template = require(\"./main.stache\");\nvar Map = require(\"can-map\");\n\nvar map = new Map();\nvar frag = template(map);\n\n// frag is a live-bound DocumentFragment\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "name": "STACHE_MODULE_NAME",
            "description": "The module name of a stache template. This\nwill typically be something like `templates/main.stache`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A renderer function that will render the template into a document fragment.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "moduleName"
        }
      ],
      "name": "STACHE_MODULE_NAME",
      "description": "The module name of a stache template. This\nwill typically be something like `templates/main.stache`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A renderer function that will render the template into a document fragment.\n"
    },
    "comment": " "
  },
  "can-cid": {
    "name": "can-cid",
    "type": "module",
    "parent": "can-infrastructure",
    "src": {
      "line": 1,
      "codeLine": 26,
      "path": "node_modules/can-cid/can-cid.js"
    },
    "body": "",
    "description": "",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "cid(object, optionalObjectType)",
        "description": "\n\nGet a unique identifier for the object, optionally prefixed by a type name.\n\nOnce set, the unique identifier does not change, even if the type name\nchanges on subsequent calls.\n\n```js\nvar cid = require(\"can-cid\");\nvar x = {};\nvar y = {};\n\nconsole.log(cid(x, \"demo\")); // -> \"demo1\"\nconsole.log(cid(x, \"prod\")); // -> \"demo1\"\nconsole.log(cid(y));         // -> \"2\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "The object to uniquely identify."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "An optional type name with which to prefix the identifier\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the unique identifier\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "name",
      "description": "An optional type name with which to prefix the identifier\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the unique identifier\n"
    }
  },
  "Component": {
    "name": "Component",
    "type": "add",
    "description": "undefined\n"
  },
  "Component.static": {
    "src": {
      "line": 41,
      "codeLine": 45,
      "path": "node_modules/can-component/can-component.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "Component.static",
    "parent": "Component",
    "title": "static"
  },
  "Component.prototype": {
    "src": {
      "line": 121,
      "codeLine": 124,
      "path": "node_modules/can-component/can-component.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "Component.prototype",
    "parent": "Component",
    "title": "prototype"
  },
  "can-component": {
    "src": {
      "path": "node_modules/can-component/docs/component.md"
    },
    "body": "\n\n## Use\n\nTo create a Component, you must first [can-component.extend extend] `Component`\nwith the methods and properties of how your component behaves:\n\n```js\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\nvar HelloWorldVM = DefineMap.extend({\n    visible: {value: false},\n    message: {value: \"Hello There!\"}\n});\n\nComponent.extend({\n  tag: \"hello-world\",\n  view: stache(\"{{#if visible}}{{message}}{{else}}Click me{{/if}}\"),\n  ViewModel: HelloWorldVM,\n  events: {\n    click: function(){\n    \tthis.viewModel.visible = !this.viewModel.visible;\n    }\n  }\n});\n```\n\nThis element says “Click me” until a user clicks it and then\nsays “Hello There!”.  To create a a instance of this component on the page,\nadd `<hello-world/>` to a [can-stache] template, render\nthe template and insert the result in the page like:\n\n    var template = stache(\"<hello-world/>\");\n    document.body.appendChild(template({}));\n\nCheck this out here:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/click_me.html'></div>\n\n\nTypically, you do not append a single component at a time.  Instead,\nyou'll render a template with many custom tags like:\n\n    <srchr-app>\n      <srchr-search {models}=\"models\">\n        <input name=\"search\"/>\n      </srchr-search>\n      <ui-panel>\n        <srchr-history/>\n        <srchr-results {models}=\"models\"/>\n      </ui-panel>\n    </srchr-app>\n\n### Defining a Component\n\nUse [can-component.extend] to define a `Component` constructor function\nthat automatically gets initialized whenever the component’s tag is\nfound.\n\nNote that inheriting from components works differently than other CanJS APIs. You\ncan’t call `.extend` on a particular component to create a “subclass” of that component.\n\nInstead, components work more like HTML elements. To reuse functionality from a base component, build on top of it with parent\ncomponents that wrap other components in their template and pass any needed viewModel properties via attributes.\n\n### Tag\n\nA component’s [can-component::tag tag] is the element node name that\nthe component will be created on.\n\n\nThe following matches `<hello-world>` elements.\n\n    Component.extend({\n      tag: \"hello-world\"\n    });\n\n### View\n\nA component’s [can-component::view view] is a template that is rendered as\nthe element’s innerHTML.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>Hello World</h1>\")\n    });\n\nChanges `<hello-world/>` elements into:\n\n    <hello-world><h1>Hello World</h1></hello-world>\n\nUse the [can-component/content] tag to position the custom element’s source HTML.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1><content/></h1>\")\n    });\n\nChanges `<hello-world>Hi There</hello-world>` into:\n\n    <hello-world><h1>Hi There</h1></hello-world>\n\n### ViewModel\n\nA component’s [can-component::ViewModel ViewModel] defines a constructor that creates\ninstances used to render the component’s template. The instance’s properties\nare typically set by attribute [can-stache-bindings data bindings] on the custom element.\nBy default, every data binding’s value is looked up in the parent [can-view-scope]\nof the custom element and added to the viewModel object.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\")\n    });\n\nChanges the following rendered template:\n\n    var template = stache(\"<hello-world {message}='greeting'/>\");\n    template({\n      greeting: \"Salutations\"\n    })\n\nInto:\n\n    <hello-world><h1>Salutations</h1></hello-world>\n\nDefault values can be provided. The following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\"),\n      viewModel: {\n        message: \"Hi\"\n      }\n    });\n\nChanges the following rendered template:\n\n    var template = stache(\"<hello-world/>\");\n    template({})\n\nInto:\n\n    <hello-world><h1>Hi</h1></hello-world>\n\nIf you want to set the string value of the attribute on the ViewModel,\nset an attribute without any binding syntax.\n\nThe following template, with the previous `hello-world` component:\n\n    var template = stache(\"<hello-world message='Howdy'/>\");\n    template({})\n\nRenders to:\n\n    <hello-world><h1>Howdy</h1></hello-world>\n\n### Events\n\nA component’s [can-component::events events] object is used to listen to events (that are not\nlistened to with [can-stache-bindings view bindings]). The following component\nadds “!” to the message every time `<hello-world>` is clicked:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\"),\n      events: {\n        \"click\" : function(){\n          var currentMessage = this.viewModel.message;\n          this.viewModel.message = currentMessage+ \"!\";\n        }\n      }\n    });\n\nComponents have the ability to bind to special [can-util/dom/events/inserted/inserted],\n[can-component/beforeremove] and [can-util/dom/events/removed/removed] events\nthat are called when a component’s tag has been inserted into,\nis about to removed, or was removed from the page.\n\n### Helpers\n\nA component’s [can-component::helpers helpers] object provides [can-stache.helper stache helper] functions\nthat are available within the component’s template.  The following component\nonly renders friendly messages:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"{{#isFriendly message}}\"+\n                  \"<h1>{{message}}</h1>\"+\n                \"{{/isFriendly}}\"),\n      helpers: {\n        isFriendly: function(message, options){\n          if( /hi|hello|howdy/.test(message) ) {\n            return options.fn();\n          } else {\n            return options.inverse();\n          }\n        }\n      }\n    });\n\nGenerally speaking, helpers should only be used for view related functionality, like\nformatting a date.  Data related methods should be in the view model or models.\n\n## Examples\n\nCheck out the following examples built with `Component`.\n\n### Tabs\n\nThe following demos a tabs widget.  Click “Add Vegetables”\nto add a new tab.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/tabs.html'></div>\n\nAn instance of the tabs widget is created by creating `<my-tabs>` and `<my-panel>`\nelements like:\n\n    <my-tabs>\n      {{#each foodTypes}}\n        <my-panel title='title'>{{content}}</my-panel>\n      {{/each}}\n    </my-tabs>\n\nTo add another panel, all we have to do is add data to `foodTypes` like:\n\n    foodTypes.push({\n      title: \"Vegetables\",\n      content: \"Carrots, peas, kale\"\n    })\n\nThe secret is that the `<my-panel>` element listens to when it is inserted\nand adds its data to the tabs' list of panels with:\n\n    var vm = this.parentViewModel = canViewModel(this.element.parentNode);\n    vm.addPanel(this.viewModel);\n\n\n### TreeCombo\n\nThe following tree combo lets people walk through a hierarchy and select locations.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/treecombo.html'></div>\n\nThe secret to this widget is the viewModel’s `breadcrumb` property, which is an array\nof items the user has navigated through, and `selectableItems`, which represents the children of the\nlast item in the breadcrub.  These are defined on the viewModel like:\n\n\n    breadcrumb: [],\n    selectableItems: function(){\n      var breadcrumb = this.attr(\"breadcrumb\");\n\n      // if there’s an item in the breadcrumb\n      if(breadcrumb.attr('length')){\n\n        // return the last item’s children\n        return breadcrumb.attr(\"\"+(breadcrumb.length-1)+'.children');\n      } else{\n\n        // return the top list of items\n        return this.attr('items');\n      }\n    }\n\nWhen the “+” icon is clicked next to each item, the viewModel’s `showChildren` method is called, which\nadds that item to the breadcrumb like:\n\n    showChildren: function(item, ev) {\n      ev.stopPropagation();\n      this.attr('breadcrumb').push(item)\n    },\n\n### Paginate\n\nThe following example shows 3\nwidget-like components: a grid, next / prev buttons, and a page count indicator. And, it shows an application component that puts them all together.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate.html'></div>\n\nThis demo uses a `Paginate` [can-define/map/map] to assist with maintaining a paginated state:\n\n    var Paginate = DefineMap.extend({\n    ...\n    });\n\nThe `app` component, using [can-define/map/map], creates an instance of the `Paginate` model\nand a `websitesPromise` that represents a request for the Websites\nthat should be displayed.  Notice how the paginate’s `count` value is tied to the\nvalue of the `websitesPromise`’s resolved `value`’s `count`.\n\n```js\nvar AppViewModel = DefineMap.extend({\n\tpaginate: {\n\t\tvalue: function() {\n\t\t\treturn new Paginate({\n\t\t\t\tlimit: 5,\n\t\t\t\tcount: compute(this, \"websitesPromise.value.count\")\n\t\t\t});\n\t\t}\n\t},\n\twebsitesPromise: {\n\t\tget: function() {\n\t\t\tvar params = {\n\t\t\t\t\tlimit: this.paginate.limit,\n\t\t\t\t\toffset: this.paginate.offset\n\t\t\t\t},\n\t\t\t\twebsitesPromise = Website.getList(params),\n\t\t\t\tself = this;\n\n\t\t\twebsitesPromise.then(function(websites) {\n\t\t\t\tself.paginate.count = websites.length;\n\t\t\t});\n\n\t\t\treturn websitesPromise;\n\t\t}\n\t}\n});\n```\n\nThe `my-app` component passes paginate, paginate’s values, and websitesPromise to\nits sub-components:\n\n    <my-app>\n      <my-grid {promise-data}='websitesPromise'>\n        {{#each items}}\n          <tr>\n            <td width='40%'>{{name}}</td>\n            <td width='70%'>{{url}}</td>\n          </tr>\n        {{/each}}\n      </my-grid>\n      <next-prev {paginate}='paginate'></next-prev>\n      <page-count {page}='paginate.page' {count}='paginate.pageCount'/>\n    </my-app>\n\n",
    "description": "Create a custom element that can be used to manage widgets or application logic.\n\n",
    "name": "can-component",
    "type": "module",
    "title": "can-component",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "download": "can/component",
    "test": "can/component/test.html",
    "parent": "can-core",
    "release": "2.0",
    "link": "../docco/component/component.html docco",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-component"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-component/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.4",
        "can-construct": "^3.0.6",
        "can-control": "^3.0.4",
        "can-namespace": "1.0.0",
        "can-observation": "^3.0.4",
        "can-stache-bindings": "^3.0.5",
        "can-types": "^1.0.1",
        "can-util": "^3.2.1",
        "can-view-callbacks": "^3.0.3",
        "can-view-model": "^3.1.2",
        "can-view-nodelist": "^3.0.2",
        "can-view-scope": "^3.1.1"
      },
      "description": "Custom elements for CanJS",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^1.0.5",
        "can-event": "^3.0.1",
        "can-list": "^3.0.1",
        "can-map": "^3.0.3",
        "can-stache": "^3.0.14",
        "can-vdom": "^3.0.0",
        "done-serve": "^0.2.5",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-component",
      "name": "can-component",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-component.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.7"
    },
    "signatures": [
      {
        "code": "<TAG BINDINGS...>[LIGHT_DOM]</TAG>",
        "description": "\n\n  Create an instance of a component on a particular tag in a [can-stache] template.\n  In 2.3, use the [can-stache-bindings bindings] syntaxes to set up bindings.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "TAG",
            "description": "An HTML tag name that matches the [can-component::tag tag]\nproperty of the component. Tag names should include a hypen (`-`) or a colon (`:`) like:\n`acme-tabs` or `acme:tabs`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache-bindings"
              }
            ],
            "optional": true,
            "name": "BINDINGS",
            "description": "Use the following binding syntaxes\nto connect the component’s [can-component::ViewModel] to the template’s [can-view-scope scope]:\n\n - [can-stache-bindings.toChild]=[can-stache.expressions expression] — one-way data binding to child\n - [can-stache-bindings.toParent]=[can-stache.expressions expression] — one-way data binding to parent\n - [can-stache-bindings.twoWay]=[can-stache.expressions expression] — two-way data binding child to parent\n - [can-stache-bindings.event]=[can-stache/expressions/call expression] — event binding on the view model\n\n Note that because DOM attribute names are case-insensitive, use hypens (`-`) to\n in the attribute name to setup for `camelCase` properties.\n\n Example:\n\n ```\n <my-tag {to-child}=\"expression\"\n         {^to-parent}=\"expression\"\n         {(two-way)}=\"expression\"\n         (event)=\"callExpression()\"></my-tag>\n ```\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "LIGHT_DOM",
            "description": "The content between the starting and ending\ntag. For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `LIGHT_DOM` can be positioned with a component’s [can-component.prototype.view] with\nthe [can-component/content] element.  The data accessible to the `LIGHT_DOM` can be controlled\nwith [can-component.prototype.leakScope].\n\n"
          }
        ],
        "release": "2.3"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "LIGHT_DOM",
      "description": "The content between the starting and ending\ntag. For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `LIGHT_DOM` can be positioned with a component’s [can-component.prototype.view] with\nthe [can-component/content] element.  The data accessible to the `LIGHT_DOM` can be controlled\nwith [can-component.prototype.leakScope].\n\n"
    },
    "comment": " "
  },
  "can-compute": {
    "src": {
      "path": "node_modules/can-compute/docs/compute.md"
    },
    "body": "\n## Use\n\n`can-compute` exports a function that lets you make an observable value.  The following\nmakes an observable `age` compute whose value changes from `33` to `34`:\n\n```js\nvar compute = require(\"can-compute\");\n\nvar age = compute(33);\nage(); // 33\n\nage.on(\"change\",function(ev, newVal, oldVal){\n\tnewVal //-> 34\n\toldVal //-> 33\n})\n\nage(34);\nage(); // 33\n```\n\nComputes are similar\nto observable maps like [can-define/map/map], but they represent a single value rather than a collection of values.\n\nComputes can derive their value from other computes, maps and lists.\nWhen the derived values change, the compute's value will be automatically updated.  This\nis `can-compute`'s best feature.  For example, the following combines the age\ncompute in the previous example, and a `name` compute into an `info` compute:\n\n```js\nvar age = compute(33),\n\tname = compute(\"Justin\"),\n\tinfo = compute(function(){\n\t\treturn name() +\" is \"+age()+\".\"\n\t});\n\ninfo() //-> \"Justin is 33.\"\n```\n\nIf we listen to [can-compute.computed.ChangeEvent] on `info`, if either `age` or `name`\nchanges, `info` will be updated automatically:\n\n```js\ninfo.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Justin is 34.\"\n});\n\nage(34)\n```\n\nComputes are similar to event streams like `Bacon.js` or `RXJS`.  However, computes\nare easier to compose values because:\n\n - you can just read other observables and computes and return a value.  \n - you don't have to manage subscribing and merging streams yourself.\n\nAlso, computes can also have [can-event/batch/batch batched updates] to prevent unnecessary\nupdates. For example, if both `age` and `name` were changed at the same time, we\ncould prevent `info` from updating twice with:\n\n```js\nvar canBatch = require(\"can-event/batch/batch\");\n\ncanBatch.start();\nage(35)\nname(\"Justin Meyer\")\ncanBatch.stop();\n```\n\nThere are a wide variety of ways to create computes. Read on to understand the basics.\n\n## Observing a value\n\nThe simplest way to use a compute is to have it store a single value, and to set it when\nthat value needs to change:\n\n```\nvar tally = compute(12);\ntally(); // 12\n\ntally.on(\"change\",function(ev, newVal, oldVal){\n    console.log(newVal,oldVal)\n})\n\ntally(13);\ntally(); // 13\n```\n\nAny value can be observed.  The following creates a compute\nthat holds an object and then changes it to an array.\n\n```js\nvar data = compute({name: \"Justin\"})\ndata([{description: \"Learn Computes\"}])\n```\n\n\n## Derived computes\n\nIf you use a compute that derives its\nvalue from properties of an observable map or other [can-compute]s, the compute will listen for changes in those\nproperties and automatically recalculate itself, emitting a _change_ event if its value\nchanges.\n\nThe following example shows creating a `fullName` compute\nthat derives its value from two properties on the `person` observe:\n\n```js\nvar person = new Person({\n\tfirstName: 'Alice',\n\tlastName: 'Liddell'\n});\n\nvar fullName = compute(function() {\n\treturn person.firstName + ' ' + person.lastName;\n});\n\nfullName.on('change', function(ev, newVal, oldVal) {\n\t\tconsole.log(\"This person's full name is now \" + newVal + '.');\n});\n\nperson.firstName = 'Allison'; // The log reads:\n//-> \"This person's full name is now Allison Liddell.\"\n```\n\nBecause Person is an observable [can-define/map/map] can-compute knows to listen for changes because the map's firstName and lastName properties are read.\n\n## Translator computes - computes that update their derived values\n\nSometimes you need a compute to be able to translate one value to another. For example,\nconsider a widget that displays and allows you to update the progress in percent\nof a task. It accepts a compute with values between 0 and 100. But,\nour task observe has progress values between 0 and 1 like:\n\n```js\nvar task = new DefineMap({\n\tprogress: 0.75\n});\n```\n\nUse `compute( getterSetter )` to create a compute that updates itself\nwhen task's `progress` changes, but can also update progress when\nthe compute function is called with a value.  For example:\n\n```js\nvar progressPercent = compute(function(percent){\n\tif(arguments.length){\n\t\ttask.progress = percent / 100;\n\t} else {\n\t\treturn task.progress * 100;\n\t}\n})\n\nprogressPercent() // -> 75\n\nprogressPercent(100)\n\ntask.progress; // -> 1\n```\n\n\nThe following is a similar example that shows converting feet into meters and back:\n\n```js\nvar wall = new DefineMap({\n    material: 'brick',\n    length: 10 // in feet\n});\n\nvar wallLengthInMeters = compute(function(lengthInM) {\n\tif(arguments.length) {\n\t\twall.length = lengthInM / 3.28084;\n\t} else {\n\t\treturn wall.length * 3.28084;\n\t}\n});\n\nwallLengthInMeters(); // 3.048\n\n// When you set the compute...\nwallLengthInMeters(5);\nwallLengthInMeters(); // 5\n\n// ...the original map changes too.\nwall.length;          // 16.4042\n```\n\n## Events\n\nWhen a compute's value is changed, it emits a [can-compute.computed.ChangeEvent] event. You can listen for this change\nevent by using `on` to bind an event handler to the compute:\n\n```js\nvar tally = compute(0);\ntally.on('change', function(ev, newVal, oldVal) {\n    console.log('The tally is now at ' + newVal + '.');\n});\n\ntally(tally() + 5); // The log reads:\n                    // 'The tally is now at 5.'\n```\n\n## Caching values\n\nA compute that has an event listener will cache its value and only update when one of its source observables change.\n\nFor example:\n\n```js\nvar foo = {\n\tfirst: \"Wonder\"\n};\nvar last = compute(\"Woman\");\nvar hero = {\n\tfullName: compute(function() {\n\t\treturn foo.first + ' ' + last();\n\t})\n}\nhero.fullName.on('change', function() {}); // bind to compute\nconsole.log(hero.fullName()); // console.logs \"Wonder Woman\"\nfoo.first = \"Super\";\nconsole.log(hero.fullName()); // console.logs \"Wonder Woman\" because the source observable (last) hasn't changed\nlast(\"Man\");\nconsole.log(hero.fullName()); // console.logs \"Super Man\" because fullName updates its value now after hearing the change on \"last\"\n```\nIn contrast, if we didn't bind to the compute:\n\n```js\nvar foo = {\n\tfirst: \"Wonder\"\n};\nvar last = compute(\"Woman\");\nvar hero = {\n\tfullName: compute(function() {\n\t\treturn foo.first + ' ' + last();\n\t})\n}\nconsole.log(hero.fullName()); // console.logs \"Wonder Woman\"\nfoo.first = \"Super\";\nconsole.log(hero.fullName()); // console.logs \"Super Woman\" because fullName did not cache its previous value\nlast(\"Man\");\nconsole.log(hero.fullName()); // console.logs \"Super Man\"\n```\n\n",
    "description": "Create an observable value. \n",
    "name": "can-compute",
    "type": "module",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-core",
    "release": "1.1",
    "link": "../docco/compute/compute.html docco",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-compute"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-compute/issues"
      },
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-event": "^3.3.0",
        "can-namespace": "1.0.0",
        "can-observation": "^3.0.1",
        "can-types": "^1.0.1",
        "can-util": "^3.2.2"
      },
      "description": "compose observables",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^1.0.1",
        "done-serve": "^0.2.5",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^1.0.4",
        "jshint": "^2.9.1",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.4.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-compute",
      "name": "can-compute",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-compute.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.0.10"
    },
    "signatures": [
      {
        "code": "compute(getterSetter[, context])",
        "description": "\n\nCreate a compute that derives its value from other observables. Uses [can-observation] to call the `getterSetter` and track observables.\n\n```js\nvar age = compute(32);\n\nvar nameAndAge = compute(function(){\n\treturn \"Matthew - \" + age();\n});\n\nconsole.log(nameAndAge()); // -> Matthew - 32\n\nage(33);\n\nconsole.log(nameAndAge()); // -> Matthew - 33\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*+"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*+"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "name": "getterSetter",
            "description": "A function that gets, and optionally sets, the value of the compute. When called with no arguments, _getterSetter_ should return the current value of the compute. When called with a single argument, _getterSetter_ should arrange things so that the next read of the compute produces that value. This compute will automatically update its value when any observables values are read.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "The `this` to use when calling the `getterSetter` function.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n\n"
        }
      },
      {
        "code": "compute(initialValue [, settings])",
        "description": "\n\nCreates a compute from a value and optionally specifies how to read, update, and\nlisten to changes in dependent values. This form of compute can be used to\ncreate a compute that derives its value from any source.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "initialValue",
            "description": "The initial value of the compute. If `settings` is\nnot provided, the compute simply updates its value to whatever the first argument\nto the compute is.\n\n    var age = compute(30);\n    age() //-> 30\n    age(31) //-> fires a \"change\" event\n"
          },
          {
            "types": [
              {
                "type": "can-compute.computeSettings"
              }
            ],
            "optional": true,
            "name": "settings",
            "description": "\n\nConfigures all behaviors of the [can-compute.computed]. The following cross\nbinds an input element to a compute:\n\n```js\nvar input = document.getElementById(\"age\")\nvar value = compute(\"\",{\n\tget: function(){\n\t\treturn input.value;\n\t},\n\tset: function(newVal){\n\t\tinput.value = newVal;\n\t},\n\ton: function(updated){\n\t\tinput.addEventListener(\"change\", updated, false);\n\t},\n\toff: function(updated){\n\t\tinput.removeEventListener(\"change\", updated, false);\n\t}\n})\n```\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The new compute.\n\n"
        }
      },
      {
        "code": "compute(initialValue, setter(newVal,oldVal))",
        "description": "\n\nCreate a compute that has a setter that can adjust incoming new values.\n\n```js\nvar age = compute(6,function(newVal, oldVal){\n\tif(!isNaN(+newVal)){\n\t\treturn +newVal;\n\t} else {\n\t\treturn oldVal;\n\t}\n});\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "initialValue",
            "description": "\n\nThe initial value of the compute.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "name": "setter",
            "description": "\n\nA function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can-compute.computed] and the current value. If\n`set` returns a value, it is used to compare to the current value of the compute. Otherwise,\n`get` is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n"
        }
      },
      {
        "code": "compute(object, propertyName [, eventName])",
        "description": "\n\nCreate a compute from an object's property value. This short-cut\nsignature lets you create a compute on objects that have events\nthat can be listened to with [can-compute.computed.on].\n\n```js\nvar input = document.getElementById('age')\nvar age = compute(input,\"value\",\"change\");\n\nvar me = new DefineMap({name: \"Justin\"});\nvar name = compute(me,\"name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "An object that has an `addEventListener` method and events dispatched on it.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The property value to read on `object`.  The\nproperty will be read via `object.attr(propertyName)` or `object[propertyName]`.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "eventName",
            "defaultValue": "propertyName",
            "description": "Specifies the event name to listen\nto on `object` for `propertyName` updates.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A new compute.\n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "eventName",
      "defaultValue": "propertyName",
      "description": "Specifies the event name to listen\nto on `object` for `propertyName` updates.\n"
    },
    "comment": " "
  },
  "connect": {
    "type": "function",
    "name": "connect",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "String"
                  }
                ]
              },
              {
                "types": [
                  {
                    "type": "Behavior"
                  }
                ]
              },
              {
                "types": [
                  {
                    "type": "function",
                    "returns": {
                      "types": [
                        {
                          "type": "undefined"
                        }
                      ]
                    },
                    "params": []
                  }
                ]
              }
            ]
          }
        ],
        "name": "behaviors",
        "description": "- An array of behavior names or custom behaviors.\nThe order of named execution gets run in order."
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "options",
        "description": "\n"
      }
    ],
    "parent": "node_modules/can-connect/connect.js",
    "src": {
      "line": 1,
      "codeLine": 7,
      "path": "node_modules/can-connect/connect.js"
    },
    "body": "",
    "description": "",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "\n"
    }
  },
  "can-connect.behaviors": {
    "name": "can-connect.behaviors",
    "title": "behaviors",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 1
  },
  "can-connect.modules": {
    "name": "can-connect.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 2
  },
  "can-connect.types": {
    "name": "can-connect.types",
    "title": "data types",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 3
  },
  "can-connect": {
    "src": {
      "path": "node_modules/can-connect/can-connect.md"
    },
    "body": "\n`can-connect` comes with the following behaviors that:\n\nLoad data:\n\n - [can-connect/data/url/url] — Persist data to restful or other types of services.\n - [can-connect/data/parse/parse] — Extract response data into a format needed for other extensions.\n\nConvert data into special types:\n\n - [can-connect/constructor/constructor] — Create instances of a constructor function or list type.\n - [can-connect/constructor/store/store] — Create only a single instance for a given id or a single list for a set.\n\nReal time:\n\n - [can-connect/real-time/real-time] — Update lists and instances with server side events.\n\nCaching strategies:\n\n - [can-connect/fall-through-cache/fall-through-cache] — Respond with data from the [connection.cacheConnection] and\n   then update the response with data from the `raw CRUD Methods`.\n - [can-connect/cache-requests/cache-requests] — Save response data and use it for future requests.\n - [can-connect/data/combine-requests/combine-requests] — Combine overlapping or reduntant requests.\n\nCaching layers:\n\n - [can-connect/data/localstorage-cache/localstorage-cache] — LocalStorage caching connection.\n - [can-connect/data/memory-cache/memory-cache] — LocalStorage caching connection.\n\nThe following modules glue certain methods together:\n\n - [can-connect/data/callbacks/callbacks] — Glues the result of the `raw CRUD Methods` to callbacks.\n - [can-connect/data/callbacks-cache/callbacks-cache] — Calls [connection.cacheConnection] methods whenever `raw CRUD methods` are called.\n\n\nThe following modules are useful to CanJS specifically:\n\n - [can-connect/can/map/map] — Create instances of a special [can-define/map/map] or [can-define/list/list] type.\n - [can-connect/can/super-map/super-map] — Create a connection for a [can-define/map/map] or [can-define/list/list] that uses almost all the plugins.\n - [can-connect/can/model/model] — Inherit from a highly compatible [can.Model](http://v2.canjs.com/docs/can.Model.html) implementation.\n - [can-connect/can/tag/tag] — Create a custom element that can load data into a template.\n\n## Overview\n\nThe `can-connect` module exports a `connect` function that is used to assemble different\nbehaviors and some options into a `connection`.  For example, the following uses `connect` and\nthe [can-connect/constructor/constructor] and [can-connect/data/url/url] behaviors to create a `todoConnection`\nconnection:\n\n```js\nvar connect = require(\"can-connect\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\nvar todoConnection = connect(\n  [constructor,dataUrl],\n  {\n    url: \"/services/todos\"\n  });\n```\n\nA connection typically provides the ability to\ncreate, read, update, or delete (CRUD) some data source. That data source is\nusually accessed through the “Instance Interface” methods:\n\n - [can-connect/connection.get]\n - [can-connect/connection.getList]\n - [can-connect/connection.save]\n - [can-connect/connection.destroy]\n\nFor example, to get all todos from \"GET /services/todos\", we could write the following:\n\n```\ntodoConnection.getList({}).then(function(todos){ ... });\n```\n\n__Behaviors__, like [can-connect/constructor/constructor] and [can-connect/data/url/url] implement,\nextend, or require some set of [interfaces](#Interfaces).  For example, [can-connect/data/url/url] implements\nthe “Data Interface” methods, and [can-connect/constructor/constructor] implements the\n“Instance Interface” methods.\n\nThe `connect` method calls these behaviors in the right order to create a connection. For instance,\nthe [can-connect/cache-requests/cache-requests] behavior must be applied after the [can-connect/data/url/url]\nconnection.  This is because [can-connect/cache-requests/cache-requests], overwrites [can-connect/data/url/url]’s\n[can-connect/connection.getListData] first check a cache for the data.  Only if the data is not present,\ndoes it call [can-connect/data/url/url]’s [can-connect/connection.getListData]. So even if we write:\n\n```js\nvar dataUrl = require(\"can-connect/data/url/url\");\nvar cacheRequests = require(\"can-connect/cache-requests/cache-requests\");\nconnect([cacheRequests,dataUrl])\n```\n\nor\n\n```\nconnect([dataUrl,cacheRequests])\n```\n\n... our connection will be built in the right order!\n\nA __connection__ is just an object with each behavior object on its prototype chain and\nits options object at the end of the prototype chain.\n\n\n### Basic Use\n\nTo use `can-connect`, it’s typically best to start out with the most basic\nbehaviors: [can-connect/data/url/url] and [can-connect/constructor/constructor]. [can-connect/data/url/url]\nconnects the “Data Interface” to a restful service. [can-connect/constructor/constructor] adds\nan “Instance Interface” that can create, read, update and delete (CRUD) typed data\nusing the lower-level \"Data Interface\".\n\nBy `typed` data we mean data that is more than just plain JavaScript objects.  For\nexample, we might to create `todo` objects with an `isComplete` method:\n\n```js\nvar Todo = function(props){\n  Object.assign(this, props);\n};\n\nTodo.prototype.isComplete = function(){\n  return this.status === \"complete\";\n};\n```\n\nAnd, we might want a special list type with `completed` and `active` methods:\n\n```js\nvar TodoList = function(todos){\n  [].push.apply(this, todos);\n};\nTodoList.prototype = Object.create(Array.prototype);\n\nTodoList.prototype.completed = function(){\n  return this.filter(function(todo){\n    return todo.status === \"complete\";\n  });\n};\n\nTodoList.prototype.active = function(){\n  return this.filter(function(todo){\n    return todo.status !== \"complete\";\n  });\n};\n```\n\nWe can create a connection that connects a restful \"/api/todos\"\nservice to `Todo` instances and `TodoList` lists like:\n\n```js\nvar todoConnection = connect([constructor, dataUrl],{\n  url: \"/api/todos\",\n  list: function(listData, set){\n  \treturn new TodoList(listData.data);\n  },\n  instance: function(props) {\n  \treturn new Todo(props);\n  }\n});\n```\n\nAnd then use that connection to get a `TodoList` of `Todo`s:\n\n```js\ntodoConnection.getList({}).then(function(todos){\n\tvar todosEl = document.getElementById(\"todos-list\");\n\ttodosEl.innerHTML = \"<h2>Active</h2>\"+\n\t\trender(todos.active())+\n\t\t\"<h2>Complete</h2>\"+\n\t\trender(todos.completed());\n});\n\nvar render = function(todos) {\n\treturn \"<ul>\"+todos.map(function(todo){\n\t\treturn \"<li>\"+todo.name+\n\t\t\t\t\"<input type='checkbox' \"+\n\t\t\t\t(todo.isComplete() ? \"checked\" : \"\")+\"/></li>\";\n\t}).join(\"\")+\"</ul>\";\n};\n```\n\nThe following demo shows the result:\n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/basics.html'></div>\n\nThis connection also lets you create, update, and destroy a Todo instance as follows:\n\n```js\nvar todo = new Todo({\n  name: \"take out trash\"\n})\n\n// POSTs to /api/todos name=take out trash\n// server returns {id: 5}\ntodoConnection.save( todo ).then(function(todo){\n  todo.id //-> 5\n  todo.name = 'take out garbage'\n\n  // PUTs to /api/todos/5 name=take out garbage\n  // server returns {id: 5, \"take out garbage\"}\n  todoConnection.save( todo ).then( function(todo){\n\n    // DELETEs to /api/todos/5\n    // server returns {}\n    todoConnection.destroy( todo ).then( function(todo){\n\n    });\n\n  });\n\n});\n```\n\n### Configure behaviors\n\nWhenever `connect` creates a connection, it always adds the [can-connect/base/base]\nbehavior. This behavior defines configurable options that are used by almost\nevery other behavior.  For example, if your data uses an `_id` property\nto uniquely identify todos, you\ncan specify this with [can-connect/base/base.idProp] like:\n\n```js\nvar todoConnection = connect([\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/data/url/url\")\n],{\n  url: \"/api/todos\",\n  idProp: \"_id\"\n});\n```\n\nOther behaviors list their configurable options in their own docs page.  \n\n### Overwrite behaviors\n\nIf configurable options are not enough, you can overwrite any behavior with your own behavior.\n\nFor example, the `constructor`’s [can-connect/constructor/constructor.updatedInstance] behavior\nsets the instance’s properties to match the result of [can-connect/connection.updateData]. But if\nthe `PUT /api/todos/5 name=take out garbage` request returned `{}`, the following would result in\na todo with only an `id` property:\n\n```js\nvar todo = new Todo({id: 5, name: \"take out garbage\"})\n// PUTs to /api/todos/5 name=take out garbage\n// server returns {}\ntodoConnection.save( todo ).then( function(todo){\n\n  todo.id //-> 5\n  todo.name //-> undefined\n});\n```\n\nThe following overwrites the behavior of `updateData`:\n\n```js\nvar mergeDataBehavior = {\n  updateData: function(instance, data){\n    Object.assign(instance, data);\n  }\n};\n\nvar todoConnection = connect([\n    require(\"can-connect/constructor/can-connect/constructor\"),\n    require(\"can-connect/data/url/url\")\n    mergeDataBehavior\n  ],{\n  url: \"/api/todos\"\n});\n```\n\nYou can add your own behavior that overwrite all base behaviors by adding\nit to the end of the behaviors list.\n\n\n### CanJS use\n\nIf you are using CanJS, you can either:\n\n- use the [can-connect/can/map/map] behavior that overwrites\n  many methods and settings to work with [can-define/map/map] and [can-define/list/list].\n- use the [can-connect/can/super-map/super-map] helper to create a connection that bundles [can-connect/can/map/map can/map] and\n  many of the other extensions.\n\nUsing [can-connect/can/map/map] to create a connection looks like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({ ... });\nTodo.List = DefineList.extend({\n    \"#\": Todo\n});\n\nvar todoConnection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/can/map/map/map\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/constructor/store/store\")\n  ],{\n  Map: Todo,\n  url: \"/todos\"\n});\n```\n\nWhen you bind on a `Todo` instance or `Todo.List` list, they will automatically call\n[can.connect/constructor-store.addInstanceReference] and [can.connect/constructor-store.addListReference].\n\nUsing [can-connect/can/super-map/super-map] to create a connection looks like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({ ... });\nTodo.List = DefineList.extend({\n    \"#\": Todo\n});\n\nvar todoConnection = superMap({\n    Map: Todo,\n    url: \"/todos\"\n});\n```\n\n### ReactJS use\n\nHelp us create a special ReactJS behavior that integrates\na connection with React’s observable life-cycle. Read more [here](#Otheruse).\n\n### Angular use\n\nHelp us create a special AngularJS behavior that integrates\na connection with Angular’s observable life-cycle. Read more [here](#Otheruse).\n\n### Backbone use\n\nHelp us create a special BackboneJS behavior that integrates\na connection with Backbone’s observable life-cycle. Read more [here](#Otheruse).\n\n### Other use\n\nIntegrating `can-connect` with your framework is typically pretty easy.  In general,\nthe pattern involves creating a behavior that integrates with your framework’s\nobservable instances. The [can-connect/can/map/map]\nbehavior can serve as a good guide. You’ll typically want to implement the following\nin your behavior:\n\n`.instance` - Creates the appropriate observable object type.  \n`.list` - Creates the appropriate observable array type.  \n`.serializeInstance` - Return a plain object out of the observable object type.  \n`.serializeList` - Return a plain array out of the observable array type.  \n\n`.createdInstance` - Update an instance with data returned from `createData`.  \n`.updatedInstance` - Update an instance with data returned from `updateData`.  \n`.destroyedInstance` -  Update an instance with data returned from `destroyData`.  \n`.updatedList` - Update a list with raw data.\n\nAnd, in most frameworks you know when a particular observable is being used, typically\nobserved, and when it can be discarded.  In those places, you should call:\n\n[can-connect/constructor/store/store.addInstanceReference] — Call when an instance is being used.\n[can-connect/constructor/store/store.deleteInstanceReference] — Call when an instance is no longer being used.\n[can-connect/constructor/store/store.addListReference] — Call when a list is being used.\n[can-connect/constructor/store/store.deleteListReference] — Called when a list is no longer being used.\n\n\n## Interfaces\n\nThe following is a list of the most important interface methods and properties implemented\nor consumed by the core behaviors.\n\n### Identifiers\n\n`.id( props | instance ) -> String` - Returns a unique identifier for the instance or raw data.  \n`.idProp -> String=\"id\"` - The name of the unique identifier property.  \n`.listSet(list) -> set` - Returns the set a list represents.  \n`.listSetProp -> String=\"__listSet\"` - The property on a List that contains its set.  \n\nImplemented by [can-connect/base/base].\n\n### Instance Interface\n\nThe following methods operate on instances and lists.\n\n#### CRUD methods:\n\n`.getList(set) -> Promise<List>` - retrieve a list of instances.  \n`.getList(set) -> Promise<Instance>` - retrieve a single instance.   \n`.save(instance) -> Promise<Instance>` - creates or updates an instance.  \n`.destroy(instance) -> Promise<Instance>` - destroys an instance.  \n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [can-connect/constructor/store/store].\n\n#### Instance callbacks\n\n`.createdInstance(instance, props)` - An instance is created.  \n`.updatedInstance(instance, props)` - An instance is updated.  \n`.destroyedInstance(instance, props)` - An instance is destroyed.  \n`.updatedList(list, updatedListData, set)` - A list has been updated.  \n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [data-connect/real-time/real-time],\n[can-connect/constructor/callbacks-once/callbacks-once].\n\n#### Hydrators and Serializers\n\n`.instance(props) -> Instance` - Creates an instance given raw data.  \n`.list({data: Array<Instance>}) -> List` - Creates a list given an array of instances.  \n`.hydrateInstance(props) -> Instance` - Provides an instance given raw data.  \n`.hydrateList({ListData}, set) -> List` - Provides a list given raw data.  \n`.hydratedInstance(instance)` - Called whenever an instance is created in memory.  \n`.hydratedList(list, set)` - Called whenever a list is created in memory.  \n`.serializeInstance(instance) -> Object` - Returns the serialized form of an instance.  \n`.serializeList(list) -> Array<Object>` - Returns the serialized form of a list and its instances.  \n\n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [can-connect/constructor/store/store],\n[can-connect/fall-through-cache/fall-through-cache].\n\n### Data Interface\n\nThe raw-data connection methods.  \n\n#### CRUD methods\n\n`.getListData(set) -> Promise<ListData>` - Retrieves list data.  \n`.updateListData(listData[, set]) -> Promise<ListData>` - Update a list’s data.\n`.getSets() -> Promise<Array<Set>>` - Returns the sets available to the connection.  \n\n\n`.getData(params) -> Promise<Object>` - Retrieves data for a particular item.  \n`.createData(props, cid) -> Promise<props>` - Creates instance data given the serialized form of the data.\n  A client ID is passed of the\n  instance that is being created.  \n`.updateData(props) -> Promise<props>` - Updates instance data given the\n  serialized form of the data.  \n`.destroyData(props) -> Promise<props>` - Destroys an instance given the seralized\nform of the data.  \n\n`.clear() -> Promise` - Clears all data in the connection.\n\nImplemented by [can-connect/data/url/url],\n[can-connect/data/localstorage-cache/localstorage-cache], [can-connect/data/memory-cache/memory-cache].\nOverwritten by [can-connect/cache-requests/cache-requests], [can-connect/data/combine-requests/combine-requests], [can-connect/fall-through-cache/fall-through-cache].\nConsumed by [can-connect/constructor/constructor].  \n\n#### Data Callbacks\n\n`.gotListData(listData, set) -> ListaData` - List data is retrieved.  \n`.gotData( props, params) -> props` - Instance data is retreived.  \n`.createdData( props, params, cid) -> props` - An instance’s data is created.\n`.updatedData( props, params) -> props` - An instance’s data is updated.\n`.destroyedData( props, params) -> props` - An instance’s data is destroyed.\n\nImplemented by [can-connect/data/callbacks/callbacks].  Overwritten by [can-connect/data/callbacks-cache/callbacks-cache],\n[can-connect/real-time/real-time].\n\n#### Response parsers\n\n`.parseListData(*) -> ListData` - Given the response of getListData, return the right object format.  \n`.parseInstanceData(*) -> props` - Given the response of getData, createData, updateData, and destroyData,\nreturn the right object format.\n\nImplemented by [can-connect/data/parse/parse].\n\n#### Store Interface\n\n`.addInstanceReference(instance)` - Signal that memory-unsafe actions can be performed on the instance.  \n`.deleteInstanceReference(instance)` - Signal that memory-unsafe actions should be removed.\n`.addListReference(list)` - Signal that memory-unsafe actions can be performed on the list.  \n`.deleteListReference(list)` - Signal that memory-unsafe actions should be removed.\n\nImplemented by [can-connect/constructor/store/store].\n\n#### Real-time Methods\n\n`createInstance( props ) -> Promise<instance>` - Inform the connection an instance has been created.  \n`updateInstance( props ) -> Promise<instance>` - Inform the connection an instance has been updated.  \n`destroyInstance( props ) -> Promise<instance>` - Inform the connection an instance has been destroyed.  \n\nImplemented by [can-connect/real-time/real-time].\n\n## Creating Behaviors\n\nTo create your own behavior, call `connect.behavior` with the name of your behavior and a function that\nreturns an object that defines the hooks you want to overwrite or provide:\n\n```js\nconnect.behavior(\"my-behavior\", function(baseConnection){\n  return {\n    // Hooks here\n  };\n})\n```\n\nFor example, creating a simple localStorage behavior might look like:\n\n```js\nconnect.behavior(\"localstorage\", function(baseConnection){\n  return {\n    getData: function(params){\n      var id = this.id(params);\n      return new Promise(function(resolve){\n        var data = localStorage.getItem(baseConnection.name+\"/\"+id);\n        resolve( JSON.parse(data) )\n      });\n    },\n    createData: function(props){\n      var id = localStorage.getItem(baseConnection.name+\"-ID\") || \"0\";\n\n      var nextId = ++JSON.parse( id );\n      localStorage.setItem(baseConnection.name+\"-ID\", nextId);\n      var id = this.idProp;\n      return new Promise(function(resolve){\n        props[id] = nextId;\n        localStorage.setItem(baseConnection.name+\"/\"+nextId, props);\n        resolve( props )\n      });\n    },\n    updateData: function(){ ... },\n    destroyData: function(){ ...}\n  };\n})\n```\n\n",
    "description": "`can-connect` provides persisted data middleware. Use it to assemble powerful model layers for any JavaScript project.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect",
    "parent": "can-core",
    "outline": "2",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-connect/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.4",
        "can-construct": "^3.1.0",
        "can-define": "^1.0.9",
        "can-event": "^3.3.0",
        "can-list": "^3.0.1",
        "can-map": "^3.0.3",
        "can-namespace": "1.0.0",
        "can-observation": "^3.0.3",
        "can-set": "^1.0.2",
        "can-stache": "^3.0.13",
        "can-stache-bindings": "^3.0.5",
        "can-types": "^1.0.0",
        "can-util": "^3.2.2",
        "can-view-callbacks": "^3.0.2",
        "can-view-nodelist": "^3.0.2",
        "jquery": "2.x - 3.x",
        "steal-stache": "^3.0.3"
      },
      "description": "Data connection middleware and utilities",
      "devDependencies": {
        "can-fixture": "^1.0.10",
        "jshint": "^2.9.4",
        "steal": "^1.0.1",
        "steal-css": "^1.0.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "engines": {
        "npm": "^3.0.0"
      },
      "homepage": "https://github.com/canjs/can-connect#readme",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "can-connect.js",
      "name": "can-connect",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-connect.git"
      },
      "scripts": {
        "build": "node build.js",
        "jshint": "jshint --config .jshintrc",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && testee --browsers firefox test/test.html",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "plugins": [
          "steal-stache",
          "steal-css"
        ]
      },
      "version": "1.3.11"
    },
    "signatures": [
      {
        "code": "connect(behaviors, options)",
        "description": "\n\nGoes through every behavior and assembles them into a final\nconnection.\n\n```js\nvar connect = require(\"can-connect\");\nvar todosConnection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/constructor/constructor\")    \n],{\n    url: \"/api/todos\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-connect/Behavior"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "behaviors",
            "description": "An array of\nbehaviors that will be used to compose the final connection.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "options",
            "description": "an object of configuration\noptions.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "an object of configuration\noptions.\n"
    },
    "comment": " "
  },
  "camelCase": {
    "type": "function",
    "name": "camelCase",
    "params": [
      {
        "name": "str",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect-signalr/can-connect-signalr.js",
    "src": {
      "line": 4,
      "codeLine": 9,
      "path": "node_modules/can-connect-signalr/can-connect-signalr.js"
    },
    "body": "",
    "description": "\n",
    "desc": "Converts a string in TitleCase to camelCase",
    "_curParam": {
      "name": "str",
      "description": ""
    },
    "returns": "{string}"
  },
  "init": {
    "type": "function",
    "name": "init",
    "params": [],
    "parent": "can-connect/can/ref/ref.methods",
    "src": {
      "line": 379,
      "codeLine": 385,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\t \n",
    "description": "\n",
    "desc": [
      "Initializes the SignalR Hub Proxy",
      "and sets up the RPC listeners for the standard"
    ],
    "can": "-connect/can/ref/ref.init init",
    "comment": "Initializes the base connection and then creates and sets [can-connect/can/ref/ref.Map.Ref]. "
  },
  "createData": {
    "type": "function",
    "name": "createData",
    "params": [
      {
        "name": "props",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect-signalr/can-connect-signalr.js",
    "src": {
      "line": 62,
      "codeLine": 67,
      "path": "node_modules/can-connect-signalr/can-connect-signalr.js"
    },
    "body": "",
    "description": "    \n",
    "desc": "Creates an instance on the Hub",
    "_curParam": {
      "name": "props",
      "description": ""
    },
    "returns": "{Promise}"
  },
  "updateData": {
    "type": "function",
    "name": "updateData",
    "params": [
      {
        "name": "props",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect-signalr/can-connect-signalr.js",
    "src": {
      "line": 72,
      "codeLine": 77,
      "path": "node_modules/can-connect-signalr/can-connect-signalr.js"
    },
    "body": "",
    "description": "    \n",
    "desc": "Updates an instance on the Hub",
    "_curParam": {
      "name": "props",
      "description": ""
    },
    "returns": "{Promise}"
  },
  "destroyData": {
    "type": "function",
    "name": "destroyData",
    "params": [
      {
        "name": "props",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect-signalr/can-connect-signalr.js",
    "src": {
      "line": 82,
      "codeLine": 87,
      "path": "node_modules/can-connect-signalr/can-connect-signalr.js"
    },
    "body": "",
    "description": "    \n",
    "desc": "Destroys an instance on the Hub",
    "_curParam": {
      "name": "props",
      "description": ""
    },
    "returns": "{Promise}"
  },
  "getListData": {
    "type": "property",
    "name": "getListData",
    "params": [
      {
        "name": "data",
        "description": ""
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 100,
      "codeLine": 107,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "  - fixture.store.getListData: {count, limit, offset, data}\n  - feathers.find:             {total, limit, skip, data}\n\n",
    "description": "Transforms getListData from fixture to feathers format.\n",
    "desc": "Gets a collection of data instances from the Hub",
    "_curParam": {
      "name": "data",
      "description": ""
    },
    "returns": [
      "{{total: number",
      "limit: number",
      "skip: number",
      "data: *}}"
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "get": {
    "type": "function",
    "name": "get",
    "params": [
      {
        "name": "set",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect-signalr/can-connect-signalr.js",
    "src": {
      "line": 102,
      "codeLine": 107,
      "path": "node_modules/can-connect-signalr/can-connect-signalr.js"
    },
    "body": "",
    "description": "    \n",
    "desc": "Gets a single instance of data from the Hub",
    "_curParam": {
      "name": "set",
      "description": ""
    },
    "returns": "{Promise}"
  },
  "testData": {
    "name": "testData",
    "type": "property",
    "parent": "node_modules/can-connect-signalr/test.js",
    "src": {
      "line": 73,
      "codeLine": 77,
      "path": "node_modules/can-connect-signalr/test.js"
    },
    "body": "",
    "description": "\n",
    "desc": "A piece of sample data for use in the tests",
    "types": []
  },
  "can-construct": {
    "name": "can-construct",
    "type": "module",
    "description": " \nProvides a way to easily use the power of prototypal inheritance\nwithout worrying about hooking up all the particulars yourself. Use\n[can-construct.extend can-construct.extend] to create an inheritable\nconstructor function of your own.\n\n",
    "src": {
      "path": "node_modules/can-construct/docs/construct.md"
    },
    "body": "\n## Use\n\nIn the example below, `Animal` is a constructor function returned by [can-construct.extend can-construct.extend]. All instances of `Animal` will have a `speak`\nmethod, and the `Animal` constructor has a `legs` property.\n\n```js\nvar Construct = require(\"can-construct\");\nvar Animal = Construct.extend({\n\tlegs: 4\n},\n{\n  speak: function() {\n  \tconsole.log(this.sound);\n  }\n});\n```\n\nAn optional [can-construct::setup setup] function can be specified to handle the instantiation of the constructor function.\n```js\nvar Animal = Construct.extend({\n\tlegs: 4,\n\tsetup: function(sound) {\n\t\treturn [sound]\n\t}\n},\n{\n  speak: function() {\n  \tconsole.log(this.sound);\n  }\n});\n```\n[can-construct::setup setup] returns {Array|undefined} If an array is returned, the array's items are passed as arguments to [can-construct::init init].\n\nIn addition [can-construct::init init] can be specified which is a method that gets called with each new instance.\n```js\nvar Animal = Construct.extend({\n\tlegs: 4,\n\tinit: function(sound) {\n\t\tthis.sound = sound;\n\t}\n},\n{\n  speak: function() {\n  \tconsole.log(this.sound);\n  }\n});\n```\n\nFor more information on deciding when to use [can-construct::setup setup] or [can-construct::init init]\nsee the bottom of the [can-construct::setup setup] documentation.\n\nYou can make instances of your object by calling your constructor function with the `new` keyword. When an object is created, the [can-construct::init init]\nmethod gets called (if you supplied one):\n\n```js\nvar panther = new Animal('growl');\npanther.speak(); // \"growl\"\npanther instanceof Animal; // true\n```\n\n## Plugins\n\nThere are plugins available to help make using `can-construct` even simpler.\n\n-   [can-construct-super] allows you to easily call base methods by making `this._super` available in inherited methods.\n\n",
    "title": "can-construct",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-construct"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-construct/issues"
      },
      "dependencies": {
        "can-namespace": "1.0.0",
        "can-types": "^1.0.1",
        "can-util": "^3.1.1"
      },
      "description": "easy constructor functions",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-construct",
      "name": "can-construct",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-construct.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.1.1"
    },
    "signatures": [
      {
        "code": "new Construct( ...args )",
        "description": "\n\nCreates a new instance using Construct's constructor functions.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "args",
            "description": "The arguments passed to the constructor."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The instantiated object.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "args",
      "description": "The arguments passed to the constructor."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The instantiated object.\n"
    },
    "comment": " "
  },
  "can-construct.static": {
    "src": {
      "line": 136,
      "codeLine": 139,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "can-construct.static",
    "parent": "can-construct",
    "title": "static"
  },
  "can-construct.constructorExtends": {
    "name": "can-construct.constructorExtends",
    "type": "property",
    "parent": "can-construct.static",
    "src": {
      "line": 140,
      "codeLine": 207,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n If `constructorExtends` is:\n\n  - `true` - the constructor extends\n  - `false` - a new instance of the constructor is created\n\n This property defaults to false.\n\n Example of constructExtends as `true`:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: true // the constructor extends\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var Pony = Animal({\n   gallop: function () {\n      console.log(\"Galloping!!\");\n   }\n }); // Pony is now a constructor function extended from Animal\n\n var frank = new Animal(); // frank is a new instance of Animal\n\n var gertrude = new Pony(); // gertrude is a new instance of Pony\n gertrude.sayHi(); // \"hai!\" - sayHi is \"inherited\" from Animal\n gertrude.gallop(); // \"Galloping!!\" - gallop is unique to instances of Pony\n```\n\n The default behavior is shown in the example below:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: false // the constructor does NOT extend\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var pony = Animal(); // pony is a new instance of Animal\n var frank = new Animal(); // frank is a new instance of Animal\n\n pony.sayHi() // \"hai!\"\n frank.sayHi() // \"hai!\"\n```\n By default to extend a constructor, you must use [can-construct.extend extend].\n\t \n",
    "description": "  Toggles the behavior of a constructor function called\n without the `new` keyword to extend the constructor function or\n create a new instance.\n\n ```js\n var animal = Animal();\n // vs\n var animal = new Animal();\n ```\n\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "constructorExtends",
    "comment": " "
  },
  "can-construct.newInstance": {
    "type": "function",
    "name": "can-construct.newInstance",
    "parent": "can-construct.static",
    "src": {
      "line": 208,
      "codeLine": 273,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "Creates a new instance of the constructor function. This method is useful for creating new instances\nwith arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n__new__ operator.\n\n## Example\n\nThe following creates a `Person` Construct and overrides `newInstance` to cache all\ninstances of Person to prevent duplication. If the properties of a new Person match an existing one it\nwill return a reference to the previously created object, otherwise it returns a new object entirely.\n\n```js\n// define and create the Person constructor\nvar Person = Construct.extend({\n  init : function(first, middle, last) {\n    this.first = first;\n    this.middle = middle;\n    this.last = last;\n  }\n});\n\n// store a reference to the original newInstance function\nvar _newInstance = Person.newInstance;\n\n// override Person's newInstance function\nPerson.newInstance = function() {\n  // if cache does not exist make it an new object\n  this.__cache = this.__cache || {};\n  // id is a stingified version of the passed arguments\n  var id = JSON.stringify(arguments);\n\n  // look in the cache to see if the object already exists\n  var cachedInst = this.__cache[id];\n  if(cachedInst) {\n    return cachedInst;\n  }\n\n  //otherwise call the original newInstance function and return a new instance of Person.\n  var newInst = _newInstance.apply(this, arguments);\n  this.__cache[id] = newInst;\n  return newInst;\n};\n\n// create two instances with the same arguments\nvar justin = new Person('Justin', 'Barry', 'Meyer'),\n\tbrian = new Person('Justin', 'Barry', 'Meyer');\n\nconsole.log(justin === brian); // true - both are references to the same instance\n```\n\n \n",
    "description": "Returns an instance of `Construct`. This method can be overridden to return a cached instance.\n\n",
    "title": "newInstance",
    "signatures": [
      {
        "code": "Construct.newInstance([...args])",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "args",
            "description": "arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\nthat if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\ninstead."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "class"
            }
          ],
          "description": "instance of the class\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "args",
      "description": "arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\nthat if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\ninstead."
    },
    "_curReturn": {
      "types": [
        {
          "type": "class"
        }
      ],
      "description": "instance of the class\n"
    },
    "comment": " "
  },
  "can-construct.setup": {
    "type": "function",
    "name": "can-construct.setup",
    "parent": "can-construct.static",
    "src": {
      "line": 319,
      "codeLine": 380,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "The static `setup` method is called immediately after a constructor\nfunction is created and\nset to inherit from its base constructor. It is useful for setting up\nadditional inheritance work.\nDo not confuse this with the prototype `[can-construct::setup]` method.\n\n## Example\n\nThis `Parent` class adds a reference to its base class to itself, and\nso do all the classes that inherit from it.\n\n```js\nParent = Construct.extend({\n  setup : function(base, fullName, staticProps, protoProps){\n    this.base = base;\n\n    // call base functionality\n    Construct.setup.apply(this, arguments)\n  }\n},{});\n\nParent.base; // Construct\n\nChild = Parent({});\n\nChild.base; // Parent\n```\n \n",
    "description": "Perform initialization logic for a constructor function. \n",
    "title": "setup",
    "signatures": [
      {
        "code": "Construct.setup(base, fullName, staticProps, protoProps)",
        "description": "\n\nA static `setup` method provides inheritable setup functionality\nfor a Constructor function. The following example\ncreates a Group constructor function.  Any constructor\nfunctions that inherit from Group will be added to\n`Group.childGroups`.\n\n\n    Group = Construct.extend({\n      setup: function(Construct, fullName, staticProps, protoProps){\n        this.childGroups = [];\n        if(Construct !== Construct){\n          this.childGroups.push(Construct)\n        }\n        Construct.setup.apply(this, arguments)\n      }\n    },{})\n    var Flock = Group.extend(...)\n    Group.childGroups[0] //-> Flock\n",
        "params": [
          {
            "types": [
              {
                "type": "constructor"
              }
            ],
            "name": "base",
            "description": "The base constructor that is being inherited from."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "fullName",
            "description": "The name of the new constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "staticProps",
            "description": "The static properties of the new constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "protoProps",
            "description": "The prototype properties of the new constructor.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "protoProps",
      "description": "The prototype properties of the new constructor.\n"
    },
    "comment": " "
  },
  "can-construct.extend": {
    "type": "function",
    "name": "can-construct.extend",
    "parent": "can-construct.static",
    "src": {
      "line": 394,
      "codeLine": 572,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "## Inheritance\nCreating \"subclasses\" with `Construct` is simple. All you need to do is call the base constructor\nwith the new function's static and instance properties. For example, we want our `Snake` to\nbe an `Animal`, but there are some differences:\n\n\n    var Snake = Animal.extend({\n        legs: 0\n    }, {\n        init: function() {\n            Animal.prototype.init.call(this, 'ssssss');\n        },\n        slither: function() {\n            console.log('slithering...');\n        }\n    });\n\n    var baslisk = new Snake();\n    baslisk.speak();   // \"ssssss\"\n    baslisk.slither(); // \"slithering...\"\n    baslisk instanceof Snake;  // true\n    baslisk instanceof Animal; // true\n\n\n## Static properties and inheritance\n\nIf you pass all three arguments to Construct, the second one will be attached directy to the\nconstructor, allowing you to imitate static properties and functions. You can access these\nproperties through the `[can-construct::constructor this.constructor]` property.\n\nStatic properties can get overridden through inheritance just like instance properties. In the example below,\nwe override both the legs static property as well as the the init function for each instance:\n\n```js\nvar Animal = Construct.extend({\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    },\n    speak: function() {\n        console.log(this.sound);\n    }\n});\n\nvar Snake = Animal.extend({\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nAnimal.legs; // 4\nSnake.legs; // 0\nvar dog = new Animal('woof');\nvar blackMamba = new Snake();\ndog.speak(); // 'woof'\nblackMamba.speak(); // 'ssssss'\n```\n\n## Alternative value for a new instance\n\nSometimes you may want to return some custom value instead of a new object when creating an instance of your class.\nFor example, you want your class to act as a singleton, or check whether an item with the given id was already\ncreated and return an existing one from your cache store (e.g. using [can-connect/constructor/store/store]).\n\nTo achieve this you can return [can-construct.ReturnValue] from `setup` method of your class.\n\nLets say you have `myStore` to cache all newly created instances. And if an item already exists you want to merge\nthe new data into the existing instance and return the updated instance.\n\n```\nvar myStore = {};\n\nvar Item = Construct.extend({\n    setup: function(params){\n        if (myStore[params.id]){\n            var item = myStore[params.id];\n            \n            // Merge new data to the existing instance:\n            Object.assign(item, params);\n            \n            // Return the updated item:\n            return new Construct.ReturnValue( item );\n        } else {\n            // Save to cache store:\n            myStore[this.id] = this;\n            \n            return [params];\n        }\n    },\n    init: function(params){\n        Object.assign(this, params);\n    }\n});\n\nvar item_1  = new Item( {id: 1, name: \"One\"} );\nvar item_1a = new Item( {id: 1, name: \"OnePlus\"} )\n```\n \n",
    "description": "\n",
    "title": "extend",
    "signatures": [
      {
        "code": "Construct.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nExtends `Construct`, or constructor functions derived from `Construct`,\nto create a new constructor function. Example:\n\n```js\nvar Animal = Construct.extend({\n  sayHi: function(){\n    console.log(\"hi\")\n  }\n});\n\nvar animal = new Animal()\nanimal.sayHi();\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Adds a name to the constructor function so\nit is nicely labeled in the developer tools. The following:\n\n    Construct.extend(\"ConstructorName\",{})\n\nreturns a constructur function that will show up as `ConstructorName`\nin the developer tools.\nIt also sets \"ConstructorName\" as [can-construct.shortName shortName].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties that are added the constructor\nfunction directly. For example:\n\n```js\nvar Animal = Construct.extend({\n  findAll: function(){\n    return can.ajax({url: \"/animals\"})\n  }\n},{}); // need to pass an empty instanceProperties object\n\nAnimal.findAll().then(function(json){ ... })\n```\n\nThe [can-construct.setup static setup] method can be used to\nspecify inheritable behavior when a Constructor function is created.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [can-construct::init init] and [can-construct::setup setup] properties\nare used for initialization.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceProperties",
      "description": "Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [can-construct::init init] and [can-construct::setup setup] properties\nare used for initialization.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"
    },
    "comment": " "
  },
  "can-construct.shortName": {
    "src": {
      "line": 653,
      "codeLine": 667,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "property",
    "body": "\n```js\nvar MyConstructor = Construct.extend(\"MyConstructor\",{},{});\nMyConstructor.shortName // \"MyConstructor\"\n```\n\t\t \n",
    "description": "\nIf you pass a name when creating a Construct, the `shortName` property will be set to the\nname.\n",
    "types": [
      {
        "type": "String"
      }
    ],
    "title": "shortName",
    "name": "can-construct.shortName",
    "parent": "can-construct.static"
  },
  "can-construct.prototype": {
    "src": {
      "line": 678,
      "codeLine": 681,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "can-construct.prototype",
    "parent": "can-construct",
    "title": "prototype"
  },
  "can-construct.prototype.constructor": {
    "src": {
      "line": 682,
      "codeLine": 710,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "property",
    "body": "\n## Example\n\nThis Construct has a static counter that counts how many instances have been created:\n\n```js\nvar Counter = Construct.extend({\n    count: 0\n}, {\n    init: function() {\n        this.constructor.count++;\n    }\n});\n\nvar childCounter = new Counter();\nconsole.log(childCounter.constructor.count); // 1\nconsole.log(Counter.count); // 1\n```\n\t \n",
    "description": "\nA reference to the constructor function that created the instance. This allows you to access\nthe constructor's static properties from an instance.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "constructor",
    "name": "can-construct.prototype.constructor",
    "parent": "can-construct.prototype",
    "comment": " "
  },
  "can-construct.ReturnValue": {
    "type": "function",
    "name": "can-construct.ReturnValue",
    "parent": "can-construct.static",
    "src": {
      "line": 710,
      "codeLine": 744,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n",
    "description": "\nUse to overwrite the return value of new Construct(...).\n",
    "title": "ReturnValue",
    "signatures": [
      {
        "code": "new Construct.ReturnValue( value )",
        "description": "\n\n  This constructor function can be used for creating a return value of the `setup` method.\n  [can-construct] will check if the return value is an instance of `Construct.ReturnValue`.\n  If it is then its `value` will be used as the new instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "value",
            "description": "A value to be used for a new instance instead of a new object.\n\n```\nvar Student = function( name, school ){\n    this.name = name;\n    this.school = school;\n} \n\nvar Person = Construct.extend({\n    setup: function( options ){\n        if (options.school){\n            return new Constructor.ReturnValue( new Student( options.name, options.school ) );\n        } else {\n            return [options];\n        }\n    }\n});\n\nvar myPerson = new Person( {name: \"Ilya\", school: \"PetrSU\"} );\n\nmyPerson instanceof Student // => true\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "value",
      "description": "A value to be used for a new instance instead of a new object.\n\n```\nvar Student = function( name, school ){\n    this.name = name;\n    this.school = school;\n} \n\nvar Person = Construct.extend({\n    setup: function( options ){\n        if (options.school){\n            return new Constructor.ReturnValue( new Student( options.name, options.school ) );\n        } else {\n            return [options];\n        }\n    }\n});\n\nvar myPerson = new Person( {name: \"Ilya\", school: \"PetrSU\"} );\n\nmyPerson instanceof Student // => true\n```\n"
    }
  },
  "can-construct.prototype.setup": {
    "type": "function",
    "name": "can-construct.prototype.setup",
    "parent": "can-construct.prototype",
    "src": {
      "line": 748,
      "codeLine": 795,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n## Deciding between `setup` and `init`\n\n\nUsually, you should use [can-construct::init init] to do your constructor function's initialization.\nYou should, instead, use `setup` when:\n\n  - there is initialization code that you want to run before the inheriting constructor's\n    `init` method is called.\n  - there is initialization code that should run whether or not inheriting constructors\n    call their base's `init` methods.\n  - you want to modify the arguments that will get passed to `init`.\n\n\n",
    "description": "\n",
    "title": "setup",
    "signatures": [
      {
        "code": "construct.setup(...args)",
        "description": "\n\nA setup function for the instantiation of a constructor function.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "The arguments passed to the constructor.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array"
            },
            {
              "type": "undefined"
            },
            {
              "type": "can-construct.ReturnValue"
            }
          ],
          "description": "If an array is returned, the array's items are passed as\narguments to [can-construct::init init]. If a [can-construct.ReturnValue] instance is returned, the ReturnValue\ninstance's value will be returned as the result of calling new Construct(). The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n```js\n\tWidgetFactory = Construct.extend({\n\t\t\tsetup: function(element){\n\t\t\t\t\treturn [$(element)]\n\t\t\t}\n\t});\n\n\tMyWidget = WidgetFactory.extend({\n\t\t\tinit: function($el){\n\t\t\t\t\t$el.html(\"My Widget!!\")\n\t\t\t}\n\t});\n ```\n\nOtherwise, the arguments to the\nconstructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "The arguments passed to the constructor.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "undefined"
        },
        {
          "type": "can-construct.ReturnValue"
        }
      ],
      "description": "If an array is returned, the array's items are passed as\narguments to [can-construct::init init]. If a [can-construct.ReturnValue] instance is returned, the ReturnValue\ninstance's value will be returned as the result of calling new Construct(). The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n```js\n\tWidgetFactory = Construct.extend({\n\t\t\tsetup: function(element){\n\t\t\t\t\treturn [$(element)]\n\t\t\t}\n\t});\n\n\tMyWidget = WidgetFactory.extend({\n\t\t\tinit: function($el){\n\t\t\t\t\t$el.html(\"My Widget!!\")\n\t\t\t}\n\t});\n ```\n\nOtherwise, the arguments to the\nconstructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n"
    },
    "comment": " "
  },
  "can-construct.prototype.init": {
    "type": "function",
    "name": "can-construct.prototype.init",
    "parent": "can-construct.prototype",
    "src": {
      "line": 796,
      "codeLine": 855,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "If a prototype `init` method is provided, `init` is called when a new Construct is created---\nafter [can-construct::setup]. The `init` method is where the bulk of your initialization code\nshould go. A common thing to do in `init` is save the arguments passed into the constructor.\n\n## Examples\n\nFirst, we'll make a Person constructor that has a first and last name:\n\n```js\nvar Person = Construct.extend({\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar justin = new Person(\"Justin\", \"Meyer\");\njustin.first; // \"Justin\"\njustin.last; // \"Meyer\"\n```\n\nThen, we'll extend Person into Programmer, and add a favorite language:\n\n```js\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n\nvar brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\nbrian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n```\n\n## Modified Arguments\n\n[can-construct::setup] is able to modify the arguments passed to `init`.\nIf you aren't receiving the arguments you passed to `new Construct(args)`,\ncheck that they aren't being changed by `setup` along\nthe inheritance chain.\n\n",
    "description": "Called when a new instance of a Construct is created. \n",
    "title": "init",
    "signatures": [
      {
        "code": "construct.init(...args)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n"
    },
    "comment": " "
  },
  "can-construct-super": {
    "src": {
      "path": "node_modules/can-construct-super/can-construct-super.md"
    },
    "body": "\nWith this plugin, functions that are inheriting from base functions\nare provided with a specialized `this._super` reference to the base\nfunction from which they inherit.\n\nThis is especially useful for calling base classes' `[can-construct::init init]` and `[can-construct::setup setup]`, but it can be used in any inheriting function.\n\nThe `Person` and `Programmer` examples from `[can-construct::init init]` demonstrate `_super`'s use.\nHere's how those classes look without can.Construct.super:\n\n```\nvar Person = Construct.extend({\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\nAnd here's how `Programmer` works using `_super`:\n\n```\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        this._super(first, last);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\nIf you want to pass an array of arguments (or an arguments object) to `_super`, use [apply](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply):\n\n```\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        this._super.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\n## `_super` on constructors\n\ncan.Construct.super also adds `super` to the constructor, so you\ncan use it in static functions.\n\nHere is a base class that has a method that squares numbers and an inherited class that has a method that cubes numbers:\n\n```\nvar Squarer = can.Construct.extend({\n    raise: function(n) {\n        return n*n;\n    }\n}, {});\n\nvar Cuber = Squarer.extend({\n    raise: function(n) {\n        return n * this._super(n);\n    }\n}, {});\n```\n\n",
    "description": "\ncan.Construct.super is a plugin that makes it easier to call base\nfunctions from inside inheriting functions.\n",
    "type": "module",
    "title": "",
    "name": "can-construct-super",
    "parent": "can-ecosystem",
    "plugin": "can-construct-super",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "can-construct-super.md",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-stache-bindings"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-construct-super/issues"
      },
      "dependencies": {
        "can-construct": "^3.0.0",
        "can-util": "^3.0.0"
      },
      "description": "Provides a reference to the prototypal parent using this._super in can-construct objects",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "jshint": "^2.9.3",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "https://github.com/canjs/can-construct-super#readme",
      "keywords": [
        "canjs",
        "donejs"
      ],
      "license": "MIT",
      "main": "can-construct-super",
      "name": "can-construct-super",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-construct-super.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-construct-super",
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.3"
    },
    "signatures": [
      {
        "code": "construct._super([...args])",
        "description": "\n\nCalls the base constructor function's method.\n",
        "params": [
          {
            "types": [
              {
                "type": "Any"
              }
            ],
            "variable": true,
            "name": "args",
            "description": "parameters to pass to the base function\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Any"
        }
      ],
      "variable": true,
      "name": "args",
      "description": "parameters to pass to the base function\n"
    },
    "comment": " "
  },
  "can.Control": {
    "name": "can.Control",
    "type": "add",
    "description": "undefined \n"
  },
  "can.Control.static": {
    "src": {
      "line": 69,
      "codeLine": 72,
      "path": "node_modules/can-control/can-control.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "can.Control.static",
    "parent": "can.Control",
    "title": "static"
  },
  "can.Control.prototype": {
    "src": {
      "line": 266,
      "codeLine": 269,
      "path": "node_modules/can-control/can-control.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "can.Control.prototype",
    "parent": "can.Control",
    "title": "prototype"
  },
  "can.Control.processor": {
    "src": {
      "path": "node_modules/can-control/control.processor.md"
    },
    "body": "",
    "description": "A function that handles the binding and unbinding of a [can.Control]'s declarative event method. \n",
    "type": "typedef",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A callback function that unbinds any event handlers bound within this processor.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "the control's element or the object \nspecified by the templated event handler (`\"{object}\"`).\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "The event type.\n"
          },
          {
            "types": [
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "selector",
            "description": "The selector preceding the event in the binding used on the Control.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ],
                    "name": "element",
                    "description": "foo"
                  },
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event",
                    "description": "bar\n"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "can.Control"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The callback function being bound.\n"
          },
          {
            "types": [
              {
                "type": "can.Control"
              }
            ],
            "name": "control",
            "description": "The Control the event is bound on.\n"
          }
        ]
      }
    ],
    "name": "can.Control.processor",
    "_curParam": {
      "types": [
        {
          "type": "can.Control"
        }
      ],
      "name": "control",
      "description": "The Control the event is bound on.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A callback function that unbinds any event handlers bound within this processor.\n"
    }
  },
  "'htmlbool'": {
    "type": "function",
    "name": "'htmlbool'",
    "params": [
      {
        "name": "val",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-map-define/can-map-define.js",
    "src": {
      "line": 235,
      "codeLine": 239,
      "path": "node_modules/can-map-define/can-map-define.js"
    },
    "body": " \n",
    "description": "Implements HTML-style boolean logic for attribute strings, where\nany string, including \"\", is truthy.\n"
  },
  "can-define-stream-kefir/behaviors": {
    "name": "can-define-stream-kefir/behaviors",
    "title": "behaviors",
    "type": "group",
    "parent": "can-define-stream-kefir",
    "description": "",
    "order": 0
  },
  "can-define-stream-kefir/DefineMap.prototype": {
    "name": "can-define-stream-kefir/DefineMap.prototype",
    "title": "DefineMap.prototype",
    "type": "group",
    "parent": "can-define-stream-kefir",
    "description": "",
    "order": 2
  },
  "can-define-stream-kefir/DefineList.prototype": {
    "name": "can-define-stream-kefir/DefineList.prototype",
    "title": "DefineList.prototype",
    "type": "group",
    "parent": "can-define-stream-kefir",
    "description": "",
    "order": 2
  },
  "can-define-stream-kefir": {
    "src": {
      "path": "node_modules/can-define-stream-kefir/docs/can-define-stream-kefir.md"
    },
    "body": "\n## Usage\n\nFor example:\n\n__Update map property based on stream value__\n\n```js\nvar canDefineStream = require(\"can-define-stream-kefir\");\n\nvar Person = DefineMap.extend({\n    name: \"string\",\n    lastValidName: {\n        stream: function() {\n            return this.stream(\".name\").filter(function(name) {\n                return name.indexOf(\" \") >= 0;\n            });\n        }\n    }\n});\n\ncanDefineStream(Person);\n\nvar me = new Person({name: \"James\"});\n\nme.on(\"lastValidName\", function(lastValid) {});\n\nme.name = \"JamesAtherton\"; //lastValidName -> undefined\nme.name = \"James Atherton\"; //lastValidName -> James Atherton\n\n```\n__Stream on DefineList__\n\n```js\nvar canDefineStream = require(\"can-define-stream-kefir\");\n\nvar PeopleList = DefineList.extend({});\n\ncanDefineStream(PeopleList);\n\nvar people = new PeopleList([\n    { first: \"Justin\", last: \"Meyer\" },\n    { first: \"Paula\", last: \"Strozak\" }\n]);\n\nvar stream = people.stream('length');\n\nstream.onValue(function(val) {\n    val //-> 2, 3\n});\n\npeople.push({\n    first: 'Obaid',\n    last: 'Ahmed'\n}); //-> stream.onValue -> 3\n\n```\n\n",
    "description": "Exports a function that takes a Type [can-define/map/map] or [can-define/list/list] and uses [can-stream-kefir] to create a streaming object \n",
    "type": "module",
    "title": "can-define-stream-kefir",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nThe `can-define-stream-kefir` module exports methods useful for converting observable values like [can-compute]s into streams.\n\n```js\nvar canDefineStream = require(\"can-define-stream-kefir\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Person = DefineMap.extend({\n    first: \"string\",\n    last: \"string\",\n    fullName: {\n        get: function() {\n            return this.first + \" \" + this.last;\n        }\n    },\n    fullNameChangeCount: {\n        stream: function() {\n            return this.stream(\".fullName\").scan(function(last) {\n                return last + 1;\n            }, 0);\n        }\n    }\n});\n\ncanDefineStream(Person);\n\nvar me = new Person({name: \"Justin\", last: \"Meyer\"});\n\nme.on(\"fullNameChangeCount\", function(ev, newVal) {\n    console.log(newVal);\n});\n\n\nme.fullNameChangeCount //-> 0\n\nme.first = \"Obaid\"; //-> console.logs 1\nme.last = \"Ahmed\"; //-> console.logs 2\n\n```\n"
      }
    ],
    "name": "can-define-stream-kefir",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-define-stream-kefir/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-define": "^1.0.0",
        "can-define-stream": "^0.1.0",
        "can-observation": "^3.0.0",
        "can-stream-kefir": "^0.2.1",
        "can-util": "^3.0.0",
        "kefir": "^3.5.1"
      },
      "description": "Adds the ability to define properties with streams on can-define types.",
      "devDependencies": {
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.35",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-define-stream-kefir",
      "name": "can-define-stream-kefir",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-define-stream-kefir.git"
      },
      "scripts": {
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git push",
        "preversion": "npm test",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "0.0.9"
    },
    "signatures": [
      {
        "code": "undefined",
        "description": "\n\n  The `can-define-stream-kefir` module doesn't export anything.  Instead it changes\n  [can-define] to support the [can-define-stream-kefir.stream] behavior and\n  [can-define/map/map] and [can-define/list/list] to have a `stream` method that's\n  a shorthand for [can-stream.toStream] with 'this' (the map or list instance) passed as the first argument.\n\n  ```js\n  require(\"can-define-stream-kefir\");\n  var DefineMap = require(\"can-define/map/map\");\n\n  var Person = DefineMap.extend({\n\t  first: \"string\",\n\t  last: \"string\"\n\t  get fullName() {\n\t\t  return this.first + \" \" + this.last;\n\t  },\n\t  fullNameChangeCount: {\n\t\t  stream: function(setStream) {\n\t\t\t  return this.stream(\".fullName\").scan(function(last){\n\t\t\t\t  return last + 1;\n\t\t\t  },0)\n\t\t  }\n\t  }\n  });\n\n  var me = new Person({first: \"Justin\", last: \"Meyer\"});\n\n  me.on(\"fullNameChangeCount\", function(ev, newVal){\n\t  console.log(newVal);\n  });\n\n  me.fullNameChangeCount //-> 0\n\n  me.first = \"Obaid\"\n  //-> console.logs 1\n\n  me.last = \"Ahmed\"\n  //-> console.logs 2\n  ```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-deparam": {
    "name": "can-deparam",
    "type": "module",
    "parent": "can-infrastructure",
    "src": {
      "line": 2,
      "codeLine": 20,
      "path": "node_modules/can-deparam/can-deparam.js"
    },
    "body": "",
    "description": "",
    "title": "can-deparam",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "deparam(params)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "params",
            "description": "a form-urlencoded string of key-value pairs"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The params formatted into an object\n\nTakes a string of name value pairs and returns a Object literal that represents those params.\n\n```js\nvar deparam = require(\"can-deparam\");\n\nconsole.log(JSON.stringify(deparam(\"?foo=bar&number=1234\"))); // -> '{\"foo\" : \"bar\", \"number\": 1234}'\nconsole.log(JSON.stringify(deparam(\"#foo[]=bar&foo[]=baz\"))); // -> '{\"foo\" : [\"bar\", \"baz\"]}'\nconsole.log(JSON.stringify(deparam(\"foo=bar%20%26%20baz\"))); // -> '{\"foo\" : \"bar & baz\"}'\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "params",
      "description": "a form-urlencoded string of key-value pairs"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The params formatted into an object\n\nTakes a string of name value pairs and returns a Object literal that represents those params.\n\n```js\nvar deparam = require(\"can-deparam\");\n\nconsole.log(JSON.stringify(deparam(\"?foo=bar&number=1234\"))); // -> '{\"foo\" : \"bar\", \"number\": 1234}'\nconsole.log(JSON.stringify(deparam(\"#foo[]=bar&foo[]=baz\"))); // -> '{\"foo\" : [\"bar\", \"baz\"]}'\nconsole.log(JSON.stringify(deparam(\"foo=bar%20%26%20baz\"))); // -> '{\"foo\" : \"bar & baz\"}'\n```\n"
    }
  },
  "can-event.addEventListener": {
    "type": "function",
    "name": "can-event.addEventListener",
    "parent": "can-event.static",
    "src": {
      "line": 53,
      "codeLine": 77,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "addEventListener",
    "signatures": [
      {
        "code": "obj.addEventListener(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\n```js\nvar canEvent = require(\"can-event\");\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.addEventListener.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the `canEvent` mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.removeEventListener": {
    "type": "function",
    "name": "can-event.removeEventListener",
    "parent": "can-event.static",
    "src": {
      "line": 91,
      "codeLine": 106,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "removeEventListener",
    "signatures": [
      {
        "code": "obj.removeEventListener(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.removeEventListener.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.dispatch": {
    "type": "function",
    "name": "can-event.dispatch",
    "parent": "can-event.static",
    "src": {
      "line": 129,
      "codeLine": 157,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "dispatch",
    "signatures": [
      {
        "code": "obj.dispatch(event, [args])",
        "description": "\n\nDispatches/triggers a basic event on an object.\n\n```js\nvar canEvent = require(\"can-event\");\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){\n  console.log(\"FOO BAR!\");\n});\n\nobj.dispatch(\"foo\"); // Causes it to log FOO BAR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "event",
            "description": "The event to dispatch"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Additional arguments to pass to event handlers"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "event The resulting event object\n"
        }
      },
      {
        "code": "canEvent.dispatch.call(obj, event, args)",
        "description": "\n\nThis syntax can be used for objects that don't include the `can.event` mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "event The resulting event object\n"
    }
  },
  "can-event.on": {
    "type": "function",
    "name": "can-event.on",
    "parent": "can-event.static",
    "src": {
      "line": 173,
      "codeLine": 186,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "on",
    "signatures": [
      {
        "code": "obj.on(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\nThis is an alias of [can-event.addEventListener addEventListener].\n",
        "params": []
      },
      {
        "code": "can-event.on.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.off": {
    "type": "function",
    "name": "can-event.off",
    "parent": "can-event.static",
    "src": {
      "line": 195,
      "codeLine": 208,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "off",
    "signatures": [
      {
        "code": "obj.off(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n\nThis is an alias of [can-event.removeEventListener removeEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.off.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.trigger": {
    "type": "function",
    "name": "can-event.trigger",
    "parent": "can-event.static",
    "src": {
      "line": 216,
      "codeLine": 228,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "trigger",
    "signatures": [
      {
        "code": "obj.trigger(event, args)",
        "description": "\n\nDispatches/triggers a basic event on an object.\nThis is an alias of [can-event.dispatch dispatch].\n",
        "params": []
      },
      {
        "code": "canEvent.trigger.call(obj, event, args)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.one": {
    "type": "function",
    "name": "can-event.one",
    "parent": "can-event.static",
    "src": {
      "line": 238,
      "codeLine": 249,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "one",
    "signatures": [
      {
        "code": "obj.one(event, handler)",
        "description": "\n\nAdds a basic event listener that listens to an event once and only once.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n    "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "The handler that will be executed to handle the event."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n    "
    }
  },
  "can-event.listenTo": {
    "type": "function",
    "name": "can-event.listenTo",
    "parent": "can-event.static",
    "src": {
      "line": 269,
      "codeLine": 287,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "listenTo",
    "signatures": [
      {
        "code": "obj.listenTo(other, event, handler)",
        "description": "\n\nListens for an event on another object.\nThis is similar to concepts like event namespacing, except that the namespace\nis the scope of the calling object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "other",
            "description": "The object to listen for events on."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.listenTo.call(obj, other, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.stopListening": {
    "type": "function",
    "name": "can-event.stopListening",
    "parent": "can-event.static",
    "src": {
      "line": 317,
      "codeLine": 333,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "stopListening",
    "signatures": [
      {
        "code": "obj.stopListening(other, event, handler)",
        "description": "\n\nStops listening for an event on another object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "other",
            "description": "The object to listen for events on."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.stopListening.call(obj, other, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.bind": {
    "type": "function",
    "name": "can-event.bind",
    "parent": "can-event.static",
    "src": {
      "line": 389,
      "codeLine": 402,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "bind",
    "signatures": [
      {
        "code": "obj.bind(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\nThis is an alias of [can-event.addEventListener addEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.bind.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ]
  },
  "can-event.unbind": {
    "type": "function",
    "name": "can-event.unbind",
    "parent": "can-event.static",
    "src": {
      "line": 406,
      "codeLine": 419,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "unbind",
    "signatures": [
      {
        "code": "obj.unbind(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n\nThis is an alias of [can-event.removeEventListener removeEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.unbind.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ]
  },
  "can-event.delegate": {
    "name": "can-event.delegate",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 422,
      "codeLine": 442,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "delegate",
    "signatures": [
      {
        "code": "obj.delegate(selector, event, handler)",
        "description": "\n\nProvides a compatibility layer for adding delegate event listeners.\nThis doesn't actually implement delegates, but rather allows\nlogic that assumes a delegate to still function.\n\nTherefore, this is essentially an alias of [can-event.addEventListener addEventListener] with the selector ignored.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "The **ignored** selector to use for the delegate."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.delegate.call(obj, selector, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can.event] mixin.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.undelegate": {
    "name": "can-event.undelegate",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 444,
      "codeLine": 464,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "undelegate",
    "signatures": [
      {
        "code": "obj.undelegate(selector, event, handler)",
        "description": "\n\nProvides a compatibility layer for removing delegate event listeners.\nThis doesn't actually implement delegates, but rather allows\nlogic that assumes a delegate to still function.\n\nTherefore, this is essentially an alias of [can-event.removeEventListener removeEventListener] with the selector ignored.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "The **ignored** selector to use for the delegate."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.undelegate.call(obj, selector, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.static": {
    "name": "can-event.static",
    "title": "static",
    "type": "group",
    "parent": "can-event",
    "description": "",
    "order": 0
  },
  "can-event": {
    "src": {
      "path": "node_modules/can-event/can-event.md"
    },
    "body": "\n## Using as a mixin\n\nThe easiest way to add events to your classes and objects is by mixing [can-event] into your object or prototype.\n\n```\nvar SomeClass = Construct(\"SomeClass\", {\n\tinit: function() {\n\t\tthis.value = 0;\n\t},\n\tincrement: function() {\n\t\tthis.value++;\n\t\tthis.dispatch(\"change\", [this.value]);\n\t}\n});\nObject.assign(SomeClass.prototype, canEvent);\n```\n\nNow that `canEvent` is included in the prototype, we can add/remove/dispatch events on the object instances.\n\n```\nvar instance = new SomeClass();\ninstance.on(\"change\", function(ev, value) {\n\talert(\"The instance changed to \" + value);\n});\n\n// This will dispatch the \"change\" event and show the alert\ninstance.increment();\n```\n\n## Using without mixing in\n\nThe same event functionality from `canEvent` can be used, even if the given object doesn't include `canEvent`. Every method within `canEvent` supports being called with an alternate scope.\n\n```\nvar obj = {};\n\ncanEvent.addEventListener.call(obj, \"change\", function() {\n\talert(\"object change!\");\n});\n\n// This will dispatch the \"change\" event and show the alert\ncanEvent.dispatch.call(obj, \"change\");\n```\n\n",
    "description": " \nAdd event functionality into your objects.\n\nThe `canEvent` object provides a number of methods for handling events in objects. This functionality is best used by mixing the `canEvent` object into an object or prototype. However, event listeners can still be used even on objects that don't include `canEvent`.\n\nAll methods provided by `canEvent` assume that they are mixed into an object -- `this` should be the object dispatching the events.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event",
    "parent": "can-infrastructure",
    "test": "can/event/test.html",
    "link": "../docco/event.html docco",
    "release": "2.1",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-event"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-event/issues"
      },
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-namespace": "1.0.0",
        "can-types": "^1.0.1",
        "can-util": "^3.6.0"
      },
      "description": "[![Build Status](https://travis-ci.org/canjs/can-event.png?branch=master)](https://travis-ci.org/canjs/can-event)",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-event",
      "name": "can-event",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-event.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": " npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "npmAlgorithm": "flat"
      },
      "version": "3.4.0"
    },
    "signatures": [
      {
        "code": "assign(YourClass.prototype, canEvent)",
        "description": "\n\nAdds event functionality to `YourClass` objects. This can also be applied to normal objects: `assign(someObject, canEvent)`.\n\nThe `assign` function can be any function that assigns additional properties on an object such as [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) or lodash's [_.assign](https://lodash.com/docs#assign) or [can-util/js/assign/assign].\n\n```js\nvar assign = require(\"can-util/js/assign/assign\");\nvar canEvent = require(\"can-event\");\n\nfunction Thing(){\n\n}\n\nassign(Thing.prototype, canEvent);\n\nvar thing = new Thing();\nthing.addEventListener(\"prop\", function(){ ... });\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-fixture-socket.properties": {
    "name": "can-fixture-socket.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-fixture-socket",
    "description": "",
    "order": 0
  },
  "can-fixture-socket.types": {
    "name": "can-fixture-socket.types",
    "title": "types",
    "type": "group",
    "parent": "can-fixture-socket",
    "description": "",
    "order": 0
  },
  "can-fixture-socket": {
    "src": {
      "path": "node_modules/can-fixture-socket/can-fixture-socket.md"
    },
    "body": "\n## Use basics\n\nLets say we wanted to test a simple app that connects to `socket.io`, and\nonce connected, creates a message, and logs when the message is created.\n\nThat app could look like the following:\n\n```js\nvar socket = io();\nsocket.on(\"connect\", function(){\n  socket.emit(\"messages create\", {text: \"A new message\"});\n});\nsocket.on(\"message created\", function(data){\n  // data.text === \"A new message\"\n  console.log(\"Server sent out a new message we just created\", data);\n});\n```\n\nTo test this, we'll first use [can-fixture-socket.Server can-fixture-socket.Server] to intercept the socket connection:\n\n```js\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n\nNow we can mock the socket server by creating socket event listeners and emitting socket events:\n\n```js\nmockServer.on(\"messages create\", function(data){\n  console.log(\"New message received\", data);\n  mockServer.emit(\"message created\", data);\n});\n```\n\nTo see this in action:\n\n<div class='demo_wrapper' data-demo-src='demos/can-fixture-socket/basic-app.html'></div>\n\n\n### Acknowledgement callbacks\n\nWe also can use socket.io [acknowledgement callbacks](http://socket.io/docs/#sending-and-getting-data-(acknowledgements)):\n```js\nmockServer.on(\"users create\", function(user, ackCb){\n    console.log(\"Simulating saving a new user to DB and return the new user id\", user);\n\n    ackCB({\n        id: Math.random()\n    });\n});\n```\n\nClient code:\n\n```js\nvar socket = io();\nsocket.on(\"connect\", function(){\n    socket.emit(\"users create\", {name: \"Ilya\", likes: \"skiing\"}, function (data) {\n        // data is what server calls the acknowledgement callback\n        // with (e.g. data.id is the new user id).\n        console.log(data.id);\n    });\n});\n```\n\n## Use with can-fixture.Store\n\nWith can-fixture [can-fixture.store] we can create a store of items and emulate a fully working CRUD service. Optionally, we can use [can-set.Algebra] to power our store filtering, pagination, and sorting abilities.\n\n```js\n// Import can-fixture that provides `store` method for creating a store:\nvar fixture = require(\"can-fixture\");\nvar canSet = require(\"can-set\");\n\n// Create a fixture store:\nvar messagesStore = fixture.store([\n    {id: 1, title: \"One\"},\n    {id: 2, title: \"Two\"},\n    {id: 3, title: \"Three\"}\n], new canSet.Algebra({}));\n```\n\nWe can mock the socket.io connection with the rich behavior of _fixture stores_ using the [can-fixture-socket.requestHandlerToListener] helper.  `requestHandlerToListener`\nconverts a _fixture store request handler_ to a _socket.io event listener_.\n\n```js\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar io = require(\"socket.io-client\");\nvar mockServer = new fixtureSocket.Server(io);\n\nmockServer.on(\"messages get\", fixtureSocket.requestHandlerToListener( messagesStore.getData ));\n```\n\nOr we can use [can-fixture-socket.storeToListeners] helper to convert all CRUD _fixture store request handlers_ into _socket.io event listeners_:\n\n```js\nvar listeners = fixtureSocket.storeToListeners( messagesStore );\nmockServer.on({\n    \"messages remove\": listeners.destroyData,\n    \"messages create\": listeners.createData,\n    \"messages update\": listeners.updateData\n});\n```\n\n## Use with FeathersJS\n\n[Feathers](http://feathersjs.com/) is a minimalist, service-oriented, real-time web framework for modern applications. It is a NodeJS framework built on top of Express. It allows you to build REST-ful services and works with three [providers](https://docs.feathersjs.com/providers/): standard HTTP communication, WebSockets and Primus.\n\nThe mocked server exposes [can-fixture-socket.Server.prototype.onFeathers] method to simulate [FeathersJS](http://feathersjs.com/) CRUD services.\n\nFor example, given the following FeathersJS client app:\n\n```js\nvar socket = io(\"http://api.my-feathers-server.com\");\nvar app = feathers()\n\t.configure(hooks())\n\t.configure(feathersSocketio(socket));\n\n// Create FeathersJS CRUD service for \"messages\" resource:\nvar messagesService = app.service(\"messages\");\n```\n\nWe can simulate it with a [can-fixture.store] as follows:\n\n```js\nvar messagesStore = fixture.store([\n    {id: 1, title: \"One\"},\n    {id: 2, title: \"Two\"},\n    {id: 3, title: \"Three\"}\n], new canSet.Algebra({}));\n\nmockServer.onFeathersService(\"messages\", fixtureStore);\n```\n\nNow you can test your FeathersJS app:\n\n```js\nmessagesService.find({}).then(function(data){\n    assert.equal(data.total, 3, \"find should receive 3 items\");\n});\nmessagesService.get(1).then(function(data){\n    assert.deepEqual(data, {id: 1, title: \"One\"}, \"get should receive an item\");\n});\nmessagesService.create({title: \"Four\"}).then(function(data){\n    assert.equal(data.title, \"Four\", \"create should add an new item\");\n});\n```\n\n",
    "description": "Simulate socket.io services. \n\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n`can-fixture-socket` intercepts socket.io messages and simulates socket.io server responses.\n\nThe `can-fixture-socket` module exports an object with:\n\n- [can-fixture-socket.Server], a constructor function which instance intercepts the socket.io connection;\n- [can-fixture-socket.requestHandlerToListener], a helper to convert XHR request handler into [can-fixture-socket.socket-event-listener];\n- [can-fixture-socket.storeToListeners], a helper to convert all [can-fixture/StoreType] request handlers into [can-fixture-socket.socket-event-listener].\n\nWith three simple steps you can test your real-time application that uses socket.io:\n\n 1. create a mock server that intercepts socket.io;\n 2. mock server behavior;\n 3. test your application.\n\n```js\nvar fixtureSocket = require(\"can-fixture-socket\");\n\n// Import socket-io client:\nvar io = require(\"socket.io-client\");\n\n// Create a mock server that intercepts socket.io:\nvar mockServer = new fixtureSocket.Server(io);\n\n// Mock server behavior\nmockServer.on(\"connection\", function(){\n  mockServer.emit(\"notifications\", {test: \"OK\"})\n});\n\n// Client. Create socket.io connection:\nvar socket = io(\"http://localhost:8080/api\");\n\n// Test your application:\nsocket.on(\"connect\", function(){\n  assert.ok(true, \"socket connected\");\n});\n\nsocket.on(\"notifications\", function(data){\n  assert.deepEqual(data, {test: \"OK\"}, \"received notifications message\");\n});\n```\n"
      }
    ],
    "name": "can-fixture-socket",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "bitovi",
        "email": "contact@bitovi.com",
        "url": "bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-fixture-socket/issues"
      },
      "dependencies": {
        "can-fixture": "^1.0.0",
        "can-util": "^3.0.0"
      },
      "description": "Simulate socket connections",
      "devDependencies": {
        "can-set": "^1.0.0",
        "documentjs": "^0.4.4",
        "done-serve": "^0.3.0-pre.0",
        "donejs-cli": "^0.10.0-pre.0",
        "es6-promise-polyfill": "^1.2.0",
        "feathers": "^2.0.2",
        "feathers-hooks": "^1.5.8",
        "feathers-socketio": "^1.4.1",
        "generator-donejs": "^0.10.0-pre.0",
        "jshint": "^2.9.1",
        "object-assign": "^4.1.0",
        "socket.io-client": "^1.5.0",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "https://github.com/canjs/can-fixture-socket",
      "keywords": [
        "Done",
        "JS",
        "Can",
        "JS"
      ],
      "main": "can-fixture-socket",
      "name": "can-fixture-socket",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-fixture-socket.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "documentjs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-fixture-socket",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "0.6.2"
    },
    "comment": " "
  },
  "can.List": {
    "name": "can.List",
    "type": "add",
    "description": "undefined\n"
  },
  "can.List.static": {
    "src": {
      "line": 48,
      "codeLine": 51,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "can.List.static",
    "parent": "can.List",
    "title": "static"
  },
  "can.List.Map": {
    "name": "can.List.Map",
    "type": "property",
    "parent": "can.List.static",
    "src": {
      "line": 52,
      "codeLine": 88,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "",
    "description": "Specify the Map type used to make objects added to this list observable. \n",
    "types": [
      {
        "type": "can.Map",
        "description": "When objects are added to a can.List, those objects are\nconverted into can.Map instances.  For example:\n\n    var list = new can.List();\n    list.push({name: \"Justin\"});\n\n    var map = list.attr(0);\n    map.attr(\"name\") //-> \"Justin\"\n\nBy changing [can.List.Map], you can specify a different type of Map instance to\ncreate. For example:\n\n    var User = can.Map.extend({\n      fullName: function(){\n        return this.attr(\"first\")+\" \"+this.attr(\"last\")\n      }\n    });\n\n    User.List = can.List.extend({\n      Map: User\n    }, {});\n\n    var list = new User.List();\n    list.push({first: \"Justin\", last: \"Meyer\"});\n\n    var user = list.attr(0);\n    user.fullName() //-> \"Justin Meyer\"\n\n\n\n\t "
      }
    ],
    "title": ""
  },
  "can.Map.extend": {
    "src": {
      "line": 89,
      "codeLine": 112,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "function",
    "body": "\n## Use\n\n\n\t \n",
    "description": "\n",
    "title": "",
    "name": "can.Map.extend",
    "signatures": [
      {
        "code": "can.List.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function. Learn more at [can.Construct.extend].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "If provided, adds the extened List constructor function\nto the window at the given name.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties and methods\ndirectly on the constructor function. The most common property to set is [can.List.Map].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "instanceProperties",
            "description": "Properties and methods on instances of this list type.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "instanceProperties",
      "description": "Properties and methods on instances of this list type.\n"
    },
    "comment": " "
  },
  "can.List.prototype": {
    "src": {
      "line": 112,
      "codeLine": 114,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "prototype",
    "body": "",
    "description": " \n",
    "name": "can.List.prototype",
    "parent": "can.List",
    "title": "prototype"
  },
  "can.List.prototype.serialize": {
    "type": "function",
    "name": "can.List.prototype.serialize",
    "params": [],
    "parent": "can.List.prototype",
    "src": {
      "line": 216,
      "codeLine": 220,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "\t \n",
    "description": "Returns the serialized form of this list.\n",
    "hide": true
  },
  "can.List.prototype.each": {
    "src": {
      "line": 223,
      "codeLine": 261,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "function",
    "body": "```\nvar i = 0;\nnew can.List([1, 10, 100]).each(function(element, index) {\n    i += element;\n});\n\ni; // 111\n\ni = 0;\nnew can.List([1, 10, 100]).each(function(element, index) {\n    i += element;\n    if(index >= 1) {\n        return false;\n    }\n});\n\ni; // 11\n```\n\t \n",
    "description": "Call a function on each element of a List. ",
    "title": "each",
    "name": "can.List.prototype.each",
    "signatures": [
      {
        "code": "list.each( callback(item, index) )",
        "description": "\n\n`each` iterates through the List, calling a function\nfor each element.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop. The callback is not invoked for List elements that were \nnever initialized.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "this List, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop. The callback is not invoked for List elements that were \nnever initialized.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "this List, for chaining\n"
    },
    "comment": " "
  },
  "can.List.prototype.splice": {
    "type": "function",
    "name": "can.List.prototype.splice",
    "parent": "can.List.prototype",
    "src": {
      "line": 261,
      "codeLine": 324,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`splice` lets you remove elements from and insert elements into a List.\n\nThis example demonstrates how to do surgery on a list of numbers:\n\n```\nvar list = new can.List([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.attr(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n## Events\n\n`splice` causes the List it's called on to emit _change_ events,\n_add_ events, _remove_ events, and _length_ events. If there are\nany elements to remove, a _change_ event, a _remove_ event, and a\n_length_ event will be fired. If there are any elements to insert, a\nseparate _change_ event, an _add_ event, and a separate _length_ event\nwill be fired.\n\nThis slightly-modified version of the above example should help\nmake it clear how `splice` causes events to be emitted:\n\n```\nvar list = new can.List(['a', 'b', 'c', 'd']);\nlist.bind('change', function(ev, attr, how, newVals, oldVals) {\n    console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\nlist.bind('add', function(ev, newVals, where) {\n    console.log('add: ' + newVals + ', ' + where);\n});\nlist.bind('remove', function(ev, oldVals, where) {\n    console.log('remove: ' + oldVals + ', ' + where);\n});\nlist.bind('length', function(ev, length) {\n    console.log('length: ' + length + ', ' + this.attr());\n});\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                   // remove: ['c'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                   // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                   // add: ['Alice', 'Bob'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n```\n\nMore information about binding to these events can be found under [can.List.attr attr].\n\t \n",
    "description": "Insert and remove elements from a List. ",
    "title": "splice",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newElements]])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "where to start removing or inserting elements\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "the number of elements to remove\nIf _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the List.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newElements",
            "description": "elements to insert into the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the elements removed by `splice`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newElements",
      "description": "elements to insert into the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the elements removed by `splice`\n"
    },
    "comment": " "
  },
  "can.List.prototype.push": {
    "name": "can.List.prototype.push",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 422,
      "codeLine": 463,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`push` adds elements onto the end of a List here is an example:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\nIf you have an array you want to concatenate to the end\nof the List, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new can.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\n## Events\n\n`push` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`push` has a counterpart in [can.List::pop pop], or you may be\nlooking for [can.List::unshift unshift] and its counterpart [can.List::shift shift].\n\t \n",
    "description": "Add elements to the end of a list. ",
    "title": "push",
    "signatures": [
      {
        "code": "list.push(...elements)",
        "description": "\n\n`push` adds elements onto the end of a List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the List\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the List\n"
    },
    "comment": " "
  },
  "can.List.prototype.unshift": {
    "name": "can.List.prototype.unshift",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 464,
      "codeLine": 505,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`unshift` adds elements to the front of the list in bulk in the order specified:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\nIf you have an array you want to concatenate to the beginning\nof the List, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new can.List(['Alice']);\n\nlist.unshift.apply(list, names);\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\n## Events\n\n`unshift` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`unshift` has a counterpart in [can.List::shift shift], or you may be\nlooking for [can.List::push push] and its counterpart [can.List::pop pop].\n\t \n",
    "description": "Add elements to the beginning of a List. ",
    "title": "unshift",
    "signatures": [
      {
        "code": "list.unshift(...elements)",
        "description": "\n\n`unshift` adds elements onto the beginning of a List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the List\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the List\n"
    },
    "comment": " "
  },
  "can.List.prototype.pop": {
    "name": "can.List.prototype.pop",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 539,
      "codeLine": 571,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`pop` is the opposite action from `[can.List.push push]`:\n\n```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\nwhen it is called.\n\n## See also\n\n`pop` has its counterpart in [can.List::push push], or you may be\nlooking for [can.List::unshift unshift] and its counterpart [can.List::shift shift].\n\t \n",
    "description": "Remove an element from the end of a List. ",
    "title": "pop",
    "signatures": [
      {
        "code": "list.pop()",
        "description": "\n\n`pop` removes an element from the end of a List.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just popped off the List, or `undefined` if the List was empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just popped off the List, or `undefined` if the List was empty\n"
    },
    "comment": " "
  },
  "can.List.prototype.shift": {
    "name": "can.List.prototype.shift",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 572,
      "codeLine": 606,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`shift` is the opposite action from `[can.List::unshift unshift]`:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n\nlist.shift(); // 'Bob'\nlist.shift(); // 'Eve'\nlist.shift(); // 'Alice'\nlist.shift(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\nwhen it is called.\n\n## See also\n\n`shift` has a counterpart in [can.List::unshift unshift], or you may be\nlooking for [can.List::push push] and its counterpart [can.List::pop pop].\n\t \n",
    "description": "Remove en element from the front of a list. ",
    "title": "shift",
    "signatures": [
      {
        "code": "list.shift()",
        "description": "\n\n`shift` removes an element from the beginning of a List.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just shifted off the List, or `undefined` if the List is empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just shifted off the List, or `undefined` if the List is empty\n"
    },
    "comment": " "
  },
  "can.List.prototype.indexOf": {
    "type": "function",
    "name": "can.List.prototype.indexOf",
    "parent": "can.List.prototype",
    "src": {
      "line": 638,
      "codeLine": 664,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1\n```\n\nIt is trivial to make a `contains`-type function using `indexOf`:\n\n```\nfunction(list, item) {\n    return list.indexOf(item) >= 0;\n}\n```\n \n",
    "description": "Look for an item in a List. ",
    "title": "indexOf",
    "signatures": [
      {
        "code": "list.indexOf(item)",
        "description": "\n\n`indexOf` finds the position of a given item in the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "the item to find\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the position of the item in the List, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "the item to find\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the position of the item in the List, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can.List.prototype.join": {
    "type": "function",
    "name": "can.List.prototype.join",
    "parent": "can.List.prototype",
    "src": {
      "line": 674,
      "codeLine": 695,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n\nvar beatles = new can.List(['John', 'Paul', 'Ringo', 'George']);\nbeatles.join('&'); // 'John&Paul&Ringo&George'\n```\n \n",
    "description": "Join a List's elements into a string. ",
    "title": "join",
    "signatures": [
      {
        "code": "list.join(separator)",
        "description": "\n\n`join` turns a List into a string by inserting _separator_ between the string representations\nof all the elements of the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "separator",
            "description": "the string to seperate elements with\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the joined string\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "separator",
      "description": "the string to seperate elements with\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the joined string\n"
    },
    "comment": " "
  },
  "can.List.prototype.reverse": {
    "type": "function",
    "name": "can.List.prototype.reverse",
    "parent": "can.List.prototype",
    "src": {
      "line": 700,
      "codeLine": 718,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n \n",
    "description": "Reverse the order of a List. ",
    "title": "reverse",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\n`reverse` reverses the elements of the List in place.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "the List, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "the List, for chaining\n"
    },
    "comment": " "
  },
  "can.List.prototype.slice": {
    "type": "function",
    "name": "can.List.prototype.slice",
    "parent": "can.List.prototype",
    "src": {
      "line": 723,
      "codeLine": 754,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList.attr(); // ['Bob', 'Charlie', 'Daniel']\n```\n\n`slice` is the simplest way to copy a List:\n\n```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy.attr();   // ['Alice', 'Bob', 'Eve']\nlist === copy; // false\n```\n \n",
    "description": "Make a copy of a part of a List. ",
    "title": "slice",
    "signatures": [
      {
        "code": "list.slice([start[, end]])",
        "description": "\n\n`slice` creates a copy of a portion of the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "start",
            "defaultValue": "0",
            "description": "the index to start copying from\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "end",
            "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "a new `can.List` with the extracted elements\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "end",
      "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "a new `can.List` with the extracted elements\n"
    },
    "comment": " "
  },
  "can.List.prototype.concat": {
    "type": "function",
    "name": "can.List.prototype.concat",
    "parent": "can.List.prototype",
    "src": {
      "line": 761,
      "codeLine": 783,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`concat` makes a new List with the elements of the List followed by the elements of the parameters.\n\n```\nvar list = new can.List();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new can.List(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n```\n \n",
    "description": "Merge many collections together into a List. ",
    "title": "concat",
    "signatures": [
      {
        "code": "list.concat(...args)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can.List"
              },
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can.List"
        },
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.\n"
    },
    "comment": " "
  },
  "can.List.prototype.forEach": {
    "type": "function",
    "name": "can.List.prototype.forEach",
    "parent": "can.List.prototype",
    "src": {
      "line": 811,
      "codeLine": 832,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`forEach` calls a callback for each element in the List.\n\n```\nvar list = new can.List([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.attr(index, element * element);\n});\nlist.attr(); // [1, 4, 9]\n```\n \n",
    "description": "Call a function for each element of a List. ",
    "title": "forEach",
    "signatures": [
      {
        "code": "list.forEach(callback[, thisArg])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "element"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "a function to call with each element of the List\nThe three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the\ncurrent element of the list, and _list_ the List the elements are coming from. _callback_ is \nnot invoked for List elements that were never initialized."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "the object to use as `this` inside the callback\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "the object to use as `this` inside the callback\n"
    },
    "comment": " "
  },
  "can.List.prototype.replace": {
    "type": "function",
    "name": "can.List.prototype.replace",
    "parent": "can.List.prototype",
    "src": {
      "line": 843,
      "codeLine": 905,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`replace` replaces all the elements of this List with new ones.\n\n`replace` is especially useful when `can.List`s are live-bound into `[can.Control]`s,\nand you intend to populate them with the results of a `[can.Model]` call:\n\n```\ncan.Control({\n    init: function() {\n        this.list = new Todo.List();\n        // live-bind the list into the DOM\n        this.element.html(can.view('list.stache', this.list));\n        // when this AJAX call returns, the live-bound DOM will be updated\n        this.list.replace(Todo.findAll());\n    }\n});\n```\n\nLearn more about [can.Model.List making Lists of models].\n\n## Events\n\nA major difference between `replace` and `attr(newElements, true)` is that `replace` always emits\nan _add_ event and a _remove_ event, whereas `attr` will cause _set_ events along with an _add_ or _remove_\nevent if needed. Corresponding _change_ and _length_ events will be fired as well.\n\nThe differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:\n```\nvar attrList = new can.List(['Alexis', 'Bill']);\nattrList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nvar replaceList = new can.List(['Alexis', 'Bill']);\nreplaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nattrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n                                              // 1, set, Ben, Bill\nreplaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n                                              // 0, add, ['Adam', 'Ben'], ['Alexis', 'Bill']\n\nattrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n                                              // 1, remove, undefined, Ben\nreplaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n                                              // 0, add, Amber, ['Adam', 'Ben']\n\nattrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n                                              // 1, add, ['Bob', 'Eve'], undefined\nreplaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n                                              // 0, add, ['Alice', 'Bob', 'Eve'], Amber\n```\n \n",
    "description": "Replace all the elements of a List. ",
    "title": "replace",
    "signatures": [
      {
        "code": "list.replace(collection)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can.List"
              },
              {
                "type": "can.Deferred"
              }
            ],
            "name": "collection",
            "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can.List`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can.List"
        },
        {
          "type": "can.Deferred"
        }
      ],
      "name": "collection",
      "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can.List`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
    },
    "comment": " "
  },
  "can-list": {
    "src": {
      "path": "node_modules/can-list/docs/list.md"
    },
    "body": "\n\nUse for observable array-like objects.\n\n\n## Use\n\n`List` is used to observe changes to an Array.  `List` extends `[can-map]`, so all the\nways that you're used to working with Maps also work here.\n\nUse [can-list::attr attr] to read and write properties of a list:\n\n    var hobbies = new List([\"JS\",\"Party Rocking\"])\n    hobbies.attr(0)        //-> \"JS\"\n    hobbies.attr(\"length\") //-> 2\n\n    hobbies.attr(0,\"JavaScript\")\n\n    hobbies.attr()         //-> [\"JavaScript\",\"Party Rocking\"]\n\nJust as you shouldn't set properties of an Map directly, you shouldn't change elements\nof a List directly. Always use `attr` to set the elements of a List, or use [can-list::push push],\n[can-list::pop pop], [can-list::shift shift], [can-list::unshift unshift], or [can-list::splice splice].\n\nHere is a tour through the forms of `List`'s `attr` that parallels the one found under [can-map.prototype.attr attr]:\n\n```\nvar people = new List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\npeople[0] = 'Adam'; // don't do this!\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']\n```\n\n## Listening to changes\n\nAs with `Map`s, the real power of observable arrays comes from being able to\nreact to changes in the member elements of the array. Lists emit five types of events:\n\n- the _change_ event fires on every change to a List.\n- the _set_ event is fired when an element is set.\n- the _add_ event is fired when an element is added to the List.\n- the _remove_ event is fired when an element is removed from the List.\n- the _length_ event is fired when the length of the List changes.\n\nThis example presents a brief concrete survey of the times these events are fired:\n\n```\nvar list = new List(['Alice', 'Bob', 'Eve']);\n\nlist.bind('change', function() { console.log('An element changed.'); });\nlist.bind('set', function() { console.log('An element was set.'); });\nlist.bind('add', function() { console.log('An element was added.'); });\nlist.bind('remove', function() {\n  console.log('An element was removed.');\n});\nlist.bind('length', function() {\n  console.log('The length of the list changed.');\n});\n\nlist.attr(0, 'Alexis'); // 'An element changed.'\n                        // 'An element was set.'\n\nlist.attr(3, 'Xerxes'); // 'An element changed.'\n                        // 'An element was added.'\n                        // 'The length of the list was changed.'\n\nlist.attr(['Adam', 'Bill']); // 'An element changed.'\n                             // 'An element was set.'\n                             // 'An element was changed.'\n                             // 'An element was set.'\n\nlist.pop(); // 'An element changed.'\n            // 'An element was removed.'\n            // 'The length of the list was changed.'\n```\n\nMore information about binding to these events can be found under [can-list::attr attr].\n\n",
    "description": "\n",
    "name": "can-list",
    "type": "module",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "inherits": "can",
    "download": "can/list",
    "test": "can/list/test.html",
    "parent": "can-legacy",
    "release": "2.0",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-list"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-list/issues"
      },
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-construct": "^3.0.0",
        "can-event": "^3.3.0",
        "can-map": "^3.0.7",
        "can-namespace": "1.0.0",
        "can-observation": "^3.0.1",
        "can-types": "^1.0.1",
        "can-util": "^3.2.2"
      },
      "description": "Observable lists",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-map-define": "^3.0.2",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-list",
      "name": "can-list",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-list.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.5"
    },
    "link": "../docco/list/list.html docco",
    "signatures": [
      {
        "code": "new List([array])",
        "description": "\n\nCreate an observable array-like object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "array",
            "description": "Items to seed the List with.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "An instance of `List` with the elements from _array_.\n"
        }
      },
      {
        "code": "new List(deferred)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can.Deferred"
              }
            ],
            "name": "deferred",
            "description": "A deferred that resolves to an\narray.  When the deferred resolves, its values will be added to the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "An initially empty `List`.  \n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-list"
        }
      ],
      "description": "An initially empty `List`.  \n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can.Deferred"
        }
      ],
      "name": "deferred",
      "description": "A deferred that resolves to an\narray.  When the deferred resolves, its values will be added to the list.\n"
    },
    "comment": " "
  },
  "static": {
    "src": {
      "line": 344,
      "codeLine": 347,
      "path": "node_modules/can-route/can-route.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "static",
    "parent": null,
    "title": "static"
  },
  "prototype": {
    "src": {
      "line": 10,
      "codeLine": 13,
      "path": "node_modules/can-simple-map/can-simple-map.js"
    },
    "type": "prototype",
    "body": "",
    "description": " \n",
    "name": "prototype",
    "parent": null,
    "title": "prototype"
  },
  "can-map": {
    "src": {
      "path": "node_modules/can-map/docs/map.md"
    },
    "body": "\n## Use\n\nWatch this video to see an example of creating an ATM machine using can.Map:\n\n<iframe width=\"662\" height=\"372\" src=\"https://www.youtube.com/embed/QP9mHyxZNiI\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n`Map` provides a way for you to listen for and keep track of changes\nto objects. When you use the getters and setters provided by `Map`,\nevents are fired that you can react to. `Map` also has support for\nworking with deep properties. Observable arrays are also available with\n`[can-list]`, which is based on `Map`.\n\n## Working with Observes\n\nTo create an Observe, use `new Map([props])`. This will return a\ncopy of `props` that emits events when its properties are changed with\n`[can-map.prototype.attr attr]`.\n\nYou can read the values of properties on Observes directly, but you should\nnever set them directly. You can also read property values using `attr`.\n\n\n    var aName = {a: 'Alexis'},\n        map = new can.Map(aName);\n\n    // Observes are copies of data:\n    aName === map; // false\n\n    // reading from an Observe:\n    map.attr();    // {a: 'Alexis'}\n    map.a;         // 'Alexis'\n    map.attr('a'); // 'Alexis'\n\n    // setting an Observe's property:\n    map.attr('a', 'Alice');\n    map.a; // Alice\n\n    // removing an Observe's property;\n    map.removeAttr('a');\n    map.attr(); // {}\n\n    // Don't do this!\n    map.a = 'Adam'; // wrong!\n\n\nFind out more about manipulating properties of a map under\n[can.Map.prototype.attr attr] and [can.Map.prototype.removeAttr removeAttr].\n\n## Listening to changes\n\nThe real power of maps comes from being able to react to\nproperties being added, set, and removed. Maps emit events when\nproperties are changed that you can bind to.\n\n`Map` has two types of events that fire due to changes on a map:\n- the _change_ event fires on every change to a map.\n- an event named after the property name fires on every change to that property.\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('Something on o changed.');\n    });\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log('a was changed.');\n    });\n\n    o.attr('a', 'Alexis'); // 'Something on o changed.'\n                           // 'a was changed.'\n    o.attr({\n        'a': 'Alice',      // 'Something on o changed.' (for a's change)\n        'b': 'Bob'         // 'Something on o changed.' (for b's change)\n    });                    // 'a was changed.'\n\n    o.removeAttr('a');     // 'Something on o changed.'\n                           // 'a was changed.'\n\n\nFor more detail on how to use these events, see [can.Map.prototype.bind bind] and\n[can.Map.prototype.unbind unbind]. There is also a plugin called [can.Map.delegate]\nthat makes binding to specific types of events easier:\n\n\n    var o = new Map({});\n    o.delegate('a', 'add', function(ev, newVal, oldVal) {\n        console.log('a was added.');\n    });\n    o.delegate('a', 'set', function(ev, newVal, oldVal) {\n        console.log('a was set.');\n    });\n    o.delegate('a', 'remove', function(ev, newVal, oldVal) {\n        console.log('a was removed.');\n    });\n    o.delegate('a', 'change', function(ev, newVal, oldVal) {\n        console.log('a was changed.');\n    });\n\n    o.attr('a', 'Alexis'); // 'a was added.'\n                           // 'a was changed.'\n\n    o.attr('a', 'Alice'); // 'a was set.'\n                          // 'a was changed.'\n\n    o.removeAttr('a'); // 'a was removed.'\n                       // 'a was changed.'\n\n## Object.prototype.watch\n\nDue to a method available on the base Object prototype called \"watch\", refrain from\nusing properties with the same name on Gecko based browsers as there will be a\ncollision. [Source](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/watch)\n\n",
    "description": "Create observable objects. \n",
    "name": "can-map",
    "type": "module",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "inherits": "can",
    "parent": "can-legacy",
    "test": "can/map/test.html",
    "plugin": "can/map",
    "release": "2.0",
    "link": "../docco/map/map.html docco",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-map"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-map/issues"
      },
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-compute": "^3.0.8",
        "can-construct": "^3.0.0",
        "can-event": "^3.3.0",
        "can-namespace": "^1.0.0",
        "can-observation": "^3.0.1",
        "can-types": "^1.0.1",
        "can-util": "^3.2.2"
      },
      "description": "Observable Objects",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-map",
      "name": "can-map",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-map.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.0.7"
    },
    "signatures": [
      {
        "code": "new Map([props])",
        "description": "\n\nCreates a new instance of can.Map.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the Observe with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "An instance of `can.Map` with the properties from _props_.\n"
        }
      },
      {
        "code": "Map.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function.\n\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "An instance of `can.Map` with the properties from _props_.\n"
    },
    "comment": " "
  },
  "can-namespace": {
    "src": {
      "path": "node_modules/can-namespace/can-namespace.md"
    },
    "body": "\n## Use\n\n`can-namespace` exports an object that can be used to ensure only one version of a module is loaded in an app.\n\nFor example, if you have a module `can-unicorn` that you want to make sure is only loaded a single time, you can use `can-namespace`:\n\n```js\nvar namespace = require('can-namespace');\n\nvar unicorn = {\n\t// ...\n};\n\nif (namespace.unicorn) {\n\tthrow new Error(\"You can't have two versions of can-unicorn, check your dependencies\");\n} else {\n\tmodule.exports = namespace.unicorn = unicorn;\n}\n```\n\nAny module requiring `can-namespace` will receive the same module because only one version of `can-namespace` will ever be published.\n\n",
    "description": "Namespace where can-* packages are registered \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "object"
      }
    ],
    "name": "can-namespace",
    "parent": "can-infrastructure",
    "release": "1.0",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-namespace/issues"
      },
      "dependencies": {},
      "description": "Namespace where can-* packages are registered",
      "devDependencies": {},
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-namespace",
      "name": "can-namespace",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-namespace.git"
      },
      "scripts": {},
      "system": {
        "npmAlgorithm": "flat"
      },
      "version": "1.0.0"
    },
    "comment": " "
  },
  "can-observation.prototype": {
    "name": "can-observation.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation.static": {
    "name": "can-observation.static",
    "title": "static",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation.types": {
    "name": "can-observation.types",
    "title": "types",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation": {
    "type": "module",
    "name": "can-observation",
    "parent": "can-infrastructure",
    "src": {
      "line": 21,
      "codeLine": 94,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "\n\n## Use\n\nInstances of `Observation` are rarely created directly.  Instead, use [can-compute]'s more friendly API to\nobserve when a function's value changes. [can-compute] uses `can-observation` internally.\n\n`Observation`'s static methods like: [can-observation.add], [can-observation.ignore], and [can-observation.trap]\nare used more commonly to control which observable events a compute will listen to.\n\nTo use `can-observation` directly, create something observable (supports `addEventListener`) and\ncalls [can-observation.add] like:\n\n```js\nvar Observation = require(\"can-observation\");\nvar assign = require(\"can-util/js/assign/assign\");\nvar canEvent = require(\"can-event\");\n\nvar me = assign({}, canEvent);\n\nvar name = \"Justin\";\nObject.defineProperty(me,\"name\",{\n  get: function(){\n    Observation.add(this,\"name\");\n    return name;\n  },\n  set: function(newVal) {\n    var oldVal = name;\n    name = newVal;\n    this.dispatch(\"name\", newVal, oldVal);\n  }\n})\n```\n\nNext, create an observation instance with a function that reads the observable value:\n\n```js\nvar observation = new Observation(function(){\n  return \"Hello \"+me.name;\n}, null, function(newVal, oldVal, batchNum){\n  console.log(newVal);\n})\n```\n\nFinally, call `observation.start()` to start listening and be notified of changes:\n\n```js\nobservation.start();\nobservation.value   //-> \"Hello Justin\";\nme.name = \"Ramiya\"; // console.logs -> \"Hello Ramiya\"\n```\n\n",
    "description": "\nProvides a mechanism to notify when an observable has been read and a\nway to observe those reads called within a given function.\n",
    "title": "",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-observation"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-observation/issues"
      },
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-event": "^3.3.0",
        "can-namespace": "1.0.0",
        "can-types": "^1.0.1",
        "can-util": "^3.5.0"
      },
      "description": "Core observable indicators",
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "can-compute": "^3.0.4",
        "can-define": "^1.0.1",
        "can-map": "^3.0.3",
        "done-serve": "^1.2.0",
        "donejs-cli": "^1.0.1",
        "generator-donejs": "^1.0.5",
        "jshint": "^2.9.1",
        "steal": "^1.2.3",
        "steal-benchmark": "0.0.1",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.5.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-observation",
      "name": "can-observation",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-observation.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint *.js reader/*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.1.5"
    },
    "signatures": [
      {
        "code": "new Observation(func, context, compute)",
        "description": "\n\nCreates an observation of a given function called with `this` as\na given context. Calls back `compute` when the return value of `func` changes.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "func",
            "description": "The function whose value is being observed."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "What `this` should be when `func` is called."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "can-compute"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldValue"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "batchNum"
                  }
                ]
              }
            ],
            "name": "updated",
            "description": "A function to call when `func`'s return value changes.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "can-compute"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "oldValue"
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ],
              "name": "batchNum"
            }
          ]
        }
      ],
      "name": "updated",
      "description": "A function to call when `func`'s return value changes.\n"
    },
    "comment": " "
  },
  "can-observation.prototype.start": {
    "type": "function",
    "name": "can-observation.prototype.start",
    "parent": "can-observation.prototype",
    "src": {
      "line": 209,
      "codeLine": 219,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "start",
    "signatures": [
      {
        "code": "observation.start()",
        "description": "\n\nStarts observing changes and adds event listeners. [can-observation.prototype.value] will\nbe available.\n\n ",
        "params": []
      }
    ]
  },
  "can-observation.prototype.stop": {
    "type": "function",
    "name": "can-observation.prototype.stop",
    "parent": "can-observation.prototype",
    "src": {
      "line": 260,
      "codeLine": 269,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "stop",
    "signatures": [
      {
        "code": "observation.stop()",
        "description": "\n\nStops observing changes and removes all event listeners.\n\n ",
        "params": []
      }
    ]
  },
  "can-observation.prototype.value": {
    "src": {
      "line": 278,
      "codeLine": 287,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "type": "property",
    "body": "\n \n",
    "description": "\nThe return value of the function once [can-observation.prototype.start] is called.\n",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "",
    "name": "can-observation.prototype.value"
  },
  "can-observation.observed": {
    "name": "can-observation.observed",
    "type": "typedef",
    "parent": "can-observation.types",
    "src": {
      "line": 287,
      "codeLine": 303,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": " \nAn object representing an observation.\n\n```js\n{ \"obj\": map, \"event\": \"prop1\" }\n```\n\n",
    "title": "Observed",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "obj",
            "description": "The observable object",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "event",
            "description": "The event, or more likely property, that is being observed.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ]
  },
  "can-observation.add": {
    "type": "function",
    "name": "can-observation.add",
    "parent": "can-observation.static",
    "src": {
      "line": 443,
      "codeLine": 463,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "\n",
    "description": "\nSignals that an object's property is being observed, so that any functions\nthat are recording observations will see that this object is a dependency.\n",
    "title": "add",
    "signatures": [
      {
        "code": "Observation.add(obj, event)",
        "description": "\n\nSignals that an event should be observed. Adds the observable being read to\nthe top of the stack.\n\n```js\nObservation.add(obj, \"prop1\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An observable object which is being observed."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event (or property) that is being observed.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "event",
      "description": "The name of the event (or property) that is being observed.\n\n"
    }
  },
  "can-observation.addAll": {
    "type": "function",
    "name": "can-observation.addAll",
    "parent": "can-observation.static",
    "src": {
      "line": 481,
      "codeLine": 500,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "addAll",
    "signatures": [
      {
        "code": "Observation.addAll(observes)",
        "description": "\n\nThe same as `Observation.add` but takes an array of [can-observation.observed] objects.\nThis will most often by used in coordination with [can-observation.trap]:\n\n```js\nvar untrap = Observation.trap();\n\nObservation.add(obj, \"prop3\");\n\nvar traps = untrap();\nOservation.addAll(traps);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-observation.observed"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "observes",
            "description": "An array of [can-observation.observed]s.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-observation.observed"
                }
              ]
            }
          ]
        }
      ],
      "name": "observes",
      "description": "An array of [can-observation.observed]s.\n"
    }
  },
  "can-observation.ignore": {
    "type": "function",
    "name": "can-observation.ignore",
    "parent": "can-observation.static",
    "src": {
      "line": 521,
      "codeLine": 544,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "ignore",
    "signatures": [
      {
        "code": "Observation.ignore(fn)",
        "description": "\n\nCreates a function that, when called, will prevent observations from\nbeing applied.\n\n```js\nvar fn = Observation.ignore(function(){\n  // This will be ignored\n  Observation.add(obj, \"prop1\");\n});\n\nfn();\nObservation.trapCount(); // -> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "Any function that contains potential calls to\n[Observation.add].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function that is free of observation side-effects.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "Any function that contains potential calls to\n[Observation.add].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function that is free of observation side-effects.\n"
    }
  },
  "can-observation.trap": {
    "type": "function",
    "name": "can-observation.trap",
    "parent": "can-observation.static",
    "src": {
      "line": 559,
      "codeLine": 578,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "trap",
    "signatures": [
      {
        "code": "Observation.trap()",
        "description": "\n\nTrap all observations until the `untrap` function is called. The state of\ntraps prior to `Observation.trap()` will be restored when `untrap()` is called.\n\n```js\nvar untrap = Observation.trap();\n\nObservation.add(obj, \"prop1\");\n\nvar traps = untrap();\nconsole.log(traps[0].obj === obj); // -> true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-observation.getTrapped"
            }
          ],
          "description": "A function to get the trapped observations.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-observation.getTrapped"
        }
      ],
      "description": "A function to get the trapped observations.\n"
    }
  },
  "can-observation.getTrapped": {
    "type": "typedef",
    "name": "can-observation.getTrapped",
    "parent": "can-observation.types",
    "src": {
      "line": 591,
      "codeLine": 602,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "getTrapped",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "getTrapped()",
        "description": "\n\n  Returns the trapped observables captured by [can-observation.trap].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-observation.observed"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-observation.observed"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    }
  },
  "can-observation.isRecording": {
    "type": "function",
    "name": "can-observation.isRecording",
    "parent": "can-observation.static",
    "src": {
      "line": 612,
      "codeLine": 621,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "isRecording",
    "signatures": [
      {
        "code": "Observation.isRecording()",
        "description": "\n\nReturns if some function is in the process of recording observes.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if a function is in the process of recording observes.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if a function is in the process of recording observes.\n"
    }
  },
  "can-param": {
    "src": {
      "path": "node_modules/can-param/can-param.md"
    },
    "body": "",
    "description": "Serialize an object or array into a query string. \n",
    "type": "module",
    "title": "can-param",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-param",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "param(object)",
        "description": "\n\nSerializes an object or array into a query string useful for making Ajax requests. `param` handles nested objects and arrays.  It uses `encodeURIComponent` to\nescape values and keys.\n\n```js\nvar param = require(\"can-param\");\n\nparam({foo: \"bar\"})          //-> \"foo=bar\"\nparam({foo: [\"bar\", \"baz\"]}) //-> \"foo[]=bar&foo[]=baz\"\nparam({foo: {bar: \"baz\"}})    //-> \"foo[bar]=baz\"\nparam({foo: \"bar & baz\"})    //-> \"foo=bar+%26+baz\"\n```\n\nThis is exported as `param` on [can-namespace].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "An object or array."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The params formatted into a form-encoded string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "object",
      "description": "An object or array."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The params formatted into a form-encoded string.\n"
    }
  },
  "can-route.param": {
    "type": "function",
    "name": "can-route.param",
    "parent": "can-route.static",
    "src": {
      "line": 349,
      "codeLine": 377,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Parameterizes the raw JS object representation provided in data.\n\n```js\nroute.param({ type: \"video\", id: 5 });\n  // -> \"type=video&id=5\"\n```\n\nIf a route matching the provided data is found, that URL is built\nfrom the data. Any remaining data is added at the end of the\nURL as &amp; separated key/value parameters.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.param({ type: \"video\", id: 5 }) // -> \"video/5\"\nroute.param({ type: \"video\", id: 5, isNew: false })\n  // -> \"video/5&isNew=false\"\n```\n \n",
    "description": "Get a route path from given data. ",
    "title": "param",
    "signatures": [
      {
        "code": "route.param(data)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "data"
              }
            ],
            "name": "object",
            "description": "The data to populate the route with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The route, with the data populated in it.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "data"
        }
      ],
      "name": "object",
      "description": "The data to populate the route with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The route, with the data populated in it.\n"
    },
    "comment": " "
  },
  "can-route.deparam": {
    "type": "function",
    "name": "can-route.deparam",
    "parent": "can-route.static",
    "src": {
      "line": 445,
      "codeLine": 497,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\nCreates a data object based on the query string passed into it. This is\nuseful to create an object based on the `location.hash`.\n\n```js\nroute.deparam(\"id=5&type=videos\");\n  // -> { id: 5, type: \"videos\" }\n```\n\n\nIt's important to make sure the hash or exclamation point is not passed\nto `route.deparam` otherwise it will be included in the first property's\nname.\n\n```js\nroute.data.id = 5 // location.hash -> #!id=5\nroute.data.type = \"videos\"\n  // location.hash -> #!id=5&type=videos\nroute.deparam(location.hash);\n  // -> { #!id: 5, type: \"videos\" }\n```\n\n`route.deparam` will try and find a matching route and, if it does,\nwill deconstruct the URL and parse out the key/value parameters into the\ndata object.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.deparam(\"videos/5\");\n  // -> { id: 5, route: \"{type}/{id}\", type: \"videos\" }\n```\n \n",
    "description": "Extract data from a route path. ",
    "title": "deparam",
    "signatures": [
      {
        "code": "route.deparam(url)",
        "description": "\n\nExtract data from a url, creating an object representing its values.\n\n```js\nroute(\"{page}\");\n\nvar result = route.deparam(\"page=home\");\nconsole.log(result.page); // -> \"home\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "url",
            "description": "A route fragment to extract data from."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object containing the extracted data.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "url",
      "description": "A route fragment to extract data from."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object containing the extracted data.\n"
    },
    "comment": " "
  },
  "static.routes": {
    "name": "static.routes",
    "type": "property",
    "parent": "static",
    "src": {
      "line": 556,
      "codeLine": 575,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n - test - A regular expression that will match the route when variable values\n   are present; i.e. for {page}/{type} the `RegExp` is /([\\w\\.]*)/([\\w\\.]*)/ which\n   will match for any value of {page} and {type} (word chars or period).\n\n - route - The original URL, same as the index for this entry in routes.\n\n - names - An array of all the variable names in this route\n\n - defaults - Default values provided for the variables or an empty object.\n\n - length - The number of parts in the URL separated by '/'.\n \n",
    "description": "\nA list of routes recognized by the router indixed by the url used to add it.\nEach route is an object with these members:\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "",
    "hide": true
  },
  "can-route.ready": {
    "type": "function",
    "name": "can-route.ready",
    "parent": "can-route.static",
    "src": {
      "line": 576,
      "codeLine": 608,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n\n## Use\n\nAfter setting all your routes, call `route.ready()`.\n\n```js\nroute(\"overview/{dateStart}-{dateEnd}\");\nroute(\"{type}/{id}\");\nroute.ready();\n```\n \n",
    "description": "\nInitializes can-route.\n",
    "title": "ready",
    "signatures": [
      {
        "code": "route.ready()",
        "description": "\n\nSets up the two-way binding between the hash and the can-route observable\nmap and sets the route map to its initial values.\n\n```js\nroute(\"{page}\", { page: \"home\" }));\n\nroute.ready();\nroute.data.page; // -> \"home\"\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-route"
            }
          ],
          "description": "The can-route object.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-route"
        }
      ],
      "description": "The can-route object.\n"
    },
    "comment": " "
  },
  "can-route.url": {
    "type": "function",
    "name": "can-route.url",
    "parent": "can-route.static",
    "src": {
      "line": 617,
      "codeLine": 657,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Similar to [can-route.link], but instead of creating an anchor tag,\n`route.url` creates only the URL based on the route options passed into it.\n\n```js\nroute.url( { type: \"videos\", id: 5 } );\n  // -> \"#!type=videos&id=5\"\n```\n\nIf a route matching the provided data is found the URL is built from the\ndata. Any remaining data is added at the end of the URL as & separated\nkey/value parameters.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.url( { type: \"videos\", id: 5 } ) // -> \"#!videos/5\"\nroute.url( { type: \"video\", id: 5, isNew: false } )\n  // -> \"#!video/5&isNew=false\"\n```\n \n",
    "description": "Creates a URL fragment based on registered routes given a set of data. ",
    "title": "url",
    "signatures": [
      {
        "code": "route.url(data [, merge])",
        "description": "\n\nMake a URL fragment that when set to window.location.hash will update can-route's properties\nto match those in `data`.\n\n```js\nroute.url({ page: \"home\" });\n// -> \"#!page=home\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The data to populate the route with."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Whether the given options should be merged into\nthe current state of the route."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The route URL and query string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "merge",
      "description": "Whether the given options should be merged into\nthe current state of the route."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The route URL and query string.\n"
    },
    "comment": " "
  },
  "can-route.link": {
    "type": "function",
    "name": "can-route.link",
    "parent": "can-route.static",
    "src": {
      "line": 666,
      "codeLine": 716,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Creates and returns an anchor tag with an href of the route\nattributes passed into it, as well as any properties desired\nfor the tag.\n\n```js\nroute.link( \"My videos\", { type: \"videos\" }, {}, false )\n  // -> <a href=\"#!type=videos\">My videos</a>\n```\n\nOther attributes besides href can be added to the anchor tag\nby passing in a data object with the attributes desired.\n\n```js\nroute.link( \"My videos\", { type: \"videos\" },\n  { className: \"new\" }, false )\n    // -> <a href=\"#!type=videos\" class=\"new\">My Videos</a>\n```\n\nIt is possible to utilize the current route options when making anchor\ntags in order to make your code more reusable. If merge is set to true,\nthe route options passed into `canRoute.link` will be passed into the\ncurrent ones.\n\n```js\nlocation.hash = \"#!type=videos\"\nroute.link( \"The zoo\", { id: 5 }, true )\n  // -> <a href=\"#!type=videos&id=5\">The zoo</true>\n\nlocation.hash = \"#!type=pictures\"\nroute.link( \"The zoo\", { id: 5 }, true )\n  // -> <a href=\"#!type=pictures&id=5\">The zoo</true>\n```\n \n",
    "description": "Creates a string representation of an anchor link using data and the registered routes.\n",
    "title": "link",
    "signatures": [
      {
        "code": "route.link(innerText, data, props [, merge])",
        "description": "\n\nMake an anchor tag (`<A>`) that when clicked on will update can-route's\nproperties to match those in `data`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "innerText",
            "description": "The text inside the link."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The data to populate the route with."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "Properties for the anchor other than `href`."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Whether the given options should be merged into the current state of the route."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A string with an anchor tag that points to the populated route.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "merge",
      "description": "Whether the given options should be merged into the current state of the route."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A string with an anchor tag that points to the populated route.\n"
    },
    "comment": " "
  },
  "can-route.current": {
    "type": "function",
    "name": "can-route.current",
    "parent": "can-route.static",
    "src": {
      "line": 722,
      "codeLine": 766,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n\n## Use\n\nChecks the page's current URL to see if the route represents the options\npassed into the function.\n\nReturns true if the options represent the current URL.\n\n```js\nroute.data.id = 5; // location.hash -> \"#!id=5\"\nroute.current({ id: 5 }); // -> true\nroute.current({ id: 5, type: 'videos' }); // -> false\n\nroute.data.type = 'videos';\n  // location.hash -> #!id=5&type=videos\nroute.current({ id: 5, type: 'videos' }); // -> true\n```\n \n",
    "description": "\nCheck if data represents the current route.\n",
    "title": "current",
    "signatures": [
      {
        "code": "route.current(data [,subsetMatch] )",
        "description": "\n\nCompares `data` to the current route. Used to verify if an object is\nrepresentative of the current route.\n\n```\nroute.data.set({page: \"recipes\", id: '5'});\n\nroute.current({page: \"recipes\"});       //-> false\nroute.current({page: \"recipes\"}, true); //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "Data to check agains the current route."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If true, `route.current` will return true\nif every value in `data` matches the current route data, even if\nthe route data has additional properties that are not matched.  Defaults to `false`\nwhere every property needs to be present."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Whether the data matches the current URL.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "subsetMatch",
      "description": "If true, `route.current` will return true\nif every value in `data` matches the current route data, even if\nthe route data has additional properties that are not matched.  Defaults to `false`\nwhere every property needs to be present."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Whether the data matches the current URL.\n"
    },
    "comment": " "
  },
  "can-route.matched": {
    "name": "can-route.matched",
    "type": "function",
    "parent": "can-route.static",
    "src": {
      "line": 848,
      "codeLine": 869,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Use `route.matched()` to find the currently matched route.\n\n```js\nroute(\"{type}\", { type: \"foo\" });\nroute(\"{type}/{subtype}\");\n\nroute.matched(); // \"{type}\"\n\nroute.data.subtype = \"foo\";\n\nroute.matched(); // \"{type}/{subtype}\"\n```\n \n",
    "description": "A compute representing the currently matched route. ",
    "title": "matched",
    "signatures": [
      {
        "code": "route.matched()",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The currently matched route.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The currently matched route.\n"
    },
    "comment": " "
  },
  "can-route.static": {
    "name": "can-route.static",
    "title": "static",
    "type": "group",
    "parent": "can-route",
    "description": "",
    "order": 0
  },
  "can-route": {
    "src": {
      "path": "node_modules/can-route/can-route.md"
    },
    "body": "\r\n## Use\r\n\r\n## Background information\r\n\r\nTo support the browser's back button and bookmarking in a JavaScript\r\n application, most applications use\r\nthe `window.location.hash`.  By\r\nchanging the hash (via a link or JavaScript),\r\none is able to add to the browser's history\r\nwithout changing the page.\r\n\r\nThis provides the basics needed to\r\ncreate history enabled single-page apps.  However,\r\n`route` addresses several other needs such as:\r\n\r\n  - Pretty urls.\r\n  - Keeping routes independent of application code.\r\n  - Listening to specific parts of the history changing.\r\n  - Setup / Teardown of widgets.\r\n\r\n## How it works\r\n\r\ncan-route is a map that represents the\r\n`window.location.hash` as an\r\nobject.  For example, if the hash looks like:\r\n\r\n    #!type=videos&id=5\r\n\r\nthe data in can-route looks like:\r\n\r\n    { type: 'videos', id: 5 }\r\n\r\ncan-route keeps the state of the hash in-sync with the `data` contained within it.\r\n\r\n## data\r\n\r\nUnderlying can-route is an observable map: `route.data`. Depending on what type of map your application uses this could be a [can-map], a [can-define/map/map], or maybe even a [can-simple-map].\r\n\r\nUnderstanding how maps work is essential to understanding can-route.\r\n\r\nYou can listen to changes in a map with `on(eventName, handler(ev, args...))` and change can-route's properties by modifying `route.data`.\r\n\r\n### Listening to changes in can-route\r\n\r\nListen to changes in history by [can-event.addEventListener listening] to\r\nchanges in can-route like:\r\n\r\n```js\r\nroute.on('foo', function(ev, attr, how, newVal, oldVal) {\r\n\t// Foo changed!\r\n})\r\n```\r\n\r\n - `attr` - the name of the changed attribute\r\n - `how` - the type of Observe change event (add, set or remove)\r\n - `newVal`/`oldVal` - the new and old values of the attribute\r\n\r\n### Updating can-route\r\n\r\nWhen using a [can-define/map/map DefineMap] to back can-route, create changes in the route data by modifying it directly:\r\n\r\n```js\r\nroute.data.type = 'image';\r\n```\r\n\r\nOr change multiple properties at once like:\r\n\r\n```js\r\nroute.data.set({type: 'page', id: 5}, true);\r\n```\r\n\r\nWhen you make changes to can-route, they will automatically\r\nchange the <code>hash</code>.\r\n\r\nIf using [can-map] or [can-simple-map] to back your route, update `route.data` using `attr`.\r\n\r\n### Encoded `/`\r\n\r\nIf the change in your route data includes a `/`, the `/` will be encoded into `%2F`.\r\nYou will see this result in the URL and `location.hash`.\r\n\r\n```js\r\nroute.data.type = 'image/bar';\r\n// OR\r\nroute.attr('type', 'image/bar');\r\n```\r\n\r\nThe URL will look like this:\r\n\r\n    https://example.com/#!type=image%2Fbar\r\n\r\nThe location hash will look like this:\r\n\r\n    #!type=image%2Fbar\r\n\r\n## Creating a route\r\n\r\nUse `route(url, defaults)` to create a\r\nroute. A route is a mapping from a url to\r\nan object (that is the route's state).\r\nIn order to map to a specific properties in the url,\r\nprepend a colon to the name of the property like:\r\n\r\n```js\r\nroute(\"#!content/{type}\");\r\n```\r\n\r\nIf no routes are added, or no route is matched,\r\ncan-route's data is updated with the [can-route.deparam deparamed]\r\nhash.\r\n\r\n```js\r\nlocation.hash = \"#!type=videos\";\r\n// route -> {type : \"videos\"}\r\n```\r\n\r\nOnce routes are added and the hash changes,\r\ncan-route looks for matching routes and uses them\r\nto update can-route's data.\r\n\r\n```js\r\nroute(\"#!content/{type}\");\r\nlocation.hash = \"#!content/images\";\r\n// route -> {type : \"images\"}\r\nroute.data.type = \"songs\";\r\n// location.hash -> \"#!content/songs\"\r\n```\r\n\r\nDefault values can be added to a route:\r\n\r\n```js\r\nroute(\"content/{type}\",{type: \"videos\" });\r\nlocation.hash = \"#!content/\"\r\n// route -> {type : \"videos\"}\r\n// location.hash -> \"#!content/\"\r\n```\r\n\r\nDefaults can also be set on the root page of your app:\r\n\r\n```js\r\nroute(\"\", { page: \"index\" });\r\nlocation.hash = \"#!\";\r\n// route -> {page : \"index\"}\r\n// location.hash -> \"#!\"\r\n```\r\n\r\n## Initializing can-route\r\n\r\nAfter your application has created all of its routes, call [can-route.ready]\r\nto set can-route's data to match the current hash:\r\n\r\n```js\r\nroute.ready();\r\n```\r\n\r\n## Changing the route\r\n\r\nTypically, you don't set `location.hash`\r\ndirectly. Instead, you can change properties on can-route\r\nlike:\r\n\r\n```js\r\nroute.data.type = 'videos';\r\n```\r\n\r\nThis will automatically look up the appropriate\r\nroute and update the hash.\r\n\r\nOften, you want to create links. can-route provides\r\nthe [can-route.link] and [can-route.url] helpers to make this\r\neasy:\r\n\r\n```js\r\nroute.link(\"Videos\", {type: 'videos'});\r\n```\r\n\r\n## Finding the matched route\r\n\r\nThe matched route is stored in the compute `route.matched` and is used to set the `window.location.hash`. The process can-route uses to find the matched route is:\r\n  - Find all routes with all of their map properties set\r\n  - If multiple routes are matched, find the route with the highest number of set properties\r\n  - If multiple routes are still matched, use the route that was registered first\r\n\r\n### Find all routes with all of their map properties set\r\n\r\nIn order for a route to be matched, all of the map properties it uses must be set. For example, in the following route, `page` and `section` must be set in order for this route to be matched:\r\n\r\n```js\r\nroute('{page}/{section}');\r\nroute.ready();\r\n\r\nroute.data.page = 'contact';\r\nroute.data.section = 'email';\r\n\r\nroute.matched(); // \"{page}/{section}\"\r\n```\r\n\r\nIf a route contains default values, these map properties must also be set to match the default value in order for the route to be matched:\r\n\r\n```js\r\nroute('{page}', { section: 'email' });\r\nroute.ready();\r\n\r\nroute.data.page = 'contact';\r\nroute.data.section = 'email';\r\n\r\nroute.matched(); // \"{page}\"\r\n```\r\n\r\n### Find the route with the highest number of set properties\r\n\r\nIf multiple routes have all of their properties set, the route with the highest number of set properties will be used:\r\n\r\n```js\r\nroute('{page}');\r\nroute('{page}/{section}');\r\nroute.ready();\r\n\r\nroute.data.page = 'two';\r\nroute.data.section = 'a';\r\n\r\nroute.matched(); // \"{page}/{section}\"\r\n```\r\n\r\n### Find the route that was registered first\r\n\r\nIf multiple routes are still matched, the route that was registered first will be matched:\r\n\r\n```js\r\nroute('', { page: 'home' });\r\nroute('{section}');\r\nroute.ready();\r\n\r\nroute.data.page = 'home';\r\nroute.data.section = 'a';\r\n\r\nroute.matched(); // \"\"\r\n```\r\n\n",
    "description": "Manage browser history and client state by synchronizing the `window.location.hash` with a map. \r\n",
    "title": "can-route\r",
    "name": "can-route",
    "parent": "can-core",
    "type": "function",
    "download": "can/route\r",
    "test": "can-route/test.html",
    "link": "../docco/route/route.html docco",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-route"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-route/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-deparam": "^1.0.1",
        "can-event": "^3.0.1",
        "can-namespace": "1.0.0",
        "can-observation": "^3.0.1",
        "can-param": "^1.0.1",
        "can-simple-map": "^3.0.0",
        "can-types": "^1.0.1",
        "can-util": "^3.1.1"
      },
      "description": "[![Build Status](https://travis-ci.org/canjs/can-route.png?branch=master)](https://travis-ci.org/canjs/can-route)",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^1.0.1",
        "can-list": "^3.0.1",
        "can-map": "^3.0.3",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "https://github.com/canjs/can-route#readme",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-route",
      "name": "can-route",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-route.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.0.11"
    },
    "signatures": [
      {
        "code": "route(template [, defaults])",
        "description": "\n\r\nCreate a route matching rule. Optionally provide defaults that will be applied to the underlying map when the route matches.\r\n\r\n```js\r\nroute(\"{page}\", { page: \"home\" });\r\n```\r\n\r\nWill apply **cart** when the url is `#cart` and **home** when the url is `#`.\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "the fragment identifier to match.  The fragment identifier should contain characters (a-Z), optionally wrapped in braces ( { } ). Identifiers wrapped in braces are interpreted as being properties on can-route's map. Examples:\r\n\r\n```js\r\nroute(\"{foo}\")\r\nroute(\"foo/{bar}\")\r\n```\r\n\r"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "defaults",
            "description": "An object of default values. These defaults are applied to can-route's map when the route is matched.\r\n\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-route"
            }
          ],
          "description": "\n\r"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "defaults",
      "description": "An object of default values. These defaults are applied to can-route's map when the route is matched.\r\n\r"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-route"
        }
      ],
      "description": "\n\r"
    },
    "comment": " "
  },
  "can-route.data": {
    "src": {
      "path": "node_modules/can-route/route_data.md"
    },
    "body": "\r\n\r\n## Background\r\n\r\nOne of the biggest challenges in a complex application is getting all the different parts of the app to talk to each other simply, cleanly, and reliably. \r\n\r\nAn elegant way to solve this problem is using the [Observer Pattern](http://en.wikipedia.org/wiki/Observer_pattern). A single object, which can be called [Application ViewModel](https://www.youtube.com/watch?v=LrzK4exG5Ss), holds the high level state of the application.\r\n\r\n## Use\r\n\r\nSetting `route.data` is an easy way to cross-bind your Application ViewModel object to `route`. This will serialize your Application ViewModel into the hash (or pushstate URLs).\r\n\r\n```js\r\nvar ViewModel = DefineMap.extend({\r\n\tpetType: \"string\",\r\n\tstoreId: \"number\"\r\n});\r\n\r\nvar viewModel = new ViewModel({\r\n\tpetType: \"string\",\r\n\tstoreId: \"number\"\r\n});\r\n\r\nroute.data = viewModel;\r\n```\r\n\r\n`route.data` can also be set to a constructor function. A new instance will be created and bound to:\r\n\r\n```js\r\nvar ViewModel = DefineMap.extend({\r\n    page: {\r\n        type: \"string\",\r\n        set: function(page){\r\n            if(page === \"user\") {\r\n                this.verifyLoggedIn();\r\n            }\r\n            return page;\r\n        }\r\n    }\r\n});\r\n\r\nroute.data = ViewModel;\r\n```\r\n\r\n## When to set it\r\n\r\nSet `route.data` at the  start of the application lifecycle, before any calls to `route.addEventListener`. This will allow events to correctly bind on this new object.\r\n\r\n## Demo\r\n\r\nThe following shows creating an Application ViewModel that loads data at page load, has a virtual property 'locationIds' which serializes an array, and synchronizes the viewModel to can-route:\r\n\r\n<div class='demo_wrapper' data-demo-src='demos/can-route/data.html'></div>\n\r\n## Complete example\r\n\r\nThe following example shows loading some metadata on page load, which must be loaded as part of the Application ViewModel before the components can be initialized\r\n\r\nIt also shows an example of a \"virtual\" property on the AppViewModel, locationIds, which is the serialized version of a non-serializeable can.List, locations.  A setter is defined on locationIds, which will translate changes in locationIds back to the locations can.List.\r\n\r\n```js\r\nvar Location = DefineMap.extend({\r\n\tselected: \"boolean\",\r\n\tid: \"any\"\r\n});\r\n\r\nvar LocationList = DefineList.extend({\r\n\t\"*\": Location\r\n});\r\n\r\nvar AppViewModel = DefineMap.extend({\r\n\tlocations: {\r\n\t\ttype: \"any\",\r\n\t\t// don't serialize this property at all in the route\r\n\t\tserialize: false\r\n\t},\r\n\t// virtual property that contains a comma separated list of ids\r\n\t// based on locations that are selected\r\n\tlocationIds: {\r\n\r\n\t\t// comma separated list of ids\r\n\t\tserialize: function(){\r\n\t\t\tvar selected = thislocations.filter(\r\n\t\t\t\tfunction(location){\r\n\t\t\t\t\treturn location.selected;\r\n\t\t\t\t});\r\n\t\t\tvar ids = [];\r\n\t\t\tselected.each(function(item){\r\n\t\t\t\tids.push(item.id);\r\n\t\t\t})\r\n\t\t\treturn selected.join(',');\r\n\t\t},\r\n\t\t\r\n\t\t// toggle selected from a comma separated list of ids\r\n\t\tset: function(val){\r\n\t\t\tvar arr = val;\r\n\t\t\tif(typeof val === \"string\"){\r\n\t\t\t\tarr = val.split(',')\r\n\t\t\t}\r\n\t\t\t// for each id, toggle any matched location\r\n\t\t\tthis.locations.forEach(function(location){\r\n\t\t\t\tif(arr.indexOf(location.id) !== -1){\r\n\t\t\t\t\tlocation.selected = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlocation.selected = false;\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n});\r\n\r\n// initialize and set route.data first, so anything binding to can-route\r\n// will work correctly\r\nvar viewModel = new AppViewModel();\r\nroute.data = appViewModel;\r\n\r\n// GET /locations\r\nvar locations = new Location.List({});\r\n\r\n// when the data is ready, set the locations property\r\nlocations.done(function(){\r\n\tviewModel.locations = locations;\r\n\r\n\t// call ready after the AppViewModel is fully initialized\r\n\troute.ready();\r\n});\r\n```\r\n\r\n## Why\r\n\r\nThe Application ViewModel object, which is cross-bound to the can-route via `route.data` and represents the overall state of the application, has several obvious uses:\r\n\r\n* It is passed into the various components and used to communicate their own internal state.\r\n* It provides deep linking and back button support. As the URL changes, Application ViewModel changes cause changes in application components.\r\n* It provides the ability to \"save\" the current state of the page, by serializing the Application ViewModel object and saving it on the backend, then restoring with that object to load this saved state.\r\n\n",
    "description": "\r\nThis is the internal map underlying can-route. It can be set in order to cross-bind a top level state object (Application ViewModel) to can-route.\r\n",
    "title": "data\r",
    "name": "can-route.data",
    "type": "function",
    "parent": "can-route.static",
    "comment": " "
  },
  "route.pushstate.root": {
    "src": {
      "line": 33,
      "codeLine": 68,
      "path": "node_modules/can-route-pushstate/can-route-pushstate.js"
    },
    "type": "property",
    "body": "\n## Use\n\nBy default, a route like:\n\n    route(\":type/:id\")\n\nMatches urls like:\n\n    http://domain.com/contact/5\n\nBut sometimes, you only want to match pages within a certain directory.  For\nexample, an application that is a filemanager.  You might want to\nspecify root and routes like:\n\n    route.pushstate.root = \"/filemanager/\"\n    route(\"file-:fileId\");\n    route(\"folder-:fileId\")\n\nWhich matches urls like:\n\n    http://domain.com/filemanager/file-34234\n\n\t \n",
    "description": "Configure the base url that will not be modified. \n",
    "types": [
      {
        "type": "String",
        "description": "Represents the base url that pushstate will prepend to all\nroutes.  `root` defaults to: `\"/\"`.\n"
      }
    ],
    "title": "",
    "name": "route.pushstate.root",
    "parent": "route.pushstate",
    "comment": " "
  },
  "can-route-pushstate": {
    "src": {
      "path": "node_modules/can-route-pushstate/can-route-pushstate.md"
    },
    "body": "\n## Use\n\ncan-route-pushstate uses the same API as [can-route]. To start using can-route-pushstate all you need is to import `can-route-pushstate`, it will set itself as default binding on [can-route].\n\nYou can check current binding by inspecting `route.currentBinding`; the default value is `\"hashchange\"`.\n\n### Creating and changing routes\n\nTo create routes use `route(url, defaults)` like:\n\n```js\nroute(\"{page}\", {page: 'homepage'});\nroute(\"contacts/{username}\");\nroute(\"books/{genre}/{author}\");\n\nroute.ready(); // Initializes can-route\n```\n\nDo not forget to [can-route.ready initialize] can-route after creating all routes, do it by calling `route.ready()`.\n\nList of defined routes is contained in `route.routes`, you can examine current route state by calling:\n\n```js\nroute.attr(); //-> {page: \"homepage\", route: \"{page}\"}\n```\n\nAfter creating routes and initializing can-route you can update current route by calling `route.attr(attr, newVal)`:\n\n```js\nroute.attr('page', 'about');\nroute.attr(); //-> {page: \"about\", route: \"{page}\"}\n\n// without cleaning current route state\nroute.attr('username', 'veljko');\nroute.attr(); //-> {page: \"about\", route: \"{page}\", username: 'veljko'}\n\n// with cleaning current can-route state\nroute.attr({username: 'veljko'}, true);\nroute.attr(); //-> {username: \"veljko\", route: \"contacts/{username}\"}\n```\n\nTo update multiple attributes at once pass hash of attributes to `route.attr(hashOfAttrs, true)`. Pass `true` as second argument to clean up current state.\n\n```js\nroute.attr({genre: 'sf', author: 'adams'}, true);\nroute.attr(); //-> {genre: \"sf\", author: \"adams\", route: \"books/{genre}/{author}\"}\n```\n\n`window.location` acts as expected:\n\n```js\nwindow.location.pathname; //-> \"/books/sf/adams\"\nwindow.location.hash; //-> \"\", hash remains unchanged\n```\n\nTo generate urls use `route.url({attrs})`:\n\n```js\nroute.url({username: 'justinbmeyer'}); //-> '/contacts/justinbmeyer'\n```\n\n### Listening changes on matched route\n\nAs can-route contains a map that represents `window.location.pathname`, you can bind on it.\n\nTo bind to specific attributes on can-route:\n\n```js\nroute.bind('username', function(ev, newVal, oldVal) {\n\t//-> ev:     {EventObject}\n\t//-> newVal: 'nikica'\n\t//-> oldVal: 'veljko'\n});\n\nroute.attr({username: nikica}, true);\n```\n\n### Using different pathname root\n\ncan-route-pushstate has one additional property, `route.bindings.pushstate.root`, which specifies the part of that pathname that should not change. For example, if we only want to have pathnames within `http://example.com/contacts/`, we can specify a root like:\n\n```js\nroute.bindings.pushstate.root = \"/contacts/\"\nroute(\"{page}\");\nroute.url({page: \"list\"}) //-> \"/contacts/list\"\nroute.url({foo: \"bar\"})   //-> \"/contacts/?foo=bar\"\n```\n\nNow, all routes will start with `\"/contacts/\"`, the default `route.bindings.pushstate.root` value is `\"/\"`.\n\n## Planning route structure\n\nComplications can arise if your route structure mimics the folder structure inside your app's public directory.  For example, if you have a folder structure like the one in this url for your admin app...\n\n`/admin/users/list.js`\n\n... using a route of /admin/users on the same page that uses the list.js file will require the use of a trailing slash on all routes and links.  The browser already learned that '/admin/users' is folder.  Because folders were originally denoted by a trailing slash in a url, the browser will correct the url to be '/admin/users/'.  While it is possible to add the trailing slash in routes and listen for them, any link to the page that omits the trailing slash will not trigger the route handler.\n\n",
    "description": "Changes [can-route] to use [pushstate](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history)\nto change the window's [pathname](https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.pathname) instead\nof the [hash](https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.hash).\n\n```js\nvar route = require(\"can-route-pushstate\");\n\nroute(\"{page}\", { page: \"home\" });\nroute.ready();\n\nroute.attr(\"page\", \"user\");\n\nlocation.pathname; // -> \"/user\"\n```\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "The",
            "description": "pushstate object comprises several properties that configure the behavior of [can-route] to work with `history.pushstate`.\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can-route-pushstate",
    "parent": "can-core",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": [
            "can-route-pushstate"
          ]
        },
        "parent": "can-route-pushstate"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-route-pushstate/issues"
      },
      "dependencies": {
        "can-event": "^3.0.1",
        "can-route": "^3.0.0",
        "can-util": "^3.3.0"
      },
      "description": "Pushstate for can-route",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^1.0.1",
        "can-map": "^3.0.0-pre.3",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-route-pushstate",
      "name": "can-route-pushstate",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-route-pushstate.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.0.3"
    },
    "comment": " "
  },
  "can-simple-dom": {
    "src": {
      "path": "node_modules/can-simple-dom/can-simple-dom.md"
    },
    "body": "\nImplements a small subset of the WHATWG DOM specification.\n\n",
    "description": "\n# can-simple-dom\n",
    "name": "can-simple-dom",
    "type": "page"
  },
  "can-types": {
    "name": "can-types",
    "type": "module",
    "parent": "can-infrastructure",
    "src": {
      "line": 1,
      "codeLine": 30,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "\n## Use\n\n`can-types` exports an object with placeholder functions that\ncan be used to provide default types or test if something is of a certain type.\n\nThis is where the sausage of loose coupling modules takes place.\nModules that provide a type will overwrite one or multiple of these functions so\nthey take into account the new type.\n\nFor example, `can-define/map/map` might overwrite `isMapLike` to return true\nif the object is an instance of Map:\n\n```js\nvar types = require(\"can-types\");\nvar oldIsMapLike = types.isMapLike;\ntypes.isMapLike = function(obj){\n  return obj instanceof DefineMap || oldIsMapLike.apply(this, arguments);\n};\ntypes.DefaultMap = DefineMap;\n```\n\n",
    "description": "A stateful container for CanJS type information. \n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "comment": " "
  },
  "can-types.isMapLike": {
    "type": "function",
    "name": "can-types.isMapLike",
    "parent": "can-types",
    "src": {
      "line": 31,
      "codeLine": 38,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "title": "isMapLike",
    "signatures": [
      {
        "code": "types.isMapLike(obj)",
        "description": "\n  Returns true if `obj` is an observable key-value pair type object.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is map like.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is map like.\n "
    }
  },
  "can-types.isListLike": {
    "type": "function",
    "name": "can-types.isListLike",
    "parent": "can-types",
    "src": {
      "line": 41,
      "codeLine": 48,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "title": "isListLike",
    "signatures": [
      {
        "code": "types.isListLike(obj)",
        "description": "\n  Returns true if `obj` is an observable list-type object with numeric keys and a length.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is list like.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is list like.\n "
    }
  },
  "can-types.isPromise": {
    "type": "function",
    "name": "can-types.isPromise",
    "parent": "can-types",
    "src": {
      "line": 51,
      "codeLine": 58,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "title": "isPromise",
    "signatures": [
      {
        "code": "types.isPromise(obj)",
        "description": "\n  Returns true if `obj` is a Promise.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is a Promise.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is a Promise.\n "
    }
  },
  "can-types.isConstructor": {
    "type": "function",
    "name": "can-types.isConstructor",
    "parent": "can-types",
    "src": {
      "line": 61,
      "codeLine": 68,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "title": "isConstructor",
    "signatures": [
      {
        "code": "types.isConstructor(obj)",
        "description": "\n  Returns true if `obj` looks like a constructor function to be called with `new`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is a constructor function.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is a constructor function.\n "
    }
  },
  "can-types.isCallableForValue": {
    "type": "function",
    "name": "can-types.isCallableForValue",
    "parent": "can-types",
    "src": {
      "line": 80,
      "codeLine": 87,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "title": "isCallableForValue",
    "signatures": [
      {
        "code": "types.isConstructor(obj)",
        "description": "\n  Returns true if `obj` looks like a function that should be read to get a value.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object should be called for a value.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object should be called for a value.\n "
    }
  },
  "can-types.isCompute": {
    "type": "function",
    "name": "can-types.isCompute",
    "parent": "can-types",
    "src": {
      "line": 90,
      "codeLine": 97,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "title": "isCompute",
    "signatures": [
      {
        "code": "types.isCompute(obj)",
        "description": "\n  Returns true if `obj` is a [can-compute].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is a [can-compute].\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is a [can-compute].\n "
    }
  },
  "can-types.iterator": {
    "name": "can-types.iterator",
    "type": "property",
    "parent": "can-types",
    "src": {
      "line": 100,
      "codeLine": 106,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Symbol",
        "description": "\n\nUsed to implement an iterable object that can be used with [can-util/js/each/each]. In browsers that support for/of this will be Symbol.iterator; in older browsers it will be a string, but is still useful with [can-util/js/each/each].\n "
      }
    ],
    "title": "iterator"
  },
  "can-types.DefaultMap": {
    "name": "can-types.DefaultMap",
    "type": "property",
    "parent": "can-types",
    "src": {
      "line": 107,
      "codeLine": 115,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Map",
        "description": "\n\n  The default map type to create if a map is needed.  If both [can-map] and [can-define/map/map]\n  are imported, the default type will be [can-define/map/map].\n "
      }
    ],
    "title": "DefaultMap"
  },
  "can-types.DefaultList": {
    "name": "can-types.DefaultList",
    "type": "property",
    "parent": "can-types",
    "src": {
      "line": 116,
      "codeLine": 124,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "can-connect.List",
        "description": "\n\n  The default list type to create if a list is needed. If both [can-list] and [can-define/list/list]\n  are imported, the default type will be [can-define/list/list].\n "
      }
    ],
    "title": "DefaultList"
  },
  "can-types.wrapElement": {
    "body": "",
    "description": "",
    "title": "wrapElement",
    "name": "can-types.wrapElement",
    "type": "function",
    "signatures": [
      {
        "code": "types.wrapElement(element)",
        "description": "\n  Wraps an element into an object useful by DOM libraries ala jQuery.\n",
        "params": [
          {
            "types": [
              {
                "type": "Node"
              }
            ],
            "name": "element",
            "description": "Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A wrapped object.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Node"
        }
      ],
      "name": "element",
      "description": "Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A wrapped object.\n "
    }
  },
  "can-types.queueTask": {
    "type": "function",
    "name": "can-types.queueTask",
    "parent": "can-types",
    "src": {
      "line": 133,
      "codeLine": 139,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "title": "queueTask",
    "signatures": [
      {
        "code": "types.queueTask(task)",
        "description": "\n  Run code that will be queued at the end of the current batch.",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "task",
            "description": "\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "task",
      "description": "\n "
    }
  },
  "can-types.unwrapElement": {
    "type": "function",
    "name": "can-types.unwrapElement",
    "parent": "can-types",
    "src": {
      "line": 146,
      "codeLine": 154,
      "path": "node_modules/can-types/can-types.js"
    },
    "body": "",
    "description": "",
    "title": "unwrapElement",
    "signatures": [
      {
        "code": "types.unwrapElement(object)",
        "description": "\n  Unwraps an object that contains an element within.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "Any object that can be unwrapped into a Node."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Node"
            }
          ],
          "description": "A Node.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "object",
      "description": "Any object that can be unwrapped into a Node."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Node"
        }
      ],
      "description": "A Node.\n "
    }
  },
  "changelog": {
    "src": {
      "path": "node_modules/can-validate/changelog.md"
    },
    "body": "\n## [1.0.0.pre]\n\n### Removed\n\n- No longer ships with validate.js shims\n- No longer ships with can.Map plugin\n- `validate`, `one`, and `isValid` methods\n\n### Added\n\n- `test` method, behaves similarly as `isValid` but also sets errors\n- `errors` method to retrieve errors\n- Register validator and library methods\n- Extend method for plugins using can-construct\n\n## [0.9.2] - 2015-06-02\n\n### Changed\n\n- Cleaning up code after incorrect merge.\n\n## [0.9.1] - 2015-06-02\n\n### Changed\n\n- Fixed Validate all bug where some properties would not get properly validate when undefined in map instance.\n- Fixed overloading of validate list on validate all method.\n\n## [0.9.0] - 2015-06-01\n\n### Changed\n\n- [#26](https://github.com/canjs/can-validate/issues/26) Fixed bug that overwrote validate properties for all instances of a Map or Model. Computes are now cached to a dunder property versus overwriting the main `validate` property.\n- [#27](https://github.com/canjs/can-validate/issues/27) Fixed the `validate` method so it resolves computes. Computes are created from functions passed as validate options so validation can be triggered when compute change is triggered.\n- Improved validate init. Using a better method for detecting when Map is initing.\n\n## [0.8.4] - 2016-06-01\n\n### Added\n\n- Added tests for issue [#26](https://github.com/canjs/can-validate/issues/26)\n- Added tests for issue [#27](https://github.com/canjs/can-validate/issues/27)\n\n### Changed\n\n- Updated dependencies\n- Switched to Mocha\n- Improved tests\n\n## [0.8.3] - 2016-04-21\n\n### Changed\n\n- Fixed bug when errors was blank would cause console error\n\n## [0.8.2] - 2016-03-02\n\n### Changed\n\n- Improved handling of validation strings, passes strings through to Validate.JS.\n\n## [0.8.1] - 2016-02-03\n\n### Added\n\n- This change log\n- Contributing guide\n\n### Changed\n\n- Changed documentation root to `can-validate-plugin`, changed from `can-validate-library`.\n- Improved readme.\n- Improved overall documentation.\n\n### Removed\n\n- Removed CanJS Validations library documentation since it is still a WIP.\n\n## [0.8.0] - 2015-12-03\n\n### Changed\n- Fixed memory leaks.\n- Improved validate object compute handling.\n- Updated to work with CanJS 2.3.x.\n\n## [0.7.1] - 2015-11-23\n\n### Changed\n- Improved build.\n\n## [0.7.0] - 2015-10-19\n\n### Added\n- Added XO for linting.\n\n### Changed\n- Cleaned up lint errors in repo.\n\n## [0.6.0] - 2015-10-19\n\n### Added\n- Improved ability to pass functions to validation properties.\n\n### Changed\n- Fixed map init bug.\n\n## [0.5.2] - 2015-10-18\n\n### Changed\n- Fixed tests.\n- Fixed merge conflicts/errors.\n\n## [0.5.1] - 2015-10-01\n\n### Changed\n- Fixed require bug.\n\n## [0.5.0] - 2015-07-16\n\n### Added\n- Added \"validate all\" method to can.Map plugin\n\n## [0.4.2] - 2015-07-13\n\n### Added\n- Published to NPM\n\n## [0.4.1] - 2015-07-13\n\n### Added\n- Inline docs.\n- Added DocumentJS dependency.\n\n## [0.4.0] - 2015-07-10\n\n### Changed\n- Restructured repository.\n\n## [0.3.0] - 2015-07-10\n\n### Added\n- Browserify build.\n\n### Changed\n- Overall build improvements.\n\n## [0.2.0] - 2015-07-09\n\n### Changed\n- Made buildable. Using `import` over Steal syntax.\n\n## [0.1.0] - 2015-07-08\n\n### Added\n- Created can-validate entry point.\n- Created can.Map plugin.\n- Created ValidateJS shim\n\n\n[0.8.0]: https://github.com/canjs/can-validate/commit/0b98de198af17980174531146e43fb8c4b5e11a6\n[0.7.1]: https://github.com/canjs/can-validate/commit/2a58bf9ef280c2bb378221c6c18e85c7fed6daa3\n[0.7.0]: https://github.com/canjs/can-validate/commit/6be268da2a02e2985f71fa1f7196bfad94c84ca5\n[0.6.0]: https://github.com/canjs/can-validate/commit/0383d482353319a6eec3cf218daaa99b8ce62585\n[0.5.2]: https://github.com/canjs/can-validate/commit/17f46a11fb3f788e029359476bca83a67dca2b94\n[0.5.1]: https://github.com/canjs/can-validate/commit/5280c965df668b3eb1b95d10847f20676a3c5820\n[0.5.0]: https://github.com/canjs/can-validate/commit/53d965869263f39ea03dca97822fd5173cf62cdc\n[0.4.2]: https://github.com/canjs/can-validate/commit/608ee0cefdc161ecdf186980738952c86c937981\n[0.4.1]: https://github.com/canjs/can-validate/commit/c15d0b72bcc3e7343615d41baccbf3cf10242898\n[0.4.0]: https://github.com/canjs/can-validate/commit/a1d581aa31c304b04a7bdb4dc40106cf5c48771d\n[0.3.0]: https://github.com/canjs/can-validate/commit/4a7de30a12c27e7db992ac2bfcdb55e94e61c17a\n[0.2.0]: https://github.com/canjs/can-validate/commit/7ba46b1ea42315f68532f4246031d9bf074b785d\n[0.1.0]: https://github.com/canjs/can-validate/commit/b9a9aa2c43d672d9c238a506d788bafb3f89ee70\n\n",
    "description": "# Change log\n",
    "name": "changelog",
    "title": "Changelog",
    "type": "page",
    "parent": "can-validate-plugin"
  },
  "validator": {
    "type": "function",
    "name": "validator",
    "params": [
      {
        "types": [
          {
            "type": "string"
          }
        ],
        "name": "id",
        "description": "The key name of the validator library."
      },
      {
        "types": [
          {
            "type": "object"
          },
          {
            "type": "function",
            "returns": {
              "types": [
                {
                  "type": "undefined"
                }
              ]
            },
            "params": []
          }
        ],
        "name": "validator",
        "description": "The validator libarary. Only pass instances.\n"
      }
    ],
    "parent": "node_modules/can-validate-legacy/can-validate.js",
    "src": {
      "line": 16,
      "codeLine": 25,
      "path": "node_modules/can-validate-legacy/can-validate.js"
    },
    "body": "",
    "description": "Registers a library with can.validate. The last one registered is the default library.\nOverride the default by changing `_validatorId` to the key of the desired registered library.\n```js\nValidate.register('validatejs',validatejs);\n```\n",
    "_curParam": {
      "types": [
        {
          "type": "object"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "validator",
      "description": "The validator libarary. Only pass instances.\n"
    }
  },
  "register": {
    "type": "function",
    "name": "register",
    "params": [
      {
        "types": [
          {
            "type": "string"
          }
        ],
        "name": "id",
        "description": "The key name of the validator library."
      },
      {
        "types": [
          {
            "type": "object"
          },
          {
            "type": "function",
            "returns": {
              "types": [
                {
                  "type": "undefined"
                }
              ]
            },
            "params": []
          }
        ],
        "name": "validator",
        "description": "The validator libarary. Only pass instances.\n"
      }
    ],
    "parent": "node_modules/can-validate-legacy/can-validate.js",
    "src": {
      "line": 29,
      "codeLine": 38,
      "path": "node_modules/can-validate-legacy/can-validate.js"
    },
    "body": "",
    "description": "Registers a library with can.validate. The last one registered is the default library.\nOverride the default by changing `_validatorId` to the key of the desired registered library.\n```js\nValidate.register('validatejs',validatejs);\n```\n",
    "_curParam": {
      "types": [
        {
          "type": "object"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "validator",
      "description": "The validator libarary. Only pass instances.\n"
    }
  },
  "isValid": {
    "type": "function",
    "name": "isValid",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "value",
        "description": "Some value to validate against."
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "options",
        "description": "Raw validation options. They will be processed since\nnot all options are valid for ValidateJS."
      }
    ],
    "parent": "node_modules/can-validate-legacy/shims/validatejs.js",
    "src": {
      "line": 62,
      "codeLine": 72,
      "path": "node_modules/can-validate-legacy/shims/validatejs.js"
    },
    "body": "",
    "description": "Simply checks if the property value will validate or not, this method will not set errors, it is meant to check validity *before* a property\nis set.\n",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "Raw validation options. They will be processed since\nnot all options are valid for ValidateJS."
    },
    "title": "Is Valid",
    "returns": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "True if valid, otherwise returns false\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "True if valid, otherwise returns false\n"
    }
  },
  "once": {
    "type": "function",
    "name": "once",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "value",
        "description": "Some value to validate against."
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "options",
        "description": "Raw validation options. They will be processed since\nnot all options are valid for ValidateJS."
      },
      {
        "types": [
          {
            "type": "string"
          }
        ],
        "name": "name",
        "description": "The key name of the value to validate. Used to prepend to\nerror messages, if any."
      }
    ],
    "parent": "node_modules/can-validate-legacy/shims/validatejs.js",
    "src": {
      "line": 23,
      "codeLine": 34,
      "path": "node_modules/can-validate-legacy/shims/validatejs.js"
    },
    "body": "",
    "description": "Validates a single property using provided validation options ",
    "_curParam": {
      "types": [
        {
          "type": "string"
        }
      ],
      "name": "name",
      "description": "The key name of the value to validate. Used to prepend to\nerror messages, if any."
    },
    "title": "Once",
    "returns": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "array"
        }
      ],
      "description": "Returns undefined if no errors, otherwise returns\na list of errors.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "array"
        }
      ],
      "description": "Returns undefined if no errors, otherwise returns\na list of errors.\n"
    }
  },
  "validate": {
    "type": "function",
    "name": "validate",
    "params": [],
    "parent": "node_modules/can-validate-legacy/map/validate/validate.js",
    "src": {
      "line": 139,
      "codeLine": 147,
      "path": "node_modules/can-validate-legacy/map/validate/validate.js"
    },
    "body": "",
    "description": "Runs validation on the entire map instance. Actual behavior of \"validate all\" is defined by the registered shim.\n\n",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "Raw validation options. They will be processed since\nnot all options are valid for ValidateJS. It should be a map of property keys\nwhich contain the respective validation properties."
    },
    "title": "Validate",
    "returns": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "array"
        }
      ],
      "description": "Returns undefined if no errors, otherwise returns\na list of errors.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "array"
        }
      ],
      "description": "Returns undefined if no errors, otherwise returns\na list of errors.\n"
    },
    "deprecated": [
      {
        "version": "1.0",
        "description": "`validate` is deprecated and will be removed in version 1.0.\nUse `_validate` instead.\n"
      }
    ]
  },
  "can-vdom.modules": {
    "name": "can-vdom.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-vdom",
    "description": "",
    "order": 0
  },
  "can-vdom.types": {
    "name": "can-vdom.types",
    "title": "types",
    "type": "group",
    "parent": "can-vdom",
    "description": "",
    "order": 0
  },
  "can-vdom": {
    "src": {
      "path": "node_modules/can-vdom/can-vdom.md"
    },
    "body": "\n\n\n## Shiming a browser environment\n\nImporting `can-vdom` will shim a browser-like environment into Node's globals. Use this approach to run code that expects a global `window` and/or `document` object.\n\n```js\nrequire(\"can-vdom\");\n\ntypeof window; // \"object\"\n\ntypeof window.addEventListener; // \"function\"\n\ndocument.getElementById(\"foo\"); // undefined\n```\n\n## Loading as a module\n\nIf you want to prevent setting globals you can load `can-vdom/make-window/make-window` directly:\n\n```js\nvar makeWindow = require(\"can-vdom/make-window/make-window\");\n\nvar myWindow = makeWindow(global);\n```\n\n",
    "description": "A browser-lite environment for Node.js or a worker thread. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "undefined",
        "description": "\n\nThe `can-vdom` module does not export anything, but it changes the current\nenvironment to have the limited subset of browser environment behavior and\nfunctionality needed to support CanJS templates and other behavior without\na native DOM.\n\n```js\nrequire(\"can-vdom\");\n\nwindow === global; // true\n\ndocument.getElementsByTagName(\"body\"); // [HTMLBodyElement]\n```\n\n`can-vdom` decorates the environment `global` to include:\n\n - a non-functional `navigator`, `location`, and `history` object.\n - a limitedly functional `document` with basic `Node` behavior, event binding and dispatching.\n\n\n"
      }
    ],
    "name": "can-vdom",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-vdom"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-vdom/issues"
      },
      "dependencies": {
        "can-simple-dom": "^1.0.0",
        "can-util": "^3.0.0",
        "can-view-parser": "^3.0.0"
      },
      "description": "A browser-lite environment for nodejs",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "chai": "^3.4.1",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.4",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "mocha": "^2.3.4",
        "steal": "^1.2.10",
        "steal-mocha": "^1.0.0",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "donejs",
        "canjs"
      ],
      "main": "can-vdom.js",
      "name": "can-vdom",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-vdom.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run test:node && npm run test:browser",
        "test:browser": "testee test/test.html --browsers firefox --reporter Spec",
        "test:node": "mocha test/test.js",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-vdom",
        "map": {
          "./assert": "chai/chai"
        },
        "meta": {
          "chai/chai": {
            "format": "global",
            "exports": "chai.assert"
          }
        },
        "plugins": [
          "chai"
        ]
      },
      "version": "3.0.3"
    },
    "comment": " "
  },
  "can/view/autorender": {
    "src": {
      "path": "node_modules/can-view-autorender/autorender.md"
    },
    "body": "\n\n## Use\n\nAs long is this module is part of your CanJS build or imported with RequireJS, StealJS, or SystemJS,\n[can/view/autorender.can-autorender] will automatically look for `can-autorender` tags and render them.  Once\nall templates have finished rendering, it will call any callbacks passed to `can.autorender()`.\n\n\nFor example, you might have a page like:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'\n\t\tmessage=\"Hello World\">\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\n\t<script src='jquery.js'></script>\n\t<!-- A CanJS build that includes this plugin -->\n\t<script src='can.custom.js'></script>\n\t<!-- All your app's code and components -->\n\t<script src='app.js'></script>\n\t<script>\n\t\t// Wait until everything has rendered.\n\t\tcan.autorender(function(){\n\n\t\t\t// Update the viewModel the template was rendred with:\n\t\t\t$(\"#main\").viewModel().attr(\"message\",\"Rendered!\");\n\n\t\t})\n\t</script>\n</body>\n```\n\n## Rendered placement\n\nIf the template source is a `<script>` tag within the `<body>`, the rendered template is placed\nimmediately following the template.\n\nFor example:\n\n```\n<body>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n\t<div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n\tHi!\n\t<div>...</div>\n</body>\n```\n\nIf the `<script>` tag is outside the body, for example in the `<head>`\ntag, the rendered result will be placed just before the closing `</body>` tag.\n\nFor example:\n\n```\n<head>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n</head>\n<body>\n\t<div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<head>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n</head>\n<body>\n\t<div>...</div>\n\tHi!\n</body>\n```\n\nIf the template source is any other element, the element's contents will be replaced with the rendered result.  For example:\n\n```\n<body>\n\t<div type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n\t<div type='text/stache' can-autorender message=\"Hi\">\n\t\tHi!\n\t</div>\n</body>\n```\n\n## Scope\n\nThe template is rendered with a [can.Map] made from the attributes of the\ntemplate source element.  That `map` is available on the\ntemplate source element via [can.viewModel].  You can\nchange the map at any time:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'>\n\t\t{{message}}!\n\t</script>\n\t<script>\n\t\tvar viewModel = can.viewModel(document.getElementById(\"main\"));\n\t\tviewModel.attr(\"message\",\"Hello There!\");\n\t</script>\n</body>\n```\n\nYou can change attributes on the element and it will update the\nviewModel too:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'>\n\t\t{{message}}!\n\t</script>\n\t<script>\n\t\tvar main = document.getElementById(\"main\");\n\t\tmain.setAttribute(\"message\",\"Hello There!\");\n\t</script>\n</body>\n```\n\n\n\n## StealJS Use\n\nFor demo pages that require very little setup:\n\n```\n<body>\n\t<script type='text/stache'>\n\t\t<can-import from=\"components/my-component\"/>\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\t<script src='../node_modules/steal/steal.js'\n\t\t\t\t\tmain='can/view/autorender/'>\n\t</script>\n</body>\n```\n\nFor demo pages that require a little custom setup:\n\n```\n<body>\n\t<script type='text/stache' can-autorender>\n\t\t<can-import from=\"components/my-component\"/>\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\t<script src='../node_modules/steal/steal.js'\n\t\t\t\t\tmain='@empty'>\n\t\tvar can = require('can');\n\t\tvar $ = reqire('jquery');\n\t\trequire('can/view/autorender/autorender');\n\n\t\t$(\"my-component\").viewModel().attr(\"message\", \"Hi\");\n\t</script>\n</body>\n```\n\n\n\n\n\n## Errors\n\nError callbacks will be called if a template has a parsing error or\na [can/view/stache/system.import] fails.\n\n",
    "description": "\nA module that automatically renders script and other elements with\nthe [can/view/autorender.can-autorender] attribute. This function is useful to know when\nthe templates have finished rendering.\n",
    "type": "module",
    "title": "can.autorender",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can/view/autorender",
    "parent": "can.view.plugins",
    "signatures": [
      {
        "code": "can.autorender(succcess, error)",
        "description": "\n\n\tRegisters functions to callback when all templates successfully render or an error in rendering happens.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "success",
            "description": "A function to callback when all autorendered templates have been rendered\nsuccessfully.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function to callback if a template was not rendered successfully.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function to callback if a template was not rendered successfully.\n"
    },
    "comment": " "
  },
  "can-view-autorender": {
    "src": {
      "path": "node_modules/can-view-autorender/can-view-autorender.md"
    },
    "body": "\n\n## Use\n\nAs long is this module is part of your CanJS build or imported with RequireJS, StealJS, or SystemJS,\n[can-view-autorender] will automatically look for `can-autorender` tags and render them.  Once\nall templates have finished rendering, it will call any callbacks passed to `can.autorender()`.\n\n\nFor example, you might have a page like:\n\n```\n<body>\n  <script type='text/stache' can-autorender id='main'\n    message=\"Hello World\">\n    <my-component>\n      {{message}}\n    </my-component>\n  </script>\n\n  <script src='jquery.js'></script>\n  <!-- A CanJS build that includes this plugin -->\n  <script src='can.all.js'></script>\n  <!-- All your app's code and components -->\n  <script src='app.js'></script>\n  <script>\n    // Wait until everything has rendered.\n    can.autorender(function(){\n\n      // Update the viewModel the template was rendred with:\n      $(\"#main\").viewModel().attr(\"message\",\"Rendered!\");\n\n    })\n  </script>\n</body>\n```\n\n## Rendered placement\n\nIf the template source is a `<script>` tag within the `<body>`, the rendered template is placed\nimmediately following the template.\n\nFor example:\n\n```\n<body>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n  <div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n  Hi!\n  <div>...</div>\n</body>\n```\n\nIf the `<script>` tag is outside the body, for example in the `<head>`\ntag, the rendered result will be placed just before the closing `</body>` tag.\n\nFor example:\n\n```\n<head>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n</head>\n<body>\n  <div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<head>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n</head>\n<body>\n  <div>...</div>\n  Hi!\n</body>\n```\n\nIf the template source is any other element, the element's contents will be replaced with the rendered result.  For example:\n\n```\n<body>\n  <div type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n  <div type='text/stache' can-autorender message=\"Hi\">\n    Hi!\n  </div>\n</body>\n```\n\n## Scope\n\nThe template is rendered with a [can.Map] made from the attributes of the\ntemplate source element.  That `map` is available on the\ntemplate source element via [can.viewModel].  You can\nchange the map at any time:\n\n```\n<body>\n  <script type='text/stache' can-autorender id='main'>\n    {{message}}!\n  </script>\n  <script>\n    var viewModel = can.viewModel(document.getElementById(\"main\"));\n    viewModel.attr(\"message\",\"Hello There!\");\n  </script>\n</body>\n```\n\nYou can change attributes on the element and it will update the\nviewModel too:\n\n```\n<body>\n  <script type='text/stache' can-autorender id='main'>\n    {{message}}!\n  </script>\n  <script>\n    var main = document.getElementById(\"main\");\n    main.setAttribute(\"message\",\"Hello There!\");\n  </script>\n</body>\n```\n\n\n\n## StealJS Use\n\nFor demo pages that require very little setup:\n\n```\n<body>\n  <script type='text/stache'>\n    <can-import from=\"components/my-component\"/>\n    <my-component>\n      {{message}}\n    </my-component>\n  </script>\n  <script src='../node_modules/steal/steal.js'\n          main='can/view/autorender/'>\n  </script>\n</body>\n```\n\nFor demo pages that require a little custom setup:\n\n```\n<body>\n  <script type='text/stache' can-autorender>\n    <can-import from=\"components/my-component\"/>\n    <my-component>\n      {{message}}\n    </my-component>\n  </script>\n  <script src='../node_modules/steal/steal.js'\n          main='@empty'>\n  </script>\n  <script>\n    steal('can','jquery','can/view/autorender/', function(can, $){\n      $(\"my-component\").viewModel().attr(\"message\", \"Hi\");\n    });\n  </script>\n</body>\n```\n\n\n\n\n\n## Errors\n\nError callbacks will be called if a template has a parsing error or\na [can/view/stache/system.import] fails.\n\n",
    "description": "\nA module that automatically renders script and other elements with\nthe `can-autorender` attribute. This function is useful to know when the templates have finished rendering.\n",
    "type": "module",
    "title": "can-view-autorender",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-autorender",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": [
            "can-view-autorender"
          ]
        },
        "parent": "can-view-autorender"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-autorender/issues"
      },
      "dependencies": {
        "can-event": "^3.0.1",
        "can-util": "^3.2.2",
        "can-view-model": "^3.0.0"
      },
      "description": "Automatically render templates found in the document",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-component": "^3.0.0-pre.3",
        "can-define": "^1.0.1",
        "can-stache": "^3.0.0-pre.19",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.4",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-autorender",
      "name": "can-view-autorender",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-autorender.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.0.4"
    },
    "parent": "can-ecosystem",
    "signatures": [
      {
        "code": "autorender(success, error)",
        "description": "\n\n  Registers functions to callback when all templates successfully render or an error in rendering happens.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "success",
            "description": "A function to callback when all autorendered templates have been rendered\nsuccessfully.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function to callback if a template was not rendered successfully.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function to callback if a template was not rendered successfully.\n"
    },
    "comment": " "
  },
  "can-view-href": {
    "src": {
      "path": "node_modules/can-view-href/can-view-href.md"
    },
    "body": "\n## Use\n\nWith no pretty routing rules, the following:\n\n```\n<li><a can-href='{page=\"recipe\" id=5}'>{{recipe.name}}</a></li>\n```\n\nproduces:\n\n```\n<li><a href='#!&page=5&id=5'>{{recipe.name}}</a></li>\n```\n\nIf pretty route is defined like:\n\n```\ncan.route(\":page/:id\")\n```\n\nThe previous use of `can-href` will instead produce:\n\n```\n<li><a href='#!page/5'>{{recipe.name}}</a></li>\n```\n\nYou can use values from stache's scope like:\n\n```\n<li><a can-href='{page=\"recipe\" id=recipeId}'>{{recipe.name}}</a></li>\n```\n\nIf `recipeId` was 6:\n\n```\n<li><a href='#!page/6'>{{recipe.name}}</a></li>\n```\n\nIf `recipeId` is observable and changes to 7:\n\n```\n<li><a href='#!page/7'>{{recipe.name}}</a></li>\n```\n\n",
    "description": "Sets an element's href attribute so that it's url will set the specified attribute values on [can-route]. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "undefined"
      }
    ],
    "name": "can-view-href",
    "parent": "can-legacy",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-route": "^3.0.0",
        "can-stache": "^3.0.1",
        "can-util": "^3.0.1",
        "can-view-callbacks": "^3.0.0",
        "can-view-scope": "^3.0.0"
      },
      "description": "Make flexible route links",
      "devDependencies": {
        "can-map": "^3.0.0-pre.11",
        "can-ssr": "^0.11.6",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.6",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs",
        "donejs",
        "canjs-plugin"
      ],
      "main": "can-view-href",
      "name": "can-view-href",
      "scripts": {
        "build": "node build.js",
        "develop": "can-serve --static --develop --port 8080",
        "jshint": "jshint src/. --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-view-href",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.4"
    },
    "deprecated": [
      {
        "version": "2.3",
        "description": "Use the [can-stache.helpers.routeUrl routeUrl helper] instead like:\n`href=\"{{routeUrl prop=value}}\"`.\n"
      }
    ],
    "signatures": [
      {
        "code": "can-href='{[attrName=attrValue...]}'",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": ""
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              }
            ],
            "name": "attrValue",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        }
      ],
      "name": "attrValue",
      "description": "\n"
    },
    "comment": " "
  },
  "can-view-model": {
    "src": {
      "path": "node_modules/can-view-model/can-view-model.md"
    },
    "body": "\n## Use\n\n**can-view-model** is used to get and set properties on an element's ViewModel. Each element in the DOM can have an associated ViewModel. An example of this is a [can-component] and it's associated [can-component.prototype.ViewModel].\n\nThis shows a Component and getting its ViewModel:\n\n```html\n<my-tabs>\n ...\n</my-tabs>\n```\n\n```js\nvar canViewModel = require(\"can-view-model\");\n\nvar element = document.querySelector(\"my-tabs\");\nvar vm = canViewModel(element);\n```\n\nThe other signatures provide the ability to get and set properties on the ViewModel. For example, this sets the \"foo\" property on a component's viewModel:\n\n```js\nvar canViewModel = require(\"can-view-model\");\n\nvar element = document.querySelector(\"my-tabs\");\nvar vm = canViewModel(element);\n\ncanViewModel(element, \"foo\", \"bar\");\n\nconsole.log(vm.foo, \"bar\");\n```\n\n## Setting an element's ViewModel\n\nOne thing that can-view-model does ***not*** do is provide a way to set what an element's ViewModel should be. To do that, use [can-util/dom/data/data] instead like so:\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar element = document.querySelector(\"#my-id\");\n\nvar myVm = new DefineMap();\n\ndomData.set.call(element, \"viewModel\", myVm);\n```\n\n",
    "description": "Gets the ViewModel of an [element](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement). \n",
    "type": "module",
    "title": "can-view-model",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-model",
    "parent": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": [
            "can-view-model"
          ]
        },
        "parent": "can-view-model"
      },
      "dependencies": {
        "can-namespace": "1.0.0",
        "can-simple-map": "^3.0.0",
        "can-types": "^1.0.1",
        "can-util": "^3.1.1"
      },
      "description": "gets or sets the view model of an element",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^1.0.5",
        "can-map": "^3.0.3",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "donejs"
      ],
      "main": "can-view-model",
      "name": "can-view-model",
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.1.3"
    },
    "signatures": [
      {
        "code": "canViewModel(element)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-util/js/types/types.DefaultMap] if it doesn't already exist, and returns the map.\n\n```js\nvar vm = canViewModel(element);\n```",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "Any element in the DOM.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            },
            {
              "type": "can-define/map/map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The ViewModel associated with this elelement.\n"
        }
      },
      {
        "code": "canViewModel(element, property)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-util/js/types/types.DefaultMap] if it doesn't already exist. Then gets the **property** inside of the ViewModel and returns that.\n\n```\nvar foo = canViewModel(element, \"foo\");\n\nconsole.log(foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "Any element in the DOM."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The property to get from the ViewModel.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property on the ViewModel or undefined if the property doesn't exist.\n"
        }
      },
      {
        "code": "canViewModel(element, property, value)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-util/js/types/types.DefaultMap] if it doesn't already exist. Sets the **property** on that map to **value**.\n\n```js\ncanViewModel(element, \"foo\", \"bar\");\n\nvar foo = canViewModel(element, \"foo\");\n\nconsole.log(foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "ANy element in the DOM."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The property that is being set on the ViewModel."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value being set on the property.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The element.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The element.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value being set on the property.\n"
    },
    "comment": " "
  },
  "can-view-nodelist.update": {
    "type": "function",
    "name": "can-view-nodelist.update",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 99,
      "codeLine": 112,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "\n",
    "title": "update",
    "signatures": [
      {
        "code": "nodeLists.update(nodeList, newNodes)",
        "description": "\n\nUpdates a nodeList with new items, i.e. when values for the template have changed.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "The list to update with the new nodes."
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "newNodes",
            "description": "The new nodes to update with.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Node"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The nodes that were removed from `nodeList`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "newNodes",
      "description": "The new nodes to update with.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "description": "The nodes that were removed from `nodeList`.\n"
    }
  },
  "can-view-nodelist.nestReplacements": {
    "type": "function",
    "name": "can-view-nodelist.nestReplacements",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 138,
      "codeLine": 152,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "nestReplacements",
    "signatures": [
      {
        "code": "nodeLists.nestReplacements(list)",
        "description": "\n\nGoes through each node in the list. `[el1, el2, el3, ...]`\nFinds the nodeList for that node in replacements.  el1's nodeList might look like `[el1, [el2]]`.\nReplaces that element and any other elements in the node list with the\nnodelist itself. resulting in `[ [el1, [el2]], el3, ...]`\nIf a replacement is not found, it was improperly added, so we add it as a deepChild.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "list",
            "description": "The nodeList of nodes to go over\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "list",
      "description": "The nodeList of nodes to go over\n\n"
    }
  },
  "can-view-nodelist.nestList": {
    "type": "function",
    "name": "can-view-nodelist.nestList",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 177,
      "codeLine": 190,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "nestList",
    "signatures": [
      {
        "code": "nodeLists.nestList(list)",
        "description": "\n\nIf a given list does not exist in the nodeMap then create an lookup\nid for it in the nodeMap and assign the list to it.\nIf the the provided does happen to exist in the nodeMap update the\nelements in the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "list",
            "description": "The nodeList being nested.\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "list",
      "description": "The nodeList being nested.\n\n "
    }
  },
  "can-view-nodelist.last": {
    "type": "function",
    "name": "can-view-nodelist.last",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 211,
      "codeLine": 224,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "last",
    "signatures": [
      {
        "code": "nodeLists.last(nodeList)",
        "description": "\n\nReturn the last HTMLElement in a nodeList; if the last\nelement is a nodeList, returns the last HTMLElement of\nthe child list, etc.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The last element of the last list nested in this list.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "A nodeList."
    },
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The last element of the last list nested in this list.\n\n "
    }
  },
  "can-view-nodelist.first": {
    "type": "function",
    "name": "can-view-nodelist.first",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 235,
      "codeLine": 249,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "first",
    "signatures": [
      {
        "code": "nodeLists.first(nodeList)",
        "description": "\n\nReturn the first HTMLElement in a nodeList; if the first\nelement is a nodeList, returns the first HTMLElement of\nthe child list, etc.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The first element of the first list nested in this list.\n\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "A nodeList."
    },
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The first element of the first list nested in this list.\n\n\n "
    }
  },
  "can-view-nodelist.register": {
    "type": "function",
    "name": "can-view-nodelist.register",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 271,
      "codeLine": 286,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "\n",
    "title": "register",
    "signatures": [
      {
        "code": "nodeLists.register(nodeList, unregistered, parent, directlyNested)",
        "description": "\n\nRegisters a nodeList and returns the nodeList passed to register.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "unregistered",
            "description": "A callback to call when the nodeList is unregistered."
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "parent",
            "description": "The parent nodeList of this nodeList."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "directlyNested",
            "description": "`true` if nodes in the nodeList are direct children of the parent."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-view-nodelist/types/NodeList"
            }
          ],
          "description": "The passed in nodeList.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "directlyNested",
      "description": "`true` if nodes in the nodeList are direct children of the parent."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "description": "The passed in nodeList.\n\n "
    }
  },
  "can-view-nodelist.unregisterChildren": {
    "type": "function",
    "name": "can-view-nodelist.unregisterChildren",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 314,
      "codeLine": 325,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "unregisterChildren",
    "signatures": [
      {
        "code": "nodeLists.unregisterChildren(nodeList)",
        "description": "\n\nUnregister all childen within the provided list and return the\nunregistred nodes.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "The nodeList of child nodes to unregister."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "The list of all nodes that were unregistered.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "The nodeList of child nodes to unregister."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "The list of all nodes that were unregistered.\n "
    }
  },
  "can-view-nodelist.unregister": {
    "type": "function",
    "name": "can-view-nodelist.unregister",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 352,
      "codeLine": 364,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "unregister",
    "signatures": [
      {
        "code": "nodeLists.unregister(nodeList, isChild)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "nodeList",
            "description": "a nodeList to unregister from its parent"
          },
          {
            "types": [
              {
                "type": "isChild"
              }
            ],
            "name": "true",
            "description": "if the nodeList is a direct child, false if a deep child"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a list of all nodes that were unregistered\n\nUnregister's a nodeList and returns the unregistered nodes.\nCall if the nodeList is no longer being updated. This will\nalso unregister all child nodeLists.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "isChild"
        }
      ],
      "name": "true",
      "description": "if the nodeList is a direct child, false if a deep child"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a list of all nodes that were unregistered\n\nUnregister's a nodeList and returns the unregistered nodes.\nCall if the nodeList is no longer being updated. This will\nalso unregister all child nodeLists.\n"
    }
  },
  "can-view-nodelist.after": {
    "type": "function",
    "name": "can-view-nodelist.after",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 385,
      "codeLine": 397,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "after",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.after(oldElements, newFrag)",
        "description": "\n\n  Inserts `newFrag` after `oldElements`.\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "The elements to use as reference."
          },
          {
            "types": [
              {
                "type": "DocumentFragment"
              }
            ],
            "name": "newFrag",
            "description": "The fragment to insert.\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "newFrag",
      "description": "The fragment to insert.\n\n "
    }
  },
  "can-view-nodelist.replace": {
    "type": "function",
    "name": "can-view-nodelist.replace",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 406,
      "codeLine": 418,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "replace",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.replace(oldElements, newFrag)",
        "description": "\n\nReplaces `oldElements` with `newFrag`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "the list elements to remove"
          },
          {
            "types": [
              {
                "type": "DocumentFragment"
              }
            ],
            "name": "newFrag",
            "description": "the fragment to replace the old elements\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "newFrag",
      "description": "the fragment to replace the old elements\n\n "
    }
  },
  "can-view-nodelist.remove": {
    "type": "function",
    "name": "can-view-nodelist.remove",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 439,
      "codeLine": 450,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "remove",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.remove(elementsToBeRemoved)",
        "description": "\n\nRemove all Nodes in `oldElements` from the DOM.\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "the list of Elements to remove (must have a common parent)\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ArrayLike",
          "template": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "name": "oldElements",
      "description": "the list of Elements to remove (must have a common parent)\n\n "
    }
  },
  "can-view-nodelist/methods": {
    "name": "can-view-nodelist/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-view-nodelist",
    "description": "",
    "order": 0
  },
  "can-view-nodelist/types": {
    "name": "can-view-nodelist/types",
    "title": "types",
    "type": "group",
    "parent": "can-view-nodelist",
    "description": "",
    "order": 0
  },
  "can-view-nodelist": {
    "src": {
      "path": "node_modules/can-view-nodelist/can-view-nodelist.md"
    },
    "body": "",
    "description": "Adds nesting of text nodes \n`can.view.nodeLists` are used to make sure \"directly nested\" live-binding\nsections update content correctly.\n\nConsider the following template:\n\n```html\n<div>\n{{#if items.length}}\n    Items:\n        {{#items}}\n            <label></label>\n        {{/items}}\n{{/if}}\n</div>\n```\n\nThe `{{#if}}` and `{{#items}}` seconds are \"directly nested\" because\nthey share the same `<div>` parent element.\n\nIf `{{#items}}` changes the DOM by adding more `<labels>`,\n`{{#if}}` needs to know about the `<labels>` to remove them\nif `{{#if}}` is re-rendered.  `{{#if}}` would be re-rendered, for example, if\nall items were removed.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-nodelist",
    "parent": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "dest": "docs",
        "parent": "can-view-nodelist",
        "glob": {
          "pattern": "{./docs,.}/*.{js,md}"
        },
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-nodelist/issues"
      },
      "dependencies": {
        "can-namespace": "1.0.0",
        "can-util": "^3.1.1"
      },
      "description": "Adds nesting of text nodes",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-nodelist",
      "name": "can-view-nodelist",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-nodelist.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.0.4"
    }
  },
  "can.view.Scope": {
    "name": "can.view.Scope",
    "type": "add",
    "description": "undefined\n"
  },
  "can.view.Scope.static": {
    "src": {
      "line": 34,
      "codeLine": 37,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "can.view.Scope.static",
    "parent": "can.view.Scope",
    "title": "static"
  },
  "can.view.Scope.prototype": {
    "src": {
      "line": 52,
      "codeLine": 55,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\n",
    "name": "can.view.Scope.prototype",
    "parent": "can.view.Scope",
    "title": "prototype"
  },
  "can.view.Scope.prototype.read": {
    "type": "function",
    "name": "can.view.Scope.prototype.read",
    "params": [
      {
        "types": [
          {
            "type": "can.stache.key"
          }
        ],
        "name": "attr",
        "description": "A dot seperated path.  Use `\".\"` if you have a property name that includes a dot."
      },
      {
        "types": [
          {
            "type": "can.view.Scope.readOptions"
          }
        ],
        "name": "options",
        "description": "that configure how this gets read."
      }
    ],
    "parent": "can.view.Scope.prototype",
    "src": {
      "line": 78,
      "codeLine": 88,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "body": "",
    "description": "",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "can.view.Scope.readOptions"
        }
      ],
      "name": "options",
      "description": "that configure how this gets read."
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "parent",
              "description": "the value's immediate parent",
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            },
            {
              "name": "rootObserve",
              "description": "the first observable to read from.",
              "types": [
                {
                  "type": "can.Map"
                },
                {
                  "type": "can.compute"
                }
              ]
            },
            {
              "name": "reads",
              "description": "An array of properties that can be used to read from the rootObserve to get the value.",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "String"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "value",
              "description": "the found value\n ",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "parent",
              "description": "the value's immediate parent",
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            },
            {
              "name": "rootObserve",
              "description": "the first observable to read from.",
              "types": [
                {
                  "type": "can.Map"
                },
                {
                  "type": "can.compute"
                }
              ]
            },
            {
              "name": "reads",
              "description": "An array of properties that can be used to read from the rootObserve to get the value.",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "String"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "value",
              "description": "the found value\n ",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    }
  },
  "cloneNode": {
    "name": "cloneNode",
    "type": "function",
    "parent": "node_modules/can-view-target/can-view-target.js",
    "src": {
      "line": 77,
      "codeLine": 88,
      "path": "node_modules/can-view-target/can-view-target.js"
    },
    "body": "\n",
    "description": "\nA custom cloneNode function to be used in browsers that properly support cloning\nof custom tags (IE8 for example). Fixes it by doing some manual cloning that\nuses innerHTML instead, which has been shimmed.\n",
    "title": "",
    "hide": true,
    "params": [
      {
        "types": [
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "frag",
        "description": "A document fragment to clone"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "frag",
      "description": "A document fragment to clone"
    },
    "returns": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "a new fragment that is a clone of the provided argument\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "a new fragment that is a clone of the provided argument\n"
    }
  },
  "can-view-target": {
    "src": {
      "path": "node_modules/can-view-target/can-view-target.md"
    },
    "body": "",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-target",
    "parent": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": [
            "can-view-target"
          ]
        },
        "parent": "can-view-target"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-target/issues"
      },
      "dependencies": {
        "can-namespace": "1.0.0",
        "can-util": "^3.1.1"
      },
      "description": "Fast cloning micro templates",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-simple-dom": "^1.0.2",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-target",
      "name": "can-view-target",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-target.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.0.7"
    },
    "signatures": [
      {
        "code": "target(nodes)",
        "description": "\n\nCreate a document fragment that can be cloned but have callbacks be\ncalled quickly on elements within the cloned fragment.\n\n```js\nvar viewTarget = require(\"can-view-target\");\n\nvar target = viewTarget([\n\t{\n\t\ttag: \"h1\",\n\t\tcallbacks: [function(data){\n\t\t\tthis.className = data.className\n\t\t}],\n\t\tchildren: [\n\t\t\t\"Hello \",\n\t\t\tfunction(){\n\t\t\t\tthis.nodeValue = data.message\n\t\t\t}\n\t\t]\n\t},\n]);\n\n// target.clone -> <h1>|Hello||</h1>\n// target.paths -> path: [0], callbacks: [], children: {paths: [1], callbacks:[function(){}]}\n\nvar frag = target.hydrate({className: \"title\", message: \"World\"});\n\nfrag //-> <h1 class='title'>Hello World</h1>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "nodes",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "nodes",
      "description": "\n"
    }
  },
  "about": {
    "src": {
      "path": "docs/can-canjs/can-about.md"
    },
    "body": "\nCanJS is part of the [DoneJS](https://donejs.com/) family of open source projects.  The [DoneJS Team](https://donejs.com/About.html#team) and [Bitovi](https://www.bitovi.com)\nare responsible for CanJS. They steer its direction, add features, fix bugs, and help\nyou become successful. Feel free to say hello anytime on [Gitter chat](https://gitter.im/canjs/canjs) or the [forums](http://forums.donejs.com/c/canjs).\n\nCanJS’s goals are briefly summarized in its mission statement:\n\n> To minimize the cost of building and maintaining JavaScript applications by balancing innovation and stability, helping developers transcend a changing technology landscape.\n\n[guides/mission Read more about our mission] and how we’ve been accomplishing those goals for\n10 years.\n\nIf CanJS’s heart isn’t enough to convince you it’s a good fit, read up on its\n[guides/technical].\n\nCanJS is used by some of the largest companies in the world. Find out who on [guides/who-uses-canjs]\n\nLearn about CanJS’s future plans, how we make them, and how you can influence them on the [roadmap] page.\n\n",
    "description": " Welcome to CanJS! Learn about CanJS’s mission & technical highlights, who uses CanJS, and our future roadmap.\n\n",
    "name": "about",
    "title": "About",
    "type": "page",
    "parent": "canjs",
    "order": 0,
    "comment": " "
  },
  "api": {
    "src": {
      "path": "docs/can-canjs/can-api.md"
    },
    "body": "\n## Collections\n\nCanJS is made of many independent packages and modules.  Those packages and modules are\norganized within the following collections.  Read on to get an overview of each collection’s\npackages.  Please star what you like so we know where to put our effort.\n\n\n### [can-core Core Collection]\n\n_The best, most hardened and generally useful libraries in CanJS._\n\n<div class=\"module-list\">\n\n- **[can-compute]** <small><%can-compute.package.version%></small> Observable values and observable composite values\n  - `npm install can-compute --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-compute\">Star</a>\n- **[can-define]** <small><%can-define.package.version%></small> Observable objects\n  - `npm install can-define --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-define\">Star</a>\n- **[can-set]** <small><%can-set.package.version%></small> Service modeling\n  - `npm install can-set --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-set\">Star</a>\n- **[can-connect]** <small><%can-connect.package.version%></small> Data connection\n  - `npm install can-connect --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-connect\">Star</a>\n- **[can-stache]** <small><%can-stache.package.version%></small> Live binding templates\n  - `npm install can-stache --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stache\">Star</a>\n- **[can-component]** <small><%can-component.package.version%></small> Custom elements\n  - `npm install can-component --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-component\">Star</a>\n- **[can-stache-bindings]** <small><%can-stache-bindings.package.version%></small> View bindings\n  - `npm install can-stache-bindings --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stache-bindings\">Star</a>\n- **[can-route]** <small><%can-route.package.version%></small> Routing\n  - `npm install can-route --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-route\">Star</a>\n- **[can-route-pushstate]** <small><%can-route-pushstate.package.version%></small> Pushstate routing\n  - `npm install can-route-pushstate --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-route-pushstate\">Star</a>\n\n\n</div>\n\n### [can-infrastructure Infrastructure Collection]\n\n_Utility libraries that power the core collection._\n\n<div class=\"module-list\">\n\n- **[can-event]** <small><%can-event.package.version%></small> Event mixin\n  - `npm install can-event --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-event\">Star</a>\n- **[can-control]** <small><%can-control.package.version%></small> DOM widget constructor\n  - `npm install can-control --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-control\">Star</a>\n- **[can-util]** <small><%can-util.package.version%></small> Low-level JS and DOM utilities\n  - `npm install can-util --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-util\">Star</a>\n- **[can-construct]** <small><%can-construct.package.version%></small> Extensible constructors\n  - `npm install can-construct --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-construct\">Star</a>\n- **[can-observation]** <small><%can-observation.package.version%></small> Observation notification\n  - `npm install can-observation --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-observation\">Star</a>\n- **[can-simple-map]** <small><%can-simple-map.package.version%></small> Simple observable object\n  - `npm install can-simple-map --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-simple-map\">Star</a>\n- **[can-view-callbacks]** <small><%can-view-callbacks.package.version%></small> Register custom elements or attributes in can-stache\n  - `npm install can-view-callbacks --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-callbacks\">Star</a>\n- **[can-view-model]** <small><%can-view-model.package.version%></small> Read a view-model from a custom element\n  - `npm install can-view-model --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-model\">Star</a>\n- **[can-view-scope]** <small><%can-view-scope.package.version%></small> Scope lookup\n  - `npm install can-view-scope --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-scope\">Star</a>\n- **[can-view-parser]** <small><%can-view-parser.package.version%></small> Parses HTML and magic tags\n  - `npm install can-view-parser --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-parser\">Star</a>\n- **[can-view-target]** <small><%can-view-target.package.version%></small> A fast-path DOM fragment compile target\n  - `npm install can-view-target --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-target\">Star</a>\n- **[can-view-live]** <small><%can-view-live.package.version%></small> Update the DOM with\n  a compute\n  - `npm install can-view-live --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-live\">Star</a>\n- **[can-view-nodelist]** <small><%can-view-nodelist.package.version%></small> Maintains live-binding relationships\n  - `npm install can-view-nodelist --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-nodelist\">Star</a>\n- **[can-cid]** <small><%can-cid.package.version%></small> Get a unique identifier for objects\n  - `npm install can-cid --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-cid\">Star</a>\n- **[can-deparam]** <small><%can-deparam.package.version%></small> Deserialize a query string into an array or object\n  - `npm install can-deparam --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-deparam\">Star</a>\n- **[can-param]** <small><%can-param.package.version%></small> Serialize an array or object into a query string\n  - `npm install can-param --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-param\">Star</a>\n- **[can-types]** <small><%can-types.package.version%></small> A stateful container for CanJS type information\n  - `npm install can-types --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-types\">Star</a>\n- **[can-namespace]** <small><%can-namespace.package.version%></small> Namespace where can-* packages are registered\n  - `npm install can-namespace --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-namespace\">Star</a>\n\n</div>\n\n### [can-ecosystem Ecosystem Collection]\n\n_Useful libraries that add important features or extend the core collection._\n\n<div class=\"module-list\">\n\n- **[can-fixture]** <small><%can-fixture.package.version%></small> Simulate AJAX requests\n  - `npm install can-fixture --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-fixture\">Star</a>\n- **[can-fixture-socket]** <small><%can-fixture-socket.package.version%></small> Simulate sockets\n  - `npm install can-fixture-socket --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-fixture-socket\">Star</a>\n- **[can-connect-feathers]** <small><%can-connect-feathers.package.version%></small> Create connections to a FeathersJS API server.\n  - `npm install can-connect-feathers --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-connect-feathers\">Star</a>\n- **[can-connect-signalr]** <small><%can-connect-signalr.package.version%></small> Create connections to a FeathersJS API server.\n  - `npm install can-connect-signalr --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-connect-signalr\">Star</a>\n- **[can-connect-cloneable]** <small><%can-connect-cloneable.package.version%></small> Make clones of Maps.\n  - `npm install can-connect-cloneable --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-connect-cloneable\">Star</a>\n- **[can-zone]** <small><%can-zone.package.version%></small> Track asynchronous activity\n  - `npm install can-zone --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-zone\">Star</a>\n- **[can-stache-converters]** <small><%can-stache-converters.package.version%></small> Form two-way binding helpers\n  - `npm install can-stache-converters --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stache-converters\">Star</a>\n- **[steal-stache]** <small><%steal-stache.package.version%></small> Import can-stache templates as dependencies with [http://stealjs.com StealJS]\n  - `npm install steal-stache --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/steal-stache\">Star</a>\n- **[can-view-import]** <small><%can-view-import.package.version%></small> Import modules within can-stache templates\n  - `npm install can-view-import --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-import\">Star</a>\n- **[can-view-autorender]** <small><%can-view-autorender.package.version%></small> Automatically\nrender templates in script tags\n  - `npm install can-view-autorender --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-autorender\">Star</a>\n- **[can-jquery]** <small><%can-jquery.package.version%></small> jQuery integrations\n  - `npm install can-jquery --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-jquery\">Star</a>\n- **[can-construct-super]** <small><%can-construct-super.package.version%></small> Call can-construct base methods easily\n  - `npm install can-construct-super --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-construct-super\">Star</a>\n- **[can-vdom]** <small><%can-vdom.package.version%></small> A virtual DOM that supports can-stache\n  - `npm install can-vdom --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-vdom\">Star</a>\n- **[can-stream-kefir]** <small><%can-stream-kefir.package.version%></small> Convert observable values into streams\n  - `npm install can-stream-kefir --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stream-kefir\">Star</a>\n- **[can-define-stream]** <small><%can-define-stream.package.version%></small> Define property values using streams\n  - `npm install can-define-stream --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-define-stream\">Star</a>\n- **[can-validate]** <small><%can-validate.package.version%></small> Validation tools and types definitions\n  - `npm install can-validate --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-validate\">Star</a>\n- **[can-validate-validatejs]** <small><%can-validate-validatejs.package.version%></small> Create validators with ValidateJS\n  - `npm install can-validate-validatejs --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-validate-validatejs\">Star</a>\n- **[can-define-validate-validatejs]** <small><%can-define-validate-validatejs.package.version%></small> Validation for DefineMaps using the ValidateJS library\n  - `npm install can-define-validate-validatejs --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-define-validate-validatejs\">Star</a>\n\n\n</div>\n\n### [can-legacy Legacy Collection]\n\n_Former libraries that are not under active development, but we\nstill accept patches._\n\n<div class=\"module-list\">\n\n- **[can-map]** <small><%can-map.package.version%></small> Observable map\n  - `npm install can-map --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-map\">Star</a>\n- **[can-list]** <small><%can-list.package.version%></small> Observable lists\n  - `npm install can-list --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-list\">Star</a>\n- **[can-map-define]** <small><%can-map-define.package.version%></small> Define property behavior\n  - `npm install can-map-define --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-map-define\">Star</a>\n- **[can-map-backup]** <small><%can-map-backup.package.version%></small> Save the last state\n  - `npm install can-map-backup --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-map-backup\">Star</a>\n- **[can-ejs]** <small><%can-ejs.package.version%></small> EJS templates\n  - `npm install can-ejs --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-ejs\">Star</a>\n- **[can-view-href]** <small><%can-view-href.package.version%></small> Older routing view helpers\n  - `npm install can-view-href --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-href\">Star</a>\n- **[can-validate-legacy]** <small><%can-validate-legacy.package.version%></small> Validation plugin for can-map's.\n  - `npm install can-validate-legacy --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-validate-legacy\">Star</a>\n</div>\n\n## The `can` Package\n\nWhile CanJS is designed to be used and should be used\nas independent packages, we still publish a `can` package\nwith a version number, currently `<%canjs.package.version%>`.\nWe do this so there is a specified version of all of the\nsub-project packages that are __integration tested__ to work together.  \n\nThe `can` package uses [semantic versioning](http://semver.org/)\nwith respect to the [can-core] and [can-infrastructure] collections\nonly.  Read the [guides/contributing/releases Release Guide] for more information on CanJS’s release process.\n\nThe sub-project package versions for `can <%canjs.package.version%>`\nare listed below. Copy the ones you use into your `package.json`\nif you want to use the same packages that were tested as part of\nCanJS `<%canjs.package.version%>`’s release.\n\n__Core Collection__\n\n```\n  \"can-component\": \"<%can-component.package.version%>\",\n  \"can-compute\": \"<%can-compute.package.version%>\",\n  \"can-connect\": \"<%can-connect.package.version%>\",\n  \"can-define\": \"<%can-define.package.version%>\",\n  \"can-route\": \"<%can-route.package.version%>\",\n  \"can-route-pushstate\": \"<%can-route-pushstate.package.version%>\",\n  \"can-set\": \"<%can-set.package.version%>\",\n  \"can-stache\": \"<%can-stache.package.version%>\",\n  \"can-stache-bindings\": \"<%can-stache-bindings.package.version%>\",\n```  \n\n__Infrastructure Collection__\n\n```js\n  \"can-construct\": \"<%can-stache-bindings.package.version%>\",\n  \"can-control\": \"<%can-control.package.version%>\",\n  \"can-event\": \"<%can-event.package.version%>\",\n  \"can-observation\": \"<%can-observation.package.version%>\",\n  \"can-simple-map\": \"<%can-simple-map.package.version%>\",\n  \"can-util\": \"<%can-util.package.version%>\",\n  \"can-view-callbacks\": \"<%can-view-callbacks.package.version%>\",\n  \"can-view-live\": \"<%can-view-live.package.version%>\",\n  \"can-view-model\": \"<%can-view-model.package.version%>\",\n  \"can-view-nodelist\": \"<%can-view-nodelist.package.version%>\",\n  \"can-view-parser\": \"<%can-view-parser.package.version%>\",\n  \"can-view-scope\": \"<%can-view-scope.package.version%>\",\n  \"can-view-target\": \"<%can-view-target.package.version%>\",\n```\n\n__Ecosystem collection__\n\n```\n  \"can-construct-super\": \"<%can-construct-super.package.version%>\",\n  \"can-define-stream\": \"<%can-define-stream.package.version%>\",\n  \"can-fixture\": \"<%can-fixture.package.version%>\",\n  \"can-fixture-socket\": \"<%can-fixture-socket.package.version%>\",\n  \"can-jquery\": \"<%can-jquery.package.version%>\",\n  \"can-stache-converters\": \"<%can-stache-converters.package.version%>\",\n  \"can-stream-kefir\": \"<%can-stream-kefir.package.version%>\",\n  \"can-vdom\": \"<%can-vdom.package.version%>\",\n  \"can-view-autorender\": \"<%can-view-autorender.package.version%>\",\n  \"can-view-import\": \"<%can-view-import.package.version%>\",\n  \"can-zone\": \"<%can-zone.package.version%>\",\n  \"steal-stache\": \"<%steal-stache.package.version%>\",\n```\n\n__Legacy Collection__\n\n```js\n  \"can-ejs\": \"<%can-ejs.package.version%>\",\n  \"can-list\": \"<%can-list.package.version%>\",\n  \"can-map\": \"<%can-map.package.version%>\",\n  \"can-map-backup\": \"<%can-map-backup.package.version%>\",\n  \"can-map-define\": \"<%can-map-define.package.version%>\",\n  \"can-view-href\": \"<%can-view-href.package.version%>\",\n```\n",
    "description": " Welcome to the CanJS docs! Learn about all the packages that make-up CanJS & how they work together to help you build amazing applications!\n\n",
    "name": "api",
    "title": "API Docs",
    "type": "page",
    "parent": "canjs",
    "order": 2,
    "outline": "0",
    "package": {
      "name": "can",
      "version": "3.8.1",
      "main": "can.js",
      "scripts": {
        "preversion": "npm test",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "testee": "testee test/index.html --browsers firefox",
        "testee-production": "testee test/production.html --browsers firefox",
        "http-server": "http-server -p 3000 --silent",
        "test": "npm run test-development && npm run test-production ",
        "test-development": "npm run build && npm run testee",
        "test-production": "npm run build && npm run build-tests && npm run testee-production",
        "ci": "npm run build && npm run test && node test/test-sauce-labs.js",
        "release:pre": "npm version prerelease && npm run build && npm publish",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:major": "npm version major && npm run build && npm publish",
        "build": "node build.js",
        "build-tests": "node test/build.js",
        "document": "bit-docs"
      },
      "title": "CanJS",
      "description": "MIT-licensed, client-side, JavaScript framework that makes building rich web applications easy.",
      "keywords": [
        "CanJS",
        "DoneJS"
      ],
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "web": "http://bitovi.com/"
      },
      "homepage": "http://canjs.com/",
      "repository": {
        "type": "git",
        "url": "git@github.com:canjs/canjs.git",
        "github": "https://github.com/canjs/canjs"
      },
      "dependencies": {
        "can-cid": "1.0.3",
        "can-component": "3.0.7",
        "can-compute": "3.0.10",
        "can-connect": "1.3.11",
        "can-connect-feathers": "3.5.5",
        "can-connect-cloneable": "0.1.3",
        "can-connect-signalr": "0.1.0",
        "can-construct": "3.1.1",
        "can-construct-super": "3.0.3",
        "can-control": "3.0.10",
        "can-define": "1.0.24",
        "can-define-stream": "0.1.1",
        "can-define-stream-kefir": "0.0.9",
        "can-define-validate-validatejs": "0.0.5",
        "can-deparam": "1.0.1",
        "can-ejs": "3.0.7",
        "can-event": "3.4.0",
        "can-fixture": "1.0.13",
        "can-fixture-socket": "0.6.2",
        "can-jquery": "3.0.7",
        "can-list": "3.0.5",
        "can-map": "3.0.7",
        "can-map-backup": "3.0.3",
        "can-map-define": "3.0.9",
        "can-namespace": "1.0.0",
        "can-observation": "3.1.4",
        "can-param": "1.0.1",
        "can-route": "3.0.10",
        "can-route-pushstate": "3.0.3",
        "can-set": "1.2.0",
        "can-simple-dom": "1.0.8",
        "can-simple-map": "3.1.3",
        "can-stache": "3.0.24",
        "can-stache-bindings": "3.1.4",
        "can-stache-converters": "3.0.7",
        "can-stream": "0.2.3",
        "can-stream-kefir": "0.2.3",
        "can-types": "1.0.4",
        "can-util": "3.7.0",
        "can-validate": "1.0.2",
        "can-validate-legacy": "1.0.2",
        "can-validate-validatejs": "0.0.6",
        "can-vdom": "3.0.3",
        "can-view-autorender": "3.0.4",
        "can-view-callbacks": "3.0.6",
        "can-view-href": "3.0.4",
        "can-view-import": "3.0.7",
        "can-view-live": "3.0.7",
        "can-view-model": "3.1.3",
        "can-view-nodelist": "3.0.4",
        "can-view-parser": "3.1.0",
        "can-view-scope": "3.1.4",
        "can-view-target": "3.0.7",
        "can-zone": "0.6.7"
      },
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "es6-promise": "^4.1.0",
        "feathers": "^2.0.3",
        "feathers-authentication-client": "^0.1.6",
        "feathers-hooks": "^1.7.1",
        "feathers-rest": "^1.5.0",
        "feathers-socketio": "^1.4.2",
        "funcunit": "^3.1.0-pre.1",
        "http-server": "^0.9.0",
        "jquery": "2.x - 3.x",
        "jquery-ui": "^1.12.0",
        "socket.io-client": "^1.7.2",
        "steal": "^0.16.44",
        "steal-qunit": "^0.1.1",
        "steal-stache": "^3.0.5",
        "steal-tools": "^0.16.8",
        "test-saucelabs": "0.0.1",
        "testee": "^0.5.0"
      },
      "demos": [
        "http://canjs.us/#examples",
        "http://canjs.us/recipes"
      ],
      "googleAnalyticsTrackingCode": "UA-2302003-11",
      "licenses": [
        {
          "type": "MIT",
          "url": "http://opensource.org/licenses/mit-license.php"
        }
      ],
      "system": {
        "npmAlgorithm": "flat",
        "main": "can",
        "npmIgnore": [
          "bit-docs",
          "testee",
          "async",
          "saucelabs",
          "test-saucelabs",
          "wd",
          "http-server"
        ],
        "meta": {
          "socket.io-client/dist/socket.io": {
            "format": "cjs"
          }
        }
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.6",
          "bit-docs-tag-sourceref": "^0.0.3",
          "bit-docs-generate-html": "^0.4.1",
          "bit-docs-html-canjs": "^0.4.15",
          "bit-docs-prettify": "^0.1.1",
          "bit-docs-html-highlight-line": "^0.2.2",
          "bit-docs-tag-demo": "^0.3.0",
          "bit-docs-tag-package": "^0.0.5"
        },
        "glob": {
          "pattern": "{node_modules,docs}/{can-*,steal-stache}/**/*.{js,md}",
          "ignore": [
            "node_modules/can-wait/examples/**/*",
            "node_modules/can-*/dist/**/*"
          ]
        },
        "altVersions": {
          "2.3.31": "https://v2.canjs.com"
        },
        "parent": "canjs",
        "minifyBuild": true
      }
    },
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "community": {
    "src": {
      "path": "docs/can-canjs/can-community.md"
    },
    "body": "\n<ul class=\"community-list\">\n  <li>\n    <a href=\"https://gitter.im/canjs/canjs\" target=\"_blank\">\n      <img src=\"/static/img/icon-gittr-gray.svg\" width=\"30\">\n      Chat with us on Gitter\n    </a>\n  </li>\n  <li>\n    <a href=\"https://github.com/canjs/canjs\" target=\"_blank\">\n      <img src=\"/static/img/icon-github-gray.svg\" width=\"30\">\n      Star us on GitHub\n    </a>\n  </li>\n  <li>\n    <a href=\"http://stackoverflow.com/search?q=canjs\" target=\"_blank\">\n      <img src=\"/static/img/icon-stackoverflow-gray.svg\" width=\"30\">\n      Ask questions on Stack Overflow\n    </a>\n  </li>\n  <li>\n    <a href=\"http://forums.donejs.com/c/canjs\" target=\"_blank\">\n      <img src=\"/static/img/icon-forums-gray.svg\" width=\"30\">\n      Visit our forums\n    </a>\n  </li>\n  <li>\n    <a href=\"https://www.meetup.com/find/?keywords=canjs&radius=Infinity\" target=\"_blank\">\n      <img src=\"/static/img/icon-meetup-gray.svg\" width=\"30\">\n      Find a local Meetup group\n    </a>\n  </li>\n  <li>\n    <a href=\"https://www.youtube.com/channel/UCM_xC8UOHt2ay5wz-3gotmg\" target=\"_blank\">\n      <img src=\"/static/img/icon-youtube-gray.svg\" width=\"30\">\n      Watch videos on YouTube\n    </a>\n  </li>\n  <li>\n    <a href=\"https://twitter.com/canjs\" target=\"_blank\">\n      <img src=\"/static/img/icon-twitter-gray.svg\" width=\"30\">\n      Follow us on Twitter\n    </a>\n  </li>\n  <li>\n    <a href=\"https://www.bitovi.com/blog/topic/canjs\" target=\"_blank\">\n      <img src=\"/static/img/icon-rss-gray.svg\" width=\"30\">\n      Read our blog\n    </a>\n  </li>\n</ul>\n\n## Upcoming Events\n\n[DoneJS.com’s Upcoming Events](https://donejs.com/community.html#events) section has a list of meetup events in the near future!\n\n## Contribute to CanJS\n\nCheck out the contribute section of the [guides] page for information on [guides/contributing/bug-report reporting bugs], [guides/contributing/feature-suggestion suggesting features], and more!\n\n## Consultancies\n\nLooking for professional help? [Bitovi](https://www.bitovi.com) is the primary corporate sponsor of CanJS. [Contact Bitovi](https://www.bitovi.com/contact) for contract opportunities.\n\nDoes your company offer CanJS consulting services? [Edit this page on GitHub](https://github.com/canjs/canjs/edit/master/docs/can-canjs/can-community.md) and submit a pull request to add yourself here!\n\n",
    "description": " Get involved with one of the most inviting communities on the internet!\n\n",
    "name": "community",
    "title": "Community",
    "type": "page",
    "parent": "canjs",
    "order": 3,
    "outline": "0",
    "comment": " "
  },
  "can-core": {
    "src": {
      "path": "docs/can-canjs/can-core.md"
    },
    "body": "\n## Use\n\nCanJS’s core libraries are the best, most hardened and generally useful modules.  \nEach module is part of an independent package, so you\nshould install the ones you use directly:\n\n```\nnpm install can-component can-compute can-connect can-define can-route can-route-pushstate can-set can-stache can-stache-bindings --save\n```\n\n\nLet’s explore each module a bit more.\n\n## can-compute\n\n[can-compute]s represent an observable value.  A compute can contain its\nown value and notify listeners of changes like:\n\n```js\nvar compute = require(\"can-compute\");\n\nvar name = compute(\"Justin\");\n\n// read the value\nname() //-> \"Justin\"\n\nname.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Matthew\"\n\toldVal //-> \"Justin\"\n});\n\nname(\"Matthew\");\n```\n\nMore commonly, a compute derives its value from other observables.  The following\n`info` compute derives its value from a `person` map, `hobbies` list, and `age`\ncompute:\n\n```js\nvar DefineMap = require(\"can-define/map/map\"),\n\tDefineList = require(\"can-define/list/list\"),\n\tcompute = require(\"can-compute\");\n\nvar person = new DefineMap({first: \"Justin\", last: \"Meyer\"}),\n\thobbies = new DefineList([\"js\",\"bball\"]),\n\tage = compute(33);\n\nvar info = compute(function(){\n\treturn person.first +\" \"+ person.last+ \" is \"+age()+\n\t\t\"and like \"+hobbies.join(\", \")+\".\";\n});\n\ninfo() //-> \"Justin Meyer is 33 and likes js, bball.\"\n\ninfo.on(\"change\", function(ev, newVal){\n\tnewVal //-> \"Justin Meyer is 33 and likes js.\"\n});\n\nhobbies.pop();\n```\n\n\n## can-define\n\n[can-define/map/map] and [can-define/list/list] allow you to create observable\nmaps and lists with well-defined properties.  You can\n[can-define.types.propDefinition define a property’s type initial value, enumerability, getter-setters and much more].\nFor example, you can define the behavior of a `Todo` type and a `TodoList` type as follows:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({           // A todo has a:\n  name: \"string\",                       // .name that’s a string\n  complete: {                           // .complete that’s\n\ttype: \"boolean\",                    //        a boolean\n\tvalue: false                        //        initialized to false\n  },                                    \n  dueDate: \"date\",                      // .dueDate that’s a date\n  get isPastDue(){                      // .pastDue that returns if the\n\treturn new Date() > this.dueDate;   //        dueDate is before now\n  },\n  toggleComplete: function(){           // .toggleComplete method that\n    this.complete = !this.complete;     //        changes .complete\n  }\n});\n\nvar TodoList = DefineList.extend({      // A list of todos:     \n  \"#\": Todo,                            // has numeric properties\n                                        //         as todos\n\n  get completeCount(){                  // has .completeCount that\n    return this.filter(\"complete\")      //         returns # of\n\t           .length;                 //         complete todos\n  }\n});\n```\n\nThis allows you to create a Todo, read its properties, and\ncall back its methods like:\n\n```js\nvar dishes = new Todo({\n\tname: \"do dishes\",\n\t// due yesterday\n\tdueDate: new Date() - 1000 * 60 * 60 * 24\n});\ndishes.name      //-> \"do dishes\"\ndishes.isPastDue //-> true\ndishes.complete  //-> false\ndishes.toggleComplete()  \ndishes.complete  //-> true\n```\n\nAnd it allows you to create a `TodoList`, access its items and properties\nlike:\n\n```js\nvar todos = new TodoList( dishes, {name: \"mow lawn\", dueDate: new Date()});\ntodos.length         //-> 2\ntodos[0].complete    //-> true\ntodos.completeCount //-> 1\n```\n\nThese observables provide the foundation\nfor data connection (models), view-models and even routing in your application.\n\n## can-set\n\n[can-set] models a service layer’s behavior as a [can-set.Algebra set.Algebra]. Once modeled, other libraries such as [can-connect] or [can-fixture] can\nadd a host of functionality like: real-time behavior, performance optimizations, and\nsimulated service layers.\n\nA `todosAlgebra` set algebra for a `GET /api/todos` service might look like:\n\n```js\nvar set = require(\"can-set\");\nvar todosAlgebra = new set.Algebra(\n    // specify the unique identifier property on data\n    set.prop.id(\"_id\"),  \n    // specify that completed can be true, false or undefined\n    set.prop.boolean(\"complete\"),\n    // specify the property that controls sorting\n    set.prop.sort(\"orderBy\")\n)\n```\n\nThis assumes that the service:\n\n - Returns data where the unique property name is `_id`:\n   ```js\n   GET /api/todos\n   -> [{_id: 1, name: \"mow lawn\", complete: true},\n       {_id: 2, name: \"do dishes\", complete: false}, ...]\n   ```\n - Can filter by a `complete` property:\n   ```js\n   GET /api/todos?complete=false\n   -> [{_id: 2, name: \"do dishes\", complete: false}, ...]\n   ```\n - Sorts by an `orderBy` property:\n   ```js\n   GET /api/todos?orderBy=name\n   -> [{_id: 2, name: \"do dishes\", complete: false},\n       {_id: 1, name: \"mow lawn\", complete: true}]\n   ```\n\nIn the next section will use `todoAlgebra` to build a model with [can-connect].\n\n## can-connect\n\n[can-connect] connects a data type, typically a `DefineMap` and its `DefineList`,\nto a service layer. This is often done via the\n[can-connect/can/base-map/base-map] module which bundles many common behaviors\ninto a single api:\n\n```js\nvar baseMap = require(\"can-connect/can/base-map/base-map\"),\n    DefineMap = require(\"can-define/map/map\"),\n    DefineList = require(\"can-define/list/list\"),\n\tset = require(\"can-set\");\n\nvar Todo = DefineMap.extend({\n\t...\n});\nvar TodosList = DefineMap.extend({\n\t\"#\": Todo,\n\t...\n});\nvar todosAlgebra = new set.Algebra({\n\t...\n});\n\nvar connection = baseMap({\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList,\n\talgebra: todosAlgebra,\n\tname: \"todo\"\n});\n```\n\n`baseMap` extends the `Map` type, in this case, `Todo`, with\nthe ability to make requests to the service layer.\n\n - [can-connect/can/map/map.getList Get a list] of Todos\n   ```js\n   Todo.getList({complete: true}).then(function(todos){})\n   ```\n - [can-connect/can/map/map.get Get] a single Todo\n   ```js\n   Todo.get({_id: 6}).then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.save Create] a Todo\n   ```js\n   var todo = new Todo({name: \"do dishes\", complete: false})\n   todo.save().then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.save Update] an [can-connect/can/map/map.prototype.isNew already created] Todo\n   ```js\n   todo.complete = true;\n   todo.save().then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.destroy Delete] a Todo\n   ```js\n   todo.destroy().then(function(todo){})\n   ```\n\n[can-connect] is also middleware, so custom connections can\nbe assembled too:\n\n```js\nvar base = require(\"can-connect/base/base\");\nvar dataUrl = require(\"can-connect/data-url/data-url\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar map = require(\"can-connect/can/map/map\");\n\nvar options = {\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList,\n\talgebra: todosAlgebra,\n\tname: \"todo\"\n}\nvar connection = map(constructor(dataUrl(base(options))));\n```\n\n## can-stache\n\n[can-stache] provides live binding mustache and handlebars syntax. While\ntemplates should typically be loaded with a module loader like [steal-stache],\nyou can create a template programmatically that lists out todos within a\npromise loaded from `Todo.getList` like:\n\n```js\nvar stache = require(\"can-stache\");\n\n// Creates a template\nvar template = stache(\n\t\"<ul>\"+\n\t\t\"{{#if todos.isPending}}<li>Loading…</li>{{/if}}\"+\n\t\t\"{{#if todos.isResolved}}\"+\n\t\t\t\"{{#each todos.value}}\"+\n\t\t\t\t\"<li class='{{#complete}}complete{{/complete}}'>{{name}}</li>\"+\n\t\t\t\"{{else}}\"+\n\t\t\t\t\"<li>No todos</li>\"+\n\t\t\t\"{{/each}}\"+\n\t\t\"{{/if}}\"+\n\t\"</ul>\");\n\n// Calls the template with some data\nvar frag = template({\n\ttodos: Todo.getList({})\n});\n\n// Inserts the result into the page\ndocument.body.appendChild(frag);\n```\n\n[can-stache] templates use magic tags like `{{}}` to control what\ncontent is rendered. The most common forms of those magic tags are:\n\n - [can-stache.tags.escaped {{key}}] - Insert the value at `key` in the page. If `key` is a function or helper, run it and insert the result.\n - [can-stache.tags.section {{#key}}...{{/key}}] - Render the content between magic tags based on some criteria.  \n\n[can-stache] templates return document fragments that update whenever\ntheir source data changes.\n\n## can-component\n\n[can-component] creates custom elements with unit-testable view models. It\ncombines a view model created by [can-define/map/map] with a template\ncreated by [can-stache].\n\n```js\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\n// Defines the todos-list view model\nvar TodosListVM = DefineMap.extend({\n\t// An initial value that is a promise containing the\n\t// list of all todos.\n\ttodos: {\n\t\tvalue: function(){\n\t\t\treturn Todo.getList({});\n\t\t}\n\t},\n\t// A method that toggles a todo’s complete property\n\t// and updates the todo on the server.\n\ttoggleComplete: function(todo){\n\t\ttodo.complete = !todo.complete;\n\t\ttodo.save();\n\t}\n});\n\nComponent.extend({\n\ttag: \"todos-list\",\n\tViewModel: TodosVM,\n\tview: stache(\n\t\t\"<ul>\"+\n\t\t\t\"{{#if todos.isPending}}<li>Loading…</li>{{/if}}\"+\n\t\t\t\"{{#if todos.isResolved}}\"+\n\t\t\t\t\"{{#each todos.value}}\"+\n\t\t\t\t\t\"<li ($click)='toggleComplete(.)'\"+\n\t\t\t\t\t     \"class='{{#complete}}complete{{/complete}}'>{{name}}</li>\"+\n\t\t\t\t\"{{else}}\"+\n\t\t\t\t\t\"<li>No todos</li>\"+\n\t\t\t\t\"{{/each}}\"+\n\t\t\t\"{{/if}}\"+\n\t\t\"</ul>\");\n});\n```\n\n## can-stache-bindings\n\n[can-stache-bindings] provides [can-view-callbacks.attr custom attributes] for\n[can-stache] event and data bindings.\n\nBindings look like:\n\n - `(event)=\"key()\"` for [can-stache-bindings.event event binding].\n - `{prop}=\"key\"` for [can-stache-bindings.toChild one-way binding to a child].\n - `{^prop}=\"key\"` for [can-stache-bindings.toParent one-way binding to a parent].\n - `{(prop)}=\"key\"` for [can-stache-bindings.twoWay two-way binding].\n\nAdding `$` to a binding like `($event)=\"key()\"` changes the binding from the viewModel to the element’s attributes or properties.\n\n[can-stache-bindings.event Event] binding examples:\n\n```html\n<!-- calls `toggleComplete` when the li is clicked -->\n<li ($click)=\"toggleComplete(.)\"/>\n\n<!-- calls `resetData` when cancel is dispatched on `my-modal`’s view model -->\n<my-modal (cancel)=\"resetData()\"/>\n```\n\n[can-stache-bindings.toChild One-way to child] examples:\n\n```html\n<!-- updates input’s `checked` property with the value of complete -->\n<input type=\"checkbox\" {$checked}=\"complete\"/>\n\n<!-- updates `todo-lists`’s  `todos` property with the result of `getTodos`-->\n<todos-list {todos}=\"getTodos(complete=true)\"/>\n```\n\n[can-stache-bindings.toChild One-way to parent] examples:\n\n```html\n<!-- updates `complete` with input’s `checked` property -->\n<input type=\"checkbox\" {^$checked}=\"complete\"/>\n\n<!-- updates `todosList` with `todo-lists`’s `todos` property -->\n<todos-list {^todos}=\"todosList\"/>\n```\n\n[can-stache-bindings.twoWay Two-way] examples:\n\n```html\n<!-- Updates the input’s `value` with `name` and vice versa -->\n<input type=\"text\" {($value)}=\"name\"/>\n\n<!-- Updates `date-picker`’s `date` with `dueDate` and vice versa -->\n<date-picker {(date)}=\"dueDate\"/>\n```\n\n## can-route and can-route-pushstate\n\n[can-route] connects a `DefineMap`’s properties to values in the\nurl. Create a map type, [canjs/doc/can-route.map connect it to the url], and [can-route.ready begin routing] like:\n\n```js\nvar route = require(\"can-route\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar AppViewModel = DefineMap.extend({\n\tseal: false\n},{\n\t// Sets the default type to string\n\t\"#\": \"string\",\n\ttodoId: \"string\",\n\ttodo: {\n\t\tget: function(){\n\t\t\tif(this.todoId) {\n\t\t\t\treturn Todo.get({_id: this.todoId})\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar appViewModel = new AppViewModel();\nroute.map(appViewModel);\n\nroute.ready();\n```\n\nWhen the url changes, to something like `#!&todoId=5`, so will the\n`appViewModel`’s `todoId` and `todo` property:\n\n```js\nappViewModel.todoId //-> \"5\"\nappViewModel.todo   //-> Promise<Todo>\n```\n\nSimilarly, if `appViewModel`’s `todoId` is set like:\n\n```js\nappViewModel.todoId = 6;\n```\n\nThe hash will be updated:\n\n```js\nwindow.location.hash //-> \"#!&todoId=6\"\n```\n\nThe `route` function can be used to specify pretty routing rules that\ntranslate property changes to a url and a url to property changes. For example,\n\n```js\n// a route like:\nroute(\"todo/{todoId}\");\n\n// and a hash like:\nwindow.location.hash = \"#!todo/7\";\n\n// produces an appViewModel like:\nappViewModel.serialize() //-> {route: \"todo/{todoId}\", todoId: \"7\"}\n```\n\n[can-route-pushstate] adds [pushstate](https://developer.mozilla.org/en-US/docs/Web/API/History_API) support. It\nmixes in this behavior so you just need to import the module:\n\n```js\nvar route = require(\"can-route\");\nrequire(\"can-route-pushstate\");\n```\n\n\n## Want to learn more?\n\nIf you haven’t already, check out the [guides] page on how to learn CanJS.  Specifically, you’ll\nwant to check out the [guides/chat] and [guides/todomvc] to learn the basics of using CanJS’s\ncore libraries.  After that, check out the [guides/api] on how to use and learn from these API docs.\n\n",
    "description": "The best, most hardened and generally useful libraries in CanJS.   \n",
    "name": "can-core",
    "title": "Core",
    "type": "page",
    "parent": "api",
    "order": 0,
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "can-ecosystem": {
    "src": {
      "path": "docs/can-canjs/can-ecosystem.md"
    },
    "body": "\n",
    "description": "Useful libraries that extend or add important features to the core collection. \n",
    "name": "can-ecosystem",
    "title": "Ecosystem",
    "type": "page",
    "parent": "api",
    "order": 2,
    "comment": " "
  },
  "can-infrastructure": {
    "src": {
      "path": "docs/can-canjs/can-infrastructure.md"
    },
    "body": "\n## Use\n\nThe infrastructure collection of libraries are lower-level utility libraries that\nare used by the [can-core] and [can-ecosystem] collections.  They can also\nbe used by applications directly.\n\nLet’s explore what’s available.\n\n## can-event\n\n[can-event] is a mixin that adds event dispatching and listening functionality\non your objects. The following shows creating a `Person` constructor function\nwhose instances can produce events that can be listened to.\n\n```js\nvar canEvent = require(\"can-event\");\nvar assign = require(\"can-util/js/assign/assign\");\n\n// Create the Person type\nfunction Person(){ ... };\nPerson.prototype.method = function(){ ... };\n\n// Add event mixin:\nassign(Person.prototype, canEvent);\n\n// Create an instance\nvar me = new Person();\n\n// Now listen and dispatch events!\nme.addEventListener(\"name\", function(){ ... });\n\nme.dispatch(\"name\");\n```\n\n[can-event/batch/batch] adds event batching abilities to the [can-event] event system.\n[can-event/async/async] adds asynchronous batched event dispatching to the [can-event] event system.\n\n## can-observation\n\n[can-observation] provides a mechanism to notify when an observable has been read and a way to observe those reads called within a given function.  [can-observation] provides the foundation for [can-compute]’s abilities.\n\nUse [can-observation.add Observation.add] to signal when an an observable value has been read.\nThe following makes the `Person` type’s `getName()` observable:\n\n```js\nvar Observation = require(\"can-observation\");\nvar canEvent = require(\"can-event\");\nvar assign = require(\"can-util/js/assign/assign\");\n\n// Create the Person type\nfunction Person(){};\nPerson.prototype.setName = function(newName){\n\tvar oldName = this.name;\n\tthis.name = newName;\n\tthis.dispatch(\"name\", [newName, oldName]);\n};\nPerson.prototype.getName = function(){\n\tObservation.add(this, \"name\");\n\treturn this.name;\n};\n```\n\nThe `Observation` constructor can be used, similar to a [can-compute] to observe\na function’s return value by tracking calls to `Observation.add`\n\n```js\nvar person = new Person();\nperson.setName(\"Justin\");\n\n\nvar greetingObservation = new Observation(function(){\n\treturn person.getName() + \" says hi!\";\n}, null, function(newValue){\n\tconsole.log(newValue);\n});\ngreetingObservation.start();\n\ngreetingObservation.value //-> \"Justin says hi!\"\n\nperson.setName(\"Matt\") //-> console.logs \"Matt says hi!\";\n```\n\n## can-util\n\n[can-util] is a collection of many different modules that provide various JavaScript\nand DOM related utilities.\n\n### DOM Utilities\n\nThe DOM utilities consist of:\n\n - Node and Element helpers: [can-util/dom/child-nodes/child-nodes], [can-util/dom/class-name/class-name], [can-util/dom/data/data], [can-util/dom/frag/frag].\n - Event helpers: [can-util/dom/dispatch/dispatch], [can-util/dom/events/delegate/delegate], [can-util/dom/events/attributes/attributes], [can-util/dom/events/inserted/inserted], [can-util/dom/events/removed/removed].\n - Ajax helpers: [can-util/dom/ajax/ajax].\n - Environment identification helpers: [can-util/dom/document/document].\n\nAnd the [can-util/dom/mutate/mutate] helper which should be used to manipulate DOM\nnodes in elements that do not support [MutationObservers](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver).  \n\n\n### JS Utilities\n\nThe JS utilities consist of:\n\n- Functional helpers: [can-util/js/each/each], [can-util/js/assign/assign], [can-util/js/deep-assign/deep-assign], [can-util/js/make-array/make-array].\n- Type detection helpers: [can-util/js/is-array-like/is-array-like],  [can-util/js/is-empty-object/is-empty-object], [can-util/js/is-function], [can-util/js/is-plain-object/is-plain-object], [can-util/js/is-promise/is-promise], [can-util/js/is-string/is-string], [can-util/js/types/types].\n- Environment detection helpers: [can-util/js/is-browser-window/is-browser-window], [can-util/js/is-node/is-node], [can-util/js/is-web-worker/is-web-worker].\n- Environment identification helpers: [can-util/js/global/global], [can-util/js/import/import], [can-util/js/base-url/base-url].\n- Polyfills - [can-util/js/set-immediate/set-immediate].\n- URL helpers: [can-param], [can-deparam], [can-util/js/join-uris/join-uris].\n- Diffing helpers: [can-util/js/diff/diff], [can-util/js/diff-object/diff-object].\n- String helpers: [can-util/js/string/string], [can-util/js/string-to-any/string-to-any].\n- Object identification helpers: [can-util/js/cid/cid].\n\n\n## can-view-callbacks\n\n[can-view-callbacks] lets you register callbacks for specific elements or attributes found in\ntemplates.\n\n```js\nvar callbacks = require(\"can-view-callbacks\");\n\ncallbacks.tag(\"blue-el\", function(el){\n    el.style.background = \"blue\";\n});\n```\n\n## can-view-live\n\nSets up a live-binding between the DOM and a compute.\n\n```js\nvar live = require(\"can-view-live\");\nvar compute = require(\"can-compute\");\nvar frag = require(\"can-util/dom/frag/frag\");\n\nvar message = compute(\"World\");\n\nvar content = frag(\"Hello\",\"\",\"!\");\n\nlive.text(content.childNodes[1], message);\n\ndocument.body.appendChild(content);\n\nmessage(\"Earth\");\n\ndocument.body.innerHTML //-> Hello Earth!\n```\n\n## can-view-nodelist\n\n[can-view-nodelist] is used to maintain the structure of HTML nodes produced by a\ntemplate. For example, a [can-stache] template like:\n\n```\n{{#if over21}}name:{{{highlight name}}}.{{/if}}\n```\n\nMight result in a nodeList structure that looks like:\n\n```\nif[\n\tTextNode(\"name:\"),\n\thighlight[<b>Justin</b>]\n]\n```\n\nThis is to say that the `#if over21` nodeList will contain a text node for `\"name:\"`\nand the `highlight name` nodeList.  The `highlight name` nodeList will contain the\nhtml content resulting from that helper (`<b>Justin</b>`).\n\n## can-view-parser\n\n[can-view-parser] parses HTML and handlebars/mustache tokens.  \n\n```js\nvar parser = require(\"can-view-parser\");\n\nvar html = '<h1><span first=\"foo\"></span><span second=\"bar\"></span></h1>';\n\nvar attrs = [];\n\nparser(html, {\n    attrStart: function(attrName){\n        attrs.push(attrName)\n    }\n});\n\nattrs //-> [\"first\", \"second\"]\n```\n\n## can-view-scope\n\n[can-view-scope] provides a lookup node within a contextual lookup. This is similar\nto a call object in closure in JavaScript.  Consider how `message`, `first`, and `last` are looked up in the following JavaScript:\n\n```js\nvar message = \"Hello\"\nfunction outer(){\n    var last = \"Abril\";\n\n    function inner(){\n        var first = \"Alexis\";\n        console.log(message + \" \"+ first + \" \" + last);\n    }\n    inner();\n}\nouter();\n```\n\n[can-view-scope] can be used to create a similar lookup path:\n\n```js\nvar globalScope = new Scope({message: \"Hello\"});\nvar outerScope = globalScope.add({last: \"Abril\"});\nvar innerScope = outerScope.add({first: \"Alexis\"});\ninnerScope.get(\"message\") //-> Hello\ninnerScope.get(\"first\")   //-> Alexis\ninnerScope.get(\"last\")    //-> Abril\n```\n\n## can-view-target\n\n[can-view-target] is used to create a document fragment that can be quickly cloned but\nhave callbacks called quickly on specific elements within the cloned fragment.\n\n```js\nvar viewTarget = require(\"can-view-target\");\n\nvar target = viewTarget([\n    {\n        tag: \"h1\",\n        callbacks: [function(data){\n            this.className = data.className\n        }],\n        children: [\n            \"Hello \",\n            function(){\n                this.nodeValue = data.message\n            }\n        ]\n    },\n]);\n\n// target.clone -> <h1>|Hello||</h1>\n// target.paths -> path: [0], callbacks: [], children: {paths: [1], callbacks:[function(){}]}\n\nvar frag = target.hydrate({className: \"title\", message: \"World\"});\n\nfrag //-> <h1 class='title'>Hello World</h1>\n```\n\n## can-cid\n\n[can-cid] is used to get a unique identifier for an object, optionally prefixed by a type name. Once set, the unique identifier does not change, even if the type name changes on subsequent calls.\n\n```js\nvar cid = require(\"can-cid\");\nvar x = {};\nvar y = {};\n\nconsole.log(cid(x, \"demo\")); // -> \"demo1\"\nconsole.log(cid(x, \"prod\")); // -> \"demo1\"\nconsole.log(cid(y));         // -> \"2\"\n```\n\n## can-types\n\n[can-types] is used to provide default types or test if something is of a certain type.\n\n```js\nvar types = require(\"can-types\");\nvar oldIsMapLike = types.isMapLike;\ntypes.isMapLike = function(obj){\n  return obj instanceof DefineMap || oldIsMapLike.apply(this, arguments);\n};\ntypes.DefaultMap = DefineMap;\n```\n\n## can-namespace\n\n[can-namespace] is a namespace where can-* packages can be registered.\n\n```js\nvar namespace = require('can-namespace');\n\nvar unicorn = {\n\t// ...\n};\n\nif (namespace.unicorn) {\n\tthrow new Error(\"You can't have two versions of can-unicorn, check your dependencies\");\n} else {\n\tmodule.exports = namespace.unicorn = unicorn;\n}\n```\n\n",
    "description": "Utility libraries that power the core and ecosystem collection. \n",
    "name": "can-infrastructure",
    "title": "Infrastructure",
    "type": "page",
    "parent": "api",
    "order": 1,
    "comment": " "
  },
  "can-legacy": {
    "src": {
      "path": "docs/can-canjs/can-legacy.md"
    },
    "body": "\n",
    "description": "Former libraries that we still accept patches for, but are not under active development.\n\n",
    "name": "can-legacy",
    "title": "Legacy",
    "type": "page",
    "parent": "api",
    "order": 3,
    "comment": " "
  },
  "canjs": {
    "src": {
      "path": "docs/can-canjs/canjs.md"
    },
    "body": "\n\n## Missing Something?\n\nIs there an itch that CanJS doesn’t scratch?  Let us know\non [Gitter chat](https://gitter.im/canjs/canjs) or the [forums](http://forums.donejs.com/c/canjs).\nWe like contributions of all sorts.  Read the [guides] _Contributing_ section for more details.\n\n## Love Something?\n\nLet us know by giving us a star on [GitHub](https://github.com/canjs/canjs) and following on [Twitter](https://twitter.com/canjs).  If there’s a particular package you like, make sure to star that too. Check out the [guides/contributing/evangelism Evangelism Guide] on\nhow to help spread the word!\n\n",
    "description": "CanJS is an evolving and improving set of client side JavaScript architectural libraries that balances innovation and stability. It targets experienced developers building complex applications with long futures ahead of them.    \n<img\n    srcset=\"docs/images/home/Home-Tortoise-bw.png 1x, docs/images/home/Home-Tortoise-bw-x2.png 2x\"\n    src=\"docs/images/home/Home-Tortoise-bw.png\"\n    style=\"float:right; padding-right: 40px;\"/>\n<img\n    srcset=\"docs/images/home/Home-Hare-bw.png 1x, docs/images/home/Home-Hare-bw-x2.png 2x\"\n    src=\"docs/images/home/Home-Tortoise-bw.png\" style=\"padding-left: 40px;\"/>\n\nIf you’re new to the project, the best place to start is the [about] page, where you’ll\nfind CanJS’s [guides/mission Mission] and [guides/technical Technical Highlights]. Then, go to the [guides] page to find\nthe [guides/chat Chat], [guides/todomvc TodoMVC], and [guides/atm ATM] guides.\n\n",
    "name": "canjs",
    "title": "CanJS",
    "type": "page",
    "dest": "../index",
    "outline": "0",
    "package": {
      "name": "can",
      "version": "3.8.1",
      "main": "can.js",
      "scripts": {
        "preversion": "npm test",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "testee": "testee test/index.html --browsers firefox",
        "testee-production": "testee test/production.html --browsers firefox",
        "http-server": "http-server -p 3000 --silent",
        "test": "npm run test-development && npm run test-production ",
        "test-development": "npm run build && npm run testee",
        "test-production": "npm run build && npm run build-tests && npm run testee-production",
        "ci": "npm run build && npm run test && node test/test-sauce-labs.js",
        "release:pre": "npm version prerelease && npm run build && npm publish",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:major": "npm version major && npm run build && npm publish",
        "build": "node build.js",
        "build-tests": "node test/build.js",
        "document": "bit-docs"
      },
      "title": "CanJS",
      "description": "MIT-licensed, client-side, JavaScript framework that makes building rich web applications easy.",
      "keywords": [
        "CanJS",
        "DoneJS"
      ],
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "web": "http://bitovi.com/"
      },
      "homepage": "http://canjs.com/",
      "repository": {
        "type": "git",
        "url": "git@github.com:canjs/canjs.git",
        "github": "https://github.com/canjs/canjs"
      },
      "dependencies": {
        "can-cid": "1.0.3",
        "can-component": "3.0.7",
        "can-compute": "3.0.10",
        "can-connect": "1.3.11",
        "can-connect-feathers": "3.5.5",
        "can-connect-cloneable": "0.1.3",
        "can-connect-signalr": "0.1.0",
        "can-construct": "3.1.1",
        "can-construct-super": "3.0.3",
        "can-control": "3.0.10",
        "can-define": "1.0.24",
        "can-define-stream": "0.1.1",
        "can-define-stream-kefir": "0.0.9",
        "can-define-validate-validatejs": "0.0.5",
        "can-deparam": "1.0.1",
        "can-ejs": "3.0.7",
        "can-event": "3.4.0",
        "can-fixture": "1.0.13",
        "can-fixture-socket": "0.6.2",
        "can-jquery": "3.0.7",
        "can-list": "3.0.5",
        "can-map": "3.0.7",
        "can-map-backup": "3.0.3",
        "can-map-define": "3.0.9",
        "can-namespace": "1.0.0",
        "can-observation": "3.1.4",
        "can-param": "1.0.1",
        "can-route": "3.0.10",
        "can-route-pushstate": "3.0.3",
        "can-set": "1.2.0",
        "can-simple-dom": "1.0.8",
        "can-simple-map": "3.1.3",
        "can-stache": "3.0.24",
        "can-stache-bindings": "3.1.4",
        "can-stache-converters": "3.0.7",
        "can-stream": "0.2.3",
        "can-stream-kefir": "0.2.3",
        "can-types": "1.0.4",
        "can-util": "3.7.0",
        "can-validate": "1.0.2",
        "can-validate-legacy": "1.0.2",
        "can-validate-validatejs": "0.0.6",
        "can-vdom": "3.0.3",
        "can-view-autorender": "3.0.4",
        "can-view-callbacks": "3.0.6",
        "can-view-href": "3.0.4",
        "can-view-import": "3.0.7",
        "can-view-live": "3.0.7",
        "can-view-model": "3.1.3",
        "can-view-nodelist": "3.0.4",
        "can-view-parser": "3.1.0",
        "can-view-scope": "3.1.4",
        "can-view-target": "3.0.7",
        "can-zone": "0.6.7"
      },
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "es6-promise": "^4.1.0",
        "feathers": "^2.0.3",
        "feathers-authentication-client": "^0.1.6",
        "feathers-hooks": "^1.7.1",
        "feathers-rest": "^1.5.0",
        "feathers-socketio": "^1.4.2",
        "funcunit": "^3.1.0-pre.1",
        "http-server": "^0.9.0",
        "jquery": "2.x - 3.x",
        "jquery-ui": "^1.12.0",
        "socket.io-client": "^1.7.2",
        "steal": "^0.16.44",
        "steal-qunit": "^0.1.1",
        "steal-stache": "^3.0.5",
        "steal-tools": "^0.16.8",
        "test-saucelabs": "0.0.1",
        "testee": "^0.5.0"
      },
      "demos": [
        "http://canjs.us/#examples",
        "http://canjs.us/recipes"
      ],
      "googleAnalyticsTrackingCode": "UA-2302003-11",
      "licenses": [
        {
          "type": "MIT",
          "url": "http://opensource.org/licenses/mit-license.php"
        }
      ],
      "system": {
        "npmAlgorithm": "flat",
        "main": "can",
        "npmIgnore": [
          "bit-docs",
          "testee",
          "async",
          "saucelabs",
          "test-saucelabs",
          "wd",
          "http-server"
        ],
        "meta": {
          "socket.io-client/dist/socket.io": {
            "format": "cjs"
          }
        }
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.6",
          "bit-docs-tag-sourceref": "^0.0.3",
          "bit-docs-generate-html": "^0.4.1",
          "bit-docs-html-canjs": "^0.4.15",
          "bit-docs-prettify": "^0.1.1",
          "bit-docs-html-highlight-line": "^0.2.2",
          "bit-docs-tag-demo": "^0.3.0",
          "bit-docs-tag-package": "^0.0.5"
        },
        "glob": {
          "pattern": "{node_modules,docs}/{can-*,steal-stache}/**/*.{js,md}",
          "ignore": [
            "node_modules/can-wait/examples/**/*",
            "node_modules/can-*/dist/**/*"
          ]
        },
        "altVersions": {
          "2.3.31": "https://v2.canjs.com"
        },
        "parent": "canjs",
        "minifyBuild": true
      }
    },
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "guides/experiment": {
    "name": "guides/experiment",
    "title": "experiment",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 0
  },
  "guides/commitment": {
    "name": "guides/commitment",
    "title": "commitment",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 1
  },
  "guides/contribute": {
    "name": "guides/contribute",
    "title": "contribute",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 2
  },
  "guides": {
    "src": {
      "path": "docs/can-guides/Guides.md"
    },
    "body": "\n## Experimenting\n\nSo now you’ve decided to give CanJS a try.\nThe best place to start is the [guides/chat].\nIt’s only an hour and shows off CanJS’s best features while you build\na real-time chat application.  You build the whole thing in a JS&nbsp;Bin.\n\nNext, you’ll want to try the [guides/todomvc].  This takes about 1.5 hours and touches on\nevery core part of CanJS.  You can also follow the whole guide in a JS&nbsp;Bin.\n\nAfter that, check out the [guides/atm].  It takes about 2 hours and shows how to build and __test__\nan ATM. It also shows how to composite state.  The whole guide is done in a JS&nbsp;Bin.\n\nYou might also want to to go through DoneJS’s [Place My Order Guide](https://donejs.com/place-my-order.html).  This is an in-depth\nlook at how CanJS works within the context of a wide variety of other tools.  This guide takes\nabout 8 hours.\n\nFinally, when you’re just about to commit, read [guides/setup] to learn how to set up\nCanJS for your particular environment.\n\n## Commitment\n\nOnce you’ve committed to CanJS, it’s important that you keep liking it and\nget better at using it.  \n\nCanJS’s community has lots of people who can offer advice and tips on\nhow to build an application the right way. Instead of struggling,\nplease ask for advice on [Gitter chat](https://gitter.im/canjs/canjs) or the [forums](http://forums.donejs.com/c/canjs).  Share a screenshot of what you’re building\nand we’ll tell you what needs to be done.\n\nTo stay up on CanJS’s latest news, we suggest:\n\n - Following [@CanJS](https://twitter.com/canjs) on twitter.\n - Subscribing to Bitovi’s [development blog](https://www.bitovi.com/blog/topic/development).\n\nTo get hands-on instruction, sign up for a DoneJS meetup in your area:\n\n- [Boston](http://www.meetup.com/DoneJS-Boston/)\n- [Chicago](http://www.meetup.com/DoneJS-Chicago/)\n- [Ft. Lauderdale](http://www.meetup.com/DoneJS-Fort-Lauderdale/)\n- [Los Angeles](http://www.meetup.com/DoneJS-LA/)\n- [New York](http://www.meetup.com/DoneJS-NYC/)\n- [Phoenix](http://www.meetup.com/DoneJS-Phoenix/)\n- [Raleigh-Durham](http://www.meetup.com/DoneJS-raleigh-durham/)\n- [San Francisco](http://www.meetup.com/DoneJS-San-Francisco/)\n- [Seattle](http://www.meetup.com/DoneJS-Seattle/)\n- [Silicon Valley](http://www.meetup.com/DoneJS-Silicon-Valley/)\n\nIf you’ve already committed to CanJS and are looking to move to 3.0, read [migrate-3].\n\n## Contributing\n\nOnce you’ve settled down with CanJS, it’s time to think about adding extensions and improvements to the framework of your own. There are many ways to contribute to\nCanJS, including:\n\n - [guides/contributing/bug-report Report a bug]\n - [guides/contributing/feature-suggestion Suggest a feature]\n - [guides/contributing/code Code changes]\n - [guides/contributing/documentation Documentation improvements]\n - [Create a plugin](https://donejs.com/plugin.html)\n - [guides/contributing/evangelism Evangelism - Blog, meetup and conference talks]\n - [guides/contributing/releases Releases - Maintaining CanJS]\n\nCanJS is managed by the [DoneJS Contributors Team](https://donejs.com/About.html#section=section_Team).\nAll contributions from all types of contributors are welcome. Contributing\nto an Open Source project can be an intimidating experience.  We’re\ncommitted to making the experience as pleasant and rewarding as possible.  We’re happy to set up a\npairing session to show you how to fix a bug or write a feature.  \n\nIf you have any questions, you can always reach us on [Gitter chat](https://gitter.im/canjs/canjs).\n\nIf you want to become a CanJS contributor, you simply have to:\n\n - [Email](mailto:contact@bitovi.com) the core team expressing your interest.\n - Attend the weekly DoneJS Contributors meeting twice a month. [DoneJS Calendar](https://www.google.com/calendar/embed?src=jupiterjs.com_g27vck36nifbnqrgkctkoanqb4%40group.calendar.google.com&ctz=America/Chicago).\n - Make one small contribution, even a spelling correction, a month.\n\nIssues that should be easy for a new contributor to pick up have an “easy” label. [This GitHub search](https://github.com/search?utf8=%E2%9C%93&q=user%3Acanjs+is%3Aopen+is%3Aissue+label%3AEasy&type=Issues) makes it easy to find easy issues across all the CanJS repositories.\n\n",
    "description": "Welcome to CanJS! These guides are here to help you develop and improve your relationship with CanJS. After all, picking a JavaScript framework is a commitment.  We want CanJS to be the framework you marry.  This page helps you know how to advance through the different stages of this relationship: \n",
    "name": "guides",
    "title": "Guides",
    "type": "page",
    "parent": "canjs",
    "order": 1,
    "comment": " "
  },
  "can-component.prototype.ViewModel": {
    "src": {
      "path": "node_modules/can-component/docs/ViewModel.md"
    },
    "body": "\n## Use\n\n[can-component]’s ViewModel property is used to create an __object__, typically an instance\nof a [can-define/map/map], that will be used to render the component’s\ntemplate. This is most easily understood with an example.  The following\ncomponent shows the current page number based off a `limit` and `offset` value:\n\n```js\nvar MyPaginateViewModel = DefineMap.extend({\n  offset: {value: 0},\n  limit: {value: 20},\n\tget page() {\n\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t}\n});\n\nComponent.extend({\n  tag: \"my-paginate\",\n  ViewModel: MyPaginateViewModel,\n  view: stache(\"Page {{page}}.\")\n})\n```\n\nIf this component HTML was inserted into the page like:\n```js\nvar template = stache(\"<my-paginate/>\");\nvar frag = template();\ndocument.body.appendChild(frag);\n```\nIt would result in:\n\n    <my-paginate>Page 1</my-paginate>\n\nThis is because the provided ViewModel object is used to create an instance of [can-define/map/map] like:\n```js\nvar viewModel = new MyPaginateViewModel();\n```\n\nThe [can-define.types.value] property definition makes offset default to 0 and limit default to 20.\n\nNext, the values are passed into `viewModel` from the [can-stache-bindings data bindings] within `<my-paginate>`\n(in this case there is none).\n\nAnd finally, that data is used to render the component’s template and inserted into the element using [can-view-scope] and [can-stache]:\n```js\nvar newViewModel = new Scope(viewModel),\n\tresult = stache(\"Page {{page}}.\")(newViewModel);\nelement.innerHTML = result;\n```\n\nThere is a short-hand for the prototype methods and properties used to extend the\n[can-types.DefaultMap default Map type] (typically [can-define/map/map])\nby setting the Component’s ViewModel to an object and using\nthat anonymous type as the view model.\n\nThe following does the same as above:\n```js\nComponent.extend({\n\ttag: \"my-paginate\",\n\tViewModel: {\n\t\toffset: {value: 0},\n\t\tlimit: {value: 20},\n\t\tget page() {\n\t\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t\t}\n\t},\n\tview: stache(\"Page {{page}}.\")\n})\n```\n\n## Values passed from attributes\n\nValues can be \"passed\" into the viewModel instance of a component, similar to passing arguments into a function. Using\n[can-stache-bindings], the following binding types can be setup:\n\n- [can-stache-bindings.toChild] — Update the component’s viewModel instance when the parent scope value changes.\n- [can-stache-bindings.toParent] — Update the parent scope when the component’s viewModel instance changes.\n- [can-stache-bindings.twoWay] — Update the parent scope or the component’s viewModel instance when the other changes.\n\nUsing [can-stache], values are passed into components like this:\n\n    <my-paginate {offset}='index' {limit}='size' />\n\nThe above creates an offset and limit property on the component that are initialized to whatever index and size are.\n\nThe following component requires an `offset` and `limit`:\n```js\nComponent.extend({\n\ttag: \"my-paginate\",\n\tViewModel: {\n\t\toffset: {value: 0},\n\t\tlimit: {value: 20},\n\t\tget page() {\n\t\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t\t}\n\t},\n\tview: stache(\"Page {{page}}.\")\n});\n```\nIf `<my-paginate>` is used like:\n```js\nvar template = stache(\"<my-paginate {offset}='index' {limit}='size' />\");\n\nvar pageInfo = new DefineMap({index: 0, size: 20});\n\ndocument.body.appendChild(template(pageInfo));\n```\n... `pageInfo`’s index and size are set as the component’s offset and\nlimit attributes. If we were to change the value of `pageInfo`’s\nindex like:\n```js\npageInfo.index = 20;\n```\n... the component’s offset value will change and its template will update to:\n\n    <my-paginate>Page 2</my-paginate>\n\n### Using attribute values\n\nYou can also pass a literal string value of the attribute. To do this in [can-stache],\nsimply pass any value not wrapped in single brackets, and the viewModel instance property will\nbe initialized to this string value:\n\n    <my-tag title=\"hello\" />\n\nThe above will set the title property on the component’s viewModel instance to the string `hello`.\n\nIf the tag’s `title` attribute is changed, it updates the viewModel instance property\nautomatically.  This can be seen in the following example:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/accordion.html'></div>\n\nClicking the __Change title__ button sets a `<panel>` element’s `title` attribute like:\n\n```js\nout.addEventListener(\"click\", function(ev){\n\tvar el = ev.target;\n\tvar parent = el.parentNode;\n\tif(el.nodeName === \"BUTTON\") {\n\t\tparent.setAttribute(\"title\", \"Users\");\n\t\tparent.removeChild(el);\n\t}\n});\n```\n\n## Calling methods on ViewModel from events within the template\n\nUsing html attributes like `can-EVENT-METHOD`, you can directly call a ViewModel method\nfrom a template. For example, we can make `<my-paginate>` elements include a next\nbutton that calls the ViewModel’s `next` method like:\n\n```js\nvar ViewModel = DefineMap.extend({\n\toffset: {value: 0},\n\tlimit: {value: 20},\n\tnext: function(){\n\t\tthis.offset = this.offset + this.limit;\n\t},\n\tget page() {\n\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t}\n});\n\nComponent.extend({\n\ttag: \"my-paginate\",\n\tViewModel: ViewModel,\n\tview: stache(\"Page {{page}} <button ($click)='next()'>Next</button>\")\n});\n```\n\nViewModel methods get called back with the current context, the element that you are listening to and the event that triggered the callback.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next.html'></div>\n\n## Publishing events on ViewModels\n\nDefineMaps can publish events on themselves. For instance, the following `<player-edit>` component,\ndispatches a `\"close\"` event when its close method is called:\n\n```js\nComponent.extend({\n\ttag: \"player-edit\",\n\tview: stache.from('player-edit-stache'),\n\tViewModel: DefineMap.extend({\n\t\tplayer: Player,\n\t\tclose: function(){\n\t\t\tthis.dispatch(\"close\");\n\t\t}\n\t}),\n\tleakScope: true\n});\n```\n\nThese can be listened to with [can-stache-bindings.event] bindings like:\n\n```js\n<player-edit\n  \t(close)=\"removeEdit()\"\n  \t{player}=\"editingPlayer\" />\n```\n\nThe following demo uses this ability to create a close button that\nhides the player editor:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next_event.html'></div>\n\n",
    "description": " \nProvides or describes a constructor function that provides values and methods\nto the component’s [can-component::view template]. The constructor function\nis initialized with values specified by the component element’s [can-stache-bindings data bindings].\n\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A new instance of the corresponding constructor function. This instance is\nadded to the top of the [can-view-scope] the component’s [can-component::view] is rendered with.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "properties",
            "description": "The initial properties that are passed by the [can-stache-bindings data bindings].\n\nThe view bindings on a tag control the properties and values used to instantiate the `ViewModel`. For example, calling `<my-tag>` as follows invokes `MyTagViewModel` as shown in the following example:\n\n```\n<my-tag/> <!-- new MyTagViewModel({}) -->\n\n<my-tag\n\t{message}=\"'Hi There'\"/> <!-- new MyTagViewModel({message: \"Hi There\"}) -->\n```\n"
          }
        ],
        "description": "A constructor function usually defined by [can-define/map/map.extend DefineMap.extend] or\n[can-map Map.extend] that will be used to create a new observable instance accessible by\nthe component’s [can-component::view].\n\nFor example, every time `<my-tag>` is found, a new instance of `MyTagViewModel` will\nbe created:\n\n```js\nvar MyTagViewModel = DefineMap.extend(\"MyTagViewModel\",{\n\tmessage: \"string\"\n});\n\nComponent.extend({\n\ttag: \"my-tag\",\n\tViewModel: MyTagViewModel,\n\tview: stache(\"<h1>{{message}}</h1>\")\n})\n```\n\nUse [can-view-model] to read a component’s view model instance.\n"
      }
    ],
    "title": "ViewModel",
    "name": "can-component.prototype.ViewModel",
    "type": "property",
    "parent": "can-component.prototype",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "properties",
      "description": "The initial properties that are passed by the [can-stache-bindings data bindings].\n\nThe view bindings on a tag control the properties and values used to instantiate the `ViewModel`. For example, calling `<my-tag>` as follows invokes `MyTagViewModel` as shown in the following example:\n\n```\n<my-tag/> <!-- new MyTagViewModel({}) -->\n\n<my-tag\n\t{message}=\"'Hi There'\"/> <!-- new MyTagViewModel({message: \"Hi There\"}) -->\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A new instance of the corresponding constructor function. This instance is\nadded to the top of the [can-view-scope] the component’s [can-component::view] is rendered with.\n"
    },
    "comment": " "
  },
  "can-component/beforeremove": {
    "src": {
      "path": "node_modules/can-component/docs/beforeremove.md"
    },
    "body": "\n",
    "description": "\nAn event called only on component’s elements before they are removed from the\ndocument if live binding is performing the removal. It can be listened to\nwithin a component’s [can-component.prototype.events] object or on a component\nelement with [can-stache-bindings.event] bindings.  This is an additional\nspecial event only on component elements.  [can-util/dom/events/inserted/inserted]\nand [can-util/dom/events/removed/removed] events are available on all elements.\n",
    "type": "typedef",
    "title": "beforeremove",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-component/beforeremove",
    "parent": "can-component.events",
    "signatures": [
      {
        "code": "\"{element} beforeremove\": function(element, event)",
        "description": "\n\nListens to when the component element is removed.  \nThis is commonly used for cleaning up and tearing down a component.\n\nFor example, the following might remove the component’s ViewModel\nfrom a parent component’s ViewModel:\n\n```js\nevents: {\n\t\"{element} beforeremove\": function(){\n\t\tcanViewModel(this.element.parentNode)\n\t\t\t.removePanel(this.viewModel);\n\t}\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "The component element."
          },
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "The `beforeremove` event object.\n"
          }
        ]
      },
      {
        "code": "($beforeremove)=\"CALL_EXRESSION\"",
        "description": "\n\nUses [can-stache-bindings.event] bindings to listen for a component’s\n`beforeremove` event.\n\n```\n<my-panel ($beforeremove)=\"removePanel(%viewModel)\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXRESSION",
            "description": "A call expression that calls some method when the event happens.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "CALL_EXRESSION",
      "description": "A call expression that calls some method when the event happens.\n"
    }
  },
  "can-component.static": {
    "name": "can-component.static",
    "title": "static",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 0
  },
  "can-component.prototype": {
    "name": "can-component.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 1
  },
  "can-component.elements": {
    "name": "can-component.elements",
    "title": "elements",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 2
  },
  "can-component.events": {
    "name": "can-component.events",
    "title": "special events",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 3
  },
  "can-component/content": {
    "src": {
      "path": "node_modules/can-component/docs/content.md"
    },
    "body": "\n",
    "description": "\nPositions the `LIGHT_DOM` within a component’s [can-component.prototype.view].\n",
    "type": "typedef",
    "title": "<content>",
    "types": [
      {
        "type": "can-stache.sectionRenderer"
      }
    ],
    "name": "can-component/content",
    "parent": "can-component.elements",
    "signatures": [
      {
        "code": "<content>DEFAULT_CONTENT</content>",
        "description": "\n\nWhen a user creates a new component in a template, the content between the tags is the\n`LIGHT_DOM`.  For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `<content>` tag can be used within `my-tag` to position the `LIGHT_DOM`.  For\nexample, to position the `LIGHT_DOM` within an `<h1>`, `<my-tag>` could be defined like:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content/></h1>\")\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "DEFAULT_CONTENT",
            "description": "The content that should be\nused if there is no `LIGHT_DOM` passed to the component.\n\nThe following, makes `my-tag` show `Hi There!` if no `LIGHT_DOM` is passed:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content>Hi There!</content></h1>\")\n});\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "DEFAULT_CONTENT",
      "description": "The content that should be\nused if there is no `LIGHT_DOM` passed to the component.\n\nThe following, makes `my-tag` show `Hi There!` if no `LIGHT_DOM` is passed:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content>Hi There!</content></h1>\")\n});\n```\n"
    }
  },
  "can-component.prototype.events": {
    "src": {
      "path": "node_modules/can-component/docs/events.md"
    },
    "body": "\n\n## Use\n\n[can-component]’s events object allows you to provide low-level [can-control]-like abilities to a `Component`\nwhile still accessing the `Component`’s [can-component::ViewModel].  The following\nexample listens to clicks on elements with `className=\"next\"` and calls `.next()` on the component’s viewModel.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_events_next.html'></div>\n\nThe events object can also listen to objects or properties on the component’s [can-component::ViewModel] instance. For instance, instead\nof using live-binding, we could listen to when offset changes and update the page manually:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_events_next_update_page.html'></div>\n\nComponents have the ability to bind to special inserted and removed events that are called when a component’s tag has been inserted into or removed from the page:\n\n      events: {\n        \"inserted\": function(){\n          // called when the component’s tag is inserted into the DOM\n        },\n        \"removed\": function(){\n          // called when the component’s tag is removed from the DOM\n        }\n      }\n\n## High performance template rendering\n\nWhile [can-stache-bindings] conveniently allows you to call a [can-component::ViewModel] method from a template like:\n\n    <input ($change)=\"doSomething()\"/>\n\nThis has the effect of binding an event handler directly to this element. Every element that has a `($click)` or similar attribute has an event handler bound to it. For a large grid or list, this could have a performance penalty.\n\nBy contrast, events bound using [can-component]’s events object use event delegation, which is useful for high performance template rendering. In a large grid or list, event delegation only binds a single event handler rather than one per row.\n\n",
    "description": "\nListen to events on elements and observables.\n",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "An object of event names and methods\nthat handle the event. For example:\n\n    Component.extend({\n\t  ViewModel: {\n\t\tlimit: \"number\",\n\t\toffset: \"number\",\n\t    next: function(){\n\t      this.offset = this.offset + this.limit;\n\t    }\n\t  },\n      events: {\n        \".next click\": function(){\n          this.viewModel.next()\n        },\n\t\t\"{viewModel} limit\": function(viewModel, ev, newValue){\n\t\t  console.log(\"limit is now\", newValue);\n\t\t}\n      }\n    })\n\n\nA component’s events object is used as the prototype of a [can-control]. The control gets created on the component’s\nelement.\n\nThe component’s [can-component.prototype.ViewModel] instance is available within event handlers as `this.viewModel`.\n\nThe component element is available as `this.element`.\n\n",
        "template": [
          {
            "types": [
              {
                "type": "can-control.eventDescription"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-control.eventHandler"
              }
            ]
          }
        ]
      }
    ],
    "title": "events",
    "name": "can-component.prototype.events",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.extend": {
    "src": {
      "path": "node_modules/can-component/docs/extend.md"
    },
    "body": "\n\n\n## Use\n\nNote that inheriting from components works differently than other CanJS APIs. You can’t call `.extend` on a particular component to create a “subclass” of that component.\n\nInstead, components work more like HTML elements. To reuse functionality from a base component, build on top of it with parent components that wrap other components in their template and pass any needed viewModel properties via attributes.\n\n",
    "description": "\nDefine the behavior of a custom element.\n",
    "title": "extend",
    "name": "can-component.extend",
    "type": "function",
    "parent": "can-component.static",
    "signatures": [
      {
        "code": "Component.extend(prototype)",
        "description": "\n\nExtends the [can-component] [can-construct constructor function] with prototype\nproperties and methods.  Registers the component by its [can-component::tag] with\n[can-view-callbacks.tag can-view-callbacks.tag].\n\n```js\nvar Component = require(\"can-component\");\nvar stache = require(\"can-stache\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar VM = DefineMap.extend({ ... });\n\nComponent.extend({\n  tag: \"tag-name\",\n  ViewModel: VM,\n  view: stache(\" .... \")\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "prototype",
            "description": "An object set as the prototype of the\nconstructor function. You will typically provide the following values\non the prototype object:\n\n  - __tag__ {[can-component.prototype.tag]} - Defines the\n  tag on which instances of the component constructor function will be\n  created.\n\n  - __ViewModel__ {[can-component.prototype.ViewModel]} - Specifies an object\n  that is is used to render the component’s template.\n\n  - __view__ {[can-component.prototype.view]} - Specifies the template\n  rendered within the custom element.\n\nAnd sometimes the following values are provided:\n\n  - __events__ {[can-component.prototype.events]} - Defines events on\n  dom elements or observable objects the component listens to.\n\n  - __helpers__ {[can-component.prototype.helpers]} - Specifies mustache helpers\n  used to render the component’s template.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "prototype",
      "description": "An object set as the prototype of the\nconstructor function. You will typically provide the following values\non the prototype object:\n\n  - __tag__ {[can-component.prototype.tag]} - Defines the\n  tag on which instances of the component constructor function will be\n  created.\n\n  - __ViewModel__ {[can-component.prototype.ViewModel]} - Specifies an object\n  that is is used to render the component’s template.\n\n  - __view__ {[can-component.prototype.view]} - Specifies the template\n  rendered within the custom element.\n\nAnd sometimes the following values are provided:\n\n  - __events__ {[can-component.prototype.events]} - Defines events on\n  dom elements or observable objects the component listens to.\n\n  - __helpers__ {[can-component.prototype.helpers]} - Specifies mustache helpers\n  used to render the component’s template.\n\n\n"
    },
    "comment": " "
  },
  "can-component.prototype.helpers": {
    "src": {
      "path": "node_modules/can-component/docs/helpers.md"
    },
    "body": "\n\n## Use\n\n[can-component]’s helper object lets you provide helper functions that are localized to\nthe component’s [can-component::view template].  The following example\nuses an `isSelected` helper to render content for selected items. Click\none of the following libraries to toggle them within the `selected` array.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/selected.html'></div>\n\n",
    "description": "\nHelper functions used with the component’s template.\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-stache.helper"
              }
            ]
          }
        ],
        "description": "\n\nAn object of [can-stache] helper names and methods. The helpers are only\navailable within the component’s template and source html. Helpers\nare always called back with `this` as the [can-component::ViewModel] instance.\n"
      }
    ],
    "title": "helpers",
    "name": "can-component.prototype.helpers",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.leakScope": {
    "src": {
      "path": "node_modules/can-component/docs/leakscope.md"
    },
    "body": "\n## Use\n\nA component’s [can-component::leakScope leakScope] option controls if a\ncomponent’s template can access the component’s outer scope and the\nuser content can read the component’s view model.\n\nLet’s define what __outer scope__, __component’s template__ and __user content__ mean.\n\nIf I have a `<hello-world>` component in a template like:\n\n```\n{{#data}}\n\t<hello-world>{{subject}}</hello-world>\n{{/data}}\n```\n\nThe __outer scope__ of `<hello-world>` has `data` as its context.  The __user content__ of\n`<hello-world>` is the template between its tags.  In this case, the __user content__\nis `{{subject}}`.\n\nFinally, if `<hello-world>` is defined like:\n\n```\nComponent.extend({\n  tag: \"hello-world\",\n  view: stache(\"{{greeting}} <content/>{{exclamation}}\")\n})\n```\n\n`{{greeting}} <content/>{{exclamation}}` represents the __component’s template__.\n\n## Using outer scope in component template\n\nIf `leakScope` is `true`, the __component’s template__ can read the data in the outer scope and will\nsee `name: \"John\"` overwriting `name: \"World\"` in the component’s viewModel instance in the following example.\n\nIf the following component is defined:\n```js\nComponent.extend({\n\ttag: 'hello-world',\n\tleakScope: true, // changed to true instead of the default value\n\tViewModel: {name: \"World\"},\n\tview: stache(\"Hello {{name}}\")\n});\n```\nWith this data in the outer scope:\n```js\n{ name: \"John\" }\n```\nAnd used like so:\n\n    <hello-world />\n\nIf `leakScope` is `true` it will render:\n\n    <hello-world>Hello John</hello-world>\n\nIf `leakScope` is `false` it will render:\n\n    <hello-world>Hello World</hello-world>\n\n## Using viewModel in user content\n\nif `leakScope` is `true`, the __user content__ is able to see the name property on the component’s\nviewModel instance in the following example. Else, name won't be seen.\n\nIf the following component is defined:\n```js\nComponent.extend({\n\ttag: 'hello-world',\n\tleakScope: true, // changed to true instead of the default value\n\tViewModel: {name: \"World\"},\n\tview: stache(\"Hello <content />\")\n});\n```\nAnd used like so:\n\n    <hello-world>{{name}}</hello-world>\n\nIf `leakScope` is `true` it will render:\n\n    <hello-world>Hello World</hello-world>\n\nIf `leakScope` is `false` it will render:\n\n    <hello-world>Hello </hello-world>\n\n",
    "description": "Allow reading the outer scope values from a component’s template and a component’s viewModel values in the user content.\n\n",
    "types": [
      {
        "type": "Boolean",
        "description": "`false` limits reading to:\n\n- the component’s viewModel from the component’s template, and\n- the outer scope values from the user content.\n\n`true` adds the ability to read:\n\n- the outer [can-view-scope scope] values from the component’s template, and\n- the component’s [can-component.prototype.ViewModel] values from the user content.\n\nThe default value is `false`.\n\nTo change leakScope from the default\n```js\nComponent.extend({\n\ttag: \"my-component\",\n\tleakScope: true,\n\tViewModel: { message: \"Hello World!\" },\n\tview: stache(\"{{message}}\")\n})\n```\n\nLeaving `leakScope` as the default `false` is useful for hiding and protecting\ninternal details of `Component`, potentially preventing accidental\nclashes. It can be helpful to set it to `true` if you, for example, wanted to customize __user content__\nbased on some value in the component’s ViewModel.\n"
      }
    ],
    "title": "leakScope",
    "name": "can-component.prototype.leakScope",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.tag": {
    "src": {
      "path": "node_modules/can-component/docs/tag.md"
    },
    "body": "\n",
    "description": "\nSpecifies the HTML tag (or node-name) the [can-component] will be created on.\n",
    "types": [
      {
        "type": "String",
        "description": "The tag name the [can-component]\nwill be created on.  Tag names are typically lower cased and\nhyphenated like: `foo-bar`.  Components register their\ntag with [can-view-callbacks.tag tag].\n\n\n"
      }
    ],
    "title": "tag",
    "name": "can-component.prototype.tag",
    "type": "property",
    "parent": "can-component.prototype"
  },
  "can-component.prototype.view": {
    "src": {
      "path": "node_modules/can-component/docs/view.md"
    },
    "body": "\n\n\n## Use\n\nThe template specified by the `view` property works similar to\nthe [http://www.w3.org/TR/shadow-dom/ W3C Shadow DOM proposal]. It represents the contents\nof a custom element, while being able to reposition the user provided __source__ elements\nwith the [can-component/content] tag.\n\nThere are three things to understand about a [can-component]’s template:\n\n - It is inserted into the component’s tag.\n - It is rendered with access to the component instance’s viewModel.\n - Any [can-component/content `<content>`] tags within the template act as insertion points for the source elements.\n\nThe following example demonstrates all three features:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/my_greeting_full.html'></div>\n\nThe following explains how each part works:\n\n__Component:__\n\n```js\nComponent({\n\ttag: \"my-greeting\",\n\tview: stache(\"<h1><content/> - {{title}}</h1>\"),\n\tViewModel: DefineMap.extend({\n\t\ttitle: {\n\t\t\tvalue: \"can-component\"\n\t\t}\n\t})\n});\n```\n\nThis registers a component for elements like `<my-greeting>`. Its template\nwill place an `<h1>` element directly within `<my-greeting>` and put\nthe original contents of `<my-greeting>` within the beginning of `<h1>`. The component’s\n[can-component::ViewModel] adds a title value.\n\n__Source template:__\n\n```html\n<header>\n  <my-greeting>\n     {{site}}\n  </my-greeting>\n</header>\n```\n\nThe source template is the template that\nuses `<my-greeting>`.  In the demo, this is defined within a `<script>`\ntag.\n\nNotice:\n\n - There is content within `<my-greeting>`.  This is called the __light__ or __user__ content.\n - The content looks for a `site` value.\n\n__Source data:__\n\n\t\tstache(\"...\")({\n\t\t\tsite: \"CanJS\"\n\t\t})\n\nThis is how we render the source template that uses `<my-greeting>`. The template is rendered with `site` in its [can-component::ViewModel].\n\n__HTML Result:__\n\n    <header>\n      <my-greeting>\n        <h1>CanJS - can-component</h1>\n      </my-greeting>\n    </header>\n\nThis is the result of the template transformations. The\n__user__ content within the original `<my-greeting>` is placed within the start of the `<h1>`\ntag.  Also, notice that the __user__ content is able to access data from\nthe source data.\n\nThe following sections break this down more.\n\n\n## Template insertion\n\nThe template specified by `view` is rendered directly within the custom tag.\n\nFor example the following component:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1>Hello There</h1>\")\n    });\n\nWith the following source html:\n\n    <header>\n      <my-greeting></my-greeting>\n    </header>\n\nProduces the following html:\n\n    <header>\n      <my-greeting><h1>Hello There</h1></my-greeting>\n    </header>\n\nHowever, if there was existing content within the source html, like:\n\n    <header>\n      <my-greeting>DO REMOVE ME!!!</my-greeting>\n    </header>\n\nthat content is removed, and replaced by the component’s template:\n\n    <header>\n      <my-greeting><h1>Hello There</h1></my-greeting>\n    </header>\n\n### The `<content>` element\n\nUse the `<content>` element to place the source content in the\ncomponent’s element within the component’s\ntemplate. For example, if we change the component to look like:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1><content/></h1>\")\n    });\n\nand rendered with source html, like:\n\n    <my-greeting>Hello World</my-greeting>\n\nit produces:\n\n    <my-greeting><h1>Hello World</h1></my-greeting>\n\n### `<content>` element default content\n\nIf the user does not provide source content, the html\nbetween the `<content>` tags will be used. For example, if we\nchange the component to look like:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1><content>Hello World</content></h1>\")\n    });\n\nand rendered with source html like:\n\n    <my-greeting></my-greeting>\n\nit produces:\n\n    <my-greeting><h1>Hello World</h1></my-greeting>\n\n",
    "description": "\nProvides a template to render directly within the component’s element. The template is rendered with the\ncomponent’s [can-component::ViewModel] instance.  `<content/>` elements within the template are replaced by the source elements within the component’s tag.\n",
    "types": [
      {
        "type": "can-stache.renderer",
        "description": "A [can-stache.renderer] returned by [can-stache]. For example:\n\n    Component({\n      tag: \"my-tabs\",\n      view: stache(\"<ul>{{#panels}}<li>{{title}}</li> ...\")\n    });\n\n"
      }
    ],
    "title": "view",
    "name": "can-component.prototype.view",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.view-model": {
    "src": {
      "path": "node_modules/can-component/docs/view-model.md"
    },
    "body": "\n",
    "description": "\nReturn the view model instance or type with which the component’s [can-component.prototype.view]\nis rendered.  This is used when more fine grained control is needed over [can-component::ViewModel].\n",
    "title": "viewModel",
    "name": "can-component.prototype.view-model",
    "type": "function",
    "parent": "can-component.prototype",
    "signatures": [
      {
        "code": "function(properties, parentScope, element)",
        "description": "\n\nThe `viewModel` function takes the `properties` and values that are used to\ntypically initialize a [can-component.prototype.ViewModel], the\n[can-view-scope] the component is rendered within, and the component’s element\nand returns either the view-model instance or ViewModel type that the component’s [can-component.prototype.view]\nis rendered with.\n\nThis is typically used only for special situations where a custom scope or custom bindings\nneed to be setup.\n\n```\nvar Component = require(\"can-component\");\nvar Scope = require(\"can-view-scope\");\n\nComponent.extend({\n\ttag: \"my-element\",\n\tviewModel: function(properties, scope, element){\n\t\tvar vm =  new DefineMap(properties);\n\t\t// do special stuff ...\n\t\treturn vm;\n\t}\n});\n\nstache(\"<my-element {first}='firstName' last='Meyer'/>\")({\n  firstName: \"Justin\",\n  middleName: \"Barry\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "properties",
            "description": "An object of values specified by the custom element’s attributes. For example, a template rendered like:\n\n    stache(\"<my-element title='name'></my-element>\")({\n      name: \"Justin\"\n    })\n\nCreates an instance of following control:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties){\n    \t  properties.title //-> \"Justin\";\n    \t}\n    })\n\nAnd calls the viewModel function with `properties` like `{title: \"Justin\"}`.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope"
              }
            ],
            "name": "parentScope",
            "description": "\n\nThe viewModel the custom tag was found within.  By default, any attribute’s values will\nbe looked up within the current viewModel, but if you want to add values without needing\nthe user to provide an attribute, you can set this up here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope){\n    \t  parentScope.get('middleName') //-> \"Barry\"\n    \t}\n    });\n\nNotice how the `middleName` value is looked up in `my-element`’s parent scope.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope, el){\n\t\t  var vm = new DefineMap({clicks: 0});\n    \t  domEvent.addEventListener.call(el, \"click\", function(){\n\t\t    vm.clicks++;\n\t\t  });\n\t\t  return vm;\n    \t}\n    });\n\nThis example should be done with the [can-component::events] object instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns one of the following.\n\n   - An observable map or list type.\n   - The prototype of an observable map or list type that will be used to render the component’s template.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "name": "element",
      "description": "The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope, el){\n\t\t  var vm = new DefineMap({clicks: 0});\n    \t  domEvent.addEventListener.call(el, \"click\", function(){\n\t\t    vm.clicks++;\n\t\t  });\n\t\t  return vm;\n    \t}\n    });\n\nThis example should be done with the [can-component::events] object instead.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Map"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns one of the following.\n\n   - An observable map or list type.\n   - The prototype of an observable map or list type that will be used to render the component’s template.\n"
    }
  },
  "can-compute.computed.addEventListener": {
    "src": {
      "path": "node_modules/can-compute/docs/addEventListener.md"
    },
    "body": "\n",
    "description": "\nListen to when a compute changes value.\n",
    "title": "addEventListener",
    "name": "can-compute.computed.addEventListener",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.addEventListener(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nage.addEventListener('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-compute.async": {
    "src": {
      "path": "node_modules/can-compute/docs/async.md"
    },
    "body": "\n\n## Use\n\nThe following compute is a live list of todos for a given \nuserId. `todos` value would alternate between `null` and a Todo.List as `userId` changes.\n\n\n    var userId = compute(5)\n    \n    var todos = compute.async(null, function(oldTodoList, setValue){\n      Todo.findAll({ userId: userId() }, function(todos){\n        setValue(todos)\n      });\n      return null;\n    });\n\n\nThe following replaces the list in place:\n\n    var userId = compute(5)\n    \n    var todos = compute.async(new Todo.List(), function(todoList, setValue){\n      todoList.replace( Todo.findAll({ userId: userId() })\n      return todoList;\n    });\n\n",
    "description": "\nCreate a compute that can set its value after the computed function has been called.\n",
    "title": "async",
    "name": "can-compute.async",
    "type": "function",
    "parent": "can-compute",
    "release": "2.1",
    "hide": true,
    "signatures": [
      {
        "code": "compute.async(initialValue, computed(currentValue, setValue(newValue) )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "The",
            "description": "initial value of the compute.\n"
          },
          {
            "types": [
              {
                "type": "can-compute.asyncComputer"
              }
            ],
            "name": "computed",
            "description": "A function \nthat returns the current value of the compute and can optionally later call \nits `setValue` callback to update the value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "Returns a compute, but a compute that will \npossibly not have the correct value unless it is bound to.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute.asyncComputer"
        }
      ],
      "name": "computed",
      "description": "A function \nthat returns the current value of the compute and can optionally later call \nits `setValue` callback to update the value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "Returns a compute, but a compute that will \npossibly not have the correct value unless it is bound to.\n"
    },
    "comment": " "
  },
  "can-compute.asyncComputer": {
    "src": {
      "path": "node_modules/can-compute/docs/async_computer.md"
    },
    "body": "\n",
    "description": "\nA function that determines a value for an [can-compute.async async compute].\n",
    "type": "typedef",
    "title": "asyncComputer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "If a `setVal` argument is not provided, the return value\nis set as the current value of the compute.  If `setVal` is provided and\nundefined is returned, the current value remains until `setVal` is called.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The last set value of the compute.  This should be returned\nif you are doing an in-place compute. \n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "setVal",
            "description": "Called to update the value \nof the compute at a later time. \n"
          }
        ],
        "description": "The function callback to [can-compute.async] that determines\nthe value of the compute.\n"
      }
    ],
    "name": "can-compute.asyncComputer",
    "parent": "can-compute",
    "release": "2.1",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newVal"
            }
          ]
        }
      ],
      "optional": true,
      "name": "setVal",
      "description": "Called to update the value \nof the compute at a later time. \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "If a `setVal` argument is not provided, the return value\nis set as the current value of the compute.  If `setVal` is provided and\nundefined is returned, the current value remains until `setVal` is called.\n"
    }
  },
  "can-compute.computed.ChangeEvent": {
    "src": {
      "path": "node_modules/can-compute/docs/change.md"
    },
    "body": "\n",
    "description": "\nEvent fired when the value of the [can-compute.computed] changes.\n",
    "type": "typedef",
    "title": "change",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-compute.computed.ChangeEvent",
    "parent": "can-compute/computed/events",
    "signatures": [
      {
        "description": "handler(event, newValue, oldValue)\n\nHandlers registered on `\"change\"` events will be called back as follows:\n\n```js\nvar age = compute(33);\n\nage.on('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newVal",
            "description": "The new value of the compute."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "oldVal",
            "description": "The old value of the compute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "oldVal",
      "description": "The old value of the compute.\n"
    }
  },
  "can-compute.computeSettings": {
    "src": {
      "path": "node_modules/can-compute/docs/compute_settings.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "computeSettings",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "description": "A function that retrieves and returns the current value of the compute."
          },
          {
            "name": "set",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "description": "A function that is used when setting a new value of the compute.\n\nA function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can-computed] and the current value. If\n`set` returns a value, it is used to compare to the current value of the compute. Otherwise,\n`get` is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.\n\n`newVal` is the value being set, while `oldVal` is the previous value in the compute.\n"
          },
          {
            "name": "on",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ],
                    "name": "updated"
                  }
                ]
              }
            ],
            "description": "Called to setup binding to dependency events. Call `updated` when the compute's value needs to be updated.\n"
          },
          {
            "name": "off",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "Called to teardown binding.\n"
          }
        ]
      }
    ],
    "name": "can-compute.computeSettings",
    "release": "2.1",
    "parent": "can-compute"
  },
  "can-compute/computed/events": {
    "name": "can-compute/computed/events",
    "title": "events",
    "type": "group",
    "parent": "can-compute.computed",
    "description": "",
    "order": 0
  },
  "can-compute/computed/methods": {
    "name": "can-compute/computed/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-compute.computed",
    "description": "",
    "order": 0
  },
  "can-compute.computed": {
    "src": {
      "path": "node_modules/can-compute/docs/computed.md"
    },
    "body": "\n## Use\n\nA compute instance is created with [can-compute] and used as an observable value. Computes are useful to provide a value representative of multiple other observables:\n\n```js\nvar person = new Person({\n\tfirst: \"Matthew\",\n\tlast: \"Phillips\"\n});\n\nvar fullName = compute(function(){\n\treturn person.first + \" \" + person.last;\n});\n\nconsole.log(fullName()); // -> \"Matthew Phillips\".\n```\n\nCalling the compute with a value will cause it to run as a setter function:\n\n```js\nvar count = compute(0);\n\nconsole.log(count()); // -> 0\n\ncount(5);\n\nconsole.log(count()); // -> 5\n```\n\nThis depends on how the [can-compute getterSetter] is defined, and can adjust how it handles setters:\n\n```js\nvar plusOne = compute(function(val){\n\tif(val) {\n\t\treturn val + 1;\n\t} else {\n\t\treturn 1;\n\t}\n});\n\nconsole.log(plusOne()); // -> 1\n\nplusOne(5);\n\nconsole.log(plusOne()); // -> 6\n```\n\n",
    "description": "A derived value from other computes and observable maps. \n",
    "title": "compute",
    "name": "can-compute.computed",
    "type": "function",
    "parent": "can-compute",
    "signatures": [
      {
        "code": "compute([newVal])",
        "description": "\n\nGets the compute's value if no arguments are provided, otherwise calls the compute's setter with the value passed as the first argument.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "If the compute is called with an argument, the first argument is used\nto set the compute to a new value. This may trigger a\n`\"change\"` event that can be listened for with [can-computed.bind].\n\nIf the compute is called without any arguments (`compute()`), it simply returns\nthe current value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The current value of the compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "newVal",
      "description": "If the compute is called with an argument, the first argument is used\nto set the compute to a new value. This may trigger a\n`\"change\"` event that can be listened for with [can-computed.bind].\n\nIf the compute is called without any arguments (`compute()`), it simply returns\nthe current value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The current value of the compute.\n"
    },
    "comment": " "
  },
  "can-compute.computed.off": {
    "src": {
      "path": "node_modules/can-compute/docs/off.md"
    },
    "body": "\n",
    "description": "\nRemove an event listener.\n",
    "title": "off",
    "name": "can-compute.computed.off",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.off(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nvar handler = function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n}\n\nage.on('change', handler);\n\nage(34);\n\nage.off('change', handler)\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be removed.  This has to be the same function that was passed to [can-compute.computed.on].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be removed.  This has to be the same function that was passed to [can-compute.computed.on].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-compute.computed.on": {
    "src": {
      "path": "node_modules/can-compute/docs/on.md"
    },
    "body": "\n",
    "description": "\nListen to when a compute changes value.\n",
    "title": "on",
    "name": "can-compute.computed.on",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.on(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nage.on('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-compute.computed.removeEventListener": {
    "src": {
      "path": "node_modules/can-compute/docs/removeEventListene.md"
    },
    "body": "\n",
    "description": "\nListen to when a compute changes value.\n",
    "title": "removeEventListener",
    "name": "can-compute.computed.removeEventListener",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.removeEventListener(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nage.removeEventListener('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-connect/base/base": {
    "type": "module",
    "name": "can-connect/base/base",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 1,
      "codeLine": 25,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\nThe `\"base\"` behavior is added automatically to every connection created by `connect`. So even we do:\n\n```\nvar connection = connect([],{});\n```\n\nThe connection still has `\"base\"` functionality:\n\n```\nconnection.id({id: 1}) //-> 1\n```\n\n",
    "description": "\nThe base behavior added to every `connect` behavior.\n",
    "title": "",
    "signatures": [
      {
        "code": "base(options)",
        "description": "\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/base/base.id": {
    "type": "function",
    "name": "can-connect/base/base.id",
    "parent": "can-connect/base/base",
    "src": {
      "line": 27,
      "codeLine": 82,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\nMany extensions, such as the [can-connect/constructor/store/store], need\nto have a unique identifier for an instance or instance data.  The\n`connection.id` method should return that.\n\nTypically, an item's `id` is a simply propertly value on the object.\nFor example, `todo` data might look like:\n\n```js\n{_id: 5, name: \"do the dishes\"}\n```\n\nIn this case, [can-connect/base/base.algebra]'s `id` comparator should be set to\n\"_id\" like:\n\n```js\nvar algebra = new set.Algebra({\n  set.comparators.id(\"_id\")\n});\nconnect([...],{algebra: algebra});\n```\n\nHowever,\nsome data sources have compound ids.  For example, \"Class Assignment\"\nconnection might be represented by two properties, the `studentId` and the\n`classId`.  For this kind of setup, you can provide your own id function as\nfollows:\n\n```js\nvar classAssignmentConnection = connect(['data-url'],{\n  url: \"/class_assignments\",\n  id: function(classAssignment){\n    return classAssignment.studentId+\"-\"+classAssignment.classId;\n  }\n});\n```\n\t \n",
    "description": "\nUniquely identify an instance or raw instance data.\n",
    "title": "id",
    "signatures": [
      {
        "code": "connection.id(instance)",
        "description": "\n\n  Returns the [can-connect/base/base.idProp] if it exists, otherwise the [can-connect/base/base.algebra]'s\n  id values, otherwise the `id` property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "The instance or raw `props` for an instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "Number"
            }
          ],
          "description": "A string or number uniquely representing `instance`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "The instance or raw `props` for an instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Number"
        }
      ],
      "description": "A string or number uniquely representing `instance`.\n"
    },
    "comment": " "
  },
  "can-connect/base/base.idProp": {
    "name": "can-connect/base/base.idProp",
    "type": "property",
    "parent": "can-connect/base/base",
    "src": {
      "line": 103,
      "codeLine": 128,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n## Use\n\n```\nconnect([\n  require(\"can-connect/data/url/url\")\n],{\n  idProp: \"_id\"\n});\n```\n\n\t \n",
    "description": "\n",
    "types": [
      {
        "type": "String",
        "description": "The name of the property that uniquely identifies\nan instance.  Defaults to `\"id\"`.\n"
      }
    ],
    "title": "idProp",
    "deprecated": [
      {
        "version": "0.5.3",
        "description": "Instead of specifying the idProp it should be\nset on the algebra passed to the connection.\n\nSpecifies the property that uniquely identifies an instance.\n"
      }
    ],
    "comment": " "
  },
  "can-connect/base/base.listSet": {
    "type": "function",
    "name": "can-connect/base/base.listSet",
    "parent": "can-connect/base/base",
    "src": {
      "line": 129,
      "codeLine": 164,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\nMany extensions, such as the [can-connect/constructor/store/store], need\nto have a unique identifier for a list.  The\n`connection.listSet` method should return that.\n\nTypically, an item's `set` is an expando property added to\na list.  For example, a list of todos might looks like todos\nafter the following has run:\n\n```\nvar todos = [{_id: 5, name: \"do the dishes\"}]\ntodos.set = {due: 'today'};\n```\n\nIn this case [can-connect/base/base.listSetProp] should be set to `\"set\"`.\n\n\t \n",
    "description": "\nUniquely identify the set a list represents.\n",
    "title": "listSet",
    "signatures": [
      {
        "code": "connection.listSet(list)",
        "description": "\n\n  Returns the [can-connect/base/base.listSetProp] if it exists.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "A list instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object that can be passed to `JSON.stringify`\nto represent the list.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "A list instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object that can be passed to `JSON.stringify`\nto represent the list.\n"
    },
    "comment": " "
  },
  "can-connect/base/base.listSetProp": {
    "name": "can-connect/base/base.listSetProp",
    "type": "property",
    "parent": "can-connect/base/base",
    "src": {
      "line": 167,
      "codeLine": 194,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\n```\nvar connection = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  listSetProp: \"set\"\n});\n\nvar list = [{id: 1, ...}, {id: 2, ...}]\nlist.set = {complete: true};\n\nconnection.listSet(list) //-> {complete: true}\n```\n\n\t \n",
    "description": "\nSpecifies the property that uniquely identifies a list.\n",
    "types": [
      {
        "type": "String",
        "description": "The name of the property that uniquely identifies\nthe list.  Defaults to `\"__listSet\"`.\n"
      }
    ],
    "title": "listSetProp",
    "comment": " "
  },
  "can-connect/base/base.algebra": {
    "body": "\n## Use\n\n```\nvar algebra = new set.Algebra(set.props.range(\"start\",\"end\"));\n\nconnect([...behavior names...],{\n  algebra: algebra\n});\n```\n\t \n",
    "description": "\n",
    "types": [
      {
        "type": "can-set.Algebra",
        "description": "A set algebra that is used by\nmany behaviors to compare the `set` objects passed to\n[can-connect/connection.getListData] and [can-connect/connection.getList]. By\ndefault no algebra is provided.\n"
      }
    ],
    "title": "algebra",
    "name": "can-connect/base/base.algebra",
    "type": "property",
    "parent": "can-connect/base/base",
    "comment": " "
  },
  "can-connect/base/base.cacheConnection": {
    "body": "\n\n## Use\n\n```\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{});\n\nconnect([...behavior names...],{\n  cacheConnection: cacheConnection\n});\n```\n\t \n",
    "description": "\nA connection used for caching.\n",
    "types": [
      {
        "type": "can-connect/DataInterface",
        "description": "A connection that can be used for\n[can-connect/DataInterface] requests. Several behaviors\nlook for this property.\n"
      }
    ],
    "title": "cacheConnection",
    "name": "can-connect/base/base.cacheConnection",
    "type": "property",
    "parent": "can-connect/base/base",
    "comment": " "
  },
  "can-connect/cache-requests/cache-requests.data": {
    "name": "can-connect/cache-requests/cache-requests.data",
    "title": "data interface",
    "type": "group",
    "parent": "can-connect/cache-requests/cache-requests",
    "description": "",
    "order": 0
  },
  "can-connect/cache-requests/cache-requests.algebra": {
    "name": "can-connect/cache-requests/cache-requests.algebra",
    "title": "algebra",
    "type": "group",
    "parent": "can-connect/cache-requests/cache-requests",
    "description": "",
    "order": 0
  },
  "can-connect/cache-requests/cache-requests": {
    "type": "module",
    "name": "can-connect/cache-requests/cache-requests",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 7,
      "codeLine": 98,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n\n## Use\n\nUse `cache-requests` in combination with a cache\nlike [can-connect/data/memory-cache/memory-cache] or [can-connect/data/localstorage-cache/localstorage-cache].  For example,\n\n```\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/cache-requests/cache-requests\")\n],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\"\n})\n```\n\nThis will make it so response data is cached in memory.  For example, if\ntoday's todos are loaded:\n\n```\ntodoConnection.getListData({due: \"today\"})\n```\n\nAnd later, a subset of those todos are loaded:\n\n```\ntodoConnection.getListData({due: \"today\", status: \"critical\"})\n```\n\nThe original request's data will be used.\n\n## Using Algebra\n\n`cache-requests` can also \"fill in\" the data the cache is mising if you provide\nit the necessary [set algebra](https://github.com/canjs/can-set).\n\nFor example, if you requested paginated data like:\n\n```\ntodoConnection.getListData({start: 1, end: 10})\n```\n\nAnd then later requested:\n\n```\ntodoConnection.getListData({start: 1, end: 20})\n```\n\n... with the appropriate configuration, `cache-requests` will only request `{start: 11, end: 20}`.\nThat configuration looks like:\n\n```\nvar algebra = new set.Algebra( set.comparators.range(\"start\",\"end\") );\n\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{algebra: algebra});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/cache-requests/cache-requests\")\n],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\",\n  algebra: algebra\n})\n```\n\nNotice that `cacheConnection`s often share many of the same options as the\nprimary connection.\n\n",
    "description": "\nCaches reponse data and uses it to prevent future requests or make future requests smaller.\n",
    "title": "",
    "signatures": [
      {
        "code": "cacheRequests( baseConnection )",
        "description": "\n\n  Overwrites [can-connect/cache-requests/cache-requests.getListData] to use set logic to\n  determine which data is already in [can-connect/base/base.cacheConnection] or needs to be loaded from the base connection.\n\n  It then gets data from the cache and/or the base connection, merges it, and returns it.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/cache-requests/cache-requests.getDiff": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getDiff",
    "parent": "can-connect/cache-requests/cache-requests.algebra",
    "src": {
      "line": 102,
      "codeLine": 143,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nCompares the available set data to the requested data and returns\nthe data that should be loaded from the cache and the data loaded\nfrom the base connection.\n",
    "title": "getDiff",
    "signatures": [
      {
        "code": "connection.getDiff( set, availableSets )",
        "description": "\n\n  This attempts to find the minimal amount of data to load by\n  going through each `availableSet` and doing a [subset](https://github.com/canjs/can-set#setsubset)\n  test and a [set difference](https://github.com/canjs/can-set#setdifference) with\n  `set`.\n\n  If `set` is a subset of an `availableSet`, `{cached: set}` will be returned.\n\n  If there is a difference of `set` and an `availableSet`, the difference\n  will be what's `needed`.  The intersection of `set` and that\n  `availableSet` will be what's `cached`.  A `count` will be taken of\n  what's `needed` resulting in an object like:\n\n  ```\n  {\n    needed: {start: 50, end: 99},\n    cached: {start: 0, end: 49},\n    count: 49\n  }\n  ```\n\n  Finally, `getDiff` will pick the diff objet with the lowest count. If there\n  is no diff object, `{needed: set}` is returned.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set that is being loaded."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Set"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "availableSets",
            "description": "An array of available sets in the\n[can-connect/base/base.cacheConnection]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": [
                        {
                          "name": "needs",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        },
                        {
                          "name": "cached",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Set"
                }
              ]
            }
          ]
        }
      ],
      "name": "availableSets",
      "description": "An array of available sets in the\n[can-connect/base/base.cacheConnection]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": [
                    {
                      "name": "needs",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    },
                    {
                      "name": "cached",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\n\n\t "
    }
  },
  "can-connect/cache-requests/cache-requests.getUnion": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getUnion",
    "parent": "can-connect/cache-requests/cache-requests.algebra",
    "src": {
      "line": 181,
      "codeLine": 198,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nReturns the union of the cached and needed data.\n",
    "title": "getUnion",
    "signatures": [
      {
        "code": "connection.getUnion(set, diff, neededData, cachedData)",
        "description": "\n\n  Uses [can-set.getUnion](https://github.com/canjs/can-set#setgetunion) to merge the two sets.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set requested."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "diff",
            "description": "The result of [can-connect/cache-requests/cache-requests.getDiff]."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "neededData",
            "description": "The data loaded from the base connection."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "cachedData",
            "description": "The data loaded from the [can-connect/base/base.cacheConnection].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "Return the merged cached and requested data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "name": "cachedData",
      "description": "The data loaded from the [can-connect/base/base.cacheConnection].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "Return the merged cached and requested data.\n\t "
    }
  },
  "can-connect/cache-requests/cache-requests.getListData": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getListData",
    "parent": "can-connect/cache-requests/cache-requests.data",
    "src": {
      "line": 202,
      "codeLine": 220,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nOnly request data that hasn't already been loaded by [can-connect/base/base.cacheConnection].\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Overwrites a base connection's `getListData` to use data in the [can-connect/base/base.cacheConnection]\n  whenever possible.  This works by [can-connect/connection.getSets getting the stored sets] and doing a\n  [can-connect/cache-requests/cache-requests.getDiff diff] to see what should be loaded from the cache\n  or from the base connection.\n\n  With that information, this `getListData` requests data from the cache and/or the base\n  connection.  Once it has been recieved, it combines the data with [can-connect/cache-requests/cache-requests.getUnion].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "\n\t "
    }
  },
  "can-connect/constructor/constructor.crud": {
    "name": "can-connect/constructor/constructor.crud",
    "title": "crud methods",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 0
  },
  "can-connect/constructor/constructor.callbacks": {
    "name": "can-connect/constructor/constructor.callbacks",
    "title": "crud callbacks",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 1
  },
  "can-connect/constructor/constructor.hydrators": {
    "name": "can-connect/constructor/constructor.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 2
  },
  "can-connect/constructor/constructor.serializers": {
    "name": "can-connect/constructor/constructor.serializers",
    "title": "serializers",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 3
  },
  "can-connect/constructor/constructor.helpers": {
    "name": "can-connect/constructor/constructor.helpers",
    "title": "helpers",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 4
  },
  "can-connect/constructor/constructor": {
    "name": "can-connect/constructor/constructor",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 2,
      "codeLine": 94,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nThe `can-connect/constructor/constructor` behavior allows you to hydrate the raw, serialized representation of\nyour application's data into a typed representation with additional methods and behaviors.\n\nFor example, you might want to be able to load data as a particular JavaScript Constructor\nfunction that has a helper methods that act upon the serialized data.\n\nAn example might be loading data from a `\"/todos\"` service and being able to call `.timeLeft()`\non the todos that you get back like:\n\n```\ntodoConnection.get({id: 6}).then(function(todo){\n  todo.timeLeft() //-> 60000\n})\n```\n\nThe following creates a `todoConnection` that does exactly that:\n\n```\nvar Todo = function(data){\n  for(var prop in data) {\n   this[prop] = data;\n  }\n};\nTodo.prototype.timeLeft = function(){\n  return new Date() - this.dueDate\n};\n\nvar todoConnection = connect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\"\n  instance: function(data){\n    return new Todo(data);\n  }\n});\n```\n\nThe `constructor` extension is still useful even if you want to keep your data as plain\nJavaScript objects (which its default behavior).  The `constructor` extension describes\nthe in-memory representation of your data on the client.  Other extensions need to know this\nrepresentation for advanced behavior like [can-connect/real-time/real-time] or [can-connect/fall-through-cache/fall-through-cache].\n\n## CRUD Methods\n\nThe `constructor` extension supplies methods that create, read, update and\ndelete (CRUD) typed representations of raw connection data.\n\n## CRUD Callbacks\n\nThe `constructor` function \"CRUD Methods\" call \"CRUD Callbacks\" with the\nthe \"data interface\" response data. These callbacks update the state of\nthe typed representation.\n\n## Instantiators\n\nThese methods are used to create a typed instance or typed list given raw \"data interface\"\nobjects.\n\n## Serializers\n\nThese methods convert the typed instance or typed list into a representation for the\n\"data interface\".\n\n\n\n",
    "description": "\nAdds the ability to operate on special types instead of plain JavaScript Objects\nand Arrays.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructor( baseConnection )",
        "description": "\n\nAdds methods that allow the connection to operate on special types.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "connection"
              }
            ],
            "name": "baseConnection",
            "description": "A connection with most of the\n[can-connect/DataInterface] implemented.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "connection"
            }
          ],
          "description": "A new connection with the additional methods.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "connection"
        }
      ],
      "name": "baseConnection",
      "description": "A connection with most of the\n[can-connect/DataInterface] implemented.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "connection"
        }
      ],
      "description": "A new connection with the additional methods.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.cidStore": {
    "name": "can-connect/constructor/constructor.cidStore",
    "type": "property",
    "parent": "can-connect/constructor/constructor.helpers",
    "src": {
      "line": 107,
      "codeLine": 118,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nA WeakReferenceMap that contains instances being created by their `._cid` property.\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "\n\n  The `cidStore` is used to temporarily hold references to instances by [can-util/js/cid/cid] that don't\n  yet have an id which are in the process of being created.\n\t "
      }
    ],
    "title": "cidStore"
  },
  "can-connect/constructor/constructor.get": {
    "type": "function",
    "name": "can-connect/constructor/constructor.get",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 121,
      "codeLine": 150,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nCall `.get()` with the parameters that identify the instance\nyou want to load.  `.get()` will return a promise that resolves\nto your instance.\n\n```\ntodoConnection.get({id: 6}).then(function(todo){ })\n```\n\n\t \n",
    "description": "\nGet a single instance from the \"data interface\".\n",
    "title": "get",
    "signatures": [
      {
        "code": "connection.get(set)",
        "description": "\n\n  Gets an instance from [can-connect/connection.getData] and runs the resulting data\n  through [can-connect/constructor/constructor.hydrateInstance].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An instance that represents the data that was loaded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "An instance that represents the data that was loaded.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.getList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.getList",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 157,
      "codeLine": 186,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nCall `.getList()` with the parameters that identify the instance\nyou want to load.  `.getList()` will return a promise that resolves\nto your instance.\n\n```\ntodoConnection.getList({due: 'today'}).then(function(todos){ })\n```\n\n\t \n",
    "description": "\nGet a single instance from the \"data interface\".\n",
    "title": "getList",
    "signatures": [
      {
        "code": "connection.getList(set)",
        "description": "\n\n  Gets an instance from [can-connect/connection.getListData] and runs the resulting data\n  through [can-connect/constructor.hydrateList].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "List",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Instance"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An instance that represents the data that was loaded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "List",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Instance"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "An instance that represents the data that was loaded.\n"
    },
    "comment": " "
  },
  "can-connect/constructor.hydrateList": {
    "type": "function",
    "name": "can-connect/constructor.hydrateList",
    "parent": "can-connect/constructor/constructor.hydrators",
    "src": {
      "line": 195,
      "codeLine": 212,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nMakes a list type object given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList(listData, set)",
        "description": "\n\n  Calls [can-connect/constructor/constructor.hydrateInstance] with each raw instance data item and then\n  calls [can-connect/constructor/constructor.list] with an array of the instances.  If [can-connect/constructor/constructor.list]\n  is not provided, a normal array is used.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "Raw list data."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set used to retrieve the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "The data type used to represent the list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set used to retrieve the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "The data type used to represent the list.\n\t "
    }
  },
  "can-connect/constructor/constructor.hydrateInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.hydrateInstance",
    "parent": "can-connect/constructor/constructor.hydrators",
    "src": {
      "line": 232,
      "codeLine": 247,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nMakes a type object given raw data.\n",
    "title": "hydrateInstance",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  If [can-connect/constructor/constructor.instance] is available passes `props` to that\n  and returns that value.  Otherwise, returns a clone of `props`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties returned by [can-connect/connection.getData].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "The data type used to represent the list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties returned by [can-connect/connection.getData].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "The data type used to represent the list.\n\t "
    }
  },
  "can-connect/constructor/constructor.save": {
    "type": "function",
    "name": "can-connect/constructor/constructor.save",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 254,
      "codeLine": 345,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n## Use\n\nTo use `save`, create a connection, then an instance, and call `.save()` with it.\n\n```\n// Create a connection:\nvar todoConnection = connect([\n  require('can-connect/constructor/constructor'),\n  require('can-connect/data/url/url')\n],{\n  url: \"/todos\"\n})\n\n// Create an instance:\nvar todo = {name: \"do dishes\"};\n\n// Call .save():\ntodoConnection.save(todo)\n```\n\nThis will POST to `/todos` with the `todo` data.  The server response data\nmight look something like:\n\n```\n{\n id: 5,\n ownerId: 9\n}\n```\n\nThis data will be passed to [can-connect/constructor/constructor.createdInstance] which will default\nto adding those properties to `todo`, resulting in `todo` looking like:\n\n```\n{\n name: \"do dishes\",\n id: 5,\n ownerId: 9\n}\n```\n\nTo update the todo, change a property and call `.save()` again:\n\n```\n// Change a property:\ntodo.name = \"Do dishes!!\";\n\n// Call .save()\ntodoConnection.save(todo)\n```\n\nThis will PUT to `/todos` with the `todo` data.  The server response data\nshould look something like:\n\n```\n{\n name: \"Do dishes!!\",\n id: 5,\n ownerId: 9\n}\n```\n\nThis data will be passed to [can-connect/constructor/constructor.updatedInstance] which will default\nto setting all of `todos` properties to look like the response data.\n\t \n",
    "description": "Creates or updates an instance using the underlying data interface. \n",
    "title": "save",
    "signatures": [
      {
        "code": "connection.save( instance )",
        "description": "\n\n  Checks if the instance has an [can-connect/base/base.id] or not.  If it\n  has an id, the instance will be updated; otherwise, it will be created.\n\n  To create an instance, the instance is added to the [can-connect/constructor.cidStore],\n  and its [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.createData].  If `createData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor/constructor.createdInstance] is called.\n\n  To update an instance, its [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.updateData]. If `updateData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor/constructor.updatedInstance] is called.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to create or save.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "resolves to the same instance that was passed to `save`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to create or save.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "resolves to the same instance that was passed to `save`.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.destroy": {
    "src": {
      "line": 375,
      "codeLine": 421,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "type": "function",
    "body": "\n## Use\n\nTo use `destroy`, create a connection, then retrieve an instance, and call `.destroy()` with it.\n\n```\n// Create a connection:\nvar todoConnection = connect([\n  require('can-connect/constructor/constructor'),\n  require('can-connect/data/url/url')\n],{\n  url: \"/todos\"\n})\n\n// Get a todo instance\ntodoConnection.get({id: 5}).then(function(todo){\n  // Call .destroy():\n  todoConnection.destroy(todo)\n});\n```\n\nThis will DELETE to `/todos/5` with the `todo` data.  The server response data\nmight look something like:\n\n```\n{}\n```\n\nThis data will be passed to [can-connect/constructor/constructor.destroyedInstance].\n\t \n",
    "description": "Destroys an instance using the underlying data interface. \n",
    "title": "destroy",
    "name": "can-connect/constructor/constructor.destroy",
    "parent": "can-connect/constructor/constructor.crud",
    "signatures": [
      {
        "code": "connection.destroy( instance )",
        "description": "\n\n  To destroy an instance, its [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.destroyData]. If `destroyData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor/constructor.destroyedInstance] is called.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to create or save.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "resolves to the same instance that was passed to `save`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to create or save.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "resolves to the same instance that was passed to `save`.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.createdInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.createdInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 435,
      "codeLine": 449,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being created with the result of [can-connect/connection.createData].\n",
    "title": "createdInstance",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n  Adds every property and value in `props` to `instance`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.createData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.createData].\n\t "
    }
  },
  "can-connect/constructor/constructor.updatedInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.updatedInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 452,
      "codeLine": 467,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being updated with the result of [can-connect/connection.updateData].\n",
    "title": "updatedInstance",
    "signatures": [
      {
        "code": "connection.updatedInstance( instance, props )",
        "description": "\n\n  Sets the properties in `instance` to match the properties and values in `props`\n  with the exception of [can-connect/base/base.idProp], which it leaves alone.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.updateData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.updateData].\n\t "
    }
  },
  "can-connect/constructor/constructor.updatedList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.updatedList",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 470,
      "codeLine": 488,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates a list with new data.\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedList( list, listData, set )",
        "description": "\n\n  [can-connect/constructor/constructor.hydrateInstance Hydrates] instances with `listData`'s data\n  and attempts to merge them into `list`.  The merge is able to identify simple insertions\n  and removals of elements instead of replacing the entire list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "list",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The raw data usd to update `list`.\n"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set of data `listData` represents.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set of data `listData` represents.\n\t "
    }
  },
  "can-connect/constructor/constructor.destroyedInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.destroyedInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 500,
      "codeLine": 515,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being destroyed with the result of [can-connect/connection.destroyData].\n",
    "title": "destroyedInstance",
    "signatures": [
      {
        "code": "connection.destroyedInstance( instance, props )",
        "description": "\n\n  Sets the properties in `instance` to match the properties and values in `props`\n  with the exception of [can-connect/base/base.idProp], which it leaves alone.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.destroyData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.destroyData].\n\t "
    }
  },
  "can-connect/constructor/constructor.serializeInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.serializeInstance",
    "parent": "can-connect/constructor/constructor.serializers",
    "src": {
      "line": 518,
      "codeLine": 532,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "",
    "description": "Returns the serialized form of an instance. \n",
    "title": "serializeInstance",
    "signatures": [
      {
        "code": "connection.serializeInstance( instance )",
        "description": "\n\n  This implementation simply clones the `instance` object.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to serialize.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A serialized representation of the instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to serialize.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A serialized representation of the instance.\n\t "
    }
  },
  "can-connect/constructor/constructor.serializeList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.serializeList",
    "parent": "can-connect/constructor/constructor.serializers",
    "src": {
      "line": 535,
      "codeLine": 551,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "",
    "description": "Returns the serialized form of an list. \n",
    "title": "serializeList",
    "signatures": [
      {
        "code": "connection.serializeList( list )",
        "description": "\n\n  This implementation simply returns an `Array` containing the result of\n  [can-connect/constructor/constructor.serializeInstance] called on each item in the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The instance to serialize.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "A serialized representation of the list.\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "The instance to serialize.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "A serialized representation of the list.\n\n\t "
    }
  },
  "can-connect/constructor/constructor.isNew": {
    "type": "function",
    "name": "can-connect/constructor/constructor.isNew",
    "parent": "can-connect/constructor/constructor.helpers",
    "src": {
      "line": 557,
      "codeLine": 570,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nReturns if this instance has not been persisted.\n",
    "title": "isNew",
    "signatures": [
      {
        "code": "connection.isNew(instance)",
        "description": "\n\n  Checks that the instance has an [can-connect/base/base.id].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "The instance to test."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the instance has not been persisted.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "The instance to test."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the instance has not been persisted.\n\t "
    }
  },
  "can-connect/constructor/constructor.list": {
    "body": "\n\n## Use\n\nIf you have a special type of list with helper functions you'd like to have available,\nyou can do that in `list`.  The following makes it so `getList` resolves to array-like\nobjects that have a `completed` function.\n\n```\nvar MyList = Object.create(Array.prototype);\nMyList.prototype.completed = function(){\n  return this.filter(function(){ return this.completed });\n};\n\nvar todosConnection = connect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"todos\",\n  list: function(listData, set){\n    var collection = Object.create(MyList);\n    Array.apply(collection, listData.data);\n    collection.__listSet = set;\n    return collection;\n  }\n});\n```\n\nThis allows:\n\n```\ntodosConnection.getList({}).then(function(todos){\n  console.log(\"There are\",todos.completed().length, \"completed todos\")\n});\n```\n\n\nNotice that we added the default [can-connect/base/base.listSetProp] (`__listSet`) data on the list. This is useful\nfor other extensions.\n\n\t \n",
    "description": "\nReturns the data in its typed list form.\n",
    "title": "list",
    "name": "can-connect/constructor/constructor.list",
    "type": "property",
    "parent": "can-connect/constructor/constructor.hydrators",
    "signatures": [
      {
        "code": "connection.list( listInstanceData, set )",
        "description": "\n\n  Takes an object with a data property that is an array of instances returned by\n  [can-connect/constructor/constructor.hydrateInstance] and should return the right type of list.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": [
                  {
                    "name": "data",
                    "types": [
                      {
                        "type": "Array",
                        "template": [
                          {
                            "types": [
                              {
                                "type": "Instance"
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "listInstanceData",
            "description": "An object that contains an array\nof instances.\n"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set this list belongs to.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "The instances in the special list type.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set this list belongs to.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "The instances in the special list type.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.instance": {
    "src": {
      "line": 635,
      "codeLine": 687,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\nIf you have a special type with helper functions you'd like to have available,\nyou can convert raw data to that type in `instance`.  The following makes it so\n[can-connect/constructor/constructor.get .get] resolves to objects with a `complete` method.\n\n```\nTodo = function(props){\n  Object.assign(this, props);\n};\nTodo.prototype.complete = function(){\n  this.completed = true;\n}\n\nvar todosConnection = connect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"todos\",\n  instance: function( props ) {\n    return new Todo(props);\n  }\n});\n```\n\nThis allows:\n\n```\ntodosConnection.get({id: 5}).then(function(todo){\n  todo.complete();\n});\n```\n\n\t \n",
    "description": "\nReturns the typed form of the raw data.\n",
    "title": "instance",
    "name": "can-connect/constructor/constructor.instance",
    "parent": "can-connect/constructor/constructor.hydrators",
    "signatures": [
      {
        "code": "connection.instance( props )",
        "description": "\n\n  Takes raw data and runs it through [can-connect/constructor/constructor.hydrateInstance].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "The typed instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "The typed instance.\n"
    },
    "comment": " "
  },
  "getData": {
    "type": "function",
    "name": "getData",
    "params": [
      {
        "name": "params",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 9,
      "codeLine": 13,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "",
    "description": "Get an instance\n",
    "returns": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "parseListData": {
    "type": "function",
    "name": "parseListData",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "listData",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 49,
      "codeLine": 55,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "\n",
    "description": "Provided by parse-data\n",
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "listData",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An array that represents the data\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An array that represents the data\n "
    }
  },
  "parseInstanceData": {
    "type": "function",
    "name": "parseInstanceData",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "instanceData",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 56,
      "codeLine": 62,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "\n",
    "description": "Provided by parse-data\n",
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "instanceData",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object of properties on the object\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object of properties on the object\n "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.data": {
    "name": "can-connect/fall-through-cache/fall-through-cache.data",
    "title": "data callbacks",
    "type": "group",
    "parent": "can-connect/fall-through-cache/fall-through-cache",
    "description": "",
    "order": 0
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrators": {
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/fall-through-cache/fall-through-cache",
    "description": "",
    "order": 0
  },
  "can-connect/fall-through-cache/fall-through-cache": {
    "name": "can-connect/fall-through-cache/fall-through-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 71,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n\n## Use\n\nTo use the `fall-through-cache`, create a connection with a\n[can-connect/base/base.cacheConnection] and a behavior that implements\n[can-connect/connection.getData] and [can-connect/connection.getListData].\n\n```\nvar cache = connect([\n  require(\"can-connect/data/localstorage-cache/localstorage-cache\")\n],{\n  name: \"todos\"\n});\n\nvar todoConnection = connect([\n   require(\"can-connect/fall-through-cache/fall-through-cache\"),\n   require(\"can-connect/data/url/url\"),\n   require(\"can-connect/constructor/constructor\"),\n   require(\"can-connect/constructor/store/store\")\n  ], {\n  url: \"/todos\",\n  cacheConnection: cache\n});\n```\n\nThen, make requests.  If the cache has the data,\nit will be returned immediately, and then the item or list updated later\nwith the response from the base connection:\n\n```\ntodoConnection.getList({due: \"today\"}).then(function(todos){\n\n})\n```\n\n## Demo\n\nThe following shows the `fall-through-cache` behavior.\n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/fall-through-cache.html'></div>\n\nClicking\n\"Completed\" or \"Incomplete\" will make one of the following requests and\ndisplay the results in the page:\n\n```\ntodoConnection.getList({completed: true});\ntodoConnection.getList({completed: false});\n```\n\nIf you click back and forth between \"Completed\" and \"Incomplete\" multiple times\nyou'll notice that the old data is displayed immediately and then\nupdated after about a second.\n\n\n",
    "description": "\nA fall through cache that checks another `cacheConnection`.\n",
    "title": "",
    "signatures": [
      {
        "code": "fallThroughCache( baseConnection )",
        "description": "\n\n  Implements a `getData` and `getListData` that\n  check their [can-connect/base/base.cacheConnection] for data and then\n  in the background update the instance or list with data\n  retrieved using the base connection.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrateList": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrateList",
    "parent": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "src": {
      "line": 78,
      "codeLine": 95,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nReturns a List instance given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList(listData, set)",
        "description": "\n\n  Calls the base `hydrateList` to create a List for `listData`.\n\n  Then, Looks for registered hydrateList callbacks for a given `set` and\n  calls them.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.getListData": {
    "src": {
      "line": 116,
      "codeLine": 143,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nGet raw data from the cache if available, and then update\nthe list later with data from the base connection.\n",
    "title": "getListData",
    "name": "can-connect/fall-through-cache/fall-through-cache.getListData",
    "parent": "can-connect/fall-through-cache/fall-through-cache.data",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Checks the [can-connect/base/base.cacheConnection] for `set`'s data.\n\n  If the cache connection has data, the cached data is returned. Prior to\n  returning the data, the [can-connect/constructor.hydrateList] method\n  is intercepted so we can get a handle on the list that's being created\n  for the returned data. Once the intercepted list is retrieved,\n  we use the base connection to get data and update the intercepted list and\n  the cacheConnection.\n\n  If the cache connection does not have data, the base connection\n  is used to load the data and the cached connection is updated with that\n  data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that returns the\nraw data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that returns the\nraw data.\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrateInstance": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrateInstance",
    "parent": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "src": {
      "line": 184,
      "codeLine": 200,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nReturns an instance given raw data.\n",
    "title": "hydrateInstance",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  Calls the base `hydrateInstance` to create an Instance for `props`.\n\n  Then, Looks for registered hydrateInstance callbacks for a given [can-connect/base/base.id] and\n  calls them.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.getData": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.getData",
    "parent": "can-connect/fall-through-cache/fall-through-cache.data",
    "src": {
      "line": 220,
      "codeLine": 247,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nGet raw data from the cache if available, and then update\nthe instance later with data from the base connection.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Checks the [can-connect/base/base.cacheConnection] for `params`'s data.\n\n  If the cache connection has data, the cached data is returned. Prior to\n  returning the data, the [can-connect/constructor/constructor.hydrateInstance] method\n  is intercepted so we can get a handle on the instance that's being created\n  for the returned data. Once the intercepted instance is retrieved,\n  we use the base connection to get data and update the intercepted instance and\n  the cacheConnection.\n\n  If the cache connection does not have data, the base connection\n  is used to load the data and the cached connection is updated with that\n  data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "The set to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that returns the\nraw data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "The set to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that returns the\nraw data.\n\t "
    }
  },
  "can-connect/helpers/map-deep-merge": {
    "type": "module",
    "name": "can-connect/helpers/map-deep-merge",
    "parent": "can-connect.modules",
    "src": {
      "line": 11,
      "codeLine": 94,
      "path": "node_modules/can-connect/helpers/map-deep-merge.js"
    },
    "body": "\n\n## Use\n\nThis method is often used by mixing in the [can-connect/can/merge/merge] behavior\ninto a connection.\n\nIt can be used directly to update a [can-define/map/map] instance or\n[can-define/list/list] instance with nested data as follows:\n\n```js\nvar mapDeepMerge = require(\"can-connect/helpers/map-deep-merge\");\n\nvar myMonth = new ContributionMonth({\n    id: 1,\n    month: \"Feb\",\n    osProjects: [ { id: 1, title: \"canjs\" }, {id: 2, title: \"jQuery++\"} ],\n    author: {id: 5, name: \"ilya\"}\n});\n\nmapDeepMerge( myMonth, {\n    id: 1,\n    month: \"February\",\n    osProjects: [ { id: 1, title: \"CanJS\" }, {id: 3, title: \"StealJS\"}, {id: 2, title: \"jQuery++\"} ],\n    author: {id: 6, name: \"ilya\"}\n});\n```\n\nThis will create the following changes:\n\n```js\n// 1 - a property update\ncontributionMonth.name = \"February\";\n// 2 - a property update on an item of a list\ncontributionMonth.osProjects[0].name = \"CanJS\";\n// 3 - item insertion\ncontributionMonth.osProjects.splice(1,0, hydrateInstance({id: 3, name: \"StealJS\"}) )\n // 4 - a map replacement (`id` is different)\ncontributionMonth.author = hydrateInstance( {id: 6, name: \"ilya\"} )\n```\n\n",
    "description": "\nPerform a smart merge of deeply nested maps and lists.\n",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "mapDeepMerge( instance, data )",
        "description": "\n\nThe `can-connect/helpers/map-deep-merge` module exports a function that\nmerges nested [can-define/map/map] or [can-define/list/list] instances.\n\n\n```\nvar mapDeepMerge = require('can-connect/helpers/map-deep-merge');\n\nvar type = new Type({ ... });\n\nmapDeepMerge(type, { ... });\n\nvar list = new Type.List([ ... ]);\nmapDeepMerge(list, [ ... ]);\n```\n\nTo properly know how to merge [can-define] instances of a [can-define/list/list],\n`mapDeepMerge` needs to know how to:\n\n- uniquely identify the instances\n- create instances from raw data (hydration)\n\n`mapDeepMerge` solves this by first identifying the [can-define.types.TypeConstructor]\nof the [can-define/list/list.prototype.wildcardItems] (index) property definition.\n\nWith the `Type` known of each item in the list, `mapDeepMerge` looks for for a `Type.algebra` to\nspecify the unique [can-set.props.id] of `Type` instances.  If `Type.algebra` does\nnot exist, it looks for an `id` and then `_id` property.\n\nWith the `Type` known of each item in the list, `mapDeepMerge` looks for a `Type.connection.hydrateInstance(props)`\nmethod.  If one does not exist, `new Type(props)` is used instead.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-define/map/map"
              },
              {
                "type": "can-define/map/list"
              }
            ],
            "name": "instance",
            "description": "An instance to apply a merge to."
          },
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "data",
            "description": "An object or array with the updated data.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "data",
      "description": "An object or array with the updated data.\n"
    },
    "comment": " "
  },
  "can-connect/helpers/weak-reference-map": {
    "type": "module",
    "name": "can-connect/helpers/weak-reference-map",
    "parent": "can-connect.modules",
    "src": {
      "line": 2,
      "codeLine": 32,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "\n\n## Use\n\n```\nvar WeakReferenceMap = require(\"can-connect/helpers/weak-reference-map\");\nvar wrm = new WeakReferenceMap();\nvar task1 = {id: 1, name: \"do dishes\"};\n\nwrm.addReference(\"1\", task1);\nwrm.has(\"1\") //-> true\nwrm.addReference(\"1\", task1);\nwrm.has(\"1\") //-> true\nwrm.deleteReference(\"1\");\nwrm.has(\"1\") //-> true\nwrm.deleteReference(\"1\");\nwrm.has(\"1\") //-> false\n```\n\n",
    "description": "\nProvides a map that only contains keys that are referenced.\n",
    "title": "WeakReferenceMap",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "new WeakReferenceMap()",
        "description": "\n\n  Creates a new weak reference map.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/helpers/weak-reference-map.prototype": {
    "src": {
      "line": 40,
      "codeLine": 43,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\n",
    "name": "can-connect/helpers/weak-reference-map.prototype",
    "parent": "can-connect/helpers/weak-reference-map",
    "title": "prototype"
  },
  "can-connect/helpers/weak-reference-map.prototype.has": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.has",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 44,
      "codeLine": 53,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "has",
    "signatures": [
      {
        "code": "weakReferenceMap.has(key)",
        "description": "\n\n  Returns if key is in the set.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A key to look for."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "If the key exists.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A key to look for."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "If the key exists.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.addReference": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.addReference",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 56,
      "codeLine": 65,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "addReference",
    "signatures": [
      {
        "code": "WeakReferenceMap.addReference(key, item)",
        "description": "\n\n  Adds a reference to item as key and increments the reference count. This should be called\n  when a value should be managed by something, typically the [can-connect/constructor/store/store].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.deleteReference": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.deleteReference",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 79,
      "codeLine": 88,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "deleteReference",
    "signatures": [
      {
        "code": "weakReferenceMap.deleteReference(key)",
        "description": "\n\n  Decrements the reference count for key and removes it if the reference count is `0`. This should be called\n  when a value should not be managed by something, typically the [can-connect/constructor/store/store].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.get": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.get",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 97,
      "codeLine": 106,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "get",
    "signatures": [
      {
        "code": "weakReferenceMap.get(key)",
        "description": "\n\n  Returns the value stored at key if it's in the store.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "The item if it's available.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store."
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "The item if it's available.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.forEach": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.forEach",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 112,
      "codeLine": 120,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "forEach",
    "signatures": [
      {
        "code": "weakReferenceMap.forEach(callback)",
        "description": "\n\n  Calls `callback` for every value in the store.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "key"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A callback handler.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "item"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "key"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "A callback handler.\n "
    }
  },
  "can-connect/real-time/real-time.methods": {
    "name": "can-connect/real-time/real-time.methods",
    "title": "methods",
    "type": "group",
    "parent": "can-connect/real-time/real-time",
    "description": "",
    "order": 0
  },
  "can-connect/real-time/real-time.callbacks": {
    "name": "can-connect/real-time/real-time.callbacks",
    "title": "data callbacks",
    "type": "group",
    "parent": "can-connect/real-time/real-time",
    "description": "",
    "order": 1
  },
  "can-connect/real-time/real-time": {
    "name": "can-connect/real-time/real-time",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 127,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n\n## Use\n\nTo use `real-time`, create a connection with its dependent\nbehaviors like:\n\n```\nvar todoConnection = connect(\n   [\"real-time\",\n    \"constructor\",\n    \"constructor-store\",\n    \"constructor-callbacks-once\",\n    \"data-url\"],{\n  url: \"/todos\"\n});\n```\n\nNext, use the connection to load lists and save those lists in the\nstore:\n\n```\ntodoConnection.getList({complete: false}).then(function(todos){\n  todoConnection.addListReference(todos);\n})\n```\n\nFinally, use one of the  [can-connect/real-time/real-time.createInstance],\n[can-connect/real-time/real-time.updateInstance], and\n[can-connect/real-time/real-time.destroyInstance] methods to tell the connection\nthat data has changed.  The connection will update (by calling splice)\neach list accordingly.\n\n\n## Example\n\nThe following demo shows two lists that use this connection.  The\n\"Run Code\" button sends the connection data changes which the\nconnection will then update lists accordingly:\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/real-time.html'></div>\n\nThis example creates a `todoList` function and `todoItem` function\nthat manage the behavior of a list of todos and a single todo respectfully.\nIt uses [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe)\nto observe changes in the todo list and individual todo data. Other\nframeworks will typically provide their own observable system.\n\n### todoList\n\nWhen `todoList` is created, it is passed the `set` of data to load.  It uses\nthis to get todos from the `todoConnection` like:\n\n\n```\ntodosConnection.getList(set).then(function(retrievedTodos){\n```\n\nIt then adds those `todos` to the [can-connect/constructor/store/store.listStore] so\nthey can be updated automatically.  And, it listens to changes in `todos` and calls an `update` function:\n\n```\ntodosConnection.addListReference(todos);\nObject.observe(todos, update, [\"add\", \"update\", \"delete\"] );\n```\n\nThe update function is able to inserted new `todoItem`s in the page when items are added\nto or removed from `todos`.  We exploit that by calling `update` as if it just added\neach todo in the list:\n\n```\nupdate(todos.map(function(todo, i){\n  return {\n    type: \"add\",\n    name: \"\"+i\n  };\n}));\n```\n\n### todoItem\n\nThe `todoItem` creates an element that updates with changes\nin its `todo`.  It listens to changes in the `todo` and saves\nthe todo in the [can-connect/constructor/store/store.instanceStore] with the\nfollowing:\n\n```\nObject.observe(todo, update, [\"add\", \"update\", \"delete\"] );\ntodosConnection.addInstanceReference(todo);\n```\n\nA `todoItem` needs to be able to stop listening on the `todo` and remove itself from the\n`instanceStore` if the `todo` is removed from the page.  To provide this teardown\nfunctionality, `todoItem` listens to a `\"removed\"` event on its element and\n`unobserves` the todo and removes it from the `instanceStore`:\n\n```\n$(li).bind(\"removed\", function(){\n  Object.unobserve(todo, update, [\"add\", \"update\", \"delete\"] );\n  todosConnection.deleteInstanceReference(todo);\n});\n```\n\n",
    "description": "\nUpdate lists to include or exclude instances based\non set logic.\n",
    "title": "",
    "signatures": [
      {
        "code": "realTime( baseConnection )",
        "description": "\n\n  Overwrites the \"data callback\" methods and provides\n  [can-connect/real-time/real-time.createInstance],\n  [can-connect/real-time/real-time.updateInstance], and\n  [can-connect/real-time/real-time.destroyInstance] methods\n  that\n  update lists to include or exclude a created,\n  updated, or destroyed instance.\n\n  An instance is put in a list if it is a\n  [set.subset](https://github.com/canjs/can-set#setsubset)\n  of the [can-connect/base/base.listSet].  The item is inserted using [can-set.Algebra.prototype.index].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/real-time/real-time.createInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.createInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 135,
      "codeLine": 172,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n\n## Use\n\nWith a `real-time` connection, call `createInstance` when an instance is created that\nthe connection itself did not make.  For instance, the following might listen to\n[socket.io](http://socket.io/) for when a `todo` is created and update the connection\naccordingly:\n\n```\nsocket.on('todo created', function(todo){\n  todoConnection.createInstance(order);\n});\n```\n\n\t \n",
    "description": "\nProgramatically indicate a new instance has been created.\n",
    "title": "createInstance",
    "signatures": [
      {
        "code": "connection.createInstance(props)",
        "description": "\n\n  If there is no instance in the [can-connect/constructor/store/store.instanceStore]\n  for `props`'s [can-connect/base/base.id], an instance is [can-connect/constructor/constructor.hydrateInstance hydrated],\n  added to the store, and then [can-connect/real-time/real-time.createdData] is called with\n  `props` and the hydrated instance's serialized data. [can-connect/real-time/real-time.createdData]\n  will add this instance to any lists the instance belongs to.\n\n  If this instance has already been created, calls\n  [can-connect/real-time/real-time.updateInstance] with `props`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/real-time/real-time.createdData": {
    "type": "function",
    "name": "can-connect/real-time/real-time.createdData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "src": {
      "line": 194,
      "codeLine": 215,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nCalled whenever instance data is created.\n",
    "title": "createdData",
    "signatures": [
      {
        "code": "connection.createdData(props, params, [cid])",
        "description": "\n\n  Updates lists with the created instance.\n\n  Gets the instance created for this request. Then, updates the instance with\n  the response data `props`.\n\n  Next, it goes through every list in the [can-connect/constructor/store/store.listStore],\n  test if the instance's data belongs in that list.  If it does,\n  adds the instance's data to the serialized list data and\n  [can-connect/constructor/constructor.updatedList updates the list].\n\n\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/real-time/real-time.updatedData": {
    "src": {
      "line": 229,
      "codeLine": 243,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nCalled whenever instance data is updated.\n",
    "title": "updatedData",
    "name": "can-connect/real-time/real-time.updatedData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "signatures": [
      {
        "code": "connection.updatedData(props, params)",
        "description": "\n\n  Gets the instance that is updated, updates\n  it with `props` and the adds or removes it to\n  lists it belongs in.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ],
          "description": "Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        }
      ],
      "description": "Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t "
    }
  },
  "can-connect/real-time/real-time.updateInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.updateInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 254,
      "codeLine": 270,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nProgramatically indicate a new instance has been updated.\n",
    "title": "updateInstance",
    "signatures": [
      {
        "code": "connection.updateInstance(props)",
        "description": "\n\n  Calls [can-connect/real-time/real-time.updatedData] in the right way so\n  that the instance is updated and added to or removed from\n  any lists it belongs in.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the instance that\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "the updated instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties of the instance that\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "the updated instance.\n\t "
    }
  },
  "can-connect/real-time/real-time.destroyedData": {
    "type": "function",
    "name": "can-connect/real-time/real-time.destroyedData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "src": {
      "line": 287,
      "codeLine": 300,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "",
    "description": "\n",
    "title": "destroyedData",
    "signatures": [
      {
        "code": "connection.destroyedData(props, params)",
        "description": "\n\nGets the instance for this request.  Then tests if the instance\nis in any list in the [can-connect/constructor/store/store.listStore].  If\nit is, removes the instance from the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the destroyed instance."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "params",
            "description": "The parameters used to destroy the data.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "params",
      "description": "The parameters used to destroy the data.\n\t "
    }
  },
  "can-connect/real-time/real-time.destroyInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.destroyInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 312,
      "codeLine": 327,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nProgramatically indicate a new instance has been destroyed.\n",
    "title": "destroyInstance",
    "signatures": [
      {
        "code": "connection.destroyInstance(props)",
        "description": "\n\n  Gets or creates an instance from `props` and uses\n  it to call [can-connect/real-time/real-time.destroyedData]\n  correctly.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the destroyed instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise with the destroyed instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties of the destroyed instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise with the destroyed instance.\n\t "
    }
  },
  "can-connect/service-worker": {
    "type": "module",
    "name": "can-connect/service-worker",
    "params": [
      {
        "name": "baseConnection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect.behaviors",
    "src": {
      "line": 4,
      "codeLine": 9,
      "path": "node_modules/can-connect/service-worker/service-worker.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "hide": true
  },
  "can-connect-cloneable": {
    "src": {
      "path": "node_modules/can-connect-cloneable/docs/can-connect-cloneable.md"
    },
    "body": "\n## Use\n\n`can-connect-cloneable` can be used with `[can-define/map/map DefineMap]`s or legacy `[can-map CanMap]`s. To make `Map` instances clonable, include `can-connect-cloneable` and call it with the `Map` constructor as the parameter. This adds a `clone` method to future instances of `Map`.\n\nAn instance and it's clone have a special relationship:\n\n1. Changes to the original instance propogate automatically to the clone.\n2. Changes to the cloned instance do *not* propogate to the original until you call the clone's `save` method.\n\n### Using DefineMap (`[can-define/map/map]`)\n\nApply the mixin:\n\n```javascript\nvar makeCloneable = require(\"can-connect-cloneable\");\nvar DefineMap = require(\"can-define/map/map\");\nvar connect = require(\"can-connect\");\n\n// Extend DefineMap\nvar MyDefineMap = DefineMap.extend({ name: \"string\" });\n\n// create the connection\nvar connection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/can/map/map\")\n],{\n    Map: MyDefineMap,\n    url: \"/api/endpoint\"\n});\n\n// apply the mixin\nmakeCloneable(MyDefineMap);\n```\n\nUse the clone method:\n\n```javascript\nvar original = new MyDefineMap({ name: \"Kyle\" });\nvar clone = original.clone();\n```\n\nMake changes to the clone, and save, updating the original:\n\n```javascript\n// Change name on the clone instance\nclone.name = \"Justin\";\n\n// The value on the clone changes, but not the original value\noriginal.name; // -> \"Kyle\"\nclone.name; // -> \"Justin\"\n\n// Once the clone is saved, the clone values propogate to the original\nclone.save();\noriginal.name; // -> \"Justin\"\nclone.name; // -> \"Justin\"\n\n```\n\nMake changes to the original, updating the clone:\n```javascript\noriginal.name; // -> \"Justin\"\nclone.name; // -> \"Justin\"\n\n// Change name on the original instance\noriginal.name = \"Kyle\";\n\n// The value on the clone changes automatically\noriginal.name; // -> \"Kyle\"\nclone.name; // -> \"Kyle\"\n\n```\n\n### Using CanMap (`[can-map]`)\n\nApply the mixin:\n\n```javascript\nvar makeCloneable = require(\"can-connect-cloneable\");\nvar CanMap = require(\"can-map\");\nrequire(\"can-map-define\");\nvar connect = require(\"can-connect\");\n\n// Extend CanMap\nvar MyCanMap = CanMap.extend({\n  define: {\n    name: {\n      type: \"string\"\n    }\n  }\n});\n\n// create the connection\nvar connection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/can/map/map\")\n],{\n    Map: MyCanMap,\n    url: \"/api/endpoint\"\n});\n\n// apply the mixin\nmakeCloneable(MyCanMap);\n```\n\nUse the clone method:\n\n```javascript\nvar original = new MyCanMap({ name: \"Kyle\" });\nvar clone = original.clone();\n```\n\nMake changes to the clone, and save, updating the original:\n\n```javascript\n// Change name on the clone instance\nclone.attr(\"name\", \"Justin\");\n\n// The value on the clone changes, but not the original value\noriginal.attr(\"name\"); // -> \"Kyle\"\nclone.attr(\"name\"); // -> \"Justin\"\n\n// Once the clone is saved, the clone values propogate to the original\nclone.save();\noriginal.attr(\"name\"); // -> \"Justin\"\nclone.attr(\"name\"); // -> \"Justin\"\n\n```\n\nMake changes to the original, updating the clone:\n```javascript\noriginal.attr(\"name\"); // -> \"Justin\"\nclone.attr(\"name\"); // -> \"Justin\"\n\n// Change name on the original instance\noriginal.attr(\"name\", \"Kyle\");\n\n// The value on the clone changes automatically\noriginal.attr(\"name\"); // -> \"Kyle\"\nclone.attr(\"name\"); // -> \"Kyle\"\n\n```\n\n",
    "description": "Makes mutable clones of [can-connect]ed maps. Changes to the clone save back to the original, and changes to the original propogate to the clone. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect-cloneable",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-connect-cloneable/issues"
      },
      "dependencies": {
        "can-connect": "^1.3.3",
        "can-util": "^3.2.2"
      },
      "description": "Allows you to make mutable clones of can-connected maps and save changes back to the original",
      "devDependencies": {
        "can-define": "^1.0.16",
        "can-fixture": "^1.0.12",
        "can-list": "^3.0.2",
        "can-map": "^3.0.4",
        "can-map-define": "^3.0.4",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.4",
        "jshint": "^2.9.1",
        "steal": "^1.2.4",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "directories": {
        "doc": "docs",
        "test": "test"
      },
      "homepage": "https://github.com/canjs/can-connect-cloneable",
      "keywords": [
        "clone",
        "plugin",
        "canjs"
      ],
      "license": "MIT",
      "main": "can-connect-cloneable",
      "name": "can-connect-cloneable",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-connect-cloneable.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "documentjs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm run build && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "0.1.3"
    },
    "signatures": [
      {
        "code": "makeCloneable(Type)",
        "description": "\n\nMakes `Type` cloneable by giving its instances a `clone` method.\n\n```javascript\nvar DefineMap = require(\"can-define/map/map\");\nvar makeCloneable = require(\"can-connect-cloneable\");\n\nvar MyDefineMap = DefineMap.extend({ name: \"string\" });\nmakeCloneable(MyDefineMap);\n\nvar original = new MyDefineMap({ name: \"Kyle\" });\nvar clone = original.clone();\nclone.name; // -> \"Kyle\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-map"
              },
              {
                "type": "can-define/map/map"
              }
            ],
            "name": "Type",
            "description": "the DefineMap or CanMap you want to make clonable\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-map"
        },
        {
          "type": "can-define/map/map"
        }
      ],
      "name": "Type",
      "description": "the DefineMap or CanMap you want to make clonable\n\n"
    },
    "comment": " "
  },
  "can-connect-feathers.behaviors": {
    "name": "can-connect-feathers.behaviors",
    "title": "behaviors",
    "type": "group",
    "parent": "can-connect-feathers",
    "description": "",
    "order": 0
  },
  "can-connect-feathers": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/can-connect-feathers.md"
    },
    "body": "\nBoth of the included behaviors require a Feathers Client instance.  Here is a basic setup: \n\n```js\n// models/feathers.js\nvar feathers = require('feathers/client');\nvar socketio = require('feathers-socketio/client');\nvar io = require('socket.io-client/dist/socket.io');\nvar hooks = require('feathers-hooks');\nvar auth = require('feathers-authentication-client');\nvar socket = io('');\n\nvar feathersClient = feathers()\n  .configure(hooks())\n  .configure(socketio(socket))\n  .configure(auth());\n\nmodule.exports = feathersClient;\n```\n\n> Pro tip: If you are planning on using Done-SSR, exchange the `socket.io-client/dist/socket.io` module for `steal-socket.io` in the above example.\n",
    "description": "Integrate can-connect with the FeathersJS Client \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n`can-connect-feathers` is a set of behaviors for integrating [can-connect] with [Feathers Client](https://docs.feathersjs.com/clients/feathers.html).\n\n - The [can-connect-feathers/service/service service] behavior connects to a Feathers service.\n - The [can-connect-feathers/session/session session] behavior connects to the [feathers-authentication-client](https://docs.feathersjs.com/authentication/client.html) methods on a Feathers Client instance.\n"
      }
    ],
    "name": "can-connect-feathers",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Marshall Thompson",
        "email": "marshall@creativeideal.net",
        "url": "https://github.com/icanjs"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-connect-feathers/issues"
      },
      "dependencies": {
        "can-observation": "^3.0.5",
        "can-util": "^3.2.1",
        "can-zone-storage": "^1.0.0",
        "feathers-authentication-popups": "^0.1.2",
        "feathers-errors": "^2.7.0",
        "jwt-decode": "^2.1.0"
      },
      "description": "Feathers client library for DoneJS and can-connect",
      "devDependencies": {
        "async": "^2.1.5",
        "babel-polyfill": "^6.23.0",
        "can-connect": "^1.0.21",
        "can-define": "^1.0.10",
        "can-fixture": "^1.0.12",
        "can-fixture-socket": "^0.6.0",
        "can-set": "^1.0.3",
        "can-zone": "^0.6.1",
        "concurrently": "^3.1.0",
        "documentjs": "^0.4.4",
        "done-serve": "^0.2.5",
        "donejs-cli": "^0.9.5",
        "feathers": "^2.0.3",
        "feathers-authentication-client": "^0.3.2",
        "feathers-hooks": "^1.7.1",
        "feathers-rest": "^1.5.0",
        "feathers-socketio": "^1.4.2",
        "generator-donejs": "^0.9.0",
        "http-server": "^0.9.0",
        "jquery": "^3.1.0",
        "jshint": "^2.9.4",
        "saucelabs": "^1.4.0",
        "socket.io-client": "^1.7.2",
        "steal": "^1.0.5",
        "steal-qunit": "^1.0.0",
        "steal-socket.io": "^4.0.8",
        "steal-tools": "^1.0.1",
        "testee": "^0.3.0",
        "wd": "^1.1.3"
      },
      "homepage": "https://github.com/canjs/can-connect-feathers",
      "keywords": [
        "canjs",
        "can",
        "plugin",
        "donejs",
        "feathersjs",
        "feathers",
        "client",
        "realtime"
      ],
      "main": "can-connect-feathers",
      "name": "can-connect-feathers",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-connect-feathers.git"
      },
      "scripts": {
        "build": "node build.js",
        "ci": "node test/test-sauce-labs.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "documentjs",
        "http-server": "http-server -p 3000 --silent",
        "install-server-deps": ". ./build-server.sh",
        "jshint": "jshint --config .jshintrc --exclude node_modules/,dist/,.vscode/,_docs/,test/server/ .",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:prerelease": "npm version prerelease && npm publish --tag pegasus",
        "start": "node ./test/server/src/index.js",
        "start-test": "node ./test/server/src/index.js --timeout",
        "test": "npm run jshint && npm run testee",
        "test-integration": "npm run jshint && npm run install-server-deps && concurrently 'npm run start-test' 'npm run testee-integration' ",
        "testee": "testee test/test.html --browsers firefox",
        "testee-integration": "testee test/test-integration.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.5.5"
    },
    "comment": " "
  },
  "can-connect-signalr/createData": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/createData.md"
    },
    "body": "\n## Setup\n\nIf your `SignalR` hub conforms to the required interface (see [can-connect-signalr]), there is nothing you need to\ndo to configure this method on the client. If the method name of the `create` end point on your `SignalR` hub deviates from\nthe standard expected by `can-connect-signalr`, you can override `can-connect-signalr`'s default naming by providing\nthis property with the name expected by your `SignalR` hub.\n\n```js\n    signalR: {\n        url: 'http://test.com', // URL of the SignalR server\n        name: 'MessageHub' // Name of the SignalR hub,\n        createName: 'nameOfMethod'\n    }\n```\n\nYou can call this method directly off of a connection:\n\n```js\nconnection.createData(message);\n```\n\n## CanJS Usage\n\nIf your connection is mixed in to a `DefineMap` (see [can-connect-signalr]), `createData` can be called off of the\n`DefineMap` constructor function. Note that `can-connect-signalr` requires the method signatures\ndefined on your hub to accept only one parameter. You can pass in multiple values by sending the method\nan object:\n\n```js\n// returns a promise that will be resolved once data is received by the Hub.\n// Note: Data returned from the Hub will be received in the proxy listener.\nnew Message({\n\ttext: 'Hi there!'\n}).save();\n```\n\nWhile `createData` returns a `Promise`, that promise does not contain an instance of the created object. That\nwill be made available through the associated RPC listener, `createdData`. This listener takes care of updating\nmodel instances or lists.\n\n",
    "description": "Creates an instance on the server.  This is invoked on a new instance by calling [save]. \n",
    "title": "createData",
    "name": "can-connect-signalr/createData",
    "type": "function",
    "parent": "can-connect-signalr/data-interface",
    "signatures": [
      {
        "code": "createData(instanceData)",
        "description": "\n\nInvokes the method specified by [can-connect-signalr.signalR].createName or\n[can-connect-signalr.signalR].name+\"Create\" and expects the server to respond\nwith the created data and a [can-connect.id] property.\n\n```js\nconnect([\n  ...\n  require(\"can-connect-signalr\"),\n  ...\n], {\n  signalR: {\n    url: 'http://test.com', // URL of the SignalR server\n    name: 'MessageHub', // Name of the SignalR hub,\n    createName: 'createTheMessage'\n  },\n  Map: Message,\n  ...\n});\n\n```\n\nThe following call to `.save()` invokes a `createTheMessage` method on the `MessageHub` hub with the message's serialized data:\n\n```js\nnew Message({\n    name: \"Justin\",\n    message: \"Hello World\"\n}).save()\n// calls MesageHub.createTheMessage({\n//   name: \"Justin\",\n//   message: \"Hello World\"\n// })\n```\n\nThe server should respond with the message data plus it's `id`:\n\n```js\n{\n  \"id\": 1,\n  \"name\": \"Justin\",\n  \"message\": \"Hello World\"\n}\n```\n\nThe following `signalR` connection configurations call their corresponding Hubs and methods:\n\n```\nsignalR: { name: 'MessageHub' } //-> MessageHub.createMessageHub(message)\nsignalR: {\n    name: 'MessageHub',\n    createName: \"createIt\"\n} //-> MessageHub.createIt(message)\nsignalR: {\n    createName: \"createIt\"\n} //-> THROWS AN ERROR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The model to create."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to nothing.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The model to create."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to nothing.\n\n"
    },
    "comment": " "
  },
  "can-connect-signalr/data-interface": {
    "name": "can-connect-signalr/data-interface",
    "title": "data interface",
    "type": "group",
    "parent": "can-connect-signalr",
    "description": "",
    "order": 0
  },
  "can-connect-signalr/options": {
    "name": "can-connect-signalr/options",
    "title": "options",
    "type": "group",
    "parent": "can-connect-signalr",
    "description": "",
    "order": 0
  },
  "can-connect-signalr/methods": {
    "name": "can-connect-signalr/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-connect-signalr",
    "description": "",
    "order": 0
  },
  "can-connect-signalr": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/can-connect-signalr.md"
    },
    "body": "\n## Use\n\n`can-connect-signalr` is a [can-connect] behavior that makes a connection that can communicate with a\n[Hub](https://docs.microsoft.com/en-us/aspnet/signalr/overview/guide-to-the-api/hubs-api-guide-server) on a\n[SignalR](https://docs.microsoft.com/en-us/aspnet/signalr/) server.\n\nThe following walks through an example setup that allows a `Message`\ntype to be created, retrieved, updated and deleted by the client AND\nto be notified when messages are created, updated, or deleted by the\nserver.\n\nSpecifically, we will detail the:\n\n - `can-connect` Client setup\n - Hub Interface Requirements\n\n### `can-connect` Client setup\n\nBelow is a complete example of connecting a `DefineMap` model type to\na SignalR hub:\n\n```js\nvar DefineMap = require('can-define/map/map');\nvar DefineList = require('can-define/list/list');\nvar connect = require(\"can-connect\");\n\n// Defines the Type that will be used on the client.\nvar Message = DefineMap.extend({\n\tbody: 'string',\n\tid: 'number'\n});\n\n// Defines a List type that contains instances of the\n// Type.\nMessage.List = DefineList.extend({\n    '#': Message\n});\n\n// The minimal behaviors used to create the connection\nvar behaviors = [\n\trequire('can-connect/constructor/constructor'),\n\trequire('can-connect/constructor/store/store'),\n\trequire('can-connect/can/map/map'),\n\trequire('can-connect/data/callbacks/callbacks'),\n\trequire('can-connect/real-time/real-time'),\n\trequire('can-connect/constructor/callbacks-once/callbacks-once'),\n\trequire('can-connect-signalr') // Import the signalR Behavior\n];\n\n// Connects the types to the SignalR server\nMessage.connection = connect(behaviors, {\n\tMap: Message,\n\tList: Message.List,\n\tsignalR: {\n\t\turl: 'http://test.com',\n\t\tname: 'MessageHub'\n\t}\n});\n```\n\nThis example creates a `Message` [can-define/map/map] type and\n`Message.List` [can-define/list/list] type and connects them\nto `MessageHub` at `http://test.com`.\n\nThis sets up `Message` so it can retrieve, create, update and delete `Message`s as follows:\n\n<style>\n.table {\n width: 100%;\n border: 1px solid #ccc;\n}\n.table td, .table th {\n border: 1px solid #ccc;\n padding: 5px;\n}\n.table td:nth-child(1), .table th:nth-child(1) {\n max-width: 350px;\n}\n.table td:nth-child(2), .table th:nth-child(2) {\n max-width: 350px;\n min-width: 220px;\n}\n.table td pre {\n border: 0;\n}\n</style>\n\n<table class=\"table\">\n   <thead>\n      <tr>\n         <th>Method</th>\n         <th>\n            Description\n            </th>\n         <th>\n            Details\n         </th>\n      </tr>\n   </thead>\n   <tbody>\n\t<tr>\n\t <td>\n\t    <pre><code>Message.getList({due: \"today\"});</code></pre>\n\t </td>\n\t <td>\n\t    retrieves a list of messages\n\t </td>\n\t <td>\n\t    This calls <code>MessageHub</code>'s <code>public List<MessageModel> messageHubGetListData(MessageQueryParams queryParams)</code> method which is expected to return a list of matched messages.\n\t </td>\n\t</tr>\n\t<tr>\n\t   <td>\n\t      <pre><code>Message.get({id: 5});</code></pre>\n\t   </td>\n\t   <td>\n\t      gets a single message\n\t   </td>\n\t   <td>\n\t      This calls <code>MessageHub</code>'s <code>public MessageModel messageHubGetData( int id )</code> method which is expected to return a single message.\n\t   </td>\n\t</tr>\n\t<tr>\n\t   <td>\n\t      <pre><code>var message = new Message({\n  body: \"Hello World!\"\n}).save();</code></pre>\n\t   </td>\n\t   <td>\n\t      creates messages\n\t   </td>\n\t   <td>\n\t      This calls <code>MessageHub</code>'s <code>public MessageModel messageHubCreate( MessageModel message )</code> method with the [can-define.types.serialize serialized] properties of the client message.  <code>MessageHubCreate</code> is expected to persist the message, add a unique\n            [can-connect/base/base.id] property and value, and return the <code>Message</code>'s new data. It should also notify clients that a message was created.\n\t   </td>\n\t</tr>\n\t<tr>\n\t   <td>\n\t      <pre><code>message.body = \"Hi there.\"; \nmessage.save();</code></pre>\n\t   </td>\n\t   <td>\n\t      updates a message\n\t   </td>\n\t   <td>\n\t      This calls <code>MessageHub</code>'s <code>public MessageModel messageHubUpdate( MessageModel message )</code> method which is expected to update the persisted representation of the message\n            and return the <code>Message</code>'s new data. It should also notify clients that a\n            message was updated.\n\t   </td>\n\t</tr>\t\n\t<tr>\n\t   <td>\n\t      <pre><code>message.destroy();</code></pre>\n\t   </td>\n\t   <td>\n\t      deletes a message\n\t   </td>\n\t   <td>\n\t      This calls <code>MessageHub</code>'s <code>public MessageModel messageHubDestroy( MessageModel message )</code> method which is expected to delete the persisted representation of the message\n            and return the <code>Message</code>'s updated data. It should also notify clients that a\n            message was destroyed.\n\t   </td>\n\t</tr>\t\t\n   </tbody>\n</table>\n\n### Hub Server Setup\n\nThe following code outlines a `MessageHub` that would work with with\nthe above client setup:\n\n```c-sharp\npublic class MessageHub : Hub\n    {\n\n        public MessageHub(MyRepository repository)\n        {\n        }\n\n\t\t// Method should take whatever data is required to create an instance\n        public MessageModel MessageHubCreate( MessageModel message )\n        {\n            PERSIST_TO_DATABASE( message );\n\n            message.id // type must have a unique id property\n\n            // Any RPC calls to the client related to creation go here\n            Clients.All.messageHubCreated(message);\n            return message;\n        }\n\n\t\t// Method should take whatever data is required to update an instance\n        public MessageModel MessageHubUpdate( MessageModel message )\n        {\n            UPDATE_DATABASE( message );\n\n            // Any RPC calls to the client related to update go here\n            Clients.All.messageHubUpdated(message);\n            return message;\n        }\n\n\t\t// Method should take whatever data is required to destroy an instance (usually an id)\n        public MessageModel MessageDestroy( MessageModel model )\n        {\n            DELETE_FROM_DATABASE( model );\n\n            // Any RPC calls to the client related to destroy go here\n            Clients.All.messageDestroyed(model);\n        }\n\n\t\t// Method should take whatever data is required to obtain a list (if any)\n        public List<MessageModel> MessageGetList( MessageQueryParams queryParams )\n        {\n            List<MessageModel> messages = GET_DATA_FROM_DATABASE( queryParams );\n            return messages;\n        }\n\n        // Method should take whatever data is required to obtain a specific item\n        public MessageModel MessageGet( int id )\n        {\n            MessageModel message = GET_RECORD_FROM_DATABASE( id );\n\n            return message;\n        }\n\n        ...\n    }\n```\n\n\n## Configuration\n\nThe name of the Hub is specified by [can-connect-signalr.signalR]`.name`.\nThis is used to create default method and event names.\n\nFor example, if the [can-connect-signalr.signalR]`.name` is `\"TaskHub\"`, it\nwill make RPC calls for the following methods ([can-connect-signalr.signalR] configuration name in parenthesis):\n\n- `taskHubGetData` (`signalR.getListName`)\n- `taskHubGetListData` (`signalR.getListName`)\n- `taskHubCreateData` (`signalR.createName`)\n- `taskHubUpdateData` (`signalR.updateName`)\n- `taskHubDestroyData` (`signalR.destroyName`)\n\nIt will listen to the following events ([can-connect-signalr.signalR] configuration name in parenthesis):\n\n- `taskHubCreatedData` (`signalR.createdData`)\n- `taskHubUpdatedData` (`signalR.updatedData`)\n- `taskHubDestroyedData` (`signalR.destroyedData`)\n\n\nFor example, you can overwrite these defaults like:\n\n```\nconnect(behaviors,{\n    Map: Task,\n    signalR: {\n        url: \"/hubs\",\n        name: \"TaskHub\",\n\n        // Calls TaskHub.getList() instead of TaskHub.taskHubGetListData().\n        getListName: \"getList\",\n    }\n});\n```\n\n",
    "description": "Connect to a [Hub](https://docs.microsoft.com/en-us/aspnet/signalr/overview/guide-to-the-api/hubs-api-guide-server) on a\n[SignalR](https://docs.microsoft.com/en-us/aspnet/signalr/) server.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect-signalr",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi, Joe Crick",
        "email": "joe@josephcrick.com",
        "url": "http://josephcrick.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-connect-signalr/issues"
      },
      "dependencies": {
        "can-connect": "^1.0.12",
        "jquery": "2.x - 3.x",
        "ms-signalr-client": "^2.2.5"
      },
      "description": "can-connect-signalr is a set of behaviors for integrating can-connect with Microsoft's signalR",
      "devDependencies": {
        "can-define": "^1.0.4",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "homepage": "https://github.com/canjs/can-connect-signalr#readme",
      "keywords": [],
      "license": "MIT",
      "main": "can-connect-signalr",
      "name": "can-connect-signalr",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-connect-signalr.git"
      },
      "scripts": {
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "preversion": "npm test",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox"
      },
      "system": {
        "transpiler": "babel"
      },
      "version": "0.1.0"
    },
    "signatures": [
      {
        "code": "connectSignalR( baseBehavior )",
        "description": "\n\nEncapsulates connecting to a `SignalR` hub, by:\n\n- implementing the: [can-connect-signalr/createData],  [can-connect-signalr/updateData], [can-connect-signalr/getData], [can-connect-signalr/getListData], and [can-connect-signalr/destroyData] [can-connect/DataInterface] methods to make RPC calls to the server.\n- listening for the following messages pushed from the server to the browser:\n  - [can-connect-signalr.signalR]`.createdName`,\n  - [can-connect-signalr.signalR]`.updatedName`,\n  - [can-connect-signalr.signalR]`.destroyedName`\n\n  and calling: [can-connect/real-time/real-time.createInstance], [can-connect/real-time/real-time.updateInstance], or [can-connect/real-time/real-time.destroyInstance].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect-signalr/destroyData": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/destroyData.md"
    },
    "body": "\n## Setup\n\nIf your `SignalR` hub conforms to the required interface (see [can-connect-signalr]), there is nothing you need to\ndo to configure this method on the client. If the method name of the `destroy` end point on your `SignalR` hub deviates from\nthe standard expected by `can-connect-signalr`, you can override `can-connect-signalr`'s default naming by providing\nthis property with the name expected by your `SignalR` hub.\n\n```js\nsignalR: {\n  url: 'http://test.com', // URL of the SignalR server\n  name: 'MessageHub' // Name of the SignalR hub,\n  destroyName: 'nameOfMethod'\n}\n```\n\nYou can call this method directly off of a connection:\n\n```js\nconnection.destroyData(message);\n```\n\n## CanJS Usage\n\nIf your connection is mixed in to a `DefineMap` (see [can-connect-signalr]), `destroyData` can be called off of the\n`DefineMap` constructor function. Note that `can-connect-signalr` requires the method signatures\ndefined on your hub to accept only one parameter. You can pass in multiple values by sending the method\nan object:\n\n```js\nmessage.destroy();\n```\n\nThe `messageDestroyed` method takes care of updating model instances or lists on connected clients.\n\n",
    "description": "Destroys an instance on the server.  This is invoked on an instance by calling [destroy]. \n\n\n",
    "title": "destroyData",
    "name": "can-connect-signalr/destroyData",
    "type": "function",
    "parent": "can-connect-signalr/data-interface",
    "signatures": [
      {
        "code": "destroyData(instanceData)",
        "description": "\n\nInvokes the method specified by [can-connect-signalr.signalR].destroyName or\n[can-connect-signalr.signalR].name+\"Destroy\".\n\n```js\nconnect([\n  ...\n  require(\"can-connect-signalr\"),\n  ...\n], {\n  signalR: {\n    url: 'http://test.com', // URL of the SignalR server\n    name: 'MessageHub', // Name of the SignalR hub,\n    destroyName: 'destroyTheMessage'\n  },\n  Map: Message,\n  ...\n});\n\n```\n\nThe following call to `.destroy()` invokes a `destroyTheMessage` method on the `MessageHub` hub with the message model:\n\n```js\nmessage.destroy();\n// calls MesageHub.destroyTheMessage(message)\n```\n\nThe following `signalR` connection configurations call their corresponding Hubs and methods:\n\n```\nsignalR: { name: 'MessageHub' } //-> MessageHub.messageHubDestroy(message)\nsignalR: {\n    name: 'MessageHub',\n    destroyName: \"destroyIt\"\n} //-> MessageHub.destroyIt(message)\nsignalR: {\n    destroyName: \"destroyIt\"\n} //-> THROWS AN ERROR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The model to delete."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The model to delete."
    },
    "comment": " "
  },
  "can-connect-signalr/getData": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/getData.md"
    },
    "body": "\n## Setup\n\nIf your `SignalR` hub conforms to the required interface (see [can-connect-signalr]), there is nothing you need to\ndo to configure this method on the client. If the method name of the `get` end point on your `SignalR` hub deviates from\nthe standard expected by `can-connect-signalr`, you can override `can-connect-signalr`'s default naming by providing\nthis property with the name expected by your `SignalR` hub.\n\n```js\nsignalR: {\n  url: 'http://test.com', // URL of the SignalR server\n  name: 'MessageHub' // Name of the SignalR hub,\n  getData: 'nameOfMethod'\n}\n```\n\nYou can call this method directly off of a connection:\n\n```js\nconnection.getData(1);\n```\n\n## CanJS Usage\n\nIf your connection is mixed in to a `DefineMap` (see [can-connect-signalr]), `getData` can be called off of the\n`DefineMap` constructor function. Note that `can-connect-signalr` requires the method signatures\ndefined on your hub to accept only one parameter. You can pass in multiple values by sending the method\nan object:\n\n```js\nMessage.getData(1);\n```\n\n",
    "description": "Gets an instance from the server. This is invoked on a constructor function by calling [getData]. \n",
    "title": "getData",
    "name": "can-connect-signalr/getData",
    "type": "function",
    "parent": "can-connect-signalr/data-interface",
    "signatures": [
      {
        "code": "getData(id)",
        "description": "\n\nInvokes the method specified by [can-connect-signalr.signalR].getData or\n[can-connect-signalr.signalR].name+\"GetData\" and expects the server to respond\nwith the data.\n\n```js\nconnect([\n  ...\n  require(\"can-connect-signalr\"),\n  ...\n], {\n  signalR: {\n    url: 'http://test.com', // URL of the SignalR server\n    name: 'MessageHub', // Name of the SignalR hub,\n    getData: 'getTheMessage'\n  },\n  Map: Message,\n  ...\n});\n\n```\n\nThe following call to `.getData()` invokes a `getTheMessage` method on the `MessageHub` hub with the provided unique message id:\n\n```js\nMessage.getData(1);\n// calls MesageHub.getTheMessage(1)\n```\n\nIt's expected that the server responds with the message:\n\n```js\n{\n  \"id\": 1,\n  \"name\": \"Justin\",\n  \"message\": \"Hello World\"\n}\n```\n\nThe following `signalR` connection configurations call their corresponding Hubs and methods:\n\n```\nsignalR: { name: 'MessageHub' } //-> MessageHub.messageHubGetData(id)\nsignalR: {\n    name: 'MessageHub',\n    getData: \"getIt\"\n} //-> MessageHub.getIt(id)\nsignalR: {\n    getData: \"getIt\"\n} //-> BREAKS\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "number"
              }
            ],
            "name": "id",
            "description": "A unique id."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to an instance.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "number"
        }
      ],
      "name": "id",
      "description": "A unique id."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to an instance.\n\n"
    },
    "comment": " "
  },
  "can-connect-signalr/getListData": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/getListData.md"
    },
    "body": "\n## Setup\n\nIf your `SignalR` hub conforms to the required interface (see [can-connect-signalr]), there is nothing you need to\ndo to configure this method on the client. If the method name of the `getList` end point on your `SignalR` hub deviates from\nthe standard expected by `can-connect-signalr`, you can override `can-connect-signalr`'s default naming by providing\nthis property with the name expected by your `SignalR` hub.\n\n```js\n    signalR: {\n        url: 'http://test.com', // URL of the SignalR server\n        name: 'MessageHub' // Name of the SignalR hub,\n        getListData: 'nameOfMethod'\n    }\n```\n\nYou can call this method directly off of a connection:\n\n```js\nconnection.getListData(queryParameters);\n```\n\n## CanJS Usage\n\nIf your connection is mixed in to a `DefineMap` (see [can-connect-signalr]), `getListData` can be called off of the\n`DefineMap` constructor function. Note that `can-connect-signalr` requires the method signatures\ndefined on your hub to accept only one parameter. You can pass in multiple values by sending the method\nan object:\n\n```js\nMessage.getListData(queryParameters);\n```\n\n",
    "description": "Gets an list of data from the server. This is invoked on a constructor function by calling [getListData]. \n",
    "title": "getListData",
    "name": "can-connect-signalr/getListData",
    "type": "function",
    "parent": "can-connect-signalr/data-interface",
    "signatures": [
      {
        "code": "getListData(queryParameters)",
        "description": "\n\nInvokes the method specified by [can-connect-signalr.signalR].getListData or\n[can-connect-signalr.signalR].name+\"GetListData\" and expects the server to respond\nwith the data.\n\n```js\nconnect([\n  ...\n  require(\"can-connect-signalr\"),\n  ...\n], {\n  signalR: {\n    url: 'http://test.com', // URL of the SignalR server\n    name: 'MessageHub', // Name of the SignalR hub,\n    getListData: 'getMessages'\n  },\n  Map: Message,\n  ...\n});\n\n```\n\nThe following call to `.getListData()` invokes a `getListOfMessages` method on the `MessageHub` hub with the provided parameters:\n\n```js\nMessage.getListData({\n  name: 'Johnson'\n});\n// calls MesageHub.getListOfMessages({\n//   name: 'Johnson'\n// })\n```\n\nIt's expected that the server responds with the message list:\n\n```js\n[\n {\n   \"id\": 1,\n   \"name\": \"Johnson\",\n   \"message\": \"Hello World\"\n },\n {\n   \"id\": 2,\n   \"name\": \"Johnson\",\n   \"message\": \"Hello again World\"\n }\n]\n```\n\nThe following `signalR` connection configurations call their corresponding Hubs and methods:\n\n```\nsignalR: { name: 'MessageHub' } //-> MessageHub.messageHubGetListData(queryParameters)\nsignalR: {\n    name: 'MessageHub',\n    getListData: \"getThem\"\n} //-> MessageHub.getThem(queryParameters)\nsignalR: {\n    getListData: \"getThem\"\n} //-> THROWS ERROR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "queryParameters",
            "description": "The query parameters."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to a list.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "queryParameters",
      "description": "The query parameters."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to a list.\n\n"
    },
    "comment": " "
  },
  "can-connect-signalr.init": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/init.md"
    },
    "body": "",
    "description": "Establishes a connection to the `SignalR` hub, sets up proxy methods and RPC listeners. \n\nThe `init` method establishes a connection to the `SignalR` hub, and creates a hub proxy. For each CRUD method,\na corresponding RPC listener is registered on the proxy. For example, `can-connect-signalr` implements a `createData`\nmethod. The listener corresponding to that method, by default called `createdData`, is registered on the proxy.\n\nThe `init` method is called automatically.\n",
    "title": "init",
    "name": "can-connect-signalr.init",
    "type": "function",
    "parent": "can-connect-signalr/methods",
    "types": []
  },
  "can-connect-signalr.signalR": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/signalR.md"
    },
    "body": "",
    "description": "The options object passed to the `can-connect` factory function that generates the  `can-connect-signalr` connection.\n\n\n",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "url",
            "description": "\nThe url of your `SignalR` hub.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "name",
            "description": "\nThe name of your `SignalR` hub.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "createName",
            "description": "\nThe name of the method on your `SignalR` hub you will use to create object instances. `can-connect-signalr`\nprovides a default name for this method (hub name + \"Create\"). Use this property to overwrite that name.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "createdName",
            "description": "\nThe name of the RPC listener your `SignalR` proxy you will use to listen for objects created on your hub. \n`can-connect-signalr` provides a default name for this method (hub name + \"Created\"). Use this property \nto overwrite that name.\n    ",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "updateName",
            "description": "\nThe name of the method on your `SignalR` hub you will use to update object instances. `can-connect-signalr`\nprovides a default name for this method (hub name + \"Update\"). Use this property to overwrite that name.\n ",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "updatedName",
            "description": "\nThe name of the RPC listener your `SignalR` proxy you will use to listen for objects updated on your hub. \n`can-connect-signalr` provides a default name for this method (hub name + \"Updated\"). Use this property \nto overwrite that name.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "destroyName",
            "description": "\nThe name of the method on your `SignalR` hub you will use to destroy object instances. `can-connect-signalr`\nprovides a default name for this method (hub name + \"Destroy\"). Use this property to overwrite that name.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "destroyedName",
            "description": "\nThe name of the RPC listener your `SignalR` proxy you will use to listen for objects deleted from your hub. \n`can-connect-signalr` provides a default name for this method (hub name + \"Destroyed\"). Use this property \nto overwrite that name.    \n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "getListName",
            "description": "\nThe name of the method on your `SignalR` hub you will use to get a list of object instances. `can-connect-signalr`\nprovides a default name for this method (hub name + \"GetList\"). Use this property to overwrite that name.\n        ",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "listDataName",
            "description": "\nThe name of the RPC listener your `SignalR` proxy you will use to listen for object lists retrieved from your hub. \n`can-connect-signalr` provides a default name for this method (hub name + \"ListData\"). Use this property \nto overwrite that name.    \n    ",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "getName",
            "description": "\nThe name of the method on your `SignalR` hub you will use to get object instances. `can-connect-signalr`\nprovides a default name for this method (hub name + \"Get\"). Use this property to overwrite that name.\n        ",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "dataName",
            "description": "\nThe name of the RPC listener your `SignalR` proxy you will use to listen for objects retrieved from your hub. \n`can-connect-signalr` provides a default name for this method (hub name + \"Data\"). Use this property \nto overwrite that name.          ",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ],
        "description": "\n\nBelow is an example of a fully configured signalR options object:\n    \n    signalR: {\n        url: 'http://test.com',\n        name: 'MessageHub',\n        createName: 'postMessage', \n        createdName: 'messagePosted',\n        updateName: 'updateThis',\n        updatedName: 'thingUpdated',\n        destroyName: 'obliterateIt',\n        destroyedName: 'itIsGone',\n        getListName: 'gimmeGimme',\n        listDataName: 'gotEmAll',\n        getName: 'wannaWanna',\n        dataName: 'gotIt'\n    }\n"
      }
    ],
    "title": "signalR",
    "name": "can-connect-signalr.signalR",
    "type": "property",
    "parent": "can-connect-signalr/options"
  },
  "can-connect-signalr/updateData": {
    "src": {
      "path": "node_modules/can-connect-signalr/docs/updateData.md"
    },
    "body": "\n## Setup\n\nIf your `SignalR` hub conforms to the required interface (see [can-connect-signalr]), there is nothing you need to\ndo to configure this method on the client. If the method name of the `update` end point on your `SignalR` hub deviates from\nthe standard expected by `can-connect-signalr`, you can override `can-connect-signalr`'s default naming by providing\nthis property with the name expected by your `SignalR` hub.\n\n```js\nsignalR: {\n  url: 'http://test.com', // URL of the SignalR server\n  name: 'MessageHub' // Name of the SignalR hub,\n  updateName: 'nameOfMethod'\n}\n```\n\nYou can call this method directly off of a connection:\n\n```js\nconnection.updateData(message);\n```\n\n## CanJS Usage\n\nIf your connection is mixed in to a `DefineMap` (see [can-connect-signalr]), `updateData` can be called off of the\n`DefineMap` constructor function. Note that `can-connect-signalr` requires the method signatures\ndefined on your hub to accept only one parameter. You can pass in multiple values by sending the method\nan object:\n\n```js\nmessage.name = 'Brian';\nmessage.save();\n```\n\nWhile `updateData` returns a `Promise`, that promise does not contain an instance of the updated object. That\nwill be made available through the associated RPC listener, `updatedData`. This listener takes care of updating\nmodel instances or lists.\n\n",
    "description": "Updates an instance on the server.  This is invoked on an existing instance by calling [save]. \n",
    "title": "updateData",
    "name": "can-connect-signalr/updateData",
    "type": "function",
    "parent": "can-connect-signalr/data-interface",
    "signatures": [
      {
        "code": "updateData(instanceData)",
        "description": "\n\nInvokes the method specified by [can-connect-signalr.signalR].updateName or\n[can-connect-signalr.signalR].name+\"Update\" and expects the server to respond\nwith the updated data.\n\n```js\nconnect([\n  ...\n  require(\"can-connect-signalr\"),\n  ...\n], {\n  signalR: {\n    url: 'http://test.com', // URL of the SignalR server\n    name: 'MessageHub', // Name of the SignalR hub,\n    updateName: 'updateTheMessage'\n  },\n  Map: Message,\n  ...\n});\n\n```\n\nThe following call to `.save()` invokes an `updateTheMessage` method on the `MessageHub` hub with the message's serialized data:\n\n```js\nmessage.name = 'Brian';\nmessage.save();\n// calls MesageHub.updateTheMessage({\n//   name: \"Brian\"\n// })\n```\n\nIt's expected the server responds with the message:\n\n```js\n{\n  \"id\": 2,\n  \"name\": \"Brian\",\n  \"message\": \"Hello World\"\n}\n```\n\nThe following `signalR` connection configurations call their corresponding Hubs and methods:\n\n```\nsignalR: { name: 'MessageHub' } //-> MessageHub.updateMessageHub(message)\nsignalR: {\n    name: 'MessageHub',\n    updateName: \"updateIt\"\n} //-> MessageHub.updateIt(message)\nsignalR: {\n    updateName: \"updateIt\"\n} //-> THROWS AN ERROR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "object"
              }
            ],
            "name": "instanceData",
            "description": "The model to update."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to nothing.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "object"
        }
      ],
      "name": "instanceData",
      "description": "The model to update."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to nothing.\n\n"
    },
    "comment": " "
  },
  "can-control.extend": {
    "src": {
      "path": "node_modules/can-control/docs/control.extend.md"
    },
    "body": "\n## Examples\n\n    // Control that writes \"hello world\"\n    HelloWorld = Control.extend({\n      init: function(element){\n        element.text(\"hello world\")  \n      }\n    });\n    new HelloWorld(\"#message\");\n    \n    // Control that shows how many times\n    // the element has been clicked on\n    ClickCounter = Control.extend({\n      init: function(){\n         this.count = 0;\n         this.element.text(\"click me\")\n      },\n      \"{element} click\": function(){\n         this.count++;\n         this.element.text(\"click count = \"+this.count)\n      }\n    })\n    new ClickCounter(\"#counter\");\n \n    // Counter that counts a specified event\n    // type\n    CustomCounter = Control.extend({\n      defaults: {\n        eventType: \"click\"\n      }\n    },{\n      init: function(){\n        this.count = 0;\n        this.element.text(this.options.eventType+\" me\")\n      },\n      \"{element} {eventType}\": function(){\n         this.count++;\n         this.element.text(this.options.eventType+\n           \" count = \"+\n           this.count);\n      }\n    })\n    new CustomCounter(\"#counter\");\n    new CustomCounter(\"#buy\",{\n      eventType: \"mouseenter\"\n    });\n    \n\n",
    "description": "\n",
    "title": "extend",
    "name": "can-control.extend",
    "type": "function",
    "parent": "can-control.static",
    "signatures": [
      {
        "code": "Control.extend([staticProperties,] instanceProperties)",
        "description": "\n\nCreate a new, extended, control constructor \nfunction. \n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "An object of properties and methods that are added the control constructor \nfunction directly. The most common property to add is [can-control.defaults].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "constructs": {
                "types": [
                  {
                    "type": "can-construct"
                  }
                ]
              },
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "element"
                    }
                  ]
                },
                {
                  "types": [
                    {
                      "type": "options"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceProperties",
      "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "constructs": {
            "types": [
              {
                "type": "can-construct"
              }
            ]
          },
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "element"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "options"
                }
              ]
            }
          ]
        }
      ],
      "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n"
    },
    "comment": " "
  },
  "can-control.defaults": {
    "src": {
      "path": "node_modules/can-control/docs/defaults.md"
    },
    "body": "\nDefault options provided for when a new control is created without values set in `options`.\n\n`defaults` provides default values for a Control's options.\nOptions passed into the constructor function will be shallowly merged\ninto the values from defaults in [can-control::setup], and\nthe result will be stored in [can-control::options this.options].\n\n\tMessage = Control.extend({\n\t  defaults: {\n\t\tmessage: \"Hello World\"\n\t  }\n\t}, {\n\t  init: function(){\n\t\tthis.element.text( this.options.message );\n\t  }\n\t});\n\n\tnew Message( \"#el1\" ); //writes \"Hello World\"\n\tnew Message( \"#el12\", { message: \"hi\" } ); //writes hi\n\n## Shared Properties\n\nNew instances of a Control will create a shallow copy of the default\noptions. Be aware as shallow copies keep a reference to object types, such as\nobjects, maps and computes.\n\n```\nvar Sample = Control.extend({\n  defaults: {\n    computedProp: can.compute(),\n    primitiveProp: 'sample'\n  }\n}, {});\n\nvar a = new Sample('div');\nvar b = new Sample('li');\n\n//`computedProp` will be shared across instances of the `Sample` control.\n//a.options.computedProp === b.options.computedProp\n```\n\n",
    "description": "Default values for the Control's options. \n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "defaults",
    "name": "can-control.defaults",
    "type": "property",
    "parent": "can-control.static",
    "comment": " "
  },
  "can-control.static": {
    "name": "can-control.static",
    "title": "static",
    "type": "group",
    "parent": "can-control",
    "description": "",
    "order": 0
  },
  "can-control.prototype": {
    "name": "can-control.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-control",
    "description": "",
    "order": 0
  },
  "can-control": {
    "src": {
      "path": "node_modules/can-control/docs/control.md"
    },
    "body": "\n## The Control Lifecycle\n\nThe following walks through a control's lifecycle\nwith an example todo list widget.  It's broken up into the following\nlifecycle events:\n\n - Extending a control\n - Creating a control instance\n - Listening to events\n - Destroying a control\n\n## Extending a control\n\nThe following example builds up a basic todos widget for listing\nand completing todo items. Start by creating a control constructor\nfunction of your own by extending [can-control] and defining an instance init method.\n\n    var Todos = Control.extend({\n      init: function( element, options ) { ... }\n    });\n\n## Creating a control instance\n\nCreate an instance of the Todos control on the `todos` element with:\n\n    var todosControl = new Todos( '#todos', {} );\n\nThe control's associated [can.ejs EJS] template looks like:\n\n    <% todos.each(function( todo ) { %>\n      <li <%= (el) -> el.data( 'todo', todo ) %> >\n        <%= todo.attr( 'name' ) %>\n        <a href=\"javascript://\" class=\"destroy\">\n      </li>\n    <% }) %>\n\n### `init(element, options)`\n\n[can-control.prototype.init] is called with the below arguments when new instances of [can-control] are created:\n\n- __element__ - The wrapped element passed to the\n                control. Control accepts a\n                raw HTMLElement, a CSS selector, or a NodeList. This is\n                set as `this.element` on the control instance.\n- __options__ - The second argument passed to new Control, extended with\n                the can.Control's static __defaults__. This is set as\n                `this.options` on the control instance. Note that static is used\n                formally to indicate that _default values are shared across control instances_.\n\nAny additional arguments provided to the constructor will be passed as normal. Use [can.view] to produce a document fragment\nfrom your template and inject it in the passed element. Note that the `todos` parameter passed to [can.view] below\nis an instance of [can-list]:\n\n    var Todos = Control.extend({\n\n      //defaults are merged into the options arg provided to the constructor\n      defaults : { view: 'todos.ejs' }\n\n    }, {\n      init: function( element , options ) {\n\n        //create a pointer to the control's scope\n        var self = this;\n\n        //run the Todo model's .findAll() method to produce a can.List\n        Todo.findAll( {}, function( todos ) {\n\n            //create a document fragment with can.view\n            //and inject it into the provided element's body\n    \t\tself.element.html( can.view(self.options.view, todos) );\n        });\n      }\n    });\n\n    // create a Todos Control with default options\n    new Todos( document.body.firstElementChild );\n\n    // overwrite the template default\n    new Todos( '#todos', { view: 'specialTodos.ejs' } );\n\n### `this.element`\n\n[can-control::element] is the\nNodeList consisting of the element the control is created on.\n\n    var todosControl = new Todos( document.body.firstElementChild );\n    todosControl.element[0] //-> document.body.firstElementChild\n\nEach library wraps elements differently. If you are using jQuery, for example,\nthe element is wrapped with `jQuery( element )`.\n\n### `this.options`\n\n[can-control::options] is the second argument passed to\n`new Control()`, merged with the control's static __defaults__ property.\n\n## Listening to events\n\nControl automatically binds prototype methods that look\nlike event handlers. Listen to __click__'s on `<li>` elements within [can-control::element this.element] like:\n\n    var Todos = Control.extend({\n      init: function( element , options ) {...},\n\n      '{element} li click': function( li, event ) {\n        console.log( 'You clicked', li.text() );\n\n        // let other controls know what happened\n        li.trigger( 'selected' );\n      }\n    });\n\nWhen an `<li>` is clicked, `\"{element} li click\"` is called with:\n\n- The library-wrapped __element__ that was clicked\n- The __event__ data\n\nControl uses event delegation, so you can add `<li>`s without needing to rebind\nevent handlers.\n\nTo destroy a todo when its `<a href=\"javascript://\" class=\"destroy\">` link\nis clicked:\n\n    var Todos = can.Control.extend({\n      init: function( element, options ) {...},\n\n      '{element} li click': function( li ) {...},\n\n      '{element} li .destroy click': function( el, ev ) {\n        // get the li element that has todo data\n        var li = el.closest( 'li' );\n\n        // get the model\n        var todo = li.data( 'todo' );\n\n        //destroy it\n        todo.destroy();\n      }\n    });\n\nWhen the todo is destroyed, EJS's live binding will remove its LI automatically.\n\n### Templated Event Handlers Part 1 `\"{eventName}\"`\n\nCustomize event handler behavior with `\"{NAME}\"` in\nthe event handler name.  The following allows customization\nof the event that destroys a todo:\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n\n      '{element} li click': function( li ) { ... },\n\n      '{element} li .destroy {destroyEvent}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // create Todos with this.options.destroyEvent\n    new Todos( '#todos', { destroyEvent: 'mouseenter' } );\n\nValues inside `{NAME}` are looked up on the control's `this.options` first,\nand then the `window`. For example, we could customize it instead like:\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n\n      '{element} li click': function( li ) { ... },\n\n      '{element} li .destroy {Events.destroy}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // Events config\n    Events = { destroy: 'click' };\n\n    // Events.destroy is looked up on the window.\n    new Todos( '#todos' );\n\nThe selector can also be templated.\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n\n      '{element} {listElement} click': function( li ) { ... },\n\n      '{element} {listElement} .destroy {destroyEvent}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // create Todos with this.options.destroyEvent\n    new Todos( '#todos',  {\n      destroyEvent: 'mouseenter',\n      listElement: 'li'\n    } );\n\n### Templated Event Handlers Part 2 `\"{objectName}\"`\n\nControl can also bind to objects other than `this.element` with\ntemplated event handlers.  This is _critical_\nfor avoiding memory leaks that are so common among MVC applications.  \n\nIf the value inside `{NAME}` is an object, Control will bind to that\nobject to listen for events. For example, the following tooltip listens to\nclicks on the window:\n\n    var Tooltip = Control.extend({\n      '{window} click': function( el, ev ) {\n        // hide only if we clicked outside the tooltip\n        if ( !this.element.has( ev.target ) ) {\n          this.element.remove();\n        }\n      }\n    });\n\n    // create a Tooltip\n    new Tooltip( $( '<div>INFO</div>' ).appendTo( el ) );\n\nThis is convenient when listening for model changes. If EJS were not\ntaking care of removing `<li>`s after their associated models were destroyed,\nwe could implement it in `Todos` like:\n\n    var Todos = Control.extend({\n      init: function( element, options ) {...},\n\n      '{element} li click': function( li ) {...},\n\n      '{element} li .destroy click': function( el, ev ) {\n        // get the li element that has todo data\n        var li = el.closest( 'li' );\n\n        // get the model\n        var todo = li.data( 'todo' );\n\n        //destroy it\n        todo.destroy();\n      },\n\n      '{Todo} destroyed': function( Todo, ev, todoDestroyed ) {\n        // find where the element\n        var index = this.todosList.indexOf( todoDestroyed );\n        this.element.children( ':nth-child(' + ( index + 1 ) + ')' )\n                    .remove();\n      }\n    });\n\n    new Todos( '#todos' );\n\n### `on()`\n\n[can-control::on] rebinds a control's event handlers. This is useful when you want\nto listen to a specific model and change it:\n\n    var Editor = Control.extend({\n      todo: function( todo ) {\n        this.options.todo = todo;\n        this.on();\n        this.setName();\n      },\n\n      // a helper that sets the value of the input\n      // to the todo's name\n      setName: function() {\n        this.element.val( this.options.todo.name );\n      },\n\n      // listen for changes in the todo\n      // and update the input\n      '{todo} updated': function() {\n        this.setName();\n      },\n\n      // when the input changes\n      // update the todo instance\n      '{element} change': function() {\n        var todo = this.options.todo;\n        todo.attr( 'name', this.element.val() );\n        todo.save();\n      }\n    });\n\n    var todo1 = new Todo({ id: 6, name: 'trash' }),\n        todo2 = new Todo({ id: 6, name: 'dishes' });\n\n    // create the editor;\n    var editor = new Editor( '#editor' );\n\n    // show the first todo\n    editor.todo( todo1 );\n\n    // switch it to the second todo\n    editor.todo( todo2 );\n\n\n## Destroying a control\n\n[can-control::destroy] unbinds a control's\nevent handlers and releases its element, but does not remove\nthe element from the page.\n\n    var todo = new Todos( '#todos' );\n    todo.destroy();\n\nWhen a control's element is removed from the page\n__destroy__ is called automatically.\n\n    new Todos( '#todos' );\n    $( '#todos' ).remove();\n\nAll event handlers bound with Control are unbound when the control\nis destroyed (or its element is removed).\n\n_Brief aside on destroy and templated event binding. Taken\ntogether, templated event binding, and control's automatic\nclean-up make it almost impossible\nto write leaking applications. An application that uses\nonly templated event handlers on controls within the body\ncould free up all\ndata by calling `$(document.body).empty()`._\n\n## Tabs Example\n\nHere is an example of how to build a simple tab widget using Control:\n\n<iframe style=\"width: 100%; height: 300px\"\n        src=\"http://jsfiddle.net/donejs/kXLLt/embedded/result,html,js,css\"\n        allowfullscreen=\"allowfullscreen\"\n        frameborder=\"0\">JSFiddle</iframe>\n\n",
    "description": "Create organized, memory-leak free, rapidly performing, stateful controls with declarative event binding. Use `Control` to create UI\ncontrols like tabs, grids, and context menus,\nand organize them into higher-order business rules with\n[can.route]. It can serve as both a traditional view and a traditional controller.\n\n",
    "type": "module",
    "title": "can-control",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "name": "can-control",
    "parent": "can-infrastructure",
    "download": "can/route",
    "test": [
      "can/route/test.html",
      "can/control/test.html"
    ],
    "inherits": "can",
    "link": "../docco/control/control.html docco",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-control"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-control/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.4",
        "can-construct": "^3.0.4",
        "can-event": "^3.0.1",
        "can-namespace": "1.0.0",
        "can-observation": "^3.0.4",
        "can-types": "^1.0.1",
        "can-util": "^3.2.2"
      },
      "description": "[![Build Status](https://travis-ci.org/canjs/can-control.png?branch=master)](https://travis-ci.org/canjs/can-control)",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^1.0.1",
        "can-map": "^3.0.3",
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-control",
      "name": "can-control",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-control.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint can-control.js can-control_test.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.0.10"
    },
    "signatures": [
      {
        "code": "Control( [staticProperties,] instanceProperties )",
        "description": "\n\nCreate a new, extended, control constructor\nfunction. This functionality is inherited from [can-construct] and is deprecated in favor of using\n[can-control.extend].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "An object of properties and methods that are added the control constructor\nfunction directly. The most common property to add is [can-control.defaults].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "An object of properties and methods that belong to\ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers (see [Listening to events](#section_Listeningtoevents)).\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "constructs": {
                "types": [
                  {
                    "type": "can.Construct"
                  }
                ]
              },
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "element"
                    }
                  ]
                },
                {
                  "types": [
                    {
                      "type": "options"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n\n"
        }
      },
      {
        "code": "new Control( element, options )",
        "description": "\n\nCreate an instance of a control. [can.Control.prototype.setup] processes\nthe arguments and sets up event binding. Write your initialization\ncode in [can.Control.prototype.init]. Note, you never call `new Control()` directly,\ninstead, you call it on constructor functions extended from `Control`.\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "can-view-nodelist"
              },
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "element",
            "description": "Specifies the element the control will be created on.\n"
          },
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "can-map"
              },
              {
                "type": "can-define/map/map"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Option values merged with [can-control.defaults Control.defaults]\nand set as [can-control::options this.options]. If options is an observable ([can-map CanMap] / [can-define/map/map DefineMap]), any values from [can-control.defaults defaults] that do not exist on the observable will be set. The observable will then be set as [can-control::options this.options].\n\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-control"
            }
          ],
          "description": "A new instance of the constructor function extending Control.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-control"
        }
      ],
      "description": "A new instance of the constructor function extending Control.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "can-map"
        },
        {
          "type": "can-define/map/map"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Option values merged with [can-control.defaults Control.defaults]\nand set as [can-control::options this.options]. If options is an observable ([can-map CanMap] / [can-define/map/map DefineMap]), any values from [can-control.defaults defaults] that do not exist on the observable will be set. The observable will then be set as [can-control::options this.options].\n\n"
    },
    "comment": " "
  },
  "can-control.prototype.destroy": {
    "src": {
      "path": "node_modules/can-control/docs/destroy.md"
    },
    "body": "## Allowing Garbage Collection\n\nDestroy is called whenever a control's element is removed from the page using\nthe library's standard HTML modifier methods. This means that you\ndon't have to call destroy yourself and it\nwill be called automatically when appropriate.\n\nThe following `Clicker` widget listens on the window for clicks and updates\nits element's innerHTML. If we remove the element, the window's event handler\nis removed auto-magically:\n\n\n\tClicker = Control({\n\t\"{window} click\": function() {\n\t\tthis.element.html( this.count ?\n\t\tthis.count++ : this.count = 0 );\n\t}\n\t});\n\n\t// create a clicker on an element\n\tnew Clicker( \"#clickme\" );\n\n\t// remove the element\n\t$( '#clickme' ).remove();\n\nThe methods you can use that will destroy controls automatically by library:\n\n__jQuery and Zepto__\n\n- `$.fn.remove`\n- `$.fn.html`\n- `$.fn.replaceWith`\n- `$.fn.empty`\n\n__Dojo__\n\n- `dojo.destroy`\n- `dojo.empty`\n- `dojo.place (with the replace option)`\n\n__Mootools__\n\n- `Element.prototype.destroy`\n\n__YUI__\n\n- `Y.Node.prototype.remove`\n- `Y.Node.prototype.destroy`\n\n\n## Teardown in Destroy\n\nSometimes, you want to reset a controlled element back to its\noriginal state when the control is destroyed. Overwriting destroy\nlets you write teardown code of this manner.\n\n__NOTE__: When overwriting destroy, make sure you call Control's base functionality.\n\nThe following example changes an element's text when the control is\ncreated and sets it back when the control is removed:\n\n\tChanger = Control.extend({\n\t\tinit: function() {\n\t\t\tthis.oldText = this.element.text();\n\t\t\tthis.element.text( \"Changed!!!\" );\n\t\t},\n\t\tdestroy: function() {\n\t\t\tthis.element.text( this.oldText );\n\t\t\tcan.Control.prototype.destroy.call( this );\n\t\t}\n\t});\n\n\t// create a changer which changes #myel's text\n\tvar changer = new Changer( '#myel' );\n\n\t// destroy changer which will reset it\n\tchanger.destroy();\n\n## Base Functionality\n\nControl prepares the control for garbage collection by:\n\n- unbinding all event handlers\n- clearing references to this.element and this.options\n- clearing the element's reference to the control\n- removing it's `Control.pluginName` from the element's className\n\n",
    "description": "Remove a Control from an element and clean up the Control. ",
    "title": "destroy",
    "name": "can-control.prototype.destroy",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.destroy()",
        "description": "\n\nPrepares a control for garbage collection and is a place to\nreset any changes the control has made.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-control.prototype.element": {
    "src": {
      "path": "node_modules/can-control/docs/element.md"
    },
    "body": "\nThe control instance's HTMLElement (or window) wrapped by the\nutil library for ease of use.\n\nIt is set by the first parameter to `new Construct( element, options )`\nin [can.Control::setup].  By default, a control listens to events on `this.element`.\n\n### Example - NodeList\n\nThe following `HelloWorld` control sets the control`s text to \"Hello World\":\n\n\tHelloWorld = Control({\n\t\tinit: function(){\n\t\t\tthis.element.text( 'Hello World' );\n\t\t}\n\t});\n\n\t// create the controller on the element\n\tnew HelloWorld( document.getElementById( '#helloworld' ) );\n\n## Wrapped NodeList\n\n`this.element` is a wrapped NodeList of one HTMLELement (or window).  This\nis for convenience in libraries like jQuery where all methods operate only on a\nNodeList.  To get the raw HTMLElement, write:\n\n\tthis.element[0] //-> HTMLElement\n\nThe following details the NodeList used by each library with\nan example of updating its text:\n\n__jQuery__ `jQuery( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Zepto__ `Zepto( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Dojo__ `new dojo.NodeList( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Mootools__ `$$( HTMLElement )`\n\n this.element.empty().appendText(\"Hello World\")\n\n__YUI__\n\n this.element.set(\"text\", \"Hello World\")\n\n## Changing `this.element`\n\nSometimes you don't want what's passed to `new Control`\nto be `this.element`.  You can change this by overwriting\nsetup or by unbinding, setting this.element, and rebinding.\n\n### Overwriting Setup\n\nThe following Combobox overwrites setup to wrap a\nselect element with a div.  That div is used\nas `this.element`. Notice how `destroy` sets back the\noriginal element.\n\n\tCombobox = Control({\n\t\tsetup: function( el, options ) {\n\t\t\tthis.oldElement = $( el );\n\t\t\tvar newEl = $( '<div/>' );\n\t\t\tthis.oldElement.wrap( newEl );\n\t\t\tcan.Control.prototype.setup.call( this, newEl, options );\n\t\t},\n\t\tinit: function() {\n\t\t\tthis.element //-> the div\n\t\t},\n\t\t\"{element} .option click\": function() {\n\t\t\t// event handler bound on the div\n\t\t},\n\t\tdestroy: function() {\n\t\t\tvar div = this.element; //save reference\n\t\t\tControl.prototype.destroy.call( this );\n\t\t\tdiv.replaceWith( this.oldElement );\n\t\t}\n\t});\n\n### Unbinding, setting, and rebinding.\n\nYou could also change this.element by calling\n[can.Control::off], setting this.element, and\nthen calling [can.Control::on] like:\n\n\tmove: function( newElement ) {\n\t\tthis.off();\n\t\tthis.element = $( newElement );\n\t\tthis.on();\n\t}\n\n",
    "description": "The element passed to the Control when creating a new instance. \n",
    "types": [
      {
        "type": "can-view-nodeList"
      }
    ],
    "title": "element",
    "name": "can-control.prototype.element",
    "type": "property",
    "parent": "can-control.prototype",
    "comment": " "
  },
  "can-control.eventDescription": {
    "src": {
      "path": "node_modules/can-control/docs/eventDescription.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "eventDescription",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-control.eventDescription",
    "parent": "can-control.types",
    "signatures": [
      {
        "code": "\"[CONTEXT ][SELECTOR ]EVENTNAME\"",
        "description": "\n\n",
        "params": []
      }
    ]
  },
  "can-control.eventHandler": {
    "src": {
      "path": "node_modules/can-control/docs/eventHandler.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "eventHandler(element, event)",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-control.eventHandler",
    "parent": "can-control.types",
    "signatures": [
      {
        "code": "function(element, event)",
        "description": "\n\n",
        "params": []
      }
    ]
  },
  "can-control.prototype.on": {
    "src": {
      "path": "node_modules/can-control/docs/on.md"
    },
    "body": "`this.on()` is used to rebind\nall event handlers when [can-control::options this.options] has changed.  It\ncan also be used to bind or delegate from other elements or objects.\n\n## Rebinding\n\nBy using templated event handlers, a control can listen to objects outside\n`this.element`.  This is extremely common in MVC programming.  For example,\nthe following control might listen to a task model's `completed` property and\ntoggle a strike className like:\n\n\tTaskStriker = Control({\n\t\t\"{task} completed\": function(){\n\t\t\tthis.update();\n\t\t},\n\t\tupdate: function(){\n\t\t\tif ( this.options.task.completed ) {\n\t\t\t\tthis.element.addClass( 'strike' );\n\t\t\t} else {\n\t\t\t\tthis.element.removeClass( 'strike' );\n\t\t\t}\n\t\t}\n\t});\n\n\tvar taskstriker = new TaskStriker({\n\t\ttask: new Task({ completed: 'true' })\n\t});\n\nTo update the `taskstriker`'s task, add a task method that updates\nthis.options and rebinds the event handlers for the new task like:\n\n\tTaskStriker = Control({\n\t\t\"{task} completed\": function(){\n\t\t\tthis.update();\n\t\t},\n\t\tupdate: function() {\n\t\t\tif ( this.options.task.completed ) {\n\t\t\t\tthis.element.addClass( 'strike' );\n\t\t\t} else {\n\t\t\t\tthis.element.removeClass( 'strike' );\n\t\t\t}\n\t\t},\n\t\ttask: function( newTask ) {\n\t\t\t\tthis.options.task = newTask;\n\t\t\t\tthis.on();\n\t\t\t\tthis.update();\n\t\t}\n\t});\n\n\tvar taskstriker = new TaskStriker({\n\t\ttask: new Task({ completed: true })\n\t});\n\n\t// Now, add a new task that is not yet completed\n\ttaskstriker.task(new Task({ completed: false }));\n\n## Adding new events\n\nIf events need to be bound to outside of the control and templated event handlers\nare not sufficient, you can call this.on to bind or delegate programmatically:\n\n\tinit: function() {\n\t\t// calls somethingClicked( el, ev )\n\t\tthis.on( 'click', 'somethingClicked' );\n\n\t\t// calls function when the window is clicked\n\t\tthis.on( window, 'click', function( ev ) {\n\t\t\t// do something\n\t\t});\n\t},\n\t\tsomethingClicked: function( el, ev ) {\n\t\t // ...\n\t}\n\n",
    "description": "Bind an event handler to a Control, or rebind all event handlers on a Control. \n",
    "title": "on",
    "name": "can-control.prototype.on",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.on([el,] selector, eventName, func)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "jQuery"
              },
              {
                "type": "collection"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "el",
            "defaultValue": "this.element",
            "description": "\nThe element to be bound.  If no element is provided, the control's element is used instead."
          },
          {
            "types": [
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "selector",
            "description": "A CSS selector for event delegation."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              },
              {
                "type": "String"
              }
            ],
            "name": "func",
            "description": "A callback function or the String name of a control function.  If a control\nfunction name is given, the control function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The id of the binding in this._bindings.\n\n`on(el, selector, eventName, func)` binds an event handler for an event to a selector under the scope of the given element.\n"
        }
      },
      {
        "code": "control.on()",
        "description": "\n\nRebind all of a control's event handlers.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of handlers bound to this Control.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of handlers bound to this Control.\n"
    },
    "comment": " "
  },
  "can-control.prototype.options": {
    "src": {
      "path": "node_modules/can-control/docs/options.md"
    },
    "body": "## Options Object\n\nThe `this.options` property is an Object that contains\nconfiguration data passed to a control when it is\ncreated (`new Control(element, options)`).\n\nIn the following example, an options object with\na message is passed to a `Greeting` control. The\n`Greeting` control changes the text of its [can-control::element element]\nto the options' message value.\n\n\tvar Greeting = Control.extend({\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message )\n\t\t}\n\t});\n\n\tnew Greeting(\"#greeting\",{message: \"I understand this.options\"});\n\nThe options argument passed when creating the control\nis merged with [can-control.defaults defaults] in\n[can-control.prototype.setup setup].\n\nIn the following example, if no message property is provided,\nthe defaults' message property is used.\n\n\tvar Greeting = Control.extend({\n\t\tdefaults: {\n\t\t\tmessage: \"Defaults merged into this.options\"\n\t\t}\n\t},{\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message )\n\t\t}\n\t});\n\n\tnew Greeting(\"#greeting\");\n\n## Options Observable\nAn observable [can-map CanMap] or [can-define/map/map DefineMap] can also be passed instead of an options object.\n\nIn the following example, the defaults' message property is set on the [can-define/map/map DefineMap] options observable, which is then set directly as `this.options`:\n\n```\n\tvar GreetingControl = Control.extend({\n\t\tdefaults: {\n\t\t\tmessage: 'Hello'\n\t\t}\n\t}, {\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message + ' ' + this.options.name )\n\t\t}\n\t});\n\n\tvar GreetingMap = DefineMap.extend({\n\t\tmessage: 'string',\n\t\tname: 'string'\n\t});\n\n\tvar data = new GreetingMap();\n\tdata.name = 'Kevin';\n\n\tnew GreetingControl('#greeting', data);\n```\n\n",
    "description": "Options used to configure a control. \n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "options",
    "name": "can-control.prototype.options",
    "type": "property",
    "parent": "can-control.prototype",
    "comment": " "
  },
  "can-control.processors": {
    "src": {
      "path": "node_modules/can-control/docs/processors.md"
    },
    "body": "\n`processors` is an object that allows you to add new events to bind\nto on a control, or to change how existent events are bound. Each\nkey-value pair of `processors` is a specification that pertains to\nan event where the key is the name of the event, and the value is\na function that processes calls to bind to the event.\n\nThe processor function takes five arguments:\n\n- _el_: The Control's element.\n- _event_: The event type.\n- _selector_: The selector preceding the event in the binding used on the Control.\n- _callback_: The callback function being bound.\n- _control_: The Control the event is bound on.\n\nInside your processor function, you should bind _callback_ to the event, and\nreturn a function for can.Control to call when _callback_ needs to be unbound.\n(If _selector_ is defined, you will likely want to use some form of delegation\nto bind the event.)\n\nHere is a Control with a custom event processor set and two callbacks bound\nto that event:\n\n\tControl.processors.birthday = function(el, ev, selector, callback, control) {\n\tif(selector) {\n\t myFramework.delegate(ev, el, selector, callback);\n\t return function() { myFramework.undelegate(ev, el, selector, callback); };\n\t} else {\n\t myFramework.bind(ev, el, callback);\n\t return function() { myFramework.unbind(ev, el, callback); };\n\t}\n\t};\n\n\tControl(\"EventTarget\", { }, {\n\t'birthday': function(el, ev) {\n\t // do something appropriate for the occasion\n\t},\n\t'.grandchild birthday': function(el, ev) {\n\t // do something appropriate for the occasion\n\t}\n\t});\n\n\tvar target = new EventTarget('#person');\n\nWhen `target` is initialized, can.Control will call `Control.processors.birthday`\ntwice (because there are two event hookups for the _birthday_ event). The first\ntime it's called, the arguments will be:\n\n- _el_: A NodeList that wraps the element with id 'person'.\n- _ev_: `'birthday'`\n- _selector_: `''`\n- _callback_: The function assigned to `' birthday'` in the prototype section of `EventTarget`'s\ndefinition.\n- _control_: `target` itself.\n\nThe second time, the arguments are slightly different:\n\n- _el_: A NodeList that wraps the element with id 'person'.\n- _ev_: `'birthday'`\n- _selector_: `'.grandchild'`\n- _callback_: The function assigned to `'.grandchild birthday'` in the prototype section of `EventTarget`'s\ndefinition.\n- _control_: `target` itself.\n\nControl already has processors for these events:\n\n- change\n- click\n- contextmenu\n- dblclick\n- focusin\n- focusout\n- keydown\n- keyup\n- keypress\n- mousedown\n- mouseenter\n- mouseleave\n- mousemove\n- mouseout\n- mouseover\n- mouseup\n- reset\n- resize\n- scroll\n- select\n- submit\n\n",
    "description": "A collection of hookups for custom events on Controls. ",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "can-control.processor"
              }
            ]
          }
        ]
      }
    ],
    "title": "processors",
    "name": "can-control.processors",
    "type": "property",
    "parent": "can-control.static",
    "comment": " "
  },
  "can-control.prototype.setup": {
    "src": {
      "path": "node_modules/can-control/docs/setup.md"
    },
    "body": "\n## Lifecycle of `setup`\n\nSetup, when called, does the following:\n\n### Sets this.element\n\nThe first parameter passed to new Control( el, options ) is expected to be\nan element.  This gets converted to a Wrapped NodeList element and set as\n[can-control.prototype.element this.element].\n\n### Adds the control's name to the element's className\n\nControl adds it's plugin name to the element's className for easier\ndebugging.  For example, if your Control is named \"Foo.Bar\", it adds\n\"foo_bar\" to the className.\n\n### Saves the control in $.data\n\nA reference to the control instance is saved in $.data.  You can find\ninstances of \"Foo.Bar\" like:\n\n\t$( '#el' ).data( 'controls' )[ 'foo_bar' ]\n\n### Merges Options\n\nMerges the default options with optional user-supplied ones.\nAdditionally, default values are exposed in the static [can-control.static.defaults defaults]\nso that users can change them.\n\n### Binds event handlers\n\nSetup does the event binding described in [can-control].\n\n",
    "description": "Perform pre-initialization logic for control instances and classes.  \n",
    "title": "setup",
    "name": "can-control.prototype.setup",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.setup(element, options)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "NodeList"
              },
              {
                "type": "String"
              }
            ],
            "name": "element",
            "description": "The element as passed to the constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "options",
            "description": "option values for the control.  These get added to\nthis.options and merged with [can-control.static.defaults defaults]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "undefined"
            },
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "options",
      "description": "option values for the control.  These get added to\nthis.options and merged with [can-control.static.defaults defaults]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.\n"
    },
    "comment": " "
  },
  "can-define.types.TypeConstructor": {
    "src": {
      "path": "node_modules/can-define/docs/TypeConstructor.md"
    },
    "body": "\r\n\r\n## Use\r\n\r\n```js\r\nvar Address = DefineMap.extend({\r\n    street: \"string\",\r\n    city: \"string\"\r\n});\r\n\r\nvar Direction = DefineMap.extend({\r\n    from: {Type: Address},\r\n    to: Address\r\n});\r\n\r\nvar direction = new Direction({\r\n    from: {street: \"2060 N. Stave\", city: \"Chicago\"},\r\n    to: new Address({street: \"123 Greenview\", city: \"Libertyville\"})\r\n});\r\n```\r\n\n",
    "description": "\r\nProvides a constructor function to be used to convert any set value into an appropriate\r\nvalue.\r\n",
    "type": "typedef",
    "title": "Type\r",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      },
      {
        "type": "can-define.types.propDefinition"
      },
      {
        "type": "Array",
        "options": []
      }
    ],
    "name": "can-define.types.TypeConstructor",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Type",
        "description": "\n\r\nA constructor function can be provided that is called to convert incoming values set on this property, like:\r\n\r\n```js\r\nprop: {\r\n  Type: Person\r\n}\r\n```    \r\n\r\n`Type` is called before [can-define.types.type] and before [can-define.types.set]. It checks if the incoming value\r\nis an [instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) `Type`. If it is, or if it is `null` or `undefined`, it passes the original value through.  If not, it passes the original value to `new Type(originalValue)` and returns the\r\nnew instance to be set.\r\n\r",
        "params": []
      },
      {
        "code": "{propDefinition}",
        "description": "\n\r\nA [can-define.types.propDefinition] that defines an inline [can-define/map/map] type.  For example:\r\n\r\n```js\r\naddress: {\r\n    Type: {\r\n        street: \"string\",\r\n        city: \"string\"\r\n    }\r\n}\r\n```\r\n\r",
        "params": []
      },
      {
        "code": "[Type|propDefinition]",
        "description": "\n\r\nDefines an inline [can-define/list/list] type that's an array of `Type` or inline `propDefinition` [can-define/map/map]\r\ninstances.  For example:\r\n\r\n```js\r\npeople: {\r\n    Type: [Person]\r\n},\r\naddresses: {\r\n    Type: [{\r\n        street: \"string\",\r\n        city: \"string\"\r\n    }]\r\n}\r\n```\r\n\r\n\r",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define.types.ValueConstructor": {
    "src": {
      "path": "node_modules/can-define/docs/ValueConstructor.md"
    },
    "body": "\r\n\r\n## Use\r\n\r\n```js\r\nvar Address = DefineMap.extend({\r\n    street: {type: \"string\", value: \"321 Longbow\"},\r\n    city: {type: \"string\", value: \"Dallas\"}\r\n});\r\n\r\nvar Direction = DefineMap.extend({\r\n    from: {Type: Address, Value: Address},\r\n    to: {Type: Address, Value: Address}\r\n});\r\n\r\nvar direction = new Direction({\r\n    to: {street: \"2070 N. Stave\"}\r\n});\r\n\r\ndirection.from.street //-> \"321 Longbow\"\r\ndirection.to.street   //-> \"2070 N. Stave\"\r\n```\r\n\n",
    "description": "\r\nProvides a constructor function to be used to provide a default value for a property.  \r\n",
    "title": "Value\r",
    "name": "can-define.types.ValueConstructor",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Value",
        "description": "\n\r\nA constructor function can be provided that is called to create a default value used for this property.\r\nThis constructor will be invoked with `new` for each created instance. The default\r\nvalue is created on demand when the property is read for the first time.\r\n\r\nSpecify `Value` like:\r\n\r\n```js\r\nprop: {\r\n    Value: Array\r\n},\r\nperson: {\r\n\tValue: Person\r\n}\r\n```\r\n\r",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define.types": {
    "src": {
      "path": "node_modules/can-define/docs/define.types.md"
    },
    "body": "\r\n\r\n## Use\r\n\r\nUse any of the type names on a [can-define.types.propDefinition]'s `type` or directly on the prototype of a [can-define/map/map DefineMap] or [can-define/map/map DefineList].\r\n\r\n```js\r\nvar define = require(\"can-define\");\r\nvar DefineMap = require(\"can-define/map/map\");\r\n\r\nvar Animal = function(name){\r\n    this.name = name;\r\n};\r\ndefine(Animal.prototype,{\r\n    name: {type: \"string\"}\r\n});\r\n\r\nvar Person = DefineMap.extend({\r\n    name: \"string\"\r\n});\r\n```\r\n\r\nYou can also pass these functions in directly:\r\n\r\n\r\n```js\r\nvar define = require(\"can-define\");\r\nvar DefineMap = require(\"can-define/map/map\");\r\n\r\nvar Animal = function(name){\r\n    this.name = name;\r\n};\r\ndefine(Animal.prototype,{\r\n    name: {type: define.type.string}\r\n});\r\n\r\nvar Person = DefineMap.extend({\r\n    name: define.type.string\r\n});\r\n```\r\n\n",
    "description": "Defines the type, initial value, and get, set, and serialize behavior for an\r\nobservable property. All type converters leave `null` and `undefined` as is except for\r\nthe `\"htmlbool\"` type converter.\r\n",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "observable",
            "description": "The default type behavior. It converts plain Objects to\r\n[can-define/map/map DefineMaps] and plain Arrays to [can-define/list/list DefineLists]. Everything else is left as is.\r",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "any",
            "description": "Leaves the set value as is, performs no type conversion. Aliased as `*`.\r",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "string",
            "description": "Converts to a string with `\"\"+val`.\r",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "date",
            "description": "Converts to a JavaScript date using `Date.parse(val)` if a string is given or `new Date(val)` if a number is passed.\r",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "number",
            "description": "Converts to a number with `+(val)`.\r",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "boolean",
            "description": "Converts to `false` if `val` is falsey, `\"0\"`, or `\"false\"`; otherwise, converts to `true`.\r",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "htmlbool",
            "description": "Like `boolean`, but converts to `true` if empty string (`\"\"`) is passed.\r",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "compute",
            "description": "Allows computes to be passed and the property take on the value of the compute.\r",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "stringOrObservable",
            "description": "Converts plain Objects to [can-define/map/map DefineMaps], plain Arrays to [can-define/list/list DefineLists] and everything else to strings.  This is useful for routing.\r\n\r",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "title": "types\r",
    "name": "can-define.types",
    "type": "property",
    "parent": "can-define.static",
    "comment": " "
  },
  "can-define.types.serialize": {
    "src": {
      "path": "node_modules/can-define/docs/serialize.md"
    },
    "body": "\r\n\r\n## Use\r\n\r\n[can-define/map/map.prototype.serialize] is useful for serializing an instance into\r\na more JSON-friendly form.  This can be used for many reasons, including saving a\r\n[can-connect]ed instance on the server or serializing [can-route.map can-route.map]'s internal\r\nmap for display in the hash or pushstate URL.\r\n\r\nThe serialize property allows an opportunity to define how\r\neach property will behave when the instance is serialized.  This can be useful for:\r\n\r\n- serializing complex types like dates, arrays, or objects into string formats\r\n- causing certain properties to be ignored when serialize is called\r\n\r\nThe following causes a locationIds property to be serialized into\r\nthe comma separated ID values of the location property on this instance:\r\n\r\n```js\r\nlocationIds: {\r\n    serialize: function(){\r\n        return this.locations.map(function(location){\r\n            ids.push(location.id);\r\n        }).join(',');\r\n    }\r\n}\r\n```\r\n\r\nReturning `undefined` for any property means this property will not be part of the serialized\r\nobject.  For example, if the property numPages is not greater than zero, the following example\r\nwon't include it in the serialized object.\r\n\r\n```js\r\nprop: {\r\n    numPages: {\r\n        serialize: function( num ){\r\n            if(num <= 0) {\r\n            \treturn undefined;\r\n            }\r\n            return num;\r\n        }\r\n    }\r\n}\r\n```\r\n\n",
    "description": "\r\nDefines custom serialization behavior for a property.\r\n",
    "title": "serialize\r",
    "name": "can-define.types.serialize",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Boolean",
        "description": "\n\r\nSpecifies if the property should be serialized.  By default, all properties except for\r\nones with defined [can-define.types.get getters] are serialized. Prevent a property\r\nfrom being serialized like:\r\n\r\n```js\r\npropertyName: {\r\n    serialize: false\r\n}\r\n```\r\n\r\nMake a [can-define.types.get getter] property part of the serialized result like:\r\n\r\n```js\r\npropertyName: {\r\n    get: function(){ ... },\r\n    serialize: true\r\n}\r\n```\r\n\r",
        "params": []
      },
      {
        "code": "serialize( currentValue, propertyName )",
        "description": "\n\r\nSpecifies the serialized value of a property.\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "currentValue",
            "description": "The current value of the attribute.\r\n\r"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The name of the property being serialized.\r\n\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If `undefined` is returned, the value is not serialized.\r\n\r"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "propertyName",
      "description": "The name of the property being serialized.\r\n\r"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If `undefined` is returned, the value is not serialized.\r\n\r"
    },
    "comment": " "
  },
  "can-define.static": {
    "name": "can-define.static",
    "title": "static",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 0
  },
  "can-define.typedefs": {
    "name": "can-define.typedefs",
    "title": "types",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 1
  },
  "can-define.behaviors": {
    "name": "can-define.behaviors",
    "title": "behaviors",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 2
  },
  "can-define": {
    "src": {
      "path": "node_modules/can-define/docs/define.md"
    },
    "body": "\r\n\r\n## Use\r\n\r\n`can-define` provides a way to create custom types with observable properties.\r\nWhere [can-define/map/map] and [can-define/list/list] provide more functionality, they also make\r\nmore assumptions on the type constructor.  `can-define` can be used\r\nto create completely customized types.\r\n\r\n\r\nThe following creates a\r\n`Person` constructor function:\r\n\r\n```js\r\nvar define = require(\"can-define\");\r\n\r\nvar Person = function(first, last){\r\n  this.first = first;\r\n  this.last = last;\r\n};\r\ndefine(Person.prototype,{\r\n  first: { type: \"string\" },\r\n  last: { type: \"string\" },\r\n  fullName: {\r\n    get: function(){\r\n      return this.first+\" \"+this.last;\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nThis can be used to create `Person` instances with observable properties:\r\n\r\n```js\r\nvar person = new Person(\"Justin\", \"Meyer\");\r\nperson.first    //-> \"Justin\"\r\nperson.last     //-> \"Meyer\"\r\nperson.fullName //-> \"Justin Meyer\"\r\n\r\nperson.on(\"fullName\", function(ev, newVal, oldVal){\r\n    newVal //-> \"Ramiya Meyer\"\r\n    oldVal //-> \"Justin Meyer\"\r\n});\r\n\r\nperson.first = \"Ramiya\"\r\n```\r\n\r\nThe observable properties call [can-observation.add Observation.add] so they can be observed by\r\n[can-compute].\r\n\n",
    "description": "Exports the `define` method that defines observable properties and their behavior on a prototype object.\r\n\r\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define",
    "parent": "can-core",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.4"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "parent": "can-define",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-define/issues"
      },
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-compute": "^3.0.0",
        "can-construct": "^3.0.6",
        "can-event": "^3.3.0",
        "can-namespace": "^1.0.0",
        "can-observation": "^3.0.1",
        "can-types": "^1.0.1",
        "can-util": "^3.5.1"
      },
      "description": "Create observable objects with JS dot operator compatibility",
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "can-list": "^3.0.1",
        "can-stache": "^3.0.13",
        "jshint": "^2.9.1",
        "serve": "^5.1.4",
        "steal": "^1.0.7",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.5.0"
      },
      "homepage": "https://github.com/canjs/can-define",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "can-define.js",
      "name": "can-define",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-define.git"
      },
      "scripts": {
        "build": "node build.js",
        "jshint": "jshint --config .jshintrc --exclude ./node_modules,./dist .",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "start": "serve -p 8080",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "1.0.26"
    },
    "signatures": [
      {
        "code": "define(prototype, propDefinitions)",
        "description": "\n\r\nDefine observable properties, type conversion, and getter/setter logic on [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain prototype objects].\r\n\r\n```js\r\nvar define = require(\"can-define\");\r\n\r\nvar Greeting = function(message){\r\n    this.message = message;\r\n};\r\n\r\ndefine(Greeting.prototype,{\r\n    message: {type: \"string\"}\r\n});\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "prototype",
            "description": "The prototype object of a constructor function or [class](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class). The prototype\r\nobject will have getter/setters defined on it that carry out the defined behavior.  The prototype will also contain\r\nall of [can-event]'s methods.\r\n\r"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "propDefinitions",
            "description": "An object of\r\nproperties and their definitions.\r\n\r\n\r"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "propDefinitions",
      "description": "An object of\r\nproperties and their definitions.\r\n\r\n\r"
    },
    "comment": " "
  },
  "can-define.types.type": {
    "src": {
      "path": "node_modules/can-define/docs/type.md"
    },
    "body": "\r\n\r\n## Use\r\n\r\nThe `type` property specifies the type of the attribute.  The type can be specified\r\nas either:\r\n\r\n- A type function that returns the type coerced value.\r\n- A named type in [can-define.types].\r\n- An object that gets converted into an inline `DefineMap`.\r\n- An array that gets converted to an inline `DefineList`.\r\n\r\n### Basic Example\r\n\r\nThe following example converts the `count` property to a number and the `items` property to an array:\r\n\r\n```js\r\nDefineMap.extend({\r\n    count: {type: \"number\"},\r\n    items: {\r\n        type: function(newValue){\r\n            if(typeof newValue === \"string\") {\r\n                return newValue.split(\",\")\r\n            } else if( Array.isArray(newValue) ) {\r\n                return newValue;\r\n            }\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nWhen a user tries to set those properties like:\r\n\r\n    map.set({count: \"4\", items: \"1,2,3\"});\r\n\r\nThe number converter will be used to turn count into 4, and the items type converter function will be used to turn items into [1,2,3].\r\n\r\n### Preventing Arrays and Objects from Automatic Conversion\r\n\r\nWhen an array value is set, it is automatically converted into a DefineList. Likewise, objects are converted into DefineMap instances. This behavior can be prevented like the following:\r\n\r\n\r\n     locations: {type: \"any\"}\r\n\r\n\r\nWhen a user tries to set this property, the resulting value will remain an array.\r\n\r\n    map.locations = [1, 2, 3]; // locations is an array, not a DefineList\r\n\r\n### Working with the 'compute' type\r\n\r\nSetting type as `compute` allows for resolving a computed property with the .attr()\r\nmethod.\r\n\r\n```\r\nMyMap = DefineMap.extend({\r\n    value: {\r\n        type: \"compute\"\r\n    }\r\n});\r\n\r\nvar myMap = new MyMap();\r\nvar c = compute(5);\r\n\r\nmyMap.value = c;\r\nmyMap.value //-> 5\r\n\r\nc(6);\r\nmyMap.value //-> 6\r\n\r\n//Be sure if setting to pass the new compute\r\nvar c2 = compute(\"a\");\r\nmyMap.value = c2;\r\nmyMap.value //-> \"a\"\r\n```\r\n\n",
    "description": "\r\nConverts a value set on an instance into an appropriate value.\r\n",
    "type": "typedef",
    "title": "type\r",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      },
      {
        "type": "string"
      }
    ],
    "name": "can-define.types.type",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "type(newValue, propertyName)",
        "description": "\n\r\nGiven the set value, transform it into a value appropriate to be set.\r\n`type` is called before [can-define.types.set].  \r\n\r\n```js\r\nage: {\r\n    type: function(newValue, propertyName){\r\n        return +newValue;\r\n    }\r\n}\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newValue",
            "description": "The value set on the property.\r"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The property name being set.\r\n\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\r\n\r"
        }
      },
      {
        "code": "\"typeName\"",
        "description": "\n\r\nSets the type to a named type in [can-define.types].  The default typeName is `\"observable\"`.\r\n\r\n```js\r\nage: {\r\n    type: \"number\"\r\n}\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "typeName",
            "description": "A named type in [can-define.types].\r\n\r\n\r"
          }
        ]
      },
      {
        "code": "{propDefinition}",
        "description": "\n\r\nA [can-define.types.propDefinition] that defines an inline [can-define/map/map] type.  For example:\r\n\r\n```js\r\naddress: {\r\n    type: {\r\n        street: \"string\",\r\n        city: \"string\"\r\n    }\r\n}\r\n```\r\n\r",
        "params": []
      },
      {
        "code": "[Type|propDefinition]",
        "description": "\n\r\nDefines an inline [can-define/list/list] type that's an array of `Type` or inline `propDefinition` [can-define/map/map]\r\ninstances.  For example:\r\n\r\n```js\r\npeople: {\r\n    type: [Person]\r\n},\r\naddresses: {\r\n    type: [{\r\n        street: \"string\",\r\n        city: \"string\"\r\n    }]\r\n}\r\n```\r\n\r\n\r",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\r\n\r"
    },
    "comment": " "
  },
  "can-define.types.get": {
    "src": {
      "path": "node_modules/can-define/docs/types.get.md"
    },
    "body": "\r\n\r\n\r\n## Use\r\n\r\nGetter methods are useful for:\r\n\r\n - Defining virtual properties on a map.\r\n - Defining property values that change with their _internal_ set value.\r\n\r\n## Virtual properties\r\n\r\n\r\nVirtual properties are properties that don't actually store any value, but derive their value\r\nfrom some other properties on the map.\r\n\r\nWhenever a getter is provided, it is wrapped in a [can-compute], which ensures\r\nthat whenever its dependent properties change, a change event will fire for this property also.\r\n\r\n```js\r\nvar Person = DefineMap.extend({\r\n    first: \"string\",\r\n    last: \"string\",\r\n\tfullName: {\r\n\t\tget: function () {\r\n\t\t\treturn this.first + \" \" + this.last;\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar p = new Person({first: \"Justin\", last: \"Meyer\"});\r\n\r\np.fullName; // \"Justin Meyer\"\r\n\r\np.on(\"fullName\", function(ev, newVal){\r\n  newVal //-> \"Lincoln Meyer\";\r\n});\r\n\r\np.first = \"Lincoln\";\r\n```\r\n\r\n## Asynchronous virtual properties\r\n\r\nOften, a virtual property's value only becomes available after some period of time.  For example,\r\ngiven a `personId`, one might want to retrieve a related person:\r\n\r\n```js\r\nvar AppState = DefineMap.extend({\r\n    personId: \"number\",\r\n    person: {\r\n        get: function(lastSetValue, resolve){\r\n          Person.get({id: this.personId})\r\n        \t.then(function(person){\r\n                       resolve(person);\r\n        \t});\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nAsynchronous properties should be bound to before reading their value.  If\r\nthey are not bound to, the `get` function will be called each time.\r\n\r\nThe following example will make multiple `Person.get` requests:\r\n\r\n```\r\nvar state = new AppState({personId: 5});\r\nstate.person //-> undefined\r\n\r\n// called sometime later ...\r\nstate.person //-> undefined\r\n```\r\n\r\nHowever, by binding, the compute only reruns the `get` function once `personId` changes:\r\n\r\n```\r\nvar state = new AppState({personId: 5});\r\n\r\nstate.on(\"person\", function(){})\r\n\r\nstate.person //-> undefined\r\n\r\n// called sometime later\r\nstate.person //-> Person<{id: 5}>\r\n```\r\n\r\nA template like [can-stache] will automatically bind for you, so you can pass\r\n`state` to the template like the following without binding:\r\n\r\n```\r\nvar template = stache(\"<span>{{person.fullName}}</span>\");\r\nvar state = new AppState({});\r\nvar frag = template(state);\r\n\r\nstate.personId = 5;\r\nfrag.childNodes[0].innerHTML //=> \"\"\r\n\r\n// sometime later\r\nfrag.childNodes[0].innerHTML //=> \"Lincoln Meyer\"\r\n```\r\n\r\nThe magic tags are updated as `personId`, `person`, and `fullName` change.\r\n\r\n\r\n## Properties values that change with their _internal_ set value\r\n\r\nA getter can be used to derive a value from a set value. A getter's\r\n`lastSetValue` argument is the last value set by `instance.propertyName = value`.\r\n\r\nFor example, a property might be set to a compute, but when read, provides the value\r\nof the compute.\r\n\r\n```\r\nvar MyMap = DefineMap.extend({\r\n    value: {\r\n        get: function( lastSetValue ){\r\n            return lastSetValue();\r\n        }\r\n    }\r\n});\r\n\r\nvar map = new MyMap();\r\nvar compute = compute(1);\r\nmap.value = compute;\r\n\r\nmap.value //-> 1\r\ncompute(2);\r\nmap.value //-> 2\r\n```\r\n\r\nThis technique should only be used when the `lastSetValue` is some form of\r\nobservable, that when it changes, can update the `getter` value.\r\n\r\nFor simple conversions, [can-define.types.set] or [can-define.types.type] should be used.\r\n\r\n## Updating the virtual property value\r\n\r\nIt's common to update virtual property values\r\ninstead of replacing it.\r\n\r\nThe following example creates an empty `locationIds` [can-define/list/list] when a new\r\ninstance of `Store` is created.  However, as `locations` change,\r\nthe [can-define/list/list] will be updated with the `id`s of the `locations`.\r\n\r\n\r\n```\r\nvar Store = DefineMap.extend({\r\n    locations: DefineList,\r\n\tlocationIds: {\r\n\t\tValue: DefineList,\r\n\t\tget: function(initialValue){\r\n\t\t\tvar ids = this.locations.map(function(location){\r\n\t\t\t\tids.push(location.id);\r\n\t\t\t});\r\n\t\t\treturn initialValue.replace(ids);\r\n\t\t}\r\n\t}\r\n});\r\n```\r\n\n",
    "description": "\r\nSpecify what happens when a certain property is read on a map. `get` functions\r\nwork like a [can-compute] and automatically update themselves when a dependent\r\nobservable value is changed.\r\n",
    "title": "get\r",
    "name": "can-define.types.get",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "get( [lastSetValue] )",
        "description": "\n\r\nDefines the behavior when a property value is read on a instance. Used to provide properties that derive their value from\r\nother properties on the object, or the property value that was set on the object.\r\n\r\nSpecify `get` like:\r\n\r\n```js\r\npropertyName: {\r\n    get: function(){ ... }\r\n},\r\npropertyName: {\r\n    get: function(lastSetValue) { ... }\r\n}\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The value last set by `instance.propertyName = value`.  Typically, _lastSetValue_\r\nshould be an observable value, like a [can-compute] or promise. If it's not, it's likely\r\nthat a [can-define.types.set] should be used instead.\r\n\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property.\r\n\r"
        }
      },
      {
        "code": "get( lastSetValue, resolve(value) )",
        "description": "\n\r\nAsynchronously defines the behavior when a value is read on an instance. Used to provide property values that\r\nare available asynchronously.\r\n\r\nOnly observed properties (via [can-event.on], [can-event.addEventListener], etc) will be passed the `resolve` function.  It will be `undefined` if the value is not observed. This is for memory safety.\r\n\r\nSpecify `get` like:\r\n\r\n```js\r\npropertyName: {\r\n  get: function(lastSetValue, resolve){ ... }\r\n}\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "lastSetValue",
            "description": "The value last set by `instance.propertyName = value`.\r\n\r"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "name": "value"
                  }
                ]
              },
              {
                "type": "undefined"
              }
            ],
            "name": "resolve",
            "description": "Updates the value of the property. This can be called\r\nmultiple times if needed. Will be `undefined` if the value is not observed.\r\n\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property before `resolve` is called.  Or a value for unobserved property reads\r\nto return.\r\n\r"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of the property before `resolve` is called.  Or a value for unobserved property reads\r\nto return.\r\n\r"
    },
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "name": "value"
            }
          ]
        },
        {
          "type": "undefined"
        }
      ],
      "name": "resolve",
      "description": "Updates the value of the property. This can be called\r\nmultiple times if needed. Will be `undefined` if the value is not observed.\r\n\r"
    },
    "comment": " "
  },
  "can-define.types.propDefinition": {
    "src": {
      "path": "node_modules/can-define/docs/types.propDefinition.md"
    },
    "body": "\r\n\r\n\r\n## Use\r\n\r\nA property definition can be defined in several ways.  The `Object` form is the most literal\r\nand directly represents a `PropDefinition` object.  The other forms\r\nget converted to a `PropDefinition` as follows:\r\n\r\n\r\n```js\r\nDefineMap.extend({\r\n  propertyA: Object      -> PropertyDefinition\r\n  propertyB: String      -> {type: String}\r\n  propertyC: Constructor -> {Type: Constructor}\r\n  propertyD: [PropDefs]  -> {Type: DefineList.extend({\"#\": PropDefs})>}\r\n  get propertyE(){...}   -> {get: propertyE(){...}}\r\n  set propertyF(){...}   -> {get: propertyF(){...}}\r\n  method: Function\r\n})\r\n```\r\n\r\nWithin a property definition, the available properties and their signatures look like:\r\n\r\n```js\r\nDefineMap.extend({\r\n  property: {\r\n    get: function(lastSetValue, resolve){...},\r\n    set: function(newValue, resolve){...},\r\n\r\n    type: function(newValue, prop){...}| Array<PropertyDefinition> | PropertyDefinition,\r\n    Type: Constructor | Array<PropertyDefinition> | PropertyDefinition,\r\n\r\n    value: function(){...},\r\n    Value: Constructor,\r\n\r\n    serialize: Boolean | function(){...}\r\n  }\r\n})\r\n```\r\n\r\nFor example:\r\n\r\n\r\n```js\r\nvar Person = DefineMap.extend(\"Person\",{\r\n  // a `DefineList` of `Address`\r\n  addresses: [Address],\r\n  // A `DefineMap` with a `first` and `last` property\r\n  name: { type: {first: \"string\", last: \"string\"} },\r\n  // A `DefineList of a ``DefineMap` with a `make` and `year` property.\r\n  cars: { Type: [{make: \"string\", year: \"number\"}] }\r\n});\r\n\r\nvar person = new Person({\r\n  addresses: [{street: \"1134 Pinetree\"}],\r\n  name: {first: \"Kath\", last: \"Iann\"}\r\n  cars: [{ make: \"Nissan\", year: 2010 }]\r\n});\r\n```\r\n\n",
    "description": "\r\nDefines the type, initial value, and get, set, and serialize behavior for an\r\nobservable property.  These behaviors can be specified with as an `Object`, `String`,\r\n`Constructor` function, `Array`, a `getter expression`, or `setter expression`.\r\n",
    "type": "typedef",
    "title": "PropDefinition\r",
    "types": [
      {
        "type": "Object",
        "description": "Defines multiple behaviors for a single property.\r\n\r\n```js\r\npropertyName: {\r\n  get: function(){ ... },\r\n  set: function(){ ... },\r\n  type: function(){ ... },\r\n  Type: Constructor,\r\n  value: function(){ ... },\r\n  Value: Constructor,\r\n  serialize: function(){ ... }\r\n}\r\n```\r\n\r",
        "options": [
          {
            "name": "value",
            "description": "Specifies the initial value of the property or\r\na function that returns the initial value.\r\n\r\n```js\r\n// A default age of `0`:\r\nvar Person = DefineMap.extend({\r\n  age: {\r\n    value: 0\r\n  },\r\n  address: {\r\n    value: function(){\r\n      return {city: \"Chicago\", state: \"IL\"};\r\n    };\r\n  }\r\n});\r\n```\r\n\r",
            "types": [
              {
                "type": "can-define.types.value"
              }
            ]
          },
          {
            "name": "Value",
            "description": "Specifies a function that will be called with `new` whose result is\r\nset as the initial value of the attribute.\r\n\r\n```js\r\n// A default empty DefineList of hobbies:\r\nvar Person = DefineMap.extend({\r\n  hobbies: {Value: DefineList}\r\n});\r\n\r\nnew Person().hobbies //-> []\r\n```\r\n\r",
            "types": [
              {
                "type": "can-define.types.ValueConstructor"
              }
            ]
          },
          {
            "name": "type",
            "description": "Specifies the type of the\r\nproperty.  The type can be specified as either a function\r\nthat returns the type coerced value or one of the [can-define.types] names.\r\n\r\n```js\r\nvar Person = DefineMap.extend({\r\n  age: {type: \"number\"},\r\n  hobbies: {\r\n    type: function(newValue){\r\n      if(typeof newValue === \"string\") {\r\n        return newValue.split(\",\")\r\n      } else if( Array.isArray(newValue) ) {\r\n        return newValue;\r\n      }\r\n    }\r\n  }\r\n});\r\n```\r\n\r",
            "types": [
              {
                "type": "can-define.types.type"
              }
            ]
          },
          {
            "name": "Type",
            "description": "A constructor function that takes\r\nthe assigned property value as the first argument and called with new. For example, the following will call\r\n`new Address(newValue)` with whatever non null, undefined, or address type is set as a `Person`'s address property.\r\n\r\n```js\r\nvar Address = DefineMap.extend({\r\n  street: \"string\",\r\n  state: \"string\"    \r\n});\r\n\r\nvar Person = DefineMap.extend({\r\n  address: {Type: Address}    \r\n});\r\n```\r\n\r",
            "types": [
              {
                "type": "can-define.types.TypeConstructor"
              }
            ]
          },
          {
            "name": "set",
            "description": "A set function that specifies what should happen when a property is set. `set` is called with the result of `type` or `Type`. The following\r\ndefines a `page` setter that updates the map's offset:\r\n\r\n```js\r\nDefineMap.extend({\r\n  page: {\r\n    set: function(newVal){\r\n      this.offset = (parseInt(newVal) - 1) * this.limit;\r\n    }\r\n  }\r\n});\r\n```\r\n\r",
            "types": [
              {
                "type": "can-define.types.set"
              }
            ]
          },
          {
            "name": "get",
            "description": "A function that specifies how the value is retrieved.  The get function is\r\nconverted to an [can-compute.async async compute].  It should derive its value from other values on the object. The following\r\ndefines a `page` getter that reads from a map's offset and limit:\r\n\r\n```js\r\nDefineMap.extend({\r\n  page: {\r\n    get: function (newVal) {\r\n\t  return Math.floor(this.offset / this.limit) + 1;\r\n\t}\r\n  }\r\n});\r\n```\r\n\r\nA `get` definition makes the property __computed__ which means it will not be enumerable by default.\r\n\r",
            "types": [
              {
                "type": "can-define.types.get"
              }
            ]
          },
          {
            "name": "serialize",
            "description": "Specifies the behavior of the property when [can-define/map/map::serialize serialize] is called.\r\n\r\nBy default, serialize does not include computed values. Properties with a `get` definition\r\nare computed and therefore are not added to the result.  Non-computed properties values are\r\nserialized if possible and added to the result.\r\n\r\n```js\r\nvar Todo = DefineMap.extend({\r\n  date: {\r\n    type: \"date\",\r\n    serialize: function(value) {\r\n      return value.getTime();\r\n    }\r\n  }\r\n});\r\n\r",
            "types": [
              {
                "type": "can-define.types.serialize"
              }
            ]
          }
        ]
      },
      {
        "type": "String",
        "description": "Defines a [can-define.types.type] converter as one of the named types in [can-define.types].\r\n\r\n```js\r\npropertyName: \"typeName\"\r\n```\r\n\r"
      },
      {
        "type": "Constructor",
        "description": "Defines a [can-define.types.TypeConstructor Type] setting with a constructor\r\nfunction.  Constructor functions are identified with [can-util/js/types/types.isConstructor].\r\n\r\n```\r\npropertyName: Constructor\r\n```\r\n\r"
      },
      {
        "type": "Array",
        "description": "Defines an inline [can-define/list/list] Type setting. This is\r\nused as a shorthand for creating a property that is an [can-define/list/list] of another type.\r\n\r\n```\r\npropertyName: [Constructor | propDefinitions]\r\n```\r\n\r\nFor example:\r\n\r\n```js\r\nusers: [User],\r\ntodos: [{complete: \"boolean\", name: \"string\"}]\r\n```\r\n\r",
        "options": []
      },
      {
        "type": "GETTER",
        "description": "Defines a property's [can-define.types.get] behavior with the\r\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get syntax].\r\n\r\n```js\r\nget propertyName(){ ... }\r\n```\r\n\r\nFor example:\r\n\r\n```js\r\nget fullName() {\r\n    return this.first + \" \" + this.last;\r\n}\r\n```\r\n\r\nThis is a shorthand for providing an object with a `get` property like:\r\n\r\n```\r\nfullName: {\r\n    get: function(){\r\n        return this.first + \" \" + this.last;\r\n    }\r\n}\r\n```\r\n\r\nYou must use an object with a [can-define.types.get] property if you want your get to take the `lastSetValue`\r\nor `resolve` arguments.\r\n\r"
      },
      {
        "type": "SETTER",
        "description": "Defines a property's [can-define.types.set] behavior with the\r\n[set syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set).\r\n\r\n```js\r\nset propertyName(newValue){ ... }\r\n```\r\n\r\nFor example:\r\n\r\n```js\r\nset fullName(newValue) {\r\n    var parts = newVal.split(\" \");\r\n    this.first = parts[0];\r\n    this.last = parts[1];\r\n}\r\n```\r\n\r\nThis is a shorthand for providing an object with a `set` property like:\r\n\r\n```\r\nfullName: {\r\n    set: function(newValue){\r\n        var parts = newVal.split(\" \");\r\n        this.first = parts[0];\r\n        this.last = parts[1];\r\n    }\r\n}\r\n```\r\n\r\nYou must use an object with a [can-define.types.set] property if you want your set to take the `resolve` argument.\r\n\r\n\r"
      }
    ],
    "name": "can-define.types.propDefinition",
    "parent": "can-define.typedefs",
    "comment": " "
  },
  "can-define.types.set": {
    "src": {
      "path": "node_modules/can-define/docs/types.set.md"
    },
    "body": "\r\n\r\n## Use\r\n\r\nA property's `set` function can be used to customize the behavior of when an attribute value is set.  Lets see some common cases:\r\n\r\n#### Side effects\r\n\r\nThe following makes setting a `page` property update the `offset`:\r\n\r\n\r\n```js\r\npage: {\r\n    set: function(newVal){\r\n        this.offset =  (parseInt(newVal) - 1) * this.limit;\r\n    }\r\n}\r\n```\r\n\r\nThe following makes changing `makeId` un-define the `modelId` property:\r\n\r\n```\r\nmakeId: {\r\n    set: function(newValue){\r\n        // Check if we are changing.\r\n        if(newValue !== this.makeId) {\r\n            this.modelId = undefined;\r\n        }\r\n        // Must return value to set as we have a `newValue` argument.\r\n        return newValue;\r\n    }\r\n}\r\n```\r\n\r\n#### Asynchronous Setter\r\n\r\nThe following shows an async setter:\r\n\r\n```js\r\nprop: {\r\n    set: function( newVal, setVal){\r\n        $.get(\"/something\", {}, setVal );\r\n    }\r\n}\r\n```\r\n\r\n\r\n## Behavior depends on the number of arguments.\r\n\r\nWhen a setter returns `undefined`, its behavior changes depending on the number of arguments.\r\n\r\nWith 0 arguments, the original set value is set on the attribute.\r\n\r\n```js\r\nMyMap = DefineMap.extend({\r\n    prop: {set: function(){}}\r\n})\r\n\r\nvar map = new MyMap({prop : \"foo\"});\r\n\r\nmap.prop //-> \"foo\"\r\n```\r\n\r\nWith 1 argument, an `undefined` return value will set the property to `undefined`.  \r\n\r\n```js\r\nMyMap = DefineMap.extend({\r\n    prop: {set: function(newVal){}}\r\n})\r\n\r\nvar map = new MyMap({prop : \"foo\"});\r\n\r\nmap.prop //-> undefined\r\n```\r\n\r\nWith 2 arguments, `undefined` leaves the property in place.  It is expected\r\nthat `resolve` will be called:\r\n\r\n```js\r\nMyMap = DefineMap.extend({\r\n    prop: {\r\n        set: function(newVal, resolve){\r\n            setVal(newVal+\"d\");\r\n        }\r\n    }\r\n});\r\n\r\nvar map = new MyMap({prop : \"foo\"});\r\n\r\nmap.prop //-> \"food\";\r\n```\r\n\r\n## Side effects\r\n\r\nA set function provides a useful hook for performing side effect logic as a certain property is being changed.\r\n\r\nFor example, in the example below, Paginator DefineMap includes a `page` property, which derives its value entirely from other properties (limit and offset).  If something tries to set the `page` directly, the set method will set the value of `offset`:\r\n\r\n```js\r\nvar Paginate = DefineMap.extend({\r\n    limit: 'number',\r\n    offset: 'number',\r\n    page: {\r\n        set: function (newVal) {\r\n            this.offset = (parseInt(newVal) - 1) * this.limit;\r\n        },\r\n        get: function () {\r\n            return Math.floor(this.offset / this.limit) + 1;\r\n        }\r\n    }\r\n});\r\n\r\nvar p = new Paginate({limit: 10, offset: 20});\r\n```\r\n\r\n\r\n\r\n## Merging\r\n\r\nBy default, if a value returned from a setter is an object the effect will be to replace the property with the new object completely.\r\n\r\n```js\r\nvar Contact = DefineMap.extend({\r\n    info: {\r\n        set: function(newVal){\r\n            return newVal;\r\n        }\r\n    }\r\n})\r\n\r\nvar alice = new Contact({\r\n\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\r\n});\r\n\r\nvar info  = alice.info;\r\n\r\nalice.info = {name: 'Allison Wonderland', phone: '888-888-8888'};\r\n\r\ninfo === alice.info // -> false\r\n```\r\n\r\nIn contrast, you can merge properties with:\r\n\r\n```js\r\nContact = DefineMap.extend({\r\n    info: {\r\n        set: function(newVal){\r\n            if(this.info) {\r\n                return this.info.set(newVal);\r\n            } else {\r\n                return newVal;\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nvar alice = new Contact({\r\n\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\r\n});\r\n\r\nvar info  = alice.info;\r\n\r\nalice.info = {name: 'Allison Wonderland', phone: '888-888-8888'};\r\n\r\ninfo === alice.info // -> true\r\n```\r\n\r\n## Batched Changes\r\n\r\nBy default, calls to `set` methods are wrapped in a call to [can-event/batch/batch.start canBatch.start] and [can-event/batch/batch.stop canBatch.stop], so if a set method has side effects that set more than one property, all these sets are wrapped in a single batch for better performance.\r\n\n",
    "description": "\r\nSpecify what happens when a property value is set.\r\n",
    "title": "set\r",
    "name": "can-define.types.set",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "set( [newVal,] [resolve] )",
        "description": "\n\r\nA set function defines the behavior of what happens when a value is set on an\r\ninstance. It is typically used to:\r\n\r\n - Add or update other properties as side effects\r\n - Coerce the set value into an appropriate action\r\n\r\nThe behavior of the setter depends on the number of arguments specified. This means that a\r\nsetter like:\r\n\r\n```js\r\nprop: {\r\n    set: function(){}\r\n}\r\n```\r\n\r\nbehaves differently than:\r\n\r\n```js\r\nprop: {\r\n    set: function(newVal){}\r\n}\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "The [can-define.types.type type function] coerced value the user intends to set on the\r\ninstance.\r\n\r"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "resolve",
            "description": "A callback that can set the value of the property\r\nasynchronously.\r\n\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If a non-undefined value is returned, that value is set as\r\nthe attribute value.\r\n\r\n\r\nIf an `undefined` value is returned, the behavior depends on the number of\r\narguments the setter declares:\r\n\r\n - If the setter _does not_ specify the `newValue` argument, the property value is set to the type converted value.\r\n - If the setter specifies the `newValue` argument only, the attribute value will be set to `undefined`.\r\n - If the setter specifies both `newValue` and `resolve`, the value of the property will not be\r\n   updated until `resolve` is called.\r\n\r\n\r"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ]
        }
      ],
      "optional": true,
      "name": "resolve",
      "description": "A callback that can set the value of the property\r\nasynchronously.\r\n\r"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If a non-undefined value is returned, that value is set as\r\nthe attribute value.\r\n\r\n\r\nIf an `undefined` value is returned, the behavior depends on the number of\r\narguments the setter declares:\r\n\r\n - If the setter _does not_ specify the `newValue` argument, the property value is set to the type converted value.\r\n - If the setter specifies the `newValue` argument only, the attribute value will be set to `undefined`.\r\n - If the setter specifies both `newValue` and `resolve`, the value of the property will not be\r\n   updated until `resolve` is called.\r\n\r\n\r"
    },
    "comment": " "
  },
  "can-define.types.value": {
    "src": {
      "path": "node_modules/can-define/docs/value.md"
    },
    "body": "\r\n\r\nThere is a third way to provide a default value, which is explained in the [can-define.types.ValueConstructor Value] docs page. `value` lowercased is for providing default values for a property type, while `Value` uppercased is for providing a constructor function, which will be invoked with `new` to create a default value for each instance of this map.\r\n\r\n```js\r\n// A default age of `0`:\r\nvar Person = DefineMap.extend({\r\n  age: {\r\n    value: 0\r\n  },\r\n  address: {\r\n    value: function(){\r\n      return {city: \"Chicago\", state: \"IL\"};\r\n    };\r\n  }\r\n});\r\n```\r\n\n",
    "description": "\r\nReturns the default value for instances of the defined type.  The default value is defined on demand, when the property\r\nis read for the first time.\r\n",
    "title": "value\r",
    "name": "can-define.types.value",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "value()",
        "description": "\n\r\nA function can be provided that returns the default value used for this property, like:\r\n\r\n```js\r\nprop: {\r\n  value: function(){ return []; }\r\n}\r\n```\r\n\r\n\r\nIf the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property `value` above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).\r\n\r",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The default value.  This will be passed through setter and type.\r\n\r"
        }
      },
      {
        "code": "value",
        "description": "\n\r\nAny value can be provided as the default value used for this property, like:\r\n\r\n```\r\nprop: {\r\n  value: 'foo'\r\n}\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "defaultVal",
            "description": "The default value, which will be passed through setter and type.\r\n\r"
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The default value.  This will be passed through setter and type.\r\n\r"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "defaultVal",
      "description": "The default value, which will be passed through setter and type.\r\n\r"
    },
    "comment": " "
  },
  "can-define/list/list": {
    "name": "can-define/list/list",
    "type": "module",
    "src": {
      "path": "node_modules/can-define/list/docs/define-list.md"
    },
    "body": "\r\n\r\n## Use\r\n\r\nThe `can-define/list/list` module exports a `DefineList` constructor function.  It can be used\r\nwith `new` to create observable lists that behave very similar to `Array`s.  For example:\r\n\r\n```js\r\nvar list = new DefineList([\"a\",\"b\", \"c\"]);\r\nlist[0] //-> \"a\";\r\n\r\nlist.push(\"x\");\r\nlist.pop() //-> \"x\"\r\n```\r\n\r\nIt can also be extended to define custom observable list types with\r\n[can-define/list/list.extend].  For example, the following defines a `StringList` type\r\nwhere every item is converted to a string by specifying the [can-define/list/list.prototype.wildcardItems items definition] `(#)`:\r\n\r\n```js\r\nvar StringList = DefineList.extend({\r\n\t\"#\": \"string\"\r\n});\r\n\r\nvar strings = new StringList([1,new Date(1475370478173),false]);\r\n\r\nstrings[0] //-> \"1\"\r\nstrings[1] //-> \"Sat Oct 01 2016 20:07:58 GMT-0500 (CDT)\"\r\nstrings[2] //-> \"false\"\r\n```\r\n\r\nNon-numeric properties can also be defined on custom DefineList type.  The following\r\ndefines a `completed` property that returns the completed todos:\r\n\r\n```js\r\nvar TodoList = DefineList.extend({\r\n\t\"#\": Todo,\r\n\tget completed(){\r\n\t\treturn this.filter({complete: true})\r\n\t}\r\n});\r\n\r\nvar todos = new TodoList([{complete: true}, {complete:false}]);\r\ntodos.completed.length //-> 1\r\n```\r\n\r\nFinally, DefineMap instances are observable, so you can use the [can-event]\r\nmethods to listen to its [can-define/list/list/AddEvent],\r\n[can-define/list/list/LengthEvent], [can-define/list/list/RemoveEvent],\r\nand [can-define/list/list/PropertyNameEvent] events:\r\n\r\n```js\r\nvar people = new DefineList([\"alice\",\"bob\",\"eve\"]);\r\n\r\npeople.on(\"add\", function(ev, items, index){\r\n\tconsole.log(\"add\", items, index);\r\n}).on(\"remove\", function(ev, items, index){\r\n\tconsole.log(\"remove\", items, index);\r\n}).on(\"length\", function(ev, newVal, oldVal){\r\n\tconsole.log(\"length\", newVal, oldVal);\r\n})\r\n\r\npeople.pop(); // remove [\"eve\"] 2\r\n              // length 2 3\r\n\r\npeople.unshift(\"Xerxes\"); // add [\"Xerxes\"] 1\r\n                          // length 3 2\r\n```\r\n\n",
    "description": "Create observable lists. \r\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-core",
    "alias": "can.DefineList",
    "inherits": "can.Construct",
    "signatures": [
      {
        "code": "new DefineList([items])",
        "description": "\n\r\nCreates an instance of a DefineList or an extended DefineList with enumerated properties from `items`.\r\n\r\n```js\r\nvar DefineList = require(\"can-define/list/list\");\r\n\r\nvar people = new DefineList([\r\n  { first: \"Justin\", last: \"Meyer\" },\r\n  { first: \"Paula\", last: \"Strozak\" }\r\n])\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "items",
            "description": "An array of items to seed the list with.\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "An instance of `DefineList` with the values from _items_.\r\n\r"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "items",
      "description": "An array of items to seed the list with.\r"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "An instance of `DefineList` with the values from _items_.\r\n\r"
    },
    "comment": " "
  },
  "can-define/list/list.static": {
    "src": {
      "line": 37,
      "codeLine": 38,
      "path": "node_modules/can-define/list/list.js"
    },
    "type": "static",
    "body": "",
    "description": "",
    "name": "can-define/list/list.static",
    "parent": "can-define/list/list",
    "title": "static"
  },
  "can-define/list/list.prototype": {
    "src": {
      "line": 56,
      "codeLine": 57,
      "path": "node_modules/can-define/list/list.js"
    },
    "type": "prototype",
    "body": "",
    "description": "",
    "name": "can-define/list/list.prototype",
    "parent": "can-define/list/list",
    "title": "prototype"
  },
  "can-define/list/list.prototype.get": {
    "type": "function",
    "name": "can-define/list/list.prototype.get",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 109,
      "codeLine": 163,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nGets an item or all items from a DefineList.\n",
    "title": "get",
    "signatures": [
      {
        "code": "list.get()",
        "description": "\n\nReturns the list converted into a plain JS array. Any items that also have a\n`get` method will have their `get` method called and the resulting value will be used as item value.\n\nThis can be used to recursively convert a list instance to an Array of other plain JavaScript objects.\nCycles are supported and only create one object.\n\n`get()` can still return other non-plain JS objects like Dates.\nUse [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.get() //-> [\"A\",\"B\"]\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "A plain JavaScript `Array` that contains each item in the list.\n"
        }
      },
      {
        "code": "list.get(index)",
        "description": "\n\nGets the item at `index`. `list.get(index)` should be used instead of\n`list[index]` if the list's items are going to be updated via [can-define/list/list.prototype.set list.set(index, value)]\n(as opposed to [can-define/list/list.prototype.splice] which is the better way).\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.get(1) //-> \"B\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "A numeric position in the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at index.\n"
        }
      },
      {
        "code": "list.get(prop)",
        "description": "\n\nGets the property at `prop` if it might not have already been defined.\n\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(\"count\",1000)\nlist.get(\"count\") //-> 1000\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "A property on the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at `prop`.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value at `prop`.\n\t "
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "prop",
      "description": "A property on the list.\n"
    }
  },
  "can-define/list/list.prototype.set": {
    "type": "function",
    "name": "can-define/list/list.prototype.set",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 171,
      "codeLine": 232,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nSets an item or property or items or properties on a list.\n",
    "title": "set",
    "signatures": [
      {
        "code": "list.set(prop, value)",
        "description": "\n\nSets the property at `prop`. This should be used when the property\nisn't already defined.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(\"count\",1000);\nlist.get(\"count\") //-> 1000;\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "prop",
            "description": "A property name."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to add to the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(newProps)",
        "description": "\n\nUpdates the properties on the list with `newProps`.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set({count: 1000, skip: 2});\nlist.get(\"count\") //-> 1000\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "newProps",
            "description": "An object of properties and values to set on the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(index, value)",
        "description": "\n\nSets the item at `index`.  Typically, [can-define/list/list::splice] should be used instead.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(2,\"C\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "A numeric position in the list."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to add to the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(newItems [,replaceAll])",
        "description": "\n\nReplaces items in the list with `newItems`\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set([\"c\"])        //-> DefineList[\"c\",\"B\"]\nlist.set([\"x\"], true)  //-> DefineList[\"x\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "newItems",
            "description": "Items used to replace existing items in the list."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "replaceAll",
            "description": "If true, will remove items at the end of the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance.\n\t "
    },
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "replaceAll",
      "description": "If true, will remove items at the end of the list."
    }
  },
  "can-define/list/list.prototype.splice": {
    "type": "function",
    "name": "can-define/list/list.prototype.splice",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 286,
      "codeLine": 331,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`splice` lets you remove elements from and insert elements into a DefineList.\n\nThis example demonstrates how to do surgery on a list of numbers:\n\n```\nvar list = new DefineList([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.get(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n## Events\n\n`splice` causes the DefineList it's called on to emit\n_add_ events, _remove_ events, and _length_ events. If there are\nany elements to remove, a _remove_ event, and a\n_length_ event will be fired. If there are any elements to insert, a\nseparate _add_ event, and a separate _length_ event\nwill be fired.\n\n\t \n",
    "description": "Insert and remove elements from a DefineList. ",
    "title": "splice",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newItems]])",
        "description": "\n\nRemoves `howMany` items at `index` and adds `newItems` in their place.\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "Where to start removing or inserting elements.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "The number of elements to remove\nIf _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the DefineList.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newItems",
            "description": "Items to insert into the DefineList\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "The elements removed by `splice`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newItems",
      "description": "Items to insert into the DefineList\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "The elements removed by `splice`.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.serialize": {
    "type": "function",
    "name": "can-define/list/list.prototype.serialize",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 380,
      "codeLine": 404,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nReturns the a serialized version of this list.\n",
    "title": "serialize",
    "signatures": [
      {
        "code": "list.serialize()",
        "description": "\n\nGoes through each item in the list and gets its serialized\nvalue and returns them in a plain Array.\n\nEach items serialized value is the result of calling `.serialize()`\non the item or if the item doesn't have a `serialize` method,\nthe item itself.\n\n```\nvar list = new DefineList([\"first\", {foo: \"bar\"}]);\nvar serializedList = list.serialize();\n\nserializedList //-> [\"first\", {foo: \"bar\"}]\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "An array with each item's serialied value.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "An array with each item's serialied value.\n\t "
    }
  },
  "can-define/list/list.prototype.push": {
    "name": "can-define/list/list.prototype.push",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 417,
      "codeLine": 467,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`push` adds elements onto the end of a DefineList here is an example:\n\n```\nvar list = new DefineList(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.get(); // ['Alice', 'Bob', 'Eve']\n```\n\nIf you have an array you want to concatenate to the end\nof the DefineList, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new DefineList(['Alice']);\n\nlist.push.apply(list, names);\nlist.get(); // ['Alice', 'Bob', 'Eve']\n```\n\n## Events\n\n`push` causes _add_, and _length_ events to be fired.\n\n## See also\n\n`push` has a counterpart in [can-define/list/list::pop pop], or you may be\nlooking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\n\t \n",
    "description": "Add elements to the end of a list. ",
    "title": "push",
    "signatures": [
      {
        "code": "list.push(...elements)",
        "description": "\n\n`push` adds elements onto the end of a DefineList.\n\n```\nvar names = new DefineList(['Alice']);\nnames.push('Bob', 'Eve');\nnames //-> DefineList['Alice','Bob', 'Eve']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the DefineList\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the DefineList\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the DefineList\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the DefineList\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.unshift": {
    "name": "can-define/list/list.prototype.unshift",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 468,
      "codeLine": 512,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n\n\nIf you have an array you want to concatenate to the beginning\nof the DefineList, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new DefineList(['Alice']);\n\nlist.unshift.apply(list, names);\nlist.get(); // ['Bob', 'Eve', 'Alice']\n```\n\n## Events\n\n`unshift` causes _add_ and _length_ events to be fired.\n\n## See also\n\n`unshift` has a counterpart in [can-define/list/list::shift shift], or you may be\nlooking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\n\t \n",
    "description": "Add items to the beginning of a DefineList. ",
    "title": "unshift",
    "signatures": [
      {
        "code": "list.unshift(...items)",
        "description": "\n\n`unshift` adds items onto the beginning of a DefineList.\n\n```\nvar list = new DefineList(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist; // DefineList['Bob', 'Eve', 'Alice']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "items",
            "description": "The items to add to the DefineList.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The new length of the DefineList.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "items",
      "description": "The items to add to the DefineList.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The new length of the DefineList.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.pop": {
    "name": "can-define/list/list.prototype.pop",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 550,
      "codeLine": 589,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`pop` is the opposite action from [can-define/list/list::push push]:\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined\n```\n\n## Events\n\n`pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\nwhen it is called.\n\n## See also\n\n`pop` has its counterpart in [can-define/list/list::push push], or you may be\nlooking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\n\t \n",
    "description": "Remove an element from the end of a DefineList. ",
    "title": "pop",
    "signatures": [
      {
        "code": "list.pop()",
        "description": "\n\n`pop` removes an element from the end of a DefineList.\n\n```js\nvar names = new DefineList(['Alice', 'Bob', 'Eve']);\nnames.pop() //-> 'Eve'\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The element just popped off the DefineList, or `undefined` if the DefineList was empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The element just popped off the DefineList, or `undefined` if the DefineList was empty\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.shift": {
    "name": "can-define/list/list.prototype.shift",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 590,
      "codeLine": 622,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`shift` is the opposite action from `[can-define/list/list::unshift unshift]`:\n\n## Events\n\n`pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\nwhen it is called.\n\n## See also\n\n`shift` has a counterpart in [can-define/list/list::unshift unshift], or you may be\nlooking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\n\t \n",
    "description": "Remove an item from the front of a list. ",
    "title": "shift",
    "signatures": [
      {
        "code": "list.shift()",
        "description": "\n\n`shift` removes an element from the beginning of a DefineList.\n\n```\nvar list = new DefineList(['Alice','Adam']);\nlist.shift(); //-> 'Alice'\nlist.shift(); //-> 'Adam'\nlist.shift(); //-> undefined\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The element just shifted off the DefineList, or `undefined` if the DefineList is empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The element just shifted off the DefineList, or `undefined` if the DefineList is empty\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.map": {
    "name": "can-define/list/list.prototype.map",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 658,
      "codeLine": 691,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Map the values in this list to another list. \n",
    "title": "map",
    "signatures": [
      {
        "code": "list.map(callback[, thisArg])",
        "description": "\n\nLoops through the values of the list, calling `callback` for each one until the list\nends.  The return values of `callback` are used to populate the returned list.\n\n```js\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar names = todos.map(function(todo){\n  return todo.name;\n});\nnames //-> DefineList[\"dishes\",\"lawn\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe three parameters that callback gets passed are:\n   - item (*) - the element at index.\n   - index (Integer) - the index of the current element of the list.\n   - list (DefineList) - the `DefineList` the elements are coming from.\n\nThe return value of `callback`, including `undefined` values are used to populate the resulting list.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "a new `DefineList` with the results of the map transform."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "a new `DefineList` with the results of the map transform."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.filter": {
    "name": "can-define/list/list.prototype.filter",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 692,
      "codeLine": 738,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nFilter a list to a new list of the matched items.\n",
    "title": "filter",
    "signatures": [
      {
        "code": "list.filter( callback [,thisArg] )",
        "description": "\n\nFilters `list` based on the return value of `callback`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\nvar aNames = names.filter(function(name){\n  return name[0] === \"a\"\n});\naNames //-> DefineList[\"alice\",\"adam\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can-define/list/list"
                      }
                    ],
                    "name": "list"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A\nfunction to call with each element of the DefineList. The three parameters that callback gets passed are:\n - item (*) - the element at index.\n - index (Integer) - the index of the current element of the list.\n - list (DefineList) - the `DefineList` the elements are coming from.\n\nIf `callback` returns a truthy result, `item` will be added to the result.  Otherwise, the `item` will be\nexcluded.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "thisArg",
            "description": "What `this` should be in the `callback`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A new instance of this `DefineList` (may be a subclass), containing the items that passed the filter.\n"
        }
      },
      {
        "code": "list.filter( props )",
        "description": "\n\nFilters items in `list` based on the property values in `props`.\n\n```\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar complete = todos.filter({complete: true});\ncomplete //-> DefineList[{name: \"lawn\", complete: true}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to be in the returned list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A new `DefineList` of the same type.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A new `DefineList` of the same type.\n "
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to be in the returned list."
    }
  },
  "can-define/list/list.prototype.reduce": {
    "name": "can-define/list/list.prototype.reduce",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 739,
      "codeLine": 777,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Map the values in this list to a single value \n",
    "title": "reduce",
    "signatures": [
      {
        "code": "list.reduce(callback, initialValue, [, thisArg])",
        "description": "\n\nLoops through the values of the list, calling `callback` for each one until the list\nends.  The return value of `callback` is passed to the next iteration as the first argument, \nand finally returned by `reduce`.\n\n```js\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar todosAsOneObject = todos.reduce(function(todos, todo){\n  todos[todo.name] = todo.complete;\n  return todos;\n}, {});\ntodosAsOneObject //-> { dishes: false, lawn: true }\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe four parameters that callback gets passed are:\n   - current (*) - the current aggregate value of reducing over the list -- the initial value if the first iteration\n   - item (*) - the element at index.\n   - index (Integer) - the index of the current element of the list.\n   - list (DefineList) - the `DefineList` the elements are coming from.\n\nThe return value of `callback` is passed to the next iteration as the first argument, and returned from \n`reduce` if the last iteration.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "initialValue",
            "description": "The initial value to use as `current` in the first iteration"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The result of the final call of `callback` on the list."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The result of the final call of `callback` on the list."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.reduceRight": {
    "name": "can-define/list/list.prototype.reduceRight",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 778,
      "codeLine": 816,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Map the values in this list to a single value from right to left \n",
    "title": "reduceRight",
    "signatures": [
      {
        "code": "list.reduceRight(callback, initialValue, [, thisArg])",
        "description": "\n\nLoops through the values of the list in reverse order, calling `callback` for each one until the list\nends.  The return value of `callback` is passed to the next iteration as the first argument, \nand finally returned by `reduce`.\n\n```js\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar todosAsOneObject = todos.reduce(function(todos, todo){\n  todos[todo.name] = todo.complete;\n  return todos;\n}, {});\ntodosAsOneObject //-> { dishes: false, lawn: true }\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe four parameters that callback gets passed are:\n   - current (*) - the current aggregate value of reducing over the list -- the initial value if the first iteration\n   - item (*) - the element at index.\n   - index (Integer) - the index of the current element of the list.\n   - list (DefineList) - the `DefineList` the elements are coming from.\n\nThe return value of `callback` is passed to the next iteration as the first argument, and returned from \n`reduce` if the last iteration.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "initialValue",
            "description": "The initial value to use as `current` in the first iteration"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The result of the final call of `callback` on the list."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The result of the final call of `callback` on the list."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.every": {
    "name": "can-define/list/list.prototype.every",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 817,
      "codeLine": 865,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nReturn true if every item in a list matches a predicate.\n",
    "title": "every",
    "signatures": [
      {
        "code": "list.every( callback [,thisArg] )",
        "description": "\n\nTests each item in `list` by calling `callback` on it.  If `callback` returns truthy for every element in\n`list`, `every` returns `true`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\nvar aNames = names.every(function(name){\n  return name[0] === \"a\"\n});\naNames //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can-define/list/list"
                      }
                    ],
                    "name": "list"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A\nfunction to call with each element of the DefineList. The three parameters that callback gets passed are:\n - item (*) - the element at index.\n - index (Integer) - the index of the current element of the list.\n - list (DefineList) - the `DefineList` the elements are coming from.\n\nIf `callback` returns a truthy result, `every` will evaluate the callback on the next element.  Otherwise, `every`\nwill return `false`.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "thisArg",
            "description": "What `this` should be in the `callback`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if calling the callback on every element in `list` returns a truthy value, `false` otherwise.\n"
        }
      },
      {
        "code": "list.every( props )",
        "description": "\n\nTests each item in `list` by comparing its properties to `props`.  If `props` match for every element in\n`list`, `every` returns `true`.\n\n```\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar complete = todos.every({complete: true});\ncomplete //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to match."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if every element in `list` matches `props`, `false` otherwise\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if every element in `list` matches `props`, `false` otherwise\n "
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to match."
    }
  },
  "can-define/list/list.prototype.some": {
    "name": "can-define/list/list.prototype.some",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 866,
      "codeLine": 914,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nReturn true if at least one item in a list matches a predicate.\n",
    "title": "some",
    "signatures": [
      {
        "code": "list.some( callback [,thisArg] )",
        "description": "\n\nTests each item in `list` by calling `callback` on it.  If `callback` returns truthy for some element in\n`list`, `some` returns `true`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\nvar aNames = names.some(function(name){\n  return name[0] === \"a\"\n});\naNames //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can-define/list/list"
                      }
                    ],
                    "name": "list"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A\nfunction to call with each element of the DefineList. The three parameters that callback gets passed are:\n - item (*) - the element at index.\n - index (Integer) - the index of the current element of the list.\n - list (DefineList) - the DefineList the elements are coming from.\n\nIf `callback` returns a falsy result, `some` will evaluate the callback on the next element.  Otherwise, `some`\nwill return `true`.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "thisArg",
            "description": "What `this` should be in the `callback`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`false` if calling the callback on some element in `list` returns a falsy value, `true` otherwise.\n"
        }
      },
      {
        "code": "list.some( props )",
        "description": "\n\nTests each item in `list` by comparing its properties to `props`.  If `props` match for some element in\n`list`, `some` returns `true`.\n\n```\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar complete = todos.some({complete: true});\ncomplete //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to match."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`false` if every element in `list` fails to match `props`, `true` otherwise\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`false` if every element in `list` fails to match `props`, `true` otherwise\n "
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to match."
    }
  },
  "can-define/list/list.prototype.indexOf": {
    "type": "function",
    "name": "can-define/list/list.prototype.indexOf",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 949,
      "codeLine": 969,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Look for an item in a DefineList. ",
    "title": "indexOf",
    "signatures": [
      {
        "code": "list.indexOf(item)",
        "description": "\n\n`indexOf` finds the position of a given item in the DefineList.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "The item to find.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "The item to find.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.lastIndexOf": {
    "type": "function",
    "name": "can-define/list/list.prototype.lastIndexOf",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 978,
      "codeLine": 998,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Look for an item in a DefineList starting from the end. ",
    "title": "lastIndexOf",
    "signatures": [
      {
        "code": "list.lastIndexOf(item)",
        "description": "\n\n`lastIndexOf` finds the last position of a given item in the DefineList.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Alice', 'Eve']);\nlist.lastIndexOf('Alice');   // 2\nlist.lastIndexOf('Charlie'); // -1\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "The item to find.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "The item to find.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.join": {
    "type": "function",
    "name": "can-define/list/list.prototype.join",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1008,
      "codeLine": 1026,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "",
    "description": "Join a DefineList's elements into a string. ",
    "title": "join",
    "signatures": [
      {
        "code": "list.join(separator)",
        "description": "\n\n`join` turns a DefineList into a string by inserting _separator_ between the string representations\nof all the elements of the DefineList.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "separator",
            "description": "The string to seperate elements.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The joined string.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "separator",
      "description": "The string to seperate elements.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The joined string.\n\n "
    }
  },
  "can-define/list/list.prototype.reverse": {
    "type": "function",
    "name": "can-define/list/list.prototype.reverse",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1031,
      "codeLine": 1051,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Reverse the order of a DefineList. ",
    "title": "reverse",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\nReverses the elements of the DefineList in place.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList; //-> DefineList['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The DefineList, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The DefineList, for chaining.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.slice": {
    "type": "function",
    "name": "can-define/list/list.prototype.slice",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1057,
      "codeLine": 1091,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`slice` is the simplest way to copy a DefineList:\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy           //-> DefineList['Alice', 'Bob', 'Eve']\nlist === copy; //-> false\n```\n \n",
    "description": "Make a copy of a part of a DefineList. ",
    "title": "slice",
    "signatures": [
      {
        "code": "list.slice([start[, end]])",
        "description": "\n\n`slice` creates a copy of a portion of the DefineList.\n\n```js\nvar list = new DefineList(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList //-> DefineList['Bob', 'Charlie', 'Daniel']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "start",
            "defaultValue": "0",
            "description": "The index to start copying from. Defaults to `0`.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "end",
            "description": "The first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A new `DefineList` with the extracted elements.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "end",
      "description": "The first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A new `DefineList` with the extracted elements.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.concat": {
    "type": "function",
    "name": "can-define/list/list.prototype.concat",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1098,
      "codeLine": 1128,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`concat` makes a new DefineList with the elements of the DefineList followed by the elements of the parameters.\n\n```\nvar list = new DefineList();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new DefineList(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.get(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n```\n \n",
    "description": "Merge many collections together into a DefineList. ",
    "title": "concat",
    "signatures": [
      {
        "code": "list.concat(...args)",
        "description": "\n\nReturns a `DefineList` with the `list`'s items and the additional `args`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can-define/list/list"
              },
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a DefineList, each of its elements will be added to\nthe end of the concatenated DefineList. Otherwise, the parameter itself will be added.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A DefineList of the same type.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can-define/list/list"
        },
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a DefineList, each of its elements will be added to\nthe end of the concatenated DefineList. Otherwise, the parameter itself will be added.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A DefineList of the same type.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.forEach": {
    "type": "function",
    "name": "can-define/list/list.prototype.forEach",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1154,
      "codeLine": 1190,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`forEach` calls a callback for each element in the DefineList.\n\n```\nvar list = new DefineList([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.get(index, element * element);\n});\nlist.get(); // [1, 4, 9]\n```\n \n",
    "description": "Call a function for each element of a DefineList. ",
    "title": "forEach",
    "signatures": [
      {
        "code": "list.forEach(callback[, thisArg])",
        "description": "\n\nLoops through the values of the list, calling `callback` for each one until the list ends\nor `false` is returned.\n\n```\nlist.forEach(function(item, index, list){ ... })\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe three parameters that callback gets passed are:\n   - item - the element at index.\n   - index - the current element of the list.\n   - list - the DefineList the elements are coming from.\n\nIf the callback returns `false` the looping stops.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.replace": {
    "type": "function",
    "name": "can-define/list/list.prototype.replace",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1201,
      "codeLine": 1227,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`replace` is essentially a shortcut for [can-define/list/list.prototype.splice].\n\n## Events\n\n`replace` causes _remove_, _add_, and _length_ events.\n \n",
    "description": "Replace all the elements of a DefineList. ",
    "title": "replace",
    "signatures": [
      {
        "code": "list.replace(collection)",
        "description": "\n\nReplaces every item in the list with `collection`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"eve\"]);\nnames.replace([\"Justin\",\"Xena\"]);\nnames //-> DefineList[\"Justin\",\"Xena\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can-define/list/list"
              }
            ],
            "name": "collection",
            "description": "The collection of items that will be in `list`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "Returns the `list`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can-define/list/list"
        }
      ],
      "name": "collection",
      "description": "The collection of items that will be in `list`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "Returns the `list`.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.sort": {
    "type": "function",
    "name": "can-define/list/list.prototype.sort",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1241,
      "codeLine": 1285,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "```\n \n",
    "description": "Sort the properties of a list. \n",
    "title": "sort",
    "signatures": [
      {
        "code": "list.sort([compareFunction])",
        "description": "\n\nSorts the elements of a list in place and returns the list. The API is the\nsame as the native JavaScript `Array.prototype.sort` API.\n\n```js\nvar accounts = new Account.List([\n  { name: \"Savings\", amount: 20.00 },\n  { name: \"Checking\", amount: 103.24 },\n  { name: \"Kids Savings\", amount: 48155.13 }\n]);\naccounts.sort(function(a, b){\n  if (a.name < b.name) {\n    return -1;\n  } else if (a.name > b.name){\n    return 1;\n  } else {\n    return 0;\n  }\n});\naccounts[0].name === \"Checking\"\naccounts[1].name === \"Kids Savings\"\naccounts[2].name === \"Savings\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "a"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "b"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "compareFunction",
            "description": "Specifies a function that defines the sort order.\n\nIf `compareFunction` is supplied, the list elements are sorted according to the return\nvalue of the compare function. If `a` and `b` are two elements being compared, then:\n\n - If `compareFunction(a, b)` returns a value less than 0, `a` will be sorted to\n a lower index than `b`, so `a` will now come first.\n - If `compareFunction(a, b)` returns 0, the order of the two values will not be changed.\n - If `compareFunction(a, b)` returns a value greater than 0, `a` will be sorted to\n a higher index than `b`, so `b` will now come first.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "a"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "b"
                }
              ]
            }
          ]
        }
      ],
      "name": "compareFunction",
      "description": "Specifies a function that defines the sort order.\n\nIf `compareFunction` is supplied, the list elements are sorted according to the return\nvalue of the compare function. If `a` and `b` are two elements being compared, then:\n\n - If `compareFunction(a, b)` returns a value less than 0, `a` will be sorted to\n a lower index than `b`, so `a` will now come first.\n - If `compareFunction(a, b)` returns 0, the order of the two values will not be changed.\n - If `compareFunction(a, b)` returns a value greater than 0, `a` will be sorted to\n a higher index than `b`, so `b` will now come first.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance."
    },
    "comment": " "
  },
  "can-define/map/map.prototype.get": {
    "type": "function",
    "name": "can-define/map/map.prototype.get",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 129,
      "codeLine": 167,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Get a value or all values from a DefineMap. \n",
    "title": "get",
    "signatures": [
      {
        "code": "map.get()",
        "description": "\n\nReturns a plain JavaScript object that contains the properties and values of the map instance.  Any property values\nthat also have a `get` method will have their `get` method called and the resulting value will be used as\nthe property value.  This can be used to recursively convert a map instance to an object of other plain\nJavaScript objects.  Cycles are supported and only create one object.\n\n`.get()` can still return other non plain JS objects like Date.\nUse [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\n\n```js\nvar map = new DefineMap({foo: new DefineMap({bar: \"zed\"})});\nmap.get() //-> {foo: {bar: \"zed\"}};\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A plain JavaScript `Object` that contains all the properties and values of the map instance.\n"
        }
      },
      {
        "code": "map.get(propName)",
        "description": "\n\nGet a single property on a DefineMap instance.\n\n`.get(propName)` only should be used when reading properties that might not have been defined yet, but\nwill be later via [can-define/map/map.prototype.set].\n\n```js\nvar map = new DefineMap();\nmap.get(\"name\") //-> undefined;\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "The property name of a property that may not have been defined yet."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of that property.\n  "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of that property.\n  "
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "propName",
      "description": "The property name of a property that may not have been defined yet."
    }
  },
  "can-define/map/map.prototype.set": {
    "type": "function",
    "name": "can-define/map/map.prototype.set",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 181,
      "codeLine": 209,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Sets multiple properties on a map instance or a property that wasn't predefined. \n",
    "title": "set",
    "signatures": [
      {
        "code": "map.set(props [,removeProps])",
        "description": "\n\nAssigns each value in `props` to a property on this map instance named after the\ncorresponding key in `props`, effectively merging `props` into the Map. If `removeProps` is true, properties not in\n`props` will be set to `undefined`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "removeProps",
            "defaultValue": "false",
            "description": "Whether to set keys not present in `props` to `undefined`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\n"
        }
      },
      {
        "code": "map.set(propName, value)",
        "description": "\n\nAssigns _value_ to a property on this map instance called _propName_.  This will define\nthe property if it hasn't already been predefined.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "The property to set."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign to `propName`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "This map instance, for chaining.\n  "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "This map instance, for chaining.\n  "
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value to assign to `propName`."
    }
  },
  "can-define/map/map.prototype.serialize": {
    "type": "function",
    "name": "can-define/map/map.prototype.serialize",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 219,
      "codeLine": 251,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Get a serialized representation of the map instance and its children. \n",
    "title": "serialize",
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n\nGet the serialized Object form of the map.  Serialized\ndata is typically used to send back to a server.  Use [can-define.types.serialize]\nto customize a property's serialized value or if the property should be added to\nthe result or not.\n\n`undefined` serialized values are not added to the result.\n\n```js\nvar MyMap = DefineMap.extend({\n  date: {\n    type: \"date\",\n    serialize: function(date){\n      return date.getTime()\n    }\n  }\n});\n\nvar myMap = new MyMap({date: new Date(), count: 5});\nmyMap.serialize() //-> {date: 1469566698504, count: 5}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A JavaScript Object that can be serialized with `JSON.stringify` or other methods.\n\n  "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A JavaScript Object that can be serialized with `JSON.stringify` or other methods.\n\n  "
    }
  },
  "can-define-stream.types": {
    "name": "can-define-stream.types",
    "title": "types",
    "type": "group",
    "parent": "can-define-stream",
    "description": "",
    "order": 3
  },
  "can-define-stream.fns": {
    "name": "can-define-stream.fns",
    "title": "DefineMap methods",
    "type": "group",
    "parent": "can-define-stream",
    "description": "",
    "order": 4
  },
  "can-define-stream": {
    "src": {
      "path": "node_modules/can-define-stream/docs/can-define-stream.md"
    },
    "body": "\n## Use\n\nThe [can-define-stream.toStream] method has shorthands for all of the other methods:\n\n```js\ntoStream(compute)                    //-> stream\ntoStream(map, \"eventName\")           //-> stream\ntoStream(map, \".propName\")           //-> stream\ntoStream(map, \".propName eventName\") //-> stream\n```\n\nFor example:\n\n__Update map property based on stream value__\n\n```js\nvar canStream = require(\"can-stream-kefir\");\nvar canDefineStream = require(\"can-define-stream\");\n\nvar Person = DefineMap.extend({\n    name: \"string\",\n    lastValidName: {\n        stream: function() {\n            return this.toStream(\".name\").filter(function(name) { // using propName\n                return name.indexOf(\" \") >= 0;\n            });\n        }\n    }\n});\n\ncanDefineStream(canStream)(Person);\n\nvar me = new Person({name: \"James\"});\n\nme.on(\"lastValidName\", function(lastValid) {});\n\nme.name = \"JamesAtherton\"; //lastValidName -> undefined\nme.name = \"James Atherton\"; //lastValidName -> James Atherton\n```\n\n__Stream on DefineList__\n\n```js\nvar canStream = require(\"can-stream-kefir\");\nvar canDefineStream = require(\"can-define-stream\");\n\nvar PeopleList = DefineList.extend({});\n\ncanDefineStream(canStream)(PeopleList);\n\nvar people = new PeopleList([\n    { first: \"Justin\", last: \"Meyer\" },\n    { first: \"Paula\", last: \"Strozak\" }\n]);\n\nvar stream = people.toStream('length'); // using eventName\n\nstream.onValue(function(val) {\n    val //-> 2, 3\n});\n\npeople.push({\n    first: 'Obaid',\n    last: 'Ahmed'\n}); //-> stream.onValue -> 3\n```\n\n",
    "description": "Add useful stream conversion methods to a supplied [can-define/map/map] or [can-define/list/list] constructor using a [can-define-stream.types.streamInterface stream interface] such as [can-stream-kefir]. \n",
    "type": "module",
    "title": "can-define-stream",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-stream",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-define-stream/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-define": "^1.0.0",
        "can-observation": "^3.0.0",
        "can-stream": "^0.2.1",
        "can-util": "^3.0.0",
        "kefir": "^3.5.1"
      },
      "description": "Adds the ability to define properties with streams on can-define types.",
      "devDependencies": {
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-define-stream",
      "name": "can-define-stream",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-define-stream.git"
      },
      "scripts": {
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git push",
        "preversion": "npm test",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "0.1.1"
    },
    "signatures": [
      {
        "code": "canDefineStream(streamInterface)",
        "description": "\n\nThe `can-define-stream` module exports a function that takes a [can-define-stream.types.streamInterface] and returns a function that takes a [can-define-stream.types.DefineMap DefineMap.prototype] or [can-define-stream.types.DefineList DefineList.prototype] and uses the supplied stream interface to create streamed property definitions.\n\n```js\nvar canStream = require(\"can-stream-kefir\");\nvar canDefineStream = require(\"can-define-stream\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Person = DefineMap.extend({\n    first: \"string\",\n    last: \"string\",\n    fullName: {\n        get: function() {\n            return this.first + \" \" + this.last;\n        }\n    },\n    fullNameChangeCount: {\n        stream: function() {\n            return this.toStream(\".fullName\").scan(function(last) {\n                return last + 1;\n            }, 0);\n        }\n    }\n});\n\ncanDefineStream(canStream)(Person);\n\nvar me = new Person({name: \"Justin\", last: \"Meyer\"});\n\nme.on(\"fullNameChangeCount\", function(ev, newVal) {\n    console.log(newVal);\n});\nme.fullNameChangeCount //-> 0\nme.first = \"Obaid\"; //-> console.logs 1\nme.last = \"Ahmed\"; //-> console.logs 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-define-stream.types.streamInterface"
              }
            ],
            "name": "streamInterface",
            "description": "A [can-define-stream.types.streamInterface] function. See [can-stream-kefir] for implementation.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function that takes a [can-define-stream.types.DefineMap DefineMap.prototype] or [can-define-stream.types.DefineList DefineList.prototype].\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-define-stream.types.streamInterface"
        }
      ],
      "name": "streamInterface",
      "description": "A [can-define-stream.types.streamInterface] function. See [can-stream-kefir] for implementation.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function that takes a [can-define-stream.types.DefineMap DefineMap.prototype] or [can-define-stream.types.DefineList DefineList.prototype].\n"
    },
    "comment": " "
  },
  "can-define-stream.tocompute": {
    "src": {
      "path": "node_modules/can-define-stream/docs/methods.toCompute.md"
    },
    "body": "\n",
    "description": "Creates a compute that gets updated whenever the stream value changes. \n",
    "title": "toCompute",
    "name": "can-define-stream.tocompute",
    "type": "function",
    "parent": "can-define-stream.fns",
    "signatures": [
      {
        "code": "canStream.toCompute( stream )",
        "description": "\n\nCreates a compute that gets updated whenever the stream value changes.s\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stream"
              }
            ],
            "name": "a",
            "description": "streams\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A [can-compute] compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stream"
        }
      ],
      "name": "a",
      "description": "streams\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A [can-compute] compute.\n"
    }
  },
  "can-define-stream.toStream": {
    "src": {
      "path": "node_modules/can-define-stream/docs/methods.toStream.md"
    },
    "body": "",
    "description": "Creates a stream based on [can-compute] compute \n",
    "title": "toStream",
    "name": "can-define-stream.toStream",
    "type": "function",
    "parent": "can-define-stream.fns",
    "signatures": [
      {
        "code": "canStream.toStream( propAndOrEvent )",
        "description": "\n\nCreates a stream that gets updated whenever the property value changes or event is triggered.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "an",
            "description": "event or property name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [can-stream](https://github.com/canjs/can-stream) stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "an",
      "description": "event or property name\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [can-stream](https://github.com/canjs/can-stream) stream.\n"
    }
  },
  "can-define-stream.tostreamfromevent": {
    "src": {
      "path": "node_modules/can-define-stream/docs/methods.toStreamFromEvent.md"
    },
    "body": "\n",
    "description": "Creates a stream based on event \n",
    "title": "toStreamFromEvent",
    "name": "can-define-stream.tostreamfromevent",
    "type": "function",
    "parent": "can-define-stream.fns",
    "signatures": [
      {
        "code": "canStream.toStreamFromEvent( eventName )",
        "description": "\n\nCreates a stream from a that gets updated whenever the event is triggered.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "an",
            "description": "event name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [can-stream](https://github.com/canjs/can-stream) stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "an",
      "description": "event name\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [can-stream](https://github.com/canjs/can-stream) stream.\n"
    }
  },
  "can-define-stream.tostreamfromproperty": {
    "src": {
      "path": "node_modules/can-define-stream/docs/methods.toStreamFromProperty.md"
    },
    "body": "\n",
    "description": "Creates a stream based on property \n",
    "title": "toStreamFromProperty",
    "name": "can-define-stream.tostreamfromproperty",
    "type": "function",
    "parent": "can-define-stream.fns",
    "signatures": [
      {
        "code": "canStream.toStreamFromProperty( property )",
        "description": "\n\nCreates a stream from a that gets updated whenever the property value changes.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "a",
            "description": "property name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [can-stream](https://github.com/canjs/can-stream) stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "a",
      "description": "property name\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [can-stream](https://github.com/canjs/can-stream) stream.\n"
    }
  },
  "can-define-stream.types.DefineList": {
    "src": {
      "path": "node_modules/can-define-stream/docs/types.DefineList.prototype.md"
    },
    "body": "\n## Use\n\nSee: [can-define/list/list] and the related [can-define/list/list.extend] method.\n\n",
    "description": "A [can-define/list/list] constructor to add stream methods to. \n",
    "type": "typedef",
    "title": "DefineList.prototype",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-stream.types.DefineList",
    "parent": "can-define-stream.types",
    "signatures": [
      {
        "code": "new DefineList([items])",
        "description": "\n\nCreates a DefineList type instance\n\n```js\nimport DefineMap from 'can-define/map/map';\nimport DefineList from 'can-define/list/list';\n\nvar People = DefineList.extend([\n\t'#': {\n\t\ttype: {\n\t\t\tfirst: 'string',\n\t\t\tlast: 'string'\n\t\t}\n\t}\n]);\n\nvar people = new People([\n\t{ first: 'John', last: 'Gardner' },\n\t{ first: 'Justin', last: 'Meyer' }\n])\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define-stream.types.DefineMap": {
    "src": {
      "path": "node_modules/can-define-stream/docs/types.DefineMap.prototype.md"
    },
    "body": "\n## Use\n\nSee: [can-define/map/map] and [can-define/map/map.extend]\n\n",
    "description": "A [can-define/map/map] constructor to add stream methods to. \n",
    "type": "typedef",
    "title": "DefineMap.prototype",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-stream.types.DefineMap",
    "parent": "can-define-stream.types",
    "signatures": [
      {
        "code": "new DefineMap({props})",
        "description": "\n\nCreates a DefineMap type instance\n\n```js\nimport DefineMap from 'can-define/map/map';\n\nvar Person = DefineMap.extend({\n\tfirst: 'string',\n\tlast: 'string',\n\tfullName: {\n\t\tget() {\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n});\n\nvar john = new Person({\n\tfirst: 'John',\n\tlast: 'Gardner'\n});\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define-stream.types.streamInterface": {
    "src": {
      "path": "node_modules/can-define-stream/docs/types.streamInterface.md"
    },
    "body": "\n## Use\n\nSee [can-stream.types.streamInterface].\n\nSee [can-stream-kefir] for an example implementation.\n\n",
    "description": "A [can-stream.types.streamInterface] function. \n",
    "type": "typedef",
    "title": "streamInterface",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-stream.types.streamInterface",
    "parent": "can-define-stream.types",
    "signatures": [
      {
        "code": "streamInterface(observable, propAndOrEvent[,event])",
        "description": "\n\nThe stream interface function returned from [can-stream] that will be used to add streamable props to a provided [can-define-stream.types.DefineMap DefineMap.prototype] or [can-define-stream.types.DefineList DefineList.prototype] and has the following property methods:\n\n- .toStream(observable, propAndOrEvent[,event])\n- .toStreamFromProperty(property)\n- .toStreamFromEvent(property)\n- .toCompute([can-stream.types.makeStream makeStream(setStream)], context):compute\n\n```js\nimport DefineMap from 'can-define/map/map';\nimport canDefineStream from 'can-define-stream';\nimport streamInterface from 'can-stream-kefir';\n\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\",\n\tfullName: {\n\t\t\tget: function() {\n\t\t\t\t\treturn this.first + \" \" + this.last;\n\t\t\t}\n\t}\n});\n\nvar john = new Person({ first: 'John' });\njohn.toStream('.first'); //-> Error (toStream doesn't exist)\n\nvar defineStreamAdder = canDefineStream(streamInterface);\ndefineStreamAdder(Person);\n\nvar justin = new Person({ first: 'Justin' });\njustin.toStream('.first'); //-> Stream\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define-validate-validatejs.defineMap": {
    "name": "can-define-validate-validatejs.defineMap",
    "title": "DefineMap.prototype",
    "type": "group",
    "parent": "can-define-validate-validatejs",
    "description": "",
    "order": 0
  },
  "can-define-validate-validatejs": {
    "src": {
      "path": "node_modules/can-define-validate-validatejs/docs/can-define-validate-validatejs.md"
    },
    "body": "\n## Usage\n\nAny validation properties must match the structure used by Validate.JS [constraints](https://validatejs.org/#validators).\n\nFor example...\n```js\nvar User = DefineMap.extend({\n    name: {\n        validate: {\n            presence: true\n        }\n    }\n});\n```\n\nInitialize the validators on the Define Map by calling the `defineValidate` function.\n\n```js\ndefineValidate(User);\n```\n\nWhen an instance is created, the instance will have validation properties that can be used in other modules or in templates\n\nIn a module...\n```js\nvar user = new User();\n\nvar onSubmit = function () {\n    if (user.errors()) {\n        alert('Cannot continue, please check form for errors');\n    }\n}\n```\n\nIn a template...\n```html\n<input type=\"submit\" {$disabled}=\"user.errors()\"/>\n```\n\n## Demo\n\n<div class='demo_wrapper' data-demo-src='demos/can-validate/credit-card.html'></div>\n\n",
    "description": "Adds validation methods and observables to a [can-define/map/map] using [validate.js](https://validatejs.org/).\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define-validate-validatejs",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "browser": {},
      "bugs": {
        "url": "https://github.com/canjs/can-define-validate-validatejs/issues"
      },
      "dependencies": {
        "can-define": "^1.0.15",
        "can-util": "^3.2.2",
        "can-validate": "^1.0.2",
        "can-validate-validatejs": "^0.0.6"
      },
      "description": "Validation helpers for can-define maps and lists.",
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "can-compute": "^3.0.5",
        "http-server": "^0.9.0",
        "jshint": "^2.9.4",
        "steal": "^1.0.8",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.3.0"
      },
      "homepage": "https://github.com/canjs/can-define-validate-validatejs",
      "keywords": [
        "Validate",
        "plugin",
        "canjs"
      ],
      "license": "MIT",
      "main": "can-define-validate-validatejs.js",
      "name": "can-define-validate-validatejs",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-define-validate-validatejs.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "http-server -c-1",
        "document": "bit-docs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:pre": "npm version prerelease && npm run build && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "ignoreBrowser": true,
        "npmIgnore": [
          "documentjs",
          "testee",
          "steal-tools"
        ],
        "npmAlgorithm": "flat",
        "npmDependencies": [
          "steal-qunit"
        ],
        "transpiler": "babel"
      },
      "version": "0.0.5"
    },
    "signatures": [
      {
        "code": "defineValidate(Map)",
        "description": "\n\n  Checks for ValidateJS constraints and attaches useful methods.\n\n  ```js\n  var defineValidate = require('can-define-validate-validatejs');\n  var User = DefineMap.extend({\n      name: {\n          validate: {\n              presence: true\n          }\n      }\n  });\n  // Attach methods to any instance created of `User`\n  defineValidate(User);\n  var user = new User();\n  user.errors();//-> [{name: ['is required']}]\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "Map",
            "description": "The [can-define/map/map] constructor. Adds [can-define-validate-validatejs.errors] and [can-define-validate-validatejs.test-set] methods to the prototype of this map.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "Map",
      "description": "The [can-define/map/map] constructor. Adds [can-define-validate-validatejs.errors] and [can-define-validate-validatejs.test-set] methods to the prototype of this map.\n"
    },
    "comment": " "
  },
  "can-define-validate-validatejs.errors": {
    "src": {
      "path": "node_modules/can-define-validate-validatejs/docs/errors.md"
    },
    "body": "\n",
    "description": "\nThe `errors` method retrieves errors from validator.\n",
    "title": "errors",
    "name": "can-define-validate-validatejs.errors",
    "type": "function",
    "parent": "can-define-validate-validatejs.defineMap",
    "signatures": [
      {
        "code": "errors()",
        "description": "\n\n  Returns all errors for the current map instance.\n\n  ```js\n  var Person = new DefineMap({\n      name: {\n          validate: {\n              presence: true\n          }\n      }\n  });\n  var person = new Person();\n  person.errors();\n  //-> [{message: \"is required\", related: \"name\"}]\n  ```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-validate.errors"
            }
          ],
          "description": "Will return `undefined` if map is valid.\nOtherwise, will return an array of [can-validate/types/errors].\n"
        }
      },
      {
        "code": "map.errors(...propName)",
        "description": "\n\n  Returns errors for the specified keys from current map instance.\n\n  ```js\n  var Person = new DefineMap({\n      name: {\n          validate: {\n              presence: true\n          }\n      }\n      age: {\n          validate: {\n              presence: true,\n              numericality: true\n          }\n      }\n  });\n  var person = new Person();\n  person.errors('name');\n  //-> [{message: \"is required\", related: \"name\"}]\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "string"
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "propName",
            "description": "The property key to retrieve errors for.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-validate.errors"
            }
          ],
          "description": "Will return `undefined` if map is valid.\nOtherwise, will return an array of [can-validate/types/errors].\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-validate.errors"
        }
      ],
      "description": "Will return `undefined` if map is valid.\nOtherwise, will return an array of [can-validate/types/errors].\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "string"
                }
              ]
            }
          ]
        }
      ],
      "optional": true,
      "name": "propName",
      "description": "The property key to retrieve errors for.\n"
    }
  },
  "can-define-validate-validatejs.testSet": {
    "src": {
      "path": "node_modules/can-define-validate-validatejs/docs/test-set.md"
    },
    "body": "\n\n## Usage\n\nWith the exception of calling `testSet` with no arguments, `testSet` is called on a copy of the map instance, this is to prevent errors from\nbeing set on the map instance when using `testSet`. This means that errors returned are a result of the values provided through arguments being merged with the existing values.\n\nThis behavior can be controlled when testing multiple values by passing `true` for `useNewInstance`. This will test values with a new instance of the map constructor, allowing better control of what values are tested.\n\n```javascript\nmap.testSet({name: '', age: 100}, true);\n```\n\n",
    "description": "\nTests value changes against constraints. Does not set errors on map instance.\n",
    "title": "testSet",
    "name": "can-define-validate-validatejs.testSet",
    "type": "function",
    "parent": "can-define-validate-validatejs.defineMap",
    "signatures": [
      {
        "code": "testSet()",
        "description": "\n\n  Calls validator on the current values of a [can-define/map/map]. This is essentially the same as\n  calling `errors()`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-validate.errors"
            }
          ],
          "description": "Will return `undefined` if map is valid.\nOtherwise, will return an array of [can-validate/types/errors].\n\n```js\n  var Person = new DefineMap({\n      name: {\n          validate: {\n              presence: true\n          }\n      }\n  });\n  var person = new Person();\n  person.testSet();\n  // returns: [{message: \"is required\", related: \"name\"}]\n```\n"
        }
      },
      {
        "code": "map.testSet(keyName, value)",
        "description": "\n\n  Changes `keyName`'s value in the map instance clone. Then checks if the object is valid.\n  ```js\n  var Person = new DefineMap({\n  name: {\n      validate: {\n          presence: true\n      }\n  }\n  });\n  var person = new Person({name: 'Juan'});\n  person.testSet('name', '');\n  //=> [{message: \"is required\", related: \"name\"}]\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "string"
              }
            ],
            "name": "keyName",
            "description": "The property key to test"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The new value to test for `keyName`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-validate.errors"
            }
          ],
          "description": "Will return `undefined` if test map is valid.\nOtherwise, will return an array of [can-validate.errors].\n"
        }
      },
      {
        "code": "map.testSet(props, useNewInstance)",
        "description": "\n\n  Replaces many values on the map instance clone. Making `useNewInstance` set to\n  `true` will create a new instance of the map and test changes on the clean instance.\n\n  ```js\n  var Person = new DefineMap({\n      name: {\n          validate: {\n              presence: true\n          }\n      },\n      age: {\n          validate: {\n              numericality: true\n          }\n      }\n  });\n  var person = new Person({name: 'Juan', age: 35});\n\n  // this returns [{message: \"is required\", related: \"name\"}]\n  person.testSet({name: ''});\n\n  //this returns [{message: \"is required\", related: \"name\"}]\n  person.testSet({age: 35}, true);\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "object"
              }
            ],
            "name": "props",
            "description": "An object of key/value pairs, where `key` is a property in\nthe map instance that will update to the new `value`.\n"
          },
          {
            "types": [
              {
                "type": "boolean"
              }
            ],
            "optional": true,
            "name": "useNewInstance",
            "defaultValue": "false",
            "description": "If `true`, will use a new instance of the\nmap constructor, then test changes against that new map instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-validate.errors"
            }
          ],
          "description": "Will return `undefined` if test map is valid.\nOtherwise, will return an array of [can-validate.errors].\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-validate.errors"
        }
      ],
      "description": "Will return `undefined` if test map is valid.\nOtherwise, will return an array of [can-validate.errors].\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "optional": true,
      "name": "useNewInstance",
      "defaultValue": "false",
      "description": "If `true`, will use a new instance of the\nmap constructor, then test changes against that new map instance.\n"
    },
    "comment": " "
  },
  "can-ejs/tags": {
    "name": "can-ejs/tags",
    "title": "tags",
    "type": "group",
    "parent": "can-ejs",
    "description": "",
    "order": 0
  },
  "can-ejs/methods": {
    "name": "can-ejs/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-ejs",
    "description": "",
    "order": 1
  },
  "can-ejs": {
    "src": {
      "path": "node_modules/can-ejs/doc/can-ejs.md"
    },
    "body": "\n## Basic Example\n\nThe following renders a Teacher's name and students into an element.  First,\ncreate a teacher template in a script tag like:\n\n```\n<script type='text/ejs' id='teacherEJS'>\n\n  <h2 class='<%= teacher.grade < 'c'? \"good\" : \"bad\" %>'>\n    <%= teacher.name %>\n  </h2>\n\n  <ul>\n    <% for(var i =0; i< teacher.students.length; i++){ %>\n      <li><%= teacher.students[i].name %></li>\n    <% } %>\n  </ul>\n\n</script>\n```\n\nNotice the magic tags?  Those are things that look like `<% %>` and\n`<%= %>`.  Code between `<% %>` is run and the return value of code\nbetween `<%= %>` is inserted into the page.\n\nNext, create a teacher and render the template:\n\n    var teacher = {\n      name : \"Mr. Smith\",\n      grade : \"a\",\n      students : [\n        {name : \"Suzy\"},\n        {name : \"Payal\"},\n        {name : \"Curtis\"},\n        {name : \"Alexis\"}\n      ]\n    };\n\n    var template = ejs.from(\"teacherEJS\");\n\n    document.getElementById('teacher')\n      .appendChild( template(teacher) )\n\nThis results in HTML like:\n\n    <div id='teachers'>\n      <h2 class='good'>\n        Mr. Smith\n      </h2>\n\n      <ul>\n         <li>Suzy</li>\n         <li>Payal</li>\n         <li>Curtis</li>\n         <li>Alexis</li>\n      </ul>\n    </div>\n\nThis is nice, but what if we change properties of the teacher?\n\n## Basic Live Binding Example\n\nEJS sets up live templating binding when a [can-map]'s properties are read\nvia [can-map::attr attr] within a magic tag.  To make this template\nrespond to changes in the teacher data, first rewrite the template\nto use the attr method to read properties and `list( observeList, cb(item, i) )`\nto iterate through a list like:\n\n    <script type='text/ejs' id='teacherEJS'>\n\n      <h2 class='<%= teacher.attr('grade') < 'c'? \"good\" : \"bad\" %>'>\n        <%= teacher.attr('name') %>\n      </h2>\n\n      <ul>\n        <% list(teacher.students, function(student){ %>\n          <li><%= student.attr('name') %></li>\n        <% }) %>\n      </ul>\n\n    </script>\n\n__Note:__ The end of this page discusses why using `list` is\nhelpful, but it does nothing fancy.\n\nNext, turn your teacher into a `new CanMap(object)` and pass\nthat to the template:\n\n    var teacher = new CanMap({\n      name : \"Mr. Smith\",\n      grade : \"a\",\n      students : [\n        {name : \"Suzy\"},\n        {name : \"Payal\"},\n        {name : \"Curtis\"},\n        {name : \"Alexis\"}\n      ]\n    });\n\n\tvar template = ejs.from(\"teacherEJS\");\n\n    document.getElementById('teacher')\n      .appendChild( template(teacher) );\n\nFinally, update some properties of teacher and slap your\nhead with disbelief ...\n\n    teacher.attr('name',\"Prof. Snape\")\n    teacher.attr('grade','f+')\n    teacher.attr('students').push({\n      name : \"Harry Potter\"\n    })\n\n... but don't slap it too hard, you'll need it for building awesome apps.\n\n## Demo\n\nThe following demo shows an EJS template being rendered with observable data.\nIt demonstrates live binding to attributes. The template and all data properties\nare editable, so experiment!\n\n<div class='iframe_wrapper' data-iframe-src='can/view/ejs/doc/demo.html' data-iframe-height='1020'></div>\n## Magic Tags\n\nEJS uses 5 types of tags:\n\n\n\n__`<%= CODE %>`__ - Runs JS Code and writes the _escaped_ result into the result of the template.\n\nThe following results in the user seeing \"my favorite element is &lt;blink>BLINK&lt;blink>\" and not\n<blink>BLINK</blink>.\n\n     <div>my favorite element is <%= '<blink>BLINK</blink>' %>.</div>\n\n__`<%== CODE %>`__  - Runs JS Code and writes the _unescaped_ result into the result of the template.\n\nThe following results in \"my favorite element is <B>B</B>.\". Using `<%==` is useful\nfor sub-templates.\n\n         <div>my favorite element is <%== '<B>B</B>' %>.</div>\n\n__`<%% CODE %>`__ - Writes <% CODE %> to the result of the template.  This is very useful for generators.\n\n         <%%= 'hello world' %>\n\n__`<%# CODE %>`__  - Used for comments.  This does nothing.\n\n         <%# 'hello world' %>\n\n## Live Binding\n\nEJS allows live binding by wrapping magic tag content within a function. When `attr()` is called\nto update an observable object, these functions are executed to return the new value.\n\n    // Suppose an observable \"foo\":\n\n    var foo = new CanMap({\n      bar: 'baz'\n    });\n\n    // Suppose also, the above observable is passed to our view:\n\n    <%= foo.attr('bar') %>\n\n    // EJS locates the magic tag and turns the above into:\n\n    function() { return foo.attr('bar'); }\n\n    // As \"foo\" is updated using attr(), this function is called again to\n    // render the view with the new value.\n\nThis means that each function tag has a closure will reference variables in it's\nparent functions. This can cause problems if you don't understand closures in\nJavaScript. For example, the following binding does not work:\n\n    <% for(var i =0; i < items.attr('length'); i++){ %>\n      <li><%= items[i].attr('name') %></li>\n    <% } %>\n\nThis is because it gets turned into:\n\n\n    <% for(var i =0; i < items.attr('length'); i++){ %>\n      LIVEBIND( function() { return items[i].attr('name') )\n    <% } %>\n\nWhen the wrapping function is called again, `i` will\nnot be the index of the item, but instead be items.length.\n\nThe [can-list.prototype.each can-list::each] method on all observable lists should be used to iterate through it:\n\n    <% items.each(function(item){ %>\n      <li><%= item.attr('name') %></li>\n    <% }) %>\n\n## Advanced Live Binding\n\nOnce you get the hang of how EJS works, it makes live-binding of complex\ncalculations possible.  The following extends a [can.Model.List] to suppot a `completed` method that\nreturns the total number of completed items in the list.  It can be used in a template like:\n\n    <h2><%= todos.complete() %> Complete Todos </h2>\n\nAnd implemented like:\n\n    Todo.List = List.extend({\n      completed: function() {\n        var count = 0;\n\n        this.attr('length');\n        this.each(function(i, todo) {\n          if(this.attr('completed')) {\n            count++;\n          }\n        });\n\n        return count;\n      }\n    });\n\n`completed` listens on changes to the list (via `this.attr('length')`) and\neach item's `'completed'` property.  EJS keeps track of which observe/attribute pairs are called\nby `.complete()`.  If they change, EJS will automatically unbind.\n\n\n## Element Callbacks\n\nIf a function is returned by the `<%= %>` or `<%== %>` magic tags within an element’s tag like:\n\n    <div <%= function( element ) { element.style.display = 'none' } %> >\n      Hello\n    </div>\n\nThe function is called back with the HTMLElement as the first argument. This is useful to initialize functionality on an element within the view. This is so common that EJS supports ES5 arrow functions that get passed the NodeList wrapped element. Using jQuery, this lets you write the above callback as:\n\n    <div <%= (el) -> el.hide() %> >\n      Hello\n    </div>\n\nThis technique is commonly used to add data, especially model instances, to an element like:\n\n    <% todos.each( function( todo ) { %>\n      <li <%= (el) -> el.data( 'todo', todo ) %>>\n        <%= todo.attr( 'name' ) %>\n      </li>\n    <% } ) %>\n\njQuery’s `el.data( NAME, data )` adds data to an element. If your library does not support this, can provides it as `can.data( NodeList, NAME, data )`. Rewrite the above example as:\n\n    <% todos.each( function( todo ) { %>\n      <li <%= (el) -> can.data( el, 'todo', todo ) %>>\n        <%= todo.attr( 'name' ) %>\n      </li>\n    <% } ) %>\n\n",
    "description": "EJS provides __live__ ERB-style client-side templates. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-ejs",
    "parent": "can-legacy",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "justin@bitovi.com",
        "url": "http://bitovi.com"
      },
      "dependencies": {
        "can-compute": "^3.0.8",
        "can-legacy-view-helpers": "^0.4.4",
        "can-namespace": "^1.0.0",
        "can-observation": "^3.1.3",
        "can-types": "^1.0.1",
        "can-util": "^3.3.7"
      },
      "description": "legacy EJS layer for canjs",
      "devDependencies": {
        "can-list": "^3.0.4",
        "can-map": "^3.0.7",
        "documentjs": "^0.4.2",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.6",
        "jshint": "^2.9.1",
        "steal": "^1.2.8",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "https://canjs.com/2.3/docs/can.ejs.html",
      "keywords": [
        "CanJS",
        "MVVM"
      ],
      "main": "can-ejs",
      "name": "can-ejs",
      "scripts": {
        "build": "node build.js",
        "develop": "can-serve --static --develop --port 8080",
        "document": "documentjs",
        "jshint": "jshint can-ejs.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version pre && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-ejs",
        "ext": {
          "ejs": "src/system"
        },
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.7"
    },
    "deprecated": [
      {
        "version": "2.1",
        "description": "EJS is incompatible with [can-component] and should\nbe avoided for new projects. Projects using EJS should consider\nswitching to [can-stache].\n"
      }
    ],
    "signatures": [
      {
        "code": "ejs( template )",
        "description": "\n\nReturns `template` compiled to a renderer function.\n\n```js\nvar ejs = require(\"can-ejs\");\nvar renderer = ejs(\"<h1><%= message %></h1>\");\nvar frag = renderer({message: \"Hello World\"});\nfrag //-> <h1>Hello World</h1>\n\ndocument.body.appendChild(frag);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "The content of the mustache template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "Any"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A function that renders the ejs template into\na live documentFragment given data.\n"
        }
      },
      {
        "code": "new ejs(options)",
        "description": "\n\nCreates an EmbeddedJS template instance.  This form can be used\nto render a string.\n\n```js\nvar ejs = require(\"can-ejs\");\nvar ejsInstance = new ejs({\n\ttext: \"<h1><%= message %></h1>\"\n});\nvar string = ejsInstance.render({message: \"Hello World\"});\nstring //-> \"<h1>Hello World</h1>\"\n```\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Any"
                }
              ]
            }
          ]
        }
      ],
      "description": "A function that renders the ejs template into\na live documentFragment given data.\n"
    },
    "comment": " "
  },
  "can-ejs/methods.from": {
    "src": {
      "path": "node_modules/can-ejs/doc/from.md"
    },
    "body": "\n",
    "description": "Return a template loaded from an element. \n",
    "title": "from",
    "name": "can-ejs/methods.from",
    "type": "function",
    "parent": "can-ejs/methods",
    "signatures": [
      {
        "code": "ejs.from(id)",
        "description": "\n\nLoad a template from an HTML element (usually a `<script>` element)\nspecified by id.  This is used typically for demo purposes.\n\nFor example, with a `<script>` tag as follows in your HTML:\n\n```\n<script type='text/ejs' id='my-template'>\n<h1><%= message %></h1>\n</script>\n```\n\nLoad and render that template like:\n\n```\nvar template = ejs.from(\"my-template\");\ntemplate({message: \"Hello There!\"});\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "id",
            "description": "The id of the element, whose `innerHTML` will be used to create a template."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A renderer function that will render the\ntemplate.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "id",
      "description": "The id of the element, whose `innerHTML` will be used to create a template."
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A renderer function that will render the\ntemplate.\n"
    },
    "comment": " "
  },
  "can-ejs/tags.comment": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.comment.md"
    },
    "body": "",
    "description": "\n",
    "title": "<%# CODE %>",
    "name": "can-ejs/tags.comment",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 4,
    "signatures": [
      {
        "code": "<%# CODE %>",
        "description": "\n\nUsed for explicitly for comments.  This will not render anything.\n\n         <%# 'hello world' %>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.escaped": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.escaped.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "<%= CODE %>",
    "name": "can-ejs/tags.escaped",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 1,
    "signatures": [
      {
        "code": "<%= CODE %>",
        "description": "\n\nRuns JS Code and writes the _escaped_ result into the result of the template. This is useful for when you want to show code in your page.\n\nThe following results in the user seeing \"my favorite element is &lt;blink>BLINK&lt;blink>\" and not\n<blink>BLINK</blink>.\n\n     <div>my favorite element is <%= '<blink>BLINK</blink>' %>.</div>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.scriptlet": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.scriptlet.md"
    },
    "body": "",
    "description": "\n",
    "title": "<% CODE %>",
    "name": "can-ejs/tags.scriptlet",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 0,
    "signatures": [
      {
        "code": "<% CODE %>",
        "description": "\n\nRuns JavaScript Code.\n\nThis type of magic tag does not modify the template but is used for JS control statements\nlike for-loops, if/else, switch, etc.  An example:\n\n    <% if( items.attr('length') === 0 ) { %>\n        <tr><td>You have no items</td></tr>\n    <% } else { %>\n        <% items.each(function(item){ %>\n          <tr> .... </tr>\n        <% }) %>\n    <% } %>\n\nVariable declarations and control blocks should always be defined in\ntheir own dedicated tags. Live binding leverages this hinting to ensure that logic is declared and executed at its intended scope.\n\n\t<!-- Each statement has its own dedicated EJS tag -->\n    <% var address = person.attr('address') %>\n    <% items.each(function(item){ %>\n        <tr> .... </tr>\n    <% }) %>\n    <span><%= address.attr('street') %><span>\n\n    <!-- This won't work! -->\n    <%\n      var address = person.attr('address');\n      items.each(function(item) {\n    %>\n        <tr> .... </tr>\n    <% }) %>\n    <span><%= address.attr('street') %><span>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.templated": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.templated.md"
    },
    "body": "",
    "description": "\n",
    "title": "<%% CODE %>",
    "name": "can-ejs/tags.templated",
    "type": "function",
    "parent": "can-ejs/tags.tags",
    "order": 3,
    "signatures": [
      {
        "code": "<%% CODE %>",
        "description": "\n\nRenders <% CODE %> as text in result of the template rather than running CODE itself. This is useful for generators.\n\nThe following results in \"<%= 'hello world' %>\" rather than the string \"hello world.\"\n\n         <%%= 'hello world' %>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.unescaped": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.unescaped.md"
    },
    "body": "",
    "description": "\n",
    "title": "<%== CODE %>",
    "name": "can-ejs/tags.unescaped",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 2,
    "signatures": [
      {
        "code": "<%== CODE %>",
        "description": "\n\nRuns JS Code and writes the _unescaped_ result into the result of the template.\n\nThe following results in \"my favorite element is <B>B</B>.\". Using `<%==` is useful\nfor sub-templates.\n\n         <div>my favorite element is <%== '<B>B</B>' %>.</div>\n",
        "params": []
      }
    ]
  },
  "can-event/async/async.dispatch": {
    "type": "function",
    "name": "can-event/async/async.dispatch",
    "parent": "can-event/async/async",
    "src": {
      "line": 19,
      "codeLine": 39,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "Dispatch events asynchronously. \n",
    "title": "dispatch",
    "signatures": [
      {
        "code": "asych.dispatch.call(target, event, [args])",
        "description": "\n\nDispatches `event` on `target` in a task queue scheduled to\nrun [can-util/js/set-immediate/set-immediate immediately] after the current\nevent loop.\n\nIf [can-event/async/async.async] is called, this will replace\nthe default [can-event.dispatch].\n\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "target",
            "description": "The object to dispatch the event on."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "event",
            "description": "The event to dispatch."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Additional arguments to pass to event handlers"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "event The resulting event object\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "args",
      "description": "Additional arguments to pass to event handlers"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "event The resulting event object\n "
    }
  },
  "can-event/async/async.queue": {
    "type": "function",
    "name": "can-event/async/async.queue",
    "parent": "can-event/async/async",
    "src": {
      "line": 49,
      "codeLine": 64,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "Queues a method to be called asynchronously. \n",
    "title": "queue",
    "signatures": [
      {
        "code": "async.queue(task)",
        "description": "\n\nQueues a method to be run scheduled to\n[can-util/js/set-immediate/set-immediate immediately] after the current\nevent loop.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "task",
            "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                }
              ]
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "task",
      "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
    }
  },
  "can-event/async/async.flush": {
    "type": "function",
    "name": "can-event/async/async.flush",
    "parent": "can-event/async/async",
    "src": {
      "line": 71,
      "codeLine": 80,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "flush",
    "signatures": [
      {
        "code": "async.flush()",
        "description": "\n\nFlushes the task queue immediately so all events or other tasks\nwill be immediately invoked.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async.async": {
    "type": "function",
    "name": "can-event/async/async.async",
    "parent": "can-event/async/async",
    "src": {
      "line": 93,
      "codeLine": 101,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "async",
    "signatures": [
      {
        "code": "async.async()",
        "description": "\n\nMakes event dispatching and event binding happen asynchronously.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async.sync": {
    "type": "function",
    "name": "can-event/async/async.sync",
    "parent": "can-event/async/async",
    "src": {
      "line": 105,
      "codeLine": 113,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "sync",
    "signatures": [
      {
        "code": "async.sync()",
        "description": "\n\nMakes event dispatching and event binding happen synchronously.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async": {
    "src": {
      "path": "node_modules/can-event/async/async.md"
    },
    "body": "\n## Use\n\nUse `can-event/async/async`'s `async` method to make event binding and\ndispatching happen immediately following the current event loop.\n\n```js\nvar canEvent = require(\"can-event\");\nvar canAsync = require(\"can-event/async/async\");\ncanAsync.async();\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){\n  console.log(\"heard foo\");\n});\nobj.dispatch(\"foo\");\nconsole.log(\"dispatched foo\");\n\n// Logs -> \"dispatched foo\" then \"heard foo\"\n```\n\nThis means you never have to call [can-event/batch/batch.start] and [can-event/batch/batch.stop]. Notice\nthat in the following example `\"change\"` is only fired once:\n\n```js\nvar canAsync = require(\"can-event/async/async\");\ncanAsync.async();\n\nvar compute = require(\"can-compute\");\n\nvar first = compute(\"Justin\");\nvar last = compute(\"Meyer\");\n\nvar fullName = compute(function(){\n\treturn first() + \" \" + last();\n});\n\nfullName.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Payal Shah\"\n\toldVal //-> \"Justin Meyer\"\n});\n\nfirst(\"Payal\");\nlast(\"Shah\");\n```\n\n",
    "description": "Makes the event system asynchronous. __WARNING:__ This is experimental technology. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event/async/async",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "Object",
        "description": "\n\nThe `can-event/async/async` module makes the event system asynchronous.  It:\n\n - Provides an [can-event/async/async.async] method which converts event binding and dispatching to happen asynchronously.\n - Provides [can-event/async/async.sync]  method which converts event binding and dispatching to happen synchronously.\n - Provides an asynchronous [can-event/async/async.dispatch], [can-event/async/async.queue],\n  [can-event/async/async.addEventListener] and [can-event/async/async.removeEventListener].\n - Provides a [can-event/async/async.flush] which can be used to immediately run all tasks in the\n   task queue.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-event/batch/batch.start": {
    "type": "function",
    "name": "can-event/batch/batch.start",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 45,
      "codeLine": 151,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "`canBatch.start` begins an event batch. Until `[can-event/batch/batch.stop]` is called, any\nevents that would result from calls to [can-event/batch/batch.trigger] to are held back from firing. If you have\nlots of changes to make to observables, batching them together can help performance - especially if\nthose observables are live-bound to the DOM.\n\nIn this example, you can see how the _first_ event is not fired (and their handlers\nare not called) until `canBatch.stop` is called.\n\n```\nvar person = new DefineMap({\n    first: 'Alexis',\n    last: 'Abril'\n});\n\nperson.on('first', function() {\n    console.log(\"First name changed.\");\n}).on('last', function() {\n    console.log(\"Last name changed.\");\n});\n\ncanBatch.start();\nperson.first = 'Alex';\nconsole.log('Still in the batch.');\ncanBatch.stop();\n\n// the log has:\n// Still in the batch.\n// First name changed.\n```\n\nYou can also pass a callback to `canBatch.start` which will be called after all the events have\nbeen fired:\n\n```\ncanBatch.start(function() {\n    console.log('The batch is over.');\n});\nperson.first = \"Izzy\"\nconsole.log('Still in the batch.');\ncanBatch.stop();\n\n// The console has:\n// Still in the batch.\n// First name changed.\n// The batch is over.\n```\n\n## Calling `canBatch.start` multiple times\n\nIf you call `canBatch.start` more than once, `canBatch.stop` needs to be called\nthe same number of times before any batched events will fire. For ways\nto circumvent this process, see [can-event/batch/batch.stop].\n\nHere is an example that demonstrates how events are affected by calling\n`canBatch.start` multiple times.\n\n```\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  name: \"string\"\n  updatedAt: \"date\",\n  complete: function(){\n    canBatch.start();\n    this.completed = true;\n    this.updatedAt = new Date();\n    canBatch.end();\n  }\n});\n\nTodo.List = DefineList.extend({\n  \"#\": Todo,\n  completeAll: function(){\n    this.forEach(function(todo){\n      todo.complete();\n    });\n  }\n});\n\nvar todos = new Todo.List([\n  {name: \"dishes\", completed: false},\n  {name: \"lawn\", completed: false}\n]);\n\ntodos[0].on(\"completed\", function(ev){\n  console.log(\"todos[0] \"+ev.batchNum);\n})\ntodos[1].on(\"completed\", function(ev){\n  console.log(\"todos[1] \"+ev.batchNum);\n});\n\ntodos.completeAll();\n// console.logs ->\n//        todos[0] 1\n//        todos[1] 1\n```\n \n",
    "description": "Begin an event batch. \n",
    "title": "start",
    "signatures": [
      {
        "code": "canBatch.start([batchStopHandler])",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "batchStopHandler",
            "description": "a callback that gets called after all batched events have been called.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "batchStopHandler",
      "description": "a callback that gets called after all batched events have been called.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.collecting": {
    "type": "function",
    "name": "can-event/batch/batch.collecting",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 180,
      "codeLine": 198,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "\n",
    "title": "collecting",
    "signatures": [
      {
        "code": "batch.collecting()",
        "description": "\n\nReturns the Queue that is currently collecting tasks.\n\n```\nbatch.start();\nbatch.collecting() //-> Queue\n\nbatch.stop();\nbatch.collecting() //-> null\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-event/batch/Queue"
            }
          ],
          "description": "The queue currently collecting tasks.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-event/batch/Queue"
        }
      ],
      "description": "The queue currently collecting tasks.\n "
    }
  },
  "can-event/batch/batch.dispatching": {
    "type": "function",
    "name": "can-event/batch/batch.dispatching",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 201,
      "codeLine": 225,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "\n",
    "title": "dispatching",
    "signatures": [
      {
        "code": "batch.dispatching()",
        "description": "\n\nReturns the Queue that is executing tasks.\n\n```\nvar canEvent = require(\"can-event\");\nvar batch = require(\"can-event/batch/batch\");\n\n\nvar obj = Object.assign({}, canEvent);\n\n\n\nbatch.start();\nobj.dispatch(\"first\");\nbatch.stop();\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-event/batch/Queue"
            }
          ],
          "description": "The queue currently executing tasks.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-event/batch/Queue"
        }
      ],
      "description": "The queue currently executing tasks.\n "
    }
  },
  "can-event/batch/batch.stop": {
    "type": "function",
    "name": "can-event/batch/batch.stop",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 228,
      "codeLine": 253,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "\n`canBatch.stop` matches an earlier `[can-event/batch/batch.start]` call. If `canBatch.stop` has been\ncalled as many times as `canBatch.start` (or if _force_ is true), all batched events will be\nfired and any callbacks passed to `canBatch.start` since the beginning of the batch will be\ncalled. If _force_ and _callStart_ are both true, a new batch will be started when all\nthe events and callbacks have been fired.\n\nSee `[can-event/batch/batch.start]` for examples of `canBatch.start` and `canBatch.stop` in normal use.\n\n \n",
    "description": "End an event batch. \n",
    "title": "stop",
    "signatures": [
      {
        "code": "canBatch.stop([force[, callStart]])",
        "description": "\n\nIf this call to `stop` matches the number of calls to `start`, all of this batch's [can-event/batch/batch.trigger triggered]\nevents will be dispatched.  If the firing of those events creates new events, those new events will be dispatched\nafter the current batch in their own batch.\n",
        "params": [
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "force",
            "defaultValue": "false",
            "description": "Whether to stop batching events immediately."
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "callStart",
            "defaultValue": "false",
            "description": "Whether to call [can-event/batch/batch.start] after firing batched events.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "callStart",
      "defaultValue": "false",
      "description": "Whether to call [can-event/batch/batch.start] after firing batched events.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.dispatch": {
    "type": "function",
    "name": "can-event/batch/batch.dispatch",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 339,
      "codeLine": 363,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "\n \n",
    "description": "Dispatchs an event within the event batching system. ",
    "title": "dispatch",
    "signatures": [
      {
        "code": "canBatch.trigger(item, event [, args])",
        "description": "\n\nMakes sure an event is fired at the appropriate time within the appropriate batch.\nHow and when the event fires depends on the batching state.\n\nThere are three states of batching:\n\n- no queues - `trigger` is called outside of any `start` or `stop` call -> The event is dispatched immediately.\n- collecting batch - `trigger` is called between a `start` or `stop` call -> The event is dispatched when `stop` is called.\n- firing queues -  `trigger` is called due to another `trigger` called within a batch -> The event is dispatched after the current batch has completed in a new batch.\n\nFinally, if the event has a `batchNum` it is fired immediately.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "item",
            "description": "the target of the event."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": [
                  {
                    "name": "type",
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "event",
            "description": "the type of event, or an event object with a type given like `{type: 'name'}`"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "the parameters to trigger the event with.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "args",
      "description": "the parameters to trigger the event with.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.queue": {
    "type": "function",
    "name": "can-event/batch/batch.queue",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 427,
      "codeLine": 452,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "Queues a method to be called. \n",
    "title": "queue",
    "signatures": [
      {
        "code": "batch.queue(task)",
        "description": "\n\nQueues a method to be called in the current [can-event/batch/batch.collecting]\nqueue if there is one.  If there is a [can-event/batch/batch.dispatching] queue,\nit will create a batch and add the task to that batch.\nFinally, if there is no batch, the task will be executed immediately.\n\n```\nvar me = {\n  say: function(message){\n    console.log(this.name,\"says\", message);\n  }\n}\nbatch.queue([me.say, me, [\"hi\"]]);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "task",
            "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                }
              ]
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "task",
      "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
    }
  },
  "can-event/batch/batch.afterPreviousEvents": {
    "src": {
      "line": 477,
      "codeLine": 555,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\nWith batching, it's possible for a piece of code to read some observable, and listen to\nchanges in that observable, but have events fired that it should ignore.\n\nFor example, consider a list widget that creates `<li>`'s for each item in the list and listens to\nupdates in that list and adds or removes `<li>`s:\n\n```js\nvar makeLi = function(){\n  return document.createElement(\"li\")\n};\n\nvar listWidget = function(list){\n  var lis = list.map(makeLi);\n  list.on(\"add\", function(ev, added, index){\n    var newLis = added.map(makeLi);\n    lis.splice.apply(lis, [index, 0].concat(newLis) );\n  }).on(\"remove\", function(ev, removed, index){\n    lis.splice(index, removed.length);\n  });\n\n  return lis;\n}\n```\n\nThe problem with this is if someone calls `listWidget` within a batch:\n\n```js\nvar list = new DefineList([]);\n\ncanBatch.start();\nlist.push(\"can-event\",\"can-event/batch/\");\nlistWidget(list);\ncanBatch.stop();\n```\n\nThe problem is that list will immediately create an `li` for both `can-event` and `can-event/batch/`, and then,\nwhen `canBatch.stop()` is called, the `add` event listener will create duplicate `li`s.\n\nThe solution, is to use `afterPreviousEvents`:\n\n```js\nvar makeLi = function(){\n  return document.createElement(\"li\")\n};\n\nvar listWidget = function(list){\n  var lis = list.map(makeLi);\n  canBatch.afterPreviousEvents(function(){\n    list.on(\"add\", function(ev, added, index){\n      var newLis = added.map(makeLi);\n      lis.splice.apply(lis, [index, 0].concat(newLis) );\n    }).on(\"remove\", function(ev, removed, index){\n      lis.splice(index, removed.length);\n    });\n  });\n\n  return lis;\n}\n```\n\n \n",
    "description": "Run code when all previuos state has settled. \n",
    "title": "afterPreviousEvents",
    "name": "can-event/batch/batch.afterPreviousEvents",
    "parent": "can-event/batch/batch",
    "signatures": [
      {
        "code": "canBatch.afterPreviousEvents(handler)",
        "description": "\n\nCalls `handler` when all previously [can-event/batch/batch.trigger triggered] events have\nbeen fired.  This is useful to know when all fired events match the current state.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "A function to call back when all previous events have fired.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "A function to call back when all previous events have fired.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch": {
    "src": {
      "path": "node_modules/can-event/batch/batch.md"
    },
    "body": "\n## Use\n\nTo batch events, call  [can-event/batch/batch.start], then make changes that\n[can-event/batch/batch.dispatch] batched events, then call [can-event/batch/batch.stop].\n\nFor example, a map might have a `first` and `last` property:\n\n```js\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\"\n});\n\nvar baby = new Person({first: \"Roland\", last: \"Shah\"});\n```\n\nNormally, when `baby`'s `first` and `last` are fired, those events are dispatched immediately:\n\n```js\nbaby.on(\"first\", function(ev, newFirst){\n\tconsole.log(\"first is \"+newFirst);\n}).on(\"last\", function(ev, newLast){\n\tconsole.log(\"last is \"+newLast);\n});\n\nbaby.first = \"Ramiya\";\n// console.logs -> \"first is Ramiya\"\nbaby.last = \"Meyer\";\n// console.logs -> \"first is Meyer\"\n```\n\nHowever, if a batch is used, events will not be dispatched until [can-event/batch/batch.stop] is called:\n\n```js\nvar canBatch = require(\"can-event/batch/batch\");\n\ncanBatch.start();\nbaby.first = \"Lincoln\";\nbaby.last = \"Sullivan\";\ncanBatch.stop();\n// console.logs -> \"first is Lincoln\"\n// console.logs -> \"first is Sullivan\"\n```\n\n\n\n## Performance\n\nCanJS synchronously dispatches events when a property changes.\nThis makes certain patterns easier. For example, if you\nare utilizing live-binding and change a property, the DOM is\nimmediately updated.\n\nOccasionally, you may find yourself changing many properties at once. To\nprevent live-binding from performing unnecessary updates,\nupdate the properties within a pair of calls to `canBatch.start` and\n`canBatch.stop`.\n\nConsider a todo list with a `completeAll` method that marks every todo in the list as\ncomplete and `completeCount` that counts the number of complete todos:\n\n```js\nvar Todo = DefineMap.extend({\n\tname: \"string\",\n\tcomplete: \"boolean\"\n});\n\nvar TodoList = DefineList.extend({\n\t\"#\": Todo,\n\tcompleteAll: function(){\n\t\tthis.forEach(function(todo){\n\t\t\ttodo.complete = true;\n\t\t})\n\t},\n\tcompleteCount: function(){\n\t\treturn this.filter({complete: true}).length;\n\t}\n})\n```\n\nAnd a template that uses the `completeCount` and calls `completeAll`:\n\n```\n<ul>\n{{#each todos}}\n\t<li><input type='checklist' {($checked)}=\"complete\"/> {{name}}</li>\n{{/each}}\n</ul>\n<button ($click)=\"todos.completeAll()\">\n  Complete {{todos.completeCount}} todos\n</button>\n```\n\nWhen `completeAll` is called, the `{{todos.completeCount}}` magic tag will update\nonce for every completed count.  We can prevent this by wrapping `completeAll` with calls to\n`start` and `stop`:\n\n```js\n\tcompleteAll: function(){\n\t\tcanBatch.start();\n\t\tthis.forEach(function(todo){\n\t\t\ttodo.complete = true;\n\t\t});\n\t\tcanBatch.end();\n\t},\n```\n\n\n## batchNum\n\nAll events created within a set of `start` / `stop` calls share the same\nbatchNum value. This can be used to respond only once for a given batchNum.\n\n    var batchNum;\n    person.on(\"name\", function(ev, newVal, oldVal) {\n      if(!ev.batchNum || ev.batchNum !== batchNum) {\n        batchNum = ev.batchNum;\n        // your code here!\n      }\n    });\n\n",
    "description": "Adds task batching abilities to event dispatching. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event/batch/batch",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "Object",
        "description": "\n\nThe `can-event/batch/batch` module adds task batching abilities to\nthe [can-event] module.  It:\n\n - Provides a [can-event/batch/batch.queue] method to add batched work.\n - Provides [can-event/batch/batch.dispatch] and overwrites [can-event.dispatch can-event.dispatch] to use the task queue when dispatching events.\n - Provides a [can-event/batch/batch.start] and [can-event/batch/batch.stop] method that can create a new task queue.\n - Provides [can-event/batch/batch.collecting] which returns the queue collecting tasks.\n - Provides [can-event/batch/batch.dispatching] which returns the queue dispatching tasks.\n - Dispatches `batchEnd` when a queue's tasks have been completed.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can.util.bind": {
    "src": {
      "line": 1,
      "codeLine": 9,
      "path": "node_modules/can-event/lifecycle/lifecycle.js"
    },
    "type": "typedef",
    "body": "\n\n",
    "description": "\nProvides mixin-able bind and unbind methods. `bind()` calls `this._bindsetup`\nwhen the first bind happens and.  `unbind()` calls `this._bindteardown` when there\nare no more event handlers.\n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "bind",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "unbind",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can.util.bind"
  },
  "can-event/lifecycle/lifecycle": {
    "src": {
      "path": "node_modules/can-event/lifecycle/lifecycle.md"
    },
    "body": "\n## Use\n\nTo use lifecycle events, provide an object with add/removeEventListener methods.\n\n```js\nvar Todo = function(){\n\n};\n\nlifecycle(assign(Todo.prototype, canEvent));\n\nTodo.prototype._eventSetup = function(){\n\t// Called the first time bindings are added.\n};\n```\n\n",
    "description": "Mixin lifecycle events onto a prototype. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event/lifecycle/lifecycle",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "lifecycle(prototype)",
        "description": "\n\nThe `can-event/lifecycle/lifecycle` module adds lifecycle events to a prototype that already has `addEventListener` and `removeEventListener`. It allows you to define:\n\n - `_eventSetup`: A method that is called the first time a binding is added to the object.\n - `_eventTeardown`: A method that is called when there are no longer any more bindings on an object.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-event-radiochange": {
    "name": "can-event-radiochange",
    "type": "page",
    "parent": "can-infrastructure",
    "src": {
      "path": "node_modules/can-stache-bindings/node_modules/can-event-radiochange/src/can-event-radiochange.md"
    },
    "body": "\nA custom event for listening to changes of inputs with type \"radio\", which fires when a conflicting radio input changes. A \"conflicting\" radio button has the same \"name\" attribute and exists within in the same form, or lack thereof. This event coordinates state bound to whether a radio is checked. The \"change\" event does not fire for deselected radios. By using this event instead, deselected radios receive notification.\n\n",
    "description": "\n# can-event-radiochange\n",
    "title": "can-event-radiochange",
    "types": [
      {
        "type": "events"
      }
    ]
  },
  "can-fixture.properties": {
    "name": "can-fixture.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-fixture",
    "description": "",
    "order": 0
  },
  "can-fixture.types": {
    "name": "can-fixture.types",
    "title": "types",
    "type": "group",
    "parent": "can-fixture",
    "description": "",
    "order": 0
  },
  "can-fixture": {
    "src": {
      "path": "node_modules/can-fixture/docs/can-fixture.md"
    },
    "body": "",
    "description": "can-fixture intercepts an AJAX request and simulates the response with a file or function. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-fixture",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.4",
          "bit-docs-generate-readme": "^0.0.10"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "parent": "can-fixture",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-fixture/issues"
      },
      "dependencies": {
        "can-connect": "^1.0.0",
        "can-deparam": "^1.0.1",
        "can-namespace": "1.0.0",
        "can-set": "^1.0.0",
        "can-util": "^3.0.1"
      },
      "description": "Intercept AJAX requests and simulate responses.",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "jquery": "^3.1.1",
        "jshint": "^2.7.0",
        "steal": "^1.0.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.5.1"
      },
      "homepage": "https://github.com/canjs/can-fixture",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "fixture.js",
      "name": "can-fixture",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-fixture.git"
      },
      "scripts": {
        "build": "node build.js",
        "jshint": "jshint fixture.js core.js store.js xhr.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee --browsers firefox test/test.html",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "1.0.14"
    },
    "signatures": [
      {
        "code": "fixture(ajaxSettings, requestHandler(...))",
        "description": "\n\nIf an XHR request matches ajaxSettings, calls requestHandler with the XHR requests data. Makes the XHR request respond with the return value of requestHandler or the result of calling its response argument.\n\nThe following traps requests to GET /todos and responds with an array of data:\n\n```js\nfixture({method: \"get\", url: \"/todos\"},\n        function(request, response, headers, ajaxSettings){\n    return {\n        data: [\n            {id: 1, name: \"dishes\"},\n            {id: 2, name: \"mow\"}\n        ]\n    };\n})\n```\n\nWhen adding a fixture, it will remove any identical fixtures from the list of fixtures. The last fixture added will be the first matched.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/ajaxSettings"
              }
            ],
            "name": "ajaxSettings",
            "description": "An object that is used to match values on an XHR object, namely the url and method. url can be templated like /todos/{_id}."
          },
          {
            "types": [
              {
                "type": "can-fixture.requestHandler"
              }
            ],
            "name": "requestHandler",
            "description": "Handles the request and provides a response. The next section details this function's use.\n"
          }
        ]
      },
      {
        "code": "fixture(ajaxSettings, url)",
        "description": "\n\nRedirects the request to another url.  This can be useful for simulating a response with a file.\n\n```js\nfixture({url: \"/tasks\"}, \"fixtures/tasks.json\");\n```\n\nPlaceholders available in the `ajaxSettings` url will be available in the redirect url:\n\n```js\nfixture({url: \"/tasks/{id}\"}, \"fixtures/tasks/{id}.json\");\n```\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, data)",
        "description": "\n\nResponds with the `JSON.stringify` result of `data`.\n\n```js\nfixture({url: \"/tasks\"}, {tasks: [{id: 1, complete: false}]});\n```\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, delay)",
        "description": "\n\nDelays the ajax request from being made for `delay` milliseconds.\n\n```js\nfixture({url: \"/tasks\"}, 2000);\n```\n\nThis doesn't simulate a response, but is useful for simulating slow connections.\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, null)",
        "description": "\n\nRemoves the matching fixture from the list of fixtures.\n\n```js\nfixture({url: \"/tasks\"}, \"fixtures/tasks.json\");\n\n$.get(\"/tasks\") // requests fixtures/tasks.json\n\nfixture({url: \"/tasks\"}, null);\n\n$.get(\"/tasks\") // requests /tasks\n```\n",
        "params": []
      },
      {
        "code": "fixture(methodAndUrl, url|data|requestHandler)",
        "description": "\n\nA short hand for creating an [can-fixture/types/ajaxSettings] with a `method` and `url`.\n\n```js\nfixture(\"GET /tasks\", requestHandler );\n\n// is the same as\n\nfixture({method: \"get\", url: \"/tasks\"}, requestHandler );\n```\n\nThe format is `METHOD URL`.\n",
        "params": []
      },
      {
        "code": "fixture(url, url|data|requestHandler)",
        "description": "\n\nA short hand for creating an [can-fixture/types/ajaxSettings] with just a `url`.\n\n```js\nfixture(\"/tasks\", requestHandler);\n\n// is the same as\n\nfixture({url: \"/tasks\"}, requestHandler);\n```\n",
        "params": []
      },
      {
        "code": "fixture(fixtures)",
        "description": "\n\nCreate multiple fixtures at once.\n\n```js\nfixture({\n    \"POST /tasks\": function(){\n        return {id: Math.random()}\n    },\n    \"GET /tasks\": {data: [{id: 1, name: \"mow lawn\"}]},\n    \"/people\": \"fixtures/people.json\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "methodAndUrl"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      },
                      {
                        "type": "Object"
                      },
                      {
                        "type": "can-fixture.requestHandler"
                      },
                      {
                        "type": "can-fixture/StoreType"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "fixtures",
            "description": "A mapping of methodAndUrl to\nsome response argument type.\n\n\n"
          }
        ]
      },
      {
        "code": "fixture(restfulUrl, store)",
        "description": "\n\nWire up a restful API scheme to a store.\n\n```js\nvar todoAlgebra = new set.Algebra(\n    set.props.id(\"id\")\n);\nvar todoStore = fixture.store([\n  { id: 1, name: 'Do the dishes'},\n  { id: 2, name: 'Walk the dog'}\n], todoAlgebra);\n\nfixture(\"/api/todos/{id}\", todoStore); // can also be written fixture(\"/api/todos\", todoStore);\n```\n\nThis is a shorthand for wiring up the `todoStore` as follows:\n\n```js\nfixture({\n    \"GET /api/todos\": todoStore.getListData,\n    \"GET /api/todos/{id}\": todoStore.getData,\n    \"POST /api/todos\": todoStore.createData,\n    \"PUT /api/todos/{id}\": todoStore.updateData,\n    \"DELETE /api/todos/{id}\": todoStore.destroyData\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "restfulUrl",
            "description": "The url that may include a template for the place of the ID prop.  The `list` url is assumed to be `restfulUrl` with the `/{ID_PROP}` part removed, if provided; otherwise the `item` url is assumed to have the `/{ID_PROP}` part appended to the end."
          },
          {
            "types": [
              {
                "type": "can-fixture/StoreType"
              }
            ],
            "name": "store",
            "description": "A store produced by [can-fixture.store].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-fixture/StoreType"
        }
      ],
      "name": "store",
      "description": "A store produced by [can-fixture.store].\n"
    }
  },
  "can-fixture.delay": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.delay.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Number"
      }
    ],
    "title": "delay",
    "name": "can-fixture.delay",
    "type": "property",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.delay",
        "description": "\n\nSets the delay until a response is fired in milliseconds.\n\n```js\nfixture.delay = 1000; // 1 second delay\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture.fixtures": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.fixtures.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Array",
        "options": []
      }
    ],
    "title": "fixtures",
    "name": "can-fixture.fixtures",
    "type": "property",
    "signatures": [
      {
        "code": "fixture.fixtures",
        "description": "\n\nThe list of currently active fixtures.\n",
        "params": []
      }
    ]
  },
  "can-fixture.on": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.on.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "on",
    "name": "can-fixture.on",
    "type": "property",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.on",
        "description": "\n\nTurns the fixtures on or off. Defaults to `true` for on.\n\n```js\nfixture.on = false; //-> AJAX requests will not be trapped\n```\n\nTo remove a fixture you can also use `fixture(ajaxSetting, null)`.\n",
        "params": []
      }
    ]
  },
  "can-fixture.rand": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.rand.md"
    },
    "body": "",
    "description": "\n",
    "title": "rand",
    "name": "can-fixture.rand",
    "type": "function",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.rand(min, max)",
        "description": "\n\nReturns a random integer in the range [min, max]. If only one argument is provided,\nreturns a random integer from [0, max].\n\n```js\nfixture.rand(1, 10) //-> Random number between 1 and 10 inclusive.\nfixture.rand(10) //-> Random number between 0 and 10 inclusive.\n```",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "min",
            "description": "The lower limit of values that will be returned."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "max",
            "description": "The upper limit of values that will be returned.  `max` is valid return value.\n"
          }
        ]
      },
      {
        "code": "fixture.rand(choices, min, max)",
        "description": "\n\nAn array of between min and max random items from choices. If only `min` is\nprovided, `max` will equal `min`.  If both `max` and `min` are not provided,\n`min` will be 1 and `max` will be `choices.length`.\n\n```js\n// pick a random number of items from an array\nfixture.rand([\"a\",\"b\",\"c\"]) //-> [\"c\"]\nfixture.rand([\"a\",\"b\",\"c\"]) //-> [\"b\",\"a\"]\n\n// pick one item from an array\nfixture.rand([\"a\",\"b\",\"c\"],1) //-> [\"c\"]\n\n// get one item from an array\nfixture.rand([\"a\",\"b\",\"c\"],1)[0] //-> \"b\"\n\n// get 2 or 3 items from the array\nfixture.rand([\"a\",\"b\",\"c\"],2,3) //-> [\"c\",\"a\",\"b\"]\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "choices",
            "description": "An array of values to chose from. The returned array will only include a value once."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "min",
            "description": "The minimum number of items to be in the returned array."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "max",
            "description": "The maximum number of items in the returned array.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "max",
      "description": "The maximum number of items in the returned array.\n"
    }
  },
  "can-fixture.store": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.store.md"
    },
    "body": "",
    "description": "\n",
    "title": "store",
    "name": "can-fixture.store",
    "type": "function",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.store(baseItems, algebra)",
        "description": "\n\nCreate a store that starts with `baseItems` for a service layer\ndescribed by `algebra`.\n\n```js\n// Describe the services parameters:\nvar todoAlgebra = new set.Algebra({\n    set.props.id(\"_id\"),\n    set.props.boolean(\"completed\"),\n    set.props.rangeInclusive(\"start\",\"end\"),\n    set.props.sort(\"orderBy\"),\n});\n\n// Create a store with initial data.\n// Pass [] if you want it to be empty.\nvar todoStore = fixture.store([\n    {\n      _id : 1,\n      name : 'Do the dishes',\n      complete: true\n    }, {\n      _id : 2,\n      name : 'Walk the dog',\n      complete: false\n    }],\n    todoAlgebra );\n\n// Hookup urls to the store:\nfixture(\"/todos/{_id}\", todoStore);\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "baseItems",
            "description": "An array of items that will populate the store."
          },
          {
            "types": [
              {
                "type": "can-set.Algebra"
              }
            ],
            "name": "algebra",
            "description": "A description of the service layer's parameters."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-fixture/StoreType"
            }
          ],
          "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n\n"
        }
      },
      {
        "code": "fixture.store(count, makeItems, algebra)",
        "description": "\n\nSimilar to `fixture.store(baseItems, algebra)`, except that\nit uses `makeItems` to create `count` entries in the store.\n\n```js\n// Describe the services parameters:\nvar todoAlgebra = new set.Algebra({ ... });\n\n// Create a store with initial data.\n// Pass [] if you want it to be empty.\nvar todoStore = fixture.store(\n    1000,\n    function(i){\n        return {\n          _id : i+1,\n          name : 'Todo '+i,\n          complete: fixture.rand([true, false],1)[0]\n        }\n    },\n    todoAlgebra );\n\n// Hookup urls to the store:\nfixture(\"/todos/{_id}\", todoStore);\n```",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "count",
            "description": "TODO describe"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "makeItems",
            "description": "A function that will generate `baseItems`"
          },
          {
            "types": [
              {
                "type": "can-set.Algebra"
              }
            ],
            "name": "algebra",
            "description": "A description of the service layer's parameters."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-fixture/StoreType"
            }
          ],
          "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-fixture/StoreType"
        }
      ],
      "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-set.Algebra"
        }
      ],
      "name": "algebra",
      "description": "A description of the service layer's parameters."
    }
  },
  "fixture.types.Store.findOne": {
    "type": "function",
    "name": "fixture.types.Store.findOne",
    "parent": "fixture.types.Store",
    "src": {
      "line": 177,
      "codeLine": 196,
      "path": "node_modules/can-fixture/helpers/legacyStore.js"
    },
    "body": "`store.findOne(request, response(item))` simulates a request to\nget a single item from the server by id.\n\n    todosStore.findOne({\n      url: \"/todos/5\"\n    }, function(todo){\n\n    });\n\n\t \n",
    "description": "Simulate a findOne request on a fixture. ",
    "title": "",
    "signatures": [
      {
        "code": "store.findOne(request, response)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "request",
            "description": "Parameters for the request."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "response",
            "description": "A function to call with the retrieved item.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "response",
      "description": "A function to call with the retrieved item.\n"
    },
    "comment": " "
  },
  "fixture.types.Store.destroy": {
    "type": "function",
    "name": "fixture.types.Store.destroy",
    "parent": "fixture.types.Store",
    "src": {
      "line": 224,
      "codeLine": 242,
      "path": "node_modules/can-fixture/helpers/legacyStore.js"
    },
    "body": "`store.destroy(request, response())` simulates\na request to destroy an item from the server.\n\n```\ntodosStore.destroy({\n  url: \"/todos/5\"\n}, function(){});\n```\n\t \n",
    "description": "Simulate destroying a Model on a fixture. ",
    "title": "",
    "signatures": [
      {
        "code": "store.destroy(request, callback)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "request",
            "description": "Parameters for the request."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "callback",
            "description": "A function to call after destruction.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "callback",
      "description": "A function to call after destruction.\n"
    },
    "comment": " "
  },
  "can-fixture-socket.socket-event-listener": {
    "src": {
      "path": "node_modules/can-fixture-socket/docs/can-fixture-socket.listener.md"
    },
    "body": "",
    "description": "A listener handler that will be executed to handle the socket event. \n",
    "type": "typedef",
    "title": "SocketEventListener",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-fixture-socket.socket-event-listener",
    "parent": "can-fixture-socket.types",
    "signatures": [
      {
        "code": "handler(...data, [ackFn])",
        "description": "\n\nSocket event listener handler expects one or more data arguments and an optional ACK callback.\n\n```js\n// Client:\nsocket.on(\"news\": function handler(data, ackCb){\n  console.log(\"received some news\", data);\n  ackCb(\"Acknowledged\", \"thank you\");\n});\n\n// Server:\nserver.emit(\"news\", {some: \"news here\"}, function ackFn(...data){\n  console.log(\"Client acknowledged data receiving\")\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "data",
            "description": "Event data. Socket.io allows to pass as many arguments as needed."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "ackCb",
            "description": "Optional acknowledgement callback to let emitter know about success receiving data.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "ackCb",
      "description": "Optional acknowledgement callback to let emitter know about success receiving data.\n"
    }
  },
  "can-fixture-socket.Server.prototype.onFeathersService": {
    "src": {
      "path": "node_modules/can-fixture-socket/docs/can-fixture-socket.on-feathers-service.md"
    },
    "body": "\n\n## Use\n\nInstantiate fixture store by calling [can-fixture.store] and provide FeathersJS service name:\n```js\nvar fixtureStore = fixture.store([\n  {_id: 1, title: 'One'},\n  {_id: 2, title: 'Two'},\n  {_id: 3, title: 'Three'}\n], new canSet.Algebra(canSet.props.id('_id')));\n *\nmockServer.onFeathersService('messages', fixtureStore, {id: \"_id\"});\n```\n\nThis will emulate FeathersJS server CRUD service.\n\nNow from Feathers client app you can do:\n```js\n// Import dependencies:\nvar io = require(\"socket.io-client\");\nvar feathers = require('feathers/client');\nvar feathersSocketio = require('feathers-socketio/client');\nvar hooks = require('feathers-hooks');\n\n// Configure Feathers client app:\nvar socket = io(\"http://api.my-feathers-server.com\");\nvar app = feathers()\n  .configure(hooks())\n  .configure(feathersSocketio(socket));\n\n// Create client Feathers service:\nvar messagesService = app.service('messages');\n\n// Test:\nmessagesService.get(1).then(function(data){\n  assert.deepEqual(data, {id: 1, title: 'One'}, 'get should receive an item');\n});\n```\n\n",
    "description": "\nSubscribes to mocked server socket events to work as FeathersJS CRUD service.\n",
    "title": "onFeathersService",
    "name": "can-fixture-socket.Server.prototype.onFeathersService",
    "type": "function",
    "parent": "can-fixture-socket.Server.prototype",
    "signatures": [
      {
        "code": "server.onFeathersService(name, fixtureStore, [options])",
        "description": "\n\nSubscribes to mocked server socket events according to FeathersJS protocol. Uses fixture store [can-fixture.Store] as a resource storage.\n\n```\nvar fixtureStore = fixture.store([\n  {id: 1, title: 'One'},\n  {id: 2, title: 'Two'},\n  {id: 3, title: 'Three'}\n], new canSet.Algebra({}));\n\nserver.onFeathersService(\"messages\", fixtureStore})\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of Feathers service."
          },
          {
            "types": [
              {
                "type": "can-fixture/StoreType"
              }
            ],
            "name": "fixtureStore",
            "description": "A fixture store. See [can-fixture.store] for more details."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options, e.g. property name for id.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options, e.g. property name for id.\n"
    },
    "comment": " "
  },
  "can-fixture-socket.Server.prototype": {
    "name": "can-fixture-socket.Server.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-fixture-socket.Server",
    "description": "",
    "order": 0
  },
  "can-fixture-socket.Server": {
    "src": {
      "path": "node_modules/can-fixture-socket/docs/can-fixture.server.md"
    },
    "body": "\n\n## Use\n\n1. Instantiate a server to intercept socket.io connection:\n```js\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n\n2. Mock socket.io server behaviour:\n```js\nmockServer.on(\"connection\", function(){\n  mockServer.emit(\"notifications\", [{text: \"A new notification\"}]);\n});\n\nmockServer.on(\"some event\", function(data, ackCb){\n  console.log(\"Client send some \", data);\n  ackCb(\"thanks\");\n});\n```\n\n3. Test your client app:\n```js\nvar socket = io(\"http://localhost:8080/ws\");\nsocket.emit(\"some event\", \"some data\", function(data){\n  assert.equal(data, \"thanks\", \"Server acknowledged our event\");\n});\n```\n\n## Examples\n\n### CRUD service with fixture store\n\nLets see how we can test a possible implementation of a CRUD service that utilizes socket.io ACK callbacks. We will use fixture store to emulate our CRUD storage and link it to our mocked server.\n\n```js\nvar fixture = require(\"can-fixture\");\n\n// First, lets create fixture store:\nvar fixtureStore = fixture.store([\n  {id: 1, title: \"One\", rank: \"good\"},\n  {id: 2, title: \"Two\", rank: \"average\"},\n  {id: 3, title: \"Three\", rank: \"good\"}\n], new canSet.Algebra({}));\n\n// And instantiate a mocked server:\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n\nFixture store is designed to work with XHR requests, thus its methods take two arguments: `request` and `response`. See [can-fixture.Store.prototype.getListData] for more details. Our mocked server can listen to socket events and its event listener expects data and an optional ACK callback. To convert a request handler to an event listener we can use [can-fixture-socket.requestHandlerToListener]:\n\nNow we can create socket event listeners for our CRUD operations:\n```js\nvar toListener = fixtureSocket.requestHandlerToListener\nmockServer.on(\"messages find\",   toListener( fixtureStore.getListData ));\nmockServer.on(\"messages get\",    toListener( fixtureStore.getData     ));\nmockServer.on(\"messages remove\", toListener( fixtureStore.destroyData ));\nmockServer.on(\"messages create\", toListener( fixtureStore.createData  ));\nmockServer.on(\"messages update\", toListener( fixtureStore.updateData  ));\n```\n\nThere is also a helper [can-fixture-socket.storeToListeners] to create all listeners at once:\n```\nvar listeners = fixtureSocket.storeToListeners(messagesStore);\nmockServer.on({\n\t\"messages find\": listeners.getListData,\n\t\"messages get\": listeners.getData,\n\t\"messages remove\": listeners.destroyData,\n\t\"messages create\": listeners.createData,\n\t\"messages update\": listeners.updateData\n});\n```\n\nNow lets implement a CRUD model on our client. We define that all our ACK callbacks take an error as the first argument, and data as the second one.\n```js\nvar socket = io(\"localhost\");\n\nsocket.emit(\"messages find\", {rank: \"good\"}, function(err, response){\n  if (err){\n    console.log(\"Error: \", err);\n    return;\n  }\n  console.log(`We found ${response.count} good items\", response.data);\n  assert.equal(response.count, 3)\n});\n```\n\nNow lets test the rest of the methods:\n```js\nsocket.emit(\"messages get\", {id: 1}, function(err, data){s\n  assert.deepEqual(data, {id: 1, title: \"One\"}, \"received the item\");\n});\nsocket.emit(\"messages update\", {id: 2, title: \"TwoPlus\"}, function(err, data){\n  assert.deepEqual(data, {id: 2, title: \"TwoPlus\"}, \"received the updated item\");\n});\nsocket.emit(\"messages get\", {id: 999}, function(err, data){\n  assert.deepEqual(err, {error: 404, message: \"no data\"}, \"received 404 when looking for a non-existent item id\");\n});\n```\n\n",
    "description": "\nIntercept socket.io messages and simulates socket.io server responses.\n",
    "type": "constructor",
    "name": "can-fixture-socket.Server",
    "title": "Server",
    "parent": "can-fixture-socket.properties",
    "signatures": [
      {
        "code": "new Server( io )",
        "description": "\n\nWhen server is instantiated with socket.io `io` object it intercepts a socket.io connection and allows to mock socket.io server behaviour. On instantiation we:\n  - empty `io.managers` object which is a cache of socket.io `io.Manager` instances;\n  - override `io.Manager.prototype` to work with current instance of the mocked server.\n  \n```js\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "io",
            "description": "Imported `socket.io-client` object.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "io",
      "description": "Imported `socket.io-client` object.\n"
    },
    "comment": " "
  },
  "subscribeFeathersStoreToServer": {
    "type": "function",
    "name": "subscribeFeathersStoreToServer",
    "params": [
      {
        "name": "serviceName",
        "description": ""
      },
      {
        "name": "fixtureStore",
        "description": ""
      },
      {
        "name": "mockServer",
        "description": ""
      },
      {
        "name": "options",
        "description": ""
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 42,
      "codeLine": 54,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "\nfixture.store data:\n\t\tgetListData: {}\n\n",
    "description": "Subscribes to mocked socket server events for FeathersJS service.\nTransforms ((query, fn))\n",
    "_curParam": {
      "name": "options",
      "description": ""
    },
    "returns": "{*}"
  },
  "wrapToId": {
    "type": "function",
    "name": "wrapToId",
    "params": [
      {
        "name": "options",
        "description": ""
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 86,
      "codeLine": 91,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "\n",
    "description": "Wraps given id into an object with property name `id` (or options.id).\n",
    "_curParam": {
      "name": "options",
      "description": ""
    },
    "returns": "{Function}"
  },
  "toFeathersRemoveHandler": {
    "type": "function",
    "name": "toFeathersRemoveHandler",
    "params": [
      {
        "name": "getData",
        "description": "The wrapped fixture.store.getData method."
      },
      {
        "name": "destroyData",
        "description": "The wrapped fixture.store.destroyData method."
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 118,
      "codeLine": 128,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "\nFeathers `remove` method emits 2 arguments with data: `id` and `query`. But we ignore 2nd data argument for now.\n\n\n",
    "description": "FeathersJS's `remove` method returns the whole item back, when fixture.store's `destroyData` gives back only the given query (e.g. {id: 123}).\nFind the item by id first, then remove from fixture.store and return the item back.\n",
    "_curParam": {
      "name": "getData",
      "description": "The wrapped fixture.store.getData method."
    },
    "returns": "{Function}"
  },
  "can-fixture-socket.Server.prototype.on": {
    "type": "function",
    "name": "can-fixture-socket.Server.prototype.on",
    "parent": "can-fixture-socket.Server.prototype",
    "src": {
      "line": 37,
      "codeLine": 71,
      "path": "node_modules/can-fixture-socket/src/index.js"
    },
    "body": "\n",
    "description": "\nAdds a socket event listener.\n",
    "title": "on",
    "signatures": [
      {
        "code": "server.on(event, handler)",
        "description": "\n\nAdds a socket event listener.\n\n```js\nserver.on(\"notifications\", function(data, ackFn){\n  console.log(\"Received \" + data);\n  ackFn(\"Acknowledged, thank you\");\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "string"
              }
            ],
            "name": "event",
            "description": "The name of the socket event to listen for."
          },
          {
            "types": [
              {
                "type": "can-fixture-socket.socket-event-listener"
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the socket event.\n"
          }
        ]
      },
      {
        "code": "server.on(eventsObject)",
        "description": "\n\nA short hand method to add multiple event listeners.\n\n```js\nserver.on({\n  \"news\": handleNews,\n  \"tweets\": handleTweets,\n  \"users\": handleUsers\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "object"
              }
            ],
            "name": "eventsObject",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "object"
        }
      ],
      "name": "eventsObject",
      "description": "\n"
    }
  },
  "can-fixture-socket.Server.prototype.emit": {
    "type": "function",
    "name": "can-fixture-socket.Server.prototype.emit",
    "parent": "can-fixture-socket.Server.prototype",
    "src": {
      "line": 85,
      "codeLine": 105,
      "path": "node_modules/can-fixture-socket/src/index.js"
    },
    "body": "\n",
    "description": "\nEmits a socket event.\n",
    "title": "emit",
    "signatures": [
      {
        "code": "server.emit(event, ...data, [ackFn])",
        "description": "\n\nEmits a socket event.\n\n```js\nserver.emit(\"news\", data1, data2, function(ackData){\n  console.log(\"Client acknowledged\", ackData);\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "string"
              }
            ],
            "name": "event",
            "description": "The name of the socket event."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "data",
            "description": "Data to be sent with the event. Socket.io allows to send more than one data objects."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "ackFn",
            "description": "The acknowledgement function that will be executed if the receiver calls the acknowledgement callback.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "ackFn",
      "description": "The acknowledgement function that will be executed if the receiver calls the acknowledgement callback.\n"
    }
  },
  "can-fixture-socket.Server.prototype.restore": {
    "type": "function",
    "name": "can-fixture-socket.Server.prototype.restore",
    "parent": "can-fixture-socket.Server.prototype",
    "src": {
      "line": 123,
      "codeLine": 135,
      "path": "node_modules/can-fixture-socket/src/index.js"
    },
    "body": "",
    "description": "\n",
    "title": "restore",
    "signatures": [
      {
        "code": "server.restore()",
        "description": "\n\nRestores `io.Manager.prototype` and clears `io.managers` cache.\n\n```\nserver.restore();\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture-socket.requestHandlerToListener": {
    "type": "function",
    "name": "can-fixture-socket.requestHandlerToListener",
    "parent": "can-fixture-socket.properties",
    "src": {
      "line": 2,
      "codeLine": 50,
      "path": "node_modules/can-fixture-socket/src/store.js"
    },
    "body": "\n\n\n## Use\n\nFixture [can-fixture.store] methods expect two arguments `req` and `res` and work like this:\n  - grab query from `req.data`;\n  - on error call `res( 403, err )`;\n  - on success call `res( data )`.\n  \nThe format of the returned data is:\n  - for [can-fixture/StoreType.prototype.getDataList]: {count: <number>, limit: <number>, offset: <number> , data: [{...},{...}, ...]}\n  - for [can-fixture/StoreType.prototype.getData]: the item object.\n\nWe can use the helper to transform fixture store methods into event listeners:\n```js\nvar fixture = require(\"can-fixture\");\nvar canSet = require(\"can-set\");\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\n\n// Create fixture store:\nvar fixtureStore = fixture.store([\n  {id: 1, title: 'One'},\n  {id: 2, title: 'Two'},\n  {id: 3, title: 'Three'}\n], new canSet.Algebra({}));\n\nvar mockedServer = new fixtureSocket.Server(io);\nmockedServer.on(\"books find\", fixtureStore.requestHandlerToListener( fixtureStore.getListData ));\n```\n\n",
    "description": "\nTransforms XHR request handler into socket event listener.\n",
    "title": "requestHandlerToListener",
    "signatures": [
      {
        "code": "requestHandlerToListener( reqHandler )",
        "description": "\n\nTransforms request handler that expects two arguments `request` and `response` into socket event listener.\n\n```js\nserver.on(\"news find\", requestHandlerToListener( fixtureStore.getListData ));\n```\n    ",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "reqHandler",
            "description": "A request handler, e.g. [can-fixture/StoreType.prototype.getListData]."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "reqHandler",
      "description": "A request handler, e.g. [can-fixture/StoreType.prototype.getListData]."
    },
    "returns": "{can-fixture-store.socket-event-listener}",
    "comment": " "
  },
  "can-fixture-socket.storeToListeners": {
    "type": "function",
    "name": "can-fixture-socket.storeToListeners",
    "parent": "can-fixture-socket.properties",
    "src": {
      "line": 65,
      "codeLine": 122,
      "path": "node_modules/can-fixture-socket/src/store.js"
    },
    "body": "\n\n\n## Use\n\nFixture [can-fixture.store] provides REST-ful resource storage. Its designed to work with XHR requests thus its methods expect two arguments `request` and `response`. To work with socket events we need to transform request handlers into socket event listeners.\n\nHere is how we can do this:\n\n```js\nvar fixture = require(\"can-fixture\");\nvar canSet = require(\"can-set\");\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\n\n// Create fixture store:\nvar fixtureStore = fixture.store([\n  {id: 1, title: 'One'},\n  {id: 2, title: 'Two'},\n  {id: 3, title: 'Three'}\n], new canSet.Algebra({}));\n\n// Instantiate mocked socket server:\nvar mockedServer = new fixtureSocket.Server(io);\n\n// Now use fixture store to emulate REST-ful service:\nvar toListener = fixtureStore.requestHandlerToListener;\nmockedServer.on({\n  \"books find\":   toListener( fixtureStore.getListData ),\n  \"books get\":    toListener( fixtureStore.getData ),\n  \"books create\": toListener( fixtureStore.createData ),\n  \"books update\": toListener( fixtureStore.updateData ),\n  \"books delete\": toListener( fixtureStore.destroyData )\n});\n```\n\n",
    "description": "\nReturns a set of listeners transformed from fixture store request handlers. Useful for working with REST-ful resources.\n",
    "title": "storeToListeners",
    "signatures": [
      {
        "code": "storeToListeners( fixtureStore )",
        "description": "\n\nWraps methods of fixture.store to make them socket event listener.\n\n```js\nvar listeners = storeToListeners( fixtureStore );\n\nserver.on({\n  \"news find\": listeners.getListData,\n  \"news get\": listeners.getData,\n})\n```\n",
        "params": [
          {
            "name": "fixtureStore",
            "description": ""
          }
        ]
      }
    ],
    "_curParam": {
      "name": "fixtureStore",
      "description": ""
    },
    "returns": "{*}",
    "comment": " "
  },
  "can-jquery.modules": {
    "name": "can-jquery.modules",
    "title": "Modules",
    "type": "group",
    "parent": "can-jquery",
    "description": "",
    "order": 0
  },
  "can-jquery.fns": {
    "name": "can-jquery.fns",
    "title": "Methods",
    "type": "group",
    "parent": "can-jquery",
    "description": "",
    "order": 1
  },
  "can-jquery": {
    "src": {
      "path": "node_modules/can-jquery/docs/can-jquery.md"
    },
    "body": "\nUsing `can-jquery` causes the two event systems to be cross-bound. You can listen to special events within [can-stache-bindings] using jQuery and you can listen to custom jQuery events within [can-control]s.\n\n## Listening to inserted/removed events\n\nUsing `can-jquery` you can listen to the removed/inserted event on an element.\n\n```js\nvar $ = require(\"can-jquery\");\n\nvar el = $(\"<div>\");\n\nel.on(\"inserted\", function(){\n\t// The element was inserted.\n});\n\n$(document.body).append(el);\n```\n\n## Listening to jQuery events within Controls\n\nInside a [can-control] you can listen to any custom jQuery events.\n\n```js\nvar $ = require(\"can-jquery\");\nvar Control = require(\"can-control\");\n\nvar MyControl = Control.extend({\n\t\"names-added\": function(el, ev, first, second, third){\n\t\t// first is \"Matthew\"\n\t\t// second is \"David\"\n\t\t// third is \"Brian\"\n\t}\n});\n\nvar dom = $(\"<div><ul></ul></div>\");\n\nnew MyControl(dom);\n\ndom.find(\"ul\").trigger(\"names-added\", [\n\t\"Matthew\",\n\t\"David\",\n\t\"Brian\"\n]);\n```\n\n",
    "description": "Extensions to the event system so that can events and jQuery events are cross-bound. \n",
    "type": "module",
    "title": "can-jquery",
    "types": [
      {
        "type": "jQuery"
      }
    ],
    "name": "can-jquery",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": [
            {
              "can-jquery": [
                "can-jquery/legacy"
              ]
            }
          ]
        },
        "parent": "can-jquery"
      },
      "dependencies": {
        "can-event": "^3.0.1",
        "can-util": "^3.3.3",
        "can-view-model": "^3.0.0",
        "jquery": "2.x - 3.x"
      },
      "description": "CanJS integrations for jQuery",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-component": "^3.0.0",
        "can-control": "^3.0.10",
        "can-define": "^1.0.0",
        "can-list": "^3.0.0",
        "can-map": "^3.0.0",
        "can-stache": "^3.0.0",
        "can-stache-bindings": "^3.0.8",
        "can-vdom": "^3.0.2",
        "done-serve": "^1.0.0",
        "donejs-cli": "^1.0.0",
        "generator-donejs": "^1.0.0",
        "jshint": "^2.9.1",
        "steal": "^1.3.2",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.2.0",
        "testee": "^0.4.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs"
      ],
      "main": "can-jquery.js",
      "name": "can-jquery",
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.0.7"
    },
    "signatures": [
      {
        "code": "jQuery",
        "description": "\n\nImporting `can-jquery` will return the [jQuery object](http://api.jquery.com/jquery/) and wire up the event system.\n\n```js\nvar $ = require(\"can-jquery\");\n\nvar div = $(\"<div>\");\n\ndiv.on(\"inserted\", function(){\n\t// it inserted!\n});\n\n$(\"body\").append(div);\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-jquery/legacy": {
    "src": {
      "path": "node_modules/can-jquery/docs/legacy.md"
    },
    "body": "\nImporting can-jquery/legacy will also bring in [can-jquery], but also has the side effect of enabling jQuery wrappers being applied to places such as [can-control]s and [can-stache-bindings.event] callbacks.\n\n***Note*** that simply importing can-jquery-legacy will enable this, so any [can-control]s expecting to receive the raw [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) will break.\n\n```js\nvar $ = require(\"can-jquery/legacy\");\nvar Control = require(\"can-control\");\n\nvar MyControl = Control.extend({\n\t\"li click\": function(el){\n\t\t// `el` is jQuery wrapped!\n\t}\n});\n\nvar dom = $(\"<div><ul><li>First</li><li>Second</li></ul></div>\");\nnew MyControl(dom);\n\ndom.find(\"li:first\").trigger(\"click\");\n```\n\n",
    "description": "Enables legacy integrations between CanJS and jQuery. \nImporting can/jquery/legacy will return the [jQuery object](http://api.jquery.com/jquery/). It will also import [can-jquery] so that the event system hooks are set up.\n\nAdditionally it will force element callbacks (such as those in [can-control]) to be jQuery wrapped.\n\n```js\nvar $ = require(\"can-jquery/legacy\");\n```\n\n",
    "type": "module",
    "title": "can-jquery/legacy",
    "types": [
      {
        "type": "jQuery"
      }
    ],
    "name": "can-jquery/legacy",
    "parent": "can-jquery.modules",
    "comment": " "
  },
  "can-jquery.fns.viewModel": {
    "src": {
      "path": "node_modules/can-jquery/docs/viewModel.md"
    },
    "body": "",
    "description": "Gets an element's View Model. \n",
    "title": "viewModel",
    "name": "can-jquery.fns.viewModel",
    "type": "function",
    "parent": "can-jquery.fns",
    "signatures": [
      {
        "code": ".viewModel()",
        "description": "\n\nCalls [can-view-model] with the unwrapped HTMLElement.\n\n```js\nvar vm = $(\"my-component\").viewModel();\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            },
            {
              "type": "can-map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the View Model set for this element.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        },
        {
          "type": "can-map"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the View Model set for this element.\n"
    }
  },
  "can.view.elements": {
    "name": "can.view.elements",
    "type": "property",
    "parent": "can.view",
    "src": {
      "line": 6,
      "codeLine": 13,
      "path": "node_modules/can-legacy-view-helpers/src/elements.js"
    },
    "body": "\n",
    "description": "\nProvides helper methods for and information about the behavior\nof DOM elements.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": ""
  },
  "can.view.elements.attrMap": {
    "body": "\nA mapping of\nspecial attributes to their JS property. For example:\n\n    \"class\" : \"className\"\n\nmeans get or set `element.className`. And:\n\n     \"checked\" : true\n\nmeans set `element.checked = true`.\n\n\nIf the attribute name is not found, it's assumed to use\n`element.getAttribute` and `element.setAttribute`.\n \n",
    "description": "\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Boolean"
              },
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "title": "",
    "name": "can.view.elements.attrMap",
    "type": "property",
    "parent": "can.view.elements"
  },
  "can.view.elements.tagMap": {
    "name": "can.view.elements.tagMap",
    "type": "property",
    "parent": "can.view.elements",
    "src": {
      "line": 38,
      "codeLine": 47,
      "path": "node_modules/can-legacy-view-helpers/src/elements.js"
    },
    "body": " \n",
    "description": "\nA mapping of parent node names to child node names that can be inserted within\nthe parent node name.  For example: `table: \"tbody\"` means that\nif you want a placeholder element within a `table`, a `tbody` will be\ncreated.\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "title": ""
  },
  "pendingHookups": {
    "name": "pendingHookups",
    "type": "property",
    "parent": "node_modules/can-legacy-view-helpers/src/render.js",
    "src": {
      "line": 6,
      "codeLine": 9,
      "path": "node_modules/can-legacy-view-helpers/src/render.js"
    },
    "body": "\n",
    "description": "Helper(s)\n"
  },
  "can.view.txt": {
    "type": "function",
    "name": "can.view.txt",
    "parent": "node_modules/can-legacy-view-helpers/src/render.js",
    "src": {
      "line": 102,
      "codeLine": 131,
      "path": "node_modules/can-legacy-view-helpers/src/render.js"
    },
    "body": "\n",
    "description": "\nA helper function used to insert the\nvalue of the contents of a magic tag into\na template's output. It detects if an observable value is\nread and will setup live binding.\n",
    "title": "",
    "hide": true,
    "signatures": [
      {
        "code": "can.view.txt(escape, tagName, status, self, func)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "1",
            "description": "if the content returned should be escaped, 0 if otherwise."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "the name of the tag the magic tag is most immediately\nwithin. Ex: `\"li\"`."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "name": "status",
            "description": "A flag indicates which part of a tag the\nmagic tag is within. Status can be:\n\n - _STRING_ - The name of the attribute the magic tag is within. Ex: `\"class\"`\n - `1` - The magic tag is within a tag like `<div <%= %>>`\n - `0` - The magic tag is outside (or between) tags like `<div><%= %></div>`\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "self",
            "description": "The `this` of the current context template. `func` is called with\nself as this.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "func",
            "description": "The \"wrapping\" function. For\nexample:  `<%= task.attr('name') %>` becomes\n  `(function(){return task.attr('name')})\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "func",
      "description": "The \"wrapping\" function. For\nexample:  `<%= task.attr('name') %>` becomes\n  `(function(){return task.attr('name')})\n\n "
    }
  },
  "elements": {
    "name": "elements",
    "type": "property",
    "parent": "node_modules/can-legacy-view-helpers/src/scanner.js",
    "src": {
      "line": 0,
      "codeLine": 5,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n",
    "description": "This module must be CJS format because is uses `with () { ... }`\nstatements which will not work in ES6 since it forces strict mode.\n"
  },
  "newLine": {
    "name": "newLine",
    "type": "property",
    "parent": "node_modules/can-legacy-view-helpers/src/scanner.js",
    "src": {
      "line": 10,
      "codeLine": 13,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n",
    "description": "Helper(s)\n"
  },
  "can.view.Scanner": {
    "type": "constructor",
    "name": "can.view.Scanner",
    "params": [
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "Object",
            "options": [
              {
                "name": "text",
                "types": [
                  {
                    "type": "can.view.Scanner.text"
                  }
                ]
              },
              {
                "name": "tokens",
                "types": [
                  {
                    "type": "Array",
                    "template": [
                      {
                        "types": [
                          {
                            "type": "can.view.Scanner.token"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "name": "helpers",
                "types": [
                  {
                    "type": "Array",
                    "template": [
                      {
                        "types": [
                          {
                            "type": "can.view.Scanner.helpers"
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "description": "\n"
      }
    ],
    "parent": "node_modules/can-legacy-view-helpers/src/scanner.js",
    "src": {
      "line": 84,
      "codeLine": 97,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n\n",
    "description": "\ncan.view.Scanner is used to convert a template into a JavaScript function.  That\nfunction is called to produce a rendered result as a string. Often\nthe rendered result will include data-view-id attributes on elements that\nwill be processed after the template is used to create a document fragment.\n",
    "title": "",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "text",
              "types": [
                {
                  "type": "can.view.Scanner.text"
                }
              ]
            },
            {
              "name": "tokens",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can.view.Scanner.token"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "helpers",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can.view.Scanner.helpers"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    }
  },
  "can.view.Scanner.text": {
    "name": "can.view.Scanner.text",
    "type": "typedef",
    "parent": "can.view.Scanner",
    "src": {
      "line": 100,
      "codeLine": 103,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "",
    "description": "\t \n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "start",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "escape",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "scope",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "options",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ]
  },
  "can.view.Scanner.prototype": {
    "name": "can.view.Scanner.prototype",
    "type": "property",
    "parent": "can.view.Scanner",
    "src": {
      "line": 159,
      "codeLine": 162,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n",
    "description": "Extend can.View to add scanner support.\n"
  },
  "can.view": {
    "name": "can.view",
    "type": "add",
    "description": "undefined\n"
  },
  "can.view.frag": {
    "type": "function",
    "name": "can.view.frag",
    "params": [
      {
        "name": "result",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "parentNode",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can.view.static",
    "src": {
      "line": 42,
      "codeLine": 46,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": "",
    "description": " \n",
    "title": "frag"
  },
  "can.view.hookup": {
    "type": "function",
    "name": "can.view.hookup",
    "params": [
      {
        "name": "fragment",
        "description": ""
      },
      {
        "name": "parentNode",
        "description": ""
      }
    ],
    "parent": "can.view",
    "src": {
      "line": 76,
      "codeLine": 83,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": "",
    "description": "hook up a fragment to its parent node\n",
    "hide": true,
    "_curParam": {
      "name": "parentNode",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "\n "
    }
  },
  "can.view.hookups": {
    "name": "can.view.hookups",
    "type": "property",
    "parent": "can.view",
    "src": {
      "line": 109,
      "codeLine": 114,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": " \n",
    "description": "A list of pending 'hookups'\n",
    "title": "",
    "hide": true
  },
  "can.view.hook": {
    "type": "function",
    "name": "can.view.hook",
    "parent": "can.view.static",
    "src": {
      "line": 119,
      "codeLine": 137,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": "Registers a hookup function that can be called back after the html is\nput on the page.  Typically this is handled by the template engine.  Currently\nonly EJS supports this functionality.\n\n    var id = can.view.hook(function(el){\n           //do something with el\n        }),\n        html = \"<div data-view-id='\"+id+\"'>\"\n    $('.foo').html(html);\n \n",
    "description": "Create a hookup to insert into templates. ",
    "title": "hook",
    "signatures": [
      {
        "code": "can.view.hook(callback)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "callback",
            "description": "A callback function to be called with the element.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "callback",
      "description": "A callback function to be called with the element.\n"
    },
    "comment": " "
  },
  "can.view.cached": {
    "name": "can.view.cached",
    "type": "property",
    "parent": "can.view",
    "src": {
      "line": 142,
      "codeLine": 148,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": " \n",
    "description": "Cached are put in this object\n",
    "hide": true,
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "view"
  },
  "can-list.Map": {
    "src": {
      "path": "node_modules/can-list/docs/Map.md"
    },
    "body": "",
    "description": "Specify the Map type used to make objects added to this list observable. \n",
    "types": [
      {
        "type": "can-map",
        "description": "When objects are added to a `List`, those objects are converted into can.Map instances. For example:\n\n     var list = new List();\n     list.push({name: \"Justin\"});\n\n     var map = list.attr(0);\n     map.attr(\"name\") //-> \"Justin\"\n\nBy changing [can-list.Map], you can specify a different type of Map instance to create. For example:\n\n     var User = Map.extend({\n       fullName: function(){\n         return this.attr(\"first\")+\" \"+this.attr(\"last\")\n       }\n     });\n\n     User.List = List.extend({\n       Map: User\n     }, {});\n\n     var list = new User.List();\n     list.push({first: \"Justin\", last: \"Meyer\"});\n\n     var user = list.attr(0);\n     user.fullName() //-> \"Justin Meyer\"\n"
      }
    ],
    "title": "Map",
    "name": "can-list.Map",
    "type": "property",
    "parent": "can-list.static"
  },
  "can-list.extend": {
    "src": {
      "path": "node_modules/can-list/docs/extend.md"
    },
    "body": "",
    "description": "\n",
    "title": "extend",
    "name": "can-list.extend",
    "type": "function",
    "parent": "can-list.static",
    "signatures": [
      {
        "code": "List.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function. Learn more at [can.Construct.extend].\n\n```js\nvar MyList = List.extend({}, {\n\t// silly unnecessary method\n\tcount: function(){\n\t\treturn this.attr('length');\n\t}\n});\n\nvar list = new MyList([{}, {}]);\nconsole.log(list.count()); // -> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "If provided, adds the extened List constructor function to the window at the given name.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties and methods directly on the constructor function. The most common property to set is [can-list.Map].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "instanceProperties",
            "description": "Properties and methods on instances of this list type.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "instanceProperties",
      "description": "Properties and methods on instances of this list type.\n"
    }
  },
  "can-list.prototype.filter": {
    "src": {
      "path": "node_modules/can-list/docs/filter.md"
    },
    "body": "\nA filter function that accepts a function, which is run on every element of the list.  If the \nfilter callback returns true, the list returned will contain this item, false and it will not.\n\nReturns a new List instance.\n\t\n\tvar list = new List([1, 2, 3])\n\n\t// returns new List([1, 2])\n\tvar filtered = list.filter( function(item, index, list)\n\t{\n\t\treturn item < 3;\n\t}); \n\n",
    "description": "Filter the elements of a List, returning a new List instance with just filtered items. \n",
    "title": "filter",
    "name": "can-list.prototype.filter",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.filter(filterFunc, context)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "Boolean"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can.List"
                      }
                    ],
                    "name": "list"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "filterFunc",
            "description": "A function to call with each element of the list. Returning `false` will remove the index."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "The object to use as `this` inside the callback.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "context",
      "description": "The object to use as `this` inside the callback.\n"
    },
    "comment": " "
  },
  "can-list.prototype": {
    "name": "can-list.prototype",
    "title": "Prototype",
    "type": "group",
    "parent": "can-list",
    "description": "",
    "order": 0
  },
  "can-list.static": {
    "name": "can-list.static",
    "title": "Static",
    "type": "group",
    "parent": "can-list",
    "description": "",
    "order": 1
  },
  "can-list.prototype.attr": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.attr.md"
    },
    "body": "\n\n## Use\n\n`attr` gets or sets elements on the `List` it's called on. Here's a tour through how all of its forms work:\n\n     var people = new List(['Alex', 'Bill']);\n\n     // set an element:\n     people.attr(0, 'Adam');\n\n     // get an element:\n     people.attr(0); // 'Adam'\n     people[0]; // 'Adam'\n\n     // get all elements:\n     people.attr(); // ['Adam', 'Bill']\n\n     // extend the array:\n     people.attr(4, 'Charlie');\n     people.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n     // merge the elements:\n     people.attr(['Alice', 'Bob', 'Eve']);\n     people.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']\n\n## Deep properties\n\n`attr` can also set and read deep properties. All you have to do is specify the property name as you normally would if you weren't using `attr`.\n\n```\nvar people = new List([{name: 'Alex'}, {name: 'Bob'}]);\n\n// set a property:\npeople.attr('0.name', 'Alice');\n\n// get a property:\npeople.attr('0.name');  // 'Alice'\npeople[0].attr('name'); // 'Alice'\n\n// get all properties:\npeople.attr(); // [{name: 'Alice'}, {name: 'Bob'}]\n```\n\nThe discussion of deep properties under `[can-map.prototype.attr]` may also be enlightening.\n\n## Events\n\n`List`s emit five types of events in response to changes. They are:\n\n- the _change_ event fires on every change to a List.\n- the _set_ event is fired when an element is set.\n- the _add_ event is fired when an element is added to the List.\n- the _remove_ event is fired when an element is removed from the List.\n- the _length_ event is fired when the length of the List changes.\n\n### The _change_ event\n\nThe first event that is fired is the _change_ event. The _change_ event is useful\nif you want to react to all changes on an List.\n\n```\nvar list = new List([]);\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log('Something changed.');\n});\n```\n\nThe parameters of the event handler for the _change_ event are:\n\n- _ev_ The event object.\n- _index_ Where the change took place.\n- _how_ Whether elements were added, removed, or set.\n Possible values are `'add'`, `'remove'`, or `'set'`.\n- _newVal_ The elements affected after the change\n _newVal_ will be a single value when an index is set, an Array when elements\nwere added, and `undefined` if elements were removed.\n- _oldVal_ The elements affected before the change.\n_newVal_ will be a single value when an index is set, an Array when elements\nwere removed, and `undefined` if elements were added.\n\nHere is a concrete tour through the _change_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\nlist.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined\nlist.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined\nlist.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis\nlist.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam\n                               // [object Object], 1, set, Bob, Bill\nlist.removeAttr(1);            // [object Object], 1, remove, undefined, Bob\n```\n\n### The _set_ event\n\n_set_ events are fired when an element at an index that already exists in the List is modified. Actions can cause _set_ events to fire never also cause _length_ events to fire (although some functions, such as `[can-list.prototype.splice splice]` may cause unrelated sets of events to fire after being batched).\n\nThe parameters of the event handler for the _set_ event are:\n\n- _ev_ The event object.\n- _newVal_ The new value of the element.\n- _index_ where the set took place.\n\nHere is a concrete tour through the _set_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('set', function(ev, newVal, index) {\n    console.log(newVal + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');\nlist.attr(0, 'Adam');          // Adam, 0\nlist.attr(['Alice', 'Bob']);   // Alice, 0\n                               // Bob, 1\nlist.removeAttr(1);\n```\n\n### The _add_ event\n\n_add_ events are fired when elements are added or inserted\ninto the List.\n\nThe parameters of the event handler for the _add_ event are:\n\n- _ev_ The event object.\n- _newElements_ The new elements.\n If more than one element is added, _newElements_ will be an array. Otherwise, it is simply the new element itself.\n- _index_ Where the add or insert took place.\n\nHere is a concrete tour through the _add_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('add', function(ev, newElements, index) {\n    console.log(newElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0\nlist.attr(2, 'Eve');           // Eve, 2\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);\n```\n\n### The _remove_ event\n\n_remove_ events are fired when elements are removed from the list.\n\nThe parameters of the event handler for the _remove_ event are:\n\n- _ev_ The event object.\n- _removedElements_ The removed elements.\n If more than one element was removed, _removedElements_ will be an array. Otherwise, it is simply the element itself.\n- _index_ Where the removal took place.\n\nHere is a concrete tour through the _remove_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('remove', function(ev, removedElements, index) {\n    console.log(removedElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);            // Bob, 1\n```\n\n### The _length_ event\n\n_length_ events are fired whenever the list changes.\n\nThe parameters of the event handler for the _length_ event are:\n\n- _ev_ The event object.\n- _length_ The current length of the list.\n If events were batched when the _length_ event was triggered, _length_ will have the length of the list when `stopBatch` was called. Because of this, you may receive multiple _length_ events with the same _length_ parameter.\n\nHere is a concrete tour through the _length_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('length', function(ev, length) {\n    console.log(length);\n});\n\nlist.attr(['Alexis', 'Bill']); // 2\nlist.attr(2, 'Eve');           // 3\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);            // 2\n```\n\n",
    "description": "Get or set elements in a List. \n",
    "title": "attr",
    "name": "can-list.prototype.attr",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.attr()",
        "description": "\n\nGets an array of all the elements in this `List`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "An array with all the elements in this List.\n"
        }
      },
      {
        "code": "list.attr(index)",
        "description": "\n\nReads an element from this `List`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The element to read."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at _index_.\n"
        }
      },
      {
        "code": "list.attr(index, value)",
        "description": "\n\nAssigns _value_ to the index _index_ on this `List`, expanding the list if necessary.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The element to set."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign at _index_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      },
      {
        "code": "list.attr(elements[, replaceCompletely])",
        "description": "\n\nMerges the members of _elements_ into this List, replacing each from the beginning in order. If _elements_ is longer than the current List, the current List will be expanded. If _elements_ is shorter than the current List, the extra existing members are not affected (unless _replaceCompletely_ is `true`). To remove elements without replacing them, use `[can-map::removeAttr removeAttr]`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "elements",
            "description": "An array of elements to merge in.\n"
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "replaceCompletely",
            "defaultValue": "false",
            "description": "whether to completely replace the elements of List\n\nIf _replaceCompletely_ is `true` and _elements_ is shorter than the List, the existing extra members of the List will be removed.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "This list, for chaining.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "replaceCompletely",
      "defaultValue": "false",
      "description": "whether to completely replace the elements of List\n\nIf _replaceCompletely_ is `true` and _elements_ is shorter than the List, the existing extra members of the List will be removed.\n"
    },
    "comment": " "
  },
  "can-list.prototype.each": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.each.md"
    },
    "body": "```\nvar i = 0;\nnew List([1, 10, 100]).each(function(element, index) {\n    i += element;\n});\n\ni; // 111\n\ni = 0;\nnew List([1, 10, 100]).each(function(element, index) {\n    i += element;\n    if(index >= 1) {\n        return false;\n    }\n});\n\ni; // 11\n```\n\n",
    "description": "Call a function on each element of a List. ",
    "name": "can-list.prototype.each",
    "title": "each",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.each( callback(item, index) )",
        "description": "\n\n`each` iterates through the List, calling a function\nfor each element.\n\n```js\nvar list = new List([1, 2, 3]);\n\nlist.each(function(elem){\n\tconsole.log(elem);\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "this List, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "this List, for chaining\n"
    },
    "comment": " "
  },
  "can-list.prototype.map": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.map.md"
    },
    "body": "```\nvar list = new List([1, 10, 100, 1000, 10000, 100000]);\nvar newList = list.map(function(element, index, listReference) {\n  var result;\n\n  switch(index) {\n    case 0: {\n      result = false;\n      break;\n    }\n    case 1: {\n      result = undefined;\n      break;\n    }\n    case 2: {\n      result = element;\n      break;\n    }\n    case 3: {\n      result = element * 5;\n      break;\n    }\n    default: {\n      result = listReference[index] /= 2;\n      break;\n    }\n  }\n\n  return result;\n});\n\nconsole.log(list);    // [    1,        10, 100, 1000, 5000, 50000]\nconsole.log(newList); // [false, undefined, 100, 5000, 5000, 50000]\n```\n\n",
    "description": "Call a function on each element of a List and return a new List instance from the results. ",
    "title": "map",
    "name": "can-list.prototype.map",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.map( callback(item, index, listReference), context )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can.List"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each\nelement of the list."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "An optional object to use as `this` inside the callback.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "A new can.List instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "context",
      "description": "An optional object to use as `this` inside the callback.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "A new can.List instance.\n"
    },
    "comment": " "
  },
  "can-list.prototype.reverse": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.reverse.md"
    },
    "body": "```\nvar list = new List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n\n`reverse` calls `replace` internally and triggers corresponding `add`, `remove`, `change` and `length` events respectively.\n\n## Demo\n\n<div class='iframe_wrapper' data-iframe-src='can/list/doc/reverse.html' data-iframe-height='350'></div>\n",
    "description": "Reverse the order of a List. ",
    "title": "reverse",
    "name": "can-list.prototype.reverse",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\n`reverse` reverses the elements of the List in place.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "the List, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-list"
        }
      ],
      "description": "the List, for chaining\n"
    },
    "comment": " "
  },
  "can-list.prototype.splice": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.splice.md"
    },
    "body": " `splice` lets you remove elements from and insert elements into a List.\n\n This example demonstrates how to do surgery on a list of numbers:\n\n```\n var list = new List([0, 1, 2, 3]);\n\n // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n list.splice(2, 1, 'Alice', 'Bob');\n list.attr(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n ## Events\n\n `splice` causes the List it's called on to emit _change_ events,\n _add_ events, _remove_ events, and _length_ events. If there are\n any elements to remove, a _change_ event, a _remove_ event, and a\n _length_ event will be fired. If there are any elements to insert, a\n separate _change_ event, an _add_ event, and a separate _length_ event\n will be fired.\n\n This slightly-modified version of the above example should help\n make it clear how `splice` causes events to be emitted:\n\n```\n var list = new List(['a', 'b', 'c', 'd']);\n list.bind('change', function(ev, attr, how, newVals, oldVals) {\n     console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n });\n list.bind('add', function(ev, newVals, where) {\n     console.log('add: ' + newVals + ', ' + where);\n });\n list.bind('remove', function(ev, oldVals, where) {\n     console.log('remove: ' + oldVals + ', ' + where);\n });\n list.bind('length', function(ev, length) {\n     console.log('length: ' + length + ', ' + this.attr());\n });\n\n // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n list.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                    // remove: ['c'], 2\n                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                    // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                    // add: ['Alice', 'Bob'], 2\n                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n```\n\n More information about binding to these events can be found under [can.List.attr attr].\n\n",
    "description": "Insert and remove elements from a List. ",
    "title": "splice",
    "name": "can-list.prototype.splice",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newElements]])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "where to start removing or inserting elements\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "the number of elements to remove\n If _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the List.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newElements",
            "description": "elements to insert into the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the elements removed by `splice`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newElements",
      "description": "elements to insert into the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the elements removed by `splice`\n"
    },
    "comment": " "
  },
  "can-map.prototype": {
    "name": "can-map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-map",
    "description": "",
    "order": 0
  },
  "can-map.static": {
    "name": "can-map.static",
    "title": "static",
    "type": "group",
    "parent": "can-map",
    "description": "",
    "order": 1
  },
  "can-map.prototype.attr": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.attr.md"
    },
    "body": "`attr` gets or sets properties on the `Map` it's called on. Here's a tour through\nhow all of its forms work:\n\n\n    var people = new Map({});\n\n    // set a property:\n    people.attr('a', 'Alex');\n\n    // get a property:\n    people.attr('a'); // 'Alex'\n\n    // set and merge multiple properties:\n    people.attr({\n        a: 'Alice',\n        b: 'Bob'\n    });\n\n    // get all properties:\n    people.attr(); // {a: 'Alice', b: 'Bob'}\n\n    // set properties while removing others:\n    people.attr({\n        b: 'Bill',\n        e: 'Eve'\n    }, true);\n\n    people.attr(); // {b: 'Bill', e: 'Eve'}\n\n\n## Deep properties\n\n`attr` can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using `attr`.\n\n\n    var people = new Map({names: {}});\n\n    // set a property:\n    people.attr('names.a', 'Alice');\n\n    // get a property:\n    people.attr('names.a'); // 'Alice'\n    people.names.attr('a'); // 'Alice'\n\n    // get all properties:\n    people.attr(); // {names: {a: 'Alice'}}\n\n\nObjects that are added to Observes become Observes themselves behind the scenes,\nso changes to deep properties fire events at each level, and you can bind at any\nlevel. As this example shows, all the same events are fired no matter what level\nyou call `attr` at:\n\n\n    var people = new Map({names: {}});\n\n    people.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    people.names.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    people.bind('names', function(ev, newVal, oldVal) {\n        console.log('people names: ' + newVal + ', ' + oldVal);\n    });\n\n    people.names.bind('a', function(ev, newVal, oldVal) {\n        console.log('people.names a: ' + newVal + ', ' + oldVal);\n    });\n\n    people.bind('names.a', function(ev, newVal, oldVal) {\n        console.log('people names.a: ' + newVal + ', ' + oldVal);\n    });\n\n    people.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined\n                                  // people.names change: a, add, Alice, undefined\n                                  // people.names a: Alice, undefined\n                                  // people names.a: Alice, undefined\n\n    people.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined\n                                  // people.names change: b, add, Bob, undefined\n                                  // people.names b: Bob, undefined\n                                  // people names.b: Bob, undefined\n\n\n## Properties with dots in their name\n\nAs shown above, `attr` enables reading and setting deep properties so special care must be taken when property names include dots '`.`'. To read a property containing dots, escape each one using '`\\`'. This prevents `attr` from performing a deep lookup and throwing an error when the deep property is not found.\n\n```\nvar person = new Map({\n\t'first.name': 'Alice'\n});\n\nperson.attr('first.name'); // throws Error\nperson.attr('first\\.name'); // 'Alice'\n\n```\n\nWhen setting a property containing dots, pass an object to `attr` containing the property name and new value. Setting a property by passing a string to `attr` will attempt to set a deep property and will throw an error.\n\n```\nvar person = new Map({\n\t'first.name': 'Alice'\n});\n\nperson.attr('first.name', 'Bob'); // throws Error\nperson.attr('first\\.name', 'Bob'); // throws Error\nperson.attr({'first.name': 'Bob'}); // Works\n\n```\n\n## See also\n\nFor information on the events that are fired on property changes and how\nto listen for those events, see [can.Map.prototype.bind bind].\n\n",
    "description": "Get or set properties on a Map. \n",
    "title": "attr",
    "name": "can-map.prototype.attr",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 2,
    "signatures": [
      {
        "code": "map.attr()",
        "description": "\n\nGets a collection of all the properties in this `Map`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with all the properties in this `Map`.\n"
        }
      },
      {
        "code": "map.attr(key)",
        "description": "\n\nReads a property from this `Map`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the property to read"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value assigned to _key_.\n"
        }
      },
      {
        "code": "map.attr(key, value)",
        "description": "\n\nAssigns _value_ to a property on this `Map` called _key_.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the property to set"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "the",
            "description": "value to assign to _key_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      },
      {
        "code": "map.attr(obj[, removeOthers])",
        "description": "\n\nAssigns each value in _obj_ to a property on this `Map` named after the\ncorresponding key in _obj_, effectively merging _obj_ into the Map.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "a collection of key-value pairs to set.\nIf any properties already exist on the `Map`, they will be overwritten.\n"
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "removeOthers",
            "defaultValue": "false",
            "description": "whether to remove keys not present in _obj_.\nTo remove keys without setting other keys, use `[can.Map::removeAttr removeAttr]`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "removeOthers",
      "defaultValue": "false",
      "description": "whether to remove keys not present in _obj_.\nTo remove keys without setting other keys, use `[can.Map::removeAttr removeAttr]`.\n"
    },
    "comment": " "
  },
  "can-map.prototype.bind": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.bind.md"
    },
    "body": "`bind` binds event handlers to property changes on `Map`s. When you change\na property using `attr`, two events are fired on the Map, allowing other parts\nof your application to map the changes to the object.\n\n## The _change_ event\n\nThe first event that is fired is the _change_ event. The _change_ event is useful\nif you want to react to all changes on a Map.\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('Something changed.');\n    });\n\n\nThe parameters of the event handler for the _change_ event are:\n\n- _ev_ The event object.\n- _attr_ Which property changed.\n- _how_ Whether the property was added, removed, or set. Possible values are `'add'`, `'remove'`, or `'set'`.\n- _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n- _oldVal_ This is the value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\nHere is a concrete tour through the _change_ event handler's arguments:\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log(ev + ', ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    o.attr('a', 'Alexis'); // [object Object], a, add, Alexis, undefined\n    o.attr('a', 'Adam');   // [object Object], a, set, Adam, Alexis\n    o.attr({\n        'a': 'Alice',      // [object Object], a, set, Alice, Adam\n        'b': 'Bob'         // [object Object], b, add, Bob, undefined\n    });\n    o.removeAttr('a');     // [object Object], a, remove, undefined, Alice\n\n\n(See also `[can.Map::removeAttr removeAttr]`, which removes properties).\n\n## The _property name_ event\n\nThe second event that is fired is an event whose type is the same as the changed\nproperty's name. This event is useful for noticing changes to a specific property.\n\n\n    var o = new Map({});\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log('The value of a changed.');\n    });\n\n\nThe parameters of the event handler for the _property name_ event are:\n\n- _ev_ The event object.\n- _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n- _oldVal_ The value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\nHere is a concrete tour through the _property name_ event handler's arguments:\n\n\n    var o = new Map({});\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log(ev + ', ' + newVal + ', ' + oldVal);\n    });\n\n    o.attr('a', 'Alexis'); // [object Object], Alexis, undefined\n    o.attr('a', 'Adam');   // [object Object], Adam, Alexis\n    o.attr({\n        'a': 'Alice',      // [object Object], Alice, Adam\n        'b': 'Bob'\n    });\n    o.removeAttr('a');     // [object Object], undefined, Alice\n\n\n## See also\n\nMore information about changing properties on Observes can be found under\n[can.Map.prototype.attr attr].\n\nFor a more specific way to changes on Observes, see the [can.Map.delegate] plugin.\n*/\n\n",
    "description": "Bind event handlers to a Map. \n",
    "title": "bind",
    "name": "can-map.prototype.bind",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 3,
    "signatures": [
      {
        "code": "map.bind(eventType, handler)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "the type of event to bind this handler to"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "comment": " "
  },
  "can-map.prototype.compute": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.compute.md"
    },
    "body": "\n`compute` is a convenience method for making computes from properties\nof Observes. More information about computes can be found under [can.compute].\n\n\n    var map = new Map({a: 'Alexis'});\n    var name = map.compute('a');\n    name.bind('change', function(ev, nevVal, oldVal) {\n        console.log('a changed from ' + oldVal + 'to' + newName + '.');\n    });\n\n    name(); // 'Alexis'\n\n    map.attr('a', 'Adam'); // 'a changed from Alexis to Adam.'\n    name(); // 'Adam'\n\n    name('Alice'); // 'a changed from Adam to Alice.'\n    name(); // 'Alice'\n\n",
    "description": "Make a can.compute from an observable property. \n",
    "title": "compute",
    "name": "can-map.prototype.compute",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 4,
    "signatures": [
      {
        "code": "map.compute(attrName)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "the property to bind to"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "a [can-compute] bound to _attrName_\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "the property to bind to"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "a [can-compute] bound to _attrName_\n"
    },
    "comment": " "
  },
  "can-map.prototype.DEFAULT-ATTR": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.default-attr.md"
    },
    "body": "\n## Use\n\nWhen extending [can-map], if a prototype property is not a function,\nit is used as a default value on instances of the extended Map.  For example:\n\n```\nvar Paginate = Map.extend({\n    limit: 20,\n    offset: 0,\n    next: function(){\n        this.attr(\"offset\", this.attr(\"offset\")+this.attr(\"limit\"))\n    }\n});\n\nvar paginate = new Paginate({limit: 30});\n\npaginate.attr(\"offset\") //-> 0\npaginate.attr(\"limit\")  //-> 30\n\npaginate.next();\n\npaginate.attr(\"offset\") //-> 30\n```\n\n",
    "description": "Specify a default property and value. \n",
    "types": [
      {
        "type": "*",
        "description": "A value of any type other than a function that will\nbe set as the `DEFAULT-ATTR` attribute's value.\n"
      }
    ],
    "title": "DEFAULT-ATTR",
    "name": "can-map.prototype.DEFAULT-ATTR",
    "type": "property",
    "parent": "can-map.prototype",
    "order": 1,
    "comment": " "
  },
  "can-map.prototype.each": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.each.md"
    },
    "body": "\n    var names = [];\n    new Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n        names.push(value);\n    });\n\n    names; // ['Alice', 'Bob', 'Eve']\n\n    names = [];\n    new Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n        names.push(value);\n        if(key === 'b') {\n            return false;\n        }\n    });\n\n    names; // ['Alice', 'Bob']\n    \n\n",
    "description": "Call a function on each property of a Map. \n",
    "title": "each",
    "name": "can-map.prototype.each",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 5,
    "signatures": [
      {
        "code": "map.each( callback(item, propName ) )",
        "description": "\n\n`each` iterates through the Map, calling a function\nfor each property value and key.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "propName"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "item"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "propName"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "comment": " "
  },
  "can-map.prototype.removeAttr": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.removeAttr.md"
    },
    "body": "`removeAttr` removes a property by name from a Map.\n\n\n    var people = new Map({a: 'Alice', b: 'Bob', e: 'Eve'});\n\n    people.removeAttr('b'); // 'Bob'\n    people.attr();          // {a: 'Alice', e: 'Eve'}\n\n\nRemoving an attribute will cause a _change_ event to fire with `'remove'`\npassed as the _how_ parameter and `undefined` passed as the _newVal_ to\nhandlers. It will also cause a _property name_ event to fire with `undefined`\npassed as _newVal_. An in-depth description at these events can be found\nunder `[can-map.prototype.attr attr]`.\n\n",
    "description": "Remove a property from a Map. \n",
    "title": "removeAttr",
    "name": "can-map.prototype.removeAttr",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 6,
    "signatures": [
      {
        "code": "map.removeAttr(attrName)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "the name of the property to remove"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value of the property that was removed\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "the name of the property to remove"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value of the property that was removed\n"
    },
    "comment": " "
  },
  "can-map.prototype.serialize": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.serialize.md"
    },
    "body": "",
    "description": "Serialize this object to something that can be passed to `JSON.stringify`. \n",
    "title": "serialize",
    "name": "can-map.prototype.serialize",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 7,
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n\nGet the serialized Object form of the map.  Serialized\ndata is typically used to send back to a server.\n\n\n    o.serialize() //-> { name: 'Justin' }\n\n\nSerialize currently returns the same data\nas [can.Map.prototype.attrs].  However, in future\nversions, serialize will be able to return serialized\ndata similar to [can.Model].  The following will work:\n\n\n    new Map({time: new Date()})\n        .serialize() //-> { time: 1319666613663 }\n\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a JavaScript Object that can be\nserialized with `JSON.stringify` or other methods.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a JavaScript Object that can be\nserialized with `JSON.stringify` or other methods.\n"
    }
  },
  "can-map.prototype.unbind": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.unbind.md"
    },
    "body": "`unbind` unbinds event handlers previously bound with [can-map.prototype.bind bind].\nIf no _handler_ is passed, all handlers for the given event type will be unbound.\n\n\n    var i = 0,\n        increaseBy2 = function() { i += 2; },\n        increaseBy3 = function() { i += 3; },\n        o = new Map();\n\n    o.bind('change', increaseBy2);\n    o.bind('change', increaseBy3);\n    o.attr('a', 'Alice');\n    i; // 5\n\n    o.unbind('change', increaseBy2);\n    o.attr('b', 'Bob');\n    i; // 8\n\n    o.unbind('change');\n    o.attr('e', 'Eve');\n    i; // 8\n\n",
    "description": "Unbind event handlers from a Map. \n",
    "title": "unbind",
    "name": "can-map.prototype.unbind",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 8,
    "signatures": [
      {
        "code": "map.unbind(eventType[, handler])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "the type of event to unbind, exactly as passed to `bind`"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "handler",
            "description": "the handler to unbind\n\n```js\nvar map = new Map({ a: 1 });\n\nfunction log(){\n\tconsole.log(\"val\", map.attr(\"a\");\n}\n\nmap.bind(\"change\", log);\n\nmap.attr(\"a\", 2);\n\n// Bind callback called.\nmap.unbind(\"change\", log);\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "handler",
      "description": "the handler to unbind\n\n```js\nvar map = new Map({ a: 1 });\n\nfunction log(){\n\tconsole.log(\"val\", map.attr(\"a\");\n}\n\nmap.bind(\"change\", log);\n\nmap.attr(\"a\", 2);\n\n// Bind callback called.\nmap.unbind(\"change\", log);\n```\n"
    },
    "comment": " "
  },
  "can-map.keys": {
    "src": {
      "path": "node_modules/can-map/docs/static.keys.md"
    },
    "body": "",
    "description": "Returns an array of the map's keys. \n",
    "title": "keys",
    "name": "can-map.keys",
    "type": "function",
    "parent": "can-map.static",
    "order": 0,
    "signatures": [
      {
        "code": "Map.keys(map)",
        "description": "\n\n```js\nvar people = new Map({\n\t\ta: 'Alice',\n\t\tb: 'Bob',\n\t\te: 'Eve'\n});\n\nMap.keys(people); // ['a', 'b', 'e']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-map"
              }
            ],
            "name": "map",
            "description": "the `Map` to get the keys from"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "array An array containing the keys from _map_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "name": "map",
      "description": "the `Map` to get the keys from"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "array An array containing the keys from _map_.\n"
    }
  },
  "can-map-backup/can-map.prototype": {
    "name": "can-map-backup/can-map.prototype",
    "title": "can-map.prototype",
    "type": "group",
    "parent": "can-map-backup",
    "description": "",
    "order": 0
  },
  "can-map-backup": {
    "src": {
      "path": "node_modules/can-map-backup/doc/can-map-backup.md"
    },
    "body": "\n`can-map-backup` is a plugin that provides a dirty bit for properties on an Map,\nand lets you restore the original values of an Map's properties after they are changed.\n\n## Overview\n\nHere is an example showing how to use [can-map-backup/can-map.prototype.backup] to save values,\n`[can-map-backup/can-map.prototype.restore restore]` to restore them, and `[can-map-backup/can-map.prototype.isDirty isDirty]`\n\nto check if the Map has changed:\n\n```js\nvar CanMap = require(\"can-map\");\nrequire('can-map-backup');\n\nvar recipe = new CanMap({\n  title: 'Pancake Mix',\n  yields: '3 batches',\n  ingredients: [{\n    ingredient: 'flour',\n    quantity: '6 cups'\n  },{\n    ingredient: 'baking soda',\n    quantity: '1 1/2 teaspoons'\n  },{\n    ingredient: 'baking powder',\n    quantity: '3 teaspoons'\n  },{\n    ingredient: 'salt',\n    quantity: '1 tablespoon'\n  },{\n    ingredient: 'sugar',\n    quantity: '2 tablespoons'\n  }]\n});\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.title;     // 'Flapjack Mix'\nrecipe.isDirty(); // true\n\nrecipe.restore();\nrecipe.title;     // 'Pancake Mix'\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "can-map"
      }
    ],
    "name": "can-map-backup",
    "parent": "can-legacy",
    "test": "src/test/test.html",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-connect": "^1.0.0",
        "can-fixture": "^1.0.0",
        "can-jquery": "^3.0.1",
        "can-list": "^3.0.0",
        "can-map": "^3.0.1",
        "can-set": "^1.0.0",
        "can-util": "^3.0.1"
      },
      "description": "Backup and restore a Maps state",
      "devDependencies": {
        "can-map-define": "^3.0.0-pre.2",
        "can-ssr": "^0.11.6",
        "documentjs": "^0.4.2",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.6",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs"
      ],
      "main": "can-map-backup",
      "name": "can-map-backup",
      "scripts": {
        "build": "node build.js",
        "develop": "can-serve --static --develop --port 8080",
        "document": "documentjs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-map-backup",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.3"
    },
    "signatures": [
      {
        "code": "require('can-map-backup')",
        "description": "\n\nAdds a [can-map-backup/can-map.prototype.backup],\n[can-map-backup/can-map.prototype.isDirty] and\n[can-map-backup/can-map.prototype.restore] method to [can-map].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "Exports [can-map].\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "Exports [can-map].\n"
    },
    "comment": " "
  },
  "can-map-backup/can-map.prototype.backup": {
    "src": {
      "path": "node_modules/can-map-backup/doc/prototype.backup.md"
    },
    "body": "\n## Example\n\n```\nvar CanMap = require('can-map');\nrequire('can-map-backup')\n\nvar recipe = new CanMap(\"Recipe\", {\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.title;     // 'Flapjack Mix'\n\nrecipe.restore();\nrecipe.title;     // 'Pancake Mix'\n```\n\n",
    "description": "Save the values of the properties of an Map. \n",
    "title": "backup",
    "name": "can-map-backup/can-map.prototype.backup",
    "type": "function",
    "parent": "can-map-backup/can-map.prototype",
    "signatures": [
      {
        "code": "map.backup()",
        "description": "\n\n`backup` backs up the current state of the properties of an Observe and marks\nthe Observe as clean. If any of the properties change value, the original\nvalues can be restored with [can.Map.backup.prototype.restore restore].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "The map, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "The map, for chaining.\n"
    },
    "comment": " "
  },
  "can-map-backup/can-map.prototype.isDirty": {
    "src": {
      "path": "node_modules/can-map-backup/doc/prototype.isDirty.md"
    },
    "body": "\n```\nvar CanMap = require('can-map');\nrequire('can-map-backup')\n\nvar recipe = new CanMap(\"Recipe\", {\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\n\nrecipe.isDirty();     // false\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.isDirty();     // true\nrecipe.restore();\nrecipe.isDirty();   // false\n\nrecipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // true\n\nrecipe.backup();\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // false\n```\n\n",
    "description": "Check whether an Observe has changed since the last time it was backed up. \n",
    "title": "isDirty",
    "name": "can-map-backup/can-map.prototype.isDirty",
    "type": "function",
    "parent": "can-map-backup/can-map.prototype",
    "signatures": [
      {
        "code": "map.isDirty([deep])",
        "description": "\n\n`isDirty` checks whether any properties have changed value or whether any properties have\nbeen added or removed since the last time the Observe was backed up. If _deep_ is `true`,\nIf the Observe has never been backed up, `isDirty` returns `undefined`.\n`isDirty` will include nested Observes in its checks.\n",
        "params": [
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "deep",
            "defaultValue": "false",
            "description": "whether to check nested Observes"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "bool"
            }
          ],
          "description": "Whether the Observe has changed since the last time it was [can.Map.backup.prototype.backup backed up].\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "deep",
      "defaultValue": "false",
      "description": "whether to check nested Observes"
    },
    "_curReturn": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "description": "Whether the Observe has changed since the last time it was [can.Map.backup.prototype.backup backed up].\n\n"
    },
    "comment": " "
  },
  "can-map-backup/can-map.prototype.restore": {
    "src": {
      "path": "node_modules/can-map-backup/doc/prototype.restore.md"
    },
    "body": "\n```js\nvar CanMap = require('can-map');\nrequire('can-map-backup')\n\nvar recipe = new CanMap(\"Recipe\", {\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\n\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.restore();\nrecipe.attr('title'); // 'Pancake Mix'\n\nrecipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.restore();\nrecipe.attr('ingredients.0.quantity'); // '7 cups'\nrecipe.restore(true);\nrecipe.attr('ingredients.0.quantity'); // '6 cups'\n```\n\n## Events\nWhen `restore` sets values or re-adds properties, the same events will be fired (including\n_change_, _add_, and _set_) as if the values of the properties had been set using [`attr`](http://canjs.com/docs/can.Map.prototype.attr.html).\n\n",
    "description": "Restore saved values of an Observe's properties. \n",
    "title": "restore",
    "name": "can-map-backup/can-map.prototype.restore",
    "type": "function",
    "parent": "can-map-backup/can-map.prototype",
    "signatures": [
      {
        "code": "map.restore( [deep] )",
        "description": "\n\n`restore` sets the properties of an Observe back to what they were the last time\n[can-map-backup.prototype.backup backup] was called. If _deep_ is `true`,\n`restore` will also restore the properties of nested Observes.\n\n`restore` will not remove properties that were added since the last backup, but it\nwill re-add properties that have been removed.\n",
        "params": [
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "deep",
            "defaultValue": "false",
            "description": "whether to restore properties in nested Observes"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "The Observe, for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "deep",
      "defaultValue": "false",
      "description": "whether to restore properties in nested Observes"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "The Observe, for chaining.\n"
    },
    "comment": " "
  },
  "can-map-define.TypeConstructor": {
    "src": {
      "path": "node_modules/can-map-define/docs/TypeConstructor.md"
    },
    "body": "\n\n\nSimilar to [can-map-define._type type], this uppercase version provides a mechanism for converting incoming values to another format or type.\n\nSpecifically, this constructor will be invoked any time this property is set, and any data passed into the setter will be passed as arguments for the constructor.\n\nIf the call to attr passes an object that is already an instance of the constructor specified with `Type`, no conversion is done.\n\n",
    "description": "\nProvides a constructor function to be used to convert any value passed into [can-map.prototype.attr attr] into an appropriate value\n",
    "title": "Type",
    "name": "can-map-define.TypeConstructor",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "constructorFunc",
        "description": "\n\nA constructor function can be provided that is called to convert incoming values set on this property, like:\n\n    define: {\n      prop: {\n        Type: Person\n      }\n    }\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-map-define.ValueConstructor": {
    "src": {
      "path": "node_modules/can-map-define/docs/ValueConstructor.md"
    },
    "body": "\n\nSimilar to [can-map-define.value value], this uppercase version provides a mechanism for providing a default value.  If the default value is an object, providing a constructor is a good way to ensure a copy is made for each instance.\n\n",
    "description": "\nProvides a constructor function to be used to provide a default value for a certain property of a [can-map Map].  This constructor will be invoked with `new` each time a new instance of the map is created.\n",
    "title": "Value",
    "name": "can-map-define.ValueConstructor",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "constructorFunc",
        "description": "\n\nA constructor function can be provided that is called to create a default value used for this property, like:\n\n    define: {\n      prop: {\n        Value: Array\n      },\n      person: {\n      \tValue: Person\n      }\n    }\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-map-define.attrDefinition": {
    "src": {
      "path": "node_modules/can-map-define/docs/attrDefinition.md"
    },
    "body": "\n",
    "description": "\nDefines the type, initial value, and get, set, and remove behavior for an attribute of a [can-map Map].\n",
    "type": "typedef",
    "title": "attribute definition",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "value",
            "description": "Specifies the initial value of the attribute or\na function that returns the initial value. For example, a default value of `0` can be \nspecified like:\n\n    define: {\n      prop: {\n        value: 0\n      }\n    }\n\n`Object` types should not be specified directly on `value` because that same object will\nbe shared on every instance of the Map.  Instead, a [can-map-define.value value function] that \nreturns a fresh copy can be provided:\n\n    define: {\n      prop: {\n        value: function(){\n          return {foo: \"bar\"}\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.value"
              },
              {
                "type": "*"
              }
            ]
          },
          {
            "name": "Value",
            "description": "Specifies a function that will be called with `new` whose result is\nset as the initial value of the attribute. For example, if the default value should be a [can-list List]:\n\n    define: {\n      prop: {\n        Value: Map.List\n      }\n    }\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "type",
            "description": "Specifies the type of the \nattribute.  The type can be specified as either a [can-map-define._type type function] \nthat returns the type coerced value or one of the following strings:\n\n - `\"string\"` - Converts the value to a string.\n - `\"date\"` - Converts the value to a date or `null if the date can not be converted.\n - `\"number\"` - Passes the value through `parseFloat`.\n - `\"boolean\"` - Converts falsey, `\"false\"` or `\"0\"` to `false` and everything else to true.\n - `\"*\"` - Prevents the default type coersion of converting Objects to [can-map Map]s and Arrays to [can-list List]s.\n\nThe following example converts the `count` property to a number and the `items` property to an array:\n\n     define: {\n       count: {type: \"number\"},\n       items: {\n         type: function(newValue){\n           if(typeof newValue === \"string\") {\n             return newValue.split(\",\")\n           } else if( can.isArray(newValue) ) {\n             return newValue;\n           }\n         }\n       }\n     }\n",
            "types": [
              {
                "type": "can-map-define._type"
              },
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "Type",
            "description": "A constructor function that takes \nthe value passed to [can-map.prototype.attr attr] as the first argument and called with \nnew. For example, if you want whatever\ngets passed to go through `new Array(newValue)` you can do that like:\n\n    define: {\n      items: {\n        Type: Array\n      }\n    }\n\nIf the value passed to [can-map.prototype.attr attr] is already an Array, it will be left as is.\n",
            "types": [
              {
                "type": "can-map-define.TypeConstructor"
              }
            ]
          },
          {
            "name": "set",
            "description": "A set function that specifies what should happen when an attribute\nis set on a [can-map]. `set` is called with the result of `type` or `Type`. The following\ndefines a `page` setter that updates the map's offset:\n\n    define: {\n      page: {\n        set: function(newVal){\n          this.attr('offset', (parseInt(newVal) - 1) * \n                               this.attr('limit'));\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.set"
              }
            ]
          },
          {
            "name": "get",
            "description": "A function that specifies how the value is retrieved.  The get function is \nconverted to an [can-compute.async async compute].  It should derive its value from other values\non the map. The following\ndefines a `page` getter that reads from a map's offset and limit:\n\n    define: {\n      page: {\n        get: function (newVal) {\n\t\t  return Math.floor(this.attr('offset') / \n\t\t                    this.attr('limit')) + 1;\n\t\t}\n      }\n    }\n    \nA `get` definition makes the property __computed__ which means it will not be serialized by default.\n",
            "types": [
              {
                "type": "can-map-define.get"
              }
            ]
          },
          {
            "name": "remove",
            "description": "A function that specifies what should happen when an attribute is removed\nwith [can-map.prototype.removeAttr removeAttr]. The following removes a `modelId` when `makeId` is removed:\n\n    define: {\n      makeId: {\n        remove: function(){\n          this.removeAttr(\"modelId\");\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.remove"
              }
            ]
          },
          {
            "name": "serialize",
            "description": "Specifies the behavior of the \nproperty when [can-map.prototype.serialize serialize] is called. \n\nBy default, serialize does not include computed values. Properties with a `get` definition\nare computed and therefore are not added to the result.  Non-computed properties values are\nserialized if possible and added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        pageNum: {\n          get: function(){ return this.offset() / 20 }\n        }\n      }\n    });\n    \n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 40}\n\nIf `true` is specified, computed properties will be serialized and added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        pageNum: { \n          get: function(){ return this.offset() / 20 },\n          serialize: true\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 40, pageNum: 2}\n    \n    \nIf `false` is specified, non-computed properties will not be added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        offset: {\n          serialize: false\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {}\n\nIf a [can-map-define.serialize serialize function] is specified, the result\nof the function is added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        offset: {\n          serialize: function(offset){\n            return (offset / 20)+1\n          }\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 3}\n    \n",
            "types": [
              {
                "type": "can-map-define.serialize"
              },
              {
                "type": "Boolean"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-map-define.attrDefinition",
    "parent": "can-map-define"
  },
  "can-map-define": {
    "src": {
      "path": "node_modules/can-map-define/docs/define.md"
    },
    "body": "\n\n## Use\n\nThe [can-map-define define] plugin allows you to completely control the behavior\nof attributes on a [can-map Map]. To use it, you specify\nan `define` object that is a mapping of properties\nto [can-map-define.attrDefinition attribute definitions]. The following example\nspecifies a Paginate Map:\n\n    var Paginate = Map.extend({\n      define: {\n        count: {\n          type: \"number\",\n          value: Infinity,\n          // Keeps count above 0.\n          set: function(newCount){\n            return newCount < 0 ? 0 : newCount;\n          }\n        },\n        offset: {\n          type: \"number\",\n          value: 0,\n          // Keeps offset between 0 and count\n          set: function(newOffset){\n            var count = this.attr(\"count\");\n            return newOffset < 0 ?\n\t\t      0 :\n\t\t      Math.min(newOffset, !isNaN( count - 1) ?\n\t\t        count - 1 :\n\t\t        Infinity);\n          }\n        },\n        limit: {\n          type: \"number\",\n          value: 5\n        },\n        page: {\n          // Setting page changes the offset\n          set: function(newVal){\n            this.attr('offset', (parseInt(newVal) - 1) *\n                                 this.attr('limit'));\n          },\n          // The page value is derived from offset and limit.\n          get: function (newVal) {\n\t\t    return Math.floor(this.attr('offset') /\n\t\t                      this.attr('limit')) + 1;\n\t\t  }\n        }\n      }\n    });\n\n## Default behaviors\n\nThe [can-map-define define] plugin not only allows you to define\nindividual attribute behaviors on a [can-map Map], but you can also define default\nbehaviors that would apply to any unspecified attribute. This is particularly\nhelpful for when you need a particular behavior to apply to every attribute on\na [can-map Map] but won't be certain of what every attribute will be.\n\nThe following example is a [can-map Map] that is tied to [can-route route] where only\nspecified attributes that are serialized will be updated in the location hash:\n\n    var State = Map.extend({\n      define: {\n        foo: {\n          serialize: true\n        },\n        '*': {\n          serialize: false\n        }\n      }\n    });\n\n    var state = new State();\n\n    // tie State map to the route\n    route.map(state);\n    route.ready();\n\n    state.attr('foo', 'bar');\n    state.attr('bar', 'baz');\n\n    window.location.hash; // -> #!foo=bar\n\n\n## Overview\n\nThis plugin is a replacement for the now deprecated attributes and setter plugins. It intends to provide a single place to define the behavior of all the properties of a [can-map Map].\n\nHere is the cliffnotes version of this plugin.  To define...\n\n* The default value for a property - use [can-map-define.value value]\n* That default value as a constructor function - use [can-map-define.ValueConstructor Value]\n* What value is returned when a property is read - use [can-map-define.get get]\n* Behavior when a property is set - use [can-map-define.set set]\n* How a property is serialized when [can-map.prototype.serialize serialize] is called on it - use [can-map-define.serialize serialize]\n* Behavior when a property is removed - use [can-map-define.remove remove]\n* A custom converter method or a pre-defined standard converter called whenever a property is set - use [can-map-define._type type]\n* That custom converter method as a constructor function - use [can-map-define.TypeConstructor Type]\n\n## Demo\n\nThe following shows picking cars by make / model / year:\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-map-define/make-model-year.html'></div>\n\n",
    "description": "\nDefines the\n`type`, initial `value`, `get`, `set`, `remove`, and `serialize` behavior for attributes\nof a [can-map Map].\n",
    "type": "module",
    "title": "can-map-define",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "define",
            "description": "Exports object with helper methods internal to\n`can-map-define`.  The export of `can-map-define` is not used directly, instead\nthe module is imported and all [can-map]'s can have their properties defined like:\n\n```js\nvar CanMap = require(\"can-map\");\nrequire(\"can-map-define\");\n\nvar Person = CanMap.extend({\n    define: {\n        fullName: function(){\n            return this.attr(\"first\") + \" \"+ this.attr(\"last\")\n        }\n    }\n})\n```\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can-map-define",
    "parent": "can-legacy",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": [
            "**/node_modules/*",
            "node_modules/**/*",
            "**/*{-,_,}{test,qunit}{s,}.js"
          ]
        },
        "readme": {
          "apis": "./doc/apis.json"
        },
        "parent": "can-map-define"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-map-define/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.4",
        "can-event": "^3.0.1",
        "can-list": "^3.0.3",
        "can-map": "^3.0.3",
        "can-util": "^3.0.13"
      },
      "description": "Define rich attribute behavior",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-component": "^3.0.3",
        "can-fixture": "^1.0.10",
        "can-model": "^3.0.0-pre.1",
        "can-route": "^3.0.5",
        "can-stache": "^3.0.13",
        "done-serve": "^0.2.5",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.6",
        "jshint": "^2.9.4",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs"
      ],
      "main": "can-map-define",
      "name": "can-map-define",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-map-define.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-map-define"
      },
      "version": "3.0.9"
    },
    "comment": " "
  },
  "can-map-define.get": {
    "src": {
      "path": "node_modules/can-map-define/docs/get.md"
    },
    "body": "\n\n\n## Use\n\nGetter methods are useful for:\n\n - Defining virtual properties on a map.\n - Defining property values that change with their _internal_ set value. \n \n## Virtual properties\n\n\nVirtual properties are properties that don't actually store any value, but derive their value \nfrom some other properties on the map.\n\nWhenever a getter is provided, it is wrapped in a [can-compute compute], which ensures \nthat whenever its dependent properties change, a change event will fire for this property also.\n\n```\nvar Person = Model.extend({\n\tdefine: {\n\t\tfullName: {\n\t\t\tget: function () {\n\t\t\t\treturn this.attr(\"first\") + \" \" + this.attr(\"last\");\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar p = new Person({first: \"Justin\", last: \"Meyer\"});\n\np.attr(\"fullName\"); // \"Justin Meyer\"\n\np.bind(\"fullName\", function(ev, newVal){\n  newVal //-> \"Lincoln Meyer\";\n});\n\np.attr(\"first\",\"Lincoln\");\n```\n\n## Asyncronous virtual properties\n\nOften, a virtual property's value only becomes available after some period of time.  For example,\ngiven a `personId`, one might want to retrieve a related person:\n\n```\nvar AppState = Map.extend({\n  define: {\n    person: {\n      get: function(lastSetValue, setAttrValue){\n        Person.findOne({id: this.attr(\"personId\")})\n        \t.then(function(person){\n        \t\tsetAttrValue(person);\n        \t});\n      }\n    }\n  }\n});\n```\n\nAsyncronous properties should be bound to before reading their value.  If \nthey are not bound to, the `get` function will be called each time.\n\nThe following example will make multiple `Person.findOne` requests: \n\n```\nvar state = new AppState({personId: 5});\nstate.attr(\"person\") //-> undefined\n\n// called sometime later ...\nstate.attr(\"person\") //-> undefined\n```\n\nHowever, by binding, the compute only reruns the `get` function once `personId` changes:\n\n```\nvar state = new AppState({personId: 5});\n\nstate.bind(\"person\", function(){})\n\nstate.attr(\"person\") //-> undefined\n\n// called sometime later\nstate.attr(\"person\") //-> Person<{id: 5}>\n```\n\nA template like [can-stache stache] will automatically bind for you, so you can pass\n`state` to the template like the following without binding:\n\n```\nvar template = stache(\"<span>{{person.fullName}}</span>\");\nvar state = new AppState({});\nvar frag = template(state);\n\nstate.attr(\"personId\",5);\nfrag.childNodes[0].innerHTML //=> \"\"\n\n// sometime later\nfrag.childNodes[0].innerHTML //=> \"Lincoln Meyer\"\n\n```\n\nThe magic tags are updated as `personId`, `person`, and `fullName` change.\n\n\n## Properties values that change with their _internal_ set value \n\nA getter can be used to derive a value from a set value. A getter's\n`lastSetValue` argument is the last value set by [can-map.prototype.attr attr]. \n\nFor example, a property might be set to a compute, but when read, provides the value\nof the compute.\n\n```\nvar MyMap = Map.extend({\n  define: {\n    value: {\n      get: function( lastSetValue ){\n        return lastSetValue();\n      }\n    }\n  }\n});\n\nvar map = new MyMap();\nvar compute = can.compute(1);\nmap.attr(\"value\", compute);\n\nmap.attr(\"value\") //-> 1\ncompute(2);\nmap.attr(\"value\") //-> 2\n```\n\nThis technique should only be used when the `lastSetValue` is some form of\nobservable, that when it changes, can update the `getter` value.\n\nFor simple conversions, [can-map-define.set set] or [can-map-define._type type] should be used.\n\n## Updating the virtual property value\n\nIt's very common (and better performing) to update the virtual property value \ninstead of replacing it. \n\nThe following example creates an empty `locationIds` [can-list List] when a new\ninstance of `Store` is created.  However, as `locations` change,\nthe [can-list List] will be updated with the `id`s of the `locations`.\n\n\n```\nvar Store = Map.extend({\n\tdefine: {\n\t\tlocationIds: {\n\t\t\tValue: Map.List,\n\t\t\tget: function(initialValue){\n\t\t\t\tvar ids = [];\n\t\t\t\tthis.attr('locations').each(function(location){\n\t\t\t\t\tids.push(location.attr(\"id\"));\n\t\t\t\t});\n\t\t\t\treturn initialValue.replace(ids);\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n",
    "description": "\nSpecify what happens when a certain property is read on a map. `get` functions\nwork like a [can-compute compute] and automatically update themselves when a dependent\nobservable value is changed.\n",
    "title": "get",
    "name": "can-map-define.get",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "get( [lastSetValue] )",
        "description": "\n\n  Defines the behavior when a value is read on a [can-map Map]. Used to provide properties that derive their value from \n  other properties of the map, or __update__ their value from \n  the changes in the value that was set. \n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The value last set by `.attr(property, value)`.  Typically, _lastSetValue_ \nshould be an observable value, like a [can-compute compute] or promise. If it's not, it's likely \nthat a [can-map-define.set define.set] should be used instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property.\n"
        }
      },
      {
        "code": "get( lastSetValue, setAttrValue(value) )",
        "description": "\n\n  Asynchronously defines the behavior when a value is read on a [can-map Map]. Used to provide property values that\n  are available asynchronously. \n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "lastSetValue",
            "description": "The value last set by `.attr(property, value)`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "value"
                  }
                ]
              }
            ],
            "name": "setAttrValue",
            "description": "Updates the value of the property. This can be called\nmultiple times if needed.\n "
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of the property.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "value"
            }
          ]
        }
      ],
      "name": "setAttrValue",
      "description": "Updates the value of the property. This can be called\nmultiple times if needed.\n "
    },
    "comment": " "
  },
  "can-map-define.remove": {
    "src": {
      "path": "node_modules/can-map-define/docs/remove.md"
    },
    "body": "\n\n## Use\n\nThe following prevents removing the _prop_ attribute if someone tries to remove the value 0:\n\n\n    define: {\n      prop: {\n        remove: function( currentVal ){\n          return currentVal !== 0;\n        }\n      }\n    }\n\n\n",
    "description": "\nCalled when an attribute is removed.\n",
    "title": "remove",
    "name": "can-map-define.remove",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "remove( currentValue )",
        "description": "\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "false"
            }
          ],
          "description": "If `false` is returned, the value is not removed.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "false"
        }
      ],
      "description": "If `false` is returned, the value is not removed.\n"
    },
    "comment": " "
  },
  "can-map-define.set": {
    "src": {
      "path": "node_modules/can-map-define/docs/set.md"
    },
    "body": "\n\n## Use\n\nAn attribute's `set` function can be used to customize the behavior of when an attribute value is set\nvia [can-map.prototype.attr `.attr()`].  Lets see some common cases:\n\n#### Side effects\n\nThe following makes setting a `page` property update the `offset`:\n\n    define: {\n      page: {\n        set: function(newVal){\n          this.attr('offset', (parseInt(newVal) - 1) *\n                               this.attr('limit'));\n        }\n      }\n    }\n\nThe following makes changing `makeId` remove the `modelId` property:\n\n    define: {\n      makeId: {\n        set: function(newValue){\n          // Check if we are changing.\n          if(newValue !== this.attr(\"makeId\")) {\n            this.removeAttr(\"modelId\");\n          }\n          // Must return value to set as we have a `newValue` argument.\n          return newValue;\n        }\n      }\n    }\n\n#### Asynchronous Setter\n\nThe following shows an async setter:\n\n    define: {\n      prop: {\n        set: function( newVal, setVal){\n          $.get(\"/something\", {}, setVal );\n        }\n      }\n    }\n\n\n## Behavior depends on the number of arguments.\n\nWhen a setter returns `undefined`, its behavior changes depending on the number of arguments.\n\nWith 0 arguments, the original set value is set on the attribute.\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    map.attr(\"prop\") //-> \"foo\"\n\nWith 1 argument, `undefined` will remove the property.  \n\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(newVal){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    Map.keys(map) //-> []\n\nWith 2 arguments, `undefined` leaves the property in place.  It is expected\nthat `setValue` will be called:\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(newVal, setValue){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    map.attr(\"prop\") //-> \"foo\"\n\n## Side effects\n\nA set function provides a useful hook for performing side effect logic as a certain property is being changed.\n\nFor example, in the example below, Paginator can.Map includes a `page` property, which derives its value entirely from other properties (limit and offset).  If something tries to set the `page` directly, the set method will set the value of `offset`:\n\n\n    var Paginate = Map.extend({\n      define: {\n        page: {\n          set: function (newVal) {\n            this.attr('offset', (parseInt(newVal) - 1) * this.attr('limit'));\n          },\n          get: function () {\n            return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n          }\n        }\n      }\n    });\n\n    var p = new Paginate({limit: 10, offset: 20});\n\n## Merging\n\nBy default, if a value returned from a setter is an object, array, can.Map, or can.List, the effect will be to replace the property with the new object completely.\n\n    Contact = Map.extend({\n      define: {\n        info: {\n          set: function(newVal){\n            return newVal;\n          }\n        }\n      }\n    })\n\n    var alice = new Contact({\n\t\t\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n\t\t});\n    alice.attr(); // {name: 'Alice Liddell', 'email': 'alice@liddell.com'}\n    alice.info._cid; // '.map1'\n\n    alice.attr('info', {name: 'Allison Wonderland', phone: '888-888-8888'});\n    alice.attr(); // {name: 'Allison Wonderland', 'phone': '888-888-8888'}\n    alice.info._cid; // '.map2'\n\nBy contrast, if you access a property of a Map using `.attr`, then change it by calling `.attr` on it directly, the new properties will be merged with the existing nested Map, not replaced.\n\n    var contact = new Map({\n      'info' : {'breath' : 'smells like roses'}\n    });\n    var newInfo = {'teeth' : 'shiny and clean'};\n    contact.attr('info').attr(newInfo); // info is now a merged object\n\nIf you would rather have the new Map or List merged into the current value, not replaced, call\n`.attr` inside the setter:\n\n\n    Contact = Map.extend({\n      define: {\n        info: {\n          set: function(newVal){\n            this.info.attr(newVal);\n            return this.info;\n          }\n        }\n      }\n    })\n\n    var alice = new Contact({\n\t\t\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n\t\t});\n    alice.attr(); // {name: 'Alice Liddell', 'email': 'alice@liddell.com'}\n    alice.info._cid; // '.map1'\n\n    alice.attr('info', {name: 'Allison Wonderland', phone: '888-888-8888'});\n    alice.attr();\n    //{\n    //  name: 'Allison Wonderland',\n    //  email: 'alice@liddell.com',\n    //  phone: '888-888-8888'\n    //}\n    alice.info._cid; // '.map1'\n\n## Batched Changes\n\nBy default, calls to set methods are wrapped in a call to [can-event/batch/batch.start batch.start] and [can-event/batch/batch.stop batch.stop], so if a set method has side effects that set more than one property, all these sets are wrapped in a single batch for better performance.\n\n",
    "description": "\nSpecify what happens when a value is set on a map attribute.\n",
    "title": "set",
    "name": "can-map-define.set",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "set( [newVal,] [setValue] )",
        "description": "\n\nA set function defines the behavior of what happens when a value is set on a\n[can-map Map]. It is typically used to:\n\n - Add or remove other attributes as side effects\n - Coerce the set value into an appropriate action\n\nThe behavior of the setter depends on the number of arguments specified. This means that a\nsetter like:\n\n    define: {\n      prop: {\n        set: function(){}\n      }\n    }\n\nbehaves differently than:\n\n    define: {\n      prop: {\n        set: function(newVal){}\n      }\n    }\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "The [can-map-define._type type function] coerced value the user intends to set on the\n[can-map Map].\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "setValue",
            "description": "A callback that can set the value of the property\nasyncronously.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the attribute value is set\n   to whatever was passed to [can-map.prototype.attr attr].\n - If the setter specifies the `newValue` argument only, the attribute value will be removed.\n - If the setter specifies both `newValue` and `setValue`, the value of the property will not be\n   updated until `setValue` is called.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ]
        }
      ],
      "optional": true,
      "name": "setValue",
      "description": "A callback that can set the value of the property\nasyncronously.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the attribute value is set\n   to whatever was passed to [can-map.prototype.attr attr].\n - If the setter specifies the `newValue` argument only, the attribute value will be removed.\n - If the setter specifies both `newValue` and `setValue`, the value of the property will not be\n   updated until `setValue` is called.\n\n"
    },
    "comment": " "
  },
  "can-map-define.serialize": {
    "src": {
      "path": "node_modules/can-map-define/docs/serialize.md"
    },
    "body": "\n\n## Use\n\n[can-map.prototype.serialize serialize] is useful for serializing a Map instance into \na more JSON-friendly form.  This can be used for many reasons, including saving a \n[can-model Model] instance on the server or serializing [can-route route]'s internal \nMap for display in the hash or pushstate URL.\n\nThe serialize property allows an opportunity to define how \neach attribute will behave when the map is serialized.  This can be useful for:\n\n- serializing complex types like dates, arrays, or objects into string formats\n- causing certain properties to be ignored when serialize is called\n\nThe following causes a locationIds property to be serialized into \nthe comma separated ID values of the location property on this map:\n\n    define: {\n      locationIds: {\n        serialize: function(){\n\t\t  var ids = [];\n\t\t  this.attr('locations').each(function(location){\n\t\t    ids.push(location.id);\n\t\t  });\n\t\t  return ids.join(',');\n        }\n      }\n    }\n\nReturning `undefined` for any property means this property will not be part of the serialized \nobject.  For example, if the property numPages is not greater than zero, the following example \nwon't include it in the serialized object.\n\n    define: {\n      prop: {\n        numPages: function( num ){\n          if(num <= 0) {\n          \treturn undefined;\n          }\n          return num;\n        }\n      }\n    }\n\n",
    "description": "\nCalled when an attribute is removed.\n",
    "title": "serialize",
    "name": "can-map-define.serialize",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "serialize( currentValue )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The current value of the attribute. \n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attr",
            "description": "The name of the attribute being serialized.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If `undefined` is returned, the value is not serialized.\n"
        },
        "context": {
          "types": [
            {
              "type": "Map"
            }
          ],
          "description": "The map instance being serialized.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attr",
      "description": "The name of the attribute being serialized.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If `undefined` is returned, the value is not serialized.\n"
    },
    "comment": " "
  },
  "can-map-define._type": {
    "src": {
      "path": "node_modules/can-map-define/docs/type.md"
    },
    "body": "\n\n## Use\n\nThe `type` property specifies the type of the attribute.  The type can be specified\nas either a type function that returns the type coerced value or one of the following strings:\n\n - `\"string\"` - Converts the value to a string except `null` or `undefined`.\n - `\"date\"` - Converts the value to a date or `null` if the date can not be converted.\n - `\"number\"` - Passes the value through `parseFloat` except for `null` or `undefined`.\n - `\"boolean\"` - Converts falsey, `\"false\"` or `\"0\"` to `false` and everything else to true.\n - `\"htmlbool\"` - Like `boolean`, but also converts empty strings to\n   `true`. Used, for example, when input is from component attributes like\n   `<can-tabs reverse/>`\n - `\"compute\"` - If the value set is a compute, will allow the returning of the computed value.\n - `\"*\"` - Prevents the default type coersion of converting Objects to [can-map Map]s and Arrays to [can-list List]s.\n\n### Basic Example\n\nThe following example converts the `count` property to a number and the `items` property to an array:\n\n     define: {\n       count: {type: \"number\"},\n       items: {\n         type: function(newValue){\n           if(typeof newValue === \"string\") {\n             return newValue.split(\",\")\n           } else if( can.isArray(newValue) ) {\n             return newValue;\n           }\n         }\n       }\n     }\n\nWhen a user tries to set those properties like:\n\n    map.attr({count: \"4\", items: \"1,2,3\"});\n\nThe number converter will be used to turn count into 4, and the items type converter function will be used to turn items into [1,2,3].\n\n### Preventing Arrays and Objects from Automatic Conversion\n\nWhen an array is passed into a Map setter, it is automatically converted into a List. Likewise, objects are converted into Map instances. This behavior can be prevented like the following:\n\n     define: {\n       locations: {type: \"*\"}\n     }\n\nWhen a user tries to set this property, the resulting value will remain an array.\n\n    map.attr('locations', [1, 2, 3]); // locations is an array, not a List\n\n### Working with the 'compute' type\n\nSetting type as [can-compute `compute`] allows for resolving a computed property with the .attr()\nmethod.\n\n```js\nMyMap = Map.extend({\n  define: {\n    value: {\n      type: \"compute\"\n    }\n  }\n});\n\nvar myMap = new MyMap();\nvar c = compute(5);\n\nmyMap.attr(\"value\",c);\nmyMap.attr(\"value\"); //-> 5\n\nc(6);\nmyMap.attr(\"value\"); //-> 6\n\n//Be sure if setting to pass the new compute\nvar c2 = compute(\"a\");\nmyMap.attr(\"value\",c2);\nmyMap.attr(\"value\"); //-> \"a\"\n```\n\n",
    "description": "\nConverts a value passed to [can-map.prototype.attr attr] into an appropriate value.\n",
    "title": "type",
    "name": "can-map-define._type",
    "type": "function",
    "parent": "can-map-define",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "newValue",
        "description": "The value passed to `attr`."
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "attrName",
        "description": "The attribute name being set."
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The attribute name being set."
    },
    "context": {
      "types": [
        {
          "type": "Map"
        }
      ],
      "description": "the instance of the [can-map Map]."
    },
    "returns": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
    },
    "comment": " "
  },
  "can-map-define.value": {
    "src": {
      "path": "node_modules/can-map-define/docs/value.md"
    },
    "body": "\n\nThere is a third way to provide a default value, which is explained in the [can-map-define.ValueConstructor Value] docs page. `value` lowercased is for providing default values for a property type, while `Value` uppercased is for providing a constructor function, which will be invoked with `new` to create a default value for each instance of this map.\n\n",
    "description": "\nReturns the default value for instances of this [can-map Map].  This is called before `init`.\n",
    "title": "value",
    "name": "can-map-define.value",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "defaulter()",
        "description": "\n\nA function can be provided that returns the default value used for this property, like:\n\n    define: {\n      prop: {\n        value: function(){ return []; }\n      }\n    }\n\nIf the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property `value` above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).\n",
        "params": [],
        "context": {
          "types": [
            {
              "type": "Map"
            }
          ],
          "description": "the instance of the [can-map Map].\n"
        },
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The default value.  This will be passed through setter and type.\n"
        }
      },
      {
        "code": "defaulVal",
        "description": "\n\nAny value can be provided as the default value used for this property, like:\n\n    define: {\n      prop: {\n        value: 'foo'\n      }\n    }\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "defaultVal",
            "description": "The default value, which will be passed through setter and type.\n"
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The default value.  This will be passed through setter and type.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "defaultVal",
      "description": "The default value, which will be passed through setter and type.\n"
    },
    "comment": " "
  },
  "can-set/Set": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.Set.md"
    },
    "body": "\n",
    "description": "\nAn object that represents a set of data.\n",
    "type": "typedef",
    "title": "Set",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nA `Set` is a plain JavaScript object used to represent a\n[https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation set] of data usually returned by the server.  For example,\na list of all completed todos might be represented by:\n\n```\n{complete: true}\n```\n\nThis set might be passed to [can-connect/can/map/map.getList] like:\n\n```\nTodo.getList({complete: true})\n```\n\nA [can-set.Algebra] is used to detail the behavior of these sets like:\n\n```\nvar todoAlgebra = new set.Algebra(\n  set.props.boolean(\"complete\")    \n);\n```\n\nUsing an algebra, all sorts of special behaviors can be performed:\n\n```\ntodoAlgebra.union({complete: true}, {complete: false}) //-> {}\n```\n"
      }
    ],
    "name": "can-set/Set",
    "parent": "can-set.types"
  },
  "can-set.Algebra.prototype": {
    "name": "can-set.Algebra.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-set.Algebra",
    "description": "",
    "order": 0
  },
  "can-set.Algebra": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.algebra.md"
    },
    "body": "",
    "description": "Perform set logic with an awareness of how certain properties represent a set.\n\n\n",
    "title": "Algebra",
    "name": "can-set.Algebra",
    "type": "function",
    "parent": "can-set.properties",
    "signatures": [
      {
        "code": "new set.Algebra(compares...)",
        "description": "\n\nAn `algebra` instance can perform a variety of set logic methods\nusing the `compares` configuration.\n\nA default `algebra` instance can be created like:\n\n```js\nvar set = require(\"can-set\");\nvar defaultAlgebra = new set.Algebra();\n```\n\nThis treats every property as a filter in a `where` clause.  For example:\n\n```js\n// `{id: 2, ownerId: 5}` belongs to ``.getList({ownerId: 5})`\ndefaultAlgebra.has({ownerId: 5}, {id: 2, ownerId: 5}) //-> true\n\ndefaultAlgebra.getSubset({ownerId: 5}, {},\n    [\n        {id: 1, ownerId: 2},\n        {id: 2, ownerId: 5},\n        {id: 3, ownerId: 12}\n    ]) //-> [{id: 2, ownerId: 5}]\n```\n\n[can-set.compares] configurations can be passed to\nadd better property behavior awareness:\n\n\n```js\nvar set = require(\"can-set\");\nvar todoAlgebra = new set.Algebra(\n  set.props.boolean(\"completed\"),\n  set.props.id(\"_id\"),\n  set.props.offsetLimit(\"offset\",\"limit\")\n);\n\ndefaultAlgebra.getSubset({limit: 2, offset: 1}, {},\n    [\n        {id: 1, ownerId: 2},\n        {id: 2, ownerId: 5},\n        {id: 3, ownerId: 12}\n    ]) //-> [{id: 2, ownerId: 5},{id: 3, ownerId: 12}]\n```\n\n[can-set.props] has helper functions that make common [can-set.compares]\nconfigurations.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.compares"
              }
            ],
            "name": "compares",
            "description": "Each argument is a compares. These\nare returned by the functions on [can-set.props] or can be created\nmanually.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.Algebra"
            }
          ],
          "description": "Returns an instance of an algebra.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "name": "compares",
      "description": "Each argument is a compares. These\nare returned by the functions on [can-set.props] or can be created\nmanually.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.Algebra"
        }
      ],
      "description": "Returns an instance of an algebra.\n"
    }
  },
  "can-set.prop": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.comparator.md"
    },
    "body": "\n",
    "description": "\n",
    "type": "typedef",
    "title": "Prop",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-set.prop",
    "parent": "can-set.types",
    "signatures": [
      {
        "code": "prop(aValue, bValue, a, b, prop, algebra)",
        "description": "\n\nA prop function returns algebra values for two values for a given property.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "aValue",
            "description": "The value of A's property in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "bValue",
            "description": "The value of A's property in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "a",
            "description": "The A set in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "b",
            "description": "The B set in a set difference A and B (A  B)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "Boolean"
            }
          ],
          "description": "A prop function should either return a Boolean which indicates if `aValue` and `bValue` are\nequal or an `AlgebraResult` object that details information about the union, intersection, and difference of `aValue` and `bValue`.\n\nAn `AlgebraResult` object has the following values:\n\n- `union` - A value the represents the union of A and B.\n- `intersection` - A value that represents the intersection of A and B.\n- `difference` - A value that represents all items in A that are not in B.\n- `count` - The count of the items in A.\n\nFor example, if you had a `colors` property and A is `[\"Red\",\"Blue\"]` and B is `[\"Green\",\"Yellow\",\"Blue\"]`, the\nAlgebraResult object might look like:\n\n```js\n{\n  union: [\"Red\",\"Blue\",\"Green\",\"Yellow\"],\n  intersection: [\"Blue\"],\n  difference: [\"Red\"],\n  count: 2000\n}\n```\n\nThe count is `2000` because there might be 2000 items represented by colors \"Red\" and \"Blue\".  Often\nthe real number can not be known.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "b",
      "description": "The B set in a set difference A and B (A  B)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Boolean"
        }
      ],
      "description": "A prop function should either return a Boolean which indicates if `aValue` and `bValue` are\nequal or an `AlgebraResult` object that details information about the union, intersection, and difference of `aValue` and `bValue`.\n\nAn `AlgebraResult` object has the following values:\n\n- `union` - A value the represents the union of A and B.\n- `intersection` - A value that represents the intersection of A and B.\n- `difference` - A value that represents all items in A that are not in B.\n- `count` - The count of the items in A.\n\nFor example, if you had a `colors` property and A is `[\"Red\",\"Blue\"]` and B is `[\"Green\",\"Yellow\",\"Blue\"]`, the\nAlgebraResult object might look like:\n\n```js\n{\n  union: [\"Red\",\"Blue\",\"Green\",\"Yellow\"],\n  intersection: [\"Blue\"],\n  difference: [\"Red\"],\n  count: 2000\n}\n```\n\nThe count is `2000` because there might be 2000 items represented by colors \"Red\" and \"Blue\".  Often\nthe real number can not be known.\n"
    }
  },
  "can-set.compares": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.compares.md"
    },
    "body": "\n",
    "description": "An object of property names and `prop` functions. \n```js\n{\n  // return `true` if the values should be considered the same:\n  lastName: function(aValue, bValue){\n    return (\"\"+aValue).toLowerCase() === (\"\"+bValue).toLowerCase();\n  }\n}\n```\n\n\n",
    "type": "typedef",
    "title": "Compares",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-set.prop"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-set.compares",
    "parent": "can-set.types"
  },
  "can-set.types": {
    "name": "can-set.types",
    "title": "types",
    "type": "group",
    "parent": "can-set",
    "description": "",
    "order": 0
  },
  "can-set.properties": {
    "name": "can-set.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-set",
    "description": "",
    "order": 0
  },
  "can-set": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.md"
    },
    "body": "\n## Use\n\nA [can-set/Set] is a plain JavaScript object used to represent a\n[https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation set] of data usually sent to the server to fetch a list of records.  For example,\na list of all completed todos might be represented by:\n\n```\n{complete: true}\n```\n\nThis set might be passed to [can-connect/can/map/map.getList] like:\n\n```\nTodo.getList({complete: true})\n```\n\nAn [can-set.Algebra] is used to detail the behavior of these sets,\noften using already provided [can-set.props] comparators:\n\n```\nvar todoAlgebra = new set.Algebra(\n  set.props.boolean(\"complete\"),\n  set.props.id(\"_id\")\n);\n```\n\nUsing an algebra, all sorts of special behaviors can be performed. For\nexample, if we already loaded the incomplete todos (`{complete: false}`) and\nwanted to load all todos (`{}`), we could use a set [can-set.Algebra.prototype.difference] to figure out how to load\nonly the data that hasn't been loaded.\n\n```js\ntodoAlgebra.difference({}, {complete: false}) //-> {complete: true}\n```\n\nThese algebra's are typically used internally by either [can-connect] or\n[can-fixture] to provide these special behaviors:\n\n```js\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{\n  algebra: todoAlgebra\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/cache-requests/cache-requests\")\n],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\",\n  algebra: todoAlgebra\n});\n```\n\n```js\nvar todoStore = fixture.store([\n    { _id : 1, name : 'Do the dishes', complete: true },\n    { _id : 2, name : 'Walk the dog', complete: false }\n  ],\n  todoAlgebra );\n\nfixture(\"/todos/{_id}\", todoStore);\n```\n\nThe best way to think about `can-set` is that its a way to detail\nthe behavior of your service layer so other utilities can benefit.\n\n## Solving Common Issues\n\nConfiguring the proper `set.Algebra` can be tricky.  The best way to make sure you\nhave things working is to create an algebra and make sure some of the basics\nwork.  \n\nThe most common problem is that your `algebra` isn't configured to know what\ninstance data belongs in which set.  \n\nFor example, `{id: 1, name: \"do dishes\"}` should belong to the\nset `{sort: \"name asc\"}`, but it doesn't:\n\n```js\nvar algebra = new set.Algebra();\nalgebra.has({sort: \"name asc\"}, {id: 1, name: \"do dishes\"}) //-> false\n```\n\nThe fix is to either ignore `sort` like:\n\n```js\nvar algebra = new set.Algebra({\n    sort: function() { return true; }\n});\nalgebra.has({sort: \"name asc\"}, {id: 1, name: \"do dishes\"}) //-> false\n```\n\nOr even better, make `sort` actually able to understand sorting:\n\n```js\nvar algebra = new set.Algebra(\n    set.props.sort(\"sort\")\n);\nalgebra.has({sort: \"name asc\"}, {id: 1, name: \"do dishes\"}) //-> true\n```\n\nSimilarly, you can verify that [can-set.Algebra.prototype.getSubset]\nworks.  The following, with a default algebra gives\nthe wrong results:\n\n```js\nvar algebra = new set.Algebra();\nalgebra.getSubset(\n    {offset: 1, limit: 2},\n    {},\n    [\n        {id: 1, name: \"do dishes\"}\n        {id: 2, name: \"mow lawn\"},\n        {id: 3, name: \"trash\"}]) //-> []\n```\n\nThis is because it's looking for instance data where `offset===1` and `limit===2`.\nAgain, you can teach your algebra what to do with these properties like:\n\n```js\nvar algebra = new set.Algebra(\n    set.props.offsetLimit(\"offset\",\"limit\")\n);\nalgebra.getSubset(\n    {offset: 1, limit: 2},\n    {},\n    [\n        {id: 1, name: \"do dishes\"}\n        {id: 2, name: \"mow lawn\"},\n        {id: 3, name: \"trash\"}]) //-> [\n            //  {id: 2, name: \"mow lawn\"},\n            // {id: 3, name: \"trash\"}\n            // ]\n```\n\n",
    "description": " \ncan-set is a utility for comparing [can-set/Set sets] that are represented by the parameters commonly passed to service requests.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nOnce you've imported the `can-set` module into your project, use it to create a `set.Algebra` and then use that to compare and perform operations on sets.  \n\n```js\nvar set = require('can-set');\n// create an algebra\nvar algebra = new set.Algebra(\n    // specify the unique identifier on data\n    set.props.id(\"_id\"),  \n    // specify that completed can be true, false or undefined\n    set.props.boolean(\"completed\"),\n    // specify properties that define pagination\n    set.props.rangeInclusive(\"start\",\"end\"),\n    // specify the property that controls sorting\n    set.props.sort(\"orderBy\"),\n)\n\n// compare two sets\nalgebra.subset({start: 2, end: 3}, {start: 1, end: 4}) //-> true\nalgebra.difference({} , {completed: true}) //-> {completed: false}\n\n// perform operations on sets\nalgebra.getSubset({start: 2,end: 3},{start: 1,end: 4},\n            [{id: 1},{id: 2},{id: 3},{id: 4}])\n//-> [{id: 2},{id: 3}]\n```\n"
      }
    ],
    "name": "can-set",
    "parent": "can-core",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.4",
          "bit-docs-generate-readme": "^0.0.10"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "parent": "can-set",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-set/issues"
      },
      "dependencies": {
        "can-namespace": "^1.0.0",
        "can-util": "^3.0.1"
      },
      "description": "Set logic for CanJS",
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "jshint": "^2.7.0",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "homepage": "https://github.com/canjs/can-set",
      "keywords": [
        "canjs"
      ],
      "license": "MIT",
      "main": "src/set.js",
      "name": "can-set",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-set.git"
      },
      "scripts": {
        "build": "node build.js",
        "jshint": "jshint src/. --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "plugins": [
          "steal-qunit"
        ]
      },
      "version": "1.2.0"
    },
    "comment": " "
  },
  "can-set.props": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.props.md"
    },
    "body": "",
    "description": "Contains a collection of prop generating functions. \nThe following functions create `compares` objects that can be mixed together to create a set `Algebra`.\n\n```js\nvar set = require(\"can-set\");\nvar algebra = new set.Algebra(\n  {\n    // ignore this property in set algebra\n    sessionId:  function(){ return true }\n  },\n  set.props.boolean(\"completed\"),\n  set.props.rangeInclusive(\"start\",\"end\")\n);\n```\n\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "props",
    "name": "can-set.props",
    "type": "property",
    "parent": "can-set.properties"
  },
  "exports": {
    "name": "exports",
    "type": "property",
    "parent": "node_modules/can-set/src/clause.js",
    "src": {
      "line": 5,
      "codeLine": 12,
      "path": "node_modules/can-set/src/clause.js"
    },
    "body": "\nnew clause.Where()\n\nThis is so we can tell what type of clause some properties are for.\n\n",
    "description": "Exports a clause constructor functions like:\n"
  },
  "subsetComparesType": {
    "type": "function",
    "name": "subsetComparesType",
    "params": [
      {
        "name": "a",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "b",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "aParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "bParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "prop",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "compares",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-set/src/compare.js",
    "src": {
      "line": 171,
      "codeLine": 177,
      "path": "node_modules/can-set/src/compare.js"
    },
    "body": " \n",
    "description": "Checks if A is a subset of B.  If A is a subset of B if:\n- A \\ B = undefined\n- A ∩ B = defined\n- B ∩ A = defined\n"
  },
  "properSubsetComparesType": {
    "type": "function",
    "name": "properSubsetComparesType",
    "params": [
      {
        "name": "a",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "b",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "aParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "bParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "prop",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "compares",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-set/src/compare.js",
    "src": {
      "line": 238,
      "codeLine": 241,
      "path": "node_modules/can-set/src/compare.js"
    },
    "body": " \n",
    "description": "Checks if A is a subset of B.  If A is a subset of B, A \\ B will be undefined. But B \\ A will be defined.\n"
  },
  "can-set.props.enum": {
    "type": "function",
    "name": "can-set.props.enum",
    "parent": "can-set.props",
    "src": {
      "line": 136,
      "codeLine": 148,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "\n",
    "title": "enum",
    "signatures": [
      {
        "code": "set.props.enum(property, propertyValues)",
        "description": "\n\nMakes a prop for a set of values.\n\n```\nvar compare = set.props.enum(\"type\", [\"new\",\"accepted\",\"pending\",\"resolved\"])\n```\n ",
        "params": []
      }
    ]
  },
  "can-set.props.boolean": {
    "type": "function",
    "name": "can-set.props.boolean",
    "parent": "can-set.props",
    "src": {
      "line": 256,
      "codeLine": 278,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports boolean properties. \n",
    "title": "boolean",
    "signatures": [
      {
        "code": "set.props.boolean(property)",
        "description": "\n\nMakes a compare object with a `property` function that has the following logic:\n\n```js\nA(true) ∪ B(false) = undefined\n\nA(undefined) \\ B(true) = false\nA(undefined) \\ B(false) = true\n```\n\nIt understands that `true` and `false` are complementary sets that combined to `undefined`. Another way to think of this is that if you load `{complete: false}` and `{complete: true}` you've loaded `{}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The name of the boolean property."
          },
          {
            "types": [
              {
                "type": "can-set.compares"
              }
            ],
            "name": "A",
            "description": "`Compares` object that can be an argument to [can-set.Algebra]\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "name": "A",
      "description": "`Compares` object that can be an argument to [can-set.Algebra]\n "
    }
  },
  "can-set.props.sort": {
    "type": "function",
    "name": "can-set.props.sort",
    "parent": "can-set.props",
    "src": {
      "line": 303,
      "codeLine": 333,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Defines the sortable property and behavior. \n",
    "title": "sort",
    "signatures": [
      {
        "code": "set.props.sort(prop, [sortFunc])",
        "description": "\n\nDefines the sortable property and behavior.\n\n```js\nvar algebra = new set.Algebra(set.props.sort(\"sortBy\"));\nalgebra.index(\n  {sortBy: \"name desc\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 1\n\nalgebra.index(\n  {sortBy: \"name\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "The sortable property."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "sortPropValue"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "item1"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "item2"
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "sortFunc",
            "description": "The\nsortable behavior. The default behavior assumes the sort property value\nlooks like `PROPERTY DIRECTION` (ex: `name desc`)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "sortPropValue"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "item1"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "item2"
                }
              ]
            }
          ]
        }
      ],
      "optional": true,
      "name": "sortFunc",
      "description": "The\nsortable behavior. The default behavior assumes the sort property value\nlooks like `PROPERTY DIRECTION` (ex: `name desc`)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
    }
  },
  "can-set.props.id": {
    "type": "function",
    "name": "can-set.props.id",
    "parent": "can-set.props",
    "src": {
      "line": 341,
      "codeLine": 370,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Defines the identify property. \n",
    "title": "id",
    "signatures": [
      {
        "code": "set.props.id(prop)",
        "description": "\n\nDefines the property name on items that uniquely\nidentifies them. This is the default sorted property if no\n[can-set.props.sort] is provided.\n\n```js\nvar algebra = new set.Algebra(set.props.id(\"_id\"));\nalgebra.index(\n  {sortBy: \"name desc\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 1\n\nalgebra.index(\n  {sortBy: \"name\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "The property name that defines the unique property id."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "prop",
      "description": "The property name that defines the unique property id."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
    }
  },
  "can-set.props.offsetLimit": {
    "type": "function",
    "name": "can-set.props.offsetLimit",
    "parent": "can-set.props",
    "src": {
      "line": 407,
      "codeLine": 427,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports sets that include a limit and offset. \n",
    "title": "offsetLimit",
    "signatures": [
      {
        "code": "set.props.offsetLimit( [offsetProperty][, limitProperty] )",
        "description": "\n\nMakes a prop for two ranged properties that specify a range of items\nthat includes both the offsetProperty and limitProperty.  For example, set like:\n`{offset: 20, limit: 10}` loads 10 items starting at index 20.\n\n```\nnew set.Algebra( set.props.offsetLimit(\"offset\",\"limit\") );\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "offsetProperty",
            "description": "The offset property name on sets.  Defaults to `\"offset\"` if none is provided."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "limitProperty",
            "description": "The offset limit name on sets. Defaults to `\"limit\"` if none is provided."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a comparator used to build a set algebra.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "limitProperty",
      "description": "The offset limit name on sets. Defaults to `\"limit\"` if none is provided."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a comparator used to build a set algebra.\n"
    }
  },
  "can-set.props.rangeInclusive": {
    "type": "function",
    "name": "can-set.props.rangeInclusive",
    "parent": "can-set.props",
    "src": {
      "line": 439,
      "codeLine": 459,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports ranged properties. \n",
    "title": "rangeInclusive",
    "signatures": [
      {
        "code": "set.props.rangeInclusive(startIndexProperty, endIndexProperty)",
        "description": "\n\nMakes a prop for two ranged properties that specify a range of items\nthat includes both the startIndex and endIndex.  For example, a range of\n[0,20] loads 21 items.\n\n```\nset.props.rangeInclusive(\"start\",\"end\")\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "startIndexProperty",
            "description": "The starting property name"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "endIndexProperty",
            "description": "The ending property name"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a prop\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "endIndexProperty",
      "description": "The ending property name"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a prop\n"
    }
  },
  "can-set.props.dotNotation": {
    "type": "function",
    "name": "can-set.props.dotNotation",
    "parent": "can-set.props",
    "src": {
      "line": 496,
      "codeLine": 514,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports MongoDB-style 'dot notation' properties. \n",
    "title": "dotNotation",
    "signatures": [
      {
        "code": "set.props.dotNotation(dotProperty)",
        "description": "\n\nDefines a property that specifies a MongoDB-style nested property match.\nFor example, a set property of \"address.city\" matches against the value of the nested `{address: {city}}` value.\n\n```\nset.props.dotNotation(\"address.city\")\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "dotProperty",
            "description": "The MongoDB-style nested property name"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a comparator used to build a set algebra\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "dotProperty",
      "description": "The MongoDB-style nested property name"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a comparator used to build a set algebra\n"
    }
  },
  "can-set.Translate": {
    "type": "function",
    "name": "can-set.Translate",
    "parent": "can-set.properties",
    "src": {
      "line": 9,
      "codeLine": 33,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "",
    "title": "Translate",
    "signatures": [
      {
        "code": "new set.Translate(clauseType, propertyName)",
        "description": "\n\nLocalizes a clause's properties within another nested property.\n\n```js\nvar algebra = new set.Algebra(\n  new set.Translate(\"where\",\"$where\")\n);\nalgebra.has(\n  {$where: {complete: true}},\n  {id: 5, complete: true}\n) //-> true\n```\n\nThis is useful when filters (which are `where` clauses) are\nwithin a nested object.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "clause",
            "description": "A clause type.  One of `'where'`, `'order'`, `'paginate'`, `'id'`."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "propertyName",
            "description": "The property name which contains the clauses's properties."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "A set compares object that can do the translation.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "propertyName",
      "description": "The property name which contains the clauses's properties."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "A set compares object that can do the translation.\n"
    }
  },
  "Algebra": {
    "type": "function",
    "name": "Algebra",
    "params": [],
    "parent": "node_modules/can-set/src/set-core.js",
    "src": {
      "line": 49,
      "codeLine": 56,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "\nnew set.Algebra(Where(),Paginate(),Sort())\n\n\n",
    "description": "An `Algebra` internally keeps different properties organized by clause type.\nIf an object comes in that isn't a clause type, it's assuemd to be a where.\n"
  },
  "can-set.Algebra.prototype.equal": {
    "type": "function",
    "name": "can-set.Algebra.prototype.equal",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 249,
      "codeLine": 265,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "equal",
    "signatures": [
      {
        "code": "algebra.equal(a, b)",
        "description": "\n\n  Returns true if the two sets the exact same.\n\n  ```js\n  algebra.equal({type: \"critical\"}, {type: \"critical\"}) //-> true\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the two sets are equal.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the two sets are equal.\n "
    }
  },
  "can-set.Algebra.prototype.subset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.subset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 268,
      "codeLine": 285,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "subset",
    "signatures": [
      {
        "code": "algebra.subset(a, b)",
        "description": "\n\nReturns true if _A_ is a subset of _B_ or _A_ is equal to _B_ (_A_ ⊆ _B_).\n\n```js\nalgebra.subset({type: \"critical\"}, {}) //-> true\nalgebra.subset({}, {}) //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `a` is a subset of `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `a` is a subset of `b`.\n "
    }
  },
  "can-set.Algebra.prototype.properSubset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.properSubset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 308,
      "codeLine": 325,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "properSubset",
    "signatures": [
      {
        "code": "algebra.properSubset(a, b)",
        "description": "\n\nReturns true if _A_ is a strict subset of _B_ (_A_ ⊂ _B_).\n\n```js\nalgebra.properSubset({type: \"critical\"}, {}) //-> true\nalgebra.properSubset({}, {}) //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `a` is a subset of `b` and not equal to `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `a` is a subset of `b` and not equal to `b`.\n "
    }
  },
  "can-set.Algebra.prototype.difference": {
    "type": "function",
    "name": "can-set.Algebra.prototype.difference",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 328,
      "codeLine": 360,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "difference",
    "signatures": [
      {
        "code": "algebra.difference(a, b)",
        "description": "\n\nReturns a set that represents the difference of sets _A_ and _B_ (_A_ \\ _B_), or\nreturns if a difference exists.\n\n```js\nalgebra1 = new set.Algebra(set.props.boolean(\"completed\"));\nalgebra2 = new set.Algebra();\n\n// A has all of B\nalgebra1.difference( {} , {completed: true} ) //-> {completed: false}\n\n// A has all of B, but we can't figure out how to create a set object\nalgebra2.difference( {} , {completed: true} ) //-> true\n\n// A is totally inside B\nalgebra2.difference( {completed: true}, {} )  //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set/Set"
            },
            {
              "type": "Boolean"
            }
          ],
          "description": "If an object is returned, it is difference of sets _A_ and _B_ (_A_ \\ _B_).\n\nIf `true` is returned, that means that _B_ is a subset of _A_, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is no difference or the sets are not comparable.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set/Set"
        },
        {
          "type": "Boolean"
        }
      ],
      "description": "If an object is returned, it is difference of sets _A_ and _B_ (_A_ \\ _B_).\n\nIf `true` is returned, that means that _B_ is a subset of _A_, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is no difference or the sets are not comparable.\n "
    }
  },
  "can-set.Algebra.prototype.union": {
    "type": "function",
    "name": "can-set.Algebra.prototype.union",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 392,
      "codeLine": 413,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "union",
    "signatures": [
      {
        "code": "algebra.union(a, b)",
        "description": "\n\nReturns a set that represents the union of _A_ and _B_ (_A_ ∪ _B_).\n\n```js\nalgebra.union(\n  {start: 0, end: 99},\n  {start: 100, end: 199},\n) //-> {start: 0, end: 199}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set/Set"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If an object is returned, it is the union of _A_ and _B_ (_A_ ∪ _B_).\n\nIf `undefined` is returned, it means a union can't be created.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set/Set"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If an object is returned, it is the union of _A_ and _B_ (_A_ ∪ _B_).\n\nIf `undefined` is returned, it means a union can't be created.\n "
    }
  },
  "can-set.Algebra.prototype.intersection": {
    "type": "function",
    "name": "can-set.Algebra.prototype.intersection",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 446,
      "codeLine": 467,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "intersection",
    "signatures": [
      {
        "code": "algebra.count(set)",
        "description": "\n\nReturns the number of items that might be loaded by the `set`. This makes use of set.Algebra's\nBy default, this returns Infinity.\n\n```js\nvar algebra =  new set.Algebra({\n  set.props.rangeInclusive(\"start\", \"end\")\n});\nalgebra.count({start: 10, end: 19}) //-> 10\nalgebra.count({}) //-> Infinity\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "[description]"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of items in the set if known, `Infinity`\nif unknown.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "[description]"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of items in the set if known, `Infinity`\nif unknown.\n "
    }
  },
  "can-set.Algebra.prototype.has": {
    "type": "function",
    "name": "can-set.Algebra.prototype.has",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 470,
      "codeLine": 493,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "has",
    "signatures": [
      {
        "code": "algebra.has(set, props)",
        "description": "\n\nUsed to tell if the `set` contains the instance object `props`.\n\n```\nvar algebra = new set.Algebra(\n  new set.Translate(\"where\",\"$where\")\n);\nalgebra.has(\n  {\"$where\": {playerId: 5}},\n  {id: 5, type: \"3pt\", playerId: 5, gameId: 7}\n) //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An instance's raw data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Returns `true` if `props` belongs in `set` and\n`false` it not.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An instance's raw data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Returns `true` if `props` belongs in `set` and\n`false` it not.\n "
    }
  },
  "can-set.Algebra.prototype.index": {
    "type": "function",
    "name": "can-set.Algebra.prototype.index",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 520,
      "codeLine": 549,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "index",
    "signatures": [
      {
        "code": "algebra.index(set, items, item)",
        "description": "\n\nReturns where `item` should be inserted into `items` which is represented by `set`.\n\n```js\nalgebra = new set.Algebra(\n  set.props.sort(\"orderBy\")\n);\nalgebra.index(\n  {orderBy: \"age\"},\n  [{id: 1, age: 3},{id: 2, age: 5},{id: 3, age: 8},{id: 4, age: 10}],\n  {id: 6, age: 3}\n)  //-> 2\n```\n\nThe default sort property is what is specified by\n[can-set.props.id]. This means if that if the sort property\nis not specified, it will assume the set is sorted by the specified\nid property.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The `set` that describes `items`."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "items",
            "description": "An array of data objects."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "item",
            "description": "The data object to be inserted."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The position to insert `item`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "item",
      "description": "The data object to be inserted."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The position to insert `item`.\n "
    }
  },
  "can-set.Algebra.prototype.getSubset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.getSubset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 573,
      "codeLine": 597,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "getSubset",
    "signatures": [
      {
        "code": "algebra.getSubset(a, b, bData)",
        "description": "\n\nGets `a` set's items given a super set `b` and its items.\n\n```js\nalgebra.getSubset(\n  {type: \"dog\"},\n  {},\n  [{id: 1, type:\"cat\"},\n   {id: 2, type: \"dog\"},\n   {id: 3, type: \"dog\"},\n   {id: 4, type: \"zebra\"}]\n) //-> [{id: 2, type: \"dog\"},{id: 3, type: \"dog\"}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "The set whose data will be returned."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A superset of set `a`."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "bData",
            "description": "The data in set `b`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The data in set `a`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "bData",
      "description": "The data in set `b`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "The data in set `a`.\n "
    }
  },
  "can-set.Algebra.prototype.getUnion": {
    "type": "function",
    "name": "can-set.Algebra.prototype.getUnion",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 613,
      "codeLine": 639,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "getUnion",
    "signatures": [
      {
        "code": "algebra.getUnion(a, b, aItems, bItems)",
        "description": "\n\nUnifies items from set A and setB into a single array of items.\n\n```js\nalgebra = new set.Algebra(\n  set.props.rangeInclusive(\"start\",\"end\")\n);\nalgebra.getUnion(\n  {start: 1,end: 2},\n  {start: 2,end: 4},\n  [{id: 1},{id: 2}],\n  [{id: 2},{id: 3},{id: 4}]);\n  //-> [{id: 1},{id: 2},{id: 3},{id: 4}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "aItems",
            "description": "Set `a`'s items."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "bItems",
            "description": "Set `b`'s items."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns items in both set `a` and set `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "bItems",
      "description": "Set `b`'s items."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns items in both set `a` and set `b`.\n "
    }
  },
  "can-set.Algebra.prototype.id": {
    "type": "function",
    "name": "can-set.Algebra.prototype.id",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 687,
      "codeLine": 714,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "id",
    "signatures": [
      {
        "code": "algebra.id(props)",
        "description": "\n\nReturns the configured `id` property value from `props`.  If there are\nmultiple ids, a `JSON.stringify`-ed JSON object is returned with each\n[can-set.props.id] value is returned.\n\n```js\nvar algebra1 = new set.Algebra(set.props.id(\"_id\"));\nalgebra1.id({_id: 5}) //-> 5\n\nvar algebra2 = new set.Algebra(\n  set.props.id(\"studentId\"),\n  set.props.id(\"classId\")\n);\n\nalgebra2.id({studentId: 6, classId: \"7\", foo: \"bar\"})\n    //-> '{\"studentId\": 6, \"classId\": \"7\"}'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An instance's raw data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "String"
            }
          ],
          "description": "If a single [can-set.props.id] is configured, it's value will be returned.\nIf multiple [can-set.props.id] properties are configured a `JSON.stringify`-ed object is returned.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An instance's raw data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "String"
        }
      ],
      "description": "If a single [can-set.props.id] is configured, it's value will be returned.\nIf multiple [can-set.props.id] properties are configured a `JSON.stringify`-ed object is returned.\n "
    }
  },
  "can-simple-map.prototype.attr": {
    "src": {
      "path": "node_modules/can-simple-map/docs/prototype.attr.md"
    },
    "body": "\n## Use\n\n`attr` gets or sets properties on the `SimpleMap` it's called on. Here's a tour through how all of its forms work:\n\n```\nvar map = new SimpleMap({ age: 29 });\n\n// get a property:\nfoo.attr('age'); // 29\n\n// set a property:\nfoo.attr('age', 30);\nfoo.attr('age'); // 30\n\n// set and merge multiple properties:\nfoo.attr({\n\tfirst: 'Kevin',\n\tlast: 'Phillips'\n});\nfoo.attr('age'); // 30\nfoo.attr('first'); // 'Kevin'\nfoo.attr('last'); // 'Phillips'\n```\n\nWhen properties are changed using attr, the `SimpleMap` will emit events. Events can be listened to using [can-event.on] or [can-event.bind].\n\n```\nvar map = new SimpleMap({ age: 29 });\n\nmap.on('age', function(ev, newVal, oldVal) {\n\tnewVal; // 30\n\toldVal; // 29\n});\n\nmap.attr('age', 30);\n```\n\n",
    "description": "Get or set properties on a SimpleMap. \n",
    "title": "attr",
    "name": "can-simple-map.prototype.attr",
    "type": "function",
    "parent": "can-simple-map.prototype",
    "signatures": [
      {
        "code": "map.attr(key)",
        "description": "\n\nReads a property from this `SimpleMap`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The property to read."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value assigned to _key_.\n"
        }
      },
      {
        "code": "map.attr(key, value)",
        "description": "\n\nAssigns _value_ to a property on this `SimpleMap` called _key_.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The property to set."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign to _key_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.SimpleMap"
            }
          ],
          "description": "This SimpleMap, for chaining.\n"
        }
      },
      {
        "code": "map.attr(obj)",
        "description": "\n\nAssigns each value in _obj_ to a property on this `SimpleMap` named after the\ncorresponding key in _obj_, effectively merging _obj_ into the SimpleMap.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "A collection of key-value pairs to set.\nIf any properties already exist on the `SimpleMap`, they will be overwritten.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.SimpleMap"
            }
          ],
          "description": "this SimpleMap, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.SimpleMap"
        }
      ],
      "description": "this SimpleMap, for chaining\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "A collection of key-value pairs to set.\nIf any properties already exist on the `SimpleMap`, they will be overwritten.\n"
    },
    "comment": " "
  },
  "can-simple-map.prototype.get": {
    "src": {
      "path": "node_modules/can-simple-map/docs/prototype.get.md"
    },
    "body": "\n\n",
    "description": "Get properties on a SimpleMap. \n",
    "title": "get",
    "name": "can-simple-map.prototype.get",
    "type": "function",
    "parent": "can-simple-map.prototype",
    "signatures": [
      {
        "code": "map.get(key)",
        "description": "\n\nReads a property from this `SimpleMap`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The property to read."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value assigned to _key_.\n\n"
        }
      },
      {
        "code": "map.get()",
        "description": "\n\nReturns the data of this simple-map as a plain JavaScript object.\n\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The data as a plain JavaScript object of this simple-map.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The data as a plain JavaScript object of this simple-map.\n"
    },
    "comment": " "
  },
  "can-simple-map.prototype.serialize": {
    "src": {
      "path": "node_modules/can-simple-map/docs/prototype.serialize.md"
    },
    "body": "",
    "description": "Returns the serialized form of the simple-map. \n",
    "title": "serialize",
    "name": "can-simple-map.prototype.serialize",
    "type": "function",
    "parent": "can-simple-map.prototype",
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n\nReturns the serialized form of the simple-map, with any values in the map that\nhave a serialize method also having serialized called.\n\n```js\nvar map = new SimpleMap();\nmap.set(\"deep\", new SimpleMap({a: \"b\"}));\n\nmap.serialize() //->  {deep: {a: \"b\"}}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A plain JavaScript object that will only contain\nprimitives and other plain JavaScript objects.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A plain JavaScript object that will only contain\nprimitives and other plain JavaScript objects.\n"
    }
  },
  "can-simple-map.prototype.set": {
    "src": {
      "path": "node_modules/can-simple-map/docs/prototype.set.md"
    },
    "body": "\n",
    "description": "Set properties on a SimpleMap. \n",
    "title": "set",
    "name": "can-simple-map.prototype.set",
    "type": "function",
    "parent": "can-simple-map.prototype",
    "signatures": [
      {
        "code": "map.set(key, value)",
        "description": "\n\nAssigns _value_ to a property on this `SimpleMap` called _key_.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The property to set"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign to _key_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.SimpleMap"
            }
          ],
          "description": "this SimpleMap, for chaining\n"
        }
      },
      {
        "code": "map.set(obj)",
        "description": "\n\nAssigns each value in _obj_ to a property on this `SimpleMap` named after the\ncorresponding key in _obj_, effectively merging _obj_ into the SimpleMap.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "a collection of key-value pairs to set.\nIf any properties already exist on the `SimpleMap`, they will be overwritten.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.SimpleMap"
            }
          ],
          "description": "this SimpleMap, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.SimpleMap"
        }
      ],
      "description": "this SimpleMap, for chaining\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "a collection of key-value pairs to set.\nIf any properties already exist on the `SimpleMap`, they will be overwritten.\n"
    },
    "comment": " "
  },
  "can-simple-map.prototype": {
    "name": "can-simple-map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-simple-map",
    "description": "",
    "order": 0
  },
  "can-simple-map": {
    "src": {
      "path": "node_modules/can-simple-map/docs/simple-map.md"
    },
    "body": "\n## Use\n\n`SimpleMap` provides a way to create an Observable whose properties can be changed using [can-simple-map.prototype.attr attr].\n\n```\nvar map = new SimpleMap({ age: 29 });\n\nmap.on('age', function(ev, newVal, oldVal) {\n\tnewVal; // 30\n\toldVal; // 29\n});\n\nfoo.attr('age'); // 29\n\nmap.attr('age', 30);\n```\n\n",
    "description": "A performant live-bound map. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "name": "can-simple-map",
    "parent": "can-infrastructure",
    "inherits": "can",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-simple-map/issues"
      },
      "dependencies": {
        "can-construct": "^3.0.0",
        "can-event": "^3.0.1",
        "can-observation": "^3.0.1",
        "can-types": "^1.0.1",
        "can-util": "^3.1.1"
      },
      "description": "A performant live-bound map",
      "devDependencies": {
        "can-compute": "^3.0.4",
        "documentjs": "^0.4.2",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.4",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "https://canjs.com",
      "keywords": [],
      "main": "can-simple-map",
      "name": "can-simple-map",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-simple-map.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "documentjs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-simple-map",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.1.4"
    },
    "signatures": [
      {
        "code": "new SimpleMap([props])",
        "description": "\n\nCreates a new instance of can.SimpleMap.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the Observe with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.SimpleMap"
            }
          ],
          "description": "An instance of `can.SimpleMap` with the properties from _props_.\n"
        }
      },
      {
        "code": "SimpleMap.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.SimpleMap"
        }
      ],
      "description": "An instance of `can.SimpleMap` with the properties from _props_.\n"
    },
    "comment": " "
  },
  "can-stache.Acquisition": {
    "src": {
      "path": "node_modules/can-stache/docs/acquisition.md"
    },
    "body": "\n## Raw Text\n\nRaw text can be templated by passing the text containing your template.  For example:\n\n\tvar text = \"My body lies over the {{.}}\",\n\t\ttemplate = stache(text),\n\t\tfragment = template(\"ocean\");\n\n\tdocument.body.appendChild(fragment);\n\n## Module Loaders\n\nFor [http://stealjs.com StealJS], use [steal-stache] to import stache templates directly.\n\n\n## Script Tags\n\nYou can embed a `<script>` tag and use its text as a stache template like:\n\n```html\n<script type='text/stache' id='my-template'>\n  <h1>{{message}}</h1>\n</script>\n```\n\nLoad this template like:\n\n```js\nvar stache = require(\"can-stache\");\nvar text = document.getElementById(\"my-template\");\nvar template = stache(text);\n```\n\n",
    "description": "\nThere are number of ways to acquire templates such as: raw text,\na module loader, or script tags in the markup.\n",
    "name": "can-stache.Acquisition",
    "title": "Template Acquisition",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 3
  },
  "can-stache.scopeAndContext": {
    "src": {
      "path": "node_modules/can-stache/docs/context.md"
    },
    "body": "\nEvery part of a stache template is rendered with a\ngiven [can-view-scope scope]. The scope is used to lookup\nvalues. A scope can contain multiple places to lookup values. Each of those\nplaces is called a `context`.  \n\nThis is very similar to how `last` is looked up in the following JavaScript:\n\n```js\nvar message = \"Hello\"\nfunction outer(){\n\tvar last = \"Abril\";\n\n\tfunction inner(){\n\t\tvar first = \"Alexis\";\n\t\tconsole.log(message + \" \"+ first + \" \" + last);\n\t}\n\tinner();\n}\nouter();\n```\n\nJavaScript looks for `last` looks in the `inner` context and then walks up the\nscope to the `outer` context to find a `last` variable.\n\n\nLets look at what happens with the scope the following example:\n\n```\nTemplate:\n\t<h1>{{message}} {{#person}}{{first}} {{last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\"},\n\t  last: \"Abril\",\n\t  message: \"Hello\" }\n\nResult:\n\t<h1>Hello Alexis Abril</h1>\n```\n\n1. The template is rendered with `Data` as the only item in the scope. `scope:[Data]`\n2. `{{message}}` is looked up within `Data`.\n3. `{{#person}}` adds the `person` context to the top of the scope. `scope:[Data,Data.person]`\n4. `{{first}}` is looked up in the scope.  It will be found on `Data.person`.\n5. `{{last}}` is looked up in the scope.  \n   1. `last` is looked in `Data.person`, it's not found.\n   2. `last` is looked up in `Data` and returned.\n6. `{{/person}}` removes `person` from the scope. `scope:[Data]`\n\n\n\nThe context used to lookup a value can be controlled with adding `../` or `./` before a\nkey. For instance, if we wanted to make sure `last` was only going to lookup on `person`,\nwe could change the template to:\n\n```\nTemplate:\n\t<h1>{{message}} {{#person}}{{first}}  {{./last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\"},\n\t  last: \"Abril\",\n\t  message: \"Hello\" }\n\nResult:\n\t<h1>Hello Alexis </h1>\n```\n\n[can-stache.tags.section Sections], [can-stache.Helpers Helpers],\nand [can-component custom elements] can modify the scope used to render a subsection.\n\n[can-stache.key] modifiers  like `../` and `@key` can control the context and value that\ngets returned.\n\n",
    "description": "\n",
    "name": "can-stache.scopeAndContext",
    "title": "Scope and Context",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 1,
    "comment": " "
  },
  "can-stache.getterSetter": {
    "src": {
      "path": "node_modules/can-stache/docs/getterSetter.md"
    },
    "body": "\n",
    "description": "The getterSetter argument passed to [can-stache.registerConverter registerConverter]. \n",
    "type": "typedef",
    "title": "getterSetter",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "description": "Takes the arguments from a [can-stache/expressions/call]\nand returns a value.\n\nAn argument is a compute if the argument has been marked with a tilde (`~`) prefix, otherwise the\nvalue of the argument is the same as the value of the corresponding scope property.\nAt least one argument should be a compute so `set` can update the value.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "args",
                    "variable": true
                  }
                ]
              }
            ]
          },
          {
            "name": "set",
            "description": "Takes the new value of the `left` side of a\n[can-stache-bindings.twoWay {(two-way)} binding] followed by the other arguments to the\n[can-stache/expressions/call].  This should change one of the compute arguments.\n\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "setValue"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "args",
                    "variable": true
                  }
                ]
              }
            ]
          }
        ],
        "description": "\n\nAn object with a `get` and `set` method that get converted to a two-way helper.\n\n```js\nstache.registerConverter(\"numberToString\", {\n get: function(fooCompute) {\n \treturn \"\" + fooCompute();\n },\n set: function(newVal, fooCompute) {\n \tfooCompute(+newVal);\n }\n});\n```\n\n\nA `getterSetter` object provides:\n\n - A `get` method that returns the value\n  of the `left` value given the arguments passed on the `right`.\n - a `set` method that updates one or multiple of the `right` arguments\n   computes given a new `left` value.\n"
      }
    ],
    "name": "can-stache.getterSetter",
    "parent": "can-stache.types",
    "comment": " "
  },
  "can-stache.from": {
    "src": {
      "path": "node_modules/can-stache/docs/from.md"
    },
    "body": "\n",
    "description": "Return a template loaded from an element. \n",
    "title": "from",
    "name": "can-stache.from",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.from(id)",
        "description": "\n\nLoad a template from an HTML element (usually a `<script>` element)\nspecified by id.  This is used typically for demo purposes.\n\nFor example, with a `<script>` tag as follows in your HTML:\n\n```\n<script type='text/stache' id='my-template'>\n<h1>{{message}}</h1>\n</script>\n```\n\nLoad and render that template like:\n\n```\nvar template = stache.from(\"my-template\");\ntemplate({message: \"Hello There!\"});\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "id",
            "description": "The id of the element, whose `innerHTML` will be used to create a template."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A renderer function that will render the\ntemplate.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "id",
      "description": "The id of the element, whose `innerHTML` will be used to create a template."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A renderer function that will render the\ntemplate.\n"
    },
    "comment": " "
  },
  "can-stache.helper": {
    "src": {
      "path": "node_modules/can-stache/docs/helper.md"
    },
    "body": "\n\n## Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create stache tags that have rich behavior.\n\nIf the helper is called __within a tag__ like:\n\n    <ul {{sortable}}/>\n\nThe returned function is called with the `<ul>` element:\n\n    stache.registerHelper(\"sortable\",function(){\n      return function(el){\n        $(el).slider();\n      }\n    });\n\nIf the helper is called __between tags__ like:\n\n    <ul>{{items}}</ul>\n\nThe returned function is called with a temporary text node:\n\n    stache.registerHelper(\"items\",function(){\n      return function(textNode){\n\t\t  // do something, probably replace textNode\n      }\n    });\n\nWhile this form of helper is still supported, it's more common\nto create similar functionality with [can-component] or [can-view-callbacks].\n\n",
    "description": "A helper function passed to [can-stache.registerHelper]. \nGiven the arguments, returns the content that should be shown in the DOM\nor a function that will be called on the DOM element the helper was\ncalled on.\n\n",
    "type": "typedef",
    "title": "helper",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            },
            {
              "type": "String"
            },
            {
              "type": "Array"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "Node"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The content to be inserted into the template or a callback function.  The content can be a:\n\n - `documentFragment` like those returned by [can-stache.helperOptions].fn.\n - `String` like `\"Hello World\"`\n - `Array` of strings and nodes like `[\"Hello\", document.createElement('div')]`\n\nIf a `function(Node)` is returned, it will be called back with an HTML Element or text node.  \n\nIf the helper is called on an element like:\n\n```\n<div {{myHelper}}>\n```\n\n... the callback function will be called with the `div`.  \n\nIf the helper is called\noutside of an element's tag like:\n\n```\n<div> {{myHelper}} </div>\n```\n\n... the callback function will be called with a placeholder text node.  \n\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-compute"
              }
            ],
            "optional": true,
            "variable": true,
            "name": "arg",
            "description": "Arguments passed from the tag. After the helper\nname, any space separated [can-stache.key keys], numbers or\nstrings are passed as arguments. [can-stache.key Keys] that\nread an observable value in [can-stache/expressions/helper helpers] are passed as [can-compute.computed]s .\n"
          },
          {
            "types": [
              {
                "type": "can-stache.helperOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "An options object\nthat is an additional argument in `Helper` expressions that is populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "can-stache.context"
            }
          ],
          "description": "The context the helper was\ncalled within.\n"
        }
      }
    ],
    "name": "can-stache.helper",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helperOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "An options object\nthat is an additional argument in `Helper` expressions that is populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        },
        {
          "type": "String"
        },
        {
          "type": "Array"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "description": "The content to be inserted into the template or a callback function.  The content can be a:\n\n - `documentFragment` like those returned by [can-stache.helperOptions].fn.\n - `String` like `\"Hello World\"`\n - `Array` of strings and nodes like `[\"Hello\", document.createElement('div')]`\n\nIf a `function(Node)` is returned, it will be called back with an HTML Element or text node.  \n\nIf the helper is called on an element like:\n\n```\n<div {{myHelper}}>\n```\n\n... the callback function will be called with the `div`.  \n\nIf the helper is called\noutside of an element's tag like:\n\n```\n<div> {{myHelper}} </div>\n```\n\n... the callback function will be called with a placeholder text node.  \n\n"
    },
    "comment": " "
  },
  "can-stache.helperOptions": {
    "src": {
      "path": "node_modules/can-stache/docs/helperOptions.md"
    },
    "body": "",
    "description": "The options argument passed to a [can-stache.helper helper function] when called by a [can-stache/expressions/helper].\n\n",
    "type": "typedef",
    "title": "helperOptions",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "fn",
            "description": "Renders the \"truthy\" subsection\nBLOCK.  `options.fn` is only available if the helper is called as a\n[can-stache.tags.section] or [can-stache.tags.inverse]. Read about\n[can-stache.sectionRenderer section renderer] for more information.\n",
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true
          },
          {
            "name": "inverse",
            "description": "Renders the \"falsey\" subsection\nINVERSE.  `options.inverse` is only available if the helper is called as a\n[can-stache.tags.section] or [can-stache.tags.inverse] and [can-stache.helpers.else]\nis used. Read about\n[can-stache.sectionRenderer section renderer] for more information.\n",
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true
          },
          {
            "name": "hash",
            "description": "An object containing all of the\n[can-stache.expressions Hash expression] keys and values. For example:\n\n```\n{{helper arg1 arg2 name=value other=3 position=\"top\"}}\n```\n\nmight provide a `hash` like:\n\n```\n{\n\t\tname: compute(\"Mr. Pig\"),\n\t\tother: 3,\n\t\tposition: \"top\"\n}\n```\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "context",
            "description": "The current context the stache helper is called within. Read\n[can-stache.scopeAndContext] for more information.\n\n",
            "types": [
              {
                "type": "*"
              }
            ]
          },
          {
            "name": "scope",
            "description": "An object that represents the current context and all parent\ncontexts. It can be used to look up [can-stache.key key] values in the current scope.\nRead [can-stache.scopeAndContext] and [can-view-scope] for more information.\n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "It can be used to look up [can-stache.key key] values in the current options scope.\nRead [can-stache.scopeAndContext] and [can-view-scope.Options] for more information.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          }
        ],
        "description": "\n\nWhen a [can-stache.helper helper function]\nis called by a [can-stache/expressions/helper], a `helperOptions`\nobject is passed with the following properties:\n\n```\nstache.registerHelper(\"myHelper\", function(helperOptions){\n  helperOptions.fn      //-> sectionRenderer(){}\n  helperOptions.inverse //-> sectionRenderer(){}\n  helperOptions.hash    //-> Object\n  helperOptions.context //-> *\n  helperOptions.scope   //-> Scope\n  helperOptions.option  //-> Scope.Options\n});\n```\n"
      }
    ],
    "name": "can-stache.helperOptions",
    "parent": "can-stache.types"
  },
  "can-stache.Helpers": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers.md"
    },
    "body": "\nExample custom helpers might include:\n\n - Converting a raw `Date` to a more user friendly timestamp. `{{timestamp birthday}}`\n - Internationalization. `{{i18n 'Hello'}}`\n - Convert markdown into HTML. `{{markdown(comment)}}`\n\nStache includes a number of built-in helpers, but custom helpers can be registered as well.\n\n## Built-in Helpers\n\nThe `[can-stache.tags.section {{#if key}}]` helper is used for **if** statements. The **if** helper is similar\nto using a `[can-stache.tags.section {{#key}}]` section. If they key passed to the helper is **truthy**, the\nsection will be rendered.\n\n\tTemplate:\n\t\t{{#if friends}}\n\t\t\tI have friends!\n\t\t{{/if}}\n\n\tData:\n\t\t{\n\t\t\tfriends: true\n\t\t}\n\n\tResult:\n\t\tI have friends!\n\nWhen using the `[can-stache.helpers.if {{#if key}}]` helper, or any other helper for that matter,\nthe special `[can-stache.helpers.else {{else}}]` helper is available. `{{else}}` is equivalent to\nan [can-stache.tags.inverse {{^key}}] inverse section (renders if given **falsey** data), except that it\nonly uses a single tag and exists inside a helper section.\n\n\tTemplate:\n\t\t<ul>\n\t\t\t{{#if friends}}\n\t\t\t\t</li>{{name}}</li>\n\t\t\t{{else}}\n\t\t\t\t<li>No friends.</li>\n\t\t\t{{/if}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tfriends: false\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>No friends.</li>\n\t\t</ul>\n\nThe `[can-stache.helpers.unless {{#unless key}}]` helper is equivalent to using a\n`[can-stache.tags.inverse {{^key}}]` inverse section. If they key passed to the helper is **falsey**, the\nsection will be rendered.\n\n\tTemplate:\n\t\t{{#unless friends}}\n\t\t\tYou don't have any friends!\n\t\t{{/unless}}\n\n\tData:\n\t\t{\n\t\t\tfriends: []\n\t\t}\n\n\tResult:\n\t\tYou don't have any friends!\n\nThe `[can-stache.helpers.each {{#each key}}]` helper is similar to using a\n`[can-stache.tags.section {{#key}}]` section for iterating an array. In this case, the entire array\nwill be rendered using the inner text item by item.\n\n\tTemplate:\n\t\t<ul>\n\t\t\t{{#each friends}}\n\t\t\t\t<li>{{name}}</li>\n\t\t\t{{/each}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tfriends: [\n\t\t\t\t{ name: \"Austin\" },\n\t\t\t\t{ name: \"Justin\" }\n\t\t\t]\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>Austin</li>\n\t\t\t<li>Justin</li>\n\t\t</ul>\n\nThe `[can-stache.helpers.with {{#with key}}]` helper is equivalent to using a\n`[can-stache.tags.section {{#key}}]` section for regular objects. The helper will change\nthe current context so that all tags inside will look for keys on the local context first.\n\n\tTemplate:\n\t\t<h1>Hi {{name}}</h1>\n\t\t{{#with friend}}\n\t\t\t<p>You have a new friend: {{name}}</p>\n\t\t{{/with}}\n\n\tData:\n\t\t{\n\t\t\tname: \"Andy\",\n\t\t\tfriend: { name: \"Justin\" }\n\t\t}\n\n\tResult:\n\t\t<h1>Hi Austin</h1>\n\t\t<p>You have a new friend: Justin</p>\n\nWhen using the `[can-stache.helpers.is {{#is key1 key2}}]` helper you can simply compare\nkey1 and key2. If the result of comparsion is **truthy**, the section will be rendered.\n\n\tTemplate:\n\t\t<ul>\n\t\t{{#is name 'Alex'}}\n\t\t\t</li>Your name is {{name}}</li>\n\t\t{{else}}\n\t\t\t<li>Your name is not Alex!</li>\n\t\t{{/is}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tname: 'John'\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>Your name is not Alex!</li>\n\t\t</ul>\n\n## Registering Helpers\n\nYou can register your own global helper with the `[can-stache.registerSimpleHelper registerSimpleHelper]` or `[can-stache.registerHelper registerHelper]` methods.\n\n`[can-stache.registerSimpleHelper registerSimpleHelper]` calls the registered helper function with\nvalues, while `[can-stache.registerHelper registerHelper]` calls the registered helper function with\n[can-compute.computed computes] if observable data is passed. `registerSimpleHelper` is\neasiser to use for basic helper functionality.\n\n\nLocalization is a good example of a custom helper you might implement\nin your application. The below example takes a given key and\nreturns the localized value using\n[jQuery Globalize](https://github.com/jquery/globalize).\n\n\tstache.registerSimpleHelper('l10n', function(str, options){\n\t\treturn Globalize != undefined\n\t\t\t? Globalize.localize(str)\n\t\t\t: str;\n\t});\n\n\nIn the template, invoke the helper by calling the helper\nname followed by any additional arguments.\n\n\tTemplate:\n\t\t<span>{{l10n 'mystring'}}</span>\n\n\tResult:\n\t\t<span>my string localized</span>\n\n### Helper Arguments\n\nThe type of arguments passed to a `registerHelper` function depends on how the helper was called and the values\npassed to the helper. In short, observables will be passed as [can-compute.computed compute] arguments\nin helper expressions.  In any other circumstance,  values will be passed.\n\nHelpers can be called as either a [can-stache.expressions Call or Helper Expression]:\n\n - Call expression - `{{myHelper(firstValue, secondValue)}}`\n - Helper expression - `{{myHelper firstValue secondValue}}`\n\nHelpers can also be called with observable values or non-observable values.\n\nConsidering a helper like:\n\n```js\nstache.registerHelper(\"myHelper\", function(value){ ... })\n```\n\nThe following details what `value` is depending on how the helper is called\nand the data passed.\n\n#### Call expression with non-observable data\n\n\tData:\n\t\t{ name: 'John' }\n\n\tTemplate:\n\t\t{{ myHelper(name) }}\n\n\tvalue:\n\t\t'John'\n\n#### Call expression with observable data\n\n\tData:\n\t\tnew DefineMap({ name: 'John' })\n\n\tTemplate:\n\t\t{{ myHelper(name) }}\n\n\tvalue:\n\t\t'John'\n\n#### Helper expression with non-observable data\n\n\tData:\n\t\t{ name: 'John' }\n\n\tTemplate:\n\t\t{{ myHelper name }}\n\n\tvalue:\n\t\t'John'\t    \n\n#### Helper expression with observable data\n\n\tData:\n\t\tnew DefineMap({ name: 'John' })\n\n\tTemplate:\n\t\t{{ myHelper name }}\n\n\tvalue:\n\t\tcompute('John')\n\n\n### Evaluating Helpers\n\nIf you want to use a helper with a [can-stache.tags.section] tag, you need to call\n`options.fn(context)` in your return statement. This will return a\ndocument fragment or string with the resulting evaluated subsection.\n\nSimilarly, you can call `options.inverse(context)` to evaluate the\ntemplate between an `{{else}}` tag and the closing tag.\n\nFor example, when a route matches the string passed to our\nrouting helper it will show/hide the text.\n\n\tstache.registerHelper('routing', function(str, options){\n\t\tif (route.attr('filter') === str)\n\t\t\treturn options.fn(this);\n\t\t}\n\t});\n\n\t{{#routing 'advanced'}}\n\t\tYou have applied the advanced filter.\n\t{{/routing}}\n\n__Advanced Helpers__\n\nHelpers can be passed normal objects, native objects like numbers and strings,\nas well as a hash object. The hash object will be an object literal containing\nall ending arguments using the `key=value` syntax. The hash object will be provided\nto the helper as `options.hash`. Additionally, when using [can-stache.tags.section] tags with a helper,\nyou can set a custom context by passing the object instead of `this`.\n\n\tstache.registerHelper('exercise', function(group, action,\n\t\t\t\t\t\t\t\t\t\t\tnum, options){\n\t\tif (group && group.length > 0 && action && num > 0) {\n\t\t\treturn options.fn({\n\t\t\t\tgroup: group,\n\t\t\t\taction: action,\n\t\t\t\twhere: options.hash.where,\n\t\t\t\twhen: options.hash.when,\n\t\t\t\tnum: num\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\treturn options.inverse(this);\n\t\t}\n\t});\n\n\t{{#exercise pets 'walked' 3 where='around the block' when=time}}\n\t\tAlong with the {{#group}}{{.}}, {{/group}}\n\t\twe {{action}} {{where}} {{num}} times {{when}}.\n\t{{else}}\n\t\tWe were lazy today.\n\t{{/exercise}}\n\n\t{\n\t\tpets: ['cat', 'dog', 'parrot'],\n\t\ttime: 'this morning'\n\t}\n\nThis would output:\n\n\tAlong with the cat, dog, parrot, we walked around the block\n\t3 times this morning.\n\nWhereas an empty data object would output:\n\n\tWe were lazy today.\n\n",
    "description": "\nHelpers are functions that can be registered and called from within templates.  These functions\nare typically used to provide functionality that is more appropriate for\nthe `view` than the `viewModel`.\n",
    "name": "can-stache.Helpers",
    "title": "Helpers",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 4
  },
  "can-stache.Binding": {
    "src": {
      "path": "node_modules/can-stache/docs/livebinding.md"
    },
    "body": "\nLive binding lets you focus on changing data and state without having to worry about also updating the\nDOM to reflect those changes.\n\nIn this example, we have a simple user welcome screen.\n\n\t<h1>Welcome {{user}}!</h1>\n\t<p>\n\t\t{{#if messages}}\n\t\t\tYou have {{messages}} new messages.\n\t\t{{else}}\n\t\t\tYou no messages.\n\t\t{{/messages}}\n\t</p>\n\n\tvar data = new DefineMap({\n\t\tuser: 'Tina Fey',\n\t\tmessages: 0\n\t});\n\n\tvar template = stache( document.getElementById(\"template\").innerHTML );\n\tvar frag = template( data );\n\tdocument.body.appendChild( frag );\n\n\nThe template evaluates the `messages` and adds the hooks for live binding automatically.\nSince we have no message it will render:\n\n\t<h1>Welcome Tina Fey!</h1>\n\t<p>You no messages.</p>\n\nNow say we have a request that updates\nthe `messages` attribute to have `5` messages.\n\n\tdata.message = 5;\n\n\nAfter the template receives this update, it will automatically\nupdate the paragraph tag to reflect the new value.\n\n\t<p>You have 5 new message.</p>\n\n\nFor more information visit the [can-define/map/map] documentation.\n\n### Binding between components\n\nIf you are looking for information on bindings between components like this:\n```\n(event)=\"key()\" for event binding.\n{prop}=\"key\" for one-way binding to a child.\n{^prop}=\"key\" for one-way binding to a parent.\n{(prop)}=\"key\" for two-way binding.\n```\nSee [can-stache-bindings].\n\n",
    "description": "\nLive binding refers to templates which update themselves when their state or data changes.\n[can-stache] templates are able to listen to observables\n(like [can-define/map/map], [can-define/list/list], and [can-compute]) changing and update the page\nto reflect those changes.\n",
    "name": "can-stache.Binding",
    "title": "Live Binding",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 5
  },
  "can-stache.magicTagTypes": {
    "src": {
      "path": "node_modules/can-stache/docs/magicTagTypes.md"
    },
    "body": "\nRendering behavior is controlled with magic tags that look like `{{}}`.  There\nare two main forms of magic tags:\n\n - Insertion tags - insert their value into the result like `{{expression}}` and `{{{expression}}}`.\n - Section tags - optional render a sub-section like `{{#expression}} ... {{/expression}}`.\n\nLet’s see the general behavior of each tag type:\n\n### Insertion Tags\n\nInsertion tags render a value into result.\n\n#### [can-stache.tags.escaped]\n\nInserts the escaped value of `expression` into the result. This is the most common tag.\n\n```\nTemplate:\n\t<div>{{name}}</div>\n\nData:\n\t{ name: \"<b>Justin</b>\" }\n\nResult:\n\t<div>&lt;b&gt;Justin&lt;/b&gt;</div>\n```\n\n#### [can-stache.tags.unescaped]\n\nInserts the unescaped value of `expression` into the result.\n\n```\nTemplate:\n\t<div>{{{name}}}</div>\n\nData:\n\t{ name: \"<b>Justin</b>\" }\n\nResult:\n\t<div><b>Justin</b></div>\n```\n\n#### [can-stache.tags.partial]\n\nRenders another template with the same context as the current context.\n\n```\nvar template = stache(\"<h1>{{>title}}</h1>\");\n\n\nvar frag = template(\n\t{message: \"Hello\"},\n\t{\n\t\tpartials: { title: \tstache(\"<blink>{{message}}</blink>”) }\n\t});\n\n\tfrag //-> <h1><blink>Hello</blink></h1>\n```\n\nOther ways to load and reference partials are discussed [can-stache.tags.partial here].\n\n#### [can-stache.tags.comment]\n\nIgnores the magic tag.\n\n```\nTemplate:\n\t<h1>{{!message}}</h1>\n\nData:\n\t{ message: \"<blink>Hello</blink>\" };\n\nResult:\n\t<h1></h1>\n```\n\n### Section Tags\n\nSection tags are passed a subsection and an optional inverse subsection. They\noptionally render the subsections and insert them into the result.\n\n#### [can-stache.tags.section {{#expression}} ... {{/expression}}]\n\nRenders the subsection or inverse subsection depending on the value of expression.\n\nIf `expression` is truthy, renders the subsection:\n\n```\nTemplate:\n\t<h1>{{#shown}}Hello{{/shown}}</h1>\n\nData:\n\t{ shown: true };\n\nResult:\n\t<h1>Hello</h1>\n```\n\nThe subsection is rendered with the `expression` value as the top of the scope:\n\n```\nTemplate:\n\t<h1>{{#person}}Hello {{first}}  {{person.last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\", last: \"Abril\"} };\n\nResult:\n\t<h1>Hello Alexis Abril</h1>\n```\n\n\nIf `expression` is falsey, renders the inverse subsection if present:\n\n```\nTemplate:\n\t<h1>{{#shown}}Hello{{else}}Goodbye{{/shown}}</h1>\n\nData:\n\t{ shown: false };\n\nResult:\n\t<h1>Goodbye</h1>\n```\n\nIf `expression` is array-like and its `length` is greater than 0, the subsection\nis rendered with each item in the array as the top of the scope:\n\n```\nTemplate:\n\t<p>{{#items}}{{.}} {{/items}}</p>\n\nData:\n\t{items: [2,4,8,16]}\n\nResult:\n\t<p>2 4 8 16 </p>\n```\n\nIf `expression` is array-like and its `length` is 0, the inverse subsection\nis rendered:\n\n```\nTemplate:\n\t<p>{{#items}}{{.}} {{else}}No items{{/items}}</p>\n\nData:\n\t{items: []}\n\nResult:\n\t<p>No items</p>\n```\n\n#### [can-stache.tags.inverse {{^expression}} ... {{/expression}}]\n\nThe [can-stache.tags.inverse inverse] section does the opposite of the\nnormal [can-stache.tags.section] tag.  That is, it renders\nthe subsection when [can-stache.tags.section] would render the inverse subsection\nand it renders the inverse subsection when [can-stache.tags.section] would\nrender the subsection.\n\n```\nTemplate:\n\t<h1>{{^shown}}Hello{{/shown}}</h1>\n\nData:\n\t{ shown: false };\n\nResult:\n\t<h1>Hello</h1>\n```\n\n",
    "description": "\n",
    "name": "can-stache.magicTagTypes",
    "title": "Magic Tag Types",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 0,
    "comment": " "
  },
  "can-stache.registerConverter": {
    "src": {
      "path": "node_modules/can-stache/docs/registerConverter.md"
    },
    "body": "\n## Use\n\n> __NOTE__: Before creating your own converter, you may want to look at what’s provided by [can-stache-converters].\n\nThese helpers are useful for avoiding creating [can-define/map/map] getters and setters that do similar conversions on the view model.  Instead,\na converter can keep your viewModels more ignorant of the demands of the\nview.  Especially as the view's most common demand is that everything\nmust be converted to a string.\n\nThat being said, the following is a richer example of a converter,\nbut one that should probably be part of a view model.\n\n```handlebars\n<input {($value)}='fullName(~first, ~last)'/>\n```\n\nThe following might converts both ways `first` and `last` to `value`.\n\n```js\nvar canBatch = require(\"can-event/batch/batch\");\n\nstache.registerConverter(\"fullName\", {\n get: function(first, last) {\n \treturn first() + last();\n },\n set: function(newFullName, first, last) {\n\tcanBatch.start();\n\tvar parts = newFullName.split(\" \");\n\tfirst(parts[0]);\n\tlast(parts[1]);\n\tcanBatch.stop();\n }\n});\n```\n\n",
    "description": "Register a helper for bidirectional value conversion. \n",
    "title": "registerConverter",
    "name": "can-stache.registerConverter",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerConverter(converterName, getterSetter)",
        "description": "\n\nCreates a helper that can do two-way conversion between two\nvalues.  This is especially useful with\n[can-stache-bindings.twoWay {($two-way)} bindings] like:\n\n```handlebars\n<input {($value)}='numberToString(~age)'/>\n```\n\nA converter helper provides:\n\n - a `get` method that returns the value\n  of the `left` value given the arguments passed on the `right`.\n - a `set` method that updates one or multiple of the `right` arguments\n   computes given a new `left` value.\n\n`numberToString` might converts a number (`age`)\nto a string (`value`), and the string (`value`) to a number (`age`)\nas follows:\n\n\n```js\nstache.registerConverter(\"numberToString\", {\n get: function(fooCompute) {\n \treturn \"\" + fooCompute();\n },\n set: function(newVal, fooCompute) {\n \tfooCompute(+newVal);\n }\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "converterName",
            "description": "The name of the converter helper."
          },
          {
            "types": [
              {
                "type": "can-stache.getterSetter"
              }
            ],
            "name": "getterSetter",
            "description": "An object containing get() and set() functions.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.getterSetter"
        }
      ],
      "name": "getterSetter",
      "description": "An object containing get() and set() functions.\n"
    },
    "comment": " "
  },
  "can-stache.registerPartial": {
    "src": {
      "path": "node_modules/can-stache/docs/registerPartial.md"
    },
    "body": "\n",
    "description": "Register a partial template that can be rendered with [can-stache.tags.partial]. \n",
    "title": "registerPartial",
    "name": "can-stache.registerPartial",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerPartial(name, template)",
        "description": "\n\nRegisters a template so it can be rendered with `{{>name}}`.\n\n```js\nstache.registerPartial(\"item.stache\", \"<li>{{name}}</li>\");\n\nvar itemsTemplate = stache(\"{{#each items}}{{>item.stache}}{{/each}}\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the partial."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "can-stache.renderer"
              }
            ],
            "name": "template",
            "description": "The string of a stache template or the\nreturned result of a stache template.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "can-stache.renderer"
        }
      ],
      "name": "template",
      "description": "The string of a stache template or the\nreturned result of a stache template.\n"
    },
    "comment": " "
  },
  "can-stache.renderer": {
    "src": {
      "path": "node_modules/can-stache/docs/renderer.md"
    },
    "body": "\n",
    "description": "A function returned by [can-stache] that renders a template into an html documentFragment.\n\n",
    "type": "typedef",
    "title": "renderer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "helpers"
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList"
          }
        ]
      }
    ],
    "name": "can-stache.renderer",
    "parent": "can-stache.types",
    "signatures": [
      {
        "code": "renderer(data, [helpers], [nodeList])",
        "description": "\n\n  A \"renderer\" function is a function returned by templates that can be used\n  to render data into a documentFragment.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "An object of data used to render the template.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "helpers",
            "description": "Local helper functions used by the template.\n"
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "optional": true,
            "name": "nodeList",
            "description": "Local helper functions used by the template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ],
          "description": "A documentFragment that contains the HTML rendered by the template.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "optional": true,
      "name": "nodeList",
      "description": "Local helper functions used by the template.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        }
      ],
      "description": "A documentFragment that contains the HTML rendered by the template.\n"
    },
    "comment": " "
  },
  "can-stache.safeString": {
    "src": {
      "path": "node_modules/can-stache/docs/safeString.md"
    },
    "body": "\n## Use\n\nIf you write a helper that generates its own HTML, you will\nusually want to return a `stache.safeString.` In this case,\nyou will want to manually escape parameters with [can-util/js/string/string.esc].\n\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nstache.registerHelper('link', function(text, url) {\n  text = string.esc(text);\n  url  = string.esc(url);\n\n  var result = '<a href=\"' + url + '\">' + text + '</a>';\n  return stache.safeString(result);\n});\n```\n\n\nRendering:\n\n```\n<div>{{link \"Google\", \"http://google.com\"}}</div>\n```\n\nResults in:\n\n```\n<div><a href=\"http://google.com\">Google</a></div>\n```\n\nAs an anchor tag whereas if we would have just returned the result rather than a\n`stache.safeString` our template would have rendered a div with the escaped anchor tag.\n\n",
    "description": "Indicate that a string does not need to be escaped to be safely inserted into the page.\n\n",
    "title": "safeString",
    "name": "can-stache.safeString",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.safeString(str)",
        "description": "\n\nBy default, stache tries to prevent some common forms of [cross site scripting attacks](https://en.wikipedia.org/wiki/Cross-site_scripting) by escaping content passed\nto tags like [can-stache.tags.escaped] and the result of helpers.  However,\none will often need to create helpers that return HTML content that shouldn't be escaped.\n\n`stache.safeString` can be used to indicate that a returned string from a helper is safe:\n\n```js\nstache.registerHelper(\"myHelper\", function(){\n  return stache.safeString(\"<blink>Hello There!</blink>\");\n})\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "A string you don't want to become escaped."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A string flagged by `stache` as safe, which will\nnot become escaped, even if you use [can-stache.tags.escaped].\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "A string you don't want to become escaped."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A string flagged by `stache` as safe, which will\nnot become escaped, even if you use [can-stache.tags.escaped].\n"
    },
    "comment": " "
  },
  "can-stache.sectionRenderer": {
    "src": {
      "path": "node_modules/can-stache/docs/sectionRenderer.md"
    },
    "body": "\n## Use\n\nRenderer functions are provided to stache [can-stache.helper helpers] on \nthe [can-stache.helperOptions options] argument and are used to render the\ncontent between sections. The `context` and `helpers` option let you control\nthe data and helpers used to render the section.\n\nThe following example adds `{first: \"Justin\"}` to the lookup \ndata. Notice how the section has access to `first` and `last`.\n\n    stache.registerHelper(\"myhelper\", function(options){\n      var section = options.fn({first: \"Justin\"});\n      return $(\"<h1>\").append( section );\n    })\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1>Justin Meyer</h1>\n\nIf no `context` is provided, the current context is passed.  Notice\nhow the section has access to `last`:\n\n    stache.registerHelper(\"myhelper\", function(options){\n      \n       var section = options.fn();\n       return $(\"<h1>\").append( section );\n      \n    });\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1> Meyer</h1>\n    \nIf a [can-view-scope] is provided, it is used to render the \nsection. Notice how `last` is not available in the section:\n\n    stache.registerHelper(\"myhelper\", function(options){\n      \n      var section = options.fn( new Scope( {first: \"Justin\"}) );\n      return $(\"<h1>\").append( section );\n      \n    });\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1>Justin </h1>\n\n\n\n\n",
    "description": "Renders a section. These functions are usually provided as `.fn` and `.inverse` on a stache helper's [can-stache.helperOptions options].\n\n",
    "type": "typedef",
    "title": "sectionRenderer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            },
            {
              "type": "String"
            }
          ],
          "description": "Returns the rendered result of the helper. If the\nsection is within a tag, like:\n\n    <h1 {{#helper}}class='power'{{/helper}}>\n\na String is returned.  \n\nIf the section is outside a tag like: \n\n    <div> {{#helper}}<h2>Tasks</h2>{{/helper}} </div>\n    \na documentFragment is returned.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-view-scope"
              }
            ],
            "optional": true,
            "name": "context",
            "description": "Specifies the data the section is rendered \nwith.  If a [can-view-scope] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current scope as it's parent.  If nothing is provided, the current\nscope is used to render the section.\n"
          },
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-view-scope.Options"
              }
            ],
            "optional": true,
            "name": "helpers",
            "description": "Specifies the helpers the section is rendered \nwith.  If a [can-view-scope.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.\n"
          }
        ]
      }
    ],
    "name": "can-stache.sectionRenderer",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "can-view-scope.Options"
        }
      ],
      "optional": true,
      "name": "helpers",
      "description": "Specifies the helpers the section is rendered \nwith.  If a [can-view-scope.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        },
        {
          "type": "String"
        }
      ],
      "description": "Returns the rendered result of the helper. If the\nsection is within a tag, like:\n\n    <h1 {{#helper}}class='power'{{/helper}}>\n\na String is returned.  \n\nIf the section is outside a tag like: \n\n    <div> {{#helper}}<h2>Tasks</h2>{{/helper}} </div>\n    \na documentFragment is returned.\n"
    },
    "comment": " "
  },
  "can-stache.Sections": {
    "src": {
      "path": "node_modules/can-stache/docs/sections.md"
    },
    "body": "\nThe most basic form of section will simply render a section of code if the key referenced is considered **truthy** (has a value):\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\n\tData:\n\t\t{\n\t\t\tperson: {\n\t\t\t\tname: \"Andy\"\n\t\t\t}\n\t\t}\n\n\tResult:\n\t\tHello!\n\t\tAndy\n\nWhenever the key doesn't exist or the value is **falsey**, the section won't be rendered:\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\n\tData:\n\t\t{}\n\n\tResult:\n\t\tHello!\n\nHowever, this scenario can be covered through the use of an inverse section \n(`[can-stache.tags.inverse {{^key}}]` followed by `[can-stache.tags.close {{/key}}]`):\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\t\t{{^person}}\n\t\t\tNo one is here.\n\t\t{{/person}}\n\n\tData:\n\t\t{}\n\n\tResult:\n\t\tHello!\n\t\tNo one is here.\n\n## Iteration\n\nThere is a special case for sections where the key references an array. In this case, the section iterates \nthe entire array, rendering the inner text for each item in the array. Arrays are considered **truthy** if \nthey aren't empty. The `{{.}}` tag will reference the current item within the array during iteration (which is \nprimarily used when the items in the array are primitives like strings and numbers).\n\n\tTemplate:\n\t\t{{#people}}\n\t\t\t{{.}} \n\t\t{{/people}}\n\n\tData:\n\t\t{\n\t\t\tpeople: [\"Andy\", \"Austin\", \"Justin\"]\n\t\t}\n\n\tResult:\n\t\tAndy Austin Justin\n\n## Understanding when to use Sections with lists\n\nSection iteration will re-render the entire section for any change in the list. It is the prefered method to\nuse when a list is replaced or changing significantly. Whereas [can-stache.helpers.each {{#each key}}] iteration\nwill do basic diffing and aim to only update the DOM where the change occured. When doing single list item\nchanges frequently, [can-stache.helpers.each {{#each key}}] iteration is the faster choice.\n\nFor example, assuming \"list\" is a [can-list] instance:\n\n{{#if list}} will check for the truthy value of list. This is akin to checking for the truthy value of any JS object and will result to true, regardless of list contents or length.\n\n{{#if list.length}} will check for the truthy value of the length attribute. If you have an empty list, the length will be 0, so the #if will result to false and no contents will be rendered. If there is a length >= 1, this will result to true and the contents of the #if will be rendered.\n\n{{#each list}} and {{#list}} both iterate through an instance of [can-list], however we setup the bindings differently.\n\n{{#each list}} will setup bindings on every individual item being iterated through, while {{#list}} will not. This makes a difference in two scenarios:\n\n1) You have a large list, with minimal updates planned after initial render. In this case, {{#list}} might be more advantageous as there will be a faster initial render. However, if any part of the list changes, the entire {{#list}} area will be re-processed.\n\n2) You have a large list, with many updates planned after initial render. A grid with many columns of editable fields, for instance. In this case, you many want to use {{#each list}}, even though it will be slower on initial render(we're setting up more bindings), you'll have faster updates as there are now many sections.\n\n",
    "description": "\nSections (`[can-stache.tags.section {{#key}}]` followed by `[can-stache.tags.close {{/key}}]`) have multiple uses \ndepending on what type of object is passed to the section. In all cases, using a section will change \nthe current [can-stache.context context].\n",
    "name": "can-stache.Sections",
    "title": "Sections",
    "type": "page"
  },
  "can-stache.simpleHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/simplehelper.md"
    },
    "body": "\n\n## Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create mustache tags that have rich behavior.\n\nIf the helper is called __within a tag__ like:\n\n    <ul {{sortable}}/>\n\nThe returned function is called with the `<ul>` element:\n\n    stache.registerSimpleHelper(\"sortable\",function(){\n      return function(el){\n        $(el).slider();\n      }\n    });\n\nIf the helper is called __between tags__ like:\n\n    <ul>{{items}}</ul>\n\nThe returned function is called with a temporary element. The\nfollowing helper would be called with a temporary `<li>` element:\n\n    stache.registerSimpleHelper(\"items\",function(){\n      return function(li){\n\n      }\n    });\n\nThe temporary element depends on the parent element. The default temporary element\nis a `<span>` element.\n\n",
    "description": "A helper function passed to [can-stache.registerSimpleHelper]. \n",
    "type": "typedef",
    "title": "simpleHelper",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "HTMLElement"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The content to be inserted into\nthe template.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "variable": true,
            "name": "arg",
            "description": "Arguments passed from the tag. After the helper\nname, any space separated [can-stache.key keys], numbers or\nstrings are passed as arguments.\n\nThe following template:\n\n    <p>{{madLib \"Lebron James\" verb 4}}</p>\n\nRendered with\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements.\n\n    stache.registerSimpleHelper('madLib',\n      function(subject, verb, number){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n    });\n\nUnlike [can-stache.helper] simple helpers will always pass the actual\nvalue (instead of a compute).\n"
          },
          {
            "types": [
              {
                "type": "can-stache.helperOptions"
              }
            ],
            "name": "options",
            "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "can-stache.context"
            }
          ],
          "description": "The context the helper was\ncalled within.\n"
        }
      }
    ],
    "name": "can-stache.simpleHelper",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helperOptions"
        }
      ],
      "name": "options",
      "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ]
            }
          ]
        }
      ],
      "description": "The content to be inserted into\nthe template.\n"
    },
    "comment": " "
  },
  "can-stache.pages": {
    "name": "can-stache.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 0
  },
  "can-stache.static": {
    "name": "can-stache.static",
    "title": "Methods",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 1
  },
  "can-stache.tags": {
    "name": "can-stache.tags",
    "title": "Tags",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 2
  },
  "can-stache/expressions": {
    "name": "can-stache/expressions",
    "title": "Expressions",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 3
  },
  "can-stache/keys": {
    "name": "can-stache/keys",
    "title": "Key Operators",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 4
  },
  "can-stache.htags": {
    "name": "can-stache.htags",
    "title": "Helpers",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 5
  },
  "can-stache.types": {
    "name": "can-stache.types",
    "title": "Types",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 6
  },
  "can-stache": {
    "src": {
      "path": "node_modules/can-stache/docs/stache.md"
    },
    "body": "\n\n\n## Use\n\nStache templates are a [mustache](https://mustache.github.io/mustache.5.html) and [handlebars](http://handlebarsjs.com/) compatible\nsyntax.  Stache templates are used to:\n\n- Convert data into HTML.\n- Update the HTML when observable data changes.\n- Enable [can-component custom elements] and [can-stache-bindings bindings].\n\nThe following\ncreates a stache template, renders it with data, and inserts\nthe result into the page:\n\n```js\nvar stache = require(\"can-stache\");\n// renderer is a \"renderer function\"\nvar renderer = stache(\"<h1>Hello {{subject}}</h1>\");\n\n// \"renderer functions\" render a template and return a\n// document fragment.\nvar fragment = renderer({subject: \"World\"})\n\n// A document fragment is a collection of elements that can be\n// used with jQuery or with normal DOM methods.\nfragment //-> <h1>Hello World</h1>\ndocument.body.appendChild(fragment)\n```\n\nRender a template with observable data like [can-define/map/map DefineMap]s or [can-define/list/list DefineList]s and the\nresulting HTML will update when the observable data changes.\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\n\nvar renderer = stache(\"<h1>Hello {{subject}}</h1>\");\nvar map = new DefineMap({subject: \"World\"});\nvar fragment = renderer(map)\ndocument.body.appendChild(fragment)\n\nmap.subject = \"Earth\";\n\ndocument.body.innerHTML //-> <h1>Hello Earth</h1>\n```\n\nThere's a whole lot of behavior that `stache` provides.  The following walks through\nthe most important stuff:\n\n- [can-stache.magicTagTypes] - The different tag types like `{{key}}` and `{{#key}}...{{/key}}`\n- [can-stache.scopeAndContext] - How key values are looked up.\n- [can-stache.expressions] - Supported expression types like `{{helper arg}}` and `{{method(arg)}}`\n- [can-stache.Acquisition] - How to load templates into your application.\n- [can-stache.Helpers] - The built in helpers and how to create your own.\n- [can-stache.Binding] - How live binding works.\n\n## See also\n\n[can-view-scope] is used by `stache` internally to hold and lookup values.  This is similar to\nhow JavaScript's closures hold variables, except you can use it programmatically.\n\n[can-component] and [can-view-callbacks.tag can-view-callbacks.tag] allow you to define custom\nelements for use within a stache template.  [can-view-callbacks.attr can-view-callbacks.attr] allow\nyou to define custom attributes.\n\n[can-stache-bindings] sets up __element and bindings__ between a stache template's [can-view-scope],\ncomponent [can-component.prototype.ViewModel viewModels], or an element's attributes.\n\n",
    "description": "Live binding Mustache and Handlebars-compatible templates. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-stache",
    "parent": "can-core",
    "release": "2.1",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-list"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-stache/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.10",
        "can-namespace": "1.0.0",
        "can-observation": "^3.0.3",
        "can-route": "^3.0.5",
        "can-types": "^1.0.1",
        "can-util": "^3.2.2",
        "can-view-callbacks": "^3.0.2",
        "can-view-live": "^3.0.4",
        "can-view-nodelist": "^3.0.2",
        "can-view-parser": "^3.0.6",
        "can-view-scope": "^3.1.1",
        "can-view-target": "^3.0.4"
      },
      "description": "Live binding handlebars templates",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^1.0.5",
        "can-event": "^3.0.1",
        "can-list": "^3.0.1",
        "can-map": "^3.0.3",
        "can-vdom": "^3.0.1",
        "done-serve": "^0.2.5",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.6",
        "jshint": "^2.9.4",
        "steal": "^1.0.5",
        "steal-benchmark": "^0.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-stache",
      "name": "can-stache",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-stache.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.0.24"
    },
    "link": "../docco/view/stache/mustache_core.html docco",
    "test": "can/view/stache/test/test.html",
    "plugin": "can/view/stache",
    "download": "http://canjs.us/release/latest/can.stache.js",
    "signatures": [
      {
        "code": "stache(template)",
        "description": "\n\nProcesses the template and returns a [can-stache.renderer renderer function].\nUse [steal-stache] to import template renderer functions with [http://stealjs.com StealJS].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "The text of a stache template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A [can-stache.renderer renderer] function that returns a live document fragment\nthat can be inserted in the page.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "template",
      "description": "The text of a stache template.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A [can-stache.renderer renderer] function that returns a live document fragment\nthat can be inserted in the page.\n"
    },
    "comment": " "
  },
  "can.stache.Lookup": {
    "src": {
      "line": 20,
      "codeLine": 27,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "type": "typedef",
    "body": "",
    "description": "",
    "hide": true,
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "types": [
              {
                "type": "String"
              }
            ],
            "description": "A value in the scope to look up.\n"
          }
        ]
      }
    ],
    "name": "can.stache.Lookup"
  },
  "makeEvaluator": {
    "type": "function",
    "name": "makeEvaluator",
    "params": [
      {
        "name": "scope",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "helperOptions",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "nodeList",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": "Either null, #, ^. > is handled elsewhere"
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "exprData",
        "description": "Data about what was in the mustache expression"
      },
      {
        "types": [
          {
            "type": "renderer"
          }
        ],
        "optional": true,
        "name": "truthyRenderer",
        "description": "Used to render a subsection"
      },
      {
        "types": [
          {
            "type": "renderer"
          }
        ],
        "optional": true,
        "name": "falseyRenderer",
        "description": "Used to render the inverse subsection"
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "optional": true,
        "name": "stringOnly",
        "description": "A flag to indicate that only strings will be returned by subsections."
      },
      {
        "types": [
          {
            "type": "can.view.Options"
          }
        ],
        "name": "The",
        "description": "option helpers in which the expression is evaluated."
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 42,
      "codeLine": 54,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Given a mode and expresion data, returns a function that evaluates that expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "stringOnly",
      "description": "A flag to indicate that only strings will be returned by subsections."
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "An 'evaluator' function that evaluates the expression.\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "An 'evaluator' function that evaluates the expression.\n "
    }
  },
  "makeLiveBindingPartialRenderer": {
    "type": "function",
    "name": "makeLiveBindingPartialRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "expressionString",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The html state of where the expression was found."
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 171,
      "codeLine": 179,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns a renderer function that live binds a partial.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The html state of where the expression was found."
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            }
          ],
          "context": {
            "types": [
              {
                "type": "HTMLElement"
              }
            ]
          }
        }
      ],
      "description": "A renderer function\nlive binds a partial.\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            }
          ],
          "context": {
            "types": [
              {
                "type": "HTMLElement"
              }
            ]
          }
        }
      ],
      "description": "A renderer function\nlive binds a partial.\n "
    }
  },
  "makeStringBranchRenderer": {
    "type": "function",
    "name": "makeStringBranchRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": ""
      },
      {
        "name": "expressionString",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 249,
      "codeLine": 256,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Return a renderer function that evaluates to a string.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "can.stache.Expression"
        }
      ],
      "name": "expression",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can.view.Scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-stache.renderer"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.renderer"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can.view.Scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-stache.renderer"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.renderer"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "makeLiveBindingBranchRenderer": {
    "type": "function",
    "name": "makeLiveBindingBranchRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": ""
      },
      {
        "name": "expressionString",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The html state of where the expression was found.\n "
      },
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 294,
      "codeLine": 301,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns a renderer function that evaluates the mustache expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The html state of where the expression was found.\n "
    }
  },
  "splitModeFromExpression": {
    "type": "function",
    "name": "splitModeFromExpression",
    "params": [
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The state of HTML where the expression was found.\n "
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 400,
      "codeLine": 406,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns the mustache mode split from the rest of the expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The state of HTML where the expression was found.\n "
    }
  },
  "cleanLineEndings": {
    "type": "function",
    "name": "cleanLineEndings",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "template",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 426,
      "codeLine": 432,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Prunes line breaks accoding to the mustache specification.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "template",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    }
  },
  "Options": {
    "name": "Options",
    "type": "property",
    "parent": "node_modules/can-stache/src/utils.js",
    "src": {
      "line": 10,
      "codeLine": 14,
      "path": "node_modules/can-stache/src/utils.js"
    },
    "body": " \n",
    "description": "The Options scope.\n",
    "hide": true
  },
  "can-stache-bindings.syntaxes": {
    "name": "can-stache-bindings.syntaxes",
    "title": "Syntaxes",
    "type": "group",
    "parent": "can-stache-bindings",
    "description": "",
    "order": 0
  },
  "can-stache-bindings": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/bindings.md"
    },
    "body": "\n\n## Use\n\nThe `can-stache-bindings` plugin provides useful [can-view-callbacks.attr custom attributes] for template declarative event, one-way bindings, and two-way\nbindings on element attributes, component [can-component::ViewModel ViewModels], and the [can-view-scope scope]. Bindings look like:\n\n\n- `(event)=\"key()\"` for event binding.\n- `{prop}=\"key\"` for one-way binding to a child.\n- `{^prop}=\"key\"` for one-way binding to a parent.\n- `{(prop)}=\"key\"` for two-way binding.\n\nPrepending `$` to a binding like `($event)=\"key()\"` changes the binding from the `ViewModel` to the element’s attributes or properties.\n\n> __Note:__ DOM attribute names are case-insensitive, use hypens (-) to in the attribute name to setup camelCase bindings.\n\nThe following are the bindings that should be used with [can-stache]:\n\n#### [can-stache-bindings.event event]\n\nBinds to `childEvent` on `<my-component>`'s [can-component::ViewModel ViewModel] and calls\n`method` on the [can-view-scope scope] with the specified arguments:\n\n```\n<my-component (child-event)=\"method('primitive', key, hash1=key1)\"/>\n```\n\nBinds to `domEvent` on `<my-component>` and calls\n`method` on the [can-view-scope scope] with the specified arguments.\n\n```\n<my-component ($dom-event)=\"method('primitive', key, hash1=key1)\"/>\n```\n\n#### [can-stache-bindings.toChild one-way to child]\n\nUpdates `childProp` in `<my-component>`’s [can-component::ViewModel ViewModel] with `value` in the [can-view-scope scope]:\n\n```\n<my-component {child-prop}=\"value\"/>\n```\n\nUpdates the `child-attr` attribute or property on `<my-component>` with `value`\nin the [can-view-scope scope]:\n\n```\n<my-component {$child-attr}=\"value\"/>\n```\n\n#### [can-stache-bindings.toParent one-way to parent]\n\nUpdates `value` in the [can-view-scope scope]  with `childProp`\nin `<my-component>`’s [can-component::ViewModel ViewModel]:\n\n```\n<my-component {^child-prop}=\"value\"/>\n```\n\nUpdates `value`\nin the [can-view-scope scope] with the `child-attr` attribute or property on `<my-component>`:\n\n```\n<my-component {^$child-attr}=\"value\"/>\n```\n\n#### [can-stache-bindings.twoWay two-way]\n\nUpdates `childProp` in `<my-component>`’s [can-component::ViewModel ViewModel] with `value` in the [can-view-scope scope] and vice versa:\n\n```\n<my-component {(child-prop)}=\"value\"/>\n```\n\nUpdates the `child-attr` attribute or property on `<my-component>` with `value`\nin the [can-view-scope scope] and vice versa:\n\n```\n<my-component {($child-attr)}=\"value\"/>\n```\n\n",
    "description": "\nProvides template event, one-way bindings, and two-way bindings.\n",
    "type": "module",
    "title": "",
    "name": "can-stache-bindings",
    "parent": "can-core",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-stache-bindings"
      },
      "dependencies": {
        "can-compute": "^3.0.10",
        "can-event": "^3.3.0",
        "can-event-radiochange": "^0.1.0",
        "can-observation": "^3.0.1",
        "can-stache": "^3.0.24",
        "can-types": "^1.0.1",
        "can-util": "^3.3.7",
        "can-view-callbacks": "^3.0.0",
        "can-view-live": "^3.0.0",
        "can-view-model": "^3.0.0",
        "can-view-scope": "^3.0.0"
      },
      "description": "Default binding syntaxes for can-stache",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^1.0.13",
        "can-list": "^3.0.1",
        "can-map": "^3.0.7",
        "can-vdom": "^3.0.2",
        "can-view-nodelist": "^3.0.2",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.9",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "donejs"
      ],
      "main": "can-stache-bindings",
      "name": "can-stache-bindings",
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint test/ ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-stache-bindings"
      },
      "version": "3.1.5"
    },
    "comment": " "
  },
  "can-stache-bindings.event": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/event.md"
    },
    "body": "\n## Use\n\nThe use of `(event)` bindings changes between listening on __DOM events__ and __viewModel events__.\n\n## DOM events\n\nTo listen for a DOM event, wrap the event name with `($event)` like:\n\n```\n<div ($click)=\"doSomething()\"/>\n```\n\nBy adding `($EVENT)='methodKey()'` to an element, the function pointed to\nby `methodKey` is bound to the element’s `EVENT` event. The function can be\npassed any number of arguments from the surrounding scope, or `name=value`\nattributes for named arguments. Direct arguments will be provided to the\nhandler in the order they were given.\n\nThe following uses `($click)=\"items.splice(%index,1)\"` to remove a\nitem from `items` when that item is clicked on.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/event-args.html'></div>\n\n### Special Event Types\n\n[can-stache-bindings] supports creating special event types\n(events that aren’t natively triggered by the DOM), which are\nbound by adding attributes like `($SPECIAL)='KEY'`. This is\nsimilar to [$.special](http://benalman.com/news/2010/03/jquery-special-events/).\n\n### ($enter)\n\n`($enter)` is a special event that calls its handler whenever the enter\nkey is pressed while focused on the current element. For example:\n\n\t<input type='text' ($enter)='save()' />\n\nThe above template snippet would call the save method\n(in the [can-view-scope scope]) whenever\nthe user hits the enter key on this input.\n\n## viewModel events\n\nTo listen on a [can-component Component’s] [can-component.prototype.ViewModel ViewModel], wrap the event name with `(event)` like:\n\n```\n<player-edit\n  \t(close)=\"removeEdit()\"\n  \t{player}=\"editingPlayer\"/>\n```\n\nViewModels can publish events on themselves. The following `<player-edit>` component\ndispatches a `\"close\"` event on itself when its `close` method is called:\n\n```\nComponent.extend({\n  tag: \"player-edit\",\n  template: can.view('player-edit-stache'),\n  viewModel: {\n    close: function(){\n      this.dispatch(\"close\");\n    }\n  }\n});\n```\n\nThe following demo uses this ability to create a close button that\nhides the player editor:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next_event.html'></div>\n\n",
    "description": "Respond to events on elements or component ViewModels. \n",
    "title": "(event)",
    "name": "can-stache-bindings.event",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 0,
    "signatures": [
      {
        "code": "($DOM_EVENT)='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on the element and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<div ($click)=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "DOM_EVENT",
            "description": "A DOM event name like `click`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression (e.g. `method(key)`) that is called when the `DOM_EVENT` is fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component’s [can-component::ViewModel ViewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n"
          }
        ]
      },
      {
        "code": "(VIEW_MODEL_EVENT)='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on the element’s [can-component::ViewModel ViewModel] and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<my-component (show)=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "VIEW_MODEL_EVENT",
            "description": "A view model event.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression like `method(key)` that is called when the `VIEW_MODEL_EVENT`\nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component’s [can-component::ViewModel ViewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.expressions"
        }
      ],
      "name": "CALL_EXPRESSION",
      "description": "A call expression like `method(key)` that is called when the `VIEW_MODEL_EVENT`\nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component’s [can-component::ViewModel ViewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n\n"
    },
    "comment": " "
  },
  "can-stache-bindings.reference": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/reference.md"
    },
    "body": "\n## Use\n\nExport a view model to the references scope by adding an attribute with the \nhypenated name of the reference scope property:\n\n```\n<year-selector *year-selector />\n```\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/reference-one-way.html'></div>\n\n",
    "description": "Export a viewModel into a template's references scope. \n",
    "title": "*REFERENCE",
    "name": "can-stache-bindings.reference",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 4,
    "signatures": [
      {
        "code": "*ref-prop",
        "description": "\n\n  A shorthand for exporting an element’s viewModel to the reference scope.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "ref-prop",
            "description": "The name of the property to set in the template's 'references' scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "ref-prop",
      "description": "The name of the property to set in the template's 'references' scope.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.toChild": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/to-child.md"
    },
    "body": "\n## Use\n\n`{child-prop}=\"key\"` is used to pass values from the scope to a component.  You can use CallExpressions like:\n\n```\n<player-scores {scores}=\"game.scoresForPlayer('Alison')\"/>\n<player-scores {scores}=\"game.scoresForPlayer('Jeff')\"/>\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-child.html'></div>\n\n",
    "description": "One-way bind a value in the parent scope to the [can-component.prototype.ViewModel ViewModel]. \n",
    "title": "{to-child}",
    "name": "can-stache-bindings.toChild",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 1,
    "signatures": [
      {
        "code": "{child-prop}=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` in [can-component.prototype.view-model viewModel]. It also updates `childProp` with the value of `key` when `key` changes.\n\n  ```\n  <my-component {some-prop}=\"value\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property to set in the\ncomponent’s viewmodel.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression whose resulting value is used to set as `childProp`.\n"
          }
        ]
      },
      {
        "code": "{$child-prop}=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` property or attribute on the element.\n\n  ```\n  <input {$value}=\"name\"/>\n  ```\n\n  This signature works, but the following should be used instead:\n\n  ```\n  <input value=\"{{name}}\"/>\n  ```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache-bindings.toParent": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/to-parent.md"
    },
    "body": "\n## Use\n\nThe use of `{^to-parent}` bindings changes between exporting __viewModel properties__ or __DOM properties__.\n\n## Exporting ViewModel properties\n\n`{^child-prop}=\"key\"` can be used to export single values or the complete view model from a\nchild component into the parent scope. Typically, the values are exported to the references scope.\n\nIn the following example, it connects the __selected__ driver in `<drivers-list>` with an editable __plateName__ in\n`<edit-plate>`:\n\n    <drivers-list {^selected}=\"*editing\"/>\n    <edit-plate {(plate-name)}=\"*editing.licensePlate\"/>\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-parent.html'></div>\n\n## Exporting DOM properties\n\n`{^$child-prop}=\"key\"` can be used to export an attribute value into the scope.  For example:\n\n```\n<input {^$value}=\"name\"/>\n```\n\nUpdates `name` in the scope when the `<input>` element’s `value` changes.\n\n## Exporting Functions\n\nYou can export a function to the parent scope with a binding like:\n\n```\n<my-tabs {^@add-panel}=\"@*addPanel\">\n```\n\nAnd pass the method like:\n\n```\n<my-panel {add-panel}=\"@*addPanel\" title=\"CanJS\">CanJS Content</my-panel>\n```\n\nCheck it out in this demo:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-parent-function.html'></div>\n\nNotice that `@` is used to prevent reading the function.  \n\n",
    "description": "One-way bind a value in the current [can-component.prototype.view-model viewModel] to the parent scope. \n",
    "title": "{^to-parent}",
    "name": "can-stache-bindings.toParent",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 2,
    "signatures": [
      {
        "code": "{^child-prop}=\"key\"",
        "description": "\n\nExports `childProp` in the [can-component.prototype.ViewModel ViewModel] to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n`key` with the value of `childProp` when `childProp` changes.\n\n```\n<my-component {^some-prop}=\"value\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property to export from the\nchild components viewmodel. Use `{^this}` or `{^.}` to export the entire viewModel.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression that will be used to set in the parent scope.\n"
          }
        ]
      },
      {
        "code": "{^$child-prop}=\"key\"",
        "description": "\n\n  Exports the element’s `childProp` property or attribute to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n  `key` with the value of `childProp` when `childProp` changes.\n\n  ```\n  <input {^$value}=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element’s property or attribute to export.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression whose resulting value with be used to set in the parent scope.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "An expression whose resulting value with be used to set in the parent scope.\n\n"
    },
    "comment": " "
  },
  "can-stache-bindings.twoWay": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/two-way.md"
    },
    "body": "\n## Use\n\n`{(child-prop)}=\"key\"` is used to two-way bind a value in a [can-component.prototype.ViewModel ViewModel] to\na value in the  [can-view-scope scope].  If one value changes, the other value is updated.\n\nThe following two-way binds the `<edit-plate>` element’s `plateName` to the `editing.licensePlate`\nvalue in the scope.  This allows `plateName` to update if `editing.licensePlate` changes and\n`editing.licensePlate` to update if `plateName` changes.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/two-way.html'></div>\n\nThis demo can be expressed a bit easier with the references scope:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/reference.html'></div>\n\n## Initialization\n\nWhen a binding is being initialized, the behavior of what the viewModel and scope properties\nare set to depends on their initial values.\n\nIf the viewModel value is `not undefined` and the scope is `undefined`, scope will be set to the viewModel value.\n\nIf the viewModel value is `undefined` and the scope is `not undefined`, viewModel will be set to the scope value.\n\nIf both the viewModel and scope are `not undefined`, viewModel will be set to the scope value.\n\n",
    "description": "Two-way bind a value in the [can-component.prototype.view-model viewModel] or the element to the parent scope. \n",
    "title": "{(two-way)}",
    "name": "can-stache-bindings.twoWay",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 3,
    "signatures": [
      {
        "code": "{(child-prop)}=\"key\"",
        "description": "\n\n  Two-way binds `childProp` in the  [can-component.prototype.ViewModel ViewModel] to\n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n\n  ```\n  <my-component {(some-prop)}=\"value\"/>\n  ```\n\n  When setting up the binding:\n\n  - If `childProp` is `undefined`, `key` will be set to `childProp`.\n  - If `key` is `undefined`, `childProp` will be set to `key`.\n  - If both `childProp` and `key` are defined, `key` will be set to `childProp`.\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property of the viewModel to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
          }
        ]
      },
      {
        "code": "{($child-prop)}=\"key\"",
        "description": "\n\n  Two-way binds the element’s `childProp` property or attribute to\n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n\n  ```\n  <input {($value)}=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element’s property or attribute to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
    },
    "comment": " "
  },
  "can-stache-converters.boolean-to-inList": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/boolean-to-inList.md"
    },
    "body": "\n## Use\n\nUse this converter when two-way binding to an element with a boolean attribute, such as a checkbox.\n\n```js\nvar map = new DefineMap({\n\titem: 5,\n\tlist: [1, 2, 3, 4, 5]\n});\n\nvar template = stache('<input type=\"checkbox\" {($value)}=\"boolean-to-inList(item, list)\" />');\n\ndocument.body.appendChild(template(map));\n\nvar input = document.querySelector('input[type=checkbox]');\n\nconsole.log(input.checked); // -> true\n\nmap.item = 6;\n\nconsole.log(input.checked); // -> false\n\nmap.list.push(6);\n\nconsole.log(input.checked); // -> true\n```\n\n\n",
    "description": "A [can-stache.registerConverter converter] that binds a boolean attribute, such as an `<input>` value, to whether or not an item is in a list. \n",
    "title": "boolean-to-inList",
    "name": "can-stache-converters.boolean-to-inList",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "boolean-to-inList(item, list)",
        "description": "\n\nWhen the getter is called, returns true if **item** is within the **list**, determined using `.indexOf`.\n\nWhen the setter is called, if the new value is truthy then the item will be added to the list using `.push`; if it is falsey the item will removed from the list using `.splice`.\n\n```handlebars\n<input type=\"checkbox\" {($value)}=\"boolean-to-inList(item, list)\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "The item to which to check"
          },
          {
            "types": [
              {
                "type": "can-define/list/list"
              },
              {
                "type": "can-list"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "list",
            "description": "The list"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element’s value changes.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-define/list/list"
        },
        {
          "type": "can-list"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "list",
      "description": "The list"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element’s value changes.\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages": {
    "name": "can-stache-converters.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-stache-converters",
    "description": "",
    "order": 0
  },
  "can-stache-converters.converters": {
    "name": "can-stache-converters.converters",
    "title": "Converters",
    "type": "group",
    "parent": "can-stache-converters",
    "description": "",
    "order": 0
  },
  "can-stache-converters": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/can-stache-converters.md"
    },
    "body": "\n\n## Use\n\nThe **can-stache-converters** plugin provides a set of useful converters useful for binding to form elements.\n\n",
    "description": "\nProvides a set of [can-stache.registerConverter converters] useful for two-way binding with form elements such as `<input>` and `<select>`.\n",
    "type": "module",
    "title": "",
    "name": "can-stache-converters",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "DoneJS Contributors",
        "email": "contact@bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-stache-converters"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-stache-converters/issues"
      },
      "dependencies": {
        "can-stache": "^3.0.1",
        "can-stache-bindings": "^3.0.1",
        "can-util": "^3.2.2"
      },
      "description": "Common converters for Stache",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-compute": "^3.0.0",
        "can-define": "^1.0.5",
        "can-event": "^3.0.1",
        "documentjs": "^0.4.2",
        "done-serve": "^1.2.0",
        "donejs-cli": "^1.0.1",
        "generator-donejs": "^1.0.5",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.5.0"
      },
      "homepage": "https://github.com/canjs/can-stache-converters",
      "keywords": [
        "Done",
        "JS",
        "Can",
        "JS"
      ],
      "main": "can-stache-converters",
      "name": "can-stache-converters",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-stache-converters.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-stache-converters"
      },
      "version": "3.1.0"
    },
    "comment": " "
  },
  "can-stache-converters.either-or": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/either-or.md"
    },
    "body": "\n## Use\n\n**either-or** is made to be used with `<input type=checkbox>` elements when there is a binary decision that can be made (so that multiple radio buttons are not needed).\n\nYou pass 3 arguments to this [can-stache.registerConverter converter]. The first argument is a compute that represents the chosen value. The second argument is the default, truthy, value. And the third argument is the falsey value.\n\n\n```handlebars\n<p>\n\t<input type=\"checkbox\"\n\t\t({$checked})=\"either-or(~pref, 'Star Trek', 'Star Wars')\" />\n\t<span>Star Trek</span>\n</p>\n\n<p>Your fandom: {{pref}}</p>\n```\n\n```js\nvar template = stache.from(\"demo-template\");\n\nvar fan = new DefineMap({\n\tpref: \"Star Trek\"\n});\n\ndocument.body.appendChild(template(fan));\n\n// User unchecks the checkbox\nfan.pref === \"Star Wars\";\n\n// Changing the value in code:\nfan.pref === \"Star Trek\";\n\n// Checkbox is now checked again.\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that two-way binds to a checkbox two values provided as arguments. This converter is useful when you have a binary decision that your user will implicitly understand. \n",
    "title": "either-or",
    "name": "can-stache-converters.either-or",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "either-or(~chosen, a, b)",
        "description": "\n\nWhen the getter is called, gets the value of the **chosen** compute and if it is equal to **a** returns true, otherwise it returns false.\n\nWhen the setter is called, if the new value is truthy, sets the **chosen** [can-compute] to **a**’s value, otherwise sets it to **b**’s value.\n\n```handlebars\n<span>Favorite superhero:</span>\n<input type=\"checkbox\" {($checked)}=\"either-or(~chosen, 'Batman', 'Superman')\"> Batman?\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "chosen",
            "description": "A compute where the chosen value (between `a` and `b` is stored). When the setter is called, this compute’s value will be updated.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "a",
            "description": "The `true` value. If the checkbox is checked, then **a**’s value will be stored in the **chosen** compute.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "b",
            "description": "The `false` value. If the checkbox is unchecked, then **b**’s value will be stored in the **chosen** compute.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter bound to the element.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "b",
      "description": "The `false` value. If the checkbox is unchecked, then **b**’s value will be stored in the **chosen** compute.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter bound to the element.\n"
    },
    "comment": " "
  },
  "can-stache-converters.equal": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/equal.md"
    },
    "body": "\n## Use\n\nThis [can-stache-converters converter] will most often be used in conjunction with a radio input in order to bind a scope’s value (such as string, but could be any value) based on the selection of the radio group.\n\nIn this example we are using objects, to select a captain from one of three players:\n\n```handlebars\n{{#each players}}\n\t<input type=\"radio\" {($checked)}=\"equal(~captain, this)\" /> {{name}}\n{{/each}}\n```\n\n```js\nvar template = stache.from(\"demo\");\nvar vm = new DefineMap({\n\tcaptain: null,\n\tplayers: [\n\t\t{ name: \"Matthew\" },\n\t\t{ name: \"Wilbur\" },\n\t\t{ name: \"Anne\" }\n\t]\n});\nvm.captain = vm.players[0];\n\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that is usually for binding to a `<input type=\"radio\">` group, so that a scope value can be set the radio group’s selected value. \n",
    "title": "equal",
    "name": "can-stache-converters.equal",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "equal(~compute, value)",
        "description": "\n\nWhen the getter is called **compute**, a [can-compute.computed], is compared to **value** and if they are equal, returns true.\n\nWhen the setter is called, if the radio is now checked the **compute**'s setter is called with **value** as the value.\n\n```handlebars\n<input type=\"radio\" {($checked)}=\"equal(~color, 'red')\" /> Red\n<input type=\"radio\" {($checked)}=\"equal(~color, 'blue')\" /> Blue\n```\n\nIn this example, the `color` scope value will be set to 'red' when the first radio is selected and 'blue' when the second radio is selected.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "A compute whose value will be compared to the second argument."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "A value of any type, that will be compared to the compute's internal value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound to the radio's checked property.\n"
        }
      },
      {
        "code": "equal(valueOne, valueTwo)",
        "description": "\n\nWhen the getter is called the two values will be compared and if they are equal, returns true.\n\n```handlebars\n<my-modal {show}=\"equal(showModal, true)\" />\n```\n\nIn this example, the `show` value of `my-modal`'s view model will be set to `true` when `showModal` in the scope is set to true.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "valueOne",
            "description": "A value of any type, that will be compared to valueTwo."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "valueTwo",
            "description": "A value of any type, that will be compared to valueOne.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be one-way bound to the `show` property.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be one-way bound to the `show` property.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "valueTwo",
      "description": "A value of any type, that will be compared to valueOne.\n"
    },
    "comment": " "
  },
  "can-stache-converters.index-to-selected": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/index-to-selected.md"
    },
    "body": "\n## Use\n\nThis will most often be used in conjunction with a `<select>` element and a bunch of options.\n\nThe provided `item` **must** be a [can-compute] so that its value can be set when the user selects own of the dropdown options.\n\nYou **must** use the indexes from the list as your `<option>` values. This is how it looks up items in the list both in the getter and the setter.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/index-to-selected.html'></div>\n\n",
    "description": "A [can-stache.registerConverter converter] that binds to a `<select>` value in order to two-way bind a selected item from a list using the index as the key. \n",
    "title": "index-to-selected",
    "name": "can-stache-converters.index-to-selected",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "index-to-selected(~item, list)",
        "description": "\n\nWhen the getter is called, returns the index of the passed in item (which should be a [can-compute] from the provided list.\n\nWhen the setter is called, takes the selected index value and finds the item from the list with that index and passes that to set the compute’s value.\n\n```handlebars\n<select {($value)}=\"index-to-selected(~person, people)\">\n\n\t{{#each people}}\n\n\t\t<option value=\"{{%index}}\">{{name}}</option>\n\n\t{{/each}}\n\n</select>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "item",
            "description": "A compute whose item is in the list."
          },
          {
            "types": [
              {
                "type": "can-define/list/list"
              },
              {
                "type": "can-list"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "list",
            "description": "A list used to find the `item`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound to the select’s value.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-define/list/list"
        },
        {
          "type": "can-list"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "list",
      "description": "A list used to find the `item`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be two-way bound to the select’s value.\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages.input-checkbox": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/input-checkbox.md"
    },
    "body": "\n\n## Binding to checkboxes\n\nTo bind to a checkbox and set a boolean value within your [can-view-scope scope], set up a [can-stache-bindings.twoWay two-way] binding to the input’s `checked` property like so:\n\n```\n<input type=\"checkbox\" {($checked)}=\"val\" />\n```\n\n[can-stache-converters] provides a couple of convenient converters that handle common use cases for binding to a checkbox.\n\n## Binding based on whether an item is in a list\n\nUsing [can-stache-converters.boolean-to-inList] is useful to two-way bind to a checkbox based on whether an item is in a list or not. When the checkbox is checked/unchecked, the list will be updated and that item will either be removed or added to the list.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-checkbox.html'></div>\n\n## Binding based on a binary decision\n\nAn alternative true and false value can be specified by using [can-stache-converters.either-or]. This is used for setting up a “boolean” property that only has two possible valid values, whose values are modelled by the true/false checked property of a checkbox, as in the following example:\n\n\n```\n<input type=\"checkbox\" {($checked)}=\"either-or=(~val, 'a', 'b')\" />\n```\n\nIn this case, the data passed in as `val` is a [can-compute] that contains either the value **a** or **b**. If the value of `val` is **a** then the checkbox will be checked. When the user checks/unchecks the checkbox then the value of `val` is set to be either **a** or **b** depending on whether it is checked.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-checkbox-binary.html'></div>\n\n",
    "description": "\nCross bind a value to a checkbox.\n",
    "name": "can-stache-converters.pages.input-checkbox",
    "title": "input[type=checkbox]",
    "type": "page",
    "parent": "can-stache-converters.pages",
    "comment": " "
  },
  "can-stache-converters.pages.input-radio": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/input-radio.md"
    },
    "body": "\n\n## Binding to radios\n\nTo bind to a radio input, if you have a set of boolean values you can bind to the input’s `checked` property as you do with [can-stache-converters.pages.input-checkbox].\n\n```handlebars\n<input type=\"radio\" {($checked)}=\"one\" /> One\n<input type=\"radio\" {($checked)}=\"two\" /> Two\n```\n\n```js\nvar template = stache.from(\"demo\");\nvar map = new DefineMap({\n\tone: true,\n\ttwo: false\n});\n\ndocument.body.appendChild(template(map));\n```\n\n## Binding to a selected value\n\nMore often than binding to boolean values of each radio's `checked` value, you will want to know what the `value` is of the radio group. Since each radio has its own `value`, the radio's selected value is the value of the radio item that is selected.\n\nUsing the [can-stache-converters.equal] [can-stache.registerConverter converter] you can bind a value within your scope to the radio group’s selected value:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-radio.html'></div>\n\n",
    "description": "\nCross bind a value to a radio input.\n",
    "name": "can-stache-converters.pages.input-radio",
    "title": "input[type=radio]",
    "type": "page",
    "parent": "can-stache-converters.pages",
    "comment": " "
  },
  "can-stache-converters.not": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/not.md"
    },
    "body": "\n## Use\n\nUse this converter to two-way bind to the negation of some value. For example:\n\n```handlebars\n<input type=\"checkbox\" {($checked)}=\"not(~val)\" />\n```\n\n```js\nvar map = new DefineMap({\n\tval: true\n});\n\ndocument.body.appendChild(template(map));\n\nvar input = document.querySelector('input');\n\ninput.checked; // -> false\n\nmap.val = false;\n\ninput.checked; // -> true\n\n// Now if you click the checkbox\nmap.val === true; // because the checkbox is now false.\n```\n\n### Combined with other converters\n\n`not()` can be useful when used in combination with other converters that deal with boolean conversion. [can-stache-converters.boolean-to-inList] determines if an item is in a list. Here we wrap `not()` around this conversion so that the inverse is what is saved in the map’s value:\n\n```handlebars\n<input type=\"checkbox\" {($checked)}=\"not(~boolean-to-inList(item, list))\" />\n```\n\n```js\nvar map = new DefineMap({\n\titem: 2,\n\tlist: new DefineList([ 1, 2, 3 ])\n});\n\ndocument.body.appendChild(template(map));\nvar input = document.querySelector('input');\n\n\ninput.checked; // -> false\n\n// Set `item` to a value not in the list\nmap.item = 4;\n\ninput.checked; // -> true\n\n// Check the input, whick will set its value to `false`\n// This will be converted to `true` by not() and pushed into the list\n\nmap.list.indexOf(4); // -> 3\n\n// Remove it from the list, which will be converted to true by not()\nmap.list.splice(3, 1);\n\ninput.checked; // -> true\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that two-way binds the negation of a value. \n",
    "title": "not",
    "name": "can-stache-converters.not",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "not(~value)",
        "description": "\n\nWhen the getter is called, gets the value of the compute and returns the negation.\n\nWhen the setter is called, sets the compute’s value to the negation of the new value derived from the element.\n\n*Note* that `not` needs a compute so that it can update the scope’s value when the setter is called.\n\n```handlebars\n<input type=\"checkbox\" {($checked)}=\"not(~val)\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "value",
            "description": "A value stored in a [can-compute]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound by [can-stache-bindings] as a getter/setter on the element.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "value",
      "description": "A value stored in a [can-compute]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be two-way bound by [can-stache-bindings] as a getter/setter on the element.\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages-select-multiple": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/select-multiple.md"
    },
    "body": "\n\n## Use\n\nSelect elements with the multiple attribute (`<select multiple {($values)}=\"KEY\"/>`)\nhave a specified behavior if the value of KEY is Array-like or\n`undefined`.\n\n## Cross binding to Arrays\n\n`<select>` tags with a multiple attribute cross bind\na [can-map] property, [can-compute.computed] or [can-list]\nin sync with the selected items of the `<select>` element.\n\nFor example, the following template:\n\n    <select multiple {($values)}=\"colors\">\n      <option value='red'>Red</option>\n      <option value='green'>Green</option>\n      <option value='yellow'>Yellow</option>\n    </select>\n\nCould be rendered with one of the following:\n\n    // A can-map property\n    new DefineMap({colors: []})\n\n    // A compute\n    { colors: compute([]) }\n\n    // A DefineList\n    { colors: new DefineList() }\n    \n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/multi-values.html'></div>\n\n",
    "description": "\nCross bind a value to a `<select>` element with multiple selections permitted.\n",
    "title": "select[multiple]",
    "name": "can-stache-converters.pages-select-multiple",
    "type": "function",
    "parent": "can-stache-converters.pages",
    "signatures": [
      {
        "code": "<select multiple {($values)}=\"KEY\"/>",
        "description": "\n\nCross binds the selected option values with an observable value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can.stache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current \nscope. `KEY`’s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY`’s value should be an Array-like,\nor `undefined`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can.stache.key"
        }
      ],
      "name": "KEY",
      "description": "A named value in the current \nscope. `KEY`’s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY`’s value should be an Array-like,\nor `undefined`.\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages.select": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/select.md"
    },
    "body": "\n\n## Use\n\nThe following cross bind's a `<select>` to a `person` map's `attending` property:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/select.html'></div>\n\n",
    "description": "\nCross bind a value to a `<select>` element.\n",
    "title": "select ",
    "name": "can-stache-converters.pages.select",
    "type": "function",
    "parent": "can-stache-converters.pages",
    "signatures": [
      {
        "code": "{($value)}=\"KEY\"",
        "description": "\n\nCross binds the selected option value with an observable value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current \nscope. `KEY`’s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY` should specify either a [can-map]/[can-define/map/map] property or a [can-compute.computed].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "KEY",
      "description": "A named value in the current \nscope. `KEY`’s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY` should specify either a [can-map]/[can-define/map/map] property or a [can-compute.computed].\n"
    },
    "comment": " "
  },
  "can-stache-converters.string-to-any": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/string-to-any.md"
    },
    "body": "\n## Use\n\nThis is usually used with `<select>`s where you would like to two-way bind a string to a primitive value.\n\n```handlebars\n<select {($value)}=\"string-to-any(~someValue)\">\n  <option value=\"2\">Number</option>\n  <option value=\"null\">Null</option>\n  <option value=\"foo\">String</option>\n  <option value=\"true\">Boolean</option>\n  <option value=\"NaN\">NaN</option>\n  <option value=\"Infinity\">Infinity</option>\n</select>\n```\n\n```js\nvar str = document.getElementById('select-template').innerHTML;\nvar template = stache(str);\n\nvar map = new DefineMap({\n\tsomeValue: \"foo\"\n});\n\ndocument.body.appendChild(template(map));\n\nmap.item = NaN; // select.value becomes \"NaN\"\n\n// Click the select box and choose Boolean\nmap.item === true; // -> true\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that binds a value to a primitive value, two-way converted back to that primitive value when the attribute changes. \n",
    "title": "string-to-any",
    "name": "can-stache-converters.string-to-any",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "string-to-any(~item)",
        "description": "\n\nWhen the getter is called, gets the value of the compute and calls `.toString()` on that value.\n\nWhen the setter is called, takes the new value and converts it to the primitive value using [can-util/js/string-to-any/string-to-any] and sets the compute using that converted value.\n\n```handlebars\n<select {($value)}=\"string-to-any(~favePlayer)\">\n  <option value=\"23\">Michael Jordan</option>\n\t<option value=\"32\">Magic Johnson</option>\n</select>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "item",
            "description": "A compute holding a primitive value."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element’s value changes.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "item",
      "description": "A compute holding a primitive value."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element’s value changes.\n"
    },
    "comment": " "
  },
  "can-stream.types": {
    "name": "can-stream.types",
    "title": "types",
    "type": "group",
    "parent": "can-stream",
    "description": "",
    "order": 0
  },
  "can-stream": {
    "src": {
      "path": "node_modules/can-stream/docs/can-stream.md"
    },
    "body": "\n## Use\n\nSee [can-stream-kefir] for an example.\n\n",
    "description": "Create useful stream methods from a minimal stream wrapper implementation. \n",
    "type": "module",
    "title": "can-stream",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-stream",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": [
            "can-stream"
          ]
        },
        "parent": "can-stream"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-stream/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-define": "^1.0.0",
        "can-event": "^3.0.0",
        "can-observation": "^3.0.0",
        "can-types": "^1.0.4",
        "can-util": "^3.0.0",
        "kefir": "^3.5.1"
      },
      "description": "Stream values into and out of computes",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-stream",
      "name": "can-stream",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-stream.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "0.2.3"
    },
    "signatures": [
      {
        "code": "canStream(streamImplementation)",
        "description": "\n\nExports a function that takes a [can-stream.types.streamImplementation] (like [can-stream-kefir]) and uses it internally to provide several useful string methods.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stream.types.streamImplementation"
              }
            ],
            "name": "streamImplementation",
            "description": "A [can-stream.types.streamImplementation] object that implements the `toStream` and `toCompute` methods for a stream library.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stream.types.streamInterface"
            }
          ],
          "description": "An object that has the following methods:\n\n- .toStream(observable, propAndOrEvent[,event])\n- .toStreamFromProperty(property)\n- .toStreamFromEvent(property)\n- .toCompute([can-stream.types.makeStream makeStream(setStream)], context):compute\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stream.types.streamImplementation"
        }
      ],
      "name": "streamImplementation",
      "description": "A [can-stream.types.streamImplementation] object that implements the `toStream` and `toCompute` methods for a stream library.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stream.types.streamInterface"
        }
      ],
      "description": "An object that has the following methods:\n\n- .toStream(observable, propAndOrEvent[,event])\n- .toStreamFromProperty(property)\n- .toStreamFromEvent(property)\n- .toCompute([can-stream.types.makeStream makeStream(setStream)], context):compute\n"
    },
    "comment": " "
  },
  "can-stream/type/implementation.toCompute": {
    "src": {
      "path": "node_modules/can-stream/docs/implementation.toCompute.md"
    },
    "body": "",
    "description": "Creates a [can-compute.computed] from a stream generator function. \n",
    "title": "toCompute",
    "name": "can-stream/type/implementation.toCompute",
    "type": "function",
    "parent": "can-stream.types.streamImplementation",
    "signatures": [
      {
        "code": "toCompute( makeStream(setStream), [context] )",
        "description": "\n\nThis returns a [can-compute.computed] that when [can-compute.computed.on bound]\ntakes on the value of the stream returned by `makeStream`.  `makeStream`\nis called with:\n\n - its `this` as the `context`, and\n - `setStream` which is a stream of values set on the returned compute (ex: `compute(5)`).\n\nThis is used to create computes from streams.\n\n```js\nvar count = Kefir.sequentially(1000, [1, 2]);\n\nvar myCompute = canStream.toCompute(function(setStream){\n\treturn setStream.merge(count);\n});\n\n// listen to the compute for it to have a value\nmyCompute.on(\"change\", function(){})\n\nmyCompute(\"A\")\n\n// immediate value\nmyCompute() //-> \"A\"\n\n// 1000ms later\nmyCompute() //-> 1\n\n// 1000ms later\nmyCompute() //-> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "Stream"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Stream"
                      }
                    ],
                    "name": "setStream"
                  }
                ]
              }
            ],
            "name": "makeStream",
            "description": "A stream generator\nfunction.  This function takes the stream of set values, and typically other streams\nand manipulates them into the final returned output stream.  The output stream's\nvalues are used as the value of the returned [can-compute.computed].\n\nThe `setStream` is the stream of values set on the returned compute. In the following example, `setStream` will emit the values `1` and then `2`.\n\n```js\nvar returnedCompute = canStream.toCompute(function(setStream){\n return setStream;\n});\nreturnedCompute(1);\nreturnedCompute(2);\n```\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "An optional context which will be the `this` of `makeStream`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute that when read will return the value of\nthe stream returned by `setStream`.  When the compute is written to, it will\nupdate `setStream`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "context",
      "description": "An optional context which will be the `this` of `makeStream`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute that when read will return the value of\nthe stream returned by `setStream`.  When the compute is written to, it will\nupdate `setStream`.\n"
    }
  },
  "can-stream/type/implementation.toStream": {
    "src": {
      "path": "node_modules/can-stream/docs/implementation.toStream.md"
    },
    "body": "",
    "description": "Create a stream from an observable. \n",
    "title": "toStream",
    "name": "can-stream/type/implementation.toStream",
    "type": "function",
    "parent": "can-stream.types.streamImplementation",
    "signatures": [
      {
        "code": "toStream( compute )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Compute"
              }
            ],
            "name": "compute",
            "description": "An [can-compute] object\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Compute"
        }
      ],
      "name": "compute",
      "description": "An [can-compute] object\n"
    }
  },
  "can-stream/type/interface.toCompute": {
    "src": {
      "path": "node_modules/can-stream/docs/interface.toCompute.md"
    },
    "body": "",
    "description": "Create a [can-compute.computed] from a stream generator function. \n",
    "title": "toCompute",
    "name": "can-stream/type/interface.toCompute",
    "type": "function",
    "parent": "can-stream.types.streamInterface",
    "signatures": [
      {
        "code": "canStream.toCompute( makeStream(setStream), [context] )",
        "description": "\n\nThis returns a [can-compute.computed] that when [can-compute.computed.on bound]\ntakes on the value of the stream returned by `makeStream`.  `makeStream`\nis called with:\n\n - its `this` as the `context`, and\n - `setStream` which is a stream of values set on the returned compute (ex: `compute(5)`).\n\nThis is used to create computes from streams.\n\n```js\nvar count = Kefir.sequentially(1000, [1, 2]);\n\nvar myCompute = canStream.toCompute(function(setStream){\n\treturn setStream.merge(count);\n});\n\n// listen to the compute for it to have a value\nmyCompute.on(\"change\", function(){})\n\nmyCompute(\"A\")\n\n// immediate value\nmyCompute() //-> \"A\"\n\n// 1000ms later\nmyCompute() //-> 1\n\n// 1000ms later\nmyCompute() //-> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "Stream"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Stream"
                      }
                    ],
                    "name": "setStream"
                  }
                ]
              }
            ],
            "name": "makeStream",
            "description": "A stream generator\nfunction.  This function takes the stream of set values, and typically other streams\nand manipulates them into the final returned output stream.  The output stream's\nvalues are used as the value of the returned [can-compute.computed].\n\nThe `setStream` is the stream of values set on the returned compute. In the following example, `setStream` will emit the values `1` and then `2`.\n\n```js\nvar returnedCompute = canStream.toCompute(function(setStream){\n return setStream;\n});\nreturnedCompute(1);\nreturnedCompute(2);\n```\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "An optional context which will be the `this` of `makeStream`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute that when read will return the value of\nthe stream returned by `setStream`.  When the compute is written to, it will\nupdate `setStream`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "context",
      "description": "An optional context which will be the `this` of `makeStream`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute that when read will return the value of\nthe stream returned by `setStream`.  When the compute is written to, it will\nupdate `setStream`.\n"
    }
  },
  "can-stream/type/interface.toStream": {
    "src": {
      "path": "node_modules/can-stream/docs/interface.toStream.md"
    },
    "body": "",
    "description": "Provides a shorthand for creating a stream from observable objects, properties and events.\n\n",
    "title": "toStream",
    "name": "can-stream/type/interface.toStream",
    "type": "function",
    "parent": "can-stream.types.streamInterface",
    "signatures": [
      {
        "code": "canStream.toStream( observable, propAndOrEvent )",
        "description": "\n\n  Creates a stream from a [can-compute] compute or an observable. This stream gets updated whenever the observable value changes.\n\n  ```js\n  var compute = require('can-compute');\n  var canStreamKefir = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n\n  var c1 = compute(0);\n\n  var resultCompute = canStreaming.toStream(c1);\n\n  resultCompute.onValue(function (val) {\n    console.log(val);\n  });\n\n  c1(1);\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "A compute whose value will be the stream values.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A stream object.\n"
        }
      },
      {
        "code": "canStream.toStream( observable, \"eventName\" )",
        "description": "\n\n  Creates an event stream with the event objects dispatched on `obs` for `eventName`.\n  This is a shorthand for [can-stream.toStreamFromEvent].\n\n  ```js\n  var DefineList = require('can-define/list/list');\n  var canStream = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n\n  var hobbies = new DefineList([\"js\",\"kayaking\"]);\n\n  var changeCount = canStreaming.toStream(hobbies, \"length\").scan(function(prev){\n\t  return prev + 1;\n  }, 0);\n  changeCount.onValue(function(event) {\n      console.log(event);\n  });\n\n  hobbies.push(\"bball\")\n  //-> console.logs {type: \"add\", args: [2,[\"bball\"]]}\n  hobbies.shift()\n  //-> console.logs {type: \"remove\", args: [0,[\"js\"]]}\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "observable",
            "description": "An observable object like a [can-define/map/map].\nPromises can work too."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An observable event name.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A stream make up of the event objects dispatched on `obs`.\n\n"
        }
      },
      {
        "code": "canStream.toStream( observable, \".propName\" )",
        "description": "\n\n  Creates a stream from an observable property value. This is a shorthand for [can-stream.toStreamFromProperty].\n\n  ```js\n  var canStreamKefir = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n\n  var DefineMap = require(\"can-define/map/map\");\n\n  var person = new DefineMap({\n      first: \"Justin\",\n\t  last: \"Meyer\"\n  });\n\n  var first = canStreaming.toStream(person, '.first'),\n      last = canStreaming.toStream(person, '.last');\n\n  var fullName = Kefir.combine(first, last, function(first, last){\n\t  return first + last;\n  });\n\n  fullName.onValue(function(newVal){\n      console.log(newVal);\n  });\n\n  map.first = \"Payal\"\n  //-> console.logs \"Payal Meyer\"\n  ```\n\n  Create a stream based on a event on an observable property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\n  Promises can work too."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name.  Multiple property names can be provided like `\".foo.bar.car\"`\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A stream of values at the specified `propName`.\n"
        }
      },
      {
        "code": "canStream.toStream( obs, \".propName eventName\" )",
        "description": "\n\n  Creates a stream from an observable property value. This is a shorthand for the second signature of [can-stream.toStreamFromEvent].\n\n  ```js\n  var canStreamKefir = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n\n  var DefineMap = require(\"can-define/map/map\");\n  var DefineList = require(\"can-define/list/list\");\n\n  var me = new DefineMap({\n      todos: [\"mow lawn\"]\n  });\n\n  var addStream = canStreaming.toStream(me, \".todos add\");\n\n  addStream.onValue(function(event){\n      console.log(event);\n  });\n\n  map.todos.push(\"do dishes\");\n  //-> console.logs {type: \"add\", args: [1,[\"do dishes\"]]}\n  ```\n\n  Create a stream based on a event on an observable property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\n  Promises can work too.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name.  Multiple property names can be provided like `\".foo.bar.car\"`"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An observable event name."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A stream of the `eventName` event objects dispatched on the objects specified by `propName`.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A stream of the `eventName` event objects dispatched on the objects specified by `propName`.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "eventName",
      "description": "An observable event name."
    }
  },
  "can-stream/type/interface.toStreamFromEvent": {
    "src": {
      "path": "node_modules/can-stream/docs/interface.toStreamFromEvent.md"
    },
    "body": "",
    "description": "Creates a stream on a {Observable} object that gets updated whenever the event occurs on the observable object. \n",
    "title": "toStreamFromEvent",
    "name": "can-stream/type/interface.toStreamFromEvent",
    "type": "function",
    "parent": "can-stream.types.streamInterface",
    "signatures": [
      {
        "code": "canStream.toStreamFromEvent( obs, eventName )",
        "description": "\n\n  Creates a stream based on event on observable\n\n  ```js\n  var canStreamKefir = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n\n  var compute = require('can-compute');\n  var DefineMap = require('can-define/map/map');\n  var DefineList = require('can-define/list/list');\n\n  var MyMap = DefineMap.extend({\n      tasks: {\n          Type: DefineList.List,\n          value: []\n      }\n  });\n  var map = new MyMap();\n\n  var stream = canStreaming.toStreamFromEvent(map, 'tasks');\n\n  stream.onValue(function(ev){\n      console.log('map.tasks has been updated');\n  });\n\n  map.fooList.push('New task');\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "An",
            "description": "observable object"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A stream.\n\n"
        }
      },
      {
        "code": "canStream.toStreamFromEvent( obs, propName, eventName )",
        "description": "\n\n  Creates a stream based on event trigger on observable property\n\n  ```js\n  var canStreamKefir = require('can-stream-kefir');\n  var canStream = require('can-stream');\n  var canStreaming = canStream(canStreamKefir);\n  var compute = require('can-compute');\n  var DefineMap = require('can-define/map/map');\n  var DefineList = require('can-define/list/list');\n\n  var MyMap = DefineMap.extend({\n      tasks: {\n          Type: DefineList.List,\n          value: []\n      }\n  });\n  var map = new MyMap();\n\n  var stream = canStreaming.toStreamFromEvent(map, 'tasks', 'length');\n\n  stream.onValue(function(ev){\n      console.log('map.tasks has been updated');\n  });\n\n  map.fooList.push('New task');\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "An",
            "description": "observable object"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "observable",
            "description": "property name"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "observable",
            "description": "event name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A stream.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A stream.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "observable",
      "description": "event name\n"
    }
  },
  "can-stream/type/interface.toStreamFromProperty": {
    "src": {
      "path": "node_modules/can-stream/docs/interface.toStreamFromProperty.md"
    },
    "body": "",
    "description": "Creates a stream on a {Observable} object that gets updated whenever the property value on the observable changes. \n",
    "title": "toStreamFromProperty",
    "name": "can-stream/type/interface.toStreamFromProperty",
    "type": "function",
    "parent": "can-stream.types.streamInterface",
    "signatures": [
      {
        "code": "canStream.toStreamFromProperty( obs, propName )",
        "description": "\n\n  Creates a stream based on property value change on observable\n\n  ```js\n  var map = {\n      foo: \"bar\"\n  };\n  var stream = canStreaming.toStreamFromProperty(map, 'foo');\n\n  stream.onValue(function(value){\n    console.log(value); // -> foobar\n  });\n\n  map.foo = \"foobar\";\n  ```",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "An",
            "description": "observable object"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "property",
      "description": "name\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A stream.\n"
    }
  },
  "can-stream.types.makeStream": {
    "src": {
      "path": "node_modules/can-stream/docs/types.makeStream.md"
    },
    "body": "",
    "description": "This function takes a stream whose values are bound to the returned [can-compute.computed]. \n",
    "type": "typedef",
    "title": "makeStream",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-stream.types.makeStream",
    "parent": "can-stream.types",
    "signatures": [
      {
        "code": "makeStream(setStream)",
        "description": "\n\n```js\nvar Kefir = require('kefir');\nvar count = Kefir.sequentially(1000, [1, 2]);\n\nvar myCompute = canStream.toCompute(function(setStream) {\n\treturn setStream.merge(count);\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Stream"
              }
            ],
            "name": "setStream",
            "description": "A stream to bind to the returned [can-compute.computed].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "name": "setStream",
      "description": "A stream to bind to the returned [can-compute.computed].\n"
    }
  },
  "can-stream.types.streamImplementation": {
    "src": {
      "path": "node_modules/can-stream/docs/types.streamImplementation.md"
    },
    "body": "\n## Use\n\nSee [can-stream-kefir] for example implementation.\n\n",
    "description": "Export an object with a minimal implementation of `toStream` and `toCompute` methods specific to a streaming library like [Kefir](https://rpominov.github.io/kefir/) \n",
    "type": "typedef",
    "title": "StreamImplementation",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "toStream",
            "description": "\n",
            "types": [
              {
                "type": "can-stream/type/implementation.toStream"
              }
            ]
          },
          {
            "name": "toCompute",
            "description": "\n",
            "types": [
              {
                "type": "can-stream/type/implementation.toCompute"
              }
            ]
          }
        ],
        "description": "\n  An object with `toStream` and `toCompute` methods.\n\n```js\nvar streamImplementation = {\n\ttoStream: function(compute){\n\t\treturn MAKE_THE_STREAM_FROM_A_COMPUTE(compute);\n\t},\n\ttoCompute: function(makeStream, context){\n\t\tvar setStream = MAKE_A_SETTABLE_STREAM_THAT_IS_SET_WHEN_COMPUTE_IS_SET();\n\t\tvar stream = makeStream.call(context, setStream);\n\n\t\tvar compute = MAKE_COMPUTE_TO_HAVE_VALUE_FROM_stream_AND_SET_TO_setStream;\n\n\t\treturn compute;\n\t}\n};\n\nvar canStream = require(\"can-stream\");\n\nvar streamInterface = canStream(streamImplementation);\n\nvar map = new DefineMap({name: \"John\"});\nstreamInterface(map, \".name\") //-> an instance of the stream library.\n\nmodule.exports = streamInterface;\n```\n"
      }
    ],
    "name": "can-stream.types.streamImplementation",
    "parent": "can-stream.types",
    "comment": " "
  },
  "can-stream.types.streamInterface": {
    "src": {
      "path": "node_modules/can-stream/docs/types.streamInterface.md"
    },
    "body": "",
    "description": "Stream interface function returned from [can-stream] \n",
    "type": "typedef",
    "title": "streamInterface",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-stream.types.streamInterface",
    "parent": "can-stream.types",
    "signatures": [
      {
        "code": "streamInterface( observable, propAndOrEvent[,event] )",
        "description": "\n\nThe stream interface function returned from [can-stream] that has the following property methods:\n\n- .toStream(observable, propAndOrEvent[,event])\n- .toStreamFromProperty(property)\n- .toStreamFromEvent(property)\n- .toCompute([can-stream.types.makeStream makeStream(setStream)], context):compute\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "observable",
            "description": "An observable object\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "A property of the observable object prepended with `.`\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "event",
            "description": "An optional event name of the observable object\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "event",
      "description": "An optional event name of the observable object\n\n"
    }
  },
  "can-stream-kefir.fns": {
    "name": "can-stream-kefir.fns",
    "title": "Methods",
    "type": "group",
    "parent": "can-stream-kefir",
    "description": "",
    "order": 2
  },
  "can-stream-kefir": {
    "src": {
      "path": "node_modules/can-stream-kefir/docs/can-stream-kefir.md"
    },
    "body": "\n## Usage\n\nThe [can-stream-kefir.toStream] method takes a compute and returns a [Kefir](https://rpominov.github.io/kefir/) stream instance.\n\n```\nvar canStream = require(\"can-stream-kefir\");\n\ncanStream.toStream(compute)                    //-> stream\n```\n\nFor example:\n\n__Converting a compute to a stream__\n\n```js\nvar canCompute = require(\"can-compute\");\nvar canStream = require(\"can-stream-kefir\");\n\nvar compute = canCompute(0);\nvar stream = canStream.toStream(compute);\n\nstream.onValue(function(newVal){\n\tconsole.log(newVal);\n});\n\ncompute(1);\n//-> console.logs 1\n```\n\n",
    "description": "Convert observable values into streams. [Kefir](https://rpominov.github.io/kefir/) is used to provide the stream functionality. \n",
    "type": "module",
    "title": "can-stream-kefir",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n  The `can-stream-kefir` module exports methods useful for converting observable values like [can-compute]s\n  or [can-define/map/map] properties into streams.\n\n  ```js\n  var canStream = require(\"can-stream-kefir\");\n  var DefineMap = require(\"can-define/map/map\");\n\n  var me = new DefineMap({name: \"Justin\"});\n\n  var nameStream = canStream.toStream(me,\".name\");\n\n\n  nameStream.onValue(function(name){\n\t  // name -> \"Obaid\";\n  });\n\n  me.name = \"Obaid\";\n  ```\n"
      }
    ],
    "name": "can-stream-kefir",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-stream-kefir/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-event": "^3.0.0",
        "can-observation": "^3.0.0",
        "can-stream": "^0.2.1",
        "can-util": "^3.0.0",
        "kefir": "^3.5.1"
      },
      "description": "Stream values into and out of computes",
      "devDependencies": {
        "can-define": "^1.0.0",
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-stream-kefir",
      "name": "can-stream-kefir",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-stream-kefir.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish --tag pre",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "0.2.3"
    },
    "comment": " "
  },
  "can-stream-kefir.toCompute": {
    "src": {
      "path": "node_modules/can-stream-kefir/docs/toCompute.md"
    },
    "body": "",
    "description": "Creates a [can-compute.computed] from a stream generator function. \n",
    "title": "toCompute",
    "name": "can-stream-kefir.toCompute",
    "type": "function",
    "parent": "can-stream-kefir.fns",
    "signatures": [
      {
        "code": "canStream.toCompute( makeStream(setStream), [context] )",
        "description": "\n\nThis returns a [can-compute.computed] that when [can-compute.computed.on bound]\ntakes on the value of the stream returned by `makeStream`.  `makeStream`\nis called with:\n\n - its `this` as the `context`, and\n - `setStream` which is a stream of values set on the returned compute (ex: `compute(5)`).\n\nThis is used to create computes from streams.  \n\n```js\nvar count = Kefir.sequentially(1000, [1, 2]);\n\nvar myCompute = canStream.toCompute(function(setStream){\n\treturn setStream.merge(count);\n});\n\n// listen to the compute for it to have a value\nmyCompute.on(\"change\", function(){})\n\nmyCompute(\"A\")\n\n// immediate value\nmyCompute() //-> \"A\"\n\n// 1000ms later\nmyCompute() //-> 1\n\n// 1000ms later\nmyCompute() //-> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "Stream"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Stream"
                      }
                    ],
                    "name": "setStream"
                  }
                ]
              }
            ],
            "name": "makeStream",
            "description": "A stream generator\nfunction.  This function takes the stream of set values, and typically other streams and manipulates them into the final returned output stream.  The output stream's values are used as the value of the returned [can-compute.computed].\n\nThe `setStream` is the stream of values set on the returned compute. In the following example, `setStream` will emit the values `1` and then `2`.\n\n```js\nvar returnedCompute = canStream.toCompute(function(setStream){\n return setStream;\n});\nreturnedCompute(1);\nreturnedCompute(2);\n```\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "An optional context which will be the `this` of `makeStream`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute that when read will return the value of the stream returned by `setStream`.  When the compute is written to, it will update `setStream`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "context",
      "description": "An optional context which will be the `this` of `makeStream`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute that when read will return the value of the stream returned by `setStream`.  When the compute is written to, it will update `setStream`.\n"
    }
  },
  "can-stream-kefir.toStream": {
    "src": {
      "path": "node_modules/can-stream-kefir/docs/tostream.md"
    },
    "body": "\n",
    "description": "Provides a shorthand for creating a stream from observable objects, properties and events.\n\n",
    "title": "toStream",
    "name": "can-stream-kefir.toStream",
    "type": "function",
    "parent": "can-stream-kefir.fns",
    "signatures": [
      {
        "code": "canStream.toStream( compute )",
        "description": "\n\n  Creates a stream from a [can-compute] compute. This stream gets updated whenever the compute value changes.\n\n  ```js\n  var compute = require('can-compute');\n  var canStream = require('can-stream-kefir');\n\n  var c1 = compute(0);\n\n  var resultCompute = canStream.toStream(c1);\n\n  resultCompute.onValue(function (val) {\n    console.log(val);\n  });\n\n  c1(1);\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "A compute whose value will be the stream values.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream.\n"
        }
      },
      {
        "code": "canStream.toStream( obs, \"eventName\" )",
        "description": "\n\n  Creates an event stream with the event objects dispatched on `obs` for `eventName`.\n  This is a shorthand for [can-stream-kefir.toStreamFromEvent].\n\n  ```js\n  var DefineList = require('can-define/list/list');\n  var canStream = require('can-stream-kefir');\n\n  var hobbies = new DefineList([\"js\",\"kayaking\"]);\n\n  var changeCount = canStream.toStream(hobbies, \"length\").scan(function(prev){\n\t  return prev + 1;\n  }, 0);\n  changeCount.onValue(function(event) {\n      console.log(event);\n  });\n\n  hobbies.push(\"bball\")\n  //-> console.logs {type: \"add\", args: [2,[\"bball\"]]}\n  hobbies.shift()\n  //-> console.logs {type: \"remove\", args: [0,[\"js\"]]}\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\nPromises can work too."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An observable event name.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream make up of the event objects dispatched on `obs`.\n\n"
        }
      },
      {
        "code": "canStream.toStream( obs, \".propName\" )",
        "description": "\n\n  Creates a stream from an observable property value. This is a shorthand for [can-stream-kefir.toStreamFromProperty].\n\n  ```js\n  var canStream = require('can-stream-kefir');\n  var DefineMap = require(\"can-define/map/map\");\n\n  var person = new DefineMap({\n      first: \"Justin\",\n\t  last: \"Meyer\"\n  });\n\n  var first = canStream.toStream(person, '.first'),\n      last = canStream.toStream(person, '.last');\n\n  var fullName = Kefir.combine(first, last, function(first, last){\n\t  return first + last;\n  });\n\n  fullName.onValue(function(newVal){\n      console.log(newVal);\n  });\n\n  map.first = \"Payal\"\n  //-> console.logs \"Payal Meyer\"\n  ```\n\n  Create a stream based on a event on an observable property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\n  Promises can work too."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name.  Multiple property names can be provided like `\".foo.bar.car\"`\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream of values at the specified `propName`.\n"
        }
      },
      {
        "code": "canStream.toStream( obs, \".propName eventName\" )",
        "description": "\n\n  Creates a stream from an observable property value. This is a shorthand for the second signature of [can-stream-kefir.toStreamFromEvent].\n\n  ```js\n  var canStream = require('can-stream-kefir');\n  var DefineMap = require(\"can-define/map/map\");\n  var DefineList = require(\"can-define/list/list\");\n\n  var me = new DefineMap({\n      todos: [\"mow lawn\"]\n  });\n\n  var addStream = canStream.toStream(me, \".todos add\");\n\n  addStream.onValue(function(event){\n      console.log(event);\n  });\n\n  map.todos.push(\"do dishes\");\n  //-> console.logs {type: \"add\", args: [1,[\"do dishes\"]]}\n  ```\n\n  Create a stream based on a event on an observable property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\n  Promises can work too.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name.  Multiple property names can be provided like `\".foo.bar.car\"`"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An observable event name."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream of the `eventName` event objects dispatched on the objects specified by `propName`.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A [Kefir](https://rpominov.github.io/kefir/) stream of the `eventName` event objects dispatched on the objects specified by `propName`.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "eventName",
      "description": "An observable event name."
    }
  },
  "can-util/dom": {
    "name": "can-util/dom",
    "title": "can-util/dom",
    "type": "group",
    "parent": "can-util",
    "description": "",
    "order": 0
  },
  "can-util/js": {
    "name": "can-util/js",
    "title": "can-util/js",
    "type": "group",
    "parent": "can-util",
    "description": "",
    "order": 0
  },
  "can-util": {
    "src": {
      "path": "node_modules/can-util/doc/can-util.md"
    },
    "body": "\n\n## can-util/js\n\n- [can-util/js/assign/assign] - A simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.\n- [can-util/js/base-url/base-url] - Get and/or set the \"base\" (containing path) of the document.\n- [can-util/js/cid/cid] - Deprecated. Use [can-cid] instead.\n- [can-util/js/deep-assign/deep-assign] - Assign properties from a source object to a target object, deeply copying properties that are objects or arrays.\n- [can-util/js/defaults/defaults] - Mimics [_.defaults](https://lodash.com/docs/4.16.2#defaults). Assigns first level properties in sources from left to right if they are not already defined.\n- [can-util/js/deparam/deparam] - Takes a string of name value pairs and returns a Object literal that represents those params.\n- [can-util/js/dev/dev] - Utilities for logging development-mode messages. Use this module for anything that should be shown to the user during development but isn't needed in production. In production these functions become noops.\n- [can-util/js/diff/diff] - Returns the difference between two ArrayLike objects (that have nonnegative integer keys and the `length` property) as an array of patch objects.\n- [can-util/js/diff-object/diff-object] - Find the differences between two objects, based on properties and values.\n- [can-util/js/each/each] - Loop over each element in an Array-Like data structure.\n- [can-util/js/get/get] - Returns the value at the specified property path of an object.\n- [can-util/js/global/global] - Returns the global that an environment provides.      \n- [can-util/js/import/import] - Imports a module.\n- [can-util/js/is-array-like/is-array-like] - Determines if an object is \"array like\", meaning it can be looped over. Any object with a `.length` property is array like.\n- [can-util/js/is-browser-window/is-browser-window] - Returns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).\n- [can-util/js/is-empty-object/is-empty-object] - Used to determine if an object is an empty object (an object with no enumerable properties) such as `{}`.\n- [can-util/js/is-function/is-function] - Used to determine if a value is a function.\n- [can-util/js/is-node/is-node] - Determines if your code is running in [Node.js](https://nodejs.org).\n- [can-util/js/is-plain-object/is-plain-object] - Attempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`.\n- [can-util/js/is-promise/is-promise] - Determines if object is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n- [can-util/js/is-promise-like/is-promise-like] - Determines if an object is \"Then-able\".\n- [can-util/js/is-string/is-string] - Determines if the provided argument is a string.\n- [can-util/js/is-web-worker/is-web-worker] - Determines if the code is running with a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers).\n- [can-util/js/join-uris/join-uris] - Provides a convenient way to join together URIs handling relative paths.\n- [can-util/js/log/log] - Utilities for logging to the console.\n- [can-util/js/make-array/make-array] - Takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array.\n- [can-util/js/make-promise/make-promise] - Will make isPromiseLike object into [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n- [can-util/js/omit/omit] - Omit properties from an object.\n- [can-util/js/param/param] - Takes an Object of name value pairs and returns a String with the parameters encoded.\n- [can-util/js/set-immediate/set-immediate] - Polyfill for setImmediate() if it doesn't exist in the global context.\n- [can-util/js/string/string] - String utilities used by CanJS libraries.\n- [can-util/js/string-to-any/string-to-any] - Turns a string representation of a primitive type back into the associated primitive.\n- [can-util/js/types/types] - Deprecated. Use [can-types] instead.\n\n## can-util/dom\n\n- [can-util/dom/ajax/ajax] - Used to make an asynchronous HTTP (AJAX) request\nsimilar to [http://api.jquery.com/jQuery.ajax/jQuery.ajax].\n- [can-util/dom/attr/attr] - A module that makes it easy to access attributes and properties of elements.\n- [can-util/dom/child-nodes/child-nodes] - Get all of the childNodes of a given node.\n- [can-util/dom/class-name/class-name] - Allows querying and manipulation of classes on HTML elements.\n- [can-util/dom/data/data] - Allows associating data as a key/value pair for a particular DOM node.\n- [can-util/dom/dispatch/dispatch] - Dispatch an event on an element.\n- [can-util/dom/document/document] - Optionally sets, and returns, the document object for the context.\n- [can-util/dom/events/events] - Allows you to listen to a domEvent and special domEvents as well as dispatch domEvents.\n- [can-util/dom/frag/frag] - Convert a String, HTMLElement, documentFragment, or contentArray into a documentFragment.\n- [can-util/dom/mutate/mutate] - Mutate an element by appending, inserting, and removing DOM nodes. Use this so that on the server \"inserted\" will be fired.\n\n",
    "description": "\nCommon JavaScript utilities for the rest of CanJS.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-util",
    "parent": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": [
            "node_modules/**/*",
            "**/*{-,_,}{test,qunit}{s,}.js"
          ]
        },
        "readme": {
          "apis": "./doc/apis.json"
        },
        "parent": "can-util"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-util/issues"
      },
      "dependencies": {
        "can-cid": "^1.0.0",
        "can-deparam": "^1.0.0",
        "can-event-radiochange": "0.0.2",
        "can-namespace": "1.0.0",
        "can-param": "^1.0.0",
        "can-types": "^1.0.1"
      },
      "description": "Common utilities for CanJS projects",
      "devDependencies": {
        "async": "^2.2.0",
        "bit-docs": "0.0.7",
        "can-vdom": "^3.0.3",
        "done-serve": "^1.0.0",
        "donejs-cli": "^1.0.0",
        "generator-donejs": "^1.0.0",
        "http-server": "^0.9.0",
        "jshint": "^2.9.1",
        "mocha": "^3.0.2",
        "mocha-qunit-ui": "^0.1.2",
        "saucelabs": "^1.4.0",
        "steal": "^1.0.4",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "test-saucelabs": "0.0.1",
        "testee": "^0.4.0",
        "wd": "^1.1.3"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "license": "MIT",
      "main": "can-util",
      "name": "can-util",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-util.git"
      },
      "scripts": {
        "build": "node build.js",
        "ci": "npm run build && npm run test && node test/test-sauce-labs.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "http-server": "http-server -p 3000 --silent",
        "jshint": "jshint dom/. js/. *.js --config",
        "mocha": "mocha --reporter dot --ui mocha-qunit-ui js/tests",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run mocha && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.7.0"
    },
    "comment": " "
  },
  "can-validate.methods": {
    "name": "can-validate.methods",
    "title": "Methods",
    "type": "group",
    "parent": "can-validate",
    "description": "",
    "order": 1
  },
  "can-validate.types": {
    "name": "can-validate.types",
    "title": "Types",
    "type": "group",
    "parent": "can-validate",
    "description": "",
    "order": 2
  },
  "can-validate": {
    "src": {
      "path": "node_modules/can-validate/docs/can-validate.md"
    },
    "body": "\n\n## Usage\n\nThe [can-validate.formatErrors] method can be used to convert errors into something more useful.\n\n```javascript\nvar formatErrors = require('can-validate').formatErrors;\nvar errors = [\n    'is required',\n    {\n        message: 'must be a number',\n        related: 'age'\n    }\n];\n\nformatErrors(errors, 'object');\n//=> [{'*': ['is required']}, {'age': ['must be a number']}]\n\nformatErrors(errors, 'flat');\n//=> ['is required', 'must be a number']\n\nformatErrors(errors, 'errors');\n//=> [{message: 'is required', related: '*'}, {'age': ['must be a number']}]\n```\n\n## Types\n\nCore definitions of types used in validation.\n\n- [can-validate.error] A flexible typedef that describes a validation error.\n- [can-validate.errors] Different error types understood by `can-validate`.\n- [can-validate.validator] A function that validate a given value against registered constraints.\n\n",
    "description": "\nShared utilities and type definitions to process validation errors.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nThe `can-validate` module exports helpful methods used for validation and also describes\nthe different types used during validation.\n\n```javascript\nvar validate = require('my-validator');\nvar utils = require('can-validate');\n\n// Normalize errors into a flat structure\nvar errors = utils.formatErrors(validate(obj, constraints), 'flat');\n```\n"
      }
    ],
    "name": "can-validate",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": [
            "can-validate"
          ]
        },
        "parent": "can-validate"
      },
      "browser": {},
      "bugs": {
        "url": "https://github.com/canjs/can-validate/issues"
      },
      "dependencies": {
        "can-util": "^3.2.2"
      },
      "description": "Validation plugin for CanJS.",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "http-server": "^0.9.0",
        "jshint": "^2.9.4",
        "steal": "^1.0.8",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.3.0"
      },
      "homepage": "https://github.com/canjs/can-validate",
      "keywords": [
        "Validate",
        "plugin",
        "canjs"
      ],
      "license": "MIT",
      "main": "can-validate.js",
      "name": "can-validate",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-validate.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "http-server -c-1",
        "document": "bit-docs",
        "jshint": "jshint .",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:pre": "npm version prerelease && npm run build && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "ignoreBrowser": true,
        "npmIgnore": [
          "documentjs",
          "testee",
          "steal-tools"
        ],
        "npmAlgorithm": "flat",
        "npmDependencies": [
          "steal-qunit"
        ],
        "transpiler": "babel"
      },
      "version": "1.0.2"
    },
    "comment": " "
  },
  "can-validate.error": {
    "src": {
      "path": "node_modules/can-validate/docs/error-object.md"
    },
    "body": "\n\n\n## Wild card\n\nIt is common to group errors by the property that triggered the error state. In\nsome cases, it possible to group errors where one error is not identified with\na property.\n\n```javascript\nvar errors = [\n    { message: 'is required'},\n    {\n        message: 'must be a number',\n        related: 'age'\n    }\n];\n```\n\nIn this situation, the first object in the array is not identified with a property.\nThis item will have a `related` assumed to be `*`. It possible for this error item\nto be grouped with other \"orphaned\" errors.\n\n```javascript\nvar errors = [\n    {\n        message: 'is required',\n        related: '*'\n    }, {\n        message: 'must be a number',\n        related: 'age'\n    }\n];\n```\n\n",
    "description": "\nAn object that defines a validation failure.\n",
    "type": "typedef",
    "title": "Error",
    "types": [
      {
        "type": "object",
        "options": [
          {
            "name": "message",
            "description": "A reason why value is in an invalid state.\n\n```javascript\nvar error = { \"message\": \"is required\"};\n```\n",
            "types": [
              {
                "type": "string"
              }
            ]
          },
          {
            "name": "related",
            "description": "Key names that are related to triggering the\ninvalid state of the current value.\n\n```json\n{ \"message\": \"is required\", \"related\": \"age\"}\n```\n\n```json\n{ \"message\": \"is required\", \"related\": [\"billingZip\", \"residenceZip\"]}\n```\n\nIf no value is passed, the wild card value (`*`) is used internally for grouping.\n",
            "types": [
              {
                "type": "string"
              },
              {
                "type": "array"
              }
            ],
            "optional": true,
            "defaultValue": "*"
          }
        ]
      }
    ],
    "name": "can-validate.error",
    "parent": "can-validate.types",
    "comment": " "
  },
  "can-validate.errors": {
    "src": {
      "path": "node_modules/can-validate/docs/errors.md"
    },
    "body": "\n",
    "description": "\nThe expected response from a validator if a value fails validation.\n",
    "type": "typedef",
    "title": "Errors",
    "types": [
      {
        "type": "undefined",
        "description": "Expected when value passes validation.\n"
      },
      {
        "type": "null",
        "description": "Will be treated similarly as `undefined`; value passed validation.\n"
      },
      {
        "type": "string",
        "description": "A message explaining the validation failure.\n\n```javascript\n\"is required\"\n```\n"
      },
      {
        "type": "ERROR",
        "description": "An object used to describe an error message. See [can-validate.error].\n\n```json\n{\n    \"message\": \"is required\",\n    \"related\": [\"billingZip\", \"residenceZip\"]\n}\n```\n"
      },
      {
        "type": "array",
        "description": "Items can be any of the valid [can-validate.errors].\n\n```json\n[\n    \"is required\",\n    {\n        \"message\": \"is required\",\n        \"related\": [\"billingZip\", \"residenceZip\"]\n    }\n]\n```\n"
      }
    ],
    "name": "can-validate.errors",
    "parent": "can-validate.types"
  },
  "can-validate.validator": {
    "src": {
      "path": "node_modules/can-validate/docs/validator.md"
    },
    "body": "\n\n## Creating a validator\n\nGiven that a `required` validation exists\n```js\n// Custom required check\nvar checkRequired = function (val) {\n    if (typeof value === 'undefined' || value === '') {\n        return false;\n    }\n    return true;\n};\n```\n\nTypically a validator can be created like so\n\n```js\n// Validator factory\nvar makeValidator = function (constraints) {\n\treturn function (value) {\n\t\tif (constraints.required && !checkRequired(value)) {\n\t\t\treturn 'is required';\n\t\t}\n\t}\n};\n```\n\nNow, creating a validator for any value is possible by doing\n\n```js\nvar nameValidator = makeValidator({required: true});\n```\n\nWhich then allows validating values as needed\n\n```js\nnameValidator('Juan'); //> undefined\nnameValidator(); //> 'is required'\n```\n\n## Validator Response\n\nThe response should match the [can-validate.errors] type. The most flexible response\nis the [can-validate.error] type which describes the error message any value keys that\ntriggered the error state.\n\n",
    "description": "\nA function that validates a value against predefined constraints and returns validation errors, if any are found.\n",
    "type": "typedef",
    "title": "validator",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-validate.validator",
    "parent": "can-validate.types",
    "signatures": [
      {
        "code": "validator(value)",
        "description": "\n\n  ```js\n  function (value) {\n  \tif (typeof value === 'undefined' || value === '')) {\n  \t\treturn 'is required';\n  \t}\n  }\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "A simple value to validate\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Error"
            },
            {
              "type": "String"
            },
            {
              "type": "undefined"
            },
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Error"
                    },
                    {
                      "type": "String"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns undefined if no errors found. Otherwise, will return an error type with the error message.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "A simple value to validate\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Error"
        },
        {
          "type": "String"
        },
        {
          "type": "undefined"
        },
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Error"
                },
                {
                  "type": "String"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns undefined if no errors found. Otherwise, will return an error type with the error message.\n"
    },
    "comment": " "
  },
  "can-validate.formatErrors": {
    "src": {
      "path": "node_modules/can-validate/docs/format-errors.md"
    },
    "body": "\n## Usage\n\nThe `errors` value should match the possible [can-validate.errors] type.\n\nGiven the following...\n\n```js\n// validate this object\nvar person = {};\n// against these constraints\nvar constraints = {\n\tage: {\n\t\trequired: true,\n\t\tnumber: true\n\t}\n};\n// will return some errors\nvar errors = someValidator(person, constraints);//> [\"is required\", \"must be a number\"]\n```\n\nWe can expect the following responses\n\n### Object Example\n\nIf no key exists in the error response, an array like object will be created.\n\n```json\n{\n\t\"0\": [\"is required\", \"must be a number\"]\n}\n```\n\n### Flat Example\n\n```json\n[\n\t\"is required\",\n\t\"must be a number\"\n]\n```\n\n\n\n### Errors Example\n\nIf a key name exists in the error response, then we can expect to see the key name\nin `related`.\n\n```json\n[\n\t{ \"message\": \"is required\", \"related\": []},\n\t{ \"message\": \"must be a number\", \"related\": []}\n]\n```\n\n### Handling errors without `related`\n\nGiven the following errors object\n\n```json\n[\n\t\"is required\",\n\t{\"message\": \"must be a number\"},\n\t{\"message\": \"must be a number\", \"related\": [\"zipCode\"]}\n]\n```\n\nBecause only one item in the array has a `related` property, the other two items\nwill be grouped together by assigning them the wildcard (`*`) key. Once processed,\nthe errors will look like\n\n```json\n[\n\t{\"message\": \"is required\", \"related\": [\"*\"]},\n\t{\"message\": \"must be a number\", \"related\": [\"*\"]},\n\t{\"message\": \"must be a number\", \"related\": [\"zipCode\"]}\n]\n```\n\n",
    "description": "\n",
    "title": "formatErrors",
    "name": "can-validate.formatErrors",
    "type": "function",
    "parent": "can-validate.methods",
    "signatures": [
      {
        "code": "formatErrors(errors, format)",
        "description": "\n  Processes `errors` (only items that match the [can-validate.errors] type) and\n  converts items to a structure defined by `format`.\n\n  ```js\n  formatErrors(['is required', {message: 'is invalid'}], 'errors');\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-validate.errors"
              }
            ],
            "name": "errors",
            "description": "A value that matches the [can-validate.errors] type."
          },
          {
            "types": [
              {
                "type": "string"
              }
            ],
            "optional": true,
            "name": "format",
            "description": "Should be equal to `object`, `flat`, or `errors`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The errors either flattened into a single array, grouped in\nby key in an object, or a single array of [can-validate.error] items. If no\n`format` is passed, errors will be returned in the raw parsed format.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "string"
        }
      ],
      "optional": true,
      "name": "format",
      "description": "Should be equal to `object`, `flat`, or `errors`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The errors either flattened into a single array, grouped in\nby key in an object, or a single array of [can-validate.error] items. If no\n`format` is passed, errors will be returned in the raw parsed format.\n"
    },
    "comment": " "
  },
  "can-validate-legacy.map-plugin": {
    "src": {
      "path": "node_modules/can-validate-legacy/docs/can-map-plugin.md"
    },
    "body": "\n## Initialization\nImport the validation library, validate plugin and a shim to immediately use the\ncan.Map.validate plugin.\n```js\nimport \"validatejs\";\nimport \"can-validate/map/validate\";\nimport \"can-validate/shims/validatejs.shim\";\n```\n\n## Usage\n\nUsing can-validate Map plugin only requires two extra actions,\n\n- add a validate object to the desired property\n- add a check in the view for the errors object\n\nThe validate object depends on the desired valdiation library. The examples\nbelow use ValidateJS.\n\n```js\nvar ViewModel = can.Map.extend({\n  define: {\n    name: {\n      value: \"\",\n      validate: {\n        required: true\n      }\n    }\n  }\n});\nvar viewModel = new ViewModel({});\nviewModel.validate();\n// `errors` will have an error because the `name` value is empty\n//  and required is true.\nviewModel.attr(\"errors\");\nviewModel.attr(\"name\", \"Juan\");\nviewModel.attr(\"errors\"); // => Errors is now empty!\n```\n\n## Demo\n\n<div class='demo_wrapper' data-demo-src='./can-validate/map/validate/demo.html'></div>\n\n",
    "description": "The can.Map plugin will works alongside can.Map.define to add validation to properties on a can.Map. Importing the plugin, validation library, and a shim will\nallow the ability to dynamically check values against validation configuration. errors\nare stored on the can.Map instance and are observable.\n\n",
    "title": "Map Plugin",
    "name": "can-validate-legacy.map-plugin",
    "type": "function",
    "parent": "can-validate-legacy",
    "comment": " "
  },
  "can-validate-legacy.core": {
    "src": {
      "path": "node_modules/can-validate-legacy/docs/can-validate-legacy-core.md"
    },
    "body": "\n## Initialization\n\n```javascript\nvar validate = require('can-validate-legacy');\n// Validation library\nrequire('validate.js');\n// Shim for library\nrequire('can-validate-legacy/shims/validatejs');\n```\n\nThe key initializing part is the shim. The shim will define how the can-validate methods\nbehave and will also define the necessary parameters.\n\n## Registering a Shim\n\nIf a new shim is needed, it must first be register itself with can-validate.\n\n<div class='demo_wrapper' data-demo-src='./demo/core-demo/demo.html'></div>\n\n",
    "description": "  Returns an object with helpful methods that will call a validation library to validate\n values.\n\n How each method behaves depends on the chosen shim and validation library.\n\n",
    "title": "Core",
    "name": "can-validate-legacy.core",
    "type": "function",
    "parent": "can-validate-legacy",
    "comment": " ",
    "signatures": [
      {
        "code": "validate.register(LIBRARY_NAME, MAP_OF_METHODS)",
        "description": "\n\nThe `MAP_OF_METHODS` consists of three methods that define the three main uses cases, validate many, validate one, and check one.\n\n## Demo\n",
        "params": []
      }
    ]
  },
  "can-validate-legacy.shims": {
    "name": "can-validate-legacy.shims",
    "title": "Shims",
    "type": "function",
    "parent": "can-validate-legacy",
    "description": "\nShims allow the flexibility of using any validation library with `can.validate`.\nCreating a shim requires just three methods, `isValid`, `once`, and `validate`.\nThe shim should also import the validation library itself. The shim then registers\nitself with can.validate and passes the methods object.\n",
    "order": 3,
    "src": {
      "path": "node_modules/can-validate-legacy/docs/shims.md"
    },
    "body": "\n## Available Shims\n\nThe original validations plugin for CanJS included a basic validation library, it\nwas ported over to can-validate as it's own library and can be used with can-validate\nusing it's shim.\n\nThere is also a shim for the popular library ValidateJS.\n\nMore libraries/shims may be added in the future but it is very easy to create a shim\nfor any library in your project.\n\n\n## Creating your own shim\n\nStart by extending can.Construct.\n\n```js\nvar Shim = can.Construct.extend({});\n```\n\nYou'll need `can` and your library, so let's add them...\n\n```js\nimport can from 'can';\nimport myLibrary from 'awesomeLibrary';\n\nvar Shim = can.Construct.extend({});\n```\n\nWe might as well register the shim now...\n\n```js\nimport can from 'can';\nimport myLibrary from 'awesomeLibrary';\n\nvar Shim = can.Construct.extend({});\n\ncan.validate.register('myLibrary', Shim);\n```\n\nSweet. Looks good so far. Now let's add the meat.\n\n```js\nimport can from 'can';\nimport myLibrary from 'awesomeLibrary';\n\nvar Shim = can.Construct.extend({\n\tisValid: function (value, options, name) {\n\t\treturn;\n\t},\n\tonce: function (value, options) {\n\t\treturn;\n\t},\n\tvalidate: function (values, options) {\n\t\treturn;\n\t}\n});\n\ncan.validate.register('myLibrary', Shim);\n```\n\nThis is all that is required. Not a lot of validation going on but the rest depends\non how your validation library works.\n\nYou may need to process the options or values a bit. You might even need to make\nsure the errors object is correct.\n\n**Remember, these methods should return `undefined` if no errors occurred. Otherwise,\nthey should return an array of errors.**\n\n"
  },
  "can-validate-legacy": {
    "src": {
      "path": "node_modules/can-validate-legacy/docs/can-validate-legacy.md"
    },
    "body": "\nCan-Validate can be used in two ways, in a can-map instance or standalone.\n\n## Usage\n\nThe module should require the following files\n\n```javascript\nimport 'can-validate-legacy';\nimport 'validate.js';\nimport 'can-validate-legacy/shims/validatejs.shim';\n```\nNow, can-validate can be used in two ways, either in a can-map or standalone.\n\n### Can-Map Plugin Usage\n\nUsing the plugin for can-map requires the can-map-define plugins as well.\n\n```javascript\nimport 'can-validate-legacy/map/validate';\nimport 'can/map/define/define';\n```\n\nAll can-maps created in the module will now have an augmented setter that checks properties as they are set.\n\n```javascript\nvar ViewModel = Map.extend({\n  define: {\n    name: {\n      value: '',\n      validate: {\n        required: true\n      }\n    }\n  }\n});\nvar viewModel = new ViewModel({});\n//\nviewModel.validate();\n// `errors` will have an error because the `name` value is empty\n//  and required is true.\nviewModel.attr('errors'); //> Returns the raw response from validation library\nviewModel.attr('name', 'Juan');\nviewModel.attr('errors'); // => Errors is now empty!\n```\n\n### Standalone Usage\n\nFirst, make sure the correct files are required.\n\n```javascript\n// can.validate is now available\nimport 'can-validate-legacy';\n// Substitute with your library of choice\nimport 'validate.js';\n// If not using ValidateJS, then you'll need a custom shim\nimport 'can-validate-legacy/shims/validatejs.shim';\n```\n\nNow, we can validate many or a single property. Let's start with the\nfollowing values and constraints:\n\n\n```javascript\nvar user = {\n\tfirstName: \"juan\",\n\tlastName: \"Orozco\"\n};\n\nvar constraints = {\n\tfirstName: {\n\t\trequired: true,\n\t\tformat: {\n\t\t\tpattern: /^[A-Z].*/,\n\t\t\tmessage: \"^ must be proper cased.\"\n\t\t}\n\t},\n\tlastName: {\n\t\trequired: true,\n\t\tformat: {\n\t\t\tpattern: /^[A-Z].*/,\n\t\t\tmessage: \"^ must be proper cased.\"\n\t\t}\n\t}\n};\n```\n\nTo validate many properties, just run...\n\n```javascript\nvar errors = validate.validate(user, constraints);\n```\n\nThe `once` method allows validating just a single value.\n\n```javascript\nvar errors = validate.once(user.firstName, constraints.firstName, 'firstName');\n```\n\n\n## Shims and Validation Libraries\n\nA shim registers a validation library with can-validate. It also processes properties and values into a structure more acceptable by the validation library. This allows consuming libraries to switch validation libraries simply by switching out their shim - any new behavior or legacy behavior can be baked into the new shim.\n\nDon't have a library of choice? Can.Validate ships with a shim for [ValidateJS](http://validatejs.org/).\n\n## Change Log\n\nA change log is maintained [here](changelog.html).\n\n## Contributing\n\nWant to contribute? [Read the contributing](contributing.html) guide to start.\n\n",
    "description": "A plugin for CanJS that wraps any validation library to `can.validate`. **Can-Validate doesn't do any validation of its own** but instead provides some abstraction to your library of choice. The chosen library is registered with can-validate using a shim.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nCan-Validate provides methods that can be used to validate values regardless of the validation library used.\n\n  ```js\n  var validate = require(\"can-validate-legacy\");\n  require(\"can-validate-legacy/shims/validatejs.shim\");\n\n  var user = {\n\t  firstName: \"juan\"\n  };\n\n  var constraints = {\n\t  firstName: {\n\t\t  required: true,\n\t\t  format: {\n\t\t\t  pattern: /^[A-Z].*/,\n      \t\t  message: \"^ must be proper cased.\"\n\t\t  }\n\t  }\n  };\n\n  var errors = validate.validate(user, constraints);\n  ```\n"
      }
    ],
    "name": "can-validate-legacy",
    "parent": "can-legacy",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": [
            "can-validate-legacy"
          ]
        },
        "parent": "can-validate-legacy"
      },
      "browser": {
        "./can-validate": "./dist/cjs/can-validate/can-validate",
        "./map/validate": "./dist/cjs/can-validate/map/validate/validate",
        "./validations": "./dist/cjs/can-validate/validations",
        "./shims/validatejs.shim": "./dist/cjs/can-validate/shims/validatejs.shim"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-validate-legacy/issues"
      },
      "dependencies": {
        "can-util": "^3.0.12",
        "validate.js": "^0.11.1"
      },
      "description": "Validation plugin for CanJS that provides an abstraction layer to your validation library of choice (Shim may be required).",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-compute": "^3.0.3",
        "can-map": "^3.0.2",
        "can-map-define": "^3.0.0",
        "can-stache": "^3.0.8",
        "done-serve": "^0.2.5",
        "jquery": "^3.1.1",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-stache": "^3.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "https://github.com/canjs/can-validate-legacy",
      "keywords": [
        "Validate",
        "plugin",
        "canjs"
      ],
      "license": "MIT",
      "main": "can-validate.js",
      "name": "can-validate-legacy",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-validate-legacy.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:pre": "npm version prerelease && npm run build && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "ignoreBrowser": true,
        "npmIgnore": [
          "documentjs",
          "testee",
          "steal-tools"
        ],
        "npmDependencies": [
          "steal-qunit"
        ],
        "paths": {
          "validate.js": "./node_modules/validate.js/validate.js"
        }
      },
      "version": "1.0.2"
    },
    "comment": " "
  },
  "can-validate-legacy.changelog": {
    "src": {
      "path": "node_modules/can-validate-legacy/docs/changelog.md"
    },
    "body": "\n### Changed\n\n- Restructured repository, main files live in root now; no `can-validate` subdirectory now.\n- Refactored tests to match CanJS standard of using QUnit.\n- Refactored codebase to match CanJS standard of using ES5.\n- Restructured Demos after repo changes\n- Updated dependencies to use CanJS 3.0 modules\n- Moved repository to `can-validate-legacy`. Original repository will continue but will soon change to match CanJS 3.0 patterns.\n- Updated docs to work with Bit-Docs\n\n## [0.9.2] - 2015-06-02\n\n### Changed\n\n- Cleaning up code after incorrect merge.\n\n## [0.9.1] - 2015-06-02\n\n### Changed\n\n- Fixed Validate all bug where some properties would not get properly validate when undefined in map instance.\n- Fixed overloading of validate list on validate all method.\n\n## [0.9.0] - 2015-06-01\n\n### Changed\n\n- [#26](https://github.com/canjs/can-validate/issues/26) Fixed bug that overwrote validate properties for all instances of a Map or Model. Computes are now cached to a dunder property versus overwriting the main `validate` property.\n- [#27](https://github.com/canjs/can-validate/issues/27) Fixed the `validate` method so it resolves computes. Computes are created from functions passed as validate options so validation can be triggered when compute change is triggered.\n- Improved validate init. Using a better method for detecting when Map is initing.\n\n## [0.8.4] - 2016-06-01\n\n### Added\n\n- Added tests for issue [#26](https://github.com/canjs/can-validate/issues/26)\n- Added tests for issue [#27](https://github.com/canjs/can-validate/issues/27)\n\n### Changed\n\n- Updated dependencies\n- Switched to Mocha\n- Improved tests\n\n## [0.8.3] - 2016-04-21\n\n### Changed\n\n- Fixed bug when errors was blank would cause console error\n\n## [0.8.2] - 2016-03-02\n\n### Changed\n\n- Improved handling of validation strings, passes strings through to Validate.JS.\n\n## [0.8.1] - 2016-02-03\n\n### Added\n\n- This change log\n- Contributing guide\n\n### Changed\n\n- Changed documentation root to `can-validate-plugin`, changed from `can-validate-library`.\n- Improved readme.\n- Improved overall documentation.\n\n### Removed\n\n- Removed CanJS Validations library documentation since it is still a WIP.\n\n## [0.8.0] - 2015-12-03\n\n### Changed\n- Fixed memory leaks.\n- Improved validate object compute handling.\n- Updated to work with CanJS 2.3.x.\n\n## [0.7.1] - 2015-11-23\n\n### Changed\n- Improved build.\n\n## [0.7.0] - 2015-10-19\n\n### Added\n- Added XO for linting.\n\n### Changed\n- Cleaned up lint errors in repo.\n\n## [0.6.0] - 2015-10-19\n\n### Added\n- Improved ability to pass functions to validation properties.\n\n### Changed\n- Fixed map init bug.\n\n## [0.5.2] - 2015-10-18\n\n### Changed\n- Fixed tests.\n- Fixed merge conflicts/errors.\n\n## [0.5.1] - 2015-10-01\n\n### Changed\n- Fixed require bug.\n\n## [0.5.0] - 2015-07-16\n\n### Added\n- Added \"validate all\" method to can.Map plugin\n\n## [0.4.2] - 2015-07-13\n\n### Added\n- Published to NPM\n\n## [0.4.1] - 2015-07-13\n\n### Added\n- Inline docs.\n- Added DocumentJS dependency.\n\n## [0.4.0] - 2015-07-10\n\n### Changed\n- Restructured repository.\n\n## [0.3.0] - 2015-07-10\n\n### Added\n- Browserify build.\n\n### Changed\n- Overall build improvements.\n\n## [0.2.0] - 2015-07-09\n\n### Changed\n- Made buildable. Using `import` over Steal syntax.\n\n## [0.1.0] - 2015-07-08\n\n### Added\n- Created can-validate entry point.\n- Created can.Map plugin.\n- Created ValidateJS shim\n\n\n[0.8.0]: https://github.com/canjs/can-validate/commit/0b98de198af17980174531146e43fb8c4b5e11a6\n[0.7.1]: https://github.com/canjs/can-validate/commit/2a58bf9ef280c2bb378221c6c18e85c7fed6daa3\n[0.7.0]: https://github.com/canjs/can-validate/commit/6be268da2a02e2985f71fa1f7196bfad94c84ca5\n[0.6.0]: https://github.com/canjs/can-validate/commit/0383d482353319a6eec3cf218daaa99b8ce62585\n[0.5.2]: https://github.com/canjs/can-validate/commit/17f46a11fb3f788e029359476bca83a67dca2b94\n[0.5.1]: https://github.com/canjs/can-validate/commit/5280c965df668b3eb1b95d10847f20676a3c5820\n[0.5.0]: https://github.com/canjs/can-validate/commit/53d965869263f39ea03dca97822fd5173cf62cdc\n[0.4.2]: https://github.com/canjs/can-validate/commit/608ee0cefdc161ecdf186980738952c86c937981\n[0.4.1]: https://github.com/canjs/can-validate/commit/c15d0b72bcc3e7343615d41baccbf3cf10242898\n[0.4.0]: https://github.com/canjs/can-validate/commit/a1d581aa31c304b04a7bdb4dc40106cf5c48771d\n[0.3.0]: https://github.com/canjs/can-validate/commit/4a7de30a12c27e7db992ac2bfcdb55e94e61c17a\n[0.2.0]: https://github.com/canjs/can-validate/commit/7ba46b1ea42315f68532f4246031d9bf074b785d\n[0.1.0]: https://github.com/canjs/can-validate/commit/b9a9aa2c43d672d9c238a506d788bafb3f89ee70\n\n",
    "description": "\n## UNRELEASED - 2016-11-23\n",
    "name": "can-validate-legacy.changelog",
    "title": "Changelog",
    "type": "page",
    "parent": "can-validate-legacy"
  },
  "validatejs-shim": {
    "src": {
      "path": "node_modules/can-validate-legacy/docs/validatejs-shim.md"
    },
    "body": "\nHello world\n\n\n## Initialization\nImport ValidateJS, validate plugin and this shim to immediately use the\nValidateJS in a CanJS project plugin.\n```js\nimport \"validatejs\";\nimport \"can-validate/can-validate\";\nimport \"can-validate/shims/validatejs.shim\";\n```\n\n## Usage\n\n",
    "description": " This shim requires ValidateJS in the consuming app's package.json. It processes\nthe passed in options so they can be properly used by the ValidateJS libarary.\n",
    "type": "module",
    "title": "ValidateJS Shim",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "validatejs-shim",
    "parent": "can-validate-legacy.shims",
    "comment": " ",
    "signatures": [
      {
        "code": "validate(MAP_OF_VALUES, MAP_OF_CONSTRAINTS)",
        "description": "\n\n```javascript\nvar errors = validate.validate(user, constraints);\n```\n\nValidate is a can.Construct that is set to can.validate. It is possible to create\nan instance for the purpose of storing errors in the instance. It is recommended\nto use can.Map, can.Map.define, and can.Map.validate instead.\n",
        "params": []
      },
      {
        "code": "once(VALUE, CONSTRAINTS, VALUE_NAME)",
        "description": "\n\n```javascript\nvar errors = validate.once(user.firstName, constraints.firstName, 'firstName');\n```",
        "params": []
      },
      {
        "code": "isValid(VALUE, CONSTRAINTS, VALUE_NAME)",
        "description": "\n\n```javascript\nvar errors = validate.once(user.firstName, constraints.firstName, 'firstName');\n```\n",
        "params": []
      }
    ]
  },
  "can-validate-validatejs.methods": {
    "name": "can-validate-validatejs.methods",
    "title": "Methods",
    "type": "group",
    "parent": "can-validate-validatejs",
    "description": "",
    "order": 1
  },
  "can-validate-validatejs": {
    "src": {
      "path": "node_modules/can-validate-validatejs/docs/can-validate-validatejs.md"
    },
    "body": "\n## Usage\n\nA validator can be created either for a single value or for many values.  More information on how to configure Validate.JS constraints can be found [here](https://validatejs.org/#validators).\n\n### Single value validation\n\nUsing the [Validate.js](https://validatejs.org/) library validators and configuration, call `makeValidator` and pass the desired constraints. The resulting function can then be used to validate specific values.\n\n```js\nvar makeValidator = require('can-validate-validatejs');\nvar validateAge = makeValidator({\n    numericality: true\n});\n\nvar age = 'hello';\nvalidateAge(age); //> ['is not a number']\n\nvar anotherAge = 35;\nvalidateAge(anotherAge); //> undefined\n```\n\n### Multiple value validation\n\nUsing the [can-validate-validatejs.many] works similar to `makeValidator`, except that `makeValidator.many` produces a validator that expects an object of values. The validator will run constraints on respective values based on the keys provided.\n\n```javascript\nvar makeValidator = require('can-validate-validatejs');\nvar validatePerson = makeValidator.many({\n    age: {\n        numericality: true\n    },\n    name: {\n        presence: true\n    }\n});\n\nvar invalidPerson = {\n    name: '',\n    age: 'hello'\n};\nvalidatePerson(invalidPerson); //> {name: ['is required'], age: ['is not a number']}\n\nvar validPerson = {\n    name: 'Juan',\n    age: 35\n};\nvalidatePerson(validPerson); //> undefined\n```\n\n",
    "description": "Create [can-validate.validator] functions using [validate.js](https://validatejs.org/). \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-validate-validatejs",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-validate-validatejs/issues"
      },
      "dependencies": {
        "can-util": "^3.2.2",
        "validate.js": "^0.11.1"
      },
      "description": "Create validator functions that use ValidateJS to validate values.",
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "http-server": "^0.9.0",
        "jshint": "^2.9.4",
        "steal": "^1.0.8",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.3.0"
      },
      "homepage": "https://github.com/canjs/can-validate-validatejs#readme",
      "keywords": [
        "Validate",
        "Validate.js",
        "can-validate",
        "plugin",
        "canjs"
      ],
      "license": "MIT",
      "main": "can-validate-validatejs.js",
      "name": "can-validate-validatejs",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-validate-validatejs.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "http-server -c-1",
        "jshint": "jshint .",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm run build && npm publish",
        "release:minor": "npm version minor && npm run build && npm publish",
        "release:patch": "npm version patch && npm run build && npm publish",
        "release:pre": "npm version prerelease && npm run build && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "ignoreBrowser": true,
        "npmIgnore": [
          "bit-docs",
          "testee",
          "steal-tools"
        ],
        "npmAlgorithm": "flat",
        "npmDependencies": [
          "steal-qunit"
        ],
        "paths": {
          "validate.js": "./node_modules/validate.js/validate.js"
        },
        "transpiler": "babel"
      },
      "version": "0.0.6"
    },
    "signatures": [
      {
        "code": "makeValidator(constraints)",
        "description": "\n\nReturns a validator function that can be used to validate a single value.\n\n  ```js\n  var validateAge = makeValidator({\n      numericality: true\n  });\n  ```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "constraints",
            "description": "An object of definitions used by the Validate.js library to run validations on a value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Validator"
            }
          ],
          "description": "A validator type function that takes a value and validates it against the provided constraints.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "constraints",
      "description": "An object of definitions used by the Validate.js library to run validations on a value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Validator"
        }
      ],
      "description": "A validator type function that takes a value and validates it against the provided constraints.\n"
    },
    "comment": " "
  },
  "can-validate-validatejs.many": {
    "src": {
      "path": "node_modules/can-validate-validatejs/docs/validate-many.md"
    },
    "body": "\n## Example\n\n  ```js\n  var makeValidator = require('can-validate-validatejs');\n  var validatePerson = makeValidator.many({\n      age: {\n          numericality: true\n      },\n      name: {\n          presence: true\n      }\n  });\n\n  var invalidPerson = {\n      name: '',\n      age: 'hello'\n  };\n  validatePerson(invalidPerson); //> {name: ['is required'], age: ['is not a number']}\n\n  var validPerson = {\n      name: 'Juan',\n      age: 35\n  };\n  validatePerson(validPerson); //> undefined\n  ```\n\n",
    "description": "\n",
    "title": "many",
    "name": "can-validate-validatejs.many",
    "type": "function",
    "parent": "can-validate-validatejs.methods",
    "signatures": [
      {
        "code": "makeValidator.many(constraints)",
        "description": "\n\n  Returns a validator function that can be used to validate many values at once.\n\n  ```js\n  var validatePerson = makeValidator.many({\n      age: {\n          numericality: true\n      },\n      name: {\n          presence: true\n      }\n  });\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "constraints",
            "description": "A map of objects which contain definitions used by the Validate.js library.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Validator"
            }
          ],
          "description": "A [can-validate.validator] type function that takes an object of values and validates every value based on the provided constraints.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "constraints",
      "description": "A map of objects which contain definitions used by the Validate.js library.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Validator"
        }
      ],
      "description": "A [can-validate.validator] type function that takes an object of values and validates every value based on the provided constraints.\n\n"
    },
    "comment": " "
  },
  "can-vdom.types.window": {
    "src": {
      "path": "node_modules/can-vdom/docs/window.md"
    },
    "body": "\n",
    "description": "\nAn object representing a fake `window` object.\n",
    "type": "typedef",
    "title": "window",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "document",
            "description": "A browser document\n",
            "types": [
              {
                "type": "can-simple-dom/document/document"
              }
            ]
          },
          {
            "name": "window",
            "description": "The window itself.\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "self",
            "description": "The `self` object is an alias for `window`.\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "addEventListener",
            "description": "A stub for `window.addEventListener`, does not actually set up events unless overridden some place else.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "removeEventListener",
            "description": "A stub for `window.removeEventListener`.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "navigator",
            "description": "\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "location",
            "description": "\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "history",
            "description": "\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can-vdom.types.window",
    "parent": "can-vdom.types"
  },
  "can-vdom/make-document/make-document": {
    "name": "can-vdom/make-document/make-document",
    "type": "module",
    "parent": "can-vdom.modules",
    "src": {
      "line": 0,
      "codeLine": 22,
      "path": "node_modules/can-vdom/make-document/make-document.js"
    },
    "body": "\n",
    "description": "\nExports a function that when called, returns a dom-light document object.\n",
    "title": "./make-document/make-document",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeDocument()",
        "description": "\n\n\nCreates a new simple document using [can-simple-dom]. Provides light-weight document needs,\nmostly for server-side rendering.\n\n```js\nvar makeDocument = require(\"can-vdom/make-document/make-document\");\nvar document = makeDocument();\n\ndocument.body //-> Node\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-simple-dom/document/document"
            }
          ],
          "description": "A can-simple-dom document.\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-simple-dom/document/document"
        }
      ],
      "description": "A can-simple-dom document.\n\n"
    }
  },
  "can-vdom/make-parser/": {
    "name": "can-vdom/make-parser/",
    "type": "module",
    "parent": "node_modules/can-vdom/make-parser/make-parser.js",
    "src": {
      "line": 0,
      "codeLine": 7,
      "path": "node_modules/can-vdom/make-parser/make-parser.js"
    },
    "body": "\n",
    "description": "\nReturns a function that can generate a HTML->TOKENs parser\ngiven a document.\n",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ]
  },
  "can-vdom/make-window/make-window": {
    "name": "can-vdom/make-window/make-window",
    "type": "module",
    "parent": "can-vdom.modules",
    "src": {
      "line": 0,
      "codeLine": 34,
      "path": "node_modules/can-vdom/make-window/make-window.js"
    },
    "body": "\n\n",
    "description": "\nExports a function that window called, returns an object that looks like a `window`.\n",
    "title": "./make-window/make-window",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeWindow()",
        "description": "\n\nCreates a document and places it, along with other common browser globals,\non a new object and then returns that object.\n\n```js\nvar makeWindow = require(\"can-vdom/make-window/make-window\");\nmakeWindow();\n\nwindow.document.body //-> Node\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-vdom.types.window"
            }
          ],
          "description": "An object with common browser globals.\n"
        }
      },
      {
        "code": "makeWindow(global)",
        "description": "\n\nCreates a document and places it, along with other common browser globals, on the `global` object.\n\n```js\nvar makeWindow = require(\"can-vdom/make-window/make-window\");\n\nvar window = makeWindow({});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-vdom.types.window"
              }
            ],
            "name": "global",
            "description": "An object that represents the environment's global."
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-vdom.types.window"
        }
      ],
      "description": "An object with common browser globals.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-vdom.types.window"
        }
      ],
      "name": "global",
      "description": "An object that represents the environment's global."
    }
  },
  "can-view-callbacks.attr": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/attr.md"
    },
    "body": "\n\n## Use\n\n`canViewCallbacks.attr` is used to add custom behavior to elements that contain a\nspecified html attribute. Typically it is used to mixin behavior (whereas\n[can-view-callbacks.tag] is used to define behavior).\n\nThe following example adds a jQueryUI tooltip to any element that has\na `tooltip` attribute like `<div tooltip=\"Click to edit\">Name</div>`.\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/tooltip.html'></div>\n\n## Listening to attribute changes\n\nIn the previous example, the content of the tooltip was static. However,\nit's likely that the tooltip's value might change. For instance, the template\nmight want to dynamically update the tooltip like:\n\n    <button tooltip=\"{{deleteTooltip}}\">\n      Delete\n    </button>\n\nWhere `deleteTooltip` changes depending on how many users are selected:\n\n    deleteTooltip: function(){\n      var selectedCount = selected.length;\n      if(selectedCount) {\n        return \"Delete \"+selectedCount+\" users\";\n      } else {\n        return \"Select users to delete them.\";\n      }\n    }\n\n\nThe [can-util/dom/events/attributes/attributes attributes] event can be used to listen to when\nthe toolip attribute changes its value like:\n\n```js\ncanViewCallbacks.attr(\"tooltip\", function( el, attrData ) {\n\t// A helper that updates or sets up the tooltip\n\tvar updateTooltip = function(){\n\t\t$(el).tooltip({\n\t\t\tcontent: el.getAttribute(\"tooltip\"),\n\t\t\titems: \"[tooltip]\"\n\t\t})\n\t}\n\t// When the tooltip attribute changes, update the tooltip\n\tdomEvents.addEventListener.call(el, \"attributes\", function(ev){\n\t\tif(ev.attributeName === \"tooltip\") {\n\t\t\tupdateTooltip();\n\t\t}\n\t});\n\t// Setup the tooltip\n\tupdateTooltip();\n\n});\n```\n\nTo see this behavior in the following demo, hover the mouse over the \"Delete\" button.  Then\nselect some users and hover over the \"Delete\" button again:\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/dynamic_tooltip.html'></div>\n\n\n## Reading values from the scope.\n\nIt's common that attribute mixins need complex, observable data to\nperform rich behavior. The attribute mixin is able to read\ndata from the element's [can.view.Scope scope]. For example,\n__toggle__ and __fade-in-when__ will need the value of `showing` in:\n\n    <button toggle=\"showing\">\n      {{#showing}}Show{{else}}Hide{{/showing}} more info</button>\n    <div fade-in-when=\"showing\">\n      Here is more info!\n    </div>\n\nThese values can be read from [can-view-callbacks.attrData]'s scope like:\n\n    attrData.scope.attr(\"showing\")\n\nBut often, you want to update scope value or listen when the scope value\nchanges. For example, the __toggle__ mixin might want to update `showing`\nand the __fade-in-when__ mixin needs to know when\nthe `showing` changes.  Both of these can be achived by\nusing [can-view-scope::compute compute] to get a get/set compute that is\ntied to the value in the scope:\n\n    var showing = attrData.scope.compute(\"showing\")\n\nThis value can be written to by `toggle`:\n\n\n    canViewCallbacks.attr(\"toggle\", function(el, attrData){\n\n      var attrValue = el.getAttribute(\"toggle\")\n          toggleCompute = attrData.scope.compute(attrValue);\n\n      $(el).click(function(){\n        toggleCompute(! toggleCompute() )\n      })\n\n    })\n\nOr listened to by `fade-in-when`:\n\n    canViewCallbacks.attr(\"fade-in-when\", function( el, attrData ) {\n      var attrValue = el.getAttribute(\"fade-in-when\");\n          fadeInCompute = attrData.scope.compute(attrValue),\n          handler = function(ev, newVal, oldVal){\n            if(newVal && !oldVal) {\n              $(el).fadeIn(\"slow\")\n            } else if(!newVal){\n              $(el).hide()\n            }\n          }\n\n      fadeInCompute.on(\"change\",handler);\n\n      ...\n    });\n\nWhen you listen to something other than the attribute's element, remember to\nunbind the event handler when the element is [can-util/dom/events/removed/removed removed] from the page:\n\n```js\ndomEvents.addEventListener.call(el,\"removed\", function(){\n\tfadeInCompute.off(handler);\n});\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/fade_in_when.html'></div>\n\n## When to call\n\n`canViewCallbacks.attr` must be called before a template is processed. When [using `can.view` to create a renderer function](http://canjs.com/docs/can.view.html#sig_can_view_idOrUrl_), `canViewCallbacks.attr` must be called before the template is loaded, not simply before it is rendered.\n\n\t\t//Call canViewCallbacks.attr first\n\t\tcanViewCallbacks.attr('tooltip', tooltipFunction);\n\t\t//Preload a template for rendering\n\t\tvar renderer = stache(\"<div tooltip='Hi There'>...</div>\");\n\t\t//No calls to canViewCallbacks.attr after this will be used by `renderer`\n\n",
    "description": "\nRegister custom behavior for an attribute.\n",
    "title": "attr",
    "name": "can-view-callbacks.attr",
    "type": "function",
    "parent": "can-view-callbacks/methods",
    "signatures": [
      {
        "code": "callbacks.attr(attributeName, attrHandler(el, attrData))",
        "description": "\n\nRegisters the `attrHandler` callback when `attributeName` is found\nin a template.\n\n```js\nvar canViewCallbacks = require(\"can-view-callbacks\");\n\ncanViewCallbacks.attr(\"show-when\", function(el, attrData){\n\tvar prop = el.getAttribute(\"show-when\");\n\tvar compute = attrData.compute(prop);\n\n\tvar showOrHide = function(){\n\t\tvar val = compute();\n\t\tif(val) {\n\t\t\tel.style.display = 'block';\n\t\t} else {\n\t\t\tel.style.display = 'hidden';\n\t\t}\n\t};\n\n\tcompute.on(\"change\", showOrHide);\n\tshowOrHide();\n\n\tdomEvents.addEventListener.call( el, \"removed\", function onremove(){\n\t\tcompute.off(\"change\", showOrHide);\n\t\tdomEvents.removeEventListener.call(\"removed\", onremove);\n\t});\n});\n```\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "RegExp"
              }
            ],
            "name": "attributeName",
            "description": "A lower-case attribute name or regular expression\nthat matches attribute names. Examples: `\"my-fill\"` or `/my-\\w/`.  \n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "HTMLElement"
                      }
                    ],
                    "name": "el"
                  },
                  {
                    "types": [
                      {
                        "type": "can-view-callbacks.attrData"
                      }
                    ],
                    "name": "attrData"
                  }
                ]
              }
            ],
            "name": "attrHandler",
            "description": "\nA function that adds custom behavior to `el`.  \n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ],
              "name": "el"
            },
            {
              "types": [
                {
                  "type": "can-view-callbacks.attrData"
                }
              ],
              "name": "attrData"
            }
          ]
        }
      ],
      "name": "attrHandler",
      "description": "\nA function that adds custom behavior to `el`.  \n"
    },
    "comment": " "
  },
  "can-view-callbacks.attrData": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/attrData.md"
    },
    "body": "\n",
    "description": "\nThe data provided to [can-view-callbacks.attr].\n",
    "type": "typedef",
    "title": "attrData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "scope",
            "description": "The scope of the element.\n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "The mustache helpers and other non-data values passed to the template.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          },
          {
            "name": "attributeName",
            "description": "The attribute name that was matched.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ],
        "description": "\n\n  ```js\n  var canViewCallbacks = require(\"can-view-callbacks\");\n  var stache = require(\"can-stache\");\n\n  canViewCallbacks.attr(\"my-attr\", function(el, attrData){\n    attrData.scope.peak(\"value\") //-> 123\n\tattrData.attributeName       //-> \"my-attr\"\n\n  });\n\n  stache(\"<div my-attr='value'/>\")({\n\t  value: 123\n  });\n  ```\n"
      }
    ],
    "name": "can-view-callbacks.attrData",
    "parent": "can-view-callbacks/types"
  },
  "can-view-callbacks/methods": {
    "name": "can-view-callbacks/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-view-callbacks",
    "description": "",
    "order": 0
  },
  "can-view-callbacks/types": {
    "name": "can-view-callbacks/types",
    "title": "types",
    "type": "group",
    "parent": "can-view-callbacks",
    "description": "",
    "order": 0
  },
  "can-view-callbacks": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/can-view-callbacks.md"
    },
    "body": "\nAllows registering callback functions that will be called when tags and attributes are rendered in [can-view-target].\n\n## Registering tags\n\n[can-view-callbacks.tag callbacks.tag] allows you to register a tag that custom behavior will be attached to.\n\nThis will style elements using the *blue-el* tag with a blue background.\n\n```js\nvar callbacks = require(\"can-view-callbacks\");\n\ncallbacks.tag(\"blue-el\", function(el){\n\tel.style.background = \"blue\";\n});\n```\n\n```html\n<blue-el><p>Some content with a blue background, gross!</p></blue-el>\n```\n\n## Registering attributes\n\nSimilarly you can register a callback for an attribute. Here we are using a regular expression to match an attribute that starts with `foo-`:\n\n```js\ncallbacks.attr(/foo-[\\w\\.]+/, function(el, attrData){\n\t// Get the part after foo-\n\tvar attrValue = attrData.attributeName.substr(4);\n\n\t// Set it's content\n\tel.textContent = attrValue;\n});\n```\n\nSo that:\n\n```html\n<div foo-bar></div>\n```\n\nRenders as:\n\n```html\n<div foo-bar>bar</div>\n```\n\n",
    "description": "Registered callbacks for behaviors \n",
    "type": "module",
    "title": "can-view-callbacks",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-callbacks",
    "parent": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./doc/apis.json"
        },
        "parent": "can-view-callbacks"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-callbacks/issues"
      },
      "dependencies": {
        "can-namespace": "1.0.0",
        "can-observation": "^3.0.1",
        "can-util": "^3.0.1"
      },
      "description": "Registered callbacks for behaviors",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-callbacks",
      "name": "can-view-callbacks",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-callbacks.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "configDependencies": [
          "live-reload"
        ]
      },
      "version": "3.0.6"
    },
    "comment": " "
  },
  "can-view-callbacks.tag": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/tag.md"
    },
    "body": "\n\n## Use\n\n`canViewCallbacks.tag` is a low-level way to add custom behavior to custom elements. Often, you\nwant to do this with [can-component]. However, [can-view-callbacks.tag callbacks.tag] is\nuseful for when [can-component] might be considered overkill.  For example, the\nfollowing creates a [jQueryUI DatePicker](http://api.jqueryui.com/datepicker/) everytime a\n`<jqui-datepicker>` element is found:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker()\n    })\n\n\nThe `tagHandler`'s [can-view-callbacks.tagData] argument is an object\nthat contains the stache [can-view-scope Scope] and helper [can-view-scope.Options]\nwhere `el` is found and a [can-stache.renderer subtemplate] that renders the contents of the\ntemplate within the custom tag.\n\n## Getting values from the template\n\n`tagData.scope` can be used to read data from the template.  For example, if I wanted\nthe value of `\"format\"` within the current template, it could be read like:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker({format: tagData.scope.get(\"format\")})\n    })\n\n    var template = mustache(\"<jqui-datepicker></jqui-datepicker>\")\n    template({format: \"mm/dd/yy\"})\n\n`tagData.options` contains the helpers and partials provided\nto the template.  A helper function might need to be called to get the current value of format like:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker({format: tagData.options.get(\"helpers.format\")()})\n    })\n\n    var template = mustache(\"<jqui-datepicker></jqui-datepicker>\")\n    template({},{format: function(){\n      return \"mm/dd/yy\"\n    }})\n\n## Responding to changing data\n\nOften, data passed to a template is observable.  If you use [can-view-callbacks.tag], you must\nlisten and respond to chagnes yourself.  Consider if format is property on a\n`settings` [can.Map] like:\n\n    var settings = new Map({\n      format: \"mm/dd/yy\"\n    })\n\nYou want to update the datepicker if `format` changes.  The easiest way to do this\nis to use [can-view-scope::compute Scope's compute] method which returns a get-set\ncompute that is tied to a key value:\n\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n\n      var formatCompute = tagData.scope.compute(\"format\"),\n          changeHandler = function(ev, newVal){\n            $(el).datepicker(\"option\",\"format\", newVal});\n          }\n\n      formatCompute.bind(\"change\",changeHandler)\n\n      changeHandler({}, formatCompute());\n\n      ...\n\n    })\n\n    var template = mustache(\"<jqui-datepicker/>\")\n    template(settings)\n\nIf you listen on something outside the tag, it's a good practice to stop listening\nwhen the element is [can-util/dom/events/removed/removed removed] from the page:\n\n\tdomEvents.addEventListener.call( el, \"removed\", function onremove(){\n\t\tcompute.off(\"change\", showOrHide);\n\t\tformatCompute.unbind(\"change\",changeHandler)\n\t});\n\n\n## Subtemplate\n\nIf content is found within a custom tag like:\n\n    var template = stache(\n      \"<my-form>\\\n         <input value=\"{{first}}\"/>\\\n         <input value=\"{{last}}\"/>\\\n       </my-form>\")\n\nA separate template function is compiled and passed\nas `tagData.subtemplate`.  That subtemplate can\nbe rendered with custom data and options. For example:\n\n    callbacks.tag(\"my-form\", function(el, tagData){\n       var frag = tagData.subtemplate({\n         first: \"Justin\"\n       }, tagData.options)\n\n       $(el).html( frag )\n    })\n\n    template({\n      last: \"Meyer\"\n    })\n\n\nIn this case, the sub-template will not get a value for `last`.  To\ninclude the original data in the subtemplate's scope, [can-view-scope::add] to\nthe old scope like:\n\n    callbacks.tag(\"my-form\", function(el, tagData){\n       var frag = tagData.subtemplate(\n         tagData.scope.add({ first: \"Justin\" }),\n         tagData.options)\n\n       $(el).html( frag )\n    })\n\n    template({\n      last: \"Meyer\"\n    })\n\n",
    "description": "\n",
    "title": "tag",
    "name": "can-view-callbacks.tag",
    "type": "function",
    "parent": "can-view-callbacks/methods",
    "signatures": [
      {
        "code": "callbacks.tag(tagName, tagHandler(el, tagData))",
        "description": "\n\nRegisters the `tagHandler` callback when `tagName` is found\nin a template.\n\n```js\nvar $ = require(\"jquery\");\nrequire(\"jquery-datepicker\");\nvar canViewCallbacks = require(\"can-view-callbacks\");\n\ncanViewCallbacks.tag(\"date-picker\", function(el, tagData){\n\t$(el).datePicker();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "A lower-case, hypenated or colon-seperated html\ntag. Example: `\"my-widget\"` or `\"my:widget\"`.  It is considered a best-practice to\nhave a hypen or colon in all custom-tag names.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "can.view.Scope"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "HTMLElement"
                      }
                    ],
                    "name": "el"
                  },
                  {
                    "types": [
                      {
                        "type": "can.view.tagData"
                      }
                    ],
                    "name": "tagData"
                  }
                ]
              }
            ],
            "name": "tagHandler",
            "description": "\n\nAdds custom behavior to `el`.  If `tagHandler` returns data, it is used to\nrender `tagData.subtemplate` and the result is inserted as the childNodes of `el`.\n"
          }
        ],
        "release": "2.1"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "can.view.Scope"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ],
              "name": "el"
            },
            {
              "types": [
                {
                  "type": "can.view.tagData"
                }
              ],
              "name": "tagData"
            }
          ]
        }
      ],
      "name": "tagHandler",
      "description": "\n\nAdds custom behavior to `el`.  If `tagHandler` returns data, it is used to\nrender `tagData.subtemplate` and the result is inserted as the childNodes of `el`.\n"
    },
    "comment": " "
  },
  "can-view-callbacks.tagData": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/tagData.md"
    },
    "body": "\n",
    "description": "\nThe data passed to [can-view-callbacks.tag].\n",
    "type": "typedef",
    "title": "tagData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "subtemplate",
            "description": "If the special tag has content,\nthe content can be rendered with subtemplate.  For example:\n\n```js\ncallbacks.tag(\"foo-bar\", function(el, tagData){\n  var frag = tagData.subtemplate(tagData.scope, tagData.options);\n  $(el).html(frag);\n});\n```\n",
            "types": [
              {
                "type": "can-stache.renderer"
              }
            ],
            "optional": true
          },
          {
            "name": "scope",
            "description": "The scope of the element.  \n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "The mustache helpers and other non-data values passed to the template.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          }
        ],
        "description": "\n"
      }
    ],
    "name": "can-view-callbacks.tagData",
    "parent": "can-view-callbacks/types"
  },
  "can-view-import.can-tag": {
    "src": {
      "path": "node_modules/can-view-import/docs/can-tag.md"
    },
    "body": "\n## Use\n\n**can-tag** allows a component to be injected using the imported promise as the\ninjected component’s view model.\n\nThe example below shows a loading graphic until the cart component has been loaded.\nOnce the cart promise is resolved, `<shopping-cart></shopping-cart>` is injected\ninto the page.\n\nFor example, here’s a `loading-indicator` component:\n\n```\nvar template = stache('{{#isResolved}}<content/>{{else}}<img src=\"loading.gif\"/>{{/isResolved}}');\n\nComponent.extend({\n  tag: \"loading-indicator\",\n  view: template\n});\n```\n\nHere’s how `can-tag` can be used to show the loading indicator before the `shopping-cart` component is imported:\n\n```\n<can-import from=\"cart\" can-tag=\"loading-indicator\">\n  <shopping-cart></shopping-cart>\n</can-import>\n```\n\n",
    "description": "Use another [can-view-callbacks.tag] (such as a [can-component]) to control the `<content>` of a [can-view-import].  \n",
    "title": "can-tag",
    "name": "can-view-import.can-tag",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "can-tag=\"TAG_NAME\"",
        "description": "\n\nInstantiates the provided [can-view-callbacks.tag] and sets its [can-component.prototype.view-model viewModel] to be the Promise for the import.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "TAG_NAME",
            "description": "The tag name (usually a [can-component]) to use.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "TAG_NAME",
      "description": "The tag name (usually a [can-component]) to use.\n"
    },
    "comment": " "
  },
  "can-view-import.pages": {
    "name": "can-view-import.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-view-import",
    "description": "",
    "order": 0
  },
  "can-view-import.attributes": {
    "name": "can-view-import.attributes",
    "title": "Attributes",
    "type": "group",
    "parent": "can-view-import",
    "description": "",
    "order": 1
  },
  "can-view-import": {
    "src": {
      "path": "node_modules/can-view-import/docs/can-view-import.md"
    },
    "body": "\n## Use\n\nA template might depend on component or helper modules. `<can-import>` allows\nyou to specify these dependencies.\n\nExample:\n\n```\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\nCurrently this __only__ works with [can-view-autorender] or the [steal-stache] plugin.\n\n## Progressive Loading\n\nA template may (conditionally) load a module after the initial page load. `<can-import>` allows progressive loading by using an end tag.\n\nThis example shows a component being loaded ad hoc:\n\n```\n<can-import from=\"components/home\"></can-import>\n```\n\nThis example illustrates conditionally loading modules based on some application state:\n\n```\n{{#eq location 'home'}}\n  <can-import from=\"components/home\">\n    ...\n  </can-import>\n{{/eq}}\n\n{{#eq location 'away'}}\n  <can-import from=\"components/away\">\n    ...\n  </can-import>\n{{/eq}}\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-view-import",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-import",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": [
            {
              "can-view-import": [
                "can-view-import.from",
                "can-view-import.can-tag",
                "can-view-import.value"
              ]
            }
          ]
        },
        "parent": "can-view-import"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-import/issues"
      },
      "dependencies": {
        "can-event": "^3.0.1",
        "can-stache": "^3.0.1",
        "can-util": "^3.2.0",
        "can-view-callbacks": "^3.0.0",
        "can-view-nodelist": "^3.0.0",
        "steal-stache": "^3.0.0"
      },
      "description": "Import dependencies in CanJS views",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-component": "^3.0.0",
        "can-compute": "^3.0.0",
        "can-map": "^3.0.0",
        "can-stache": "^3.0.0",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.4",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.0",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "homepage": "https://canjs.com",
      "keywords": [],
      "main": "can-view-import",
      "name": "can-view-import",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-import.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.0.7"
    },
    "signatures": [
      {
        "code": "<can-import from=\"MODULE_NAME\" />",
        "description": "\n\nStatically import a module from within a [can-stache] template. *MODULE_NAME* will be imported before the template renders.\n\n```\n<can-import from=\"components/tabs\" />\n<tabs-widget />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "optional": true,
            "name": "MODULE_NAME",
            "description": "A module that this template depends on.\n"
          }
        ]
      },
      {
        "code": "<can-import from=\"MODULE_NAME\">content</can-import>",
        "description": "\n\nDynamically import *MODULE_NAME*; the scope within the template is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```\n<can-import from=\"components/tabs\">\n  {{#if isResolved}}\n    <tabs-widget />\n  {{/if}}\n</can-import>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "optional": true,
            "name": "MODULE_NAME",
            "description": "A module that this template depends on.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "moduleName"
        }
      ],
      "optional": true,
      "name": "MODULE_NAME",
      "description": "A module that this template depends on.\n"
    },
    "comment": " "
  },
  "can-view-import.pages.dynamic": {
    "src": {
      "path": "node_modules/can-view-import/docs/dynamic.md"
    },
    "body": "\nTo make your import be loaded dynamically it *cannot* be self closing (i.e. `/>`) but rather it must have a closing tag (i.e. `</can-import>`).\n\n### Example\n\nThese `can-import` and Steal import examples are equivalent:\n\n```\n<can-import from=\"components/foobar\">\n  {{#if isResolved}}\n    <foobar/>\n  {{/if}}\n</can-import>\n```\n\n```\nsteal.import('components/foobar').then(function(foobar) {\n // access to the module you loaded.\n // e.g. access to a component's ViewModel \n // foobar.ViewModel\n});\n```\n\n__Note:__ when dynamically importing modules in a stache file, the scope inside [can-view-import <can-import>] is a Promise, so you have to wait until it is resolved before injecting something like a [can-component]. Use the `{{#if isResolved}}` helper to determine whether the Promise has been resolved.\n",
    "description": "\nDynamic imports are used in conditional situations such as within an [can-stache.helpers.if] to prevent unnecessarily fetching resources that might not be needed in all cases.\n",
    "name": "can-view-import.pages.dynamic",
    "title": "Dynamic Imports",
    "type": "page",
    "parent": "can-view-import.pages"
  },
  "can-view-import.from": {
    "src": {
      "path": "node_modules/can-view-import/docs/from.md"
    },
    "body": "",
    "description": "Set the module name that will be imported into the template. \n",
    "title": "from",
    "name": "can-view-import.from",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "from=\"MODULE_NAME\"",
        "description": "\n\nPasses MODULE_NAME to [can-util/js/import/import] and sets the [can-view-import <can-import>]'s viewModel to be the returned Promise.\n\n```js\n<can-import from=\"bootstrap/bootstrap.css\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "MODULE_NAME",
            "description": "The name of the module to import.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "MODULE_NAME",
      "description": "The name of the module to import.\n"
    }
  },
  "can-view-import.pages.static": {
    "src": {
      "path": "node_modules/can-view-import/docs/static.md"
    },
    "body": "\nTo make your import be static, it *must* be self closing like `/>`.\n\n## Example\n\nThese `can-import` and ES6 import examples are equivalent:\n\n```\n<can-import from=\"mymodule\" />\n```\n\n```\nimport from \"mymodule\";\n```\n\n",
    "description": "\nStatic imports reflect direct dependencies of the template. Most uses of [can-view-import] will be for static imports.\n",
    "name": "can-view-import.pages.static",
    "title": "Static Imports",
    "type": "page",
    "parent": "can-view-import.pages"
  },
  "can-view-import.value": {
    "src": {
      "path": "node_modules/can-view-import/docs/value.md"
    },
    "body": "",
    "description": "Set the value that is returned from the [can-view-import can-import] Promise to a [can-stache-bindings.reference reference scope] variable. \n",
    "title": "{^value}",
    "name": "can-view-import.value",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "{^value}=\"*NAME\"",
        "description": "\n\nSets up a [can-stache-bindings.toParent] binding to \\*NAME in the references scope.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "NAME",
            "description": "The variable name to assign to the references scope. This can be any string name you want to use, but must be preceded by `*` or it will be placed on the template's View Model.\n\n```html\n<can-import from=\"app/person\" {^value}=\"*person\" />\n\t\n<section>\n\thello {{*person.name}}\n</section>\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "NAME",
      "description": "The variable name to assign to the references scope. This can be any string name you want to use, but must be preceded by `*` or it will be placed on the template's View Model.\n\n```html\n<can-import from=\"app/person\" {^value}=\"*person\" />\n\t\n<section>\n\thello {{*person.name}}\n</section>\n```\n"
    }
  },
  "can-view-live.attr": {
    "type": "function",
    "name": "can-view-live.attr",
    "parent": "can-view-live",
    "src": {
      "line": 2,
      "codeLine": 21,
      "path": "node_modules/can-view-live/lib/attr.js"
    },
    "body": "",
    "description": "\n",
    "title": "attr",
    "signatures": [
      {
        "code": "live.attr(el, attributeName, compute)",
        "description": "\n\nKeep an attribute live to a [can-compute].\n\n```js\nvar div = document.createElement('div');\nvar compute = canCompute(\"foo bar\");\nlive.attr(div,\"class\", compute);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "The element whos attribute will be kept live."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attributeName",
            "description": "The attribute name."
          },
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "The compute.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "compute",
      "description": "The compute.\n\n"
    }
  },
  "can-view-live": {
    "name": "can-view-live",
    "type": "module",
    "parent": "can-infrastructure",
    "src": {
      "line": 11,
      "codeLine": 40,
      "path": "node_modules/can-view-live/lib/core.js"
    },
    "body": "\n\n\n## Use\n\n [can-view-live] is an object with utility methods for setting up\n live-binding in relation to different parts of the DOM and DOM elements.  For\n example, to make an `<h2>`'s text stay live with\n a compute:\n\n  var live = require(\"can-view-live\");\n  var text = canCompute(\"Hello World\");\n  var textNode = $(\"h2\").text(\" \")[0].childNodes[0];\n  live.text(textNode, text);\n\n\n\n",
    "description": "\nSetup live-binding between the DOM and a compute manually.\n",
    "title": "can-view-live",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "An",
            "description": "object with the live-binding methods:\n[can-view-live.html], [can-view-live.list], [can-view-live.text], and\n[can-view-live.attr].\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-view-live"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-live/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-event": "^3.0.1",
        "can-types": "^1.0.1",
        "can-util": "^3.1.1",
        "can-view-callbacks": "^3.0.0",
        "can-view-nodelist": "^3.0.1",
        "can-view-parser": "^3.0.0",
        "can-view-target": "^3.0.0"
      },
      "description": "[![Build Status](https://travis-ci.org/canjs/can-view-live.png?branch=master)](https://travis-ci.org/canjs/can-view-live)",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-list": "^3.0.1",
        "can-map": "^3.0.3",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.2.10",
        "steal-qunit": "^1.0.1",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "CanJS",
        "DoneJS"
      ],
      "main": "can-view-live",
      "name": "can-view-live",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-live.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-view-live",
        "configDependencies": [
          "live-reload"
        ],
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.7"
    },
    "release": "2.0.4",
    "comment": " "
  },
  "can.view.live.replace": {
    "type": "function",
    "name": "can.view.live.replace",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "HTMLElement"
                  }
                ]
              }
            ]
          }
        ],
        "name": "nodes",
        "description": "An array of elements.  There should typically be one element."
      },
      {
        "types": [
          {
            "type": "String"
          },
          {
            "type": "HTMLElement"
          },
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "val",
        "description": "The content that should replace\n`nodes`.  If a string is passed, it will be [can.view.hookup hookedup].\n"
      },
      {
        "types": [
          {
            "type": "function",
            "returns": {
              "types": [
                {
                  "type": "undefined"
                }
              ]
            },
            "params": []
          }
        ],
        "optional": true,
        "name": "teardown",
        "description": "A callback if these elements are torn down.\n "
      }
    ],
    "parent": "can.view.live",
    "src": {
      "line": 125,
      "codeLine": 139,
      "path": "node_modules/can-view-live/lib/core.js"
    },
    "body": "\n",
    "description": "\nReplaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\ncorrect.\n",
    "title": "",
    "release": "2.0.4",
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "teardown",
      "description": "A callback if these elements are torn down.\n "
    }
  },
  "can-view-live.html": {
    "type": "function",
    "name": "can-view-live.html",
    "parent": "can-view-live",
    "src": {
      "line": 6,
      "codeLine": 38,
      "path": "node_modules/can-view-live/lib/html.js"
    },
    "body": "\n",
    "description": "\nLive binds a compute's value to a collection of elements.\n",
    "title": "html",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.html(el, compute, [parentNode])",
        "description": "\n\n`live.html` is used to setup incremental live-binding on a block of html.\n\n```js\n// a compute that changes its list\nvar greeting = compute(function(){\n  return \"Welcome <i>\"+me.attr(\"name\")+\"</i>\"\n});\n\nvar placeholder = document.createTextNode(\" \");\n$(\"#greeting\").append(placeholder);\n\nlive.html(placeholder, greeting);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "An html element to replace with the live-section.\n"
          },
          {
            "types": [
              {
                "type": "can.compute"
              }
            ],
            "name": "compute",
            "description": "A [can.compute] whose value is HTML.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "optional": true,
            "name": "parentNode",
            "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "optional": true,
      "name": "parentNode",
      "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
    }
  },
  "can-view-live.list": {
    "type": "function",
    "name": "can-view-live.list",
    "parent": "can-view-live",
    "src": {
      "line": 83,
      "codeLine": 123,
      "path": "node_modules/can-view-live/lib/list.js"
    },
    "body": "",
    "description": "\n",
    "title": "list",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.list(el, list, render, context, [parentNode])",
        "description": "\n\nLive binds a compute's list incrementally.\n\n```js\n// a compute that change's it's list\nvar todos = compute(function(){\n  return new Todo.List({page: can.route.attr(\"page\")})\n})\n\nvar placeholder = document.createTextNode(\" \");\n$(\"ul#todos\").append(placeholder);\n\ncan.view.live.list(\n  placeholder,\n  todos,\n  function(todo, index){\n    return \"<li>\"+todo.attr(\"name\")+\"</li>\"\n  });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "An html element to replace with the live-section.\n"
          },
          {
            "types": [
              {
                "type": "can-compute"
              },
              {
                "type": "can-list"
              },
              {
                "type": "can-define/list/list"
              }
            ],
            "name": "list",
            "description": "An observable list type.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "String"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ],
                    "name": "index"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "render",
            "description": "A function that when called with\nthe incremental item to render and the index of the item in the list.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "The `this` the `render` function will be called with.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "optional": true,
            "name": "parentNode",
            "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "optional": true,
      "name": "parentNode",
      "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
    }
  },
  "can-view-live.text": {
    "type": "function",
    "name": "can-view-live.text",
    "parent": "can-view-live",
    "src": {
      "line": 3,
      "codeLine": 12,
      "path": "node_modules/can-view-live/lib/text.js"
    },
    "body": "",
    "description": "\n",
    "title": "text",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.text(el, compute, [parentNode], [nodeList])",
        "description": "\n\nReplaces one element with some content while keeping [can-view-live.nodeLists nodeLists] data correct.\n",
        "params": []
      }
    ]
  },
  "can-view-nodelist/types/NodeList": {
    "src": {
      "path": "node_modules/can-view-nodelist/doc/NodeList.md"
    },
    "body": "\n",
    "description": "\nA collection of nodes being managed by a part of a live-bound template and\nreferences to other collections.\n",
    "type": "typedef",
    "title": "NodeList",
    "types": [
      {
        "type": "Array",
        "options": [],
        "description": "\n\n  A `NodeList` is an array of nodes that a part of a live-bound template manages.  For\n  example `{{name}}` might manage a single text node while something\n  like `{{#each todos}}{{name}}{{/each}}` might manage multiple nodes and other child.\n\n  NodeLists are primarily used to teardown live binding.  When a \"parent\" section of a template\n  is updated, every sub-section needs to be torn down.  NodeLists provide this structure.\n\n  __NOTE: The structure of a NodeList is purposefully not documented as it's subject to change.__\n"
      }
    ],
    "name": "can-view-nodelist/types/NodeList",
    "parent": "can-view-nodelist/types"
  },
  "can-view-parser.ParseHandler.attrStart": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrStart.md"
    },
    "body": "",
    "description": "",
    "title": "attrStart",
    "name": "can-view-parser.ParseHandler.attrStart",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "attrStart(attrName)",
        "description": "\n\nCalled when an attribute is found on an element.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "The name of the attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The name of the attribute.\n"
    }
  },
  "can-view-parser.ParseHandler.attrEnd": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrEnd.md"
    },
    "body": "",
    "description": "",
    "title": "attrEnd",
    "name": "can-view-parser.ParseHandler.attrEnd",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "attrEnd(attrName)",
        "description": "\n\nCalled at the end of parsing an attribute; after the [can-view-parser.ParserHandler.attrStart] and [can-view-parser.ParserHandler.attrValue] functions have been called.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "The name of the attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The name of the attribute.\n"
    }
  },
  "can-view-parser.ParseHandler.attrValue": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrValue.md"
    },
    "body": "",
    "description": "",
    "title": "attrValue",
    "name": "can-view-parser.ParseHandler.attrValue",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "attrValue(value)",
        "description": "\n\nCalled when an attribute's **value** has been found.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The value discovered associated with an attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The value discovered associated with an attribute.\n"
    }
  },
  "can-view-parser": {
    "src": {
      "path": "node_modules/can-view-parser/docs/can-view-parser.md"
    },
    "body": "",
    "description": "Parse HTML and mustache tokens. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-parser",
    "parent": "can-infrastructure",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-view-parser"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-parser/issues"
      },
      "dependencies": {
        "can-namespace": "1.0.0",
        "can-util": "^3.1.1"
      },
      "description": "Parses html and magic tags",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-parser",
      "name": "can-view-parser",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-parser.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.1.0"
    },
    "signatures": [
      {
        "code": "parse(html, handler, [returnIntermediate])",
        "description": "\n\nParse an html string:\n\n```js\nvar parser = require(\"can-view-parser\");\n\nvar html = '<h1><span bob=\"phillips\"></span><span bob=\"meyers\"></span>' +\n\t'</h1>';\n\nvar bobs = {};\nvar curAttr;\n\nparser(html, {\n\tattrStart: function(attrName){\n\t\tcurAttr = attrName;\n\t},\n\tattrValue: function(value){\n\t\tbobs[curAttr] = value;\n\t}\n});\n\nfor(var first in bobs) {\n\tvar last = bobs[first];\n\tconsole.log(\"Hello\", first, last);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "html",
            "description": "A mustache and html string to parse or an intermediate object the represents a previous parsing."
          },
          {
            "types": [
              {
                "type": "can-view-parser.ParseHandler"
              }
            ],
            "name": "handler",
            "description": "An object of callbacks."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "returnIntermediate",
            "defaultValue": "false",
            "description": "If true, returns a JS object representation of the parsing.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "returnIntermediate",
      "defaultValue": "false",
      "description": "If true, returns a JS object representation of the parsing.\n"
    }
  },
  "can-view-parser.ParseHandler.chars": {
    "src": {
      "path": "node_modules/can-view-parser/docs/chars.md"
    },
    "body": "",
    "description": "",
    "title": "chars",
    "name": "can-view-parser.ParseHandler.chars",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "chars(value)",
        "description": "\n\nCalled when [CharacterData](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData) is found within a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The character data within the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The character data within the tag.\n"
    }
  },
  "can-view-parser.ParseHandler.close": {
    "src": {
      "path": "node_modules/can-view-parser/docs/close.md"
    },
    "body": "",
    "description": "",
    "title": "close",
    "name": "can-view-parser.ParseHandler.close",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "close(tagName)",
        "description": "\n\nCalled when a closing tag is found. If no closing tag exists for this tag (because it is self-closing) this function will not be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "tagName",
      "description": "The name of the tag.\n"
    }
  },
  "can-view-parser.ParseHandler.comment": {
    "src": {
      "path": "node_modules/can-view-parser/docs/comment.md"
    },
    "body": "",
    "description": "",
    "title": "comment",
    "name": "can-view-parser.ParseHandler.comment",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "comment(value)",
        "description": "\n\nCalled when a [Comment](https://developer.mozilla.org/en-US/docs/Web/API/Comment) is found within a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The Comment within the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The Comment within the tag.\n"
    }
  },
  "can-view-parser.ParseHandler.done": {
    "src": {
      "path": "node_modules/can-view-parser/docs/done.md"
    },
    "body": "",
    "description": "",
    "title": "done",
    "name": "can-view-parser.ParseHandler.done",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "done()",
        "description": "\n\nCalled at the end of parsing the template.\n",
        "params": []
      }
    ]
  },
  "can-view-parser.ParseHandler.end": {
    "src": {
      "path": "node_modules/can-view-parser/docs/end.md"
    },
    "body": "",
    "description": "",
    "title": "end",
    "name": "can-view-parser.ParseHandler.end",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "end(tagName, unary)",
        "description": "\n\nCalled at the end of parsing a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "unary",
            "description": "If this tag is unary (has no closing tag).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "unary",
      "description": "If this tag is unary (has no closing tag).\n"
    }
  },
  "can-view-parser.ParseHandler.magicMatch": {
    "src": {
      "path": "node_modules/can-view-parser/docs/magicMatch.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "RegExp",
        "description": "\n\nA regular expression that matches from the start of the magic tag to the end of the\nmagic tag.  It should also have the first capture group match the content within the\nmagic tag.  \n\n```js\nparser(\" ... content ....\", {\n\t...\n\tmagicStart: \"{\",\n\tmagicMatch:  /\\{([^\\}]*)\\}/g\n});\n```\n"
      }
    ],
    "title": "magicMatch",
    "name": "can-view-parser.ParseHandler.magicMatch",
    "type": "property",
    "parent": "can-view-parser.ParseHandler"
  },
  "can-view-parser.ParseHandler.magicStart": {
    "src": {
      "path": "node_modules/can-view-parser/docs/magicStart.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "String",
        "description": "\n\nThe starting characters of a magic tag.\n\n```js\nparser(\" ... content ....\", {\n\t...\n\tmagicStart: \"{\",\n\tmagicMatch:  /\\{([^\\}]*)\\}/g\n});\n```\n"
      }
    ],
    "title": "magicStart",
    "name": "can-view-parser.ParseHandler.magicStart",
    "type": "property",
    "parent": "can-view-parser.ParseHandler"
  },
  "can-view-parser.ParseHandler": {
    "src": {
      "path": "node_modules/can-view-parser/docs/parse-handler.md"
    },
    "body": "",
    "description": "An object consisting of callback functions that handle stages in the parsing process and settings that configure the parsing process.\n\n",
    "type": "typedef",
    "title": "ParseHandler",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-parser.ParseHandler",
    "parent": "can-view-parser"
  },
  "can-view-parser.ParseHandler.start": {
    "src": {
      "path": "node_modules/can-view-parser/docs/start.md"
    },
    "body": "",
    "description": "",
    "title": "start",
    "name": "can-view-parser.ParseHandler.start",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "start(tagName, unary)",
        "description": "\n\nCalled when parsing a tag begins.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "unary",
            "description": "If this tag is unary (has no closing tag).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "unary",
      "description": "If this tag is unary (has no closing tag).\n"
    }
  },
  "can-view-scope.attr": {
    "src": {
      "path": "node_modules/can-view-scope/docs/attr.md"
    },
    "body": "\n## Use\n\n`scope.attr(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.attr(\"name\"); //-> \"Justin\"\n    curScope.attr(\"length\"); //-> 2\n\nPrefixing a key with `\"./\"` prevents any parent scope look ups.\nPrefixing a key with one or more `\"../\"` shifts the lookup path\nthat many levels up.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}];\n    list.name = \"Programmers\";\n    list.surname = \"CanJS\";\n\n    var justin = list[0];\n    var brian = list[1];\n    var curScope = new Scope(list).add(justin).add(brian);\n\n    curScope.attr(\"name\"); //-> \"Brian\"\n    curScope.attr(\"surname\"); //-> \"CanJS\"\n    curScope.attr(\"./surname\"); //-> undefined\n    curScope.attr(\"../name\"); //-> \"Justin\"\n    curScope.attr(\"../surname\"); //-> \"CanJS\"\n    curScope.attr(\".././surname\"); //-> \"undefined\"\n    curScope.attr(\"../../name\"); //-> \"Programmers\"\n\n",
    "description": "\n",
    "title": "attr",
    "name": "can-view-scope.attr",
    "type": "function",
    "signatures": [
      {
        "code": "scope.attr(key)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-mustache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.static": {
    "name": "can-view-scope.static",
    "title": "static",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope.prototype": {
    "name": "can-view-scope.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope.types": {
    "name": "can-view-scope.types",
    "title": "types",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope": {
    "src": {
      "path": "node_modules/can-view-scope/docs/can-view-scope.md"
    },
    "body": "\n## Use\n\nA [can-view-scope] represents a lookup context and parent contexts\nthat can be used to lookup a [can-stache.key key] value.\n\nIf no parent scope is provided, only the scope's context will be\nexplored for values.  For example:\n\n    var data = {name: {first: \"Justin\"}},\n    \tscope = new Scope(data);\n\n    scope.get(\"name.first\") //-> \"Justin\"\n    scope.get(\"length\")     //-> undefined\n\nHowever, if a `parent` scope is provided, key values will be\nsearched in the parent's context after the initial context is explored.  For example:\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n    \tjustin = list[0];\n\n    var listScope = new Scope(list),\n    \tcurScope = new Scope(justin, listScope)\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\nUse [can-view-scope::add add] to easily create a new scope from a parent scope like:\n\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n    \tjustin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\n",
    "description": "Create a lookup node for [can-mustache.key keys]. \n\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-scope",
    "parent": "can-infrastructure",
    "inherits": "can",
    "test": "can/view/scope/test.html",
    "package": {
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-view-scope"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-scope/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-construct": "^3.0.0",
        "can-list": "^3.0.0",
        "can-namespace": "1.0.0",
        "can-observation": "^3.0.1",
        "can-simple-map": "^3.0.0",
        "can-types": "^1.0.1",
        "can-util": "^3.2.2"
      },
      "description": "Observable scopes",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^1.0.1",
        "can-map": "^3.0.0",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^1.0.1",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.0",
        "testee": "^0.3.0"
      },
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-scope",
      "name": "can-view-scope",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-scope.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "version": "3.1.4"
    },
    "signatures": [
      {
        "code": "new Scope(context, [parent], [meta] )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "A value that represents the\ncurrent context. This is often an object or observable and is the first\nplace a `key` is looked up.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope"
              }
            ],
            "optional": true,
            "name": "parent",
            "description": "The parent scope. If a `key` value\nis not found in the current scope, it will then look in the parent\nscope.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope/Meta"
              }
            ],
            "optional": true,
            "name": "meta",
            "description": "A configuration object that\ncan specify special behavior of the context.\n"
          }
        ],
        "release": "2.0.1",
        "returns": {
          "types": [
            {
              "type": "can-view-scope"
            }
          ],
          "description": "Returns a scope instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope/Meta"
        }
      ],
      "optional": true,
      "name": "meta",
      "description": "A configuration object that\ncan specify special behavior of the context.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-view-scope"
        }
      ],
      "description": "Returns a scope instance.\n"
    },
    "comment": " "
  },
  "can-view-scope.compute": {
    "src": {
      "path": "node_modules/can-view-scope/docs/compute.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "compute",
    "name": "can-view-scope.compute",
    "type": "function",
    "signatures": [
      {
        "code": "scope.compute(key, [options])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope.readOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options that configure how the `key` gets read.\n"
          }
        ],
        "release": "2.1",
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute that can get or set `key`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope.readOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options that configure how the `key` gets read.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute that can get or set `key`.\n"
    }
  },
  "can-view-scope.computeData": {
    "src": {
      "path": "node_modules/can-view-scope/docs/compute_data.md"
    },
    "body": "\n## Use\n\n`scope.computeData(key, options)` is used heavily by [can-mustache] to get the value of\na [can-mustache.key key] value in a template. Configure how it reads values in the\nscope and what values it returns with the [can-view-scope.readOptions options] argument.\n\n    var context = new Map({\n      name: {first: \"Curtis\"}\n    })\n    var scope = new Scope(context)\n    var computeData = scope.computeData(\"name.first\");\n\n    computeData.scope === scope //-> true\n    computeData.initialValue    //-> \"Curtis\"\n    computeData.compute()       //-> \"Curtis\"\n\nThe `compute` value is writable.  For example:\n\n    computeData.compute(\"Andy\")\n    context.attr(\"name.first\") //-> \"Andy\"\n\n",
    "description": "\n",
    "title": "computeData",
    "name": "can-view-scope.computeData",
    "type": "function",
    "signatures": [
      {
        "code": "scope.computeData(key)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope.readOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options that configure how the `key` gets read.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": [
                {
                  "name": "compute",
                  "description": "A compute that returns the\nvalue of `key` looked up in the scope's context or parent context. This compute can\nalso be written to, which will set the observable attribute or compute value at the\nlocation represented by the key.\n",
                  "types": [
                    {
                      "type": "can-compute.computed"
                    }
                  ]
                },
                {
                  "name": "scope",
                  "description": "The scope the key was found within. The key might have\nbeen found in a parent scope.\n",
                  "types": [
                    {
                      "type": "can-view-scope"
                    }
                  ]
                },
                {
                  "name": "initialData",
                  "description": "The initial value at the key's location.\n",
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An object with the following values:\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope.readOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options that configure how the `key` gets read.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "compute",
              "description": "A compute that returns the\nvalue of `key` looked up in the scope's context or parent context. This compute can\nalso be written to, which will set the observable attribute or compute value at the\nlocation represented by the key.\n",
              "types": [
                {
                  "type": "can-compute.computed"
                }
              ]
            },
            {
              "name": "scope",
              "description": "The scope the key was found within. The key might have\nbeen found in a parent scope.\n",
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "name": "initialData",
              "description": "The initial value at the key's location.\n",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An object with the following values:\n"
    },
    "types": [],
    "comment": " "
  },
  "can-view-scope.prototype.add": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.add.md"
    },
    "body": "\n## Use\n\n`scope.add(context)` creates a new scope object that\nfirst looks up values in context and then in the\nparent `scope` object.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\n",
    "description": "\n",
    "title": "add",
    "name": "can-view-scope.prototype.add",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.add(context [,meta])",
        "description": "\n\nCreates a new scope and sets the current scope to be the parent.\n\n```js\nvar scope = new Scope([\n   {name:\"Chris\"},\n   {name: \"Justin\"}\n]).add({name: \"Brian\"});\nscope.get(\"name\") //-> \"Brian\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "The context to add on top of the current scope."
          },
          {
            "types": [
              {
                "type": "can-view-scope/Meta"
              }
            ],
            "name": "meta",
            "description": "A meta option that can be used to configure special behaviors of this context.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope/Meta"
        }
      ],
      "name": "meta",
      "description": "A meta option that can be used to configure special behaviors of this context.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.compute": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.compute.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "compute",
    "name": "can-view-scope.prototype.compute",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.compute(key [, options])",
        "description": "\n\nGet a compute that is two-way bound to the `key` value in the scope. These computes\ncan be optimized beyond wrapping a compute around a call to [can-view-scope::get].\n\n```js\nscope.compute(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.get": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.get.md"
    },
    "body": "\n## Use\n\n`scope.get(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\"); //-> \"Justin\"\n    curScope.get(\"length\"); //-> 2\n\nPrefixing a key with `\"./\"` prevents any parent scope look ups.\nPrefixing a key with one or more `\"../\"` shifts the lookup path\nthat many levels up.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}];\n    list.name = \"Programmers\";\n    list.surname = \"CanJS\";\n\n    var justin = list[0];\n    var brian = list[1];\n    var curScope = new Scope(list).add(justin).add(brian);\n\n    curScope.get(\"name\"); //-> \"Brian\"\n    curScope.get(\"surname\"); //-> \"CanJS\"\n    curScope.get(\"./surname\"); //-> undefined\n    curScope.get(\"../name\"); //-> \"Justin\"\n    curScope.get(\"../surname\"); //-> \"CanJS\"\n    curScope.get(\".././surname\"); //-> \"undefined\"\n    curScope.get(\"../../name\"); //-> \"Programmers\"\n\n",
    "description": "\n",
    "title": "get",
    "name": "can-view-scope.prototype.get",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.get(key [, options])",
        "description": "\n\nWalks up the scope to find a value at `key`.  Stops at the first context where `key` has\na value.\n\n```js\nscope.get(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.peek": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.peek.md"
    },
    "body": "\n\n## Use\n\n`scope.peek(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.peek(\"name\"); //-> \"Justin\"\n    curScope.peek(\"length\"); //-> 2\n\n",
    "description": "\nRead a value from the scope without being observable.\n",
    "title": "peek",
    "name": "can-view-scope.prototype.peek",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.peek(key [, options])",
        "description": "\n\nWorks just like [can-view-scope.prototype.get], but prevents any calls to [can-observation.add].\n\n\nWalks up the scope to find a value at `key`.  Stops at the first context where `key` has\na value.\n\n```js\nscope.peek(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.set": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.set.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "set",
    "name": "can-view-scope.prototype.set",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.set(key, value [, options])",
        "description": "\n\nTries to set `key` in the scope to `value`.  This looks for the first context in the value where\n`key` can be set.  For example, if `key` is `\"person.first.name\"`, it will find the first\ncontext where `person.first` is some type of Object whose `name` property can be set.\n\n```js\nscope.set(\"person.first.name\", \"Justin\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to be set.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value to be set.\n"
    },
    "comment": " "
  },
  "can-view-scope.Options": {
    "src": {
      "path": "node_modules/can-view-scope/docs/static.Options.md"
    },
    "body": "\nA Scope that can be used to lookup stache helpers.\n\n",
    "description": "\n",
    "title": "Options",
    "name": "can-view-scope.Options",
    "type": "function",
    "parent": "can-view-scope.static"
  },
  "can-view-scope.Refs": {
    "src": {
      "path": "node_modules/can-view-scope/docs/static.Refs.md"
    },
    "body": "",
    "description": "\n",
    "title": "Refs",
    "name": "can-view-scope.Refs",
    "type": "function",
    "parent": "can-view-scope.static",
    "hide": true
  },
  "can-view-scope/Meta": {
    "src": {
      "path": "node_modules/can-view-scope/docs/types.Meta.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "Meta",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "notContext",
            "description": "The context should not be reference-able with `./` or `../`.\n",
            "types": [
              {
                "type": "Boolean"
              }
            ]
          }
        ],
        "description": "\n\n  Specify special behavior of a scope.\n\n"
      }
    ],
    "name": "can-view-scope/Meta",
    "parent": "can-view-scope.types"
  },
  "can-zone.ZoneSpec": {
    "src": {
      "path": "node_modules/can-zone/docs/ZoneSpec.md"
    },
    "body": "",
    "description": " A ZoneSpec is the way you tap into the lifecycle hooks of a [can-zone Zone]. The hooks are described below.\n\nUsing these hooks you can do things like create timers and override global variables that will change the *shape* of code that runs within the Zone.\n\n",
    "type": "typedef",
    "title": "ZoneSpec",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "created",
            "description": "\n\nCalled when the zone is first created, after all ZoneSpecs have been parsed. this is useful if you need to do setup behavior that covers the entire zone lifecycle.\n\n```js\nnew Zone({\n\tcreated: function(){\n\t\t// Called as soon as `new Zone` is called\n\t}\n});\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "beforeRun",
            "description": "\n\nCalled immediately before the **Zone.prototype.run** function is called.\n\n```js\nvar zone = new Zone({\n\tbeforeRun: function(){\n\t\t// Setup that needs to happen immediately before running\n\t\t// the zone function\n\t}\n});\n\nzone.run(function() { ... });\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "beforeTask",
            "description": "\n\nCalled before each Task is called. Use this to override any globals you want to exist during the execution of the task:\n\n```js\nnew Zone({\n\tbeforeTask: function(){\n\t\twindow.setTimeout = mySpecialSetTimeout;\n\t}\n});\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "ended",
            "description": "\n\nCalled when the Zone has ended and is about to exit (it's Promise will resolve).\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "hooks",
            "description": "\n\n**hooks** allows you to specify custom hooks that your plugin calls. This is mostly to communicate between plugins that inherit each other.\n\n```js\nvar barZone = {\n\tcreated: function(){\n\t\tthis.execHook(\"beforeBar\");\n\t},\n\n\thooks: [\"beforeBar\"]\n};\n\nvar fooZone = {\n\tbeforeBar: function(){\n\t\t// Called!\n\t},\n\tplugins: [barZone]\n};\n\nnew Zone({\n\tplugins: [fooZone]\n});\n\nzone.run(function() { ... });\n```\n",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "string"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "name": "plugins",
            "description": "\n\nAllows specifying nested [can-zone.ZoneSpec ZoneSpecs] that the current depends on. This allows creating rich plugins that depend on other plugins (ZoneSpecs). You can imagine having a bunch of tiny plugins that do one thing and then composing them together into one meta-plugin that is more end-user friendly.\n\nSimilar to the [can-zone Zone] constructor you can either specify [can-zone.ZoneSpec] objects or functions that return ZoneSpec objects. The former gives you a closure specific to the Zone, which is often needed for variables. These two forms are equivalent:\n\n```js\nvar specOne = {\n\tcreated: function(){\n\n\t}\n};\n\nvar specTwo = function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t}\n};\n\nvar zone = new Zone({\n\tplugins: [ specOne, specTwo ]\n});\n```\n",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-zone.ZoneSpec"
                      },
                      {
                        "type": "can-zone.makeZoneSpec"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone.ZoneSpec",
    "parent": "can-zone.types"
  },
  "can-zone.prototype.addWait": {
    "src": {
      "path": "node_modules/can-zone/docs/addWait.md"
    },
    "body": "",
    "description": "\n",
    "title": "addWait",
    "name": "can-zone.prototype.addWait",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.addWait()",
        "description": "\n\nAdds a wait to the [can-zone Zone]. Adding a wait will delay the Zone's Promise from resolving (the promise created by calling [can-zone.prototype.run zone.run]) by incrementing its internal counter.\n\nUsually a corresponding [can-zone.prototype.removeWait] will be called to decrement the counter.\n\n```js\nnew Zone().run(function(){\n\n\tvar zone = Zone.current;\n\n\tzone.addWait(); // counter at 1\n\tzone.removeWait(); // counter at 0, Promise resolves\n\n}).then(function(){\n\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.static": {
    "name": "can-zone.static",
    "title": "static",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.prototype": {
    "name": "can-zone.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.types": {
    "name": "can-zone.types",
    "title": "types",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.modules": {
    "name": "can-zone.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.plugins": {
    "name": "can-zone.plugins",
    "title": "plugins",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone": {
    "src": {
      "path": "node_modules/can-zone/docs/can-zone.md"
    },
    "body": "\n## Use\n\n**can-zone** is a library that aids in tracking asynchronous calls in your application. To create a new Zone call it's constructor function with `new`:\n\n```js\nvar zone = new Zone();\n```\n\nThis gives you a [can-zone Zone] from which you can run code using [can-zone.prototype.run zone.run]:\n\n```js\nzone.run(function(){\n\n\tsetTimeout(function(){\n\n\t}, 500);\n\n})\nthen(function(){\n\n});\n```\n\nThe function you provide to [can-zone.prototype.run] will be run within the Zone. This means any calls to asynchronous functions (in this example `setTimeout`)\twill be waited on.\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "readme": {
          "apis": "./docs/apis.json"
        },
        "parent": "can-view-live"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-zone/issues"
      },
      "description": "Asynchronous render for all frameworks",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "chai": "^3.4.1",
        "mocha": "^3.2.0",
        "steal": "^1.2.10",
        "steal-mocha": "^1.0.0",
        "steal-tools": "^1.1.2",
        "testee": "^0.3.1"
      },
      "homepage": "https://github.com/canjs/can-zone#readme",
      "keywords": [
        "server-side",
        "rendering",
        "canjs",
        "asynchronous",
        "rendering"
      ],
      "license": "MIT",
      "main": "lib/zone.js",
      "name": "can-zone",
      "repository": {
        "type": "git",
        "url": "git+ssh://git@github.com/canjs/can-zone.git"
      },
      "scripts": {
        "build": "node scripts/build.js",
        "document": "bit-docs",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run test:node && npm run test:browser && npm run test:xss",
        "test:browser": "testee test/test.html test/register.html --browsers firefox --reporter Spec",
        "test:node": "mocha test/test.js && mocha test/test_register_node.js",
        "test:xss": "mocha test/xss/test.js",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "npmDependencies": [
          "steal-mocha",
          "mocha",
          "chai"
        ],
        "map": {
          "./assert": "chai/chai"
        },
        "meta": {
          "chai/chai": {
            "format": "global",
            "exports": "chai.assert"
          }
        },
        "plugins": [
          "chai"
        ]
      },
      "version": "0.6.7"
    },
    "signatures": [
      {
        "code": "new Zone()",
        "description": "\n\nCreates a new Zone with no additional overrides. Can then call [can-zone.prototype.run zone.run] to call a function within the Zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar zone = new Zone();\n\nzone.run(function(){\n\n\treturn \"hello world\";\n\n}).then(function(data){\n\tdata.result // -> \"hello world\"\n});\n```\n",
        "params": []
      },
      {
        "code": "new Zone(zoneSpec)",
        "description": "\n\nCreate a new Zone using the provided [can-zone.ZoneSpec] to configure the Zone. The following examples configures a Zone that will time out after 5 seconds.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar timeoutSpec = function(){\n\tvar timeoutId;\n\n\treturn {\n\t\tcreated: function(){\n\t\t\ttimeoutId = setTimeout(function(){\n\t\t\t\tZone.error(new Error(\"This took too long!\"));\n\t\t\t}, 5000);\n\t\t},\n\t\tended: function(){\n\t\t\tclearTimeout(timeoutId);\n\t\t}\n\t};\n};\n\nvar zone = new Zone(timeoutSpec);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-zone.ZoneSpec"
              },
              {
                "type": "can-zone.makeZoneSpec"
              }
            ],
            "name": "zoneSpec",
            "description": "A [can-zone.ZoneSpec] object or a [can-zone.makeZoneSpec function that returns] a ZoneSpec object.\n\nThese two are equivalent:\n\n```js\nnew Zone({\n\tcreated: function(){\n\n\t}\n});\n\nnew Zone(function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t};\n});\n```\n\nThe latter form is useful so that you have a closure specific to that [can-zone Zone].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        },
        {
          "type": "can-zone.makeZoneSpec"
        }
      ],
      "name": "zoneSpec",
      "description": "A [can-zone.ZoneSpec] object or a [can-zone.makeZoneSpec function that returns] a ZoneSpec object.\n\nThese two are equivalent:\n\n```js\nnew Zone({\n\tcreated: function(){\n\n\t}\n});\n\nnew Zone(function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t};\n});\n```\n\nThe latter form is useful so that you have a closure specific to that [can-zone Zone].\n"
    },
    "comment": " "
  },
  "can-zone.current": {
    "src": {
      "path": "node_modules/can-zone/docs/current.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "can-zone"
      }
    ],
    "title": "current",
    "name": "can-zone.current",
    "type": "property",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.current",
        "description": "\n\nRepresents the currently running [can-zone zone]. If the code using **Zone.current** is not running within a zone the value will be undefined.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar myZone = new Zone();\n\nmyZone.run(function(){\n\n\tZone.current === myZone;\n\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.prototype.data": {
    "src": {
      "path": "node_modules/can-zone/docs/data.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "data",
    "name": "can-zone.prototype.data",
    "type": "property",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.data",
        "description": "\n\nYou might want to get data back from can-zone, for example if you are using the library to track asynchronous rendering requests. Each zone contains a **data** object which can be used to store artibitrary values.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"http://example.com\");\nxhr.onload = function(){\n\t// Save this data for later\n\tZone.current.data.xhr = xhr.responseText;\n};\nxhr.send();\n```\n\n",
        "params": []
      }
    ]
  },
  "can-zone.error": {
    "src": {
      "path": "node_modules/can-zone/docs/error.md"
    },
    "body": "",
    "description": "\n",
    "title": "error",
    "name": "can-zone.error",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.error(err)",
        "description": "\n\nAllows you to add an error to the currently running zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\n\tsetTimeout(function(){\n\t\tZone.error(new Error(\"oh no\"));\n\t}, 100);\n\n}).then(null, function(error){\n\terror; // -> {message: \"oh no\"}\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Error"
              }
            ],
            "name": "err",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Error"
        }
      ],
      "name": "err",
      "description": "\n"
    }
  },
  "can-zone.ignore": {
    "src": {
      "path": "node_modules/can-zone/docs/ignore.md"
    },
    "body": "\n## Use\n\n**Zone.ignore** is used to prevent a function from being waited on within a Zone. Normally a Zone's calls to functions like `setTimeout` and `XMLHttpRequest` are waited on before the [can-zone.prototype.run run promise] is resolved, but in some cases you might not want to wait on these calls; for example if there is a very long delay or a delay that will not result in rendering to take place.\n\nProvide Zone.ignore a function and it will return a function that can be called in it's place.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar fn = Zone.ignore(function(){\n\t// do any asynchronous stuff here\n});\n\nfn(); // waits ignored\n```\n\n",
    "description": "\n",
    "title": "ignore",
    "name": "can-zone.ignore",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.ignore(fn)",
        "description": "\n\nCreates a function that, when called, will not track any calls. This might be needed if you are calling code that does unusual things, like using setTimeout recursively indefinitely.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\tfunction recursive(){\n\t\tsetTimeout(function(){\n\t\t\trecursive();\n\t\t}, 20000);\n\t}\n\n\tvar fn = Zone.ignore(recursive);\n\n\t// This call will not be waited on.\n\tfn();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "A function that contains calls to asynchronous functions that are needing to be ignored.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function in which calls to [can-zone.prototype.addWait] and [can-zone.prototype.removeWait] will be ignored, preventing the Zone's promise from remaining unresolved while asynchronous activity continues within.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "A function that contains calls to asynchronous functions that are needing to be ignored.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function in which calls to [can-zone.prototype.addWait] and [can-zone.prototype.removeWait] will be ignored, preventing the Zone's promise from remaining unresolved while asynchronous activity continues within.\n"
    },
    "comment": " "
  },
  "can-zone.makeZoneSpec": {
    "src": {
      "path": "node_modules/can-zone/docs/makeZoneSpec.md"
    },
    "body": "\nUsing a function rather than a ZoneSpec object gives you a closure where you can store local variables that will be specific to the [can-zone Zone] you are running in.\n\n",
    "description": "\nA function that returns a [can-zone.ZoneSpec] object. This can be used any place where a [can-zone.ZoneSpec] is accepted.\n",
    "type": "typedef",
    "title": "makeZoneSpec",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "can-zone.ZoneSpec"
            }
          ],
          "description": "A [can-zone.ZoneSpec]\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-zone.prototype.data"
              }
            ],
            "name": "data",
            "description": "The [can-zone Zone's] data object, useful when you want to append data to the Zone.\n\nThis examples wraps [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to keep count of how many elements are created, and appends the count to [can-zone.prototype.data] when the Zone ends.\n\n```js\nvar mySpec = function(data){\n\tvar realCreateElement,\n\t\tcount = 0;\n\n\treturn {\n\t\tbeforeTask: function(){\n\t\t\trealCreateElement = document.createElement;\n\t\t\tdocument.createElement = function(){\n\t\t\t\tcount++;\n\t\t\t\treturn realCreateElement.apply(this, arguments);\n\t\t\t};\n\t\t},\n\t\tafterTask: function(){\n\t\t\tdocument.createElement = realCreateElement;\n\t\t},\n\t\tended: function(){\n\t\t\tdata.elementsCreated = count;\n\t\t}\n\t};\n};\n\nvar zone = new Zone(mySpec);\n\nzone.run(function(){\n\t// Do stuff here\n})\n.then(function(data){\n\tdata.elementsCreated; // -> 5\n});\n```\n"
          }
        ]
      }
    ],
    "name": "can-zone.makeZoneSpec",
    "parent": "can-zone.types",
    "_curParam": {
      "types": [
        {
          "type": "can-zone.prototype.data"
        }
      ],
      "name": "data",
      "description": "The [can-zone Zone's] data object, useful when you want to append data to the Zone.\n\nThis examples wraps [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to keep count of how many elements are created, and appends the count to [can-zone.prototype.data] when the Zone ends.\n\n```js\nvar mySpec = function(data){\n\tvar realCreateElement,\n\t\tcount = 0;\n\n\treturn {\n\t\tbeforeTask: function(){\n\t\t\trealCreateElement = document.createElement;\n\t\t\tdocument.createElement = function(){\n\t\t\t\tcount++;\n\t\t\t\treturn realCreateElement.apply(this, arguments);\n\t\t\t};\n\t\t},\n\t\tafterTask: function(){\n\t\t\tdocument.createElement = realCreateElement;\n\t\t},\n\t\tended: function(){\n\t\t\tdata.elementsCreated = count;\n\t\t}\n\t};\n};\n\nvar zone = new Zone(mySpec);\n\nzone.run(function(){\n\t// Do stuff here\n})\n.then(function(data){\n\tdata.elementsCreated; // -> 5\n});\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        }
      ],
      "description": "A [can-zone.ZoneSpec]\n"
    }
  },
  "can-zone/register": {
    "src": {
      "path": "node_modules/can-zone/docs/register.md"
    },
    "body": "",
    "description": " \nIn order to do it's magic, [can-zone] has to register handlers for all of the common JavaScript async operations. If you have code (or a dependency with this code) that does:\n\n```js\nvar st = setTimeout;\n```\n\nAnd this module loads before can-zone, any time `st` is used we won't be able to track that within the Zone.\n\nTo work around this, **can-zone/register** is used as a script that you run before any other modules.\n\n### In Node\n\n```js\nrequire(\"can-zone/register\");\n```\n\nAt the top of your entry-point script.\n\n### In the Browser\n\nYou can either add a script tag above all others:\n\n```js\n<script src=\"node_modules/can-zone/register.js\"></script>\n```\n\nOr, if you're using a module loader / bundler, configure it so that can-zone/register is placed above all others in the bundle.\n\n",
    "type": "module",
    "title": "can-zone/register",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone/register",
    "parent": "can-zone.modules"
  },
  "can-zone.prototype.removeWait": {
    "src": {
      "path": "node_modules/can-zone/docs/removeWait.md"
    },
    "body": "",
    "description": "\n",
    "title": "removeWait",
    "name": "can-zone.prototype.removeWait",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.removeWait()",
        "description": "\n\nDecrements the [can-zone Zone's] internal counter that is used to decide when its [can-zone.prototype.run run Promise] will resolve.\n\nUsually used in conjuction with [can-zone.prototype.addWait]. Most of the time you'll want to use [can-zone.waitFor], but in some cases where a callback is not enough to know waiting is complete, using addWait/removeWait gives you finer grained control.\n\n```js\nvar zone = new Zone();\n\nvar obj = new SomeObject();\n\n// This is only done when the event.status is 3\nobj.onprogress = function(ev){\n\tif(ev.status === 3) {\n\t\tzone.removeWait();\n\t}\n};\n\nzone.addWait();\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.prototype.run": {
    "src": {
      "path": "node_modules/can-zone/docs/run.md"
    },
    "body": "",
    "description": "\n",
    "title": "run",
    "name": "can-zone.prototype.run",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.run(fn)",
        "description": "\n\nRuns a function within a [can-zone Zone]. Calling run will set the Zone's internal Promise which will only resolve once all asynchronous calls within `fn` are complete.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "Any function which needs to run within the Zone. The function will be executed immediately.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-zone.prototype.data"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that will resolve with the Zone's [can-zone.prototype.data] object.\n\n```js\nvar zone = new Zone();\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\t\tzone.data.foo = \"bar\";\n\t});\n\n}).then(function(data){\n\tdata.foo // -> \"bar\"\n});\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "Any function which needs to run within the Zone. The function will be executed immediately.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-zone.prototype.data"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that will resolve with the Zone's [can-zone.prototype.data] object.\n\n```js\nvar zone = new Zone();\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\t\tzone.data.foo = \"bar\";\n\t});\n\n}).then(function(data){\n\tdata.foo // -> \"bar\"\n});\n```\n"
    }
  },
  "can-zone.waitFor": {
    "src": {
      "path": "node_modules/can-zone/docs/waitFor.md"
    },
    "body": "",
    "description": "\n",
    "title": "waitFor",
    "name": "can-zone.waitFor",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.waitFor(fn)",
        "description": "\n\n**Zone.waitFor** is a function that creates a callback that can be used with any async functionality. Calling Zone.waitFor registers a wait with the currently running request and returns a function that, when called, will decrement the wait count.\n\nThis is useful if there is async functionality other than what [we implement](#tasks). You might be using a library that has C++ bindings and doesn't go through the normal JavaScript async APIs.\n\n```js\nvar Zone = require(\"can-zone\");\nvar fs = require(\"fs\");\n\nfs.readFile(\"data.json\", \"utf8\", Zone.waitFor(function(){\n\t// We waited on this!\n}));\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "\n"
    }
  },
  "can-zone-storage.methods": {
    "name": "can-zone-storage.methods",
    "title": "methods",
    "type": "group",
    "parent": "can-zone-storage",
    "description": "",
    "order": 0
  },
  "can-zone-storage.properties": {
    "name": "can-zone-storage.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-zone-storage",
    "description": "",
    "order": 1
  },
  "can-zone-storage": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.md"
    },
    "body": "\n## Use\n\n`can-zone-storage` provides a Zone-safe method of storing data for a user.\n\nIt implements three of the methods from the WebStorage Interface:\n - [can-zone-storage.setItem setItem] stores keyed data.\n - [can-zone-storage.getItem getItem] retrieves keyed data.\n - [can-zone-storage.removeItem removeItem] deletes keyed data.\n\nOne additional method, [can-zone-storage.getStore getStore], allows you to retrieve the current data store and inspect it directly.\n\n## Zone Safe\n\nDone-SSR, the Server Side Rendering solution built into DoneJS, uses Zones to increase performance.  Other web servers will completely rebuild the app for every incoming request.  Done-SSR uses Zones to keep the app running in memory and share it between all incoming connections.  \n\nSharing modules between connections is often fine, but some data should not be shared.  Private data belonging to one user should not reach another user on the same server.  Can-Zone provides each incoming request with a `CanZone.current` object that is not shared.  The `can-zone-storage` module detects if CanZone is in the global namespace.  If it *is* found, it uses the `CanZone.current.data` object as the data store.  If `CanZone` is not found, an internal memory store is used.\n",
    "description": "Implement Zone-safe memory-based storage \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-zone-storage",
    "parent": "can-ecosystem",
    "package": {
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.4"
        },
        "glob": {
          "pattern": "**/*.{js,md}",
          "ignore": "node_modules/**/*"
        },
        "parent": "can-zone-storage",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-zone-storage/issues"
      },
      "description": "Implement Zone-safe memory-based storage",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "bit-docs-generate-readme": "0.0.10",
        "can-zone": "^0.6.1",
        "semistandard": "^9.2.1",
        "steal": "^1.0.6",
        "steal-qunit": "^1.0.0",
        "steal-tools": "^1.0.1",
        "testee": "^0.3.0"
      },
      "homepage": "https://github.com/canjs/can-zone-storage",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "can-zone-storage.js",
      "name": "can-zone-storage",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-zone-storage.git"
      },
      "scripts": {
        "build": "node build.js",
        "lint": "semistandard --fix",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run lint && npm run testee",
        "testee": "testee test/zone-test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "steal": {
        "main": "can-zone-storage"
      },
      "version": "1.0.0"
    },
    "signatures": [
      {
        "code": "define(prototype, propDefinitions)",
        "description": "\n\nImplement a Zone-safe memory-based storage solution.  This is especially useful for Server Side Rendering (SSR).\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\n\nvar value = 'Store me';\n\nzoneStorage.setItem('key-name', value);\n\nzoneStorage.getItem('key-name') === 'Store me' // --> true\n\nzoneStorage.removeItem('key-name');\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-zone-storage.getItem": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.methods.getItem.md"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "name": "can-zone-storage.getItem",
    "type": "function",
    "parent": "can-zone-storage.methods",
    "signatures": [
      {
        "code": "getItem(key)",
        "description": "\n\nStores keyed data in the current data store.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\n\nvar test = zoneStorage.getItem('key-name') // test === undefined\n\nvar value = 'Store me';\n\nzoneStorage.setItem('key-name', value);\nzoneStorage.getItem('key-name') // test === 'Store me'\n\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key name from which the data will be retrieved."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key name from which the data will be retrieved."
    }
  },
  "can-zone-storage.getStore": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.methods.getStore.md"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "name": "can-zone-storage.getStore",
    "type": "function",
    "parent": "can-zone-storage.methods",
    "signatures": [
      {
        "code": "getStore()",
        "description": "\n\nRetrieves the current store.  \n\nIf the [can-zone] library has been imported, `getStore` returns the `CanZone.current.data` object.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\nvar Zone = require(\"can-zone\");\nvar store = zoneStorage.getStore();\n\nstore === window.CanZone.current.data // true\n```\n\nIf the [can-zone] library has NOT been imported, `getStore` returns the internal [can-zone-storage.data] object.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\nvar store = zoneStorage.getStore();\n\nstore === zoneStorage.data // true\n```\n",
        "params": []
      }
    ]
  },
  "can-zone-storage.removeItem": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.methods.removeItem.md"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "name": "can-zone-storage.removeItem",
    "type": "function",
    "parent": "can-zone-storage.methods",
    "signatures": [
      {
        "code": "removeItem(key, value)",
        "description": "\n\nRemoves keyed data from the current data store.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\n\nzoneStorage.removeItem('key-name');\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key name that will be deleted from the data store.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key name that will be deleted from the data store.\n"
    }
  },
  "can-zone-storage.setItem": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.methods.setItem.md"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "name": "can-zone-storage.setItem",
    "type": "function",
    "parent": "can-zone-storage.methods",
    "signatures": [
      {
        "code": "setItem(key, value)",
        "description": "\n\nStores keyed data in the current data store.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\n\nvar value = 'Store me';\n\nzoneStorage.setItem('key-name', value);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key name under which the data will be stored."
          },
          {
            "types": [
              {
                "type": "Any"
              }
            ],
            "name": "value",
            "description": "The data to be stored."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Any"
        }
      ],
      "name": "value",
      "description": "The data to be stored."
    }
  },
  "can-zone-storage.data": {
    "src": {
      "path": "node_modules/can-zone-storage/docs/can-zone-storage.properties.data.md"
    },
    "body": "",
    "description": "Implement Zone-safe memory-based storage \n",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nThe `data` property of `can-zone-storage` is a plain old JavaScript object.  It is used as the memory-based storage when window.CanZone is undefined (when the [can-zone] module hasn't been loaded).  If `window.CanZone` is found (when [can-zone] is used), the `CanZone.current.data` object is used, instead, for Zone-safe storage.\n\n```js\nvar zoneStorage = require(\"can-zone-storage\");\n\nconsole.log(zoneStorage.data) // --> {}\n\nzoneStorage.setItem('test', 123);\n\nconsole.log(zoneStorage.data) // --> {test: 123}\n```\n"
      }
    ],
    "title": "data",
    "name": "can-zone-storage.data",
    "type": "property",
    "parent": "can-zone-storage.properties"
  },
  "roadmap": {
    "src": {
      "path": "docs/can-guides/commitment/Roadmap.md"
    },
    "body": "\n## How our roadmap is decided\n\nCanJS’s direction is shaped by its community creating [guides/contributing/feature-suggestion feature suggestions] and [guides/contributing/bug-report bug reports],\nand giving them a `+1`.\n\nThen, the [DoneJS core team members](http://donejs.com/About.html#section=section_Team) prioritize\nissues with a `P0` to `P4` tag indicating their priority:\n\n- `P0` - An issue that will preempt any other issues currently being worked on.\n- `P1` - A critical feature or bug that needs to be fixed to keep CanJS’s high degree of quality.\n- `P2` - A feature or bug that is less likely to be encountered, but something we intend to get to.\n- `P3` - A nice to have. The OS team might get to it, but it’s helpful if the community assists.\n- `P4` - A nice to have that the OS team will accept, but will be unlikely to prioritize any effort towards.\n\n\n\n\n## Current Roadmap\n\nCanJS’s roadmap is constantly changing, so showing a schedule would be impossible.\nThe following links to CanJS’s feature issues grouped by priorities:\n\n - [P1 ](https://github.com/search?q=org%3Acanjs+label%3Aenhancement+label%3AP1&ref=searchresults&state=open&type=Issues)\n - [P2 ](https://github.com/search?q=org%3Acanjs+label%3Aenhancement+label%3AP2&ref=searchresults&state=open&type=Issues)\n - [P3 ](https://github.com/search?q=org%3Acanjs+label%3Aenhancement+label%3AP3&ref=searchresults&state=open&type=Issues)\n\n\n## How to influence the roadmap\n\n\nThese priorities can change.  The best ways to influence the priority of an issue is to:\n\n - Add test or implement the feature or fix\n - Come to a contributors meeting and let us know why it’s important to you\n - Make your case clearly and concisely in the issue\n - `+1` the issue to show your support\n\n",
    "description": "Learn about CanJS’s future plans, how we make them, and how you can influence them. \n",
    "name": "roadmap",
    "title": "Roadmap",
    "type": "page",
    "parent": "about",
    "order": 3,
    "comment": " "
  },
  "guides/api": {
    "src": {
      "path": "docs/can-guides/commitment/api-guide.md"
    },
    "body": "\n\n## Documentation Structure\n\nCanJS’s documentation is broken down by pages for:\n\n - library collections\n - packages and modules and their exports\n - functions, properties, and type definitions (typedefs) related to module exports\n\nFor example, [can-define/map/map.prototype.on can-define/map/map.prototype.on] is a\nmethod that listens to changes on an observable map as follows:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar map = new DefineMap({name: \"Justin\"});\n\nmap.on(\"name\", function(ev, newVal, oldValue){ ... })\n```\n\n`.on` is a function the `prototype` of the `DefineMap` export of the `can-define/map/map`\nmodule.  The `can-define/map/map` is part of CanJS’s [can-core] collection.\n\nSo understanding CanJS’s API pages are about understanding the relationships between:\n\n- library collections\n- packages and modules and their exports\n- functions, properties, and type definitions (typedefs) related to module exports\n\n... and what’s documented on those pages.  \n\n### Library Collection pages\n\nThe API docs are divided in 4 collection pages:\n\n- [can-core]\n- [can-ecosystem]\n- [can-infrastructure]\n- [can-legacy]\n\nEach collection page acts as an overview and cheat sheet for the modules and functionality\ncontained within the collection.\n\nThe [can-core] collection contains the documentation for the libraries that\nare use most commonly and directly within a CanJS application.  This is where the Model-View-ViewModel\nlibraries of CanJS are documented.\n\nThe [can-ecosystem] collection contains less commonly used libraries or libraries that aren’t quite core ready yet.  The most commonly used libraries here are [can-fixture], [can-stache-converters], and [can-jquery].\n\nThe [can-infrastructure] collection contains the utility libraries that power the core and ecoystem\ncollection.  Often, this functionality is used indirectly.  For example, the [can-event] mixin\nis used to add `on`, `off`, and `dispatch` methods to [can-define] and [can-compute].  And, [can-util] contains a wide variety of low-level DOM and JavaScript utilities.\n\nSometimes [can-infrastructure] is used directly.  The most important examples are:\n\n - [can-event/batch/batch] is used to batch changes for faster performance.\n - [can-util/dom/attr/attr] provides special [can-util/dom/attr/attr.special.focused] and [can-util/dom/attr/attr.special.values] attributes that [can-stache-bindings] can be bound to.\n - [can-util/dom/events/events] provides special [can-util/dom/events/attributes/attributes],\n   [can-util/dom/events/inserted/inserted], and [can-util/dom/events/removed/removed] events.\n - [can-view-callbacks] lets you register behavior for custom elements and attributes.\n\nFinally, the [can-legacy] collection.  This is for libraries that are no longer under active\ndevelopment.  Hopefully, you aren’t there very often.\n\n> Look to library collection pages for a high level cheat and explanation of every module within\n> the collection.  \n\n## Package and Module Pages\n\nA package or module documents the \"direct\" functionality of the export and provides an overview of\nall functionality contained within the module or package.\n\nFor example, [can-define/list/list] documents the \"direct\" functionality of the export, namely\nthe `DefineList` function that is exported.  While  [can-define/list/list.extend DefineList.extend] is the most common starting place when using `DefineList`, the `DefineList` export method can only be used like `new DefineList()` directly.  This is why `new DefineList()` is documented\non [can-define/list/list].  \n\nHowever, after the `new DefineList()` signature is detailed, [can-define/list/list] has a __#Use__\nsection that provides an overview of all functionality contained within the `can-define/list/list`\nmodule.\n\n> Look to Package and module pages for details of what is specifically exported and an overview\n> of what the module does, why it’s useful, and how to use it.\n\n## Functions, Properties, and Typedef pages\n\nWithin a module, there might be a variety of functions, properties and types a\nmodule might provide.\n\nThese values are generally organized by groupings.  The most common groupings are:\n\n - _prototype_ - A property or function is on the prototype of a parent function.\n - _static_ - A property or method is a direct value on the parent function or object.\n - _events_ - Events dispatched on the parent object or instances of the parent function.\n - _types_ - Type definitions.\n\nLet’s see a few examples and then give an overview of how their content is structured.\n\n#### prototype\n\n[can-define/list/list.prototype.concat can-define/list/list.prototype.concat] is in\nthe _prototype_ group on [can-define/list/list] because `concat` is on\nthe `can-define/list/list` export’s `prototype`:\n\n```js\nvar DefineList = require(\"can-define/list/list\");\nDefineList.prototype.concat //-> function\n```\n\nBecause of how JavaScript works, this means that you can call `.concat` directly on any instance\nof `DefineList`:\n\n```js\nvar hobbies = new DefineList([\"learning\"]);\nhobbies.concat([\"programming\"]);\n```\n\n#### static\n\n[can-define/map/map.extend] s in\nthe _static_ group on [can-define/map/map] because `extend` is a direct property on the `can-define/map/map` export:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nDefineMap.prototype.map //-> function\n```\n\n#### types\n\nSometimes a method might expect data passed to it in a certain format, or returns\ndata in another format.  These formats are often described separate from the\nmethod.\n\nFor example, the [can-fixture.store can-fixture.store] method returns an object\nof the [can-fixture/StoreType Store type].\n\n```js\nvar fixture = require(\"can-fixture\");\n\nvar todoStore = fixture.store([{id: 1, name: \"trash\"}]);\n\ntodoStore.createData  //-> function\ntodoStore.destroyData //-> function\ntodoStore.get         //-> function\n```\n\nAs you can see above, a `Store` can have lots of methods\nitself: `createData`, `destroyData`, etc.  So this type that isn’t directly\naccessible is documented under `can-fixture`’s _types_.  It’s also\nspecified as the return value of [can-fixture.store can-fixture.store].\n\n### Functions, Properties, and Typedef content\n\nEach function, property, and typedef page will have one or more signature’s describing\nwhat is being documented.\n\nSignatures are the __what__ and the __how__.  They should be precise on the\nbehavior of what is being documented.\n\nSome function, property, and typedef pages have __#Use__ sections that give\nmore information and examples on what is being documented.\n\n> Look to Functions, Properties, and Typedef pages to provide low-level details on\n> a specific piece of CanJS’s API.\n\n\n## How to find what you’re looking for ...\n\n1. Get a good understand of the purpose behind each module.  \n2. Start with core modules.\n3. Then checkout infrastructure modules.\n\nIf you don’t find what you want on the lowest level, walk up to the parent module, it\nmight be in its __#Use__ section.  \n\nIf not, let us know!\n\n",
    "description": "This page walks through how to use and understand CanJS’s API documentation.   \n",
    "name": "guides/api",
    "title": "API Guide",
    "type": "page",
    "parent": "guides/commitment",
    "order": 0,
    "comment": " "
  },
  "migrate-3": {
    "src": {
      "path": "docs/can-guides/commitment/migrating_to_3.0.md"
    },
    "body": "\nCanJS 3 introduces an even more modular project structure and several new features, while having a minimal number of deprecations and removals from the [2.3 API](//v2.canjs.com/docs/).\n\nThis guide goes over:\n\n* [*Pre-migration preparation*](#Pre_migrationpreparation) you can do in your current 2.x project to more easily move to 3.x in the future.\n* [The *minimal migration path*](#Minimalmigrationpath), which includes the fewest changes required to upgrade from 2.x to 3.x.\n* [The *modernized migration path*](#Modernizedmigrationpath), which includes upgrading your code to match more modern conventions (such as using the new npm packages).\n* [The *latest & greatest migration path*](#Latest_greatestmigrationpath), which uses all of the modern libraries we are most excited about (such as [can-define]).\n* [How to *avoid future deprecations & removals*](#Avoidfuturedeprecations_removals) in releases after 3.x\n\n## Pre-migration preparation\n\nBefore upgrading your project from 2.x to 3.x, make sure your project builds successfully and all the tests pass.\n\nAdditionally, you can take the following steps in your CanJS 2.x app to prepare it for migrating to CanJS 3.\n\n### Use the module folders\n\nYou can start importing CanJS code in a modular way before moving to CanJS 3.\n\nFor example, you might be using [can-component] like this:\n\n```js\nvar can = require(\"can\");\n\ncan.Component.extend({ ... });\n```\n\nUpdate your code to instead look like this:\n\n```js\nvar Component = require(\"can/component/component\");\n\nComponent.extend({ ... });\n```\n\nUse the same pattern for the other modules you are using. Be careful when declaring names for imported modules that share a similar name to native objects like Map.\n\nInstead of:\n\n```js\nimport Map from 'can/map/map'; // this local declaration of Map will collide with ECMAScript2015 [Map](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Map)\n```\n\nWrite:\n\n```js\nimport CanMap from 'can/map/map';\n```\n\nHere’s a list of all the `can.` properties in CanJS 2.3 that can be replaced with modular paths:\n\n- `can.autorender` — `can/view/autorender/autorender`\n- `can.batch` — `can/event/batch/batch`\n- `can.bindings` — `can/view/bindings/bindings`\n- `can.Component` — `can/component/component`\n- `can.compute` — `can/compute/compute`\n- `can.Construct` — `can/construct/construct`\n- `can.Control` — `can/control/control`\n- `can.Deferred` — `can/util/deferred`\n- `can.define` — `can/map/define`\n- `can.deparam` — `can/util/string/deparam/deparam`\n- `can.ejs` — `can/view/ejs/ejs`\n- `can.event` — `can/event/event`\n- `can.fixture` — `can/util/fixture`\n- `can.isFunction` — `can/util/js/is-function/is-function`\n- `can.LazyMap` — `can/map/lazy/lazy`\n- `can.List` — `can/list/list`\n- `can.Map` — `can/map/map`\n- `can.Model` — `can/model/model`\n- `can.Model.Cached` — `can/model/cached/cached`\n- `can.mustache` — `can/view/mustache/mustache`\n- `can.Object` — `can/util/object/object`\n- `can.route` — `can/route/route`\n- `can.stache` — `can/view/stache/stache`\n- `can.util` — `can/util/util`\n- `can.view.callbacks` — `can/view/callbacks/callbacks`\n\n### Replace uses of `can.$`\n\n[`can.$`](//v2.canjs.com/docs/can.$.html) allows you to access the underlying DOM library bundled with CanJS; for example, jQuery in `can.jquery.js`.\n\nYou might be using it in your code to easily reference the library:\n\n```js\nvar can = require(\"can\");\nvar body = can.$('body');\n```\n\nUpdate your code to explicitly require the library on which you depend. For example:\n\n```js\nvar $ = require(\"jquery\");\nvar body = $('body');\n```\n\n### Set `leakScope` in components\n\nCanJS 2.2 introduced [can-component.prototype.leakScope leakScope: false] as a property on a [can-component]. This prevents values in parent templates from leaking into your component’s template. In CanJS 3, **leakScope** is now `false` by default.\n\nIf you have a template like:\n\n```\n<some-component></some-component>\n```\n\nThat you render with a [can-map map] containing a `page` property like so:\n\n```js\nrender(new Map({\n\tpage: \"home\"\n}));\n```\n\nThis `page` property is not available within `some-component`’s own template.\n\nIf the component’s template looks like:\n\n```\n<h1>Hello {{page}}</h1>\n```\n\nIt can only lookup the `page` property on `some-component`’s own [can-component.prototype.ViewModel]. To restore the behavior in 2.x, simply set [can-component.prototype.leakScope] to be `true` on the component:\n\n```js\nComponent.extend({\n\ttag: \"some-component\",\n\tViewModel: ...,\n\tleakScope: true\n});\n```\n<span line-highlight='4'></span>\n## Minimal migration path\n\nIf you are already using `can` through npm, simply run the following command to install the latest version:\n\n```\nnpm install can@3 --save\n```\n\nThis will update your `package.json` to look something like this:\n\n```js\n{\n  ...\n  \"dependencies\": {\n    \"can\": \"^<%canjs.package.version%>\"\n  }\n}\n```\n\nThe `^` ensures you get minor and patch releases as those are released.\n\nAt a minimum, to upgrade your code for CanJS 3, you must make all of the following changes to your code:\n\n### Use `can/legacy`\n\nIn your code where you normally would import `can`, instead import `can/legacy`:\n\n```js\nvar can = require(\"can/legacy\");\n```\n\nThis will give you a `can` object with *most* of the same APIs as in 2.3, with a few exceptions:\n\n* [can.mustache](v2.canjs.com/docs/can.mustache.html) is not included with `can/legacy`, but it can still be installed as a [separate package](https://www.npmjs.com/package/can-mustache).\n* The former `can.view` functionality no longer exists; see below for more details.\n\n### Asynchronous `inserted` & `removed` events\n\nIn your [can-component]s, the [can-util/dom/events/inserted/inserted inserted] and [can-util/dom/events/removed/removed] events were previously fired synchronously as the element was inserted or removed from the DOM. To improve performance, these events are now fired asynchronously.\n\nThere is now a [can-component/beforeremove] event that fires synchronously in case you need to perform memory cleanup. For example, you might need to access the parent’s viewModel:\n\n```js\nComponent.extend({\n\ttag: \"my-panel\",\n\n\tevents: {\n\t\t\"{element} beforeremove\": function(){\n\t\t\tcanViewModel(this.element.parentNode).removePanel(this.viewModel);\n\t\t}\n\t}\n}\n```\n\n### Replace uses of `can.view`\n\nThe `can.view` methods have been removed in CanJS 3. The most common use was to create a template renderer from a script element within the page.\n\nInstead of:\n\n```js\nvar render = can.view('some-id');\n```\n\nJust use the DOM APIs and pass the string directly into [can-stache]:\n\n```js\nvar templateString = document.getElementById('some-id').innerHTML;\nvar render = stache(templateString);\n```\n\nIf you were using `can.view` to load a template from a URL like so:\n\n```js\nvar render = can.view('./template.stache');\n```\n\nWe encourage you to use [StealJS](https://stealjs.com/) with [steal-stache](#Usingsteal_stachefortemplates):\n\n```js\nimport render from \"./template.stache\";\n```\n\nAlternatively, use the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API):\n\n```js\nfetch(\"./todos.stache\")\n\t.then((resp) => stache(resp.text()))\n\t.then((render) => /* use render */);\n```\n\nIf you’re using another module loader (such as Browserify or webpack), check out [guides/setup] for instructions on how to load templates.\n\n#### `can.view.preload`\n\nIf you were using `can.view.preload` then use [can-stache.registerPartial] instead.\n\n```js\nstache.registerPartial(\"some-id\", renderer);\n```\n\n### Replace uses of `can.Construct.proxy`\n\n The `can.Construct.proxy` method has been removed in favor of [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n\n Instead of:\n\n ```js\n this.proxy(randFunc)\n ```\n\n You should now do this:\n\n ```js\n randFunc.bind(this)\n ```\n\n ### Replace uses of `can.batch`\n\n `can.batch` has been moved to the `can-event` module.\n\n Instead of:\n\n ```js\n can.batch.method();\n ```\n\nYou should now do this:\n\n```js\nimport canBatch from 'can-event/batch/batch';\ncanBatch.method();\n```\n\nThe `trigger` method has also been renamed to `dispatch`.\n\n ```js\n can.batch.trigger(myObj, 'myEvent');\n ```\n\n Becomes:\n\n ```js\n canBatch.dispatch(myObj, 'myEvent');\n ```\n\n ### Replace uses of `can.isFunction`\n\n `can.isFunction` has been moved to the `can-util` module.\n\n Instead of:\n\n ```js\n can.isFunction(func);\n ```\n\n You should now do this:\n\n ```js\n import isFunction from 'can/util/js/is-function/is-function';\n isFunction(func);\n ```\n\n### `can.event`\n\nSome methods have been renamed in `can.event`.\n\n```js\ncan.event.addEvent.call(el, 'click', function() {});\ncan.event.removeEvent.call(el, 'click', function() {});\n```\n\nBecomes:\n\n```js\ncan.event.addEventListener.call(el, 'click', function() {});\ncan.event.removeEventListener.call(el, 'click', function() {});\n```\n\n### `can.extend`\n\nThis method has been split into two: a shallow and deep merge. Previously, passing `true` as the first parameter would do a deep merge. Now, you explicitly invoke the deep merge or shallow merge function.\n\n```js\ncan.extend({}, { answer: 42 }); // shallow\ncan.extend(true, {}, { answer: 42 }); // deep\n```\n\nBecomes:\n\n```js\nimport assign from 'can-util/js/assign/assign';\nimport deepAssign from 'can-util/js/deepAssign/deepAssign';\nassign({}, { answer: 42 }); // shallow\ndeepAssign({}, { answer: 42 }); // deep\n```\n\n### `can.addClass`\n\nThis method now requires the DOM element to be the context of function.\n\nReplace this:\n\n```js\ncan.addClass(el, 'myClass');\n```\n\nWith this:\n\n```js\nimport className from 'can-util/dom/class-name/class-name';\nclassName.add.call(el, 'myClass');\n```\n\n### `can.append`\n\nThis method now require the DOM element to be the context of function.\n\nReplace this:\n\n```js\ncan.append(el, '<p></p>');\n```\n\nWith this:\n\n```js\nimport mutate from 'can-util/dom/mutate/mutate';\nmutate.append.call(el, '<p></p>');\n```\n\n### `can.data`\n\nThis method now requires the DOM element to be the context of function. It also has a separate method for getting and setting data.\n\nReplace this:\n\n```js\ncan.data(el, 'something', 'secret'); // set\ncan.data(el, 'something'); // get\n```\n\nWith this:\n\n```js\nimport domData from 'can-util/dom/data/data';\ndomData.set.call(el, 'something', 'secret');\ndomData.get.call(el, 'something');\n```\n\n### String methods\n\nAll string methods are grouped together now, so you only have to import the string utilities once.\n\n```js\ncan.camelize('first-name');\ncan.hyphenate('firstName');\n```\n\nBecomes:\n\n```js\nimport string from 'can-util/js/string/string';\n\nstring.camelize('first-name');\nstring.hyphenate('firstName');\n```\n\n### Use native Promises\n\nNative [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) are used instead of jQuery promises which means you need to:\n\n* Include a Promise polyfill if targeting browsers that do not have native support. [Steal](http://stealjs.com/) includes a polyfill for you.\n* Use `.catch()` instead of `.fail()`.\n* Use `.then()` instead of `.done()`.\n\nNote that only a single value is returned from a native Promise.\n\n### Passing the `this` value to a helper\n\n[can-stache] now passes a [can-compute] to [can-stache.Helpers helpers].\n\nIf you were passing the `this` value to a helper like so:\n\n```\n{{helper .}}\n```\n\nYou can fix this either by having your helpers handle computes, or by using [can-stache/expressions/call call expressions] instead:\n\n```\n{{helper(.)}}\n```\n\n### No more global scope names\n\nMost recently-built applications do not depend on adding to the global namespace, but in case you have code that does:\n\n```js\nConstruct.extend(\"foo.bar\", ...)\n```\n\nWhich sets `window.foo.bar`, this argument is no longer accepted by [can-construct]. If you *really* need to set a global, you can do so yourself using the return value of [can-construct.extend].\n\nInstead, the first argument to [can-construct.extend] is the name of the constructor function. This is nice for development as you’ll get named objects in your dev tools.\n\n<a id=\"Usingsteal_stachefortemplates\"></a>\n\n### Using `steal-stache` for templates\n\nIf you use StealJS, you’ll need to install [steal-stache] to load your templates:\n\n```\nnpm install steal-stache@3 --save\n```\n\nIf you’re using StealJS 0.16, you don’t need to do anything else to make your templates load correctly.\n\nIf you’re using StealJS 1, you also need to add `steal-stache` to the `plugins` configuration in your `package.json`:\n\n```json\n{\n  ...\n  \"steal\": {\n    ...\n    \"plugins\": [\"steal-stache\"]\n  }\n}\n```\n\n### Replace `template` with `view` in components\n\nThe `template` property name has been deprecated in favor of `view`.\n\nInstead of:\n\n```js\nimport template from \"./todo.stache\";\nComponent.extend({\n\ttag: \"some-component\",\n\ttemplate: template\n});\n```\n<span line-highlight='4'></span>\nYou should write:\n\n```js\nimport view from \"./todo.stache\";\nComponent.extend({\n\ttag: \"some-component\",\n\tview: view\n});\n```\n<span line-highlight='4'></span>\n## Modernized migration path\n\nCanJS 3 is divided into separate npm packages. This allows us to more quickly update parts of CanJS without affecting other functionality.\n\nIn addition to the above, take advantage of the individual packages by installing and using them directly to set your project up for easier upgrades in the future.\n\nFor example, you might be using [can-component] like either:\n\n```js\nvar can = require(\"can\");\n\ncan.Component.extend({ ... });\n```\n\nor\n\n```js\nvar Component = require(\"can/component/component\");\n\nComponent.extend({ ... });\n```\n\nRegardless of which you are using, update your code to instead look like:\n\n```js\nvar Component = require(\"can-component\");\n\nComponent.extend({ ... });\n```\n\nUse the same pattern for the other `can` modules you are using. In general, you should not be using the `can.` properties any more, but rather importing (through your module loader / bundler) only the packages and modules that you are using.\n\nHere’s a list of all the paths in CanJS 2.3 that now have separate modules in CanJS 3:\n\n- `can/component/component` — [can-component]\n- `can/compute/compute` — [can-compute]\n- `can/construct/construct` — [can-construct]\n- `can/construct/super` — [can-construct-super]\n- `can/control/control` — [can-control]\n- `can/event/event` — [can-event]\n- `can/list/list` — [can-list]\n- `can/map/backup` — [can-map-backup]\n- `can/map/define` — [can-map-define]\n- `can/map/map` — [can-map]\n- `can/model/model` — [can-model](https://github.com/canjs/can-model)\n- `can/route/pushstate/pushstate` — [can-route-pushstate]\n- `can/route/route` — [can-route]\n- `can/util/fixture` — [can-fixture]\n- `can/util/string/deparam/deparam` — [can-deparam]\n- `can/util/util` — [can-util]\n- `can/view/autorender/autorender` — [can-view-autorender]\n- `can/view/callbacks/callbacks` — [can-view-callbacks]\n- `can/view/ejs/ejs` — [can-ejs]\n- `can/view/href/href` — [can-view-href]\n- `can/view/import/import` — [can-view-import]\n- `can/view/live/live` — [can-view-live]\n- `can/view/mustache/mustache` — [can-mustache](https://github.com/canjs/can-mustache)\n- `can/view/node_lists/node_lists` — [can-view-nodelist]\n- `can/view/parser/parser` — [can-view-parser]\n- `can/view/scope/scope` — [can-view-scope]\n- `can/view/stache/stache` — [can-stache]\n- `can/view/target/target` — [can-view-target]\n\n<a id=\"Future_proofmigrationpath\"></a>\n## Latest & greatest migration path\n\nIn addition to the steps taken in the two sections above, make the following changes to your application if you *really* want to stay ahead of the curve.\n\n### Move from `can-map` to `can-define`\n\nIf you’ve used [can-map-define] in the past, then using [can-define] should be familiar to you. Using [can-define/map/map] is the easiest migration path and is what we show in all of the examples in CanJS 3’s docs.\n\nA typical map looks like:\n\n```js\nvar Map = require(\"can-map\");\nrequire(\"can-map-define\");\n\nvar CarOwner = Map.extend({\n\tdefine: {\n\t\tcars: {\n\t\t\tType: Car.List\n\t\t},\n\t\tfavorite: {\n\t\t\tType: Car\n\t\t},\n\t\tcolor: {\n\t\t\ttype: \"string\"\n\t\t},\n\t\tage: {\n\t\t\tvalue: 18\n\t\t}\n\t}\n});\n```\n\nWhich can be replaced by flattening it into a [can-define/map/map] like so:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar CarOwner = DefineMap.extend({\n\tcars: Car.List,\n\tfavorite: Car,\n\tcolor: \"string\",\n\tage: {\n\t\ttype: \"number\",\n\t\tvalue: 18\n\t}\n});\n```\n\nUsing [can-define] allows you to use maps without the [can-map.prototype.attr .attr()] method that’s needed in [can-map] and [can-list]. To use this with `DefineMap`, just use the `.` (dot) operator instead:\n\n```js\nvar carOwner = new CarOwner();\n\n// This is observable!\ncarOwner.favorite = new Car({ make: \"Toyota\" });\n```\n\n**Note:** With `can-map` you are able to assign initial values to a property while defining a `Map` like so:\n\n```js\nvar CanMap = require(\"can-map\");\n\nvar Person = CanMap.extend({\n  name: \"Justin\"\n});\n```\n\nThis shorthand in `can-define/map/map` defines the [can-define.types type], not the initial value.\n\nHere’s the example above updated for `can-define/map/map`:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Person = DefineMap.extend({\n  name: {value: \"Justin\"}\n});\n```\n\n#### Remove use of `change` events\n\nWhen you upgrade to use [can-define], you’ll no longer receive `change` events on maps. If you had any code that binded to a map’s `change` event, you’ll want to instead bind to the properties that you are interested in.\n\nFor example:\n\n```js\nroute.bind(\"change\", function(){\n\t// The route changed\n});\n```\n\nCan be modified to instead use a compute that calls `serialize` on the route’s map:\n\n```js\nvar routeMap = compute(function(){\n\treturn route.map.serialize();\n});\n\nrouteMap.bind(\"change\", function(){\n\t// A property on the route’s map changed.\n});\n```\n\nAs you might notice, [can-event.on on()] is preferable to `bind()`, although `bind()` still works the same.\n\n### Use `can-connect` directly\n\nWhen using the easy migration path, you were secretly using [can-connect/can/model/model], a constructor that is mostly backwards-compatible with [can-model](//v2.canjs.com/docs/can.Model.html).\n\nMost new projects should use [can-connect] directly. [can-connect/can/super-map/super-map] is the easiest way to create models with `can-connect`’s features. Using `can-connect` directly allows you to use [can-define/map/map]s as your models like so:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\nvar superMap = require(\"can-connect/can/super-map/super-map\");\n\nvar Message = DefineMap.extend({\n\tid: \"*\"\n});\n\nMessage.List = DefineList.extend({\n\t\"#\": Message\n});\n\nvar messageConnection = superMap({\n\turl: 'http://chat.donejs.com/api/messages',\n\tidProp: 'id',\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n```\n\n## Avoid future deprecations & removals\n\n### Wrap elements in jQuery objects\n\nIf you are using [can-jquery/legacy] to automatically get jQuery-wrapped elements in [can-control] event handlers, you’ll want to remove the usage of [can-jquery/legacy] as it doesn’t play well with [can-component]s that do not expect elements to be jQuery-wrapped.\n\nInstead, use [can-jquery] directly and handle the wrapping yourself. For example:\n\n```js\nvar Component = require(\"can-component\");\nvar $ = require(\"can-jquery\");\n\nComponent.extend({\n\ttag: \"some-component\",\n\n\tevents: {\n\t\tinserted: function(){\n\t\t\tthis.element = $(this.element);\n\t\t},\n\t\t\"li click\": function(li){\n\t\t\tvar $li = $(li);\n\t\t}\n\t}\n});\n```\n\n[can-jquery] will continue to be supported indefinitely but [can-jquery/legacy] will be dropped in a future major version.\n\n### Use the new binding syntax\n\nCanJS 2.3 introduced new binding syntaxes. They’re available in CanJS 3 with [can-stache-bindings]. Although the old binding syntaxes still work, they will likely be dropped in 4.0. View [can-stache-bindings]’s documentation to learn how to use the new binding syntax.\n\nAn example is changing a `can-value` binding from:\n\n```\n<input type=\"text\" can-value=\"{someProp}\" />\n```\n\nTo:\n\n```\n<input type=\"text\" {($value})=\"someProp\" />\n```\n\nCanJS 3 also introduces new [can-stache.registerConverter stache converters], which are special two-way [can-stache.Helpers helpers] that update an element when an observable value changes and update the observable value when the form element’s value changes (from user input).\n\nAn example is the [can-stache-converters.string-to-any] converter, which converts a primitive value to a string to set a `<select>`’s value, and then converts the `<select>` value when a user selects an `<option>` back to the primitive value to update the scope value:\n\n```\n<select {($value)}=\"string-to-any(~favePlayer)\">\n\t<option value=\"23\">Michael Jordan</option>\n\t<option value=\"32\">Magic Johnson</option>\n</select>\n```\n\n",
    "description": "This guide walks you through the step-by-step process to upgrade a 2.x app to CanJS 3. \n",
    "name": "migrate-3",
    "title": "Migrating to CanJS 3",
    "type": "page",
    "parent": "guides/commitment",
    "order": 2,
    "templateRender": [
      "<%",
      "%>"
    ],
    "outline": "0",
    "comment": " "
  },
  "guides/contributing/bug-report": {
    "src": {
      "path": "docs/can-guides/contribute/bug-report.md"
    },
    "body": "\n## Overview\n\nCanJS uses [GitHub Issues](https://github.com/canjs/canjs/issues/new) to track bugs. However,\nCanJS is made up of many individual GitHub repositories. Ideally, bugs are created within the\nrepository whose code is causing the issue.  For example, issues with\n[can-define] can be created at [canjs/can-define/issues/new](https://github.com/canjs/can-define/issues/new).\n\nIf you do not know which repository your issue belongs to, that’s totally ok!  Please\ncreate your issue in the main\n[canjs/canjs issues page](https://github.com/canjs/canjs/issues/new).  The core team will\nmove the issue to the correct repository if necessary.\n\nWhen creating an issue, it’s very helpful to include:\n\n - Small examples using tools like JS&nbsp;Bin. You can clone the following [CanJS bin](https://jsbin.com/losoceranu/1/edit?html,js,output) that includes everything in CanJS. Make\n   sure it’s pointing at the same version of CanJS you are using.  \n - Breaking unit tests (optional). See [guides/contributing/code].\n - Proposed fix solutions (optional)\n\nAlso, please search for previous tickets.  If there’s something similar, add to that, or\ngive it a `+1`.\n\nFinally, if there are any questions, reach out to\nus on the [CanJS forums](http://forums.donejs.com/c/canjs) or talk to us on\nthe [Gitter canjs/canjs channel](https://gitter.im/canjs/canjs).\n\n## Priority, Tags, and Complexity\n\nThe [core team](https://donejs.com/About.html#section=section_Team) reviews issues\nand assigns them a `P0` to `P4` tag corresponding to the following priorities:\n\n- `P0` - An issue that will preempt any other issues currently being worked on.\n- `P1` - A critical feature or bug that needs to be fixed to keep CanJS’s high degree of quality.\n- `P2` - A feature or bug that is less likely to be encountered, but something we intend to get to.\n- `P3` - A nice to have. The OS team might get to it, but it’s helpful if the community assists.\n- `P4` - A nice to have that the OS team will accept, but will be unlikely to prioritize any effort towards.\n\nThere are several ways to influence these priorities:\n\n - Offer to pair with a contributor on a solution.\n - Write a good test.\n - Come to a DoneJS Contributors meeting and make your case.\n - Get others from other organizations to `+1` the issue.\n - Make your case on Gitter with a contributor or in the issue.\n - You can always hire [Bitovi](http://bitovi.com) or a contributor to make the change.\n\n\nAlso, the core team will often include a complexity indicator in the title that looks like\n`~NUMBER`.  This is a fibonacci number.  `~1` means its an extremely simple task.  `~8` is about\na half day task.  `~34` might take a week of experimentation.\n\n",
    "description": "Learn how to submit a bug report. \n",
    "name": "guides/contributing/bug-report",
    "title": "Bug Report",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/code": {
    "src": {
      "path": "docs/can-guides/contribute/code.md"
    },
    "body": "\n## Overview\n\nContributing to any Open Source project can be intimidating.  All contributions from all types of contributors are welcome.  We’re\ncommitted to making the experience as pleasant and rewarding as possible.  We’re happy to set up a\npairing session to show you how to fix a bug or write a feature.  \n\nIf you have any questions, you can always reach us on [Gitter chat](https://gitter.im/canjs/canjs).\n\nThe first thing to know about `CanJS` is that its code is split across about 40 different\nrepositories.  All but one of these are __library__ repositories like\n[canjs/can-event](https://github.com/canjs/can-event) and [canjs/can-define](https://github.com/canjs/can-define).  These all work the same way.\nThe [canjs/canjs](https://github.com/canjs/canjs) __framework__ repository works slightly\ndifferently.  The vast majority of code changes happen in one of the __library__\nrepositories.\n\nIf you don’t know which repository you need to work on, ask us in [Gitter chat](https://gitter.im/canjs/canjs).\n\nWe’ll cover the following details in this guide:\n\n- Setting up your development environment.\n- Getting the repository’s code and verify it’s working.\n- The file organization and responsibilities.\n- Making changes and submitting a pull request.\n\nThe following video walks through most of the following steps:\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/PRuueWqnpIw\" frameborder=\"0\" allowfullscreen></iframe>\n\n## Setting up your development environment\n\nDeveloping CanJS requires:\n\n - A [GitHub](https://github.com/) account and git client.\n - Node.js version 5 or later.\n - Firefox for running automated tests.\n\n### Getting GitHub account and client\n\nSign up for a [GitHub](https://github.com/) account.  \n\nThere are a variety of ways to get a git command line client\nconnected to your GitHub account. GitHub has\ngreat documentation on how to [set up Git](https://help.github.com/articles/set-up-git/).\n\n\nIf you already have `git` installed, make sure you’ve\n[set up your ssh keys](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/).\n\n### Get Node.js\n\nDownload Node.js version 5 or later at [NodeJS.org](https://nodejs.org).  You can\nverify Node’s version with:\n\n```\nnode -v\n```\n\n### Get Firefox\n\nDownload the Firefox browser\n[here](https://www.mozilla.org/en-US/firefox/new/). Make sure it gets installed into the\ndefault location for your operating system.\n\nFirefox is used to run each repository’s tests.\n\n\n## Getting the code and verifying that it’s working\n\nOnce your environment is set up, you should be able to clone the repository you\nwant to change, install its dependencies, and verify you’ve set up your\ndevelopment environment correctly.\n\n__1.__  Click the __Fork__ button to fork the repository from which you will be working.\nFor example, you can fork `can-compute` by pressing its __Fork__ button on GitHub:\n\n<img src=\"../../../docs/can-guides/contribute/fork.png\" width=\"600px\"/>\n\n\n__2.__ Clone your forked version of the repository:\n\n```\ngit clone git@github.com:<your username>/<repository-name>.git\n```\n\nFor example, if your username is `justinbmeyer` and you forked `can-compute`:\n\n```\ngit clone git@github.com:justinbmeyer/can-compute.git\n```\n\n__3.__ Move into your project’s directory.  For example\n\n```\ncd can-compute\n```\n\n__4.__ Install npm dependencies with:\n\n```\nnpm install\n```\n\n__5.__ Make sure Firefox is closed and run the test suite with:\n\n```\nnpm test\n```\n\nIf every test passed, __congrats__! You have everything you need to\nchange code and have the core team review it.\n\n## File organization and responsibilities\n\nMost __library__ repositories share a similar structure.  Understanding it can help\nyou figure out what code needs to be changed.  The following outline shows the\ndirectory structure of a nonexistent `can-example` repository:\n\n```\n├── .editorconfig           — Configures editors for this project\n├── .gitignore              — Tells git to ignore certain files\n├── .jshintrc               — Configures JSHint\n├── .npmignore              — Tells npm publish to ignore certain files\n├── .travis.yml             — Travis CI configuration\n├── build.js                — Build script to export code in other formats\n├── can-example.js          — Main module code\n├── package.json            — Configuration of package and dev scripts\n├── readme.md               — Automatically generated readme\n├── docs/                   — Documentation source\n|   ├── can-example.md      — Package or module documentation\n├── node_modules/           — Node dependency installation folder\n├── test/                   — Test files\n|   ├── can-example-test.js — Main test file\n|   ├── test.html           — Main test page\n```\n\nGenerally speaking, the most important files are:\n\n - the main module —  `can-example.js`\n - the main test module — `test/can-example-test.js`\n - the test page — `test/test.html`\n\nTo fix a bug or making a feature, add a test in the main test module, update code in the main module, and then verify the tests are passing by running\nthe test page.\n\nSome modules have multiple modules, test modules, and test pages.  These modules are\ncommonly organized as __modlets__ where each folder will have its own main module, test module,\nand test page:\n\n```\n├── a-module/            — Module’s modlet folder\n|   ├── a-module.js      — The module\n|   ├── a-module-test.js — The module’s tests\n|   ├── test.html        — A test page that runs just the module’s tests\n```\n\nWhere possible, CanJS code uses:\n\n- Tabs not spaces\n- JSHint\n- CommonJS not ES6\n- jQuery’s [coding conventions](https://contribute.jquery.org/style-guide/js/)\n\n\n##  Make your changes\n\nOnce you’ve figured out where you need to make changes, you’ll want to complete the following steps\nto make those changes and create a pull request so we can include your code in future releases:\n\n\n1. Create a new feature branch. For example, `git checkout -b html5-fix`.\n2. Make some changes to the code and tests.\n4. Run `npm test` to make sure the tests pass in all browsers.\n5. Update the documentation if necessary.\n6. Push your changes to your remote branch.  For example, `git push origin html5-fix`.\n7. Submit a pull request! On GitHub, navigate to Pull Requests and click the “New Pull Request” button. Fill in some\n   details about your potential patch, including a meaningful title. When finished, press “Send pull request”. The core team will be notified of your submission and will let you know of any problems or a targeted release date.\n\nIf you enjoy making these kinds of fixes and want to directly influence CanJS’s direction,\nconsider joining our [Core team](https://donejs.com/About.html#section=section_Coreteam).\n\n## Making a plugin\n\nMaking an official or unofficial CanJS plugin is easy.  \n\nAn __official__ plugin is:\n\n - In a repository under the [https://github.com/canjs CanJS organization].\n - Listed and documented under the [can-ecosystem Ecosystem Collection].\n - Tested in the `canjs/canjs` integration suite.\n - Published as `can-<name>` (with a few exceptions).\n\n__Unofficial__ plugins can be maintained however you choose, but to maximize your project’s:\n\n- Compatibility — useful in as many development environments as possible (Browserify, StealJS, Webpack, etc.)\n- Discoverability — other developers can find it\n- Contribute-ability — other developers can contribute to it\n\n…we suggest following the [DoneJS plugin guide](https://donejs.com/plugin.html) with the following changes:\n\n__1.__ Pick a plugin name that has `can` in the name.  \n\n__2.__ When the `donejs add plugin` generator asks for “Project main folder”, use `.`\n\n__3.__ List `canjs` in your `package.json`’s `keywords`.\n\n__4.__ Update the code to match the [File organization and responsibilities](#Fileorganizationandresponsibilities) section.  There are a few changes to make:\n\n- Change everything to CommonJS.  Use `require('module-name')` instead of `import 'module-name'`.\n- Use _tabs_ instead of _spaces_.\n- Use dashes instead of underscores in generated filenames.\n\n__5.__ Use the [migrate-3] guide to update the code for CanJS 3. This won’t be necessary with DoneJS 1; it’s [coming soon](https://github.com/donejs/donejs/issues/703)!\n",
    "description": "Learn how contribute a code change to CanJS. \n",
    "name": "guides/contributing/code",
    "title": "Code",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/documentation": {
    "src": {
      "path": "docs/can-guides/contribute/documentation.md"
    },
    "body": "\n## Overview\n\nThe CanJS site is generated with [bit-docs](https://github.com/bit-docs/bit-docs),\na modified version of [DocumentJS](http://documentjs.com).  Its\ncontent is hosted using GitHub pages publishing the [canjs/canjs#gh-pages](https://github.com/canjs/canjs/tree/gh-pages) repo.\n\n`bit-docs` reads JavaScript comments and markdown files within the `canjs` repo as well as\nthe individual repositories within `node_modules` to produce a static site.\n\nThe high level content (Ex: homepage) and the guides content for the site is within the\n`canjs/docs` folder.  Individual repositories contain their own markdown and commented\nJavaScript files used to produce their API pages.\n\n## Generate the documentation locally\n\nTo generate the CanJS site:\n\n1. Clone [https://github.com/canjs/canjs](https://github.com/canjs/canjs)\n\n   ```\n   > git clone git@github.com:canjs/canjs\n   ```\n\n2. Install dependencies:\n\n   ```\n   > npm install\n   ```\n\n3. Run `bit-docs`:\n\n   ```\n   > ./node_modules/.bin/bit-docs -d\n   ```\n\nThis should produce a static site in your `canjs` folder.  Open `canjs/index.html`\nand you should see the site.  You might want to use [http-server](https://www.npmjs.com/package/http-server) to start\na simple static file server.\n\n## Improve the theme’s design and styles\n\nThe CanJS theme is in\n[bit-docs-html-canjs](https://github.com/canjs/bit-docs-html-canjs). It’s\n[readme](https://github.com/canjs/bit-docs-html-canjs/blob/master/readme.md)\nhas instructions on how to test out the theme.  Once the theme is updated and published,\n\n1. Open `canjs/package.json`. Update `bit-docs-html-canjs`’s version to the new theme version.\n2. Run `./node_modules/.bin/bit-docs -df` to make sure the theme is correctly applied.\n\n## Test out content from other repos\n\nAs noted above, the API docs from each package come from that package.  So if you’re\nimproving the docs for say `can-compute`, you want to see what `can-compute`’s docs look like,\ninstall your local `can-compute` and re-run bit-docs like:\n\n```\n> npm install ../can-compute && ./node_modules/.bin/bit-docs -d\n```\n\n\n## Publish the documentation\n\nOnce the docs look right locally, commit your changes, then run:\n\n```\n> make\n```\n\nThe make script will generate the documentation again and push out the `gh-pages` branch.\n\n\n## Writing API documentation\n\nOur documentation is modeled off of jQuery’s.  Please read\ntheir [guidelines](https://github.com/jquery/api.jquery.com/blob/master/README.md). Also read our\n[guides/api].\n\nGenerally speaking there are three parts to every documentation page:\n\n - Its description\n - Its signatures\n - The body (typically \"Use\" section)\n\n### Description\n\nThe description section should be a one or two sentence explanation of what this\npiece of documentation does from a _user_-centric view.  Descriptions are a quick summary\nof the __why__ and the __what__. It should take on an\nactive voice.  For example, [can-component]’s description:\n\n> Create a custom element that can be used to manage widgets or application logic.\n\nNotice that it uses \"Create\" not \"Creates\".\n\n### Signatures\n\nSignatures are the __what__ and the __how__.  They should include all or most of the following:\n\n - __What the signature does__, if different from the description, especially if there are\n   multiple signatures.\n - High level details on __how the code works__.\n - A simple example showing __how to use the code__.\n\n[can-compute]’s first signature is a good example of this. First, it explains\n__what that signature does__:\n\n> Create a compute that derives its value from other observables.\n\nThen it briefly explains __how the code works__:\n\n> Uses can-observation to call the getterSetter and track observables.\n\nFinally, it provides minimal sample code:\n\n```js\nvar age = compute(32);\n\nvar nameAndAge = compute(function(){\n    return \"Matthew - \" + age();\n});\n\nnameAndAge() // -> \"Matthew - 32\"\n\nage(33);\n\nnameAndAge() // -> \"Matthew - 33\"\n```\n\nNot all signatures need to hit all three points.  For example [can-event/batch/batch]’s\nsignature simply adds a bit more depth to the purpose of [can-event/batch/batch]\nand then details __how the code works__.  __How to use the code__ is\nleft for the `body` section as importing the module is not necessary to show.\n\n\n\nSignature titles should follow jQuery’s conventions:\n\n - Static methods like: `TypeAlias.method()`\n - Prototype methods like: `typeAlias.method()`\n - Spaces in between arguments: `typeAlias.method( arg1, arg2 )`\n - Brackets around optional args: `typeAlias.method( arg1 [, arg2 ], arg3 )` or\n   `typeAlias.method( arg1 [, arg2 ][, arg3 ] )`\n\nMake sure to fully document the a signature’s parameters and return\nvalue.  There’s a lot of flexibility in documenting the [type expression](http://documentjs.com/docs/documentjs.typeExpression.html) of\na return value or parameters and the [name expression](http://documentjs.com/docs/documentjs.nameExpression.html) of\nparameters.\n\n - Parameter and descriptions should start with a `Capital` and end with a period like:\n   `@param {Type} name Indicates that something should happen.`\n\n\n\n### body\n\nMost body sections start with a `## Use` subsection.  This is a mini guide on\nhow to use that piece of code.  Modules should have long bodies that span\nmultiple topics.  For example [can-component]’s body has examples and\ninformation about nearly all of its sub-functions.  However\n[can-component.prototype.tag can-component.prototype.tag] doesn’t have a\nuse section because it’s covered in [can-component].\n\n\n### structuring documentation\n\n- Group names (like `prototype`) should be lower case.\n- Types should be capitalized `{String}` except when they are describing a function [can-fixture.requestHandler].\n\n",
    "description": "Learn how to improve CanJS’s site and documentation. \n",
    "name": "guides/contributing/documentation",
    "title": "Documentation",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/evangelism": {
    "src": {
      "path": "docs/can-guides/contribute/evangelism.md"
    },
    "body": "\n## Overview\n\nHopefully you love CanJS as much as we do and you want to share your\nknowledge about it.  Fantastic!  We can help you.\n\nThere’s lots of ways to spread the word about CanJS such as:\n\n - Giving a presentation at a conference or meetup\n - Organizing or speaking at a CanJS or DoneJS meetup\n - Writing a blog article\n\nWhatever you do, please let us know so we can promote you and what you’re doing.\n\n## Giving a presentation\n\nThe [Presentations Google Drive Folder](https://drive.google.com/drive/u/1/folders/0Bx-kNqf-wxZeaWc2ay1ZSzZZQXc)\ncontains all of the DoneJS teams talks organized by project.  It contains\na CanJS folder with CanJS presentations.  \n\nSome of the presentations are out dated, but it’s a good place to check for\nexisting content.\n\n\n## Meetups\n\nThere are several DoneJS meetups already created:\n\n - [Chicago](http://www.meetup.com/DoneJS-Chicago/)\n - [Silicon Valley](http://www.meetup.com/DoneJS-Silicon-Valley/)\n - [Boston](http://www.meetup.com/DoneJS-Boston/)\n - [Ft. Lauderdale](http://www.meetup.com/DoneJS-Fort-Lauderdale/)\n - [Los Angeles](http://www.meetup.com/DoneJS-LA/)\n - [New York](http://www.meetup.com/DoneJS-NYC/)\n - [Phoenix](http://www.meetup.com/DoneJS-Phoenix/)\n - [Raleigh-Durham](http://www.meetup.com/DoneJS-raleigh-durham/)\n - [San Francisco](http://www.meetup.com/DoneJS-San-Francisco/)\n - [Seattle](http://www.meetup.com/DoneJS-Seattle/)\n\nWe’re always looking for people to speak at one of these meetups, become an organizer,\nor start their own meetup.  If you are interested in any of these things,\nplease let Justin Meyer know (`justin@bitovi.com`).\n\n\n## Writing a blog article\n\nIf you’re writing something about CanJS and would like us to review it,\nwe’re happy to help.  Once it’s published, let us know so we can promote it.  \n\n",
    "description": "Learn about resources that can help you spread the word about CanJS. \n",
    "name": "guides/contributing/evangelism",
    "title": "Evangelism",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/feature-suggestion": {
    "src": {
      "path": "docs/can-guides/contribute/feature-suggestion.md"
    },
    "body": "\n## Overview\n\nCanJS uses [GitHub Issues](https://github.com/canjs/canjs/issues/new) to track feature requests. However,\nCanJS is made up of many individual GitHub repositories. Ideally, features are created within the\nrepository whose code needs to be modified.  For example, features with\n[can-define] can be created at [canjs/can-define/issues/new](https://github.com/canjs/can-define/issues/new).\n\nIf you do not know which repository your feature belongs to, that’s totally ok!  Please\ncreate your issue in the main\n[canjs/canjs issues page](https://github.com/canjs/canjs/issues/new).  The core team will\nmove the issue to the correct repository if necessary.\n\nWhen creating an feature issue, it’s very helpful to include:\n\n - Examples of what using the feature will look like.\n - Benefits and drawbacks of the feature.\n - Why the feature is important.\n - Any implementation details around the feature.\n\nHere’s some example well written feature requests:\n\n - [Make events fire asynchronously and dispatched during request animation frame or setImmediate](https://github.com/canjs/can-event/issues/11)\n - [Modify key -> argument behavior in stache](https://github.com/canjs/canjs/issues/1699)\n\nAlso, please search for previous feature requests.  If there’s something similar, add to that, or\ngive it a `+1`.\n\nFinally, if there are any questions, reach out to\nus on the [CanJS forums](http://forums.donejs.com/c/canjs) or talk to us on\nthe [Gitter canjs/canjs channel](https://gitter.im/canjs/canjs).\n\n## Priority, Tags, and Complexity\n\nThe [core team](https://donejs.com/About.html#section=section_Team) reviews issues\nand assigns them a `P0` to `P4` tag corresponding to the following priorities:\n\n- `P0` - An issue that will preempt any other issues currently being worked on.\n- `P1` - A critical feature or bug that needs to be fixed to keep CanJS’s high degree of quality.\n- `P2` - A feature or bug that is less likely to be encountered, but something we intend to get to.\n- `P3` - A nice to have. The OS team might get to it, but it’s helpful if the community assists.\n- `P4` - A nice to have that the OS team will accept, but will be unlikely to prioritize any effort towards.\n\nThere are several ways to influence these priorities:\n\n - Offer to pair with a contributor on a solution.\n - Write a good test.\n - Come to a DoneJS Contributors meeting and make your case.\n - Get others from other organizations to `+1` the issue.\n - Make your case on Gitter with a contributor or in the issue.\n - You can always hire [Bitovi](http://bitovi.com) or a contributor to make the change.\n\n\nAlso, the core team will often include a complexity indicator in the title that looks like\n`~NUMBER`.  This is a fibonacci number.  `~1` means its an extremely simple task.  `~8` is about\na half day task.  `~34` might take a week of experimentation.\n\n",
    "description": "Learn how to suggest a feature. \n",
    "name": "guides/contributing/feature-suggestion",
    "title": "Feature Suggestion",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/adding-ecosystem-modules": {
    "src": {
      "path": "docs/can-guides/contribute/including-new-modules.md"
    },
    "body": "\nA project that is useful to the CanJS community can be included on the [CanJS documentation](https://canjs.com/) site.\n\nBefore submitting a PR with these changes, make sure that the source module has [guides/contributing/documentation] and tests that follow [guides/contributing/code] standards set forth by the CanJS community.\n\n## Definitions\n\nIn this guide, `source repo` refers to the repository that will be added to the CanJS.com site.\n\n## Source Repo Documentation\n\nCreate a markdown file in the `docs` folder of source repo and name it after the project.\n\n```bash\ncd can-fixture\nmkdir ./docs\ntouch ./docs/can-fixture.md\n```\n\n> Note: The location of the document files is discussed here as a common use case. Keep in mind that `bit-docs` does not expect documents in any folder. Only that documents use the correct [tag syntax](https://documentjs.com/docs/documentjs.tags.html).\n\n## Source Repo Documentation Tags\n\nIn order to include the source project's documentation on the CanJS site, the main document file requires some tags.\n\n```javadocs\n@module {*} <PACKAGE_NAME>\n@parent <CANJS_PARENT_TARGET>\n@package <PATH_TO_PACKAGE.JSON>\n```\n\n- `PACKAGE_NAME`: is the project name, which should match the `name` property in the source project's `package.json`.\n- `CANJS_PARENT_TARGET`: is the name of the target area in CanJS. For example, if the module is a part of the \"Ecosystem\", then the value for `@parent` would be `can-ecosystem`. If the target is \"Legacy\" then the value is `can-legacy`.\n- `PATH_TO_PACKAGE.JSON`: is a relative path from the main document file for the source repo. Considering the following structure...\n\n```\n- docs\n - can-fixture.md\n- src\n- package.json\n```\n\nIf `can-fixture.md` is the main document, then the relative path to the `package.json` is `../package.json`.\n\nThis would result in a main document file that looked [something like this](https://github.com/canjs/can-fixture/blob/40a4b03f0858a7a24182c12ef7b0ebe37c821e24/docs/can-fixture.md)\n\n```md\n@module {function} can-fixture\n@parent can-ecosystem\n@package ../package.json\n\n> Documentation goes here\n```\n\n## Requiring source repo in CanJS repo\n\nTo build the documentation, first, the source repo needs to be added to the CanJS project.\n\n```bash\nnpm install <PACKAGE_NAME> --save\n```\n\nOnce the project is added as a dependency, the source project's main file needs to be included in the CanJS project.\n\nIn the root directory of the project, locate the `ecosystem.js` JavaScript file - the file should be located in the CanJS project root.\n\n```md\n- /canjs\n - core.js\n - ecosystem.js\n - infrastructure.js\n - legacy.js\n```\n\nOpen the desired file and require the source project.\n\n```javascript\nrequire('<SOURCE_PACKAGE_NAME>');\n```\n\nFor example, in [CanJS](https://github.com/canjs/canjs/blob/e3301daad996df01463a623d50b38bd5091c9b35/ecosystem.js#L4), we have included the [can-fixture] project.\n\n## Require source tests in CanJS repo\n\nOpen the main test file in the CanJS repo, located at `canjs/test/test.js`.\n\nRequire the source repo's test main file in the appropriate area. For example, if the source repo will go in \"Legacy\" area of the site, then add it to the \"Legacy\" section of the test file.\n\nFor example, we have added the [can-fixture tests](https://github.com/canjs/canjs/blob/e3301daad996df01463a623d50b38bd5091c9b35/test/test.js#L56) to the test file.\n\n## Add necessary markup to CanJS docs\n\nOpen the main doc file, located at `./docs/can-canjs/canjs.md`.\n\nAgain, add any necessary markup to the correct section (related to the target parent; legacy for legacy, etc).\n\nFollow this helpful markdown template:\n\n```md\n- **[<PACKAGE_NAME>]** <small><%<PACKAGE_NAME>.package.version%></small> <PACKAGE_DESCRIPTION>\n  - `npm install <PACKAGE_NAME> --save`\n  - <a class=\"github-button\" href=\"<PROJECT_GITHUB_URL>\" data-count-href=\"/<PROJECT_GITHUB_ORG>/<PACKAGE_NAME>/stargazers\" data-count-api=\"/repos/<PROJECT_GITHUB_ORG>/<PACKAGE_NAME>#stargazers_count\">Star</a>\n```\n\n- `PACKAGE_NAME`: The project name, which should match the `name` property in the source project's `package.json`.\n- `PACKAGE_DESCRIPTION`: short description of project, can match the `description` property in source project's `package.json`.\n- `PROJECT_GITHUB_URL`: The Github url. Not the `git` path but the path to the html site.\n- `PROJECT_GITHUB_ORG`: The organization id or user id that owns the project in Github.\n\nFor example, we have added the [markup for can-fixtures](https://github.com/canjs/canjs/blob/e3301daad996df01463a623d50b38bd5091c9b35/docs/can-canjs/canjs.md#the-can-package).\n\n## Adding Continuous Integration\n\nMake sure to activate CI on the source package by including a `.tavis.yml` file in the project root.  \n\n```yml\n# An example configuration\nlanguage: node_js\n# Load nodejs 6.x\nnode_js:\n  - \"6\"\n# Allow ability to run Firefox headless for Testee\nbefore_install:\n  - \"export DISPLAY=:99.0\"\n  - \"sh -e /etc/init.d/xvfb start\"\n```\n\n## Notes\n\nThe last part of the process is to verify the following commands locally. Once the site build is verified, create a PR against the CanJS repo to submit changes.\n\n- `npm run test` to run tests, verify documents and project do not adversely affect the test suite.\n- `./node_modules/.bin/bit-docs -d` to build the documentation site. Read more on the [guides/contributing/documentation] page.\n\n",
    "description": "Learn how to add your module to this site. \n",
    "name": "guides/contributing/adding-ecosystem-modules",
    "title": "New Package",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/releases": {
    "src": {
      "path": "docs/can-guides/contribute/releases.md"
    },
    "body": "\nFor maintainers of CanJS and its submodules this guide describes\n\n- How continuous integration is set up\n- How dependencies are kept up to date\n- How to make a releases of CanJS subprojects and the main package\n- How to update the CanJS website\n\n\n## Continuous Integration\n\n### Travis CI\n\nAll repositories automatically run their tests in [Travis CI](https://travis-ci.org/) using the `npm test` command (browser tests use Firefox as their target browser). If `npm test` is passing locally but not on Travis CI\n\n- Try setting the `DEBUG=testee*` environment variable in `travis-ci.org/canjs/<repository>/settings` to get more information.\n- Run the tests on an Ubuntu VM (e.g. [Ubuntu for Virtualbox](https://www.virtualbox.org/wiki/Linux_Downloads))\n\n### Saucelabs\n\n[canjs/canjs](https://github.com/canjs/canjs) also runs the tests of all dependencies in the supported browsers on [Saucelabs](https://saucelabs.com):\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/canjs.svg)](https://saucelabs.com/u/canjs)\n\nTo view Saucelabs test runs and results, request an invite from a Saucelabs user that has access to the `canjs` Saucelabs project (existing users can send invites under [my account](https://saucelabs.com/beta/users/canjs)). Saucelabs tests can be run locally via\n\n```\nnpm run ci\n```\n\n\n## Updating Dependencies with Greenkeeper\n\nAll CanJS repositories are set up with [Greenkeeper](https://greenkeeper.io/). Greenkeeper tracks dependencies and creates a branch for every new version coming in. This will trigger Travis CI to run the tests and if a dependency update breaks the tests or a breaking (major) version was released, it will create a pull request.\n\nGreenkeeper is free for open source projects and works on the CanJS organization level. To add a new project or change the status of an existing project:\n\n- Install the command line via `npm install greenkeeper -g`\n- Run `greenkeeper login` to log in via GitHub\n- For more information run `greenkeeper` or `greenkeeper start`\n- To enable a project, in the project folder run `greenkeeper enable`\n\n\n## Making releases\n\nWith the exception of the `can` package, __ALL subprojects__ MUST follow the [Semantic Versioning](http://semver.org/) guidelines in the form of `MAJOR.MINOR.PATCH` for\n\n- `MAJOR` version when you make incompatible API changes,\n- `MINOR` version when you add functionality in a backwards-compatible manner, and\n- `PATCH` version when you make backwards-compatible bug fixes.\n\nBefore making any release please make sure that\n\n- You have write access to the GitHub repository you want to publish.\n- Have an [npm](https://www.npmjs.com) account and are logged in on the CLI tool (`npm whoami`).\n- Your user is a collaborator on npm. You can ask an existing collaborator to add you. Existing collaborators can be listed via `npm owner ls <packagename>` or on the npm module page (e.g. [can-route](https://www.npmjs.com/package/can-route)).\n\n\n### Releasing CanJS subprojects\n\nAll CanJS subprojects modules have the same structure which allows making releases through NPM scripts.\n\nTo make a release:\n\n1. Move to the `master` branch\n2. Fetch all latest changes from the repository\n3. Reinstall all Node modules in their latest version\n\n   ```\n   git checkout master\n   git fetch --all && git rebase\n   npm cache clean\n   rm -rf node_modules\n   npm install\n   ```\n\n4. Then run `npm run release:<versiontype>`. For example, to make a `PATCH` release:\n\n   ```\n   npm run release:patch\n   ```\n\nThis will run the tests, build, bump the version number accordingly and publish the module to [npm](https://www.npmjs.com/).\n\n\n### Releasing the CanJS main project\n\nThe CanJS main project repository is at\n[canjs/canjs](https://github.com/canjs/canjs) and published as the `can` package. We\npublish a `can` module so there is a specified version of the library packages that are\n__integration tested__ to work together. A single `can` release can include multiple\nreleases of library packages.\n\nThe `can` package does __not__ follow strict [semantic versioning](http://semver.org/)\nguidelines. It still follows a `MAJOR.MINOR.PATCH` release names, but where:\n\n - `MAJOR` - Incompatible API changes in a library in the [can-core] or [can-infrastructure] collection.\n - `MINOR` - Either:\n    - New features added [can-core] and [can-infrastructure] but still backwards-compatible.\n    - New [can-ecosystem] or [can-legacy] library added or removed to their respective collection.\n - `PATCH` - Either:\n    - Bug fixes in [can-core] and [can-infrastructure].\n    - A new release of a [can-ecosystem] or [can-legacy] library.\n\nThe `can` package __does__ follow strict [semantic versioning](http://semver.org/) guidelines\nwith respect to the [can-core] and [can-infrastructure] collections. If a\nnew [can-ecosystem] or [can-legacy] package is added to `can`, it’s treated as a `MINOR` changes to `can`,\nany subsequent releases of those packages are treated as `PATCH` changes to `can`.\n\nWhen making a release, review the the version number changes and collection of all packages that have changed within the release.  Then run `npm run release:<versiontype>`.\n\nFor example, the following would be a `PATCH` release:\n\n```\ncan-core-a       3.0.1 -> 3.0.2\ncan-core-b       3.0.1 -> 3.0.10\ncan-ecosystem-a  1.0.0 -> 2.0.0\n```\n\nThe following would be a `MINOR` release:\n\n```\ncan-core-a       3.0.1 -> 3.0.2\ncan-core-b       3.0.1 -> 3.0.10\n// this means can-ecoystem-b was added to the ecosystem collection\n+ can-ecosystem-b 0.0.1  \n```\n\nThe following would be a `MINOR` release:\n\n```\ncan-core-a       3.0.1 -> 3.0.2\ncan-core-b       3.0.1 -> 3.1.0\ncan-ecosystem-a  1.0.0 -> 1.0.1\n```\n\nThe following would be a `MAJOR` release:\n\n```\ncan-core-a           3.0.1 -> 3.0.2\ncan-core-b           3.0.1 -> 3.1.0\ncan-infrastructure-a 3.0.1 -> 4.0.0\n```\n\n\n## Updating canjs.com\n\ncanjs.com is hosted on [GitHub pages](https://pages.github.com/) from the [canjs/canjs#gh-pages](https://github.com/canjs/canjs/tree/gh-pages) branch. To generate and push a new version of the website, verify you have push access to that branch. Then get all latest changes via:\n\n```\ngit checkout master\ngit fetch --all && git rebase\nnpm cache clean\nrm -rf node_modules\nnpm install\n```\n\nWe also have to delete the local `gh-pages` branch:\n\n```\ngit branch -D gh-pages\n```\n\nThen run\n\n```\nmake\n```\n\nThis will generate and publish a new version of the website.\n\n",
    "description": "Release and hosting information for CanJS maintainers. \n",
    "name": "guides/contributing/releases",
    "title": "Releases",
    "type": "page",
    "parent": "guides/contribute",
    "outline": "2",
    "comment": " "
  },
  "guides/setup": {
    "src": {
      "path": "docs/can-guides/experiment/setting-up-canjs.md"
    },
    "body": "\nYou can download CanJS from npm or a CDN. We recommend using npm. If you don’t already have Node.js and npm, [learn how to install both on npm’s website](https://docs.npmjs.com/getting-started/installing-node).\n\nOnce downloaded or installed, you can load CanJS in a variety of ways:\n\n - StealJS\n - Browserify\n - `<script>` tags\n\nThis guide shows how to setup common combinations.  If you don’t see yours, please\nask on the [forums](http://forums.donejs.com/c/canjs) or [Gitter chat](https://gitter.im/canjs/canjs).\n\n## JS Bin\n\nUse this JS Bin to play around with CanJS:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/safigic/7/embed?html,js,output\">CanJS on jsbin.com</a><script src=\"//static.jsbin.com/js/embed.min.js?3.40.2\"></script>\n\nIt uses `can.all.js` so you have the [can-core core], [can-ecosystem ecosystem], and [can-infrastructure infrastructure] modules available to you.\n\n## StealJS and npm\n\nInstall [can-core CanJS’s core modules] and StealJS with npm:\n\n```\nnpm install can-component can-compute can-connect can-define can-route can-route-pushstate can-set can-stache can-stache-bindings --save\nnpm install steal steal-stache --save\n```\n\nNext, create a `main.stache` template for your app:\n\n```\n<!-- main.stache -->\n<h1>{{message}}</h1>\n```\n\nNext, create a `main` module for your application. Import [can-define/map/map] and your template to say “Hello World”:\n\n```\n// main.js\nimport DefineMap from \"can-define/map/map\";\nimport template from \"./main.stache!\";\n\nvar data = new DefineMap({message: \"Hello World\"});\n\ndocument.body.appendChild(template(data));\n```\n\nFinally, create a page that loads `steal.js` and specifies `main` as the main module:\n\n```\n<html>\n  <body>\n    <script src=\"./node_modules/steal/steal.js\" data-main=\"main\"></script>\n  </body>\n</html>\n```\n\nStealJS supports “modlet” module names that end with `/`.  This means that the above could\nalso be written like:\n\n```\n// main.js\nimport DefineMap from \"can-define/map/\";\nimport template from \"./main.stache!\";\n\nvar data = new DefineMap({message: \"Hello World\"});\n\ndocument.body.appendChild(template(data));\n```\n<span line-highlight='2-2'></span>\nBesides ES6 modules, StealJS supports AMD and CommonJS.  You could also write `main.js` like:\n\n```\n// main.js\nvar DefineMap = require(\"can-define/map/map\");\nvar template = require(\"./main.stache!\");\n\nvar data = new DefineMap({message: \"Hello World\"});\n\ndocument.body.appendChild(template(data));\n```\n<span line-highlight='2-3'></span>\n__Note:__ if you see dozens of errors in your console, you may need to set `system.npmAlgorithm` to `flat` in your `package.json` (see the [Steal docs](http://stealjs.com/docs/StealJS.quick-start.html#section_Setup) for more info).\n\n### Building for production\n\nStealJS’s [Moving to Production](https://stealjs.com/docs/StealJS.moving-to-prod.html)\nguide has instructions for how to create a production build.\n\n## webpack and npm\n\nInstall [can-core CanJS’s core modules] and webpack (with `raw-loader`) with npm:\n\n```\nnpm install can-component can-compute can-connect can-define can-route can-route-pushstate can-set can-stache can-stache-bindings --save\nnpm install webpack raw-loader --save-dev\n```\n\nNext, create a `main.stache` template for your app:\n\n```\n<!-- main.stache -->\n<h1>{{message}}</h1>\n```\n\nNext, create a `main` module for your application. Import [can-define/map/map], [can-stache], and your template to say “Hello World”:\n\n```\n// main.js\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\nvar data = new DefineMap({message: \"Hello World\"});\nvar template = stache(require('raw-loader!./main.stache'));\n\ndocument.body.appendChild(template(data));\n```\n\nNext, run webpack from the command line:\n\n```\n./node_modules/webpack/bin/webpack.js main.js bundle.js\n```\n\nFinally, create a page that loads `bundle.js`:\n\n```\n<html>\n  <body>\n    <script src=\"./bundle.js\" type=\"text/javascript\"></script>\n  </body>\n</html>\n```\n\n## Browserify and npm\n\nCanJS works with Browserify. Install [can-core CanJS’s core modules] and Browserify (with `stringify`) with npm:\n\n```\nnpm install can-component can-compute can-connect can-define can-route can-route-pushstate can-set can-stache can-stache-bindings --save\nnpm install browserify stringify --save-dev\n```\n\nNext, create a `main.stache` template for your app:\n\n```\n<!-- main.stache -->\n<h1>{{message}}</h1>\n```\n\nNext, create a `main.js` file for your application. Import [can-define/map/map], [can-stache], and your template to say “Hello World”:\n\n```\n// main.js\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\nvar data = new DefineMap({message: \"Hello World\"});\nvar template = stache(require(\"./main.stache\"));\n\ndocument.body.appendChild(template(data));\n```\n\nNext, change your `package.json` to include the required `stringify` configuration:\n\n```\n{\n  ...\n  \"devDependencies\": {\n    \"browserify\": \"^13.1.1\",\n    \"stringify\": \"^5.1.0\"\n  },\n  \"stringify\": {\n    \"appliesTo\": { \"includeExtensions\": [\".stache\"] }\n  }\n}\n```\n<span line-highlight='7-9'></span>\nNext, run Browserify from the command line:\n\n```\n./node_modules/browserify/bin/cmd.js -t stringify main.js > bundle.js\n```\n\nFinally, create a page that loads `bundle.js`:\n\n```\n<html>\n  <body>\n    <script src=\"./bundle.js\" type=\"text/javascript\"></script>\n  </body>\n</html>\n```\n\n## RequireJS\n\nRequireJS is no longer supported. If you would like to [guides/contributing/code contribute] the code required for AMD, please look at [this issue](https://github.com/canjs/canjs/issues/2646).\n\n## Script tags\n\n### npm\n\nYou can install CanJS with npm:\n\n```\nnpm install can --save\n```\n\nThe `node_modules/can/dist/global/` directory will include two files:\n- `can.all.js`: includes the [can-core core], [can-ecosystem ecosystem], and [can-infrastructure infrastructure] modules\n- `can.js`: includes the [can-core core] and [can-infrastructure infrastructure] modules\n\nWith `can` installed, you can use it in an HTML page with a `<script>` tag:\n\n    <html>\n    <head>\n        <title>CanJS</title>\n    </head>\n    <body>\n        <script src=\"./node_modules/can/dist/global/can.all.js\"></script>\n        <script type='text/stache' id='app'>\n        \t<hello-world/>\n        </script>\n\n        <script type=\"text/javascript\">\n            can.Component.extend({\n\t            tag: 'hello-world',\n\t            view: can.stache(\"<h1>{{message}}</h1>\"),\n\t            ViewModel: can.DefineMap.extend({\n\t\t            message: {\n\t\t                type: 'string',\n\t\t                value: 'Hello world'\n\t                }\n\t            })\n            });\n            document.body.appendChild(\n\t            can.stache.from(\"app\")()\n            );\n        </script>\n    </body>\n    </html>\n<span line-highlight='6-6'></span>\n### CDN\n\nAnother quick way to start locally is by loading CanJS from a CDN:\n\n    <html>\n    <head>\n        <title>CanJS</title>\n    </head>\n    <body>\n        <script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n        <script type='text/stache' id='app'>\n        \t<hello-world/>\n        </script>\n\n        <script type=\"text/javascript\">\n            can.Component.extend({\n\t            tag: 'hello-world',\n\t            view: can.stache(\"<h1>{{message}}</h1>\"),\n\t            ViewModel: can.DefineMap.extend({\n\t\t            message: {\n\t\t                type: 'string',\n\t\t                value: 'Hello world'\n\t                }\n\t            })\n            });\n            document.body.appendChild(\n\t            can.stache.from(\"app\")()\n            );\n        </script>\n    </body>\n    </html>\n<span line-highlight='6-6'></span>\n## A note on Promises\n\nCanJS uses native [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), which means you might see the following error in Internet Explorer 9 or later:\n\n```\n'Promise' is undefined\n```\n\nYou must include a Promise polyfill if you’re targeting browsers that do not have [native support](http://caniuse.com/#feat=promises). If you’re using [StealJS](http://stealjs.com/), [a Promise polyfill](https://github.com/stefanpenner/es6-promise) is included for you.\n\n",
    "description": "Get started with CanJS by installing it with [npm](https://www.npmjs.com/), using a [JS&nbsp;Bin](https://jsbin.com/about), or just adding it to an HTML page with a `<script>` tag. \n",
    "name": "guides/setup",
    "title": "Setting up CanJS",
    "type": "page",
    "parent": "guides/experiment",
    "order": 5,
    "outline": "2",
    "comment": " "
  },
  "guides/comparison": {
    "src": {
      "path": "docs/can-guides/introduction/comparison.md"
    },
    "body": "\n**CanJS** is a full **MVVM** library for creating fantastic web applications, but let’s face it, there are a lot of other frameworks that solve the same problem. These days, most of the **MV*** frameworks and libraries have some mechanism for creating **Custom Elements** for the browser and binding those elements to some sort of **observable state or data-store**, along with features like **routing** and connecting data to a **web service API**. The modern **MV*** frameworks are starting to look more and more similar, as concepts and features are shared between them, and the general needs of developers start to converge.\n\nYou should evaluate if a framework fits your mental model of how applications should be built, and to do that you’ll need to know the subtle but important differences that may not seem obvious at first glance.\n\nTwo of the most popular frameworks/libraries for building web applications are **[React](#React)** and **[Angular 2](#Angular2)**. So here are some comparisons you should consider when evaluating which framework to use to build your non-trivial application.\n\n## React\n\n**React** is really just the \"V in MVC\", while **CanJS** is a full **MVVM** library, so it may feel like we’re comparing apples to bananas, but there are certain tradeoffs that can be explored when comparing **CanJS** to **React**\n\nBecause **React** is only a view layer, there has been a deluge of competing libraries, each trying to establish itself as the de facto state management library for your **React** app. Some of the more popular libraries right now include **Redux**, **MobX**, **Alt**, **Reflux** and, of course, Facebook’s own **Flux** library (an implementation of their Flux architecture). Even frameworks like **Angular 2** and **CanJS** are joining in and making \"React friendly\" implementations.\n\nBut with all these choices and change, who is to say the state management library you pick for your **React** app will be around next year? The year after that? Things are moving so fast around the **React** ecosystem, it’s hard to see what it will look like in the coming years.\n\n**CanJS** has a historical track record providing a stable platform in a way **React** cannot, because **React** is too new and has a small focus, inviting an unstable ecosystem of tooling to form around it. Read more about our approach balancing stability and innovation [here](business-advantages.html).\n\nTo make a fair comparison, at times we will be referencing and comparing **CanJS** to **React-Redux**, arguably the most popular **Flux** implementation and state management library for **React** at this time\n\n### Observables\n\n**CanJS** has **observable** constructs that are powerful but still very easy to use.\n\n**React** has no real equivalent of observable state, and manages state changes through explicit calls to `render()` or `setState()`.\n\n**React-Redux** has a pattern for updating application state that is synchronous and uses pure functions, but it can be difficult to work with.\n\nThe synchronous data flow provided by the **Redux** store is generally insufficient for real web apps. The web is very async by nature, with it’s ajax calls, web-workers, web-sockets and all sorts of common APIs resolving asynchronously using events and callbacks. So you find yourself either writing a whole lot of code to manage your asynchronous action creation, or more likely you pull in asynchronous middleware like **redux-thunk**, **redux-promise** or **redux-rx**.\n\nSuddenly, the strict unidirectional data flow, is no longer that easy to follow, and you end up having to write a non-trivial amount of code to support the Redux pattern of dispatch -> action -> reducer -> state.\n\n```javascript\nconst ViewModel = DefineMap.extend({\n  subreddit: 'string',\n  posts: {\n    get(lastSetValue, resolve) {\n      this.postPromise\n        .then(response => resolve( response.json() ));\n    }\n  },\n  postsPromise() {\n    get() {\n      return fetch(`http://www.reddit.com/r/${this.subreddit}.json`)\n    }\n  }\n});\n```\n\nVS\n\n```javascript\nfunction requestPosts(subreddit) {\n  return {\n    type: REQUEST_POSTS,\n    subreddit\n  }\n}\n\nexport const RECEIVE_POSTS = 'RECEIVE_POSTS'\nfunction receivePosts(subreddit, json) {\n  return {\n    type: RECEIVE_POSTS,\n    subreddit,\n    posts: json.data.children.map(child => child.data),\n    receivedAt: Date.now()\n  }\n}\n\n// assumes thunkMiddleware is in use\nexport function fetchPosts(subreddit) {\n  return function (dispatch) {\n    dispatch(requestPosts(subreddit))\n    return fetch(`http://www.reddit.com/r/${subreddit}.json`)\n      .then(response => response.json())\n      .then(json =>\n        dispatch(receivePosts(subreddit, json))\n      );\n  }\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    posts: state.posts,\n    subredit: state.subredit\n  }\n}\n\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  return {\n    onTodoClick: (id) => {\n      this.props.dispatch(fetchPosts(ownProps.subreddit))\n    }\n  }\n}\n\nconst VisiblePostsList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(PostsList)\n\nexport default VisiblePostsList\n```\n\nThe functional aspects of **Redux** do have benefits to simplicity but there is obviously a trade-off, and you have to decide which way you prefer to attack simplifying the asynchronous and stateful demands of client side web UIs.\n\nUsing **MobX** observables with **React** is fairly popular, though not as popular as **Redux**, and could just as easily be compared to using **CanJS** observables with **React**, which is very possible and easy to do, because of **CanJS**’ modularity.\n\n### Data Fetching and Real-time Data\n\n**[Can-Connect](../../can-connect.html)** allows for **CanJS** **observables** to be connected to a data source such as an RESTful API or a real-time data stream, with advanced features like fall-through caching and batched minimal requests, so that your components can just request the data they need while can-connect figures out how to fetch that data in the most efficient way possible.\n\n**React**, being just a view layer, has no concept of this.\n\n**Relay**, a JavaScript framework for building data-driven **React** applications, has some very promising features, similar to can-connect, but requires you to implement a GraphQL server while **Can-Connect** can work with whatever data source or API you have.\n\nBeing tied directly to one particular type of back end service may end up with **Relay** being slightly easier to use, but **Can-Connect**’s flexibility, and it’s configurable integration points, will be valuable if you have different types of back-end services, like traditional REST APIs or you need to work with unique kinds of data stores.\n\n### One-Way Data Flow\n\nOne-Way data flow is touted as a benefit, that it simplifies the complexity of your UI state management. But if your problem is that state is changing unexpectedly or not changing when you think it should, maybe the solution is is to simplify your structure, not limit your tools.\n\nOne-Way data flow may be simpler to follow, but you end up writing a lot more code as a trade off. The reason 2-way binding became popular was that it removed a lot of boilerplate code: binding to a change, updating the state, updating any other dependants with the new state…etc.\n\n**CanJS** supports many types of data-bindings in our views, including one-directional, two-way binding, sibling-to-sibling value binding, and binding directly to DOM events. **CanJS** makes it easy to save writing a lot of code and keep your app simple to follow at the same time.\n\n```javascript\n// Binding to a Todo models completed property\nconst Todo = DefineMap.extend({\n  name: 'string',\n  completed: 'boolean'\n});\n\n// In stache\n{{#each todos}}\n<label><input type=\"checkbox\" {($checked)}=\"completed\" />{{ name }}</label>\n{{/each}}\n```\n\n**React** has a dedication to the one-way data flow. This leads to a lot of boilerplate, hooking up event handlers just to change the state, over and over everywhere. **Flux** and **React-Redux** follow this same principle and ends up with even more code: `actions`, which get sent to a `dispatcher`, which pass the `action` to a `store`, to finally set the `state`. More code to write, more places for bugs to hide.\n\n```javascript\n// minimal reducer\nconst todo = ( state, action ) => {\n  switch (action.type) {\n    case 'TOGGLE_TODO':\n      return Object.assign({}, state, {\n        completed: !state.completed\n      });\n    default:\n      return state;\n  }\n}\n\n// minimal mapStateToProps and mapDispatchToProps functions for container\nconst mapStateToProps = ( state ) => {\n  return {\n    todos: state.todos\n  };\n};\nconst mapDispatchToProps = ( dispatch, ownProps ) => {\n  return {\n    onChange(id) {\n      dispatch({\n        type: 'TOGGLE_TODO',\n        id\n      });\n    }\n  };\n};\n\nconst TodoListContainer = connect( mapStateToProps, mapDispatchToProps )( TodoList ) );\n\n// in JSX\nTodo = (props) => {\n  checkboxProps = {\n    checked: props.completed,\n    name = props.name,\n    onChange(event) {\n      props.onChange(props.name)\n    }\n  }\n  return <label><input type=\"checkbox\" ...checkboxProps />{ props.name }}</label>\n}\n```\n\nIf the problem is losing track of what is changing the state, is the problem solved by adding more code, or is it better solved with a simpler abstraction and more succinct code?\n\n### DOM Libraries and Memory Leaks\nSometimes you are not starting a brand new project, and you’d rather incrementally add your new framework to your existing app, rather than do a whole re-write. Maybe you are using [Bootstrap](http://getbootstrap.com/javascript/), or [jQuery](https://jquery.com/) plugins, and you’d rather not re-implement everything you have at once.\n\n**CanJS** makes working with other libraries seamless. You can just use [can-stache](../../can-stache.html) to add [can-components](../../can-components.html) custom elements into your page as needed, and since **CanJS** works with real DOM events and attributes, everything just works as expected.\n\nIf you are using [jQuery](https://jquery.com/), [jQuery plugins](https://plugins.jquery.com/) or [Bootstrap](http://getbootstrap.com/javascript/), CanJS has a library, [can-jquery](../../can-jquery.html), which was specifically created for apps using CanJS with jQuery, and allows all jQuery events or DOM manipulations to “just work” without any special code needed.\n\n```handlebars\n<!-- A Bootstrap Modal -->\n<div id=\"my-modal\" class=\"modal fade\">\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-body\">\n\n        <script type=\"text/stache\" can-autorender>\n          <!-- A CanJS user-form component -->\n          <user-form />\n        </script>\n\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">Close</button>\n        <button type=\"button\" class=\"btn btn-primary save\">Save changes</button>\n      </div>\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal-dialog -->\n</div><!-- /.modal -->\n\n<button class=\"btn btn-primary newuser\">New User</button>\n\n<script>\n$('.newuser').on('click', ev => { $(\"#my-modal\").modal('show'); });\n\n$(\"#my-modal\").on('show.bs.modal', ev => {\n  let modal = $(ev.currentTarget);\n  modal.find('button.save').on('click', ev => {\n    modal.find(\"user-form\").trigger('submit');\n    modal.modal('hide');\n  });\n});\n</script>\n```\n\n**React** replaces certain core aspects of the DOM, namely the event system and attributes, with its own “React version” of events and props. Because of this, **React** can have some frustrating “gotchas” when you try and integrate it with jQuery plugins or any other library that queries or manipulates the DOM.\n\nUsing `ReactDOM.render()` to insert **React** components in to your app, may even cause a [memory leak](http://www.ibm.com/developerworks/web/library/wa-memleak/). To prevent memory leaks when using **ReactDOM** this way, you need to be aware of and use `ReactDOM.unmountComponentAtNode()` every time a **React** node get’s deleted. This is important and often forgotten. Forgetting to call `unmountComponentAtNode` will cause your app to leak memory, so you’ll have to hook up this call, into your current app lifecycle.\n\n```handlebars\n// DO NOT DO THIS, THIS CAUSES A MEMORY LEAK\n<div id=\"dialog-form\" title=\"Create new user\">\n  <div class=\"react-user-form-component\"></div>\n</div>\n<button id=\"create-user\">Create new user</button>\n\n<script>\n// This will leak memory\nReactDOM.render( $('.react-user-form-component').get(0), UserFormComponent );\ndialog = $( \"#dialog-form\" ).dialog({\n  autoOpen: false,\n  modal: true,\n  buttons: {\n    \"Create an account\": dialog.find( \"user-form\" ).submit(),\n    Cancel: () => {\n      dialog.dialog( \"close\" );\n    }\n  }\n});\n$( \"#create-user\" ).button().on( \"click\", function() {\n  dialog.dialog( \"open\" );\n});\n</script>\n```\n\nConversely **CanJS** is aware of its own DOM removal, and will clean up any event handlers or bindings *automatically*.\n\nIf you have existing legacy code, you’ll probably want integrate your new framework progressively, a piece at a time, and it’s important that things “just work”, without any surprises or frustrations.\n\n### Encapsulation of Components\n\nThere is a trend in JavaScript these days towards small reusable modules, tiny components, and little composable functions. But as with everything in programming there are tradeoffs, and if your modules are all too small, too isolated, the effort of wiring them together to become useful becomes greater than the benefit of reusability.\n\nEncapsulation is one way to simplify your applications. By encapsulating modules and only exposing an api for input and output, your app becomes easier to reason as you can think about it in larger chunks that have their input and output defined. Having well encapsulated modules or components means you don’t have to hold all the details of the implementation in your head, just the parts that matter at the level you are using that module.\n\n**React-Redux** has chosen to model their encapsulation in layers.\n\n* There is the **View** layer which holds all the **React** components, action creators and the dispatcher\n\n* There is the **Store** layer which holds all the reducers and redux middleware.\n\nThese layers have a simple and inverse API, the Store layer takes actions and returns state, the View layer takes in state and returns actions (as the user takes action on the UI).\n\n<img src=\"../../docs/can-guides/images/introduction/redux-flow.png\" style=\"width:100%;max-width:750px\"/>\n\n...and there are layers *within those layers*, like **action creators** and **redux-middleware**.\n\nThis architecture is nice and simple, with discrete lines of interaction and well-defined purpose and interface. The **tradeoff** however, is that to add a feature you need to add **_all_** the individual pieces to each of these layers.\n\nTo illustrate the idea with an example you wanted to to add a \"live video chat\" feature to your app. Let’s pretend you have already implemented this sort of thing in some other app, so you are just going to reuse the shared portions of it for this app.\n\nLet’s say the video chat feature assumes there is a users model that hold the URL to the video stream for each user. Features of the Video-Chat include:\n\n* Adding and removing users to your video chat\n\n* Muting the microphone\n\n* Turning the camera on and off\n\nSo in your **React-Redux** app, you would at minimum need to import:\n\n* A video chat component\n\n* 8 action creators\n\n* 9 reducers\n\n<img src=\"../../docs/can-guides/images/introduction/video-chat-react.png\" style=\"width:100%;max-width:750px\"/>\n\n...and wire them all together with code. The wiring up is not free, and though simple, may produce bugs and there is no guarantee the individual bits will work well together.\n\n**CanJS** has a more cross-cutting encapsulation strategy. A can-component knows what data it accepts through **attrs**, and can fetch its own data with models as dependencies, and also handles the user interaction, state-changes and display all within the component.\n\nThe individual parts of a component follow the MVVM pattern, and so are decoupled and easily testable themselves, but act as a cohesive unit of functionality for sharing and reuse across the app.\n\nCan-Components can then be used in parent can-component’s views, who can pass the child components attrs through the template bindings, and the whole app can be composed as a tree of components and HTML elements, each acting as little apps themselves.\n\n<img src=\"../../docs/can-guides/images/introduction/canjs-flow.png\" style=\"width:100%;max-width:750px\"/>\n\nTo continue with the **Video-Chat** example above, sharing a video-chat component from one **CanJS** app to another would be far more straightforward. You would only have to import the 1 video chat component, and the only wiring necessary would be to pass in a list of Users to the video-component attrs.\n\n<img src=\"../../docs/can-guides/images/introduction/video-chat-canjs.png\" style=\"width:100%;max-width:750px\"/>\n\nEncapsulated modules, like **can-components**, have many advantages over monolithic layers, like the layers provided by **react-redux**.\n\nThe encapsulated components are easier to test. In the **react-redux** example, to run some black-box functional tests, you would have to pull in all the individual pieces and assemble them like a mini version of the app. The can-component on the other hand could just be imported and placed on the page, and have the tests run, because it encompasses all the behaviour it needs in one uni\n\nUsing encapsulated components makes it easier to find and fix bugs. Working across layers means understanding the different parts and how they work together, if something is broken you’ll have to check in several spots to see where the problem is coming from. When you fix bugs in layered code, you end up having to touch the code in many places, as opposed to the encapsulated module where all the related code is in one place. And touching different places in code increases the chances of having some unintended effect on downstream code, making it more fragile.\n\nWhen you are working in a team, the layered approach can be more risky, as you’ll all be working in the same code a lot, since layer fixes and features will always span multiple layers, and you’ll have a lot more opportunity for overlap, or having a negative effect on another person’s feature, leading to merge conflicts and potential bugs.\n\n**CanJS** chooses a pattern of encapsulated models over a layered architecture because they are easier to share, easier to test, easier to find and fix bugs in and easier to work together  on as a team.\n\n### Summary\n\n**React** is not really a full solution for building apps with web technology, and the **React** ecosystem is still the wild west when it comes to state management and supporting technologies.\n\n**CanJS** simplifies your code with it’s observables and component architecture.\n\n**CanJS** let’s you integrate with your existing project easier and lets you be confident you won’t be re-writing your app in a new JavaScript framework next year.\n\n## Angular 2\n\n**Angular 2 (ng2)** is actually very similar to **CanJS**, if you look at these two \"Hello-World\" components, you see just how aligned the concepts behind **Angular 2** and **CanJS** really are.\n\n```javascript\nimport Component from 'can-component';\nimport stache from 'can-stache';\n\nexport default Component.extend({\n  tag: \"hello-world\",\n  template: stache(`<h1 ($click)=\"emphasize()\">{{ message }}</h1>`),\n  viewModel: {\n    message: \"Hello world!\",\n    emphasize() {\n      this.message += '!';\n    }\n  }\n});\n```\n\n\nAND\n\n```javascript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'hello-world',\n  template: '<h1 (click)=\"emphasize()\">{{ message }}</h1>'\n})\nexport class HelloWorld {\n  message = 'Hello World!';\n  emphasize() {\n    this.message += '!';\n  }\n};\n```\n\nBecause it’s backed by Google, **Angular** is sometimes the \"go-to\" choice for teams developing web apps or web pages, but often it’s way more than what the project requires.\n\nThe steep learning curve, esoteric terminology, tricky syntax and concepts can end up slowing a team down far more than any benefit it provides. So it’s worth the effort to evaluate the framework and see if **Angular 2** is really what your team needs.\n\nThat being said, **Angular 2** also encompasses a lot more than just the **MV*** portion of the library: things like code generators, a dev-server, an SSR solution, and a system for script loading and dependency management. This makes **Angular 2** a lot more comparable to **CanJS**’s parent project [DoneJS](https://donejs.com/), but we can still evaluate the parts that *do* line up, to find the notable differences you need to make a proper comparison.\n\n### Longevity and Stability\n\nWhen evaluating **Angular 2** as an option, it is unwise not to consider the proverbial elephant in the room: \"Is this version going to stick around this time\"?\n\nGoogle and the Angular team released **Angular 2** as a complete re-write with no backwards compatibility, and no real plan for upgrading your application beyond running both Angular 1 and 2 on the same page until you can get all your directives and services migrated over to the new one. Google has a [history of abandoning projects](http://www.wordstream.com/articles/google-failures-google-flops), so you’ve got to ask: How long will it be until you’re rebuilding your app in the new, incompatible **ng3**?\n\nWith **CanJS** we have a guiding principle: You shouldn’t have to rewrite your application to keep pace with technology. We’re in it for the long haul, and dedicating to providing you stability and easy upgrades balanced with new features and progressive techniques in web development.\n\n### Modularity\n\nSometimes, you’re not building the next Gmail, you only have a few interactive forms on your site that could use some pizzaz. Sometimes, you already have a working app, and you want to move progressively into a new framework, not do a whole re-write of what is already working.\n\nThe key in these times, is to pick something you can use a piece at a time, as you need it, and pick the parts you need, without bringing in the kitchen sink. You’ll want modularity,\n\n**CanJS** is very modular. In **CanJS 3.0**, a lot of time was spent breaking out the useful parts of the system into modules and packages that can be used independently of each other but still work harmoniously together.\n\nFor example you could:\n\n* just use **can-compute** to quickly bind HTML inputs to observable values, giving you a nicer abstraction without a lot of event listeners and callback coordination\n\n* use **can-fixture** by itself to to mock out ajax and websocket requests for your tests\n\n* use only **can-connect** and **can-define** to create awesome observable models that are connected in realtime to your existing API\n\n* use just **can-route** to take advantage of state-based observable routes, for the easy url updating and decoupling the pattern provides\n\nAny individual or combination of modules will provide you a great tools for streamlining your web development, and together they become our own little \"Megazord” **CanJS**, greater than the sum of it’s parts\n\n**Angular 2** is more of an \"everything out of the box\" framework, where you get everything up front, and it all works together to help you develop more efficiently. The pieces and modules of Angular’s libraries are not really meant to be used on their own, and it would be hard to just extract the tiny bits you need without buying into the whole Angular framework.\n\nThere’s a [funny story](https://news.ycombinator.com/item?id=12692595) on Hacker News about JavaScript Expert whose performance improvements involved removing almost all the JavaScript on the site. The point is, you should know what you need, and include only the tools needed to get the job done, everything else is bloat.\n\n### Typescript\n\n**TypeScript** is a typed superset of JavaScript that compiles to plain JavaScript that offers optional static typing and type inference. But if you are not already using TypeScript, should your choice of framework decide that for you? Do you even want it?\n\n**CanJS** was created before ES6 and transpiling were prevalent in front-end JavaScript, so you don’t need TypeScript, though of course it would still would work with TypeScript if that was your preference.\n\nThough the **Angular 2** people have been assuring the general masses that \"you don’t **need** typescript to write **Angular 2** apps\", the fact is the framework was designed around embracing the syntactic allowances, like decorators and class fields, and if the framework to be presented without them it would look clunky and pretty verbose.\n\n```javascript\nconst HelloWorldComponent = ng.core.Component({\n  selector: 'hello-world',\n  template: '<h1>Hello {{name}}!</h1>' + '<input [(ngModel)]=\"name\">',\n  viewProviders: [GreetingService]\n}).Class({\n  constructor: [GreetingService, function(greetingService) {\n    this.greetingService = greetingService;\n    this.name = \"world\";\n  }\n});\n\nvar AppComponent = ng.core.Component({\n  selector: 'app',\n  template: '<hello-world></hello-world>',\n  directives: [HelloWorldComponent]\n}).Class({\n  constructor: function() {}\n});\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  ng.platform.browser.bootstrap(AppComponent);\n});\n```\n\nTypeScript may offer all sort of benefits, especially for large apps with multiple teams working on them, but it’s more unnecessary baggage if you weren’t using typescript already.\n\n### Dependency Injection\n\nDependency Injection (**DI**) *as a pattern* can provide decoupling from your dependencies, and allow a flexibility of configuration for your modules, but **DI** *as a framework* adds additional verbosity and configuration all over your application. In JavaScript, a **DI framework** is useful in only rare cases, due to the flexibility of the language so, in the end, is it really worth it to have all the extra code and complexity?\n\n**CanJS** chooses not to include a Dependency Injection framework, opting instead for the developer to decide if they need any more DI than JavaScript can already provide. JavaScript’s prototypal inheritance and mutable runtime instances can serve 90% of the uses for Dependency Injection, and if the developer decided they need a DI library they are free to add their own.\n\n**Angular 2** has doubled down on Dependency Injection, making every part of it’s design incorporate providers, services, and an injection syntax. This creates an odd pattern in **Angular 2** where not only do you have to import a component or service and use it, you also have to declare the provider for it, often just passing the class as a shorthand.\n\nNote in the example below `FriendService` is imported, used *and also* needs to be declared in the `providers` metadata:\n\n```javascript\nimport { Component } from '@angular/core';\nimport { FriendService } from 'app/friend.service';\n\n@Component({\n    selector: 'my-friends',\n    providers : [FriendService],\n    template: `\n        <div *ngFor=\"#f of friends\">\n          <h4> Name : {{f.name}} </h4> <h4>Age: {{f.age}}</h4>\n        </div>\n    `\n})\nexport class FriendComponent {\n    constructor(_friendService: FriendService) {\n        this.friends = _friendService.getFriends();\n    }\n}\n```\n\nA Dependency Injection system may have a place in other languages, like Java, but JavaScript can handle the pattern easily already. The DI System just ends up being extra syntax, and a there is a confusing loss of clarity when the classes and types imported into the class definition may not actually be the classes used to produce the dependency instance.\n\n*See the above code example, and realize that `FriendService`, may in some instances not actually be used in the `FriendComponent`, if some parent module defines a different provider for `FriendComponent`*\n\n### Steep Learning curve\nAngular is known for it’s steep learning curve, and Angular 2 doesn’t really break that reputation.\n\nThere are a whole lot of new things a developer must learn to become effective with\nAngular 2. You have to learn the TypeScript syntax, all the examples are written\nin it so you’re going to have trouble if you skip this step. The Dependency Injection\nsystem is so ingrained, you must learn early how it works, and the syntax involved\njust to get going. There is the templating system, the decorators/annotations, a\n[wealth of APIs and modules](https://angular.io/docs/js/latest/api/), and the kicker\nof it all is, because of the “all-or-nothing” nature of Angular 2, you have to learn a\nwhole lot of it, just to get started.\n\nCanJS also has many different modules and APIs to learn, but because of CanJS’s modular and individually packaged libraries, you only have to learn what you need, when you need it. There is no new \"transpile-to-js\" language to learn and no Dependency Injection framework to understand before you can start creating your components and composing your apps.\n\nIf your team needs to get started quickly, and hit the ground running, Angular 2 may not be the best choice, but CanJS just might be the right fit for your team.\n\n### Data Fetching and Real-time Data\n\n**[Can-Connect](../../can-connect.html)** allows for **CanJS** **observables** to be connected to a data source such as an RESTful API or a real-time data stream, with advanced features like fall-through caching and batched minimal requests, so that your components can just request the data they need while can-connect figures out how to fetch that data in the most efficient way possible.\n\n**Angular 2**’s HTTP Service doesn’t have the advanced features like minimal requests and fall-through caches, and any real-time data-source would require you to write a custom service.\n\n### Summary\n\n**Angular 2** is not the safe bet you may be hoping it is. Google wouldn’t hesitate to drop it entirely when it no longer serves their purpose, it’s got a steep learning curve, and lot of features that you may not want or need.\n\n**CanJS** has a mission to be the stable platform for you to develop your web apps on for years to come. It’s modular enough to take only the parts you need as you need them. It has all the features you need and doesn’t force you into patterns or technologies you don’t.\n\n## Non-technical comparison\n\nIf none of the technical arguments convince you to give CanJS a try, consider this: all the modern frameworks have more or less converged in 2016. You can build a very similar application, with routing, observables, models, and server side rendering (with some exceptions) with Angular 2, several of the React frameworks, Ember, or CanJS. Therefore, the MOST important factor, even beyond small technical differences, is the stability and stability of the framework. You want to bet on a horse that you can ride into the future, not the horse that looks prettiest today.\n\nCanJS’s mission is to __minimize the cost of building and maintaining\nJavaScript applications by balancing innovation and stability, helping developers transcend a changing technology landscape__. We’ve spent the past 9 years focused on balancing these two oppoising goals, and have the track record to prove it. Read in more detail on our [mission page](mission.html).\n\nThere’s no advantage to choosing projects maintained by a big company, since big companies often kill platforms that many developers have invested in.\n\n<img src=\"../../docs/can-guides/images/introduction/framework-death.png\" style=\"width:100%;max-width:650px\"/>\n\nThere’s no advantage to choosing a framework with a large community, since communities are fickle and change yearly.\n\nThere’s no advantage to choosing a framework based on ability to hire devs that list X on their resume, since any competent JavaScript developer can be equally effective in any modern framework with a couple days of learning.\n\nThis is why CanJS has a stellar reputation with [enterprise companies](who-uses.html). Stability and longevity are critical factors to your application’s success.\n\n",
    "description": "\n",
    "name": "guides/comparison",
    "title": "Comparison to Other Frameworks",
    "type": "page",
    "parent": "guides/introduction",
    "order": 5,
    "hide": true,
    "comment": " "
  },
  "guides/mission": {
    "src": {
      "path": "docs/can-guides/introduction/mission.md"
    },
    "body": "\nCanJS’s mission is to __minimize the cost of building and maintaining\nJavaScript applications by balancing innovation and stability, helping developers transcend a changing technology landscape__.\n\nYou shouldn’t have to rewrite your application to keep pace with technology.\nWe constantly integrate new ideas and evolving best practices into CanJS libraries,\nbut in a responsible way that makes it possible to\nupgrade gracefully. We aim to provide a stable\nand innovative platform, so you can block out noise and stay focused your app, not the tools.\n\n<img\n    srcset=\"../../docs/images/home/Home-Tortoise-color.png 1x, ../../docs/images/home/Home-Tortoise-color-x2.png 2x\"\n    src=\"../../docs/images/home/Home-Tortoise-color.png\"\n    style=\"float:right; padding-right: 40px;\"/>\n<img\n    srcset=\"../../docs/images/home/Home-Hare-color.png 1x, ../../docs/images/home/Home-Hare-color-x2.png 2x\"\n    src=\"../../docs/images/home/Home-Tortoise-color.png\" style=\"padding-left: 40px;\"/>\n\n[//]: # (ANIMATION: Smooth ride, looking out the window, while hurricane of JavaScript logos and terminology passes by outside the window. Vehicle has an arrow pointing forward towards progress.)\n\nKeep reading to learn why our mission is important\nand how we’ve fared in realizing it:\n\n- [Stability and innovation matter](#Stabilityandinnovationmatter) — Why stability and innovation are the two most important factors in minimizing the cost of building and maintaining JavaScript applications.\n- [Stability is difficult in the JavaScript community](#StabilityisdifficultintheJavaScriptcommunity) — Why the JavaScript community sees a never-ending stream of frameworks and suffers from _JavaScript Framework Fatigue_.\n- [Our history of stability and innovation](#Ourhistoryofstabilityandinnovation) — How we’ve managed to\n keep innovating for 10 years (while still providing a viable upgrade path) and what we’re doing now to make CanJS even more stable moving forward.\n\n## Stability and innovation matter\n\nStability and innovation are often conflicting goals, but they are both critical\nfactors to application success.  Application development lifecycles\ncan last years, so it’s important that code written today will be relevant\ntomorrow. Yet technology changes quickly, especially in JavaScript.\nNew technology brings better techniques and is critical for developer happiness\nand retention.\n\nWhen starting a new application, it’s easy to forget that the majority of development happens after\nthe application is released. Many frameworks, after a short period of popularity, either:\n\n - End up getting replaced by a _hot new_ framework.\n - Release a major version that not even _remotely_ backwards-compatible with the previous version.\n\nProductivity-wise, over the life of your application, that ends up looking like this:\n\n<img src=\"../../docs/can-guides/images/introduction/betting-bomb-2.png\" style=\"width:100%;max-width:650px\"/>\n\nOr like this:\n\n<img src=\"../../docs/can-guides/images/introduction/betting-bomb.png\" style=\"width:100%;max-width:650px\"/>\n\n\nWhat is needed is a balance of innovation and stability, where developer productivity\nincreases over time, but doesn’t take large steps backward.  That looks something like this:\n\n<img src=\"../../docs/can-guides/images/introduction/good-bet.png\" style=\"width:100%;max-width:650px\"/>\n\nThis is our mission.\n\n## Stability is difficult in the JavaScript community\n\nYou may be familiar with the\n[never-ending stream](https://medium.freecodecamp.com/javascript-fatigue-fatigue-66ffb619f6ce#.n5tt0jqhf) of [hot new JavaScript frameworks](http://www.allenpike.com/2015/javascript-framework-fatigue/)\nthat take our community by storm every one or two years.\n\n> SproutCore -> Knockout -> Backbone -> Angular -> React -> ?\n\nThis isn’t surprising.  Consider how many different programming languages you can use\non the server-side: Java, Ruby, Python, C#, Haskell, etc.  There is only one JavaScript. Innovation\nis going to move at a blistering pace.  We should embrace it.\n\nBut, the blistering pace of innovation also means that most frameworks will emerge with one\nrevolutionary feature and then fade as the\nnext revolutionary framework emerges.  Instead of the old framework adopting new ideas, the community and its attention move onto the next _hot_ framework.\n\nThis makes it difficult to avoid stagnation in any community-driven tool over a long period of time.\n\n## Our history of stability and innovation\n\nCanJS has been helping developers transcend the [constantly changing technology landscape](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.lrntx9nby)\nfor over 10 years.  Read on to learn about:\n\n - Our history of stability.\n - Our history of innovation.\n - How 3.0 improves stability and innovation.\n\n### Our history of stability\n\nCanJS has been around since 2007. CanJS was originally called [JavaScriptMVC](http://javascriptmvc.com).  In 2012, JavaScriptMVC was split up into several pieces, including CanJS. Every year, we have improved CanJS by incorporating new best practices and ideas from the larger JavaScript community, while not leaving behind our existing users. The result has been a viable upgrade path for over 10 years!\n\n<img src=\"../../docs/can-guides/images/introduction/best-bet.png\" style=\"width:100%;max-width:650px\"/>\n\nMajor releases are not fully backwards-compatible, but it was possible to transition with\nlimited effort.\n\nLet’s see how one piece of CanJS, [can-control], evolved over this time.\n\n__In 2007__, using JavaScriptMVC 1.0, to listen to when any element\nthat matches the selector `.todos li.complete` is clicked, you might have written something like the following:\n\n```js\nnew MVC.Controller('todos',{\n    \"li.complete click\": function(el, ev){\n        // DO STUFF\n    }\n});\n```\n\nJavaScriptMVC was one of the first libraries to support event delegation,\nbut these old controls weren’t extensible and couldn’t work in an isolated\ncontext.\n\n__In 2009__, [jQuery](http://jquery.com) began to dominate JavaScript development.\nWe helped add event delegation to jQuery and integrated it into JavaScriptMVC 2.0.\nThe previous code became:\n\n```js\n$.Controller.extend(\"TodosController\",{\n    \"li.complete click\": function(el, ev){\n        // DO STUFF\n    }\n});\n\n$(\".todos\").todos_controller();\n```\n<span line-highlight='1,7'></span>\n__In 2012__, using CanJS 1.0, this became:\n\n```js\nTodosController = can.Control.extend({\n    \"li.complete click\": function(el, ev){\n        // DO STUFF\n    }\n});\n\nnew TodosController(\".todos\");\n```\n<span line-highlight='1,7'></span>\n__In 2013__, we released CanJS 2.0, and transitioned to\n[can-component]s instead of [can-control]s.  But even now, almost 10 years later,\nto make that `MVC.Controller` work in CanJS 3.0,\nyou could update it to the following:\n\n```js\nvar Control = require(\"can-control\");\n\nvar TodosController = Control.extend({\n    \"li.complete click\": function(el, ev){\n        // DO STUFF\n    }\n});\n\nnew TodosController(document.querySelector(\".todos\"));\n```\n<span line-highlight='1,3,9'></span>\nThis is one of many examples of CanJS’s code undergoing significant\nimprovements and changes, while still keeping it possible to upgrade your application.\n\nFor teams upgrading to `3.0`, we created multiple [migrate-3 migration paths]\nso upgrading can be done incrementally.  \n\n\n### Our history of innovation\n\nOver the past 9 years of CanJS, the web has evolved, and the best practices in JavaScript application development have changed. As these changes have occurred, CanJS has filtered out the very best ideas and practices, and implemented them in evolving APIs.\n\nTo name a few:\n- Event delegation became a best practice for managing events around 2009. CanJS added support for event delegation in 2008, before jQuery landed support.  Later, when jQuery became ubiquitous, we\n integrated jQuery into CanJS.\n- RESTful APIs eventually became the best practice for designing a backend interface. [can-model](//v2.canjs.com/docs/can.Model.html) in 2010 provided ActiveRecord style abstractions around this pattern.\n- Data bindings hit the mainstream in 2013 when Angular rose in popularity. CanJS landed support for this feature in 2011 with [can-ejs].\n- Building UI widgets as HTML custom elements, similar to web components, has become a best practice. [can-component] landed in 2013 to support this architecture.\n- In 2015, CanJS landed support for using a Virtual DOM and simple server-side rendering with [can-vdom].\n- In early 2016, CanJS added real-time support and advanced caching technology with [can-connect].\n- In late 2016, CanJS added a more powerful [can-define observable type] and enabled it to use\n  [can-define-stream functional reactive programming techniques].\n\nThis timeline shows more examples:\n\n<iframe src=\"https://cdn.knightlab.com/libs/timeline/latest/embed/index.html?source=1lBdurIQbbJkTZ8_kCQaXZtFaD06ulMFAlkqyEmXH4k0&amp;font=Bevan-PotanoSans&amp;maptype=toner&amp;lang=en&amp;start_at_slide=3&amp;height=650&amp;start_zoom_adjust=-2\" width=\"100%\" height=\"650\" style=\"max-width:800px\" frameborder=\"0\"></iframe>\n\n\n### How 3.0 improves stability and innovation\n\nCanJS 3.0 has been reorganized into several different dozen independent repositories,\neach with its own npm package and version number using [Semantic Versioning](http://semver.org/).\nOrganizing CanJS into individual repositories will improve\nCanJS’s stability and innovation going forward.\n\n#### Stability\n\nIndependent repositories improve stability because they make it easier to upgrade\nmore frequently. For example,\ncompare upgrading a 2.3 app to upgrading a 3.0 app.\n\nDespite making relatively few breaking changes, and\nproviding a [migrate-3 migration guide], upgrading from CanJS 2.3 to 3.0 looks like\na big step:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-3-upgrade.png\" style=\"width:100%;max-width:450px\"/>\n\nBut if you break that step down, CanJS 2.3 is mostly CanJS 3.0 with a bunch of bug\nfixes, a heap of new features, and a few breaking changes.  Most of the difficulties\nupgrading are the breaking changes, which account for the majority of the upgrade step size:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-upgrade-breakdown.png\" style=\"width:100%;max-width:450px\"/>\n\nCurrently, to get all of those bug fixes and new features, you have to\ntake on those breaking changes all at once.  Depending on your company culture,\nand scale of your application, this might not be easy.\n\nGoing forward in CanJS 3.0, packages are released independently of\neach other.  You can upgrade to bug fixes and new features\nimmediately and delay breaking changes (example: `can-route 4.0.0`) until later. You can upgrade breaking changes in steps too.  For example,\nyou might upgrade to `can-route 4.0.0` one month and `can-component 4.0.0`\nthe following month.  CanJS 3.0’s upgrade path might look like:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-upgrade-new.png\" style=\"width:100%;max-width:450px\"/>\n\nIndependent repositories also mean that [can-legacy legacy] libraries (like [can-ejs]) can continue\nliving through community-driven fixes and releases.  Legacy libraries don’t die simply because\nthey’re no longer included in the core CanJS build.\n\n#### Innovation\n\nIndependent repositories enable CanJS to innovate faster for several reasons:\n\n- Supporting [can-legacy legacy] libraries, like [can-ejs], will not slow down the\n  development of other libraries.\n- Experiments like [can-stream-kefir], where a lot of innovation happens, can be\n  released and have breaking changes without having to “get in” breaking changes\n  in the core and infrastructure libraries.\n- CanJS doesn’t feel as monolithic, appealing to developers using\n  just one part.  More users means more contributors.\n\nThe shift to independent repositories was CanJS 3.0’s biggest undertaking and\narguably biggest feature. This fact underscores how important our goal\nof balancing innovation and stability is to us. For more nuts-and-bolts features of CanJS,\nplease read [guides/technical CanJS’s Technical Highlights].\n\n",
    "description": "Learn about CanJS’s mission, why it matters, and how we’ve worked (and will keep working) to accomplish it.\n\n\n",
    "name": "guides/mission",
    "title": "Mission",
    "type": "page",
    "parent": "about",
    "order": 0,
    "comment": " "
  },
  "guides/technical": {
    "src": {
      "path": "docs/can-guides/introduction/technical.md"
    },
    "body": "\n\n## Browser and Environment Support\n\nCanJS supports:\n\n - Latest Chrome, Firefox, Edge, Safari\n - IE9+\n - iOS Safari 10+\n - NodeJS 6+ with [can-vdom] as a document.\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/canjs.svg)](https://saucelabs.com/u/canjs)\n\n## Phenomenal Features, Small Size\n\nThe [can-core core] of CanJS is under 50KB (gzipped). While there may be smaller architectural libraries, there are not other frameworks that provide comparable functionality. For custom elements, observables, live binding, routing, a model layer with intelligent caching and real-time support, 50KB is very small.\n\njQuery 3.1 is 30KB minified and gzipped, and that is only providing DOM utilities. CanJS implements its own DOM utilities, in addition to much more.\n\nEmber 2.9 is 108KB minified and gzipped, providing a comparable feature set.\n\nReact 15.3 is 44KB minified and gzipped, yet React is, on its own, simply a View layer.\n\nThe Angular 2’s Hello World app, provided by the angular-cli, is ~100KB minified and gzipped.\n\n## Independent Repositories and Packages\n\nCanJS 3.0 is maintained in independent repositories,\neach with its own npm package and [semantic version](http://semver.org/) number.\nOrganizing CanJS into individual repositories and packages has many benefits.  \n\nThe obvious advantage is that pieces can be used without the whole. You can choose to use CanJS’s observables or [can-fixture] without the rest of the framework. You could even mix and match CanJS libraries with other libraries like React quite easily.\n\nHowever, the main benefit is that independent repositories\nimprove CanJS’s stability — one half of CanJS’s [guides/mission mission]. This is\nbecause independent repositories make it easier to upgrade more frequently. For example,\ncompare:\n\n- Upgrading a 2.3 app, which was not organized in individual repositories, to\n- Upgrading a 3.0 app.\n\nDespite making relatively few breaking changes, and\nproviding a [migrate-3 migration guide], upgrading from CanJS 2.3 to 3.0 looks like\na big step:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-3-upgrade.png\" style=\"width:100%;max-width:450px\"/>\n\nBut if you break that step down, CanJS 2.3 is mostly CanJS 3.0 with a bunch of bug\nfixes, a heap of new features, and a few breaking changes.  Most of the difficulties\nupgrading are the breaking changes, which account for the majority of the upgrade step size:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-upgrade-breakdown.png\" style=\"width:100%;max-width:450px\"/>\n\nTo get all of those bug fixes and new features in 3.0, you have to\ntake on those breaking changes from 2.3 all at once.  Depending on your company culture,\nand scale of your application, this might not be easy.\n\nGoing forward in CanJS 3.0, packages are released independently of\neach other.  You can upgrade to bug fixes and new features\nimmediately and delay breaking changes (example: `can-route 4.0.0`) until later. You can upgrade breaking changes in steps too.  For example,\nyou might upgrade to `can-route 4.0.0` one month and `can-component 4.0.0`\nthe following month.  CanJS 3.0’s upgrade path might look like:\n\n<img src=\"../../docs/can-guides/images/introduction/mission-stability-upgrade-new.png\" style=\"width:100%;max-width:450px\"/>\n\nIndependent repositories also mean that [can-legacy legacy] libraries, like [can-ejs] can continue\nliving through community-driven fixes and releases.  They don’t die simply because\nthey are no longer included in the core CanJS build.\n\n## Flexible Features\n\nNo framework can perfectly satisfy every application\nrequirement.  Often, a framework can’t even satisfy all the requirements\nfor a single application. When this happens, it’s nice to have a framework that can\nflexibly adapt to the challenge.  The sections below have\nmany examples of this flexibility:\n\n- CanJS can be both [object-oriented and functional](#Objectorientedandfunctional),\n  imperative and declarative.\n- CanJS’s MVVM [observables are useful outside the framework](#Flexible).\n- CanJS [integrates with jQuery](#jQueryintegration), making DOM-centric development easier.\n\nThere are a bunch of other ways that CanJS makes it easy to develop outside the box:\n\n - [can-control] can handle when DOM-centric programming is necessary.\n - [can-compute] can be wired up to anything.\n - The [can-infrastructure] collection has a number of utility libraries that\n   can help jump-start development.\n\n## Cool Computes\n\nCanJS has two powerful observable systems that are the foundation for many of the other\ncore libraries:\n\n - [can-compute] - Observable values and derived observable values.\n - [can-define] - Observable objects.\n\nThis section is about the technical highlights of [can-compute].  However,\nas [can-define] uses computes internally for [computed getter properties](#Computedgetterproperties)\nand [asynchronous computed getter properties](##Asynccomputedgetterproperties), the benefits\nof computes extend to [can-define]. In a few examples cases, we’ll use [computed getter properties](#Computedgetterproperties) to\nshow the advantages of computes.\n\n[can-compute] is used in similar situations as event streams libraries like RXJS and Bacon.js. Computes\nare used to transform a set of observable values into another observable value.  While event stream libraries are able to set up more complex transformations, computes can set up simple but common transformations more easily.\n\nFor example, the following compute keeps the completed count of todos in a list:\n\n```js\nvar DefineList = require(\"can-define/list/list\");\nvar DefineMap = require(\"can-define/map/map\");\nvar compute = require(\"can-compute\");\n\nvar todoList = new DefineList([\n    {name: \"dishes\",  complete: true},\n    {name: \"laundry\", complete: false}\n]);\n\nvar completedCount = compute(function(){\n    return todoList.filter(function(todo){\n        return todo.complete;\n    });\n})\n```\n\n`completedCount` is updated when any todo’s `complete` property changes like:\n\n```js\ntodoList[0].complete = false;\n```\n\nOr a todo is added to or removed from the list like:\n\n```js\ntodoList.push({name: \"learn about computes\", complete: true})\n```\n\n`completedCount` automatically listens to all of these changes because\n[can-compute] infers dependencies.  Computes also:\n\n - [Cache their value](#Cachedvalues) for faster reads.\n - [Dispatch events synchronously](#Synchronous) for easier testing and debugging.\n - [Update only once for batched changes](#Batchedevents) for faster updates.\n\n### Inferred dependencies\n\nIn event stream libraries or other computed libraries, you must declare your\ndependencies like:\n\n```js\nvar fullNameStream = Kefir.combine(firstNameStream, lastNameStream, function(firstName, lastName){\n    return firstName + \" \" + lastName;\n});\n```\n\nor like:\n\n```js\nfullName: Ember.computed('firstName', 'lastName', function() {\n\treturn this.get('firstName')+\" \"+this.get('lastName');\n});\n```\n\n[can-compute] infers its own dependencies without needing to explicitly declare them, therefore requiring less boilerplate code. This means you can write `fullName` like:\n\n```js\nvar fullName = compute(function(){\n    return firstName() + \" \" + lastName();\n});\n```\n\nor like:\n\n```js\nPerson = DefineMap.extend({\n    firstName: \"string\",\n    lastName: \"string\",\n    get fullName() {\n        return this.firstName + \" \" +this.lastName;\n    }\n});\n```\n\nThis ability is especially useful when the dependencies are dynamic as in the\nfollowing `completedCount` example:\n\n\n```js\nvar todoList = new DefineList([\n    {name: \"dishes\",  complete: true},\n    {name: \"laundry\", complete: false}\n]);\n\nvar completedCount = compute(function(){\n    return todoList.filter(function(todo){\n        return todo.complete;\n    });\n})\n```\n\nWhen todos are added to and removed from `todoList`, `completedCount`\nwill update its bindings automatically.\n\n\n### Cached values\n\nOnce a compute is bound (using [can-compute.computed.on] or [can-compute.computed.addEventListener]), it immediately calculates its\nvalue and caches it so any future reads will use the cached value.\n\nIn the following example, before `fullName` is bound,\n`fullName`’s value is recalculated every time it is read.  After `fullName` is bound,\nits value is recalculated only when a dependent value changes.\n\n```js\nvar compute = require(\"can-compute\");\nvar firstName = compute(\"Payal\");\nvar lastName = compute(\"Meyer\");\n\nvar fullName = compute(function(){\n    console.log(\"Calculating fullName.\");\n    return firstName()+\" \"+lastName();\n});\n\nfullName() // console.logs \"Calculating fullName.\"\n           //-> \"Payal Meyer\"\n\nfullName() // console.logs \"Calculating fullName.\"\n           //-> \"Payal Meyer\"\n\nfullName.on(\"change\", function(){}) // console.logs \"Calculating fullName.\"\n\nfullName() //-> \"Payal Meyer\"\nfullName() //-> \"Payal Meyer\"\n\nfirstName(\"Ramiya\") // console.logs \"Calculating fullName.\"\n\nfullName() //-> \"Ramiya Meyer\"\n```\n\nUsing cached values improves performance in situations where a computed value is frequently read by multiple parts of the application.  \n\n### Synchronous\n\nCanJS observables synchronously notify any event listeners. This makes testing\nand debugging quite easier.\n\nThe following example shows how you can\nchange the `firstName` value and immediately check the consequences of that change:\n\n```js\nvar stache = require(\"can-stache\");\nvar compute = require(\"can-compute\");\n\nvar template = stache(\"<h1>Welcome {{fullName}}</h1>\");\n\nvar firstName = compute(\"Justin\");\nvar lastName = compute(\"Meyer\");\n\nvar fullName = compute(function(){\n    return firstName()+\" \"+lastName();\n});\n\nvar frag = template({fullName: fullName});\n\nassert.equal(frag.firstChild.innerHTML, \"Welcome Payal Meyer\");\n\nfirstName(\"Ramiya\");\n\nassert.equal(frag.firstChild.innerHTML, \"Welcome Ramiya Meyer\");\n```\n\n### Batched events\n\nThe previous section highlighted that synchronous event\n[can-event/batch/batch.dispatch dispatching] and DOM updates are ideal for many scenarios. But, there are times where this can cause performance problems. To prevent unnecessary updates, events can be batched using [can-event/batch/batch.start batch.start] and [can-event/batch/batch.stop batch.stop]. Computes and the DOM will only be updated once for all changes within the batch.\n\nIn the previous example, `{{fullName}}` would be updated twice\nif `firstName` and `lastName` are changed:\n\n```js\nfirstName(\"Payal\");\nlastName(\"Shah\");\n```\n\nWrapping this in a batch makes `{{fullName}}` update only once:\n\n\n```js\nvar batch = require(\"can-event/batch/batch\");\n\nbatch.start();\nfirstName(\"Payal\");\nlastName(\"Shah\");\nbatch.stop();\n```\n\nUsing [can-event/batch/batch.start batch.start] and [can-event/batch/batch.stop batch.stop]\ncan even make quadratic updates (`O(n^2)`) become linear (`O(n)`).\n\nConsider the performance of a `completeAll` method that completes every todo in a list\nand a `completeCount` compute that calculates the number of complete todos:\n\n```js\nvar todoList = new DefineList([\n    {name: \"dishes\",  complete: false},\n    {name: \"laundry\", complete: false}\n]);\n\nvar completeAll = function(){\n    todoList.forEach(function(todo){\n        console.log(\"completing\", todo.name)\n        todo.complete = true;\n    });\n};\n\nvar completedCount = compute(function(){\n    return todoList.filter(function(todo){\n        console.log(\"  checking\", todo.name);\n        return todo.complete;\n    });\n});\n\ncompletedCount.on(\"change\", function(ev, newVal){\n    console.log(\"completedCount is\", newVal);\n});\n```\n\nIf `completeAll` is called, the following will be logged:\n\n```\ncompleteAll();\n// console.logs \"completing dishes\"\n// console.logs \"  checking dishes\"\n// console.logs \"  checking laundry\"\n// console.logs \"completedCount is 1\"\n// console.logs \"completing laundry\"\n// console.logs \"  checking dishes\"\n// console.logs \"  checking laundry\"\n// console.logs \"completedCount is 2\"\n```\n\nThis means that every time a todo is marked as complete, `completedCount` loops\nthrough every todo.\n\nHowever, changing `completeAll` to use `batch.start` and `batch.stop` like:\n\n```js\nvar completeAll = function(){\n    batch.start();\n    todoList.forEach(function(todo){\n        console.log(\"completing\", todo.name)\n        todo.complete = true;\n    });\n    batch.stop()\n};\n```\n\nmeans `completeAll` will log the following:\n\n```js\ncompleteAll();\n// console.logs \"completing dishes\"\n// console.logs \"completing laundry\"\n// console.logs \"  checking dishes\"\n// console.logs \"  checking laundry\"\n// console.logs \"completedCount is 2\"\n```\n\n[can-event/batch/batch.start batch.start] and [can-event/batch/batch.stop batch.stop]\ncan improve performance by preventing compute recalculations.\n\n## Outstanding Observable Objects\n\n[can-define] is used to create observable [Models](#MalleableModels) and [ViewModels](#VeraciousViewModels) like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Person = DefineMap.extend({\n    first: \"string\",\n    last: \"string\",\n    get fullName(){\n        return this.first + \" \" + this.last;\n    }\n})\n```\n\n[can-define] uses [can-compute] internally to support [computed getter properties](##Computedgetterproperties) like the previous example’s `fullName`, so make sure to read about the benefits of [cool computes](#CoolComputes).\n\nAs [can-define] powers almost everything in a CanJS application, it has grown to be\nquite powerful, performant and flexible.  Read on to explore some of its best characteristics.\n\n### Expressive property definition syntax\n\n[can-define] supports an expressive, powerful syntax for defining properties on observable objects and lists. It supports [can-define.types.get getter], [can-define.types.set setter],\ninitial [can-define.types.value], and [can-define.types.type] conversion, [can-define.types.serialize]\nand [can-define-stream.stream] behaviors.\n\nThe following illustrates the signatures of these behaviors:\n\n```js\nDefineMap.extend({\n    propertyName: {\n        get: function(lastSetValue, resolve){ ... },\n        set: function(newValue, resolve){ ... },\n        type: function(newValue, propertyName){ ... },\n        Type: Constructor,\n        value: function(){ ... },\n        Value: Constructor,\n        serialize: function(){ ... },\n        stream: function(setStream){ ... }\n    }\n})\n```\n\n[can-define] also supports a wide variety of short hands for setting up these\nbehaviors. The following illustrates some of these behaviors:\n\n```js\nDefineMap.extend({\n    propertyA: Object      -> PropertyDefinition\n    propertyB: String      -> {type: String}\n    propertyC: Constructor -> {Type: Constructor}\n    propertyD: [PropDefs]  -> {Type: DefineList.extend({\"#\": PropDefs})>}\n    get propertyE(){...}   -> {get: propertyE(){...}}\n    set propertyF(){...}   -> {get: propertyF(){...}}\n    method: Function\n})\n```\n\nPutting it together, the following defines an `Address` and `Person` type with some nifty features:\n\n```js\n// Address has a street, city, and state property\nvar Address = DefineMap.extend({\n    street: \"string\",\n    city: \"string\",\n    state: \"string\"\n})\n\nvar Person = DefineMap.extend({\n    // first is a string\n    first: {type: \"string\"},\n    // last is a string\n    last: \"string\",\n    // fullName is the combination of first and last\n    get fullName(){\n        return this.first+\" \"+this.last;\n    },\n    // age is a number that defaults to `0`\n    age: {value: 0, type: \"number\"},\n    // addresses is a DefineList of Address types\n    addresses: [Address]\n});\n```\n\n### Object-oriented and functional\n\nCanJS’s observables produce data types that are easy for others to consume,\nbut can be implemented with the rigor of declarative programming.  This is\naccomplished by combining the benefits of object-oriented programming,\nfunctional programming, and functional reactive programming.\n\n[Functional programming](https://en.wikipedia.org/wiki/Functional_programming), which is a\nform of [declarative programming](https://en.wikipedia.org/wiki/Declarative_programming), avoids\nchanging state and mutable data.  It treats programming as math.  This eliminates side effects,\nmaking it easier to predict the behavior of an application.\n\n> Programming is, at its best, a branch of formal mathematics and applied logic.   \n> __Edsger Dijkstra__ - _1 March 1999 at the ACM Symposium on Applied Computing at San Antonio, TX_\n\nHowever, [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming) APIs often feel more natural.\n\n> Object-oriented programming leverages the fact that humans have millions of years of evolution invested in conceiving of the world in terms of things, which have properties, and associated methods of doing things with them. A salt shaker has a property of the amount of salt in it, and can be shaken.  \n> [Tim Boudreau, Oracle Labs](https://www.quora.com/Why-did-Dijkstra-say-that-%E2%80%9CObject-oriented-programming-is-an-exceptionally-bad-idea-which-could-only-have-originated-in-California-%E2%80%9D)\n\nWe agree with both of these ideas! The following object-oriented `SaltShaker` API feels intuitive - any\ndeveloper can immediately understand it.\n\n```js\nvar saltShaker = new SaltShaker();\n\nsaltShaker.fill();  \n\nsaltShaker.shake() //-> \"salt\"\nsaltShaker.shake() //-> \"salt\"  \nsaltShaker.shake() //-> null   \n\nsaltShaker.empty   //-> true\n```\n\nTo satisfy this API, `SaltShaker` could be implemented as follows:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nSaltShaker = DefineMap.extend({\n    saltCount: {type: \"number\", value: 0},\n    fill: function(){\n        this.saltCount = 2;\n    },\n    shake: function(){\n        var hasSalt = this.saltCount;\n        this.saltCount = hasSalt ? this.saltCount - 1 : 0;\n        return hasSalt ? \"salt\" : null;\n    },\n    get empty() {\n        return ! this.saltCount;\n    }\n});\n```\n\nWhile `empty` is implemented [declaratively](https://en.wikipedia.org/wiki/Declarative_programming),\nnotice how both `fill` and `shake` mutate the state of `saltCount`.  In a more complex type,\nthis can easily lead to bugs.  Instead, the following uses [can-define-stream] and\n[functional reactive programming](https://en.wikipedia.org/wiki/Functional_reactive_programming)\nto make `saltCount` a function of the calls to `fill` and `shake`:\n\n```js\nvar SaltShaker = DefineMap.extend({\n    saltCount: {\n        stream: function() {\n            return this.stream(\"fill\")\n\t\t\t\t\t.merge(this.stream(\"shake\"))\n\t\t\t\t\t.scan(function(prev, event){\n\t\t\t\tif(event.type === \"fill\") {\n\t\t\t\t\treturn 2;\n\t\t\t\t} else {\n\t\t\t\t\treturn prev > 0 ? prev - 1 :  0;\n\t\t\t\t}\n\t\t\t},0);\n        }\n    },\n    fill: function() {\n        this.dispatch(\"fill\");\n    },\n    shake: function() {\n\t\tvar hadSalt = this.saltCount;\n        this.dispatch(\"shake\");\n        return hadSalt ? \"salt\" : null;\n    },\n    get empty() {\n        return !this.saltCount;\n    }\n});\n```\n\nCanJS provides three powerful functional helpers on [can-define/map/map] and [can-define/list/list] that will explore in the following sections:\n\n - [can-define.types.get computed getter properties]\n - [can-define.types.get async computed getter properties]\n - [can-define-stream.stream streamed properties]\n\n### Computed getter properties\n\n[can-define.types.get Computed getters] are the easiest way to declaratively transform\nstateful values into derived values.  For example, the following defines a `completedCount`\nproperty on instances of the `TodoList` type:\n\n```js\nvar TodoList = DefineList.extend({\n    \"#\": Todo,\n    get completedCount(){\n        return this.filter({complete: true}).length\n    }\n});\n\nvar todos = new TodoList([{complete: true}, {complete:false}]);\ntodos.completedCount //-> 1\n```\n\nThese [can-define.types.get getters] are made with [can-compute], so they\n[infer dependencies](#Inferreddependencies), [cache their values](#Cachedvalues), and are [synchronous](#Synchronous).\n\n### Async computed getter properties\n\nIt’s common to load data asynchronously given some state. For example, given\na `todoId`, you might need to load a `todo` from the server.  This `todo` property\ncan be described using [can-define.types.get asynchronous computed getters] as follows:\n\n```js\nvar EditTodoVM = DefineMap.extend({\n    todoId: \"number\",\n    todo: {\n        get: function(lastSetValue, resolve){\n            Todo.get(this.todoId).then(resolve);\n        }\n    }    \n});\n```\n\n### Streamed properties\n\nWhen the behavior of properties can’t be described with computes,\nthe [can-define-stream] module adds the ability to work with event\nstreams.  For example, `lastValidName` keeps track of `Person`’s\nlast `name` property that includes a space.\n\n```js\nvar Person = DefineMap.extend({\n  name: \"string\",\n  lastValidName: {\n    stream: function(){\n      return this.stream(\".name\").filter(function(name){\n        return name.indexOf(\" \") >= 0;\n      })\n    }\n  }\n});\n\nvar me = new Person({name: \"James\"});\n\nme.on(\"lastValidName\", function(lastValid) {\n  console.log(lastValid)\n});\n\nme.name = \"JamesAtherton\"; // No change\n\nme.name = \"James Atherton\";\n//-> console.logs \"James Atherton\";\n\nme.name = \"JustinMeyer\"; // No change\n\nme.name = \"Justin Meyer\";\n//-> console.logs \"Justin Meyer\";\n```\n\n## Maintainable MVVM\n\n\nCanJS applications are Model-View-ViewModel (MVVM) architecture with\ncustom elements providing orchestration.\n\n<img src=\"../../docs/can-guides/images/introduction/mvvm.png\" style=\"width:100%;max-width:750px\" alt=\"Model-View-ViewModel Diagram\"/>\n\nIt’s a [straightforward](#Straightforward), but [flexible](#Flexible) architecture that\nproduces [easily testable](#Easily_testable), [compose-able](#Compose_able) modules and components.\n\n### Straightforward\n\nOn the highest level, CanJS applications are broken down into 2 parts:\n\n- **Custom Elements** that manage a particular part of the application.  \n- [Models](#MalleableModels) that handle data requests to and from the server.\n\nFor example, consider the following order page from [place-my-order](http://place-my-order.com):\n\n<img src=\"../../docs/can-guides/images/introduction/tech-component-map.png\" style=\"width:100%;max-width:750px\" />\n\nThis page might be broken down into the following\ncustom elements:\n\n - `<pmo-nav>`\n - `<pmo-order-new>` which is further broken down into:\n   - `<bit-tabs>`\n   - `<pmo-order-menu>`\n\nThese _Custom Elements_ use the `Restaurant` model\nto get a restaurant’s menu by making a `GET` request to `/api/restaurants`;\nand they use the `Order` model to create an order by making a `POST` request to\n`POST /api/orders`.\n\n_Custom Elements_ are broken down themselves into two layers:\n\n- [ViewModels](#VeraciousViewModels) that manage the logic of a custom element.\n- [Views](#VivaciousViews) that convert the data and values of the\n _ViewModel_ into HTML elements. Views update their HTML\n elements when the _ViewModel_ changes and are able to\n call methods on the _ViewModel_ when a user interacts\n with their HTML.\n\nAll of these parts, _Custom Elements_, _Models_,\n_View Models_, and _Views_, are __mostly__ written using just\na couple APIs:\n\n- [can-define] observables for _ViewModels_ and _Models_.\n- [can-stache] templates with [can-stache-bindings] for _Views_.\n\nThe rest of the core APIs are just decorators, used\nto turn [can-define] observables and [can-stache] templates\ninto something more:\n\n - [can-component] combines a [can-define] observable\n   and [can-stache] template into a _Custom Element_.\n - [can-route] two-way binds a [can-define] observable\n   with the browser’s URL.\n - [can-connect] adds methods to a [can-define] observable,\n   enabling it to create, read, update, and delete data on\n   a RESTful URL.\n\nCanJS is straightforward because it’s just about building\ncustom elements and models with just a small set of tools -  [can-define]\nand [can-stache].\n\n### Independent\n\nCanJS’s Models, Views, and ViewModels are all independent, individually\nuseful layers.  This independence is the source for the benefits of\nMVVM architecture discussed in the following sections:\n\n - [Flexible](#Flexible) - change tools and patterns when the need arises.\n - [Testable](#Testable) - easily unit test parts of the application.\n - [Compose-able](#Compose_able) - combine smaller units of functionality into a large whole.\n\nFor now, we’ll just demonstrate that these things actually are independent using\ncode in the [guides/todomvc].  We’ll organize code related to the `<todo-list>` component\ninto individual and independent modules and files that look like:\n\n```\n├── models/\n|   ├── todo.js\n├── components/\n|   ├── todo-list/\n|   |   ├── view-model.js\n|   |   ├── view.stache\n|   |   ├── todo-list.js\n```\n\nThe __Model__, in _models/todo.js_, looks like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\"),\n    DefineList = require(\"can-define/list/list\"),\n    set = require(\"can-set\"),\n    superMap = require(\"can-connect/can/super-map/super-map\");\n\n// Defines the type of data we get back from the server.\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\n// Defines methods or properties on lists\n// we get back from the server.\nTodo.List = DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\n// Defines the behavior of the \"get list\"\n// API endpoint.\nTodo.algebra = new set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\n// Connects the types above to a RESTful url.\nTodo.connection = superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: Todo.algebra\n});\n\nmodule.exports = Todo;\n```\n\nThis model can independently make requests to a RESTful service layer.\n\n- [can-connect/can/map/map.getList Get a list] of Todos\n  ```js\n  Todo.getList({complete: true}).then(function(todos){})\n  ```\n- [can-connect/can/map/map.get Get] a single Todo\n  ```js\n  Todo.get({_id: 6}).then(function(todo){})\n  ```\n- [can-connect/can/map/map.prototype.save Create] a Todo\n  ```js\n  var todo = new Todo({name: \"do dishes\", complete: false})\n  todo.save().then(function(todo){})\n  ```\n- [can-connect/can/map/map.prototype.save Update] an [can-connect/can/map/map.prototype.isNew already created] Todo\n  ```js\n  todo.complete = true;\n  todo.save().then(function(todo){})\n  ```\n- [can-connect/can/map/map.prototype.destroy Delete] a Todo\n  ```js\n  todo.destroy().then(function(todo){})\n  ```\n\nThe __ViewModel__, in _components/todo-list/view-model.js_, looks like:\n\n```js\nvar DefineMap = \"can-define/map/map\";\nvar Todo = \"../models/todo\";\n\nmodule.exports = DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n\n  // Returns true if the current todo is being edited.\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n\n  // Marks a todo as being edited.\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n\n  // Cancels that todo as being edited.\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n\n  // Updates the todo being edited on\n  // the server.\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n```\n\nThis _ViewModel_ will be tested independent of the view in the\n[testable](#Testable) section.  \n\nThe __View__, in _components/todo-list/view.stache_, looks like:\n\n```\n<ul id=\"todo-list\">\n  <!-- Loop through every todo -->\n  {{#each todos}}\n\n    <!-- Create an li with the right class names -->\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n\n      <div class=\"view\">\n        <!-- Connect this checkbox to the `complete` property\n             of the current todo -->\n        <input class=\"toggle\" type=\"checkbox\"\n               {($checked)}=\"complete\"\n               ($change)=\"save()\">\n\n        <!-- Edit this todo on double click -->\n        <label ($dblclick)=\"edit(this)\">{{name}}</label>\n\n        <!-- Delete this todo on the server when clicked -->\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n\n      <!-- Handle editing this todo with this input element -->\n      <input class=\"edit\" type=\"text\"\n        {($value)}=\"name\"\n        ($enter)=\"updateName()\"\n        {$focused}=\"isEditing(this)\"\n        ($blur)=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n```\n\nThis _View_ lives in its own file, so a designer can modify it\nwithout touching any JavaScript directly.\n\nFinally, the component file in _components/todo-list/todo-list.js_ puts\neverything together:\n\n```js\nvar Component = require('can-component');\nvar ViewModel = require(\"./view-model\");\nvar view = require('./view.stache!');\n\nComponent.extend({\n    tag: 'todo-list',\n    ViewModel: ViewModel,\n    view: view\n});\n```\n\nRead on to see how CanJS’s independence results in easily testable, flexible,\nand compose-able code.\n\n\n### Testable\n\nCanJS’s MVVM architecture results in testable code. In the previous\nsection, we created the [guides/todomvc]’s `<todo-list>`’s Model, ViewModel, and View code.\nThe following shows examples of testing each part.\n\nTesting the __Model__’s `active` and `complete` properties:\n\n```js\ntest(\"Todo active and complete\", function(){\n    var list = new Todo.List([\n        {name: \"dishes\", complete: false},\n        {name: \"lawn\", complete: true}\n    ]);\n    assert.deepEqual(list.active.get(), [{name: \"dishes\", complete: false}], \"one active\");\n    assert.deepEqual(list.complete.get(), [{name: \"lawn\", complete: true}], \"one complete\")\n});\n```\n\nTesting the __ViewModel__’s `edit` and `cancelEdit` methods:\n\n```js\ntest(\"TodoListVM cancelEdit\", function(){\n    var todos = new Todo.List([\n        {name: \"mow lawn\", complete: false},\n        {name: \"dishes\", complete: true},\n    ]);\n\n    var todoListVM = new TodoListVM({\n        todos: todos\n    });\n\n    todoListVM.edit(todos[0]);\n    todos[0].name = \"mow yard\";\n\n    todoListVM.cancelEdit();\n\n    assert.equal(todos[0].name, \"mow lawn\");\n});\n```\n\nTo test the __View__, we typically recommend testing the component. The\nfollowing, using [can-fixture], tests that the component can edit a\ntodo’s name.\n\n```js\ntest(\"<todo-list> can update todo name\", function(done){\n\n    fixture(\"PUT /api/todos/{id}\", function(request){\n        assert.equal(request.data.name, \"MOW YARD\", \"update\");\n        done();\n    });\n\n    var todos = new Todo.List([\n        {name: \"mow lawn\", complete: false, id: 22},\n        {name: \"dishes\", complete: true, id: 23},\n    ]);\n\n    var template = stache(\"<todo-list {todos}='todos'/>\");\n    var todoListElement = template({todos: todos}).firstChild;\n\n    // double click todo\n    todosListElement.querySelector(\".todo label\").dispatch( new MouseEvent('dblclick') );\n\n    // change its value to MOW YARD by hitting enter (which causes a change first)\n    var input = todoListElement.querySelector(\".todo input.edit\");\n    input.value = \"MOW YARD\";\n\n    input.dispatchEvent( new Event('change') );\n\n    input.dispatchEvent( new KeyboardEvent(\"keyup\",{code: \"Enter\", keyCode: 13}) );\n});\n```\n\nCheck out these tests running in [this JS&nbsp;Bin](http://justinbmeyer.jsbin.com/xaduto/3/edit?html,js,output).\n\n### Flexible\n\nCanJS’s architecture produces observables that stand on their\nown, useful outside of the framework.  CanJS’s observables aren’t dependent on a diffing engine to identify changes.  Instead, any other tool or library can be an observer or call methods\non the observable.\n\n[This JS Bin](https://jsbin.com/vivowu/7/edit?html,js,output) shows an analog clock that uses the [Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The `Analog`\nclock listens to a `timer` observable and updates the position of the second, hour, and minute\nhands when the time changes.\n\n```js\nAnalog = function(element, timer) {\n    ...\n    timer.on(\"time\", this.drawClock.bind(this) );\n};\n\nvar timer = new Timer();\nnew Analog(document.getElementById(\"analog\"), timer);\n```\n\nAlso, with the ideas discussed in [Object-oriented and functional](#Objectorientedandfunctional),\nCanJS applications can closely approximate a stateless, redux-like,\narchitecture.  While we think this architecture creates more work than necessary for\ndevelopers, it’s possible by:\n\n - Having a single, ApplicationViewModel that contains all state, derived using\n   [can-define-stream] from events dispatched on the ApplicationViewModel.\n - Enforcing that parent-to-child communication only uses one-way\n   [can-stache-bindings.toChild] bindings like:\n   ```\n   <child-component {prop}=\"parentValue\"/>\n   ```\n - Enforcing that child-to-parent communication is [can-stache-bindings.event] based:\n   ```\n   <child-component (event)=\"parentMethod()\"/>\n   ```\n\n\n### Compose-able\n\nWe believe that application state should be federated:\n\n> [Federated](https://en.oxforddictionaries.com/definition/federate) - form or be formed into a single centralized unit, within which each state or organization keeps some internal autonomy.\n\nCanJS applications are composed from hierarchical [can-component]s, each containing their own independent state (their own ViewModel). This architecture is at the core of CanJS’s approach to building large applications.\n\n> The secret to building large apps is never build large apps. Break your applications into small pieces. Then, assemble those testable, bite-sized pieces into your big application.\n\nCanJS applications can be represented by [Hierarchical State Machines](https://en.wikipedia.org/wiki/UML_state_machine#Hierarchically_nested_states). The [guides/atm]\nwalks through an example of this concept where a `Card`, `Deposit`, and `Withdrawal`’s states\nare composed into the `ATM`’s state.\n\n<img src=\"../../docs/can-guides/experiment/atm/1-pages-template/state-diagram.png\">\n\nThis dispersed (federated) state means that a `Card` is still useful without the\n`ATM`.  A `Card` can make AJAX requests and maintains its state of being\n`verified` or `unverified`.\n\nFederated state stands in contrast to architectures that have a\n_one-way_ data flow. Architectures with a _one-way_ data flow usually flow to\na central and global _state mechanism_. That _state mechanism_\nbecomes an implicit dependency of every component in the application. This creates additional downstream problems:\n\n* It becomes harder to work independently and verify the behavior of component of the project. Thus, scaling the team and parallelizing the effort becomes trickier, as several developers might have to touch the same central state mechanism.\n\n* Individual components become less reusable in other contexts because of their dependency on this external state layer.\n\n* Individual components become harder to test in isolation, since testing them requires importing or mocking large external dependencies.\n\n## Veracious ViewModels\n\nCanJS’s ViewModels are [can-define] observables that manage the state of a [can-component].\nAs ViewModels are observables, CanJS’s ViewModels have all the benefits of\nCanJS’s outstanding observable objects, namely:\n\n - [Expressive property definition syntax](#Expressivepropertydefinitionsyntax)\n - [Object-oriented and functional](#Objectorientedandfunctional)\n - [Computed getter properties](#Computedgetterproperties)\n - [Async computed getter properties](#Asynccomputedgetterproperties)\n - [Streamed properties](#Streamedproperties)\n\nIn CanJS, the ViewModel is its own layer, completely independent from the\ntemplate and the component. This is why ViewModels are largely responsible for\nmany of the benefits of CanJS’s maintainable MVVM architecture:\n\n - [Independence](#Independent)\n - [Flexible](#Independent)\n - [Testable](#Testable)\n - [Compose-able](#Compose_able)\n\nThe introduction of a strong ViewModel provides key advantages for maintaining large applications:\n\n* Decouples the presentation from its business logic - A ViewModel is essentially an object and methods representing the state of a View. This separation of concerns enables simple, HTML-based Views containing minimal logic, while the ViewModel manages the complexities of application logic.\n\n* Enables designer/developer cooperation - Because the view is stripped of code and application logic, designers can safely and comfortably change the View without fear of breaking things.\n\n* Enables easier testing - ViewModels can be unit tested easily. Because they represent the view’s state without any knowledge of the DOM, they provide a simple interface for testing.\n\n## Vivacious Views\n\nCanJS views are [can-stache] templates, that implement a syntax similar to\n[Mustache](https://mustache.github.io/mustache.5.html) and [Handlebars](http://handlebarsjs.com/),\nand include special features like event bindings, custom elements, and performance optimizations.\n\n[can-stache] templates look like HTML, but with _magic_ tags like [can-stache.tags.escaped]\nand view bindings like [can-stache-bindings.twoWay] in the template. For example, the following is the application template in the [guides/todomvc]:\n\n```\n<header id=\"header\">\n\t<h1>todos</h1>\n\t<todo-create/>\n</header>\n\n<ul id=\"todo-list\">\n\t{{#each todos}}\n\t\t<li class=\"todo {{#if complete}}completed{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t\t<button class=\"destroy\" ($click)=\"destroy()\"></button>\n\t\t\t\t</div>\n\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t</li>\n\t{{/each}}\n</ul>\n```\n\nThe following sections cover:\n\n - [The powerful syntaxes](#MustacheandHandlebarsextendedsyntax) that support the transformation of any ViewModel into HTML.\n - How [custom elements and attributes](#Customelementsandattributes) make\n   applications easer to assemble and debug.\n - The [binding syntaxes](#DataandEventBindings) that allow HTML to\n   call methods back on the ViewModel.\n - The strategies used to keep [DOM updates to a minimum](#MinimalDOMupdates).\n - How Views can fit in your larger ecosystem with [template minification](#Templateminification),\n   [dependency declarations](#In_templatedependencydeclarations), and [progressive loading](#ProgressiveLoading).\n\n### Mustache and Handlebars extended syntax\n\n[can-stache] templates implement the mustache syntax\n[Mustache](https://mustache.github.io/mustache.5.html), adopt many of\nthe [Handlebars](http://handlebarsjs.com/) extensions, and provide a few extensions of\ntheir own.  The result is a simple syntax that covers the most common things needed in a template,\nbut is capable of translating any ViewModel into HTML.\n\n\n[can-stache] is built on the Mustache spec because Mustache simplifies the most common needs of templates into\na very limited subset of syntax.  Most of Mustache is just:\n\n - [can-stache.tags.escaped] - to insert content into the page.\n - [can-stache.tags.section]...[can-stache.tags.close] - to do conditionals, looping, or change context.\n\nA simple template might look like:\n\n```\n<p>Hello {{name}}</p>\n<p>You have just won {{value}} dollars!</p>\n{{#in_ca}}\n<p>Well, {{taxed.ca.value}} dollars, after taxes.</p>\n{{/in_ca}}\n```\n\nThis is not enough to translate every ViewModel into HTML, so [can-stache] supports\nHandlebars helpers like [can-stache.helpers.each] and\nthe ability to [can-stache/expressions/call call methods].\n\nA template that uses those features looks like:\n\n```js\n{{#players}}\n    <h2>{{name}}</h2>\n    {{#each stats.forPlayerId(id) }}\n\t\t<span>\n\t\t\t{{type}}\n\t\t</span>\n\t{{/each}}\n{{/players}}\n```\n\n\n\n\n\n### Custom elements and attributes\n\nCanJS supports defining custom elements and\nattributes.  You can make it so adding a `<ui-datepicker>`\nelement to the page creates a date picker widget; or, you can make it so\na `my-tooltip=\"your message\"` attribute adds a tooltip.\n\nCustom elements are created for widgets like `<ui-datepicker>` and for\nhigher-order components like `<acme-message-editor>`.  Higher-order components\noften assemble the behavior of multiple widget components.  Custom elements are created with [can-view-callbacks.tag] or [can-component].\n\nCustom attributes are typically used for mixins that can be\nadded to any element. Custom attributes are created with [can-view-callbacks.attr].\n\nThe main advantages of building applications based on custom HTML elements and attributes are:\n\n1. Ease of use - Designers can do it! Non-developers can express complex behavior with little to no JavaScript required. All you need to build a new page or feature is HTML.\n2. Application assembly clarity - Applications assembled with custom elements are easier to debug and\n   and understand the relationship between the user interface and the code powering it.\n\nLet’s explore these benefits more in the following sections:\n\n__Ease of use__\n\nBefore custom HTML elements existed, to add a date picker to your page, you would:\n\n1. Add a placeholder HTML element\n\n   ```\n   <div class='datepicker' />\n   ```\n\n2. Add JavaScript code to instantiate your datepicker:\n\n   ```javascript\n   $('.datepicker').datepicker(task.dueDate)\n   ```\n\n3. Wire up the datepicker to update the rest of your application and vice-versa:\n\n   ```javascript\n   task.on(\"dueDate\", function(ev, dueDate){\n       $('.datepicker').datepicker(dueDate)\n   })\n\n   $('.datepicker').on(\"datechange\", function(ev, dueDate){\n       task.dueDate = dueDate;\n   });\n   ```\n\n\n\nWith custom HTML elements, to add the same datepicker, you would\nsimply add the datepicker to your HTML or template:\n\n```\n<ui-datepicker {(value)}=\"task.dueDate\"/>\n```\n\nThat might seem like a subtle difference, but it is actually a major step forward. The custom HTML element syntax allows for instantiation, configuration, and location, all happening at the same time.\n\nCustom HTML elements are one aspect of [Web Components](http://webcomponents.org/), a collection of browser specs that have [yet to be implemented](http://caniuse.com/#search=components) across browsers.\n\n__Application assembly clarity__\n\nCustom elements make it easier to tell how an application was assembled. This is because you\ncan inspect the DOM and see the custom elements and their bindings.  \n\nThe\nfollowing shows inspecting the [guides/todomvc]’s _“What needs to be done?”_ input element.  Notice how it’s easy to tell that its behavior is provided by the\n`<todo-create>` element.\n\n\n<img src=\"../../docs/can-guides/images/introduction/inspect.png\" style=\"width:100%;max-width:750px\" />\n\n\n### Data and Event Bindings\n\n[can-stache] includes Mustache data bindings that update the DOM when data changes.  For example,\nif the data passed to the following template changes, the DOM is automatically updated.\n\n```\n<h1 class=\"{{#if user.admin}}admin{{/if}}\">Hello {{user.name}}</h1>\n```\n\nIn addition to the default Mustache data bindings, the [can-stache-bindings] module\nadds more powerful data and event bindings. These event bindings provide full control over how\ndata and control flows between the DOM, ViewModels, and the [can-view-scope]. Bindings look like:\n\n- [can-stache-bindings.event (event)=\"key()\"] for event binding.\n- [can-stache-bindings.toChild {prop}=\"key\"] for one-way binding to a child.\n- [can-stache-bindings.toParent {^prop}=\"key\"] for one-way binding to a parent.\n- [can-stache-bindings.twoWay {(prop)}=\"key\"] for two-way binding.\n\nPrepending `$` to a binding like `($event)=\"key()\"` changes the binding from the element’s `viewModel` to the element’s attributes or properties. [can-util/dom/attr/attr.special Special properties] can also be targeted with `$`.\n\nTo two-way bind an `<input>` element’s `value` to a `todo.name` looks like:\n\n```js\n<input {($value)}=\"todo.name\"/>\n```\n\nTo two-way bind a custom `<ui-datepicker>`’s `date` to a `todo.dueDate` looks like:\n\n```js\n<ui-datepicker {(date)}=\"todo.dueDate\"/>\n```\n\nBy mixing and matching `$` and the different syntaxes, you have complete control over how\ndata flows.\n\n### Minimal DOM updates\n\nEveryone knows that updating the DOM is traditionally the slowest part of JavaScript\napplications.  CanJS uses two strategies for keeping DOM updates to a minimum:\nobservation and data diffing.\n\nTo understand how these strategies are used, consider a template like:\n\n```\n<ul>\n{{#each completeTodos() }}\n\t<div>{{name}}</div>\n{{/each}}\n</ul>\n```\n\nAnd rendered with `viewModel` like:\n\n```js\nvar ViewModel = DefineMap.extend({\n    tasks: Todo.List,\n    completeTodos: function(){\n        return this.tasks.filter({complete: false});\n    }\n});\n\nvar viewModel = new ViewModel({\n    tasks: new Todo.List([\n        {name: \"dishes\", complete: true},\n        {name: \"lawn\", complete: false}\n    ])\n})\n```\n\n__Observation__\n\nCanJS directly observes what’s happening in each magic tag\nlike `{{name}}` so it can localize changes as much as possible. This means\nthat when the first todo’s name is changed like:\n\n```js\nviewModel.tasks[0].name = \"Do the dishes\"\n```\n\nThis change will be observed, and a textNode in the div will simply\nbe updated with the new `name`.  There’s no diffing on the whole template.  A\nchange happens and we know directly what is impacted.\n\n__Data diffing__\n\nThe [can-stache.helpers.each {{#each}} helper] provides data diffing.  It is able\nto do a difference between two arrays and calculate a minimal set of mutations to\nmake one array match another.  This means that if a new task is added to the\nlist of `tasks` like:\n\n```js\nviewModel.tasks.push({name: \"Understand diffing\", complete: true})\n```\n\nThis change will be observed, and a new array will be returned from\n`completeTodos()`.  The `#each` helper will [can-util/js/diff/diff] this new array to the\noriginal array, and only create a single new `<div>` for the new todo.  \n\n\n### Template minification\n\nWhile templates provide obvious benefits to application maintainability, they can be a\nchore to correctly integrate into the build tool chain. The [steal-stache] library provides an easy hook to load [can-stache] templates using [StealJS](http://stealjs.com) and include the compiled templates into the minified result of the build.\n\n[steal-stache] returns a renderer function that will render the template into a document fragment.\n\n```javascript\nimport todosStache from \"todos.stache\"\ntodosStache([{name: \"dishes\"}]) //-> <documentFragment>\n```\n\nWhen the build is run, this import statement will tell StealJS that \"todos.stache\" is a dependency, and will include an already parsed representation in the build result.\n\n### In-template dependency declarations\n\n[can-view-import](../../can-view-import.html) allows templates to import their dependencies like\nother modules. You can import custom elements, helpers, and other modules straight from a template module like:\n\n```\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\n### Progressive Loading\n\nA template may load or conditionally load a module after the initial page load. `<can-import>` allows progressive loading by using an end tag.\n\nThis feature, when used with [steal-stache](../../steal-stache.html), signals to the build that the enclosed section’s dependencies should be dynamically loaded at runtime.\n\n```\n{{#eq location 'home'}}\n<can-import from=\"components/home\">\n  <my-home/>\n</can-import>\n{{/eq}}\n{{#eq location 'away'}}\n<can-import from=\"components/chat\">\n  <my-chat/>\n</can-import>\n{{/eq}}\n```\n\n## Malleable Models\n\nCanJS’s models are primarily responsible for defining your data’s schema and communicating with a server to read and write data.\n\nIn addition to CRUD and real-time capabilities, [can-set] and [can-connect] provide lots of great features out-of-the-box:\n\n- [Memory-safe instance store](#Memory_safeinstancestore)\n- [Real-time list updates](#Real_timelistupdates)\n- [Parameter awareness](#Parameterawareness)\n- [Caching and minimal data requests](#Cachingandminimaldatarequests)\n- [Related-data features](#Related_datafeatures)\n\nWe’ll cover each of these in the sections below.\n\n### Separation of concerns\n\nCanJS separates your model layer into two parts:\n\n1) Communicating with a server.\n2) Managing your data’s schema.\n\nSeparating these two concerns means your model data isn’t tied to how you communicate with your API. Your project may start with a RESTful API for CRUD operations but end up with a real-time WebSocket API, and with CanJS, that change doesn’t affect how your data is modeled.\n\nAdditionally, with our mixin-based approach, you can easily add behaviors to both parts separately. Want to add [can-connect/data/localstorage-cache/localstorage-cache Local Storage] caching? It’s a one-line add-on. How about a behavior to [can-connect/data/combine-requests/combine-requests efficiently combine network requests]? One line too! Need something not provided by [can-connect]? Write and mix in your own custom behaviors.\n\nThis separation of concerns and powerful mixin behavior is accomplished by encapsulating the code required to connect to a service and encouraging typed definitions of your model data. For every “type” of data object in your project, you can create a model to represent the properties and methods attached to it. With this model in hand, you can structure how you communicate with your server. Different API calls can return the same type of data and have those represented as the same model objects.\n\nLet’s look at an example of how we would define a `Todo` type and a list of todos:\n\n```javascript\nvar DefineList = require(\"can-define/list/list\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Todo = DefineMap.extend({\n\tcomplete: \"boolean\",\n\tname: \"string\"\n});\n\nTodo.List = DefineList.extend({\n\t\"#\": Todo,\n\tcompleteCount: function(){\n\t\treturn this.filter({complete: true}).length;\n\t}\n})\n```\n\nThis example uses [can-define/map/map] to create a type definition for a `Todo`; each instance of `Todo` has a boolean `complete` property and a string `name` property.\n\nThis example also uses [can-define/list/list] to define a type for an array of `Todo` instances; the list has a `completeCount` method for easily determining how many todos in the list have been completed.\n\nUsing [can-connect], we’ll create a connection between a RESTful `/api/todos` service and our `Todo` instances and `TodoList` lists:\n\n```javascript\nvar connect = require(\"can-connect\");\nTodo.connection = connect([\n\trequire(\"can-connect/can/map/map\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/data/url/url\")\n], {\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList\n});\n```\n\nThat connection can be used to get a `Todo.List` of `Todo`s:\n\n```javascript\nTodo.getList({}).then(function(todos) {\n\t// Do what you’d like with the `todos`\n});\n```\n\n### Memory-safe instance store\n\nLet’s continue with our todo app example and imagine that we want to show two lists on a page: incomplete and urgent todos.\n\nFirst, let’s fetch the incomplete todos:\n\n```javascript\nTodo.getList({completed: false}).then(function(incompleteTodos) {});\n```\n\n`incompleteTodos` might look like this:\n\n    [\n      {id: 2, completed: false, name: \"Finish docs\", priority: \"high\"},\n      {id: 3, completed: false, name: \"Publish release\", priority: \"medium\"}\n    ]\n\nNext, let’s fetch a list of high-priority todos:\n\n```javascript\nTodo.getList({priority: \"high\"}).then(function(urgentTodos) {});\n```\n\n`urgentTodos` might look like this:\n\n    [\n      {id: 1, completed: true, name: \"Finish code\", priority: \"high\"},\n      {id: 2, completed: false, name: \"Finish docs\", priority: \"high\"}\n    ]\n\nNote that the “Finish docs” todo appears in both lists. If we make a change to the todo (e.g. changing its name), we want that change to appear in both lists.\n\n[can-connect]’s [can-connect/constructor/store/store.instanceStore instance store] keeps a reference to every model object by `id` (but you can [can-set.props.id change] which property is used). It does two things:\n\n1. Prevents duplicate instances of a model object from being created.\n2. Cleans up unused instances to release memory when they’re no longer referenced.\n\nLet’s look at both of these points in more detail.\n\n#### Duplicate instances\n\nThe instance store prevents duplicate instances from being created by storing each model object by its [can-set.props.id id]. When a model object is fetched from the server, CanJS checks its `id` to see if it’s already in the instance store; if it is, then CanJS will reuse the same object.\n\nIn our example, CanJS puts the “Finish docs” todo in the instance store when `incompleteTodos` is fetched. When `urgentTodos` is retrieved, CanJS sees the “Finish docs” todo with the same `id`, so it reuses the instance of “Finish docs” that is already in the instance store.\n\nIf these todos are displayed in separate lists on the page, and a user marks “Finish docs” as completed in one of the lists (causing the `completed` property to be set to `true`), then the other list will reflect this change.\n\n#### Prevent memory leaks\n\nA global instance store _sounds_ great until you consider the memory implications: if every model object instance is tracked, then won’t the application’s memory usage only grow over time?\n\nCanJS solves this potential problem by keeping track of which objects are observing changes to your model object instances.\n\nThe reference count for each object increases in two ways:\n\n- __Explicitly:__ if you use [can-connect/constructor/store/store.addInstanceReference] or call `.on()` on an instance (e.g. `todo.on('name', function(){})`)\n\n- __Implicitly:__ if properties of the instance are bound to via live-binding in a view, e.g. `Name: {{name}}` in a [can-stache] template\n\nSimilarly, the reference count is decreased in two ways:\n\n- __Explicitly:__ if you use [can-connect/constructor/store/store.deleteInstanceReference] or call `.off()` on an instance\n\n- __Implicitly:__ if part of the DOM connected to a live-binding gets removed\n\nWhen the reference count for a model object instance gets back down to 0 (no more references), the instance is removed from the store so its memory can be garbage collected.\n\nThe result is that in long-running applications that stream large amounts of data, this store will not cause memory to increase unnecessarily over time.\n\nYou can read more about the benefits of the instance store in our [“Avoid the Zombie Apocalypse” blog post](https://www.bitovi.com/blog/avoid-the-zombie-apocalypse).\n\n### Real-time list updates\n\nCanJS also automatically inserts, removes, and replaces objects within lists.\n\nLet’s continue with our incomplete and urgent todo example from the previous section.\n\n`incompleteTodos` looks like this:\n\n    [\n      {id: 2, completed: false, name: \"Finish docs\", priority: \"high\"},\n      {id: 3, completed: false, name: \"Publish release\", priority: \"medium\"}\n    ]\n\n`urgentTodos` looks like this:\n\n    [\n      {id: 1, completed: true, name: \"Finish code\", priority: \"high\"},\n      {id: 2, completed: false, name: \"Finish docs\", priority: \"high\"}\n    ]\n\nIn the UI, there’s a checkbox next to each urgent todo that toggles the `completed` property:\n\n```javascript\ntodo.completed = !todo.completed;\ntodo.save();\n```\n\nWhen the user clicks the checkbox for the “Finish docs” todo, its `completed` property is set to `true` and it disappears from the `incompleteTodos` list when [can-connect/can/map/map.prototype.save .save()] is called.\n\nThis is made possible by two things:\n\n- The [can-connect/constructor/store/store.listStore list store] contains all of the lists loaded from the server. It’s memory safe so it won’t leak.\n\n- [can-set] understands what your parameters mean so it can insert, remove, and replace objects within your lists. This is discussed in the following _\"Parameter awareness\"_ section.\n\nCanJS’s real-time list updates work great with \"push notification\" systems like [socket.io](http://socket.io/) and SignalR.  To add realtime behavior to a CanJS app, you\njust have to call the [can-connect/real-time/real-time.createInstance],\n[can-connect/real-time/real-time.updateInstance] and [can-connect/real-time/real-time.destroyInstance]\nwhen updates happen similar to the following:\n\n```js\nvar socket = io('http://my-todo-app.com');\n\nsocket.on('todo created', function(todo){\n    Todo.connection.createInstance(todo)\n});\nsocket.on('todo updated', function(todo){\n    Todo.connection.updateInstance(todo)\n});\nsocket.on('todo removed', function(todo){\n    Todo.connection.destroyInstance(todo)\n});\n```\n\n### Parameter awareness\n\nWhen you make a request for `incompleteTodos` like the one below:\n\n```javascript\nTodo.getList({completed: false}).then(function(incompleteTodos) {});\n```\n\nThe `{completed: false}` object is passed to the server as parameters and represents all incomplete todos. You can configure a connection with [can-set.Algebra] that understands these parameters.\n\nHere’s an example of [can-connect/base/base.algebra setting up the algebra] for the `Todo.connection`:\n\n```\nvar connect = require(\"can-connect\");\nvar set = require(\"can-set\");\n\nTodo.algebra = new set.Algebra(\n\tset.props.boolean(\"completed\")\n);\n\nTodo.connection = connect([\n\trequire(\"can-connect/can/map/map\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/data/url/url\")\n], {\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: Todo.List,\n\talgebra: Todo.algebra\n});\n```\n<span line-highlight='4-6,16-16'></span>\nThe `{completed: false}` parameters are associated with `incompleteTodos` so `can-connect` knows that `incompleteTodos` should contain _any_ todo with a `false` `completed` property. By understanding what\nthe parameters used to request data mean, all sorts of interesting behaviors and performance optimizations\ncan happen, including:\n\n - Real-time updates as described in the previous section.\n - Fall-through caching, request caching, and combining requests behaviors as described in the\n following sections.\n\nParameter awareness is provided by [can-set].  Read more about the magic of `can-set` in its [can-set API docs].\n\n### Caching and minimal data requests\n\nUndoubtedly, the slowest part of any web application is communicating with the server. CanJS uses the following strategies to improve performance:\n\n* [can-connect/fall-through-cache/fall-through-cache Fall-through caching]: improve perceived performance by showing cached data first (while still fetching the latest data)\n* [can-connect/cache-requests/cache-requests Request caching]: reduce the number and size of server requests by intelligently using cached datasets\n* [can-connect/data/combine-requests/combine-requests Combining requests]: combine multiple requests to the same API into one request\n\n#### Fall-through caching\n\nTo increase perceived performance, `can-connect` includes a [can-connect/fall-through-cache/fall-through-cache fall-through cache] that first serves cached data from `localStorage` while simultaneously making the API request to get the latest data.\n\nThe major benefit of this technique is improved perceived performance: users will see content faster because it’s returned immediately from the cache. When the data hasn’t changed, the user doesn’t notice anything, but when it has, the magic of live-bindings automatically updates the data as soon as the API request finishes.\n\n#### Request caching\n\nIn some scenarios, an even more aggressive caching strategy is favorable. One example is fetching data that doesn’t change very often, or cached data that you can invalidate yourself. The [can-connect/cache-requests/cache-requests] behavior can reduce both the number of requests that are made and the size of those requests in these cases.\n\nIn the first scenario, where the data doesn’t change very often (and thus shouldn’t be fetched again during the lifetime of the application), no more requests to the API will be made for that same set of data. In the second scenario, you can choose to invalidate the cache yourself, so after the first API request the data is always cached until you clear it manually.\n\nAdditionally, the request logic is more aggressive in its attempts to find subsets of the data within the cache and to only make an API request for the subset NOT found in the cache. In other words, partial cache hits are supported.\n\n#### Combining requests\n\nCanJS collects requests that are made within [can-connect/data/combine-requests.time a millisecond] of each other and tries to combine them into a single request if they are for the same API.\n\nFor example, let’s say we’re loading a page that has two parts: a section with incomplete todos and a section that’s an archive of completed todos. The incomplete section is just a list of todos, while the archive section is broken up by month, so you want to split these sections into two different components.\n\nIn most other frameworks, you would probably decide to have some parent component fetch the list of all todos so you could pass different subsets to each component. This decreases the reusability and maintainability of the components, but it would result in just one network request instead of two.\n\nWith CanJS, you don’t have to choose between maintainability and performance. You can decide to have each component fetch its data independently and [can-connect] will intelligently combine the two requests into one.\n\nThis is made possible by the [can-set] algebra we discussed earlier. [can-connect] sees the outgoing requests, can determine that requests for `Todo.getList({completed: true, sort: 'completedDate'})` and `Todo.getList({completed: false, sort: 'priority'})` are equivalent to just one `Todo.getList({})` request, then make that single request and return the correct sorted data to each call.\n\nThis [can-connect/data/combine-requests/combine-requests configurable behavior] is extremely powerful because it abstracts network request complexity away from how you create and compose your application.\n\n### Related-data features\n\nCanJS makes dealing with document-based APIs easier by handling situations where the server might return either a reference to a value or the value itself.\n\nFor example, in a MongoDB setup, a request like `GET /api/todos/2` might return:\n\n```\n{\n  id: 2,\n  name: \"Finish docs\",\n  projectRef: 1\n}\n```\n\nBut a request like `GET /api/todos/2?$populate=projectRef` might return:\n\n```\n{\n  id: 2,\n  name: \"Finish docs\",\n  projectRef: {\n\tid: 1,\n\tname: \"Release\"\n  }\n}\n```\n\n[can-connect/can/ref/ref] handles this ambiguity by creating a [can-connect/can/ref/ref.Map.Ref Ref type] that is always populated by the `id` and can contain the full value if it’s been fetched.\n\nFor example, without populating the project data:\n\n```\nTodo.get({id: 2}).then(function(todo){\n  todo.projectRef.id //-> 2\n});\n```\n\nWith populating the project data:\n\n```\nTodo.get({id: 2, populate: \"projectRef\"}).then(function(todo){\n  todo.projectRef.id //-> 2\n});\n```\n\nThe values of other properties and methods on the [can-connect/can/ref/ref.Map.Ref Ref type] are determined by whether the reference was populated or the referenced item already exists in the [can-connect/constructor/store/store.instanceStore].\n\nFor example, `value`, which points to the referenced instance, will be populated if the reference was populated:\n\n```\nTodo.get({id: 2, populate: \"projectRef\"}).then(function(todo){\n  todo.projectRef.value.name //-> “Release”\n});\n```\n\nOr, it can be lazy loaded if it’s used in a template. For example, with this template:\n\n```\n{{#each todos as todo}}\n  Name: {{todo.name}}\n  Project: {{todo.projectRef.value.name}}\n{{/each}}\n```\n\nIf `todo.projectRef.value` hasn’t been loaded by some other means, CanJS will fetch it from the server so it can be displayed in the template. This is handled automatically without you having to write any additional code to fetch the project data.\n\nAdditionally, if multiple todos have the same project, only one request will be made to the server (if the data isn’t already cached), thanks to the [can-connect/data/combine-requests/combine-requests] behavior.\n\n## jQuery integration\n\nBy default, CanJS’s [can-core] works without jQuery.  However, the [can-jquery]\nmodule integrates jQuery’s and CanJS’s event system.  This allows you to listen to\njQuery custom events like `draginit` directly in [can-stache-bindings.event can-stache event bindings]\nor using [can-control].\n\n[This JS Bin](https://jsbin.com/yifopus/3/edit?html,css,js,output) lets a user drag an item\ninto a trashcan using custom jQuery drag/drop events.\n\n## Server Side Rendering\n\nCanJS applications can be rendered on the server by running the same code. This is known as [Isomorphic JavaScript](http://isomorphic.net/javascript) or [Universal JavaScript](https://medium.com/@mjackson/universal-javascript-4761051b7ae9).\n\nServer-side rendering (SSR) provides two main benefits over traditional single page apps: better page load performance and SEO support.\n\nCanJS makes it possible to load your application on the server. This is because CanJS works in a NodeJS context, on top of a virtual DOM.\n\nUsing [can-vdom](../can-vdom.html) and [can-zone](../can-zone.html), you can set up your own server side rendering system, such as [the one used in DoneJS](https://donejs.com/Apis.html#section=section_ServerSideRenderingAPIs). For information on using SSR without setting anything up yourself, please check out the DoneJS [quick start](https://donejs.com/Guide.html) and [in depth](https://donejs.com/place-my-order.html) guides.\n\n",
    "description": "Learn about CanJS’s technical accomplishments. \n",
    "name": "guides/technical",
    "title": "Technical Highlights",
    "type": "page",
    "parent": "about",
    "order": 1,
    "outline": "2",
    "comment": " "
  },
  "guides/what-is-canjs": {
    "src": {
      "path": "docs/can-guides/introduction/what-is-canjs.md"
    },
    "body": "\nCanJS is an evolving and improving set of client side JavaScript architectural\nlibraries that balances innovation and stability.\n\nCanJS includes everything you need to build a modern, well architected\nJavaScript application:\n\n- Observable objects\n- Computed properties\n- Live binding templates\n- Custom elements\n- Service modeling and intelligent data caching\n- Routing\n\nThe CanJS libraries are divided into four categories:\n\n1. __The Core Collection__ - the core, most useful parts of the library.\n2. __The Ecosystem Collection__ - extensions to the core collection, which may\nbe useful for some applications, like mocked AJAX requests, helpers for\nimporting modules, virtual DOM libraries, and two-way data bindings\n3. __The Infrastructure Collection__ - Lower-level utilities that power the\ncore collection, generally not things that application developers will use\noften, like low-level JS and DOM utilities, the core parts of the template and\nobservable systems.\n4. __The Legacy Collection__ - Supported former libraries that are no longer\nactively developed, such as previous template engines and observable APIs.\n\n## Part of a stack\n\nCanJS is one piece of the larger DoneJS framework, which provides a full stack\nof tooling for building high performance, real-time web and mobile\napplications.\n\nCanJS, and each of its libraries, can be used in isolation, and are\nindividually useful, but are even more useful when combined together.\n\n[//]: # (GRAPHIC: show CanJS as a piece of DoneJS, and it’s modules as pieces themselves)\n\n## The Team\n\nCanJS is built by 100s of contributors.\n\n### Core Team\n\n#### Prashant Sharma\n\nPrashant is based in Bangalore, India. He likes the understated elegance of CanJS. I also believe DoneJS is a great framework in the making, since it makes technology selection a no brainer by uniquely offering developers an all-in-one technology stack.\ngithub\n\n#### Julian Kern\n\nA 29 old guy from Germany, Julian started coding at the age of 16. Now he freelances with CanJS. He likes the clean structure of Model, Views, and ViewModels.\n\n[https://twitter.com/@22_Solutions @22_Solutions]\n\n#### Mohamed Cherif Bouchelaghem\n\nMohamed Cherif BOUCHELAGHEM from Algiers, Algeria, almost a server side developer in day work, JavaScript developer after work hours specially using DoneJS/CanJS. He likes to help people to learn and find solutions to issues with DoneJS framework and build applications and code samples that help to show the best from DoneJS/Canjs and learn it faster.\n\n[https://twitter.com/Cherif_b @Cherif_b]\n\n### Full-time Team\n\n#### Kevin Phillips\n\nKevin is based in Chicago (well, close enough). He wants to make it easy for anyone to get started with DoneJS and will work on features that help solve complex problems.\n\n[https://twitter.com/kdotphil @kdotphil]\n\n\n#### Justin Meyer\n\nJustin dances and plays basketball in Chicago. He created JavaScriptMVC and manages the DoneJS project, and shouldn’t code on it as much as he does.\n\n[https://twitter.com/justinbmeyer @justinbmeyer]\n\n#### David Luecke\n\nDavid is a Canadian by way of Germany. His focus is on CanJS and DoneJS’s testing stack.\n\n[https://twitter.com/daffl @daffl]\n\n#### Matthew Phillips\n\nMatthew, keeper of beards, is the lead maintainer of StealJS and its related tools.\n\n[https://twitter.com/matthewcp @matthewcp]\n\nTo become a contributor to DoneJS or its sub-projects, you simply have to:\n\n * Email the core team expressing your interest.\n * Attend the weekly DoneJS Contributors meeting twice a month. [Meeting Calendar](https://www.google.com/calendar/embed?src=jupiterjs.com_g27vck36nifbnqrgkctkoanqb4%40group.calendar.google.com&ctz=America/Chicago)\n * Make one small contribution, even a spelling correction, per month.\n\n",
    "description": "\n",
    "name": "guides/what-is-canjs",
    "title": "What is CanJS?",
    "type": "page",
    "parent": "guides/introduction",
    "order": 1,
    "hide": true,
    "comment": " "
  },
  "guides/who-uses-canjs": {
    "src": {
      "path": "docs/can-guides/introduction/who-uses.md"
    },
    "body": "\n<div class=\"screenshots\">\n\n## Apple Store\n\nDiscovered via [Reddit](https://www.reddit.com/r/javascript/comments/1kffau/apple_store_use_canjs_javascript_framework_not/)\n\n<a href=\"http://www.apple.com/shop/buy-iphone/iphone-7\"><span>http://www.apple.com/shop/buy-iphone/iphone-7</span><img src=\"../../docs/can-guides/images/apps/screenshots-aos.jpg\"></a>\n\n## Chase\n\n<a href=\"http://payments.chase.com\"><span>http://payments.chase.com</span><img src=\"../../docs/can-guides/images/apps/screenshots-chase.jpg\">\n\n## HP\n\n<a href=\"http://store.hp.com\"><span>http://store.hp.com</span><img src=\"../../docs/can-guides/images/apps/screenshots-hp.jpg\"></a>\n\n## USGA\n\n<a href=\"http://www.usga.org/\"><span>http://www.usga.org</span><img src=\"../../docs/can-guides/images/apps/screenshots-usga.jpg\"></a>\n\n## Yahoo\n\nYahoo uses CanJS in its [Brightroll Console](https://www.bitovi.com/blog/canjs-case-study-brightroll), a tool used to purchase ads and explore analytics.\n\n<img src=\"../../docs/can-guides/images/apps/screenshots-brightroll.jpg\">\n\n## PlutoTV\n\n<a href=\"http://pluto.tv/watch\"><span>http://pluto.tv/watch</span><img src=\"../../docs/can-guides/images/apps/screenshots-plutotv.jpg\"></a>\n\n## FedEx\n\nFedEx uses CanJS in its package tracker.\n\n<a href=\"https://www.fedex.com/apps/fedextrack/?action=track&cntry_code=us\"><span>https://www.fedex.com/apps/fedextrack</span><img src=\"../../docs/can-guides/images/apps/screenshots-fedex.jpg\"></a>\n\n## Sam’s Club\n\n<a href=\"https://m.samsclub.com/locator?xid=hdr_locator\"><span>https://m.samsclub.com</span><img src=\"../../docs/can-guides/images/apps/screenshots-sams.jpg\"></a>\n\n\n## Delta SkyMiles\n\nDelta uses CanJS in its rewards program, SkyMiles.\n\n<a href=\"http://www.skymilesshopping.com/\"><span>http://www.skymilesshopping.com</span><img src=\"../../docs/can-guides/images/apps/screenshots-skymiles.jpg\"></a>\n\n\n## Fidelity\n\nFidelity uses JavaScriptMVC (the previous name for CanJS) in its Mutual Fund comparison tool.\n\n<a href=\"https://www.fidelity.com/fund-screener/research.shtml\"><span>https://www.fidelity.com/fund-screener/research.shtml</span><img src=\"../../docs/can-guides/images/apps/screenshots-fidelity.jpg\"></a>\n\n\n## Cars.com\n\n<a href=\"http://www.cars.com\"><span>http://www.cars.com</span><img src=\"../../docs/can-guides/images/apps/screenshots-cars.jpg\"></a>\n\n\n</div>\n\n## Submit other apps\n\nDid you work on an app that uses CanJS? Please add it to the list [here](https://github.com/canjs/canjs/blob/master/docs/can-guides/introduction/who-uses.md) and create a PR, or email it [here](mailto:contact@bitovi.com) and we’d be happy to submit it for you!\n\n\n[//]: # (Volkswagon)\n\n[//]: # (Wells Fargo)\n\n[//]: # (Walmart)\n\n[//]: # (T-Mobile)\n\n",
    "description": "\n",
    "name": "guides/who-uses-canjs",
    "title": "Who Uses CanJS?",
    "type": "page",
    "parent": "about",
    "order": 2,
    "comment": " "
  },
  "can-connect/can/base-map/base-map": {
    "src": {
      "path": "node_modules/can-connect/can/base-map/base-map.md"
    },
    "body": "\n\n## Use\n\nThe `can-connect/can/base-map` module exports a helper function that creates a connection\nwith the \"standard\" behaviors in can-connect and hooks it up to a\n[can-define/map/map] and [can-define/list/list].\n\nIf you are using CanJS, this is an easy way to create a connection that can be useful and\nfast in most circumstances.\n\nTo use it, first define a Map and List constructor function:\n\n```js\nvar Todo = DefineMap.extend({ ... });\nvar TodoList = DefineList.extend({\n\t\"#\": Todo,\n\t...\n});\n```\n\nNext, call `baseMap` with all of the options needed by the behaviors that `baseMap` adds:\n\n```\nvar todoConnection = baseMap({\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nAs, [can-connect/can/map/map] adds CRUD methods to the `Map` option, you can use those to create,\nread, update and destroy todos:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.attr({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nCreate connection with many of the best behaviors in can-connect and hook it up to\na [can-define/map/map].\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect/can/base-map/base-map",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "baseMap(options)",
        "description": "\n\n  Creates a connection with the following behaviors: [can-connect/constructor/constructor],\n  [can-connect/can/map/map],\n  [can-connect/constructor/store/store],\n  [can-connect/data/callbacks/callbacks],\n  [can-connect/data/callbacks-cache/callbacks-cache],\n  [can-connect/data/parse/parse],\n  [can-connect/data/url/url],\n  [can-connect/real-time/real-time],\n  [can-connect/constructor/callbacks-once/callbacks-once].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/map/map.id": {
    "type": "function",
    "name": "can-connect/can/map/map.id",
    "parent": "can-connect/can/map/map.identifiers",
    "src": {
      "line": 41,
      "codeLine": 57,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nReturns a unique identifier value for an instance.\n",
    "title": "id",
    "signatures": [
      {
        "code": "connection.id( instance )",
        "description": "\n\n  Reads the [can-connect/base/base.algebra]'s id so that it's observable unless\n  the id is being read as part of the map being bound or\n  unbound.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/map/map.serializeInstance": {
    "type": "function",
    "name": "can-connect/can/map/map.serializeInstance",
    "parent": "can-connect/can/map/map.serializers",
    "src": {
      "line": 82,
      "codeLine": 92,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCalls `instance.serialize()`.\n",
    "title": "serializeInstance",
    "signatures": [
      {
        "code": "connection.serializeInstance( instance )",
        "description": "\n\n  Simply calls [can-define/map/map.prototype.serialize] on the underlying map.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.serializeList": {
    "type": "function",
    "name": "can-connect/can/map/map.serializeList",
    "parent": "can-connect/can/map/map.serializers",
    "src": {
      "line": 95,
      "codeLine": 105,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCalls `list.serialize()`.\n",
    "title": "serializeList",
    "signatures": [
      {
        "code": "connection.serializeList( list )",
        "description": "\n\n  Simply calls [can-define/list/list.prototype.serialize] on the underlying list.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map._Map": {
    "src": {
      "line": 108,
      "codeLine": 143,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  complete: function(){\n    this.completed = true\n  }\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n```\n\t \n",
    "description": "\nSpecify what type of `Map` should be hydrated.\n",
    "types": [
      {
        "type": "Map",
        "description": "Defaults to [can-types.DefaultMap] if a Map is\nnot specified.\n"
      }
    ],
    "title": "Map",
    "name": "can-connect/can/map/map._Map",
    "parent": "can-connect/can/map/map.hydrators",
    "comment": " "
  },
  "can-connect/can/map/map._List": {
    "src": {
      "line": 143,
      "codeLine": 188,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  complete: function(){\n    this.completed = true\n  }\n});\n\nvar Todo.List = DefineList.extend({\n  \"*\": Todo,\n  completed: function(){\n    this.filter(function(todo){\n      return todo.completed;\n    });\n  }\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  List: Todo.List,\n  url: \"/todos\"\n});\n```\n\t \n",
    "description": "\nSpecify what type of `CanList` should be hydrated.\n",
    "types": [
      {
        "type": "CanList",
        "description": "Defaults to [can-connect/can/map/map._Map]'s `.List` and\nthen [can-util/js/types/types.DefaultList] if `connection.List` is not specified.\n"
      }
    ],
    "title": "List",
    "name": "can-connect/can/map/map._List",
    "parent": "can-connect/can/map/map.hydrators",
    "comment": " "
  },
  "can-connect/can/map/map.instance": {
    "type": "function",
    "name": "can-connect/can/map/map.instance",
    "parent": "can-connect/can/map/map.hydrators",
    "src": {
      "line": 188,
      "codeLine": 201,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCreates a `Map` instance.\n",
    "title": "instance",
    "signatures": [
      {
        "code": "connection.instance( props )",
        "description": "\n\n  Uses the [can-connect/can/map/map._Map] property if available, otherwise\n  creates the [can-types.DefaultMap].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The raw instance data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Map"
            }
          ],
          "description": "An observable map type.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The raw instance data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Map"
        }
      ],
      "description": "An observable map type.\n\t "
    }
  },
  "can-connect/can/map/map.list": {
    "type": "function",
    "name": "can-connect/can/map/map.list",
    "parent": "can-connect/can/map/map.hydrators",
    "src": {
      "line": 205,
      "codeLine": 223,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCreates a `List` instance given raw data.\n",
    "title": "list",
    "signatures": [
      {
        "code": "connection.list(listData, set)",
        "description": "\n\n  Uses the [can-connect/can/map/map._List] property if available, otherwise\n  creates the [can-connect/can/map/map._Map].List if available, and then finally\n  defaults to [can-util/js/types/types.DefaultList].\n\n  This will add properties on `listData` to the list too.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The raw list data."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set the data belongs to."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "An observable list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set the data belongs to."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "An observable list.\n\t "
    }
  },
  "can-connect/can/map/map.updatedList": {
    "type": "function",
    "name": "can-connect/can/map/map.updatedList",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "src": {
      "line": 235,
      "codeLine": 249,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nUpdates a list with response data.\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedList( list, listData, set)",
        "description": "\n\n  Updates the list within a batch event. Overwrite this if you want custom updating behavior.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The list to be updated."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "Raw list data."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set of the list being updated.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set of the list being updated.\n\t "
    }
  },
  "can-connect/can/map/map.createdInstance": {
    "src": {
      "line": 280,
      "codeLine": 294,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.createData].\n",
    "title": "createdInstance",
    "name": "can-connect/can/map/map.createdInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"created\" event on the map and the map's constructor function.\n",
        "params": [
          {
            "types": [
              {
                "type": "Map"
              }
            ],
            "name": "instance",
            "description": "a Map instance"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the updated properties\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the updated properties\n\t "
    }
  },
  "can-connect/can/map/map.updatedInstance": {
    "src": {
      "line": 295,
      "codeLine": 306,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.updateData].\n",
    "title": "updatedInstance",
    "name": "can-connect/can/map/map.updatedInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.updatedInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"updated\" event on the map and the map's constructor function.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.destroyedInstance": {
    "src": {
      "line": 307,
      "codeLine": 318,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.destroyData].\n",
    "title": "destroyedInstance",
    "name": "can-connect/can/map/map.destroyedInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.destroyedInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"destroyed\" event on the map and the map's constructor function.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.callbackInstanceEvents": {
    "type": "function",
    "name": "can-connect/can/map/map.callbackInstanceEvents",
    "parent": "can-connect/can/map/map.static",
    "src": {
      "line": 347,
      "codeLine": 370,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nDispatch events for instance callbacks, e.g. [can-connect/can/map/map.updatedInstance].\n",
    "title": "callbackInstanceEvents",
    "signatures": [
      {
        "code": "canMapBehavior.callbackInstanceEvents( cbName, instance )",
        "description": "\n\n  Dispatches events in the end of instance callbacks. This static method could be useful for overriding\n  instance callbacks. E.g.: to override `updatedInstance` callback:\n\n  ```\n  connect( [ canMap, {\n      updatedInstance: function( instance, props ) {\n          instance = smartMerge( instance, props );\n          canMapBehavior.callbackInstanceEvents( \"updated\", instance );\n      }\n  } ], {} )\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "cbName",
            "description": "Callback name prefix, e.g. (\"created\" | \"updated\" | \"destroyed\") to form a string \"createdInstance\", etc."
          },
          {
            "types": [
              {
                "type": "Map"
              }
            ],
            "name": "instance",
            "description": "A Map instance.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Map"
        }
      ],
      "name": "instance",
      "description": "A Map instance.\n"
    }
  },
  "can-connect/can/map/map.getList": {
    "type": "function",
    "name": "can-connect/can/map/map.getList",
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 393,
      "codeLine": 429,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n\n## Use\n\n```\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nTodo.getList({due: \"today\"}).then(function(todos){\n\n});\n```\n \n",
    "description": "\nGets a list of instances of the map type.\n",
    "title": "getList",
    "signatures": [
      {
        "code": "Map.getList(set)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "CanList"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "CanList"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.findAll": {
    "type": "function",
    "name": "can-connect/can/map/map.findAll",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "connection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 434,
      "codeLine": 441,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": " \n",
    "description": "\nAlias of [can-connect/can/map/map.getList]. You should use `.getList()`.\n",
    "title": "findAll",
    "hide": true
  },
  "can-connect/can/map/map.get": {
    "type": "function",
    "name": "can-connect/can/map/map.get",
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 446,
      "codeLine": 482,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n\n## Use\n\n```js\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nTodo.get({id: 5}).then(function(todo){\n\n});\n```\n \n",
    "description": "\nGets an instance of the map type.\n",
    "title": "get",
    "signatures": [
      {
        "code": "Map.get(params)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "params",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Map"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "params",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Map"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.findOne": {
    "type": "function",
    "name": "can-connect/can/map/map.findOne",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "connection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 488,
      "codeLine": 495,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": " \n",
    "description": "\nAlias of [can-connect/can/map/map.get]. You should use `.get()`.\n",
    "title": "findOne",
    "hide": true
  },
  "can-connect/can/map/map.prototype.isNew": {
    "src": {
      "line": 531,
      "codeLine": 543,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map has not been persisted.\n",
    "title": "isNew",
    "name": "can-connect/can/map/map.prototype.isNew",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isNew()",
        "description": "\n\n  Returns `true` if [can-connect/base/base.id] is 0 or truthy.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/map/map.prototype.isSaving": {
    "src": {
      "line": 551,
      "codeLine": 563,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map is currently being saved.\n",
    "title": "isSaving",
    "name": "can-connect/can/map/map.prototype.isSaving",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isSaving()",
        "description": "\n\n  Returns `true` if .save() has been called, but has not resolved yet.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/map/map.prototype.isDestroying": {
    "src": {
      "line": 569,
      "codeLine": 589,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map is currently being destroyed.\n",
    "title": "isDestroying",
    "name": "can-connect/can/map/map.prototype.isDestroying",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isDestroying()",
        "description": "\n\nObserves if the promise returned by `.destroy()` has completed.  This is\noften used in template like:\n\n```\n<button ($click)=\"todo.destroy()\"\n   {{#todo.isDestroying}}disabled{{/todo.isDestroying}}>\n  X\n</button>\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `.destroy()` has been called but is not resolved yet.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `.destroy()` has been called but is not resolved yet.\n\t "
    }
  },
  "can-connect/can/map/map.prototype.save": {
    "src": {
      "line": 595,
      "codeLine": 632,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\n```\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nnew Todo({name: \"dishes\"}).save();\n```\n\t \n",
    "description": "\nPersists the map's data to the connection.\n",
    "title": "save",
    "name": "can-connect/can/map/map.prototype.save",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.save( [success], [error] )",
        "description": "\n\n  Calls [can-connect/connection.save].\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "success",
            "description": "A function that is called if the save is successful."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function that is called if the save is rejected."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance is successful.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function that is called if the save is rejected."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance is successful.\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.prototype.destroy": {
    "src": {
      "line": 640,
      "codeLine": 677,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\n```\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nnew Todo({name: \"dishes\"}).save(function(todo){\n  todo.destroy();\n});\n```\n\t \n",
    "description": "\nDelete's the instance with the connection.\n",
    "title": "destroy",
    "name": "can-connect/can/map/map.prototype.destroy",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.destroy( [success], [error] )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "success",
            "description": "A function that is called if the destroy is successful."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function that is called if the destroy is rejected."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance is successful.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function that is called if the destroy is rejected."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance is successful.\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.map-static": {
    "name": "can-connect/can/map/map.map-static",
    "title": "map static methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 0
  },
  "can-connect/can/map/map.map": {
    "name": "can-connect/can/map/map.map",
    "title": "map instance methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 1
  },
  "can-connect/can/map/map.hydrators": {
    "name": "can-connect/can/map/map.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 2
  },
  "can-connect/can/map/map.serializers": {
    "name": "can-connect/can/map/map.serializers",
    "title": "serializers",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 3
  },
  "can-connect/can/map/map.identifiers": {
    "name": "can-connect/can/map/map.identifiers",
    "title": "identifiers",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 4
  },
  "can-connect/can/map/map.instance-callbacks": {
    "name": "can-connect/can/map/map.instance-callbacks",
    "title": "instance callbacks",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 5
  },
  "can-connect/can/map/map.static": {
    "name": "can-connect/can/map/map.static",
    "title": "behavior static methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 6
  },
  "can-connect/can/map/map": {
    "src": {
      "path": "node_modules/can-connect/can/map/map.md"
    },
    "body": "\n\n## Use\n\nThe `can-connect/can/map/map` behavior make a connection use instances of a [can-define/map/map] and\n[can-define/list/list].  It also adds methods to the [can-define/map/map]\nthat use the connection for retrieving, creating, updating, and destroying Map instances.\n\nTo use `can-connect/can/map/map`, first create a Map and List constructor function:\n\n```\nvar Todo = DefineMap.extend({\n  canComplete: function(ownerId) {\n    return this.ownerId === ownerId;\n  }\n});\n\nvar TodoList = DefineList.extend({\n  \"#\": Todo,\n  incomplete: function(){\n    return this.filter({complete: false});\n  }\n});\n```\n\nNext, pass the Map and List constructor functions to `connect` as options. The following\ncreates a connection that connects `Todo` and `TodoList` to a restful URL:\n\n```js\nvar connect = require(\"can-connect\");\n\nvar todoConnection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/can/map/map\")\n],{\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\"\n});\n```\n\nNow the connection can be used to CRUD `Todo` and `TodoList`s:\n\n```js\ntodoConnection.getList({}).then(function(todos){\n  var incomplete = todos.incomplete();\n  incomplete[0].canComplete( 5 ) //-> true\n});\n```\n\nHowever, because `can/map` adds methods to the `Map` option, you can use `Todo` directly to\nretrieve `Todo` and `TodoList`s:\n\n```js\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n```\n\nYou can also create, update, and [can-connect/can/map/map.prototype.destroy] todo instances. Notice\nthat [can-connect/can/map/map.prototype.save] is used to create\nand update:\n\n\n```js\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.set({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\nThere's also methods that let you know if an instance is in the process of being\n[can-connect/can/map/map.prototype.isSaving saved] or [can-connect/can/map/map.prototype.isDestroying destroyed]:\n\n```js\nvar savePromise = new Todo({name: \"dishes\"}).save();\ntodo.isSaving() //-> true\n\nsavePromise.then(function(){\n\ttodo.isSaving() //-> false\n\n\tvar destroyPromise = todo.destroy();\n\ttodo.isDestroying() //-> true\n\n\tdestroyPromise.then(function(){\n\n\t\ttodo.isDestroying() //-> false\n\t})\n})\n```\n\n",
    "description": "\nMake a connection use a [can-define/map/map] type.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect/can/map/map",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "canMap( baseConnection )",
        "description": "\n\n  Implements the hydrators, serializers, identifiers, and instance\n  callback interfaces of [can-connect/constructor/constructor] so they work with a [can-define/map/map] and [can-define/list/list].\n  Adds static methods like [can-connect/can/map/map.getList] and prototype methods\n  like [can-connect/can/map/map.prototype.isDestroying] to the Map type that make use of the connection's\n  methods.\n\n\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/constructor-hydrate/constructor-hydrate": {
    "name": "can-connect/can/constructor-hydrate/constructor-hydrate",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 75,
      "path": "node_modules/can-connect/can/constructor-hydrate/constructor-hydrate.js"
    },
    "body": "\n\n## Use\n\nThis behavior is useful if `Type` converters of [can-define/map/map] are used in multiple places of your app.\nIn which case if a property is set with an id of an already created instance then the connection behaviour will\ncheck [can-connect/constructor/store/store.instanceStore]. If there is already an instance with the same id\nthen it will be returned instead of a new object.\n\nLet's say we have the following page state with two properties which are of type `Student`:\n```js\nvar myPage = new (DefineMap.extend({\n    student: { Type: Student },\n\t   teamLead: { Type: Student },\n}));\n```\n\nThe type `Student` is a DefineMap with `can-connect` capabilities:\n```js\nvar Student = DefineMap.extend({});\nStudent.List = DefineList.extend({\n    '#': { Type: Student }\n});\n\nStudent.connection = connect([\n\t   require(\"can-connect/data/url/url\"),\n\t   require(\"can-connect/constructor/constructor\"),\n\t   require(\"can-connect/constructor/store/store\"),\n\t   require(\"can-connect/can/map/map\"),\n\t   require(\"can-connect/can/constructor-hydrate/constructor-hydrate\"),\n], {\n\t   Map: Student,\n\t   List: Student.List,\n\t   url: \"api/students\"\n});\n```\n\nNow lets say your application loads `student` in a regular way using `Student.get()`, and it gets data\nfor `teamLead` from somewhere else. Also let's the team lead is the same person as student:\n\n```js\nmyPage.student = Student.get({id: 1});\n\nmyPage.loadTeamLead().then( function(person){ myPage.teamLead = person; } );\n```\n\nWithout [can-connect/can/constructor-hydrate/constructor-hydrate] we would end up with two instances of `Student` with the same id.\nAlso, the `teamLead` would not be referencing an instance that is stored in connection's `instanceStore`\nand thus will loose real-time updates if [can-connect/real-time/real-time] was used.\n\nThis behavior solves this problem by checking `instanceStore` before creating a new instance. So, in our app\nit will return the existing instance and give it to `teamLead`. Now both `myPage.student` and `myPage.teamLead`\nare referencing the same instance:\n\n```js\nvar instanceStore = Student.connection.instanceStore;\nmyPage.student === myPage.teamLead;                           // => true\nmyPage.teamLead === instanceStore.get( myPage.teamLead.id );  // => true\n```\n\n",
    "description": "\nAlways check the [can-connect/constructor/store/store.instanceStore] when creating new instances of the connected [can-connect/can/map/map._Map] type.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructorHydrate( baseConnection )",
        "description": "\n\n\t Overrides [can-define/map/map]'s `setup` method and checks whether a newly created instance already\n\t exists in [can-connect/constructor/store/store.instanceStore]. If it exists that instance will be\n\t returned instead of a new object.\n\n\t This behavior has to be used with [can-connect/constructor/store] and [can-connect/can/map/map] behaviors.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/merge/merge.createdInstance": {
    "type": "function",
    "name": "can-connect/can/merge/merge.createdInstance",
    "parent": "can-connect/can/merge/merge.instance-callbacks",
    "src": {
      "line": 7,
      "codeLine": 24,
      "path": "node_modules/can-connect/can/merge/merge.js"
    },
    "body": "",
    "description": "Makes minimal updates to an instance's properties and its nested properties using [can-connect/helpers/map-deep-merge].\n\n",
    "title": "createdInstance",
    "signatures": [
      {
        "code": "connection.createdInstance(instance, props)",
        "description": "\n\n  Calls `mapDeepMerge` and triggers the `'created'` event on the instance\n  within a [can-event/batch/batch batch].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance that was just created whose\nproperties will be updated."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The new data the instance and children of the\ninstance should be updated to look like.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The new data the instance and children of the\ninstance should be updated to look like.\n\t "
    }
  },
  "can-connect/can/merge/merge.destroyedInstance": {
    "type": "function",
    "name": "can-connect/can/merge/merge.destroyedInstance",
    "parent": "can-connect/can/merge/merge.instance-callbacks",
    "src": {
      "line": 30,
      "codeLine": 47,
      "path": "node_modules/can-connect/can/merge/merge.js"
    },
    "body": "",
    "description": "Makes minimal updates to an instance's properties and its nested properties using [can-connect/helpers/map-deep-merge].\n\n",
    "title": "destroyedInstance",
    "signatures": [
      {
        "code": "connection.destroyedInstance(instance, props)",
        "description": "\n\n  Calls `mapDeepMerge` and triggers the `'destroyed'` event on the instance\n  within a [can-event/batch/batch batch].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance that was just destroyed whose\nproperties will be updated."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The new data the instance and children of the\ninstance should be updated to look like.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The new data the instance and children of the\ninstance should be updated to look like.\n\t "
    }
  },
  "can-connect/can/merge/merge.updatedInstance": {
    "type": "function",
    "name": "can-connect/can/merge/merge.updatedInstance",
    "parent": "can-connect/can/merge/merge.instance-callbacks",
    "src": {
      "line": 53,
      "codeLine": 70,
      "path": "node_modules/can-connect/can/merge/merge.js"
    },
    "body": "",
    "description": "Makes minimal updates to an instance's properties and its nested properties using [can-connect/helpers/map-deep-merge].\n\n",
    "title": "updatedInstance",
    "signatures": [
      {
        "code": "connection.updatedInstance(instance, props)",
        "description": "\n\n  Calls `mapDeepMerge` and triggers the `'updated'` event on the instance\n  within a [can-event/batch/batch batch].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance that was just updated whose\nproperties will be updated."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The new data the instance and children of the\ninstance should be updated to look like.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The new data the instance and children of the\ninstance should be updated to look like.\n\t "
    }
  },
  "can-connect/can/merge/merge.updatedList": {
    "type": "function",
    "name": "can-connect/can/merge/merge.updatedList",
    "parent": "can-connect/can/merge/merge.instance-callbacks",
    "src": {
      "line": 76,
      "codeLine": 92,
      "path": "node_modules/can-connect/can/merge/merge.js"
    },
    "body": "",
    "description": "Makes minimal updates to an list's items and those items' nested properties using [can-connect/helpers/map-deep-merge].\n\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedList(list, listData)",
        "description": "\n\n  Calls `mapDeepMerge` on the list\n  within a [can-event/batch/batch batch].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The list that will be updated."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The new data the list and items in the\nlist should be updated to look like.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "name": "listData",
      "description": "The new data the list and items in the\nlist should be updated to look like.\n\t "
    }
  },
  "can-connect/can/merge/merge.instance-callbacks": {
    "name": "can-connect/can/merge/merge.instance-callbacks",
    "title": "instance callbacks",
    "type": "group",
    "parent": "can-connect/can/merge/merge",
    "description": "",
    "order": 5
  },
  "can-connect/can/merge/merge": {
    "src": {
      "path": "node_modules/can-connect/can/merge/merge.md"
    },
    "body": "\n\n## Use\n\nTo use `can-connect/can/merge/merge`, you have to:\n\n1. Add the behavior after [can-connect/can/map/map], and\n2. Make sure all types, especially `List` types are properly configured.  \n\nAdding the `can-connect/can/merge/merge` behavior after [can-connect/can/map/map]\nis pretty straightforward.  When you create a custom connection, create it as follows:\n\n```js\nvar canMergeBehavior = require(\"can-connect/can/merge/merge\");\nvar canMapBehavior = require(\"can-connect/can/map/map\");\n\nvar ClassRoom = DefineMap.extend({\n\t...\n});\n\nClassRoom.List = DefineList.extend({\n\t\"#\": ClassRoom\n});\n\nClassRoom.algebra = new set.Algebra({...})\n\nClassRoom.connection = connect([..., canMapBehavior, canMergeBehavior, ...],{\n\tMap: ClassRoom,\n\tList: ClassRoom.List\n});\n```\n\nFor [can-connect/helpers/map-deep-merge] to\nmerge correctly, it needs to know how to uniquely identify an instance and\nbe able to convert raw data to instances and lists. `map-deep-merge` looks for\nthis configuration on the `.algebra` and `.connection` properties of the\n[can-define.types.TypeConstructor] setting on [can-define] types.\n\nThis is more easily understood if the `ClassRoom` has a `students` property that\nis a list of `Student` instances like:\n\n```js\nvar ClassRoom = DefineMap.extend({\n\tstudents: Student.List\n});\n```\n\nTo be able to uniquely identify `Student` instances, make sure `Student`\nhas an `algebra` property that is configured with the unique identifier property:\n\n```js\nStudent = DefineMap.extend({ ... });\n\nStudent.algebra = new set.Algebra(set.props.id(\"_id\"))\n```\n\nAlso, make sure that `Student.List` points its [can-define/list/list.prototype.wildcardItems]\ndefinition to `Student` like the following:\n\n```js\nStudent.List = DefineList.extend({\n    \"#\": Student\n});\n```\n\nFinally, the default method used to create a `Student` will be `new Student(props)`.  However,\nif `Student`'s have a `.connection`, the `.connection.hydrateInstance(props)` will be\nused.  This is useful if `Student`s should be looked up in their [can-connect/constructor/store/store.instanceStore].\n\nFor example, `Student` might have a connection like:\n\n```js\nStudent.connection = baseMap({\n\tMap: Student,\n\tList: Student.List,\n\turl: \"/services/students\",\n\tname: \"students\"\n});\n```\n\n",
    "description": "\nUpdate nested data structures correctly with the response from the server.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect/can/merge/merge",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "canMergeBehavior( baseConnection )",
        "description": "\n\nOverwrites [can-connect/can/map/map]'s instance callbacks\nso they use [can-connect/helpers/map-deep-merge].  [can-connect/helpers/map-deep-merge]\nis able to make minimal changes to instances and lists given raw data.  Use this behavior\nafter the [can-connect/can/map/map] behavior:\n\n```js\nvar canMergeBehavior = require(\"can-connect/can/merge/merge\");\nvar canMapBehavior = require(\"can-connect/can/map/map\");\n\nconnect([..., canMapBehavior, canMergeBehavior, ...],{\n\t...\n});\n```\n\nThe connection's [can-connect/can/map/map._Map], [can-connect/can/map/map._List]\nand any other types that they reference must be property configured.  That configuration\nis discussed in the `Use` section below.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/model/model": {
    "src": {
      "path": "node_modules/can-connect/can/model/model.md"
    },
    "body": "\n## Use\n\n`can-connect/can/model` is for backwards compatibility\nwith `can.Model` so that developers can migrate\nto `can-connect` without having to rewrite their models immediately.\n\nHowever, use of `can.Model` will be deprecated in CanJS 3.0. Instead of extending `can.Model`,\nextend [can-map] and [can-list] and use the [can-connect/can/map/map] behavior to connect your Map and List to a connection:\n\n```js\nvar CanMap = require(\"can-map\");\nvar CanList = require(\"can-list\");\n\nvar Todo = CanMap.extend({ ... });\n\nvar TodoList = CanList.extend({\n  Map: Todo\n},{ ... });\n\nvar todoConnection = connect([\"data-url\",\"constructor\",\"can/map\"],{\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\"\n});\n```\n\nOr, use the [can-connect/can/super-map/super-map] function to create a connection with the \"super\" behaviors:\n\n```\nvar todoConnection = superMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nFor your legacy code, you should just need to import \"can-connect/can/model/\" instead of \"can/model/\" like:\n\n```js\nimport Model from \"can-connect/can/model/\";\n\nTodo = Model.extend({\n  findAll: \"/todos\"\n},{});\n\nTodo.findAll({}).then(function(todos){\n\n});\n```\n\n## Upgrading can.Models to can-connect\n\nThis section walks through making the necessary changes to upgrade a legacy can.Model to use `can-connect` and its\nbehaviors.  We'll convert a `can.Model` and `can.Model.List` that looks like:\n\n```\nTodo = can.Model.extend({\n  resource: \"/\",\n  destroy: \"POST /todos/{id}/delete\",\n  findOne: function(params){\n    return $.get(\"/todos/\"+params._id);\n  },\n\n  parseModels: function(data){\n    return data.todos;\n  },\n  parseModel: \"todo\",\n\n  id: \"_id\",\n},{\n  method: function(){ ... },\n  define: { ... }\n});\n\nTodo.List = Todo.List.extend({ ... });\n```\n\nConverting this to use `can-connect` looks like:\n\n```js\nvar CanMap = require(\"can-map\"),\n\tCanList = require(\"can-list\");\n\nTodo = CanMap.extend({\n  method: function(){ ... },\n  define: { ... }\n});\nTodo.List = CanList.extend({\n  Map: Todo\n},{ ... })\n\nconnect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/data/parse/parse\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\"),\n\trequire(\"can-connect/can/map/map\")\n  ],\n  {\n    Map: Todo,\n    List: Todo.List,\n\n    url: {\n      resource: \"/\",\n      destroyData: \"POST /todos/{id}/delete\",\n      getData: function(params){\n        return $.get(\"/todos/\"+params._id);\n      }\n    },\n\n    parseListData: function(data){\n      return data.todos;\n    },\n    parseInstanceProp: \"todo\",\n\n    idProp: \"_id\"\n  });\n```\n\nInstead of `Todo.findAll` and `Todo.findOne`, use `Todo.getList` and `Todo.get`.\n\nLets break this down in the following sections.\n\n### Defining the Map and List\n\nThe first step is to pull out the parts of the Model and Model.List that define the\nobservable Map and List's behavior into a [can-map] and [can-list]:\n\n```js\nvar CanMap = require(\"can-map\"),\n\tCanList = require(\"can-list\");\n\nTodo = CanMap.extend({\n  method: function(){ ... },\n  define: { ... }\n});\nTodo.List = CanList.extend({\n  Map: Todo\n},{ ... })\n```\n\nOne of the main advantageous of `can-connect` is that it lets separate persistence behavior\nfrom property behavior.\n\n### Connecting the Map and List to behaviors\n\nThe next step is to connect the Map and List to the right behaviors.  The following\nadds behaviors with similar functionality to legacy `can.Map` and uses the [can-connect/can/map/map] behavior\n(which makes use of [can-connect/constructor/constructor]) to connect the connection to the provided Map and List types:\n\n```\nconnect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/data/parse/parse\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\"),\n\trequire(\"can-connect/can/map/map\")\n  ],\n  {\n    Map: Todo,\n    List: Todo.List,\n    ...\n  })\n```\n\n### Connecting to urls\n\nThe [can-connect/data/url/url] behavior supports CRUDing data from urls.  It can be configured like:\n\n```\nconnect([\"data-url\", ...],\n  {\n    ...\n    url: {\n      resource: \"/\",\n      destroyData: \"POST /todos/{id}/delete\",\n      getData: function(params){\n        return $.get(\"/todos/\"+params._id);\n      }\n    },\n    ...\n  });\n```\n\n### Correcting response data\n\nThe [can-connect/data/parse/parse] behavior supports correcting response data.  It can be configured like:\n\n```\nconnect([..., \"data-parse\", ...],\n  {\n    ...\n    parseListData: function(data){\n      return data.todos;\n    },\n    parseInstanceProp: \"todo\",\n    ...\n  });\n```\n\n### Specifying the id\n\nThe id of a model is used in a variety of ways.  It's part of the [can-connect/base/base] behavior\nadded to every connection.  You can customize which property represents the id with [can-connect/base/base.idProp].\n\n```\nconnect([...],\n  {\n    idProp: \"_id\"\n  });\n```\n\n### Retrieving data\n\nThe [can-connect/can/map/map] behavior adds a `getList` and `get` method to the `Map` option.  Use them in\nplace of `findAll` and `findOne`:\n\n```\nTodo.findAll({}).then(function(todosList){ ... });\nTodo.findOne({id: 5}).then(function(todo){ ... });\n```\n\n## Differences from can.Model\n\nModel's produced from `can-connect/can/model`:\n\n - Do not support `makeFindAll` or `makeFindOne`.  If your legacy code did this, you can probably add it as a custom behavior.\n - Has the instance store at `Model.store`, but items should be retrieved like `Model.store.get(id)`.\n - Should not use `Model.models` or `Model.model` to correct Ajax data and should instead use `Models.parseModel` and `Model.parseModels`.\n - Uses a Promise polyfill, not jQuery's promises.\n\n",
    "description": "Exports a constructor that works very similar to [can.Model](http://canjs.com/docs/can.Model.html). \n",
    "type": "module",
    "title": "",
    "name": "can-connect/can/model/model",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "Model.extend( static, prototype )",
        "description": "\n\n  Defines a [can-map] that has almost all of the functionality of\n  `can.Model`.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/ref/ref.hydrators": {
    "name": "can-connect/can/ref/ref.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/can/ref/ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.methods": {
    "name": "can-connect/can/ref/ref.methods",
    "title": "methods",
    "type": "group",
    "parent": "can-connect/can/ref/ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref": {
    "name": "can-connect/can/ref/ref",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 145,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n## Use\n\n`can/ref` is useful when the server might return either a reference to\na value or the value itself.  For example, in a MongoDB setup,\na request like `GET /game/5` might return:\n\n```\n{\n  id: 5,\n  teamRef: 7,\n  score: 21\n}\n```\n\nBut a request like `GET /game/5?$populate=teamRef` might return:\n\n```\n{\n  id: 5,\n  teamRef: {id: 7, name: \"Cubs\"},\n  score: 21\n}\n```\n\n`can/ref` can handle this ambiguity and even make lazy loading possible.\n\nTo use `can/ref`, first create a Map and a connection for the referenced type:\n\n```\nvar Team = DefineMap.extend({\n  id: 'string'\n});\n\nconnect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/constructor/store/store\"),\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/can/ref/ref\")\n],{\n    Map: Team,\n    List: Team.List,\n    ...\n})\n```\n\nThe connection is necessary because it creates an instance store which will\nhold instances of `Team` that the `Team.Ref` type will be able to access.\n\nNow we can create a reference to the Team within a Game map and the Game's connection:\n\n```\nvar Game = DefineMap.extend({\n  id: 'string',\n  teamRef: {type: Team.Ref.type},\n  score: \"number\"\n});\n\nsuperMap({\n  Map: Game,\n  List: Game.List\n})\n```\n\nNow, `teamRef` is a [can-connect/can/ref/ref.Map.Ref] type, which will\nhouse the id of the reference no matter how the server returns data, e.g.\n`game.teamRef.id`.\n\nFor example, without populating the team data:\n\n```\nGame.get({id: 5}).then(function(game){\n  game.teamRef.id //-> 7\n});\n```\n\nWith populating the team data:\n\n```\nGame.get({id: 5, populate: \"teamRef\"}).then(function(game){\n  game.teamRef.id //-> 7\n});\n```\n\nThe values of other properties and methods on the [can-connect/can/ref/ref.Map.Ref] type\nare determined by if the reference was populated or the referenced item already exists\nin the [can-connect/constructor/store/store.instanceStore].\n\nFor example, `value`, which points to the referenced instance, will be populated if the reference was populated:\n\n```\nGame.get({id: 5, $populate: \"teamRef\"}).then(function(game){\n  game.teamRef.value.name //-> 5\n});\n```\n\nOr, it will be populated if that instance had been loaded through another means and\nit’s in the instance store:\n\n```\nTeam.get({id: 7}).then(function(team){\n  // binding adds things to the store\n  team.on(\"name\", function(){})\n}).then(function(){\n  Game.get({id: 5}).then(function(game){\n    game.teamRef.value.name //-> 5\n  });\n})\n```\n\n`value` is an [can-define.types.get asynchronous getter], which means that even if\nthe referenced value isn't populated or loaded through the store, it can be lazy loaded. This\nis generally most useful in a template.\n\nThe following will make an initial request for game `5`, but when the template\ntried to read and listen to `game.teamRef.value.name`, a request for team `7`\nwill be made.\n\n```\nvar template = stache(\"{{game.teamRef.value.name}} scored {{game.score}} points\");\nGame.get({id: 5}).then(function(game){\n  template({game: game});\n});\n```\n\n\n\n",
    "description": "Handle references to instances in the raw data returned by the server. \n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "canRef( baseConnection )",
        "description": "\n\n  Makes a reference type that loads the related type or holds onto an existing one. This handles circular references and loads relevant data as needed.\n",
        "params": [
          {
            "types": [
              {
                "type": "connection"
              }
            ],
            "name": "baseConnection",
            "description": "The base connection should have [can-connect/can/map/map]\nalready applied to it.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "connection"
        }
      ],
      "name": "baseConnection",
      "description": "The base connection should have [can-connect/can/map/map]\nalready applied to it.\n"
    },
    "comment": " "
  },
  "can-connect/can/ref/ref.Map.Ref.static": {
    "name": "can-connect/can/ref/ref.Map.Ref.static",
    "title": "static",
    "type": "group",
    "parent": "can-connect/can/ref/ref.Map.Ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.Map.Ref.prototype": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-connect/can/ref/ref.Map.Ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.Map.Ref": {
    "type": "property",
    "name": "can-connect/can/ref/ref.Map.Ref",
    "params": [
      {
        "types": [
          {
            "type": "string"
          }
        ],
        "name": "id",
        "description": "string representing the record id"
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "value",
        "description": "instance loaded / hydrated"
      }
    ],
    "parent": "can-connect/can/ref/ref.hydrators",
    "src": {
      "line": 154,
      "codeLine": 163,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "title": "Map.Ref",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "value",
      "description": "instance loaded / hydrated"
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Instance for the id\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Instance for the id\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.store": {
    "name": "can-connect/can/ref/ref.Map.Ref.store",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.static",
    "src": {
      "line": 202,
      "codeLine": 207,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": " \n",
    "description": "A WeakReferenceMap that contains instances being created by their `._cid` property.\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map"
      }
    ],
    "title": "store"
  },
  "can-connect/can/ref/ref.Map.Ref.type": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.type",
    "parent": "can-connect/can/ref/ref.Map.Ref.static",
    "src": {
      "line": 209,
      "codeLine": 218,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "\n",
    "title": "type",
    "signatures": [
      {
        "code": "Map.Ref.type(ref)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "name": "ref",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/can/ref/ref.Map.Ref"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "String"
        },
        {
          "type": "Number"
        }
      ],
      "name": "ref",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/can/ref/ref.Map.Ref"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.promise": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.promise",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 230,
      "codeLine": 237,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Promise"
      }
    ],
    "title": "promise",
    "signatures": [
      {
        "code": "ref.promise",
        "description": "\nReturns a promise if it has already been resolved, if not, returns a new promise.",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.value": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.value",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 261,
      "codeLine": 268,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "value",
    "signatures": [
      {
        "code": "ref.value",
        "description": "\nReturns the actual object that reference points to.",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "object"
            }
          ],
          "description": "actual object that reference points to\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "object"
        }
      ],
      "description": "actual object that reference points to\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.reason": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.reason",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 279,
      "codeLine": 286,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "reason",
    "signatures": [
      {
        "code": "ref.reason",
        "description": "\nHandles the rejection case for the promise.",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "error message if the promise is rejected\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "error message if the promise is rejected\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isResolved": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isResolved",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 310,
      "codeLine": 318,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "\n",
    "title": "isResolved",
    "signatures": [
      {
        "code": "ref.isResolved",
        "description": "\nReturns a {boolean}.",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isRejected": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isRejected",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 321,
      "codeLine": 328,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "title": "isRejected",
    "signatures": [
      {
        "code": "ref.isRejected",
        "description": "\nReturns boolean if the promise was rejected.",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isPending": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isPending",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 332,
      "codeLine": 339,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "title": "isPending",
    "signatures": [
      {
        "code": "ref.isPending",
        "description": "\nReturns true if the state is not 'resolved' or 'rejected'.",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.serialize": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.serialize",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 343,
      "codeLine": 350,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "title": "serialize",
    "signatures": [
      {
        "code": "ref.serialize",
        "description": "\nReturns the `idProp`.",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "string"
            }
          ],
          "description": "idProp\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "string"
        }
      ],
      "description": "idProp\n "
    }
  },
  "can-connect/can/super-map/super-map": {
    "src": {
      "path": "node_modules/can-connect/can/super-map/super-map.md"
    },
    "body": "\n\n## Use\n\nThe `can-connect/can/super-map` module exports a helper function that creates a connection\nwith the \"advanced\" behaviors in can-connect and hooks it up to a [can-define/map/map]\nand [can-define/list/list].\n\nIf you are using CanJS, this is an easy way to create a connection that can be useful and\nfast in most circumstances.\n\nTo use it, first define a Map and List constructor function:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({ ... });\nvar TodoList = DefineList.extend({\n\t\"#\": Todo\n});\n```\n\nNext, call `superMap` with all of the options needed by the behaviors that `superMap` adds:\n\n```\nvar todoConnection = superMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\n[can-connect/can/map/map] adds CRUD methods to the `Map` option, you can use those to create,\nread, update and destroy todos:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.set({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nCreate connection with many of the best behaviors in can-connect and hook it up to\na [can-define/map/map].\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect/can/super-map/super-map",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "superMap(options)",
        "description": "\n\n  Creates a connection with the following behaviors: [can-connect/constructor/constructor],\n  [can-connect/can/map/map],\n  [can-connect/constructor/store/store],\n  [can-connect/data/callbacks/callbacks],\n  [can-connect/data/callbacks-cache/callbacks-cache],\n  [can-connect/data/combine-requests/combine-requests],\n  [can-connect/data/parse/parse],\n  [can-connect/data/url/url],\n  [can-connect/real-time/real-time],\n  [can-connect/fall-through-cache/fall-through-cache],\n  [can-connect/constructor/callbacks-once/callbacks-once].\n\n  And creates a [can-connect/data/localstorage-cache/localstorage-cache] to use as a [can-connect/base/base.cacheConnection].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/tag/tag": {
    "src": {
      "line": 0,
      "codeLine": 32,
      "path": "node_modules/can-connect/can/tag/tag.js"
    },
    "type": "module",
    "body": "\n## Use\n\n```\nconnect.tag(\"order-model\", connection);\n```\n\n```\n<order-model get-list=\"{type=orderType}\">\n  <ul>\n  {{#isPending}}<li>Loading</li>{{/isPending}}\n  {{#isResolved}}\n    {{#each value}}\n      <li>{{name}}</li>\n    {{/each}}\n  {{/isResolved}}\n  </ul>\n</order-model>\n```\n\n\n",
    "description": "\nMakes either getList or getInstance\n",
    "title": "",
    "name": "can-connect/can/tag/tag",
    "parent": "can-connect.modules",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "tagName",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "connection",
        "description": "\n"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "connection",
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/constructor/callbacks-once/callbacks-once": {
    "name": "can-connect/constructor/callbacks-once/callbacks-once",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 14,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "body": "\n",
    "description": "\nPrevents unecessary calls to the instance callback methods.\n",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "constructorCallbacksOnce( baseConnection )",
        "description": "\n\n  Prevents duplicate calls to the instance callback methods by tracking\n  the last data the methods were called with.  If called with the\n  same data again, it does not call the base connection's instance callback.\n\n\n",
        "params": []
      }
    ]
  },
  "can-connect/constructor/callbacks-once/callbacks-once.createdData": {
    "src": {
      "line": 20,
      "codeLine": 28,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.createData]. The result of this function will be used\nas the new response data.\n",
    "title": "createdData",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.createdData",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once"
  },
  "can-connect/constructor/callbacks-once/callbacks-once.updatedData": {
    "src": {
      "line": 29,
      "codeLine": 37,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.updateData]. The result of this function will be used\nas the new response data.\n",
    "title": "updatedData",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.updatedData",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once"
  },
  "can-connect/constructor/callbacks-once/callbacks-once.destroyedData": {
    "src": {
      "line": 38,
      "codeLine": 46,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.destroyData]. The result of this function will be used\nas the new response data.\n",
    "title": "destroyedData",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.destroyedData",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once"
  },
  "can-connect/constructor/store/store.stores": {
    "name": "can-connect/constructor/store/store.stores",
    "title": "stores",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 0
  },
  "can-connect/constructor/store/store.crud": {
    "name": "can-connect/constructor/store/store.crud",
    "title": "crud methods",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 1
  },
  "can-connect/constructor/store/store.hydrators": {
    "name": "can-connect/constructor/store/store.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 2
  },
  "can-connect/constructor/store/store": {
    "name": "can-connect/constructor/store/store",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 80,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe `constructor-store` extension is used to:\n - provide a store of instances and lists used by the client.\n - prevent multiple instances from being hydrated for the same [can-connect/base/base.id] or multiple\n   lists for the same [can-connect/base/base.listSet].\n\nThe stores provide access to an instance\nby its [can-connect/base/base.id] or a list by its [can-connect/base/base.listSet]. These stores are\nused by other extensions like [can-connect/real-time/real-time] and [can-connect/fall-through-cache/fall-through-cache].\n\nLets see how `constructor-store`'s behavior be used to prevent multiple\ninstances from being hydrated.  This example allows you to create multiple instances of a `todoEditor` that loads\nand edits a todo instance.\n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/constructor-store.html'></div>\n\nYou'll notice that you can edit one todo's name and the other\ntodo editors update.  This is because each `todoEditor` gets the same instance in memory.  So that when it\nupdates the todo's name ...\n\n```\nelement.firstChild.onchange = function(){\n  todo.name = this.value;\n};\n```\n\n... the other widgets update because they have bound on the same instance:\n\n```\nObject.observe(todo, update, [\"update\"] );\ntodosConnection.addInstanceReference(todo);\n```\n\nEach `todoEditor` gets the same instance because they called [can-connect/constructor/store/store.addListReference]\nwhich makes it so anytime a todo with `id=5` is requested, the same instance is returned.\n\nNotice that if you change an input element, and click \"Create Todo Editor\", all the `todoEditor`\nwidgets are set back to the old text.  This is because whenever data is loaded from the server,\nit is passed to [can-connect/constructor/constructor.updatedInstance] which defaults to overwriting any current\nproperties with those from the server.\n\nTo make sure the server has the latest, you can save a todo by hitting \"ENTER\".\n\nFinally, this widget cleans itself up nicely when it is removed by unobserving the\n`todo` instance and\n[can-connect/constructor/store/store.deleteInstanceReference deleting the instance reference]. Doing this\nprevents memory leaks.\n\n```\nObject.unobserve(todo, update, [\"update\"] );\ntodosConnection.deleteInstanceReference(todo);\n```\n\n\n\n\n",
    "description": "\nSupports saving and retrieving lists and instances in a store.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructorStore( baseConnection )",
        "description": "\n\n  Overwrites baseConnection so it contains a store for\n  instances and lists.  It traps calls to the\n  [can-connect/constructor/store/store.hydrateInstance] and\n  [can-connect/constructor/store/store.hydrateList] methods to\n  use instances or lists in the store if available. It\n  overwrites \"CRUD METHODS\" to make sure that while any request\n  is pending, all lists and instances are added to the store.\n  Finally, it provides methods to add and remove items in the\n  store via reference counting.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/constructor/store/store.instanceStore": {
    "name": "can-connect/constructor/store/store.instanceStore",
    "type": "property",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 112,
      "codeLine": 129,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nA store of instances mapped by [can-connect/base/base.id].\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "\n\n  Stores instances by their [can-connect/base/base.id] which have had\n  [can-connect/constructor/store/store.addInstanceReference] called more\n  times than [can-connect/constructor/store/store.deleteInstanceReference].\n\n  ```js\n  connection.addInstanceReference(todo5);\n  connection.instanceStore.get(\"5\") //-> todo5\n  ```\n\t "
      }
    ],
    "title": "instanceStore"
  },
  "can-connect/constructor/store/store.listStore": {
    "name": "can-connect/constructor/store/store.listStore",
    "type": "property",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 130,
      "codeLine": 146,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "A store of lists mapped by [can-connect/base/base.listSet].\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "\n\n  Stores lists by their [can-connect/base/base.listSet] which have had\n  [can-connect/constructor/store/store.addListReference] called more\n  times than [can-connect/constructor/store/store.deleteListReference].\n\n  ```js\n  connection.addInstanceReference(allTodos,{});\n  connection.instanceStore.get({}) //-> allTodos\n  ```\n\t "
      }
    ],
    "title": "listStore"
  },
  "can-connect/constructor/store/store.addInstanceReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.addInstanceReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 163,
      "codeLine": 227,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe [can-connect/constructor/store/store.instanceStore] contains a collection of instances\ncreated for each [can-connect/base/base.id]. The `instanceStore` is used to prevent creating the\nsame instance multiple times.  Instances need to be added to this store for this behavior\nto happen.  To do this, call `addInstanceReference` like the following:\n\n```\n// A basic connection:\nvar todoConnection = connect([\n  require(\"can-connect/constructor/store/store\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"/todos\"\n});\n\nvar originalTodo;\n\n// Get a todo:\ntodoConnection.get({id: 5}).then(function( todo ){\n\n  // Add it to the store\n  todoConnection.addInstanceReference(todo);\n  originalTodo = todo;\n});\n```\n\nNow, if you were to retrieve the same data sometime later,\nit would be the same instance.\n\n```\ntodoConnection.get({id: 5}).then(function( todo ){\n\n  todo === originalTodo //-> true\n});\n```\n\nThe `.getData`  response data is passed with `originalTodo` to [can-connect/constructor/constructor.updatedInstance]\nwhich can update the `originalTodo` with the new data.\n\n\nAll these instances stay in memory.  Use [can-connect/constructor/store/store.deleteInstanceReference]\nto remove them.\n\nTypically, `addInstanceReference` is called when something expresses interest in the interest, such\nas an event binding, and `deleteInstanceReference` is called when interest is removed.\n\n\t \n",
    "description": "\nAdds a reference to an instance so it can be easily looked up.\n",
    "title": "addInstanceReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Adds a reference to an instance in the [can-connect/constructor/store/store.instanceStore] by [can-connect/base/base.id].\n  The number of references are incremented.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to add.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to add.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.deleteInstanceReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.deleteInstanceReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 247,
      "codeLine": 278,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\n`deleteInstanceReference` is called to remove references to instances in\nthe [can-connect/constructor/store/store.instanceStore] so the instances maybe garbage\ncollected.  It's usually called when the application or some part of the application no\nlonger is interested in an instance.\n\n[can-connect/constructor/store/store.addInstanceReference] has an example of adding\nan instance to the store.  The following continues that example to remove\nthe `originalTodo` from the store:\n\n```\ntodoConnection.deleteInstanceReference(originalTodo);\n```\n\n\t \n",
    "description": "\nRemoves a reference to an instance by [can-connect/base/base.id] so it can be garbage collected.\n",
    "title": "deleteInstanceReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Decrements the number of references to an instance in the [can-connect/constructor/store/store.instanceStore].\n  Removes the instance if there are no longer any references.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to remove.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to remove.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.addListReference": {
    "type": "property",
    "name": "can-connect/constructor/store/store.addListReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 281,
      "codeLine": 346,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe [can-connect/constructor/store/store.listStore] contains a collection of lists\ncreated for each [can-connect/base/base.listSet]. The `listStore` is used to prevent creating the\nsame list multiple times and for identifying a list for a given set. Lists need to be added to this store for this behavior\nto happen.  To do this, call `addListReference` like the following:\n\n```\n// A basic connection:\nvar todoConnection = connect([\n  require(\"can-connect/constructor/store/store\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"/todos\"\n});\n\nvar dueToday;\n\n// Get a todo:\ntodoConnection.getList({due: \"today\"}).then(function( todos ){\n\n  // Add it to the store\n  todoConnection.addListReference(todos, {due: \"today\"});\n  dueToday = todos;\n});\n```\n\nNow, if you were to retrieve the same data sometime later,\nit would be the same list.\n\n```\ntodoConnection.get({due: \"today\"}).then(function( todos ){\n\n  todos === dueToday //-> true\n});\n```\n\nThe `.getListData`  response data is passed with `dueToday` to [can-connect/constructor/constructor.updatedList]\nwhich can update `dueToday` with the new data.\n\nAll these lists stay in memory.  Use [can-connect/constructor/store/store.deleteListReference]\nto remove them.\n\nTypically, `addListReference` is called when something expresses interest in the list, such\nas an event binding, and `deleteListReference` is called when interest is removed.\n\n\t \n",
    "description": "\nAdds a reference to a list so it can be easily looked up.\n",
    "types": [
      {
        "type": "WeakReferenceMap"
      }
    ],
    "title": "addListReference",
    "signatures": [
      {
        "code": "connection.addListReference( list[, set] )",
        "description": "\n\n  Adds a reference to a list in the [can-connect/constructor/store/store.listStore].  The number of\n  references are incremented.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The list to add.\n"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "optional": true,
            "name": "set",
            "description": "The set this list represents if it can't be identified with [can-connect/base/base.listSet].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "optional": true,
      "name": "set",
      "description": "The set this list represents if it can't be identified with [can-connect/base/base.listSet].\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.deleteListReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.deleteListReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 352,
      "codeLine": 383,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\n`deleteListReference` is called to remove references to lists in\nthe [can-connect/constructor/store/store.listStore] so the lists maybe garbage\ncollected.  It's usually called when the application or some part of the application no\nlonger is interested in an list.\n\n[can-connect/constructor/store/store.addListReference] has an example of adding\na list to the store.  The following continues that example to remove\nthe `dueToday` from the store:\n\n```\ntodoConnection.deleteListReference(dueToday);\n```\n\n\t \n",
    "description": "\nRemoves a reference to a list by [can-connect/base/base.listSet] so it can be garbage collected.\n",
    "title": "deleteListReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Decrements the number of references to an list in the [can-connect/constructor/store/store.listStore].\n  Removes the list if there are no longer any references.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "list",
            "description": "The list to remove.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "list",
      "description": "The list to remove.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.hydratedInstance": {
    "src": {
      "line": 389,
      "codeLine": 402,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nCalled when [can-connect/constructor/store/store.hydrateInstance] is called and a new instance is created.\n",
    "title": "hydratedInstance",
    "name": "can-connect/constructor/store/store.hydratedInstance",
    "parent": "can-connect/constructor/store/store.hydrators",
    "signatures": [
      {
        "code": "hydratedInstance(instance)",
        "description": "\n\n  If there are pending requests, the instance is kept in the [can-connect/constructor/store/store.instanceStore].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The hydrated instance.\n\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The hydrated instance.\n\n\t "
    }
  },
  "can-connect/constructor/store/store.hydrateInstance": {
    "src": {
      "line": 413,
      "codeLine": 429,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns a instance given raw data.\n",
    "title": "hydrateInstance",
    "name": "can-connect/constructor/store/store.hydrateInstance",
    "parent": "can-connect/constructor/store/store.hydrators",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  Overwrites the base `hydratedInstance` so that if a matching instance is\n  in the [can-connect/constructor/store/store.instanceStore], that instance will\n  be [can-connect/constructor/constructor.updatedInstance updated] with `props` and returned.\n  If there isn't a matching instance, the base `hydrateInstance` will be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The raw data used to create an instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Instance"
            }
          ],
          "description": "A typed instance created or updated from `props`.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The raw data used to create an instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "description": "A typed instance created or updated from `props`.\n\t "
    }
  },
  "can-connect/constructor/store/store.hydratedList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.hydratedList",
    "parent": "can-connect/constructor/store/store.hydrators",
    "src": {
      "line": 442,
      "codeLine": 456,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nCalled whenever [can-connect/constructor/store/store.hydrateList] is called with the hydration result.\n",
    "title": "hydratedList",
    "signatures": [
      {
        "code": "hydratedList(list)",
        "description": "\n\n  If there are pending requests, the list is kept in the [can-connect/constructor/store/store.listStore].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The hydrated list.\n\n\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "The hydrated list.\n\n\n\t "
    }
  },
  "can-connect/constructor/store/store.hydrateList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.hydrateList",
    "parent": "can-connect/constructor/store/store.hydrators",
    "src": {
      "line": 469,
      "codeLine": 486,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nReturns a list given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList( listData, set )",
        "description": "\n\n  Overwrites the base `hydrateList` so that if a matching list is\n  in the [can-connect/constructor/store/store.listStore], that list will\n  be [can-connect/constructor/constructor.updatedList updated] with `listData` and returned.\n  If there isn't a matching list, the base `hydrateList` will be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "List data to hyrate into a list type."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set that represents the data in `listData`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "List"
            }
          ],
          "description": "A list from either the store or a newly created instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set that represents the data in `listData`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "List"
        }
      ],
      "description": "A list from either the store or a newly created instance.\n\t "
    }
  },
  "can-connect/constructor/store/store.getList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.getList",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 499,
      "codeLine": 516,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.getList] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] or [can-connect/constructor/store/store.hydrateList hydrated lists]\nare kept in the store until the response resolves.\n",
    "title": "getList",
    "signatures": [
      {
        "code": "connection.getList( set )",
        "description": "\n\n  Increments the request counter so these instances will be stored\n  and then decrements it after the request is complete.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "Params used to specify which list to retrieve."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.getList].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "Params used to specify which list to retrieve."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.getList].\n\t "
    }
  },
  "can-connect/constructor/store/store.get": {
    "type": "function",
    "name": "can-connect/constructor/store/store.get",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 528,
      "codeLine": 545,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.get] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "get",
    "signatures": [
      {
        "code": "connection.get( params )",
        "description": "\n\n  Increments the request counter so this instance will be stored\n  and then decrements it after the request is complete.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "Params used to specify which instance to retrieve."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.get].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "Params used to specify which instance to retrieve."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.get].\n\t "
    }
  },
  "can-connect/constructor/store/store.save": {
    "type": "function",
    "name": "can-connect/constructor/store/store.save",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 558,
      "codeLine": 582,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.save] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "save",
    "signatures": [
      {
        "code": "connection.save( instance )",
        "description": "\n\n  Increments the request counter so this instance will be stored\n  and then decrements it after the request is complete.\n\n  ```\n  var promise = connection.save(todo5);\n  connection.instanceStore.get(\"5\") //-> todo5\n  promise.then(function(){\n    connection.instanceStore.has(\"5\") //-> false\n  })\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "An typed instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.save].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "An typed instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.save].\n\t "
    }
  },
  "can-connect/constructor/store/store.destroy": {
    "type": "function",
    "name": "can-connect/constructor/store/store.destroy",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 603,
      "codeLine": 627,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.destroy] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "destroy",
    "signatures": [
      {
        "code": "connection.destroy( instance )",
        "description": "\n\n  Increments the request counter so this instance will be stored\n  and then decrements it after the request is complete.\n\n  ```\n  var promise = connection.destroy(todo5);\n  connection.instanceStore.get(\"5\") //-> todo5\n  promise.then(function(){\n    connection.instanceStore.has(\"5\") //-> false\n  })\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "An typed instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.destroy].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "An typed instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.destroy].\n\t "
    }
  },
  "can-connect/data/callbacks/callbacks": {
    "name": "can-connect/data/callbacks/callbacks",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 10,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "\n",
    "description": "\nCalls callback methods as a result of raw [can-connect/DataInterface] requests.\n",
    "title": "",
    "signatures": [
      {
        "code": "dataCallbacks( baseConnection )",
        "description": "\n\n\n",
        "params": []
      }
    ]
  },
  "can-connect/data/callbacks/callbacks.gotListData": {
    "name": "can-connect/data/callbacks/callbacks.gotListData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 15,
      "codeLine": 31,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "",
    "description": "\n",
    "title": "gotListData",
    "signatures": [
      {
        "code": "connection.gotListData(data, params, cid)",
        "description": "\n\n  Called with the resolved response data\n  of [can-connect/connection.getListData]. The result of this function will be used\n  as the new response data.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The raw data returned by the response."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "The parameters used to make this request."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "The cid of the instance created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The raw data this request represents.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "The cid of the instance created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The raw data this request represents.\n "
    }
  },
  "can-connect/data/callbacks/callbacks.createdData": {
    "name": "can-connect/data/callbacks/callbacks.createdData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 33,
      "codeLine": 49,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "",
    "description": "\n",
    "title": "createdData",
    "signatures": [
      {
        "code": "connection.createdData(data, params, cid)",
        "description": "\n\n  Called with the resolved response data\n  of [can-connect/connection.createData]. The result of this function will be used\n  as the new response data.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The raw data returned by the response."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "The parameters used to make this request."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "The cid of the instance created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The raw data this request represents.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "The cid of the instance created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The raw data this request represents.\n "
    }
  },
  "can-connect/data/callbacks/callbacks.updatedData": {
    "name": "can-connect/data/callbacks/callbacks.updatedData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 50,
      "codeLine": 66,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "",
    "description": "\n",
    "title": "updatedData",
    "signatures": [
      {
        "code": "connection.updatedData(data, params, cid)",
        "description": "\n\n  Called with the resolved response data\n  of [can-connect/connection.updateData]. The result of this function will be used\n  as the new response data.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The raw data returned by the response."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "The parameters used to make this request."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "The cid of the instance created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The raw data this request represents.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "The cid of the instance created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The raw data this request represents.\n "
    }
  },
  "can-connect/data/callbacks/callbacks.destroyedData": {
    "name": "can-connect/data/callbacks/callbacks.destroyedData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 67,
      "codeLine": 83,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "",
    "description": "\n",
    "title": "destroyedData",
    "signatures": [
      {
        "code": "connection.destroyedData(data, params, cid)",
        "description": "\n\n  Called with the resolved response data\n  of [can-connect/connection.destroyData]. The result of this function will be used\n  as the new response data.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The raw data returned by the response."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "The parameters used to make this request."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "The cid of the instance created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The raw data this request represents.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "The cid of the instance created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The raw data this request represents.\n "
    }
  },
  "can-connect/data/callbacks-cache/callbacks-cache": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 13,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": "\n",
    "description": "\nCallback [can-connect/base/base.cacheConnection] methods when [can-connect/data/callbacks/callbacks data interface callbacks]\nare called.\n",
    "title": "",
    "signatures": [
      {
        "code": "dataCallbacksCache( baseConnection )",
        "description": "\n\n  Implements the [can-connect/data/callbacks/callbacks data callbacks] so that a corresponding method is called\n  on the [can-connect/base/base.cacheConnection].This is\n  useful for making sure a [can-connect/base/base.cacheConnection] is updated whenever data is updated.\n",
        "params": []
      }
    ]
  },
  "can-connect/data/callbacks-cache/callbacks-cache.createdData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.createdData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 19,
      "codeLine": 26,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.createData]. Calls `createData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "createdData"
  },
  "can-connect/data/callbacks-cache/callbacks-cache.updatedData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.updatedData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 27,
      "codeLine": 34,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.updateData]. Calls `updateData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "updatedData"
  },
  "can-connect/data/callbacks-cache/callbacks-cache.destroyedData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.destroyedData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 35,
      "codeLine": 42,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.destroyData]. Calls `destroyData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "destroyedData"
  },
  "can-connect/data/combine-requests.data-methods": {
    "name": "can-connect/data/combine-requests.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.options": {
    "name": "can-connect/data/combine-requests.options",
    "title": "options",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.algebra": {
    "name": "can-connect/data/combine-requests.algebra",
    "title": "algebra methods",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.types": {
    "name": "can-connect/data/combine-requests.types",
    "title": "types",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests/combine-requests": {
    "type": "module",
    "name": "can-connect/data/combine-requests/combine-requests",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 8,
      "codeLine": 76,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n\n## Use\n\nCreate a connection with the `combine-requests` plugin like:\n\n```\nvar todosConnection = connect([\n  require(\"can-connect/data/combine-requests/combine-requests\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\"\n});\n```\n\nBy default, the following will only make a single request if made at the same time:\n\n```\ntodosConnection.getListData({})\ntodosConnection.getListData({userId: 5});\ntodosConnection.getListData({userId: 5, type: \"critical\"});\n```\n\nThis is because [can-set](https://github.com/canjs/can-set) knows that\n`{userId: 5, type: \"critical\"}` and `{userId: 5}` are subsets of `{}`.\n\nFor more advanced combining, use set algebra.  The following supports\ncombining ranges:\n\n```\nvar todosConnection = connect([\n  require(\"can-connect/data/combine-requests/combine-requests\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\",\n  algebra: new Algebra(set.props.range(\"start\",\"end\"))\n});\n```\n\nNow the following will make single request:\n\n```\ntodosConnection.getListData({start: 0, end: 49})\ntodosConnection.getListData({start: 0, end: 5});\ntodosConnection.getListData({start: 50, end: 99});\n```\n\n\n",
    "description": "\nCombines multiple incoming requests into one if possible.\n",
    "title": "",
    "signatures": [
      {
        "code": "dataCombineRequests( baseConnection )",
        "description": "\n\n  Overwrites [can-connect/data/combine-requests.getListData] to collect the requested\n  sets for\n  some [can-connect/data/combine-requests.time].  Once that time has expired, it tries\n  to take the [can-connect/data/combine-requests.unionPendingRequests union] of those sets. It\n  makes requests with those unioned sets. Once the unioned set data has returned,\n  the original requests re satisified by getting\n  [can-connect/data/combine-requests.getSubset subsets] of the unioned set data.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/combine-requests.unionPendingRequests": {
    "type": "function",
    "name": "can-connect/data/combine-requests.unionPendingRequests",
    "parent": "can-connect/data/combine-requests.algebra",
    "src": {
      "line": 80,
      "codeLine": 128,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n## Use\n\nThis function gets called automatically.  However, it converts something like:\n\n```\n[\n  {set: {completed: false}, deferred: def1},\n  {set: {completed: true}, deferred: def2}\n]\n```\n\nto\n\n```\n[\n  {\n   set: {},\n   pendingRequests: [\n     {set: {completed: false}, deferred: def1},\n     {set: {completed: true}, deferred: def2}\n   ]\n  }\n]\n```\n\n\t \n",
    "description": "\n",
    "title": "unionPendingRequests",
    "signatures": [
      {
        "code": "connection.unionPendingRequests( pendingRequests )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-connect/data/combine-requests.PendingRequest"
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "\n\nAn array of objects, each containing:\n\n- `set` - the requested set\n- `deferred` - a deferred that will be resolved with this sets data\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": [
                        {
                          "name": "set",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        },
                        {
                          "name": "pendingRequests",
                          "types": [
                            {
                              "type": "can-connect/data/combine-requests.PendingRequest"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\nReturns an array of each of the unioned requests to be made.  Each unionized request should have:\n\n- `set` - the set to request\n- `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the set satisfies.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/data/combine-requests.PendingRequest"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\nAn array of objects, each containing:\n\n- `set` - the requested set\n- `deferred` - a deferred that will be resolved with this sets data\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": [
                    {
                      "name": "set",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    },
                    {
                      "name": "pendingRequests",
                      "types": [
                        {
                          "type": "can-connect/data/combine-requests.PendingRequest"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\nReturns an array of each of the unioned requests to be made.  Each unionized request should have:\n\n- `set` - the set to request\n- `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the set satisfies.\n"
    },
    "comment": " "
  },
  "can-connect/data/combine-requests.getSubset": {
    "type": "function",
    "name": "can-connect/data/combine-requests.getSubset",
    "parent": "can-connect/data/combine-requests.algebra",
    "src": {
      "line": 176,
      "codeLine": 191,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nReturn the items that belong to an initial request.\n",
    "title": "getSubset",
    "signatures": [
      {
        "code": "connection.getSubset( set, unionSet, data )",
        "description": "\n\n  This implementation uses [can-set.Algebra.prototype.getSubset] on the [can-connect/base/base.algebra].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "the subset initially requested"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "unionSet",
            "description": "the combined set that was actually requested"
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "data",
            "description": "the data from the combined set"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "the data that belongs to `set`\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "name": "data",
      "description": "the data from the combined set"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "the data that belongs to `set`\n\t "
    }
  },
  "can-connect/data/combine-requests.time": {
    "name": "can-connect/data/combine-requests.time",
    "type": "property",
    "parent": "can-connect/data/combine-requests.options",
    "src": {
      "line": 194,
      "codeLine": 214,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nSpecifies the amount of time to wait to combine requests.\n",
    "types": [
      {
        "type": "Number",
        "description": "Defaults to `1` which means that only requests made within the same\n\"thread of execution\" will be combined.  Increasing this number will mean\nthat requests are going to be delayed that length of time in case other requests\nare made.  Generally speaking, there's no good reason to increase the amount of time.\n\n```\nconnect([\n  require(\"can-connect/data/combine-requests/combine-requests\"),\n  ...\n],{\n  time: 100\n})\n```\n\t "
      }
    ],
    "title": "time"
  },
  "can-connect/data/combine-requests.getListData": {
    "type": "function",
    "name": "can-connect/data/combine-requests.getListData",
    "parent": "can-connect/data/combine-requests.data-methods",
    "src": {
      "line": 215,
      "codeLine": 233,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nTries to combine requests using set logic.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData( set )",
        "description": "\n\n  Collects the sets for calls to `getListData` for\n  some [can-connect/data/combine-requests.time].  Once that time has expired, it tries\n  to take the [union](https://github.com/canjs/can-set#setunion) of those sets. It\n  makes requests with those unioned sets. Once the unioned set data has returned,\n  the original requests rae satisified by taking\n  [can-set.Algebra.prototype.getSubset] of the unioned set data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set used to request data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "The data for the requested set of data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set used to request data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "The data for the requested set of data.\n\t "
    }
  },
  "can-connect/data/combine-requests.PendingRequest": {
    "src": {
      "line": 288,
      "codeLine": 295,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "type": "typedef",
    "body": "",
    "description": "\n",
    "title": "PendingRequest",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "set",
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "description": "A [can-set](https://github.com/canjs/can-set) set object."
          },
          {
            "name": "deferred",
            "types": [
              {
                "type": "Deferred"
              }
            ],
            "description": "A defferred that can be used to resolve or reject a promise.\n"
          }
        ]
      }
    ],
    "name": "can-connect/data/combine-requests.PendingRequest",
    "parent": "can-connect/data/combine-requests.types"
  },
  "can-connect/data/localstorage-cache/localstorage-cache.identifiers": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache.identifiers",
    "title": "identifiers",
    "type": "group",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/localstorage-cache/localstorage-cache.data-methods": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache",
    "description": "",
    "order": 1
  },
  "can-connect/data/localstorage-cache/localstorage-cache": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 47,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n\n## Use\n\n`data/localstorage-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n[can-connect/cache-requests/cache-requests].  Make sure you configure the connection's [can-connect/data/localstorage-cache/localstorage-cache.name].\n\n```\nvar cacheConnection = connect([\n  require(\"can-connect/data/localstorage-cache/localstorage-cache\")\n],{\n  name: \"todos\"\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/fall-through-cache/fall-through-cache\")\n],\n{\n  url: \"/services/todos\",\n  cacheConnection: cacheConnection\n});\n```\n\n\n",
    "description": "\nSaves raw data in localStorage.\n",
    "title": "",
    "signatures": [
      {
        "code": "localStorage( baseConnection )",
        "description": "\n\n  Creates a cache of instances and a cache of sets of instances that is\n  accessible to read via [can-connect/data/localstorage-cache/localstorage-cache.getSets],\n  [can-connect/data/localstorage-cache/localstorage-cache.getData], and [can-connect/data/localstorage-cache/localstorage-cache.getListData].\n  The caches are updated via [can-connect/data/localstorage-cache/localstorage-cache.createData],\n  [can-connect/data/localstorage-cache/localstorage-cache.updateData], [can-connect/data/localstorage-cache/localstorage-cache.destroyData],\n  and [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n\n  [can-connect/data/localstorage-cache/localstorage-cache.createData],\n  [can-connect/data/localstorage-cache/localstorage-cache.updateData],\n  [can-connect/data/localstorage-cache/localstorage-cache.destroyData] are able to move items in and out\n  of sets.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.name": {
    "src": {
      "line": 212,
      "codeLine": 234,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```\nvar cacheConnection = connect([\"data-localstorage-cache\"],{\n  name: \"todos\"\n});\n```\n\t \n",
    "description": "\nSpecify a name to use when saving data in localstorage.\n",
    "types": [
      {
        "type": "String",
        "description": "This name is used to find and save data in\nlocalstorage. Instances are saved in `{name}/instance/{id}`\nand sets are saved in `{name}/set/{set}`.\n"
      }
    ],
    "title": "name",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.name",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.identifiers",
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.clear": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.clear",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 236,
      "codeLine": 245,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nResets the memory cache so it contains nothing.\n",
    "title": "clear",
    "signatures": [
      {
        "code": "connection.clear()",
        "description": "\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getSets": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getSets",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 270,
      "codeLine": 291,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n\n## Use\n\n```\nconnection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n```\n\n\t \n",
    "description": "\nReturns the sets contained within the cache.\n",
    "title": "getSets",
    "signatures": [
      {
        "code": "connection.getSets(set)",
        "description": "\n\n  Returns the sets added by [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the list of sets.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the list of sets.\n"
    },
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getListData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 294,
      "codeLine": 311,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nGets a set of data from localstorage.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Goes through each set add by [can-connect/data/memory-cache.updateListData]. If\n  `set` is a subset, uses [can-connect/base/base.algebra] to get the data for the requested `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "An object that represents the data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "An object that represents the data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
    }
  },
  "can-connect/data/localstorage-cache.getListDataSync": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache.getListDataSync",
    "parent": "can-connect/data/localstorage-cache.data-methods",
    "src": {
      "line": 319,
      "codeLine": 327,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nSynchronously gets a set of data from localstorage.\n",
    "title": "getListDataSync",
    "signatures": [
      {
        "code": "connection.getListDataSync(set)",
        "description": "\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 349,
      "codeLine": 365,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nGet an instance's data from localstorage.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Looks in localstorage for the requested instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A promise that resolves to the item if the memory cache has this item.\nIf localstorage does not have this item, it rejects the promise.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A promise that resolves to the item if the memory cache has this item.\nIf localstorage does not have this item, it rejects the promise.\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.updateListData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.updateListData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 375,
      "codeLine": 390,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nSaves a set of data in the cache.\n",
    "title": "updateListData",
    "signatures": [
      {
        "code": "connection.updateListData(listData, set)",
        "description": "\n\n  Tries to merge this set of data with any other saved sets of data. If\n  unable to merge this data, saves the set by itself.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Promise resolves if and when the data has been successfully saved.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Promise resolves if and when the data has been successfully saved.\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.createData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.createData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 412,
      "codeLine": 423,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is created and should be added to cache.\n",
    "title": "createData",
    "signatures": [
      {
        "code": "connection.createData(props)",
        "description": "\n\n  Adds `props` to the stored list of instances. Then, goes\n  through every set and adds props the sets it belongs to.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.updateData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.updateData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 435,
      "codeLine": 446,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is updated.\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "connection.updateData(props)",
        "description": "\n\n  Overwrites the stored instance with the new props. Then, goes\n  through every set and adds or removes the instance if it belongs or not.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.destroyData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.destroyData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 478,
      "codeLine": 489,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance should be removed from the cache.\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "connection.destroyData(props)",
        "description": "\n\n  Goes through each set of data and removes any data that matches\n  `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.data-methods": {
    "name": "can-connect/data/memory-cache/memory-cache.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/memory-cache/memory-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/memory-cache/memory-cache": {
    "name": "can-connect/data/memory-cache/memory-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 43,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n\n## Use\n\n`data/memory-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n[can-connect/cache-requests/cache-requests].\n\n```js\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/fall-through-cache/fall-through-cache\")\n],\n{\n  url: \"/services/todos\",\n  cacheConnection: cacheConnection\n});\n```\n\n",
    "description": "\nSaves raw data in JavaScript memory that disappears when the page refreshes.\n",
    "title": "",
    "signatures": [
      {
        "code": "memoryCache( baseConnection )",
        "description": "\n\n  Creates a cache of instances and a cache of sets of instances that is\n  accessible to read via [can-connect/data/memory-cache/memory-cache.getSets],\n  [can-connect/data/memory-cache/memory-cache.getData], and [can-connect/data/memory-cache/memory-cache.getListData].\n  The caches are updated via [can-connect/data/memory-cache/memory-cache.createData],\n  [can-connect/data/memory-cache/memory-cache.updateData], [can-connect/data/memory-cache/memory-cache.destroyData],\n  and [can-connect/data/memory-cache/memory-cache.updateListData].\n\n  [can-connect/data/memory-cache/memory-cache.createData],\n  [can-connect/data/memory-cache/memory-cache.updateData],\n  [can-connect/data/memory-cache/memory-cache.destroyData] are able to move items in and out\n  of sets.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/memory-cache/memory-cache.getSets": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getSets",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 162,
      "codeLine": 183,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n\n## Use\n\n```\nconnection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n```\n\n\t \n",
    "description": "\nReturns the sets contained within the cache.\n",
    "title": "getSets",
    "signatures": [
      {
        "code": "connection.getSets()",
        "description": "\n\n  Returns the sets added by [can-connect/data/memory-cache/memory-cache.updateListData].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "can-set/Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the list of sets.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can-set/Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the list of sets.\n"
    },
    "comment": " "
  },
  "can-connect/data/memory-cache/memory-cache.clear": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.clear",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 188,
      "codeLine": 215,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nResets the memory cache so it contains nothing.\n",
    "title": "clear",
    "signatures": [
      {
        "code": "connection.clear()",
        "description": "\n\n  Removes all instances and lists being stored in memory.\n\n  ```\n  var cacheConnection = connect([\n    require(\"can-connect/data/memory-cache/memory-cache\")\n  ],{});\n\n  cacheConnection.updateInstance({id: 5, name: \"justin\"});\n\n  cacheConnection.getData({id: 5}).then(function(data){\n    data //-> {id: 5, name: \"justin\"}\n    cacheConnection.clear();\n    cacheConnection.getData({id: 5}).catch(function(err){\n      err -> {message: \"no data\", error: 404}\n    });\n  });\n  ```\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getListData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 219,
      "codeLine": 236,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nGets a set of data from the memory cache.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Goes through each set add by [can-connect/data/memory-cache/memory-cache.updateListData]. If\n  `set` is a subset, uses [can-connect/base/base.algebra] to get the data for the requested `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "An object that represents the data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "An object that represents the data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
    }
  },
  "can-connect/data/memory-cache.getListDataSync": {
    "type": "function",
    "name": "can-connect/data/memory-cache.getListDataSync",
    "parent": "can-connect/data/memory-cache.data-methods",
    "src": {
      "line": 245,
      "codeLine": 253,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nSynchronously gets a set of data from the memory cache.\n",
    "title": "getListDataSync",
    "signatures": [
      {
        "code": "connection.getListDataSync(set)",
        "description": "\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.updateListData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.updateListData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 269,
      "codeLine": 284,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nSaves a set of data in the cache.\n",
    "title": "updateListData",
    "signatures": [
      {
        "code": "connection.updateListData(listData, set)",
        "description": "\n\n  Tries to merge this set of data with any other saved sets of data. If\n  unable to merge this data, saves the set by itself.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The data that belongs to `set`."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set `listData` belongs to."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Promise resolves if and when the data has been successfully saved.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set `listData` belongs to."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Promise resolves if and when the data has been successfully saved.\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.getData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 310,
      "codeLine": 326,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nGet an instance's data from the memory cache.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Looks in the instance store for the requested instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A promise that resolves to the item if the memory cache has this item.\nIf the memory cache does not have this item, it rejects the promise.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A promise that resolves to the item if the memory cache has this item.\nIf the memory cache does not have this item, it rejects the promise.\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.createData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.createData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 338,
      "codeLine": 349,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is created and should be added to cache.\n",
    "title": "createData",
    "signatures": [
      {
        "code": "connection.createData(props)",
        "description": "\n\n  Adds `props` to the stored list of instances. Then, goes\n  through every set and adds props the sets it belongs to.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.updateData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.updateData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 362,
      "codeLine": 373,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is updated.\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "connection.updateData(props)",
        "description": "\n\n  Overwrites the stored instance with the new props. Then, goes\n  through every set and adds or removes the instance if it belongs or not.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.destroyData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.destroyData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 407,
      "codeLine": 418,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance should be removed from the cache.\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "connection.destroyData(props)",
        "description": "\n\n  Goes through each set of data and removes any data that matches\n  `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/parse/parse": {
    "name": "can-connect/data/parse/parse",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 55,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n\n## Use\n\n`data/parse` is used to modify the response data of \"data interface\" methods to comply with what\nis expected by \"instance interface\" methods.  For example, if a service was returning list data\nat the `/services/todos` url like:\n\n```\n{\n  todos: [\n    {todo: {id: 0, name: \"dishes\"}},\n    {todo: {id: 2, name: \"lawn\"}}\n  ]\n}\n```\n\nThat service does not return [can-connect.listData] in the right format which should look like:\n\n```\n{\n  data: [\n    {id: 0, name: \"dishes\"},\n    {id: 2, name: \"lawn\"}\n  ]\n}\n```\n\nTo correct this, you can configure `data-parse` to use the [can-connect/data/parse/parse.parseListProp] and [connection.parseInstanceProp]\nas follows:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n parseListProp: \"todos\",\n parseInstanceProp: \"todo\"\n})\n```\n\n\n",
    "description": "\nExtract response data into a format needed for other extensions.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "dataParse( baseConnection )",
        "description": "\n\n  Overwrites the [can-connect/DataInterface] methods to run their results through\n  either [can-connect/data/parse/parse.parseInstanceData] or [can-connect/data/parse/parse.parseListData].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "The base connection.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "The base connection.\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseListData": {
    "type": "function",
    "name": "can-connect/data/parse/parse.parseListData",
    "parent": "can-connect/data/parse/parse",
    "src": {
      "line": 64,
      "codeLine": 131,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n## Use\n\n`parseListData` comes in handy when dealing with an irregular API\nthat can be improved with data transformation.\n\nSuppose an endpoint responds with a status of 200 OK, even when the\nrequest generates an empty result set. Worse yet, instead of representing\nan emtpy set with an empty list, it removes the property.\n\nA request to `/services/todos` may return:\n\n```\n{\n  todos: [\n    {todo: {id: 0, name: \"dishes\"}},\n    {todo: {id: 2, name: \"lawn\"}}\n  ]\n}\n```\n\nWhat if a request for `/services/todos?filterName=bank` responds with\n200 OK:\n\n```\n{\n}\n```\n\nThis response breaks its own schema. One way to bring it in line\nwith a format compatible with [can-connect.listData] is:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  parseListProp: \"todos\",\n  parseListData(responseData) {\n    if (responseData && !responseData.todos) {\n      responseData = { todos: [] };\n    }\n\n    return responseData;\n  }\n})\n```\n    \n",
    "description": "Given a response from [can-connect/connection.getListData] returns its data in the proper [can-connect.listData] format.\n\n",
    "title": "parseListData",
    "signatures": [
      {
        "code": "connection.parseListData(responseData)",
        "description": "\n\n  This function uses [can-connect/data/parse/parse.parseListProp] to find the array\n  containing the data for each instance.  Then it uses [can-connect/data/parse/parse.parseInstanceData]\n  on each item in the array  Finally, it returns data in the\n  [can-connect.listData] format.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "The response data from the AJAX request.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "An object like `{data: [props, props, ...]}`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "responseData",
      "description": "The response data from the AJAX request.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "An object like `{data: [props, props, ...]}`.\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseInstanceData": {
    "type": "function",
    "name": "can-connect/data/parse/parse.parseInstanceData",
    "parent": "can-connect/data/parse/parse",
    "src": {
      "line": 161,
      "codeLine": 231,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n## Use\n\n`parseInstanceData` comes in handy when dealing with an irregular API\nthat can be improved with data transformation.\n\nSuppose a request to `/services/todos` returns:\n```\n{\n  baseUrl: \"/proxy/share\",\n  todo: {\n    id: 0,\n    name: \"dishes\",\n    friendFaceUrl: \"friendface?id=0\",\n    fiddlerUrl: \"fiddler?id=0\"\n  }\n}\n```\n\nThe baseUrl property is meta-data that needs to be incorporated into the\ninstance data. One way to deal with this is:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  parseInstanceProp: \"todo\",\n  parseInstanceData(responseData) {\n    ['friendFaceUrl', 'fiddlerUrl'].map(urlProp => {\n      responseData.todo[urlProp] = [\n        responseData.baseUrl,\n        responseData.todo[urlProp]\n      ].join('/');\n    });\n\n    return responseData;\n  }\n})\n```\n\nThis results in an object like:\n\n```js\n{\n  id: 0,\n  name: \"dishes\",\n  friendFaceUrl: \"/proxy/share/friendface?id=0\",\n  fiddlerUrl: \"/proxy/share/fiddler?id=0\"\n}\n```\n    \n",
    "description": "Returns the properties that should be used to [can-connect/constructor/constructor.hydrateInstance make an instance] given the results of [can-connect/connection.getData], [can-connect/connection.createData], [can-connect/connection.updateData],\nand [can-connect/connection.destroyData].\n\n",
    "title": "parseInstanceData",
    "signatures": [
      {
        "code": "connection.parseInstanceData(responseData)",
        "description": "\n\n  This function will use [connection.parseInstanceProp] to find the data object\n  representing the instance that will be created.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "responseData",
      "description": "The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseListProp": {
    "body": "\n\n## Use\n\nSet `parseListProp` if your response data does not look like: `{data: [props, props]}`.\n\nFor example, if [can-connect/connection.getListData] returns data like:\n\n```\n{\n\t  todos: [{id: 1, name: \"dishes\"}, {id: 2, name: \"lawn\"}]\n}\n```\n\nSet `parseListProp` to `\"todos\"` like:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url : \"/todos\",\n  parseListProp: \"todos\"\n});\n```\n\n\t \n",
    "description": "\nThe property to find the array-like data that represents each instance item.\n",
    "types": [
      {
        "type": "String",
        "description": "[can-connect/data/parse/parse.parseListData] uses this property to find an array-like data struture\non the result of [can-connect/connection.getListData].\n"
      }
    ],
    "title": "parseListProp",
    "name": "can-connect/data/parse/parse.parseListProp",
    "type": "property",
    "parent": "can-connect/data/parse/parse",
    "comment": " "
  },
  "connection.parseInstanceProp": {
    "src": {
      "line": 276,
      "codeLine": 318,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\nSet `parseInstanceData` if your response data does not directly contain the data you would like to pass to\n[connection.hydrateInstance].\n\nFor example, if [can-connect/connection.getData] returns data like:\n\n```\n{\n  todo: {\n\t   id: 1,\n    name: \"dishes\"\n  }\n}\n```\n\nSet `parseInstanceProp` to `\"todo\"` like:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url : \"/todos\",\n  parseInstanceProp: \"todo\"\n});\n```\n\t \n",
    "description": "\nThe property to find the data that represents an instance item.\n",
    "types": [
      {
        "type": "String",
        "description": "[can-connect/data/parse/parse.parseInstanceData] uses this property's value to\n[can-connect/constructor/constructor.hydrateInstance make an instance].\n"
      }
    ],
    "title": "parseInstanceProp",
    "name": "connection.parseInstanceProp",
    "parent": "can-connect/data/parse/parse",
    "comment": " "
  },
  "can-connect/data/url/url.data-methods": {
    "name": "can-connect/data/url/url.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/url/url",
    "description": "",
    "order": 0
  },
  "can-connect/data/url/url.option": {
    "name": "can-connect/data/url/url.option",
    "title": "options",
    "type": "group",
    "parent": "can-connect/data/url/url",
    "description": "",
    "order": 0
  },
  "can-connect/data/url/url": {
    "name": "can-connect/data/url/url",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 96,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "\n## Use\n\nThe `data/url` behavior implements many of the [can-connect/DataInterface]\nmethods to send instance data to a URL.\n\nFor example, the following `todoConnection`:\n\n```js\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: {\n    getListData: \"GET /todos\",\n    getData: \"GET /todos/{id}\",\n    createData: \"POST /todos\",\n    updateData: \"PUT /todos/{id}\",\n    destroyData: \"DELETE /todos/{id}\"\n  }\n});\n```\n\nWill make the following request when the following\nmethods are called:\n\n```\n// GET /todos?due=today\ntodoConnection.getListData({due: \"today\"});\n\n// GET /todos/5\ntodosConnection.getData({id: 5})\n\n// POST /todos \\\n// name=take out trash\ntodosConnection.createData({\n  name: \"take out trash\"\n});\n\n// PUT /todos/5 \\\n// name=do the dishes\ntodosConnection.updateData({\n  name: \"do the dishes\",\n  id: 5\n});\n\n// DELETE /todos/5\ntodosConnection.destroyData({\n  id: 5\n});\n```\n\nThere's a few things to notice:\n\n1. URL values can include simple templates like `{id}`\n   that replace that part of the URL with values in the data\n   passed to the method.\n2. GET and DELETE request data is put in the URL using [can-util/js/param/param].\n3. POST and PUT requests put data that is not templated in the URL in POST or PUT body\n   as JSON-encoded data.  To use form-encoded requests instead, add the property\n   `contentType:'application/x-www-form-urlencoded'` to your [can-connect/data/url/url.url].\n4. If a provided URL doesn't include the method, the following default methods are provided:\n   - `getListData` - `GET`\n   - `getData` - `GET`\n   - `createData` - `POST`\n   - `updateData` - `PUT`\n   - `destroyData` - `DELETE`\n\nIf [can-connect/data/url/url.url] is provided as a string like:\n\n```js\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\"\n});\n```\n\nThis does the same thing as the first `todoConnection` example.\n\n",
    "description": "\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior",
        "description": "\n\nUses the [can-connect/data/url/url.url] option to implement the behavior of\n[can-connect/connection.getListData],\n[can-connect/connection.getData],\n[can-connect/connection.createData],\n[can-connect/connection.updateData], and\n[can-connect/connection.destroyData] to make an AJAX request\nto urls.\n"
      }
    ],
    "comment": " "
  },
  "can-connect/data/url/url.url": {
    "body": "\n",
    "description": "\nSpecify the url and methods that should be used for the \"Data Methods\".\n",
    "types": [
      {
        "type": "String",
        "description": "If a string is provided, it's assumed to be a RESTful interface. For example,\nif the following is provided:\n\n```\nurl: \"/services/todos\"\n```\n\n... the following methods and requests are used:\n\n - `getListData` - `GET /services/todos`\n - `getData` - `GET /services/todos/{id}`\n - `createData` - `POST /services/todos`\n - `updateData` - `PUT /services/todos/{id}`\n - `destroyData` - `DELETE /services/todos/{id}`\n"
      },
      {
        "type": "Object",
        "options": [],
        "description": "If an object is provided, it can customize each method and URL directly\nlike:\n\n```\nurl: {\n  getListData: \"GET /services/todos\",\n  getData: \"GET /services/todo/{id}\",\n  createData: \"POST /services/todo\",\n  updateData: \"PUT /services/todo/{id}\",\n  destroyData: \"DELETE /services/todo/{id}\"\n}\n```\n\nYou can provide a `resource` property that works like providing `url` as a string, but overwrite\nother values like:\n\n```\nurl: {\n  resource: \"/services/todo\",\n  getListData: \"GET /services/todos\"\n}\n```\n\nFinally, you can provide your own method to totally control how the request is made:\n\n```\nurl: {\n  resource: \"/services/todo\",\n  getListData: \"GET /services/todos\",\n  getData: function(param){\n    return new Promise(function(resolve, reject){\n      $.get(\"/services/todo\", {identifier: param.id}).then(resolve, reject);\n    });\n  }\n}\n```\n"
      }
    ],
    "title": "url",
    "name": "can-connect/data/url/url.url",
    "type": "property",
    "parent": "can-connect/data/url/url.option"
  },
  "can-connect/data/url/url.ajax": {
    "src": {
      "line": 204,
      "codeLine": 227,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "type": "property",
    "body": "\n",
    "description": "\nSpecify the ajax functionality that should be used to make the request.\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that resolves to the data.\n "
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "settings",
            "description": "Configuration options for the AJAX request."
          }
        ],
        "description": "Provides an alternate function to be used to make\najax requests.  By default [can-util/dom/ajax/ajax] provides the ajax\nfunctionality. jQuery's ajax method can be substituted as follows:\n\n```js\nconnect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/things\",\n  ajax: $.ajax\n});\n```\n"
      }
    ],
    "title": "ajax",
    "name": "can-connect/data/url/url.ajax",
    "parent": "can-connect/data/url/url.option",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "settings",
      "description": "Configuration options for the AJAX request."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that resolves to the data.\n "
    }
  },
  "can-connect/data/url/url.getListData": {
    "name": "can-connect/data/url/url.getListData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 232,
      "codeLine": 246,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "getListData(set)",
        "description": "\n\n  Retrieves list data for a particular set given the [can-connect/data/url/url.url] settings.\n  If `url.getListData` is a function, that function will be called.  If `url.getListData` is a\n  string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n  `url`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the ListData format.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the ListData format.\n "
    }
  },
  "can-connect/data/url/url.getData": {
    "name": "can-connect/data/url/url.getData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 247,
      "codeLine": 261,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "signatures": [
      {
        "code": "getData(params)",
        "description": "\n\n  Retrieves raw instance data given the [can-connect/data/url/url.url] settings.\n  If `url.getData` is a function, that function will be called.  If `url.getData` is a\n  string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "A object that represents the set of data needed to be loaded."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "A object that represents the set of data needed to be loaded."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance data.\n "
    }
  },
  "can-connect/data/url/url.createData": {
    "name": "can-connect/data/url/url.createData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 262,
      "codeLine": 278,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "signatures": [
      {
        "code": "createData(instanceData, cid)",
        "description": "\n\n  Creates instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.createData` is a function, that function will be called.  If `url.createData` is a\n  string, a request to that string will be made. If `url` is a string, a `POST` request is made to\n  `url`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "A unique id that represents the instance that is being created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the newly created instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "A unique id that represents the instance that is being created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the newly created instance data.\n "
    }
  },
  "can-connect/data/url/url.updateData": {
    "name": "can-connect/data/url/url.updateData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 279,
      "codeLine": 294,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "updateData(instanceData)",
        "description": "\n\nUpdates instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.updateData` is a function, that function will be called.  If `url.updateData` is a\n  string, a request to that string will be made. If `url` is a string, a `PUT` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the updated instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the updated instance data.\n "
    }
  },
  "can-connect/data/url/url.destroyData": {
    "name": "can-connect/data/url/url.destroyData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 295,
      "codeLine": 310,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "destroyData(instanceData)",
        "description": "\n\nDeletes instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.destroyData` is a function, that function will be called.  If `url.destroyData` is a\n  string, a request to that string will be made. If `url` is a string, a `DELETE` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the deleted instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the deleted instance data.\n "
    }
  },
  "can-connect/data/worker/worker.getListData": {
    "src": {
      "line": 64,
      "codeLine": 76,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getListData",
    "name": "can-connect/data/worker/worker.getListData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getListData(set)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getListData` is overwritten\nto forward calling [can-connect/connection.getListData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getListData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.updateListData": {
    "src": {
      "line": 77,
      "codeLine": 89,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "updateListData",
    "name": "can-connect/data/worker/worker.updateListData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".updateListData(listData, set)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `updateListData` is overwritten\nto forward calling [can-connect/connection.updateListData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.updateListData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.getSets": {
    "src": {
      "line": 90,
      "codeLine": 102,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getSets",
    "name": "can-connect/data/worker/worker.getSets",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getSets()",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getSets` is overwritten\nto forward calling [can-connect/connection.getSets] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getSets] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.clear": {
    "src": {
      "line": 103,
      "codeLine": 115,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "clear",
    "name": "can-connect/data/worker/worker.clear",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".clear()",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `clear` is overwritten\nto forward calling [can-connect/connection.clear] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.clear] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.getData": {
    "src": {
      "line": 116,
      "codeLine": 128,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-connect/data/worker/worker.getData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getData(params)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getData` is overwritten\nto forward calling [can-connect/connection.getData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.createData": {
    "src": {
      "line": 129,
      "codeLine": 141,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-connect/data/worker/worker.createData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".createData(instanceData, cid)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `createData` is overwritten\nto forward calling [can-connect/connection.createData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.createData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.updateData": {
    "src": {
      "line": 142,
      "codeLine": 154,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "updateData",
    "name": "can-connect/data/worker/worker.updateData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".updateData(instanceData)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `updateData` is overwritten\nto forward calling [can-connect/connection.updateData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.updateData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.destroyData": {
    "src": {
      "line": 155,
      "codeLine": 167,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-connect/data/worker/worker.destroyData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".destroyData(instanceData)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `destroyData` is overwritten\nto forward calling [can-connect/connection.destroyData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.destroyData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.name": {
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "String",
        "description": "The connection must be provided a unique name. This\nmakes sure the connections in both windows are linked.\n\n```js\nconnect([...],{\n  name: \"todos\"\n})\n```\n\t\t "
      }
    ],
    "title": "name",
    "name": "can-connect/data/worker/worker.name",
    "type": "property",
    "parent": "can-connect/data/worker/worker.identifiers"
  },
  "can-connect/data/worker/worker.worker": {
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Worker",
        "description": "A [web-worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) that \"data instance\" methods will be sent to.  This\nweb-worker should include a connection that matches the name of the window's\nconnection. If a worker isn't provided, the connection behaves as if the `data/worker` behavior\nwas not added.\n\n```js\nvar worker = new Worker(\"path/to/script.js\");\nconnect([...],{\n  worker: worker\n})\n```\n\t\t "
      }
    ],
    "title": "worker",
    "name": "can-connect/data/worker/worker.worker",
    "type": "property",
    "parent": "can-connect/data/worker/worker.identifiers"
  },
  "can-connect/data/worker/worker.identifiers": {
    "name": "can-connect/data/worker/worker.identifiers",
    "title": "options",
    "type": "group",
    "parent": "can-connect/data/worker/worker",
    "description": "",
    "order": 0
  },
  "can-connect/data/worker/worker.data": {
    "name": "can-connect/data/worker/worker.data",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/worker/worker",
    "description": "",
    "order": 0
  },
  "can-connect/data/worker/worker": {
    "src": {
      "path": "node_modules/can-connect/data/worker/worker.md"
    },
    "body": "\n\n## Use\n\nThe best way to use `data/worker` is to create a connection module that works when loaded in\neither the `window` or in a [Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers).\nThis pattern tends to work even if workers are not supported.\n\nThe following creates a connection that does the work of [can-connect/cache-requests/cache-requests],\n[can-connect/data/url/url], and [can-connect/data/memory-cache/memory-cache] in a worker thread.  \n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/data-worker.html'></div>\n\nThe `todo_connection` module can be found [here](https://github.com/canjs/can-connect/blob/master/src/data/worker/demo/todo_connection.js)\nand looks like the following:\n\n\n```js\nvar connect = require(\"can-connect\");\nvar fixture = require(\"can-fixture\");\n\n// If we are in the main thread, see if we can load this same\n// connection in a worker thread.\nvar worker;\nif(typeof document !== \"undefined\") {\n\tworker = new Worker( System.stealURL+\"?main=can-connect/data/worker/demo/todo_connection\" );\n}\n\n\n// create cache connection\nvar cache = connect([\n\trequire(\"can-connect/data/memory-cache/\")\n],{\n\tname: \"todos\"\n});\n\n// Create the main connection with everything you need.  If there is a worker,\n// all data interface methods will be sent to the worker.\nvar todosConnection = connect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/cache-requests/cache-requests\"),\n\trequire(\"can-connect/data/worker/worker\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\")\n],{\n    url: \"/todos\",\n    cacheConnection: cache,\n    worker: worker,\n    name: \"todos\"\n});\n\n\nfixture.delay = 1000;\nfixture({\n\t\"GET /todos\": function(request){\n\t\treturn {data: [\n\t\t\t{id: 1, name: \"wash dishes\"},\n\t\t\t{id: 2, name: \"mow lawn\"},\n\t\t\t{id: 3, name: \"do laundry\"}\n\t\t]};\n\t}\n});\n\nmodule.exports = todosConnection;\n```\n\n\n\nThe things to notice:\n\n1. A `Worker` should be passed as the [can-connect/data/worker/worker.worker] option\nthat loads a connection with the same name as the connection in the `window`.  In thise case, the same\nconnection module is loaded so everything works.\n\n2. A single `Worker` could load multiple connection modules and perform other behaviors.  \n\n### Split Connection Logic\n\nTHe previous example used a single module that was loaded by both the window and the worker.\nThis doesn't have to be the case.  Two different modules could be used.  For example, `todo-window.js` and\n`todo-worker.js`.  Each might look like:\n\n```js\n// todo-window.js\nvar workerURL = System.stealURL+\"?main=app/models/todo-worker\";\n\nvar todoConnection = connect([\n\trequire(\"can-connect/data/worker/worker\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\"),\n  {\n    worker: new Worker( workerURL ),\n    name: \"todos\"\n  });\n```\n\n```js\n// todo-worker.js\nvar cache = connect([\n\trequire(\"can-connect/data/memory-cache/memory-cache\")\n],{\n\tname: \"todos-cache\"\n});\n\nvar todoConnection = connect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/cache-requests/cache-requests\"),\n\trequire(\"can-connect/data/worker/worker\")\n],{\n    url: \"/todos\",\n    cacheConnection: cache,\n    name: \"todos\"\n  });\n```\n\nHowever, the problem with the two-module approach is that it will not work\nif Workers are not supported by your browser.\n\n",
    "description": "\nConnects a connection to another connection in a worker thread.\n",
    "type": "module",
    "title": "",
    "name": "can-connect/data/worker/worker",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "dataWorker( baseConnection )",
        "description": "\n\nIf a [Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)\nis provided, overwrites the \"data interface methods\" to package the arguments and send them as\npart of a `postMessage` to the Worker.\n\n\nIf a `Worker` is not provided, it is assumed \"data-worker\" is being added\nwithin a worker thread.  It listens to messages sent to the Worker, calls the specified \"data interface method\"\nand sends a message back with the result.\n\nAny data methods called on the `window` connection will wait until the `worker` connection\nhas established a handshake.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/connection.clear": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/clear.md"
    },
    "body": "\n## Use\n\nImplement `clear` to remove all data in a connection.\n\n```js\nconnect.behavior(\"my-behavior\", function(baseConnection){\n\treturn {\n\t\tclear: function(){\n\t\t\t// delete tabs, or clear localStorage, etc\n\t\t}\n\t}\n})\n```\n\n",
    "description": "Deletes all records on a connection. \n",
    "type": "typedef",
    "title": "clear",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Returns a promise that resolves when all data is cleared.\n"
        },
        "params": [],
        "description": "\n\nDeletes all records on a connection.\n"
      }
    ],
    "name": "can-connect/connection.clear",
    "parent": "can-connect/DataInterface",
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Returns a promise that resolves when all data is cleared.\n"
    },
    "comment": " "
  },
  "can-connect/connection.createData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/createData.md"
    },
    "body": "",
    "description": "Creates a new record in the connection. \n",
    "type": "typedef",
    "title": "createData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise resolved with the _created_ data of the newly created instance. The _created_\ndata __must__ have the [can-connect/base/base.id] of the created record.  \n\nBy default, [can-connect/constructor/constructor.createdInstance] only adds the data in `createdInstanceData` to\n`myInstance`, it does not remove it.  To remove \"missing\" properties on `myInstance` that are not in `createdInstanceData`, overwrite\n[can-connect/constructor/constructor.createdInstance].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "cid",
            "description": "A unique id that represents the instance that is being created.  Given this value,\nthe instance can be retrieved in the [can-connect/constructor/constructor.cidStore].\n"
          }
        ],
        "description": "\n\nCreates a new record given the serialized form of the data. Resolves to a promise with any additional\nproperties that should be added to the\ninstance. A [can-util/js/cid/cid client ID] is passed of the instance that is\nbeing created.\n\nThe following shows how [can-connect/constructor/constructor] calls `createData`\nand what it does with the response:\n\n```js\nvar CID = require(\"can-util/js/cid/cid\");\n\n// Create an instance of a special type\nvar myInstance = new MyType({ ... });\n\n// get its CID\nvar cid = CID(myInstance);\n\n// get its raw data\nvar instanceData = connection.serializeInstance(myInstance);\n\nconnection.createData(instanceData, cid).then(function(createdInstanceData){\n\tconnection.createdInstance(myInstance, createdInstanceData);\n})\n```\n\n"
      }
    ],
    "name": "can-connect/connection.createData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "cid",
      "description": "A unique id that represents the instance that is being created.  Given this value,\nthe instance can be retrieved in the [can-connect/constructor/constructor.cidStore].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise resolved with the _created_ data of the newly created instance. The _created_\ndata __must__ have the [can-connect/base/base.id] of the created record.  \n\nBy default, [can-connect/constructor/constructor.createdInstance] only adds the data in `createdInstanceData` to\n`myInstance`, it does not remove it.  To remove \"missing\" properties on `myInstance` that are not in `createdInstanceData`, overwrite\n[can-connect/constructor/constructor.createdInstance].\n"
    }
  },
  "can-connect/DataInterface": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/data_interface.md"
    },
    "body": "",
    "description": "The most common __raw__ data methods. \n",
    "type": "typedef",
    "title": "DataInterface",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-connect/DataInterface",
    "parent": "can-connect.types",
    "signatures": [
      {
        "code": "DataInterface",
        "description": "\n\nThe `DataInterface` methods are the methods most used most commonly\nby `can-connect` behaviors to get or mutate information in some form of\npersisted storage.  The `DataInterface` methods only operate on __raw__\ndata comprised of plain JavaScript Objects, Arrays and primitive types.\nThis is in contrast to the [can-connect/InstanceInterface] methods that\noperate on typed data.\n\nThose methods are:\n\n- [can-connect/connection.clear] - Remove all records.\n- [can-connect/connection.createData] - Create a new record.\n- [can-connect/connection.destroyData] - Destroy a record.\n- [can-connect/connection.getData] - Get a single record.\n- [can-connect/connection.getListData] - Get multiple records.\n- [can-connect/connection.getSets] - Get the [can-set/Set]s available within the persisted storage.\n- [can-connect/connection.updateData] - Update a single record.\n- [can-connect/connection.updateListData] - Update multiple records.\n\nBehaviors either implement these methods or overwrite these methods to perform some\nextra functionality.  \n\nFor example, [can-connect/data/url/url] implements these behaviors to\nmake an Ajax request like:\n\n```js\nconnect.behavior(\"data/url\", function(baseConnection) {\n\treturn {\n\t\tgetListData: function(set){\n\t\t\treturn ajax({\n\t\t\t\ttype: \"GET\",\n\t\t\t\turl: this.url,\n\t\t\t\tdata: set\n\t\t\t});\n\t\t},\n\t\tgetData: function(){ ... },\n\t\t...\n\t}\n});\n```\n\nThe [can-connect/data/parse/parse] behavior overwrites the `baseConnection`’s methods to\nperform cleanup on the response data:\n\n```js\nconnect.behavior(\"data/parse\", function(baseConnection) {\n\treturn {\n\t\tgetListData: function(set){\n\t\t\tvar self = this;\n\t\t\treturn baseConnection.getListData(set).then(function(response){\n\t\t\t\treturn self.parseListData(response);\n\t\t\t});\n\t\t},\n\t\tgetData: function(){ ... },\n\t\t...\n\t}\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-connect/connection.destroyData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/destroyData.md"
    },
    "body": "",
    "description": "Destroys a record in the collection. \n",
    "type": "typedef",
    "title": "destroyData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise resolved with the _destroyed_ data of the instance. The _destroyed_\ndata.  \n\nBy default, [can-connect/constructor/constructor.destroyedInstance] deletes properties in `myInstance` that are not in `destroyedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.destroyedInstance].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          }
        ],
        "description": "\n\nDestroys an instance given the serialized form of the\ndata. Returns any additional properties that should be added to the instance.\n\nThe following shows how [can-connect/constructor/constructor] calls `destroyData` and\nwhat it does with the response:\n\n```js\n// get its raw data\nvar instanceData = connection.serializeInstance(myInstance);\n\nconnection.destroyData(instanceData).then(function(destroyedInstanceData){\n\tconnection.destroyedInstance(myInstance, createdInstanceData);\n});\n```\n"
      }
    ],
    "name": "can-connect/connection.destroyData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise resolved with the _destroyed_ data of the instance. The _destroyed_\ndata.  \n\nBy default, [can-connect/constructor/constructor.destroyedInstance] deletes properties in `myInstance` that are not in `destroyedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.destroyedInstance].\n"
    }
  },
  "can-connect/connection.getData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getData.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/url/url] implement `getData`  but implementing it yourself can be as simple as:\n\n```js\nvar behavior = connect([],{\n  getData: function(params){\n    return new Promise(function(resolve, reject){\n\t\t$.get(\"/api/todo\",params).then(resolve, reject)\n\t});\n  }\n})\n```\n\n",
    "description": "Retrieves a record. \n",
    "type": "typedef",
    "title": "getData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the properties of a record.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "A object that represents the set of data needed to be loaded.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to the instance data for particular parameters.\n\n  The following shows how [can-connect/constructor/constructor] calls `getData`\n  and what it does with the response:\n\n  ```js\n  connection.getData({id: 1}).then(function(instanceData){\n  \tconnection.hydrateInstance(instanceData);\n  });\n  ```\n"
      }
    ],
    "name": "can-connect/connection.getData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "A object that represents the set of data needed to be loaded.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the properties of a record.\n"
    },
    "comment": " "
  },
  "can-connect/connection.getListData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getListData.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/url/url] make it easy to implement `getListData`, but it can be as simple as:\n\n```js\nvar connection = connect([],{\n  getListData: function(set){\n    return new Promise(function(resolve, reject){\n\t\t$.get(\"/api/todos\",set).then(resolve, reject)\n\t});\n  }\n})\n```\n\n",
    "description": "Retrieves list of records for the given set. \n",
    "type": "typedef",
    "title": "getListData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the [can-connect.listData] format like:\n\n```js\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ],\n  count: 1000\n}\n```\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded.  For example, `{complete: true}`\nmight represent the set of all completed records.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to a [can-connect.listData] for a particular set.  \n\n  ```js\n  connection.getListData({complete: true}).then(function(listData){\n\t  connection.hydrateList(listData);\n  });\n  ```\n"
      }
    ],
    "name": "can-connect/connection.getListData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded.  For example, `{complete: true}`\nmight represent the set of all completed records.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the [can-connect.listData] format like:\n\n```js\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ],\n  count: 1000\n}\n```\n"
    },
    "comment": " "
  },
  "can-connect/connection.getSets": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getSets.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/localstorage-cache/localstorage-cache] implement\n`.getSets` to provide the sets they contain.\n\n",
    "description": "Gets the sets that are available in the connection. \n",
    "type": "typedef",
    "title": "getSets",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "can-set/Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to an an array of sets.\n"
        },
        "params": [],
        "description": "\n\n  Returns a promise that resolves to a list of [can-set/Set] objects contained in the\n  connection.  This is useful for querying a [can-connect/base/base.cacheConnection]\n  if it will be able to satisfy a request.\n\n  An example response might look like:\n\n  ```js\n  connection.getSets().then(function(sets){\n\t  sets //-> [\n\t  //   {complete: true},\n\t  //   {userId: 5, start: 10, end: 20}\n\t  //]\n  })\n  ```\n"
      }
    ],
    "name": "can-connect/connection.getSets",
    "parent": "can-connect/DataInterface",
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can-set/Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to an an array of sets.\n"
    },
    "comment": " "
  },
  "can-connect/connection.updateData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/updateData.md"
    },
    "body": "",
    "description": "Updates a record in the collection. \n",
    "type": "typedef",
    "title": "updateData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise resolved with the _updated_ data of the newly created instance.  \n\nBy default, [can-connect/constructor/constructor.updatedInstance] deletes properties in `myInstance` that are not in `updatedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.updatedInstance].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          }
        ],
        "description": "\n\nUpdates a record given the serialized form of the data. Returns a promise\nthat resolves to a object that contains the new properties and values\nof the record.\n\nAn example request and response might look like:\n\n```js\nconnection.updateData({\n\tid: 5,\n\tname: \"do dishes\",\n\tcreatedAt: 1477104548997\n}).then(function(instanceData){\n\tinstanceData //-> {\n\t//\tid: 5,\n\t//\tname: \"do dishes\",\n\t//\tcreatedAt: 1477104540000,\n\t//\tupdatedAt: 1477104580000\n\t//}\n})\n```\n\nThe following shows how [can-connect/constructor/constructor] calls `updateData`\nand what it does with the response:\n\n```js\n// get its raw data\nvar instanceData = connection.serializeInstance(myInstance);\n\nconnection.updateData(instanceData).then(function(updatedInstanceData){\n  connection.updatedInstance(myInstance, updatedInstanceData);\n})\n```\n"
      }
    ],
    "name": "can-connect/connection.updateData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise resolved with the _updated_ data of the newly created instance.  \n\nBy default, [can-connect/constructor/constructor.updatedInstance] deletes properties in `myInstance` that are not in `updatedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.updatedInstance].\n"
    }
  },
  "can-connect/connection.updateListData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/updateListData.md"
    },
    "body": "\n",
    "description": "Updates records for a particular set in the connection. \n",
    "type": "typedef",
    "title": "updateListData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the updated [can-connect.listData].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "A object that represents the set of data needed to be loaded.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "set",
            "description": "The set of data that is updating.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to the list data for a particular set.\n\n  ```js\n  connection.updateListData({\n\t  data: [\n\t\t  {id: 1, name: \"dishes\", createdAt: 1477104548997}\n\t  ]\n  }, {}).then(function(listData){\n\t  listData //-> {\n\t  //\t  data: [\n\t  //\t\t  {id: 1, name: \"dishes\",\n\t  //\t\t   createdAt: 1477104548997, updatedAt: 1477104580000}\n\t  //\t  ]\n\t  //}\n  })\n  ```\n"
      }
    ],
    "name": "can-connect/connection.updateListData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "set",
      "description": "The set of data that is updating.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the updated [can-connect.listData].\n"
    },
    "comment": " "
  },
  "can-connect/connection.destroy": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/destroy.md"
    },
    "body": "\n",
    "description": "\nDestroy an instance.\n",
    "title": "connection.destroy",
    "name": "can-connect/connection.destroy",
    "type": "function",
    "parent": "can-connect/InstanceInterface",
    "signatures": [
      {
        "code": "connection.destroy( instance )",
        "description": "\n\nDestroys an instance using the `connection` by calling\n[can-connect/connection.destroyData].\n\n```js\n// get an instance\nconnection.get({id: 5}).then(function( instance ){\n\n\t// destroy it\n\tconnection.destroy( instance );\n})\n```\n\nNote that [can-connect/can/map/map] adds `destroy` to the `instance`\ntype's prototype.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "A typed instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect/Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that\nresolve with destroyed instance if [can-connect/connection.destroyData] is resolved.  The promise is rejected if [can-connect/connection.destroyData] is rejected.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "A typed instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that\nresolve with destroyed instance if [can-connect/connection.destroyData] is resolved.  The promise is rejected if [can-connect/connection.destroyData] is rejected.\n"
    }
  },
  "can-connect/connection.get": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/get.md"
    },
    "body": "\nGets a [can-connect/Instance].\n\n",
    "description": "\n",
    "title": "connection.get",
    "name": "can-connect/connection.get",
    "type": "function",
    "parent": "can-connect/InstanceInterface",
    "signatures": [
      {
        "code": "connection.get( params )",
        "description": "\n\nGet a single [can-connect/Instance] using the `connection` by calling\n[can-connect/connection.getData].\n\n```js\nconnection.get({id: 5}).then(function(instance){\n\n});\n```\n\nNote that [can-connect/can/map/map] adds `get` to the `instance`'s\nconstructor function.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that specifies an instance to retrieve.  Typically, the object contains the `id` property and the `id` value of the\ninstance that should be retrieved like `{_id: \"saq232la8kjsa\"}`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.List"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that\nresolve with a `List` if [can-connect/connection.getData] is resolved.  The promise is rejected if [can-connect/connection.getData] is rejected.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that specifies an instance to retrieve.  Typically, the object contains the `id` property and the `id` value of the\ninstance that should be retrieved like `{_id: \"saq232la8kjsa\"}`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.List"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that\nresolve with a `List` if [can-connect/connection.getData] is resolved.  The promise is rejected if [can-connect/connection.getData] is rejected.\n"
    }
  },
  "can-connect/connection.getList": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/getList.md"
    },
    "body": "\n",
    "description": "\nGets a [can-connect.List] of instances.\n",
    "title": "connection.getList",
    "name": "can-connect/connection.getList",
    "type": "function",
    "parent": "can-connect/InstanceInterface",
    "signatures": [
      {
        "code": "connection.getList( set )",
        "description": "\n\nGets a [can-connect.List] of instances using the `connection` by calling\n[can-connect/connection.getListData].\n\n```js\nconnection.getList({parentId: 5}).then(function(list){\n\n});\n```\n\nNote that [can-connect/can/map/map] adds `getList` to the `instance`'s\nconstructor function.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A set object that represents the list of data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.List"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that\nresolve with a `List` if [can-connect/connection.getListData] is resolved.  The promise is rejected if [can-connect/connection.getListData] is rejected.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A set object that represents the list of data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.List"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that\nresolve with a `List` if [can-connect/connection.getListData] is resolved.  The promise is rejected if [can-connect/connection.getListData] is rejected.\n"
    }
  },
  "can-connect/InstanceInterface": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/instance_interface.md"
    },
    "body": "",
    "description": "The methods used to create, retrieve, update and destroy typed instances with a connection. \n",
    "type": "typedef",
    "title": "InstanceInterface",
    "name": "can-connect/InstanceInterface",
    "parent": "can-connect.types",
    "signatures": [
      {
        "code": "InstanceInterface",
        "description": "\n\nThe [can-connect/constructor/constructor] behavior is typically\nused to implement the core instance interface methods:\n\n - [can-connect/connection.getList] - Get a list of instances.\n - [can-connect/connection.get] - Get a single instance.\n - [can-connect/connection.save] - Create or update an instance.\n - [can-connect/connection.destroy] - Destroy an instance.\n",
        "params": []
      }
    ]
  },
  "can-connect/connection.save": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/save.md"
    },
    "body": "\n",
    "description": "\nCreate or update an instance.\n",
    "title": "connection.save",
    "name": "can-connect/connection.save",
    "type": "function",
    "parent": "can-connect/InstanceInterface",
    "signatures": [
      {
        "code": "connection.save( instance )",
        "description": "\n\nCreates or updates an instance using the `connection` by calling\n[can-connect/connection.createData] or [can-connect/connection.updateData].\n\n```js\n// create an instance\nvar instance = new Type();\n\n// create it with the connection\nconnection.save( instance ).then(function(instance){\n\n\t// change the instance\n\tinstance.prop = \"NEW VALUE\";\n\n\t// update it with the connection\n\tconnection.save( instance ).then(function(instance){\n\n\t});\n\n});\n```\n\nThe choice of [can-connect/connection.createData] or [can-connect/connection.updateData] is made by the result of\n[can-connect/constructor/constructor.isNew].\n\n\n\nNote that [can-connect/can/map/map] adds `save` to the `instance`\ntype's prototype.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "A typed instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect/Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that\nresolve with created or updated instance if [can-connect/connection.createData] or [can-connect/connection.updateData] is resolved.  The promise is rejected if [can-connect/connection.createData] or [can-connect/connection.updateData] is rejected.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "A typed instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that\nresolve with created or updated instance if [can-connect/connection.createData] or [can-connect/connection.updateData] is resolved.  The promise is rejected if [can-connect/connection.createData] or [can-connect/connection.updateData] is rejected.\n"
    }
  },
  "connection.algebra": {
    "src": {
      "path": "node_modules/can-connect/docs/options/algebra.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Algebra"
      }
    ],
    "title": "algebra",
    "name": "connection.algebra",
    "type": "property",
    "parent": "can-connect.options"
  },
  "connection.cacheConnection": {
    "src": {
      "path": "node_modules/can-connect/docs/options/cacheConnection.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "connection"
      }
    ],
    "title": "cacheConnection",
    "name": "connection.cacheConnection",
    "type": "property",
    "parent": "can-connect.options"
  },
  "connection.id": {
    "src": {
      "path": "node_modules/can-connect/docs/options/id.md"
    },
    "body": "",
    "description": "",
    "title": "id",
    "name": "connection.id",
    "type": "function",
    "parent": "can-connect.options"
  },
  "connection.idProp": {
    "src": {
      "path": "node_modules/can-connect/docs/options/idProp.md"
    },
    "body": "",
    "description": "",
    "title": "idProp",
    "name": "connection.idProp",
    "type": "property",
    "parent": "can-connect.options"
  },
  "connection.instance": {
    "src": {
      "path": "node_modules/can-connect/docs/options/instance.md"
    },
    "body": "",
    "description": "",
    "title": "instance",
    "name": "connection.instance",
    "type": "function",
    "parent": "can-connect.options"
  },
  "connection.list": {
    "src": {
      "path": "node_modules/can-connect/docs/options/list.md"
    },
    "body": "",
    "description": "\n",
    "title": "list",
    "name": "connection.list",
    "type": "function",
    "parent": "can-connect.options",
    "signatures": [
      {
        "code": "connection.list( instancesData, set )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": [
                  {
                    "name": "data",
                    "types": [
                      {
                        "type": "Array",
                        "template": [
                          {
                            "types": [
                              {
                                "type": "Object",
                                "options": []
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "instancesData",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "data",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "name": "instancesData",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "\n"
    }
  },
  "connection.listSet": {
    "src": {
      "path": "node_modules/can-connect/docs/options/listSet.md"
    },
    "body": "",
    "description": "",
    "title": "listSet",
    "name": "connection.listSet",
    "type": "function",
    "parent": "can-connect.options"
  },
  "can-connect/Instance": {
    "src": {
      "path": "node_modules/can-connect/docs/types/instance.md"
    },
    "body": "",
    "description": "An instance of some JavaScript type. \n",
    "type": "typedef",
    "title": "Instance",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n  `can-connect` is primarily used to connect some form of __typed data__ to\n  a service layer.  For example, the typed data might be a `Todo` with methods\n  like `todo.complete()` and the service layer might be a RESTful URL like\n  `https://myapp.com/todos`.\n\n  __Typed data__, with methods, validation, type coercion, and other logic is\n  very useful to a client side developer.  However, a service layer\n  doesn't provide this functionality, instead it just provides raw data.\n\n  `can-connect` is used to bridge the gap between __typed data__ and the\n  raw data provided by the server.  \n\n  An `Instance` represents some form of typed data. For example,\n  an `Instance` might represent an instance of the `Todo` type in the example above.\n\n  The [can-connect/constructor/constructor] behavior is primarily responsible for\n  providing methods that go [can-connect/constructor/constructor.hydrateInstance back] and\n  [can-connect/constructor/constructor.serializeInstance forth] between\n  instances and raw data.  Other behaviors like [can-connect/can/map/map]\n  extend this functionality. \n"
      }
    ],
    "name": "can-connect/Instance",
    "parent": "can-connect.types"
  },
  "can-connect.List": {
    "src": {
      "path": "node_modules/can-connect/docs/types/list.md"
    },
    "body": "",
    "description": "A list type. \n",
    "type": "typedef",
    "title": "List",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "The `List` type is a JavaScript type, typically\na constructor function, that is used to contain a list of typed [can-connect/Instance instances].  `List` types usually are\n`Array`-like.  An instance of type `List` is what's returned by\n[can-connect/constructor.hydrateList] to convert raw data into\nwhat's returned by [can-connect/connection.getList].\n\n```js\nvar list = connection.hydrateList({\n  data: [{id: 1, name: \"raw data\"}]\n});\n\nlist //-> an instance of List\n```\n\nThe `List` type often has special methods used to interact with\nthe collection of [can-connect/Instance] instances.\n\n```js\nvar list = connection.hydrateList({\n  data: [{id: 1, name: \"raw data\"}]\n});\n\nlist.someSpecialMethod();\n```\n\nThe [can-connect/constructor/constructor.list] option is used\nto convert an Array of instances into the final `List` type.\n"
      }
    ],
    "name": "can-connect.List",
    "parent": "can-connect.types"
  },
  "can-connect.listData": {
    "src": {
      "path": "node_modules/can-connect/docs/types/listData.md"
    },
    "body": "\n\n",
    "description": "\nThe data format used to create typed lists.  \n",
    "type": "typedef",
    "title": "ListData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "data",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "The ListData object must have a `data` property that is an array of objects.  Each\nobject is used to [can-connect/constructor/constructor.hydrateInstance hydrate] typed instances.\n"
          }
        ],
        "description": "A plain JavaScript object used to [can-connect/constructor.hydrateList hydrate] a typed\nlist.  This is the data format resolved by [can-connect/connection.getListData].\n\nA `ListData` object should look like:\n\n```js\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ]\n}\n```\n\nThe object must have a `data` property that is an `Array` of\ninstance data used to [can-connect/constructor/constructor.hydrateInstance hydrate] typed instances.  \n\nThe ListData object can have other meta information related to the data\nthat has been loaded.  For example, `count` might be the total\nnumber of items the server has:\n\n```\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ],\n  count: 1000\n}\n```\n\nThe [can-connect/data/parse/parse] behavior can be used to convert request responses to the `ListData` format.\n"
      }
    ],
    "name": "can-connect.listData",
    "parent": "can-connect.types",
    "comment": " "
  },
  "can-connect-feathers/service/service.data-methods.createData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/data-methods.create-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-connect-feathers/service/service.data-methods.createData",
    "type": "function",
    "parent": "can-connect-feathers/service/service.data-methods",
    "signatures": [
      {
        "code": "createData(instanceData, cid)",
        "description": "\n\nUses the [can-connect-feathers/service/service.options.feathersService feathersService] `create` method with the provided serialized `instanceData`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "A unique id that represents the instance that is being created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the newly created instance data.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "A unique id that represents the instance that is being created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the newly created instance data.\n"
    }
  },
  "can-connect-feathers/service/service.data-methods.destroyData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/data-methods.destroy-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-connect-feathers/service/service.data-methods.destroyData",
    "type": "function",
    "parent": "can-connect-feathers/service/service.data-methods",
    "signatures": [
      {
        "code": "destroyData(instanceData)",
        "description": "\n\nCalls the [can-connect-feathers/service/service.options.feathersService feathersService] `remove` method with the provided serialized `instanceData`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the deleted instance data.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the deleted instance data.\n"
    }
  },
  "can-connect-feathers/service/service.data-methods.getData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/data-methods.get-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-connect-feathers/service/service.data-methods.getData",
    "type": "function",
    "parent": "can-connect-feathers/service/service.data-methods",
    "signatures": [
      {
        "code": "getData(params)",
        "description": "\n\nCalls the [can-connect-feathers/service/service.options.feathersService feathersService] `get` method to retrieve instance data for the provided `params`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "A object that represents the set of data needed to be loaded."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance data."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "A object that represents the set of data needed to be loaded."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance data."
    }
  },
  "can-connect-feathers/service/service.data-methods.getListData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/data-methods.get-list-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "getListData",
    "name": "can-connect-feathers/service/service.data-methods.getListData",
    "type": "function",
    "parent": "can-connect-feathers/service/service.data-methods",
    "signatures": [
      {
        "code": "getListData(set)",
        "description": "\n\nCalls the [can-connect-feathers/service/service.options.feathersService feathersService] `find` method to retrieve list data for a particular `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded.  The `set` object is passed to the Feathers service's `find` method as the query params: `.find({query: set})`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the ListData format."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded.  The `set` object is passed to the Feathers service's `find` method as the query params: `.find({query: set})`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the ListData format."
    }
  },
  "can-connect-feathers/service/service.data-methods.updateData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/data-methods.update-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "updateData",
    "name": "can-connect-feathers/service/service.data-methods.updateData",
    "type": "function",
    "parent": "can-connect-feathers/service/service.data-methods",
    "signatures": [
      {
        "code": "updateData(instanceData)",
        "description": "\n\nCalls the [can-connect-feathers/service/service.options.feathersService feathersService] `update` method with the provided serialized `instanceData`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the updated instance data.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the updated instance data.\n"
    }
  },
  "can-connect-feathers/service/service.options.feathersService": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/options.feathers-service.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "FeathersService",
        "description": "\n\nSpecifies a [FeathersClient](https://docs.feathersjs.com/clients/feathers.html) Service instance to use for the data connection.  See the [can-connect-feathers] page for an example Feathers Client configuration.\n\n```js\n// Bring in the feathersClient instance and setup a service.\nvar feathersClient = require('./feathers');\nvar todoService = feathersClient.service('/api/todos');\n\nconnect([\n  feathersService,\n  realtime\n], {\n  // Pass the service as the `feathersService` property\n  feathersService: todoService\n});\n```\n\nSee [can-connect-feathers/service/service] for a complete Todo Model example."
      }
    ],
    "title": "feathersService",
    "name": "can-connect-feathers/service/service.options.feathersService",
    "type": "property",
    "parent": "can-connect-feathers/service/service.options"
  },
  "can-connect-feathers/service/service.options": {
    "name": "can-connect-feathers/service/service.options",
    "title": "options",
    "type": "group",
    "parent": "can-connect-feathers/service/service",
    "description": "",
    "order": 0
  },
  "can-connect-feathers/service/service.data-methods": {
    "name": "can-connect-feathers/service/service.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect-feathers/service/service",
    "description": "",
    "order": 0
  },
  "can-connect-feathers/service/service": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/service/service.md"
    },
    "body": "\nThe `feathers-service` behavior maps can-connect's [can-connect/DataInterface] methods to FeathersJS's [Service Interface](https://docs.feathersjs.com/services/readme.html#service-methods) methods.\n\n``` \n| DataInterface method | Feathers method | HTTP method | Example Path |\n|----------------------|-----------------|-------------|--------------|\n| .getListData()       | .find()         | GET         | /todos       |\n| .getData()           | .get()          | GET         | /todos/{id}  |\n| .createData()        | .create()       | POST        | /todos       |\n| .updateData()        | .update()       | PUT         | /todos/{id}  |\n| not yet implemented  | .patch()        | PATCH       | /todos/{id}  |\n| .destroyData()       | .remove()       | DELETE      | /todos/{id}  | \n```\n\n## Use\n\nSetting up the Feathers Client is a prerequisite for using this behavior.  See the [can-connect-feathers] page for an example of a basic Feathers Client configuration.  With the Feathers client setup, it can be used with the `feathers-service` behavior as demonstrated in the example, below.  Also note that the [can-connect/real-time/real-time real-time] behavior is included to receive real-time push events from the server. \n\n```js\n// models/todo.js\nvar connect = require('can-connect');\nvar DefineMap = require('can-define/map/');\nvar DefineList = require('can-define/list/list');\nvar set = require(\"can-set\");\n\n// Bring in the feathers service behavior\nvar feathersServiceBehavior = require('can-connect-feathers/service');\nvar dataParse = require('can-connect/data/parse/');\nvar constructor = require('can-connect/constructor/');\nvar constructorStore = require('can-connect/constructor/store/');\nvar constructorCallbacksOnce = require('can-connect/constructor/callbacks-once/');\nvar canMap = require('can-connect/can/map/');\nvar canRef = require('can-connect/can/ref/');\nvar dataCallbacks = require('can-connect/data/callbacks/');\nvar realtime = require('can-connect/real-time/');\n\n// Bring in the feathersClient instance.\nvar feathersClient = require('./feathers');\n\n// Use feathersClient.service(url) to create a service\nvar todoService = feathersClient.service('/api/todos');\n\nvar Todo = DefineMap.extend('Todo', {\n  _id: 'string',\n  description: 'string',\n  complete: 'boolean'\n});\n\nTodo.algebra = new set.Algebra(\n  set.comparators.id('_id')\n);\n\nTodo.List = DefineList.extend({'*': Todo});\n\nTodo.connection = connect([\n  // Include the feathers service behavior in the behaviors list.\n  feathersServiceBehavior,\n  dataParse,\n  constructor,\n  constructorStore,\n  constructorCallbacksOnce,\n  canMap,\n  canRef,\n\t// Include both the dataCallbacks and realtime behaviors.\n  dataCallbacks,\n  realtime\n], {\n  idProp: '_id',\n  Map: Todo,\n  List: Todo.List,\n  // Pass the service as the `feathersService` property.\n  feathersService: todoService,\n  name: 'todos',\n  algebra: Todo.algebra\n});\n\nmodule.exports = Todo;\n```\n\nIn the above example, both `Todo` and `Todo.connection` will have methods for handling data, as described in the [can-connect basic use] section.\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect-feathers/service/service",
    "parent": "can-connect-feathers.behaviors",
    "signatures": [
      {
        "code": "feathersService(baseConnect)",
        "description": "\n\nConnects the [can-connect/DataInterface] methods to the Feathers [Service Interface](https://docs.feathersjs.com/services/readme.html#service-methods) methods.\n\n```js\nconnect([\n  feathersService,\n  realtime\n], {\n  feathersService: feathersClient.service('/api/todos')\n});\n```\n\nFor can-connect's real-time functionality to work with this behavior, the [can-connect/real-time/real-time real-time behavior] must also be included as shown in the examples. \n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect-feathers/session/session.data-methods.createData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/session/data-methods.create-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-connect-feathers/session/session.data-methods.createData",
    "type": "function",
    "parent": "can-connect-feathers/session/session.data-methods",
    "signatures": [
      {
        "code": "createData(sessionData)",
        "description": "\n\nUses the [can-connect-feathers/session/session.options.feathersClient feathersClient] `authenticate` method to authenticate with a Feathers server.  See the [Feathers Authentication Client documentation](https://docs.feathersjs.com/authentication/client.html) for details about Feathers authentication.  Upon successful authentication, the Feathers server will return a JSON Web Token (JWT) containing information about the current \"session\".  Note that Feathers uses JWT instead of server sessions.\n\nFor Socket.io connections, the current socket connection's state will be marked as authenticated on the server side.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "sessionData",
            "description": "The serialized data for creating a session.  The `sessionData` payload will vary depending on which authentication strategy is used on the server.  For example, [feathers-authentication-local](https://github.com/feathersjs/feathers-authentication-local) requires an `email` and `password`, but another strategy may have different requirements."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the server's response.  On success, a JSON Web Token created by the server will be returned.  On error, a [feathers-errors](https://github.com/feathersjs/feathers-errors) instance will be returned.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "sessionData",
      "description": "The serialized data for creating a session.  The `sessionData` payload will vary depending on which authentication strategy is used on the server.  For example, [feathers-authentication-local](https://github.com/feathersjs/feathers-authentication-local) requires an `email` and `password`, but another strategy may have different requirements."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the server's response.  On success, a JSON Web Token created by the server will be returned.  On error, a [feathers-errors](https://github.com/feathersjs/feathers-errors) instance will be returned.\n"
    }
  },
  "can-connect-feathers/session/session.data-methods.destroyData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/session/data-methods.destroy-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-connect-feathers/session/session.data-methods.destroyData",
    "type": "function",
    "parent": "can-connect-feathers/session/session.data-methods",
    "signatures": [
      {
        "code": "destroyData()",
        "description": "\n\nUses the [can-connect-feathers/session/session.options.feathersClient feathersClient] `logout` method to remove the current JSON Web Token from the client.  See the [Feathers Authentication Client documentation](https://docs.feathersjs.com/authentication/client.html) for details about Feathers authentication.\n\nFor Socket.io connections, the current socket connection's state will be marked as unauthenticated on the server side.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to a success message.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to a success message.\n"
    }
  },
  "can-connect-feathers/session/session.data-methods.getData": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/session/data-methods.get-data.md"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-connect-feathers/session/session.data-methods.getData",
    "type": "function",
    "parent": "can-connect-feathers/session/session.data-methods",
    "signatures": [
      {
        "code": "getData()",
        "description": "\n\nUses the [can-connect-feathers/session/session.options.feathersClient feathersClient] `getJWT` method to retrieve and verify the current JSON Web Token (JWT).\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the JWT payload if the token was valid.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the JWT payload if the token was valid.\n"
    }
  },
  "can-connect-feathers/service/service.options.feathersClient": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/session/options.feathers-client.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "FeathersClient",
        "description": "\n\nSpecifies a FeathersClient instance to use for authentication.  The [feathers-authentication-client plugin](https://github.com/feathersjs/feathers-authentication-client) is required.  See the [can-connect-feathers] page for an example Feathers Client configuration.\n\n```js\n// Bring in the feathers client instance.\nvar feathersClient = require('./feathers');\n\nconnect([\n  feathersSession\n], {\n  // Pass the feathers client as the `feathersClient` property.\n  feathersClient: feathersClient\n});\n```\n\nSee [can-connect-feathers/session/session] for a complete Session Model example."
      }
    ],
    "title": "feathersClient",
    "name": "can-connect-feathers/service/service.options.feathersClient",
    "type": "property",
    "parent": "can-connect-feathers/session/session.options"
  },
  "can-connect-feathers/session/session.options": {
    "name": "can-connect-feathers/session/session.options",
    "title": "options",
    "type": "group",
    "parent": "can-connect-feathers/session/session",
    "description": "",
    "order": 0
  },
  "can-connect-feathers/session/session.data-methods": {
    "name": "can-connect-feathers/session/session.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect-feathers/session/session",
    "description": "",
    "order": 0
  },
  "can-connect-feathers/session/session": {
    "src": {
      "path": "node_modules/can-connect-feathers/_docs/session/session.md"
    },
    "body": "\nThe `feathers-session` behavior uses the [feathers-authentication-client](https://github.com/feathersjs/feathers-authentication-client) to authenticate with a Feathers server.  Three of the [can-connect/DataInterface DataInterface] methods are used:\n\n - [can-connect-feathers/session/session.data-methods.createData createData] attempts to authenticate with the Feathers server, which upon success returns a JSON Web Token (JWT).  The JWT contains a payload with information about the current session.  That payload is returned as the session object.\n - [can-connect-feathers/session/session.data-methods.getData] validates a stored JWT and returns its payload if the token hasn't expired.\n - [can-connect-feathers/session/session.data-methods.destroyData] unauthenticates from the server and discards the JWT token on the client.\n\n## Use\n\nSetting up the Feathers Client is a prerequisite for using this behavior.  See the [can-connect-feathers] page for an example of a basic Feathers Client configuration.  With the Feathers client setup, it can be used with the `feathers-session` behavior as demonstrated in the example, below.\n\n```js\n// models/session.js\nvar connect = require('can-connect');\nvar DefineMap = require('can-define/map/');\n\nvar feathersSessionBehavior = require('can-connect-feathers/session');\nvar dataParse = require('can-connect/data/parse/');\nvar construct = require('can-connect/constructor/');\nvar constructStore = require('can-connect/constructor/store/');\nvar constructCallbacksOnce = require('can-connect/constructor/callbacks-once/');\nvar canMap = require('can-connect/can/map/');\nvar canRef = require('can-connect/can/ref/');\nvar dataCallbacks = require('can-connect/data/callbacks/');\n// Bring in your user model to setup the relation in your DefineMap.\nvar User = require('./user');\n\n// Bring in the feathersClient instance.\nvar feathersClient = require('./feathers');\n\nexport const Session = DefineMap.extend('Session', {\n  seal: false\n}, {\n  exp: 'any',\n  userId: 'any',\n  user: {\n    Type: User,\n    // Automatically populate the user data when a userId is received.\n    get (lastSetVal, resolve) {\n      if (lastSetVal) {\n        return lastSetVal;\n      }\n      if (this.userId) {\n        User.get({_id: this.userId}).then(resolve);\n      }\n    }\n  }\n});\n\nconnect([\n  // Include the feathers session behavior in the behaviors list.\n  feathersSession,\n  dataParse,\n  canMap,\n  canRef,\n  construct,\n  constructStore,\n  constructCallbacksOnce,\n  // Include the realtime behavior.\n  realtime,\n  dataCallbacks\n], {\n  // Pass the feathers client as the `feathersClient` property.\n  feathersClient: feathersClient,\n  idProp: 'exp',\n  Map: Session,\n  name: 'session'\n});\n```\n\n### Obtaining current session data\n\nOnce authentication has been established, the Map or DefineMap provided as the `Map` option on the can-connect Model will have a new `current` property defined.  So, if you passed a `Session` object, `Session.current` will always hold the current session data.  This greatly simplifies the session property in your application ViewModel.  Here's an abbreviated example.\n\n```js\nimport Session from 'my-app/models/session';\n\nconst AppViewModel = DefineMap.extend({\n  session: {\n    get () {\n      return Session.current;\n    }\n  }\n});\n```\n\nThat's it!  The `session` property in the above example will automatically populate when the user authenticates.\n\n### Handling OAuth Logins\n\nThe `feathers-session` behavior is preconfigured to listen to `login` messages coming in over the [feathers-authentication-popups](https://github.com/feathersjs/feathers-authentication-popups) `authAgent`.  When any message is received through the `authAgent`, its validity is checked.  If it's a valid JWT token, a Session instance will be created automatically.  This will both populate `Session.current` and dispatch a `created` event on the connected Session Map.\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect-feathers/session/session",
    "parent": "can-connect-feathers.behaviors",
    "signatures": [
      {
        "code": "feathersSession(baseConnect)",
        "description": "\n\nConnects [can-connect/DataInterface] methods to the [feathers-authentication-client](https://github.com/feathersjs/feathers-authentication-client) plugin methods for authentication.\n\n```js\nconnect([\n  feathersSession,\n  realtime\n], {\n  feathersClient: feathersClient,\n  Map: SessionMap\n});\n``` \n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define/list/list/events": {
    "name": "can-define/list/list/events",
    "title": "events",
    "type": "group",
    "parent": "can-define/list/list",
    "description": "",
    "order": 0
  },
  "can-define/list/list/AddEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.add.md"
    },
    "body": "\r\n",
    "description": "\r\nEvent fired when items are added to the list.\r\n",
    "type": "typedef",
    "title": "add\r",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/AddEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, added, index)",
        "description": "\n\r\nHandlers registered with [can-event] methods on `list` will be called back when\r\nitems are added to a list.\r\n\r\n```\r\nlist.on(\"add\", function(event, added, index){ ... });\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object.\r"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "added",
            "description": "An array of the items added to the list.\r"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The location where the items were added.\r\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "index",
      "description": "The location where the items were added.\r\n"
    }
  },
  "can-define/list/list/LengthEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.length.md"
    },
    "body": "\r\n",
    "description": "\r\nEvent fired when items are added or removed from the list.\r\n",
    "type": "typedef",
    "title": "length\r",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/LengthEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, length)",
        "description": "\n\r\nHandlers registered on \"length\" events will be called\r\nback as follows.\r\n\r\n```\r\nlist.on(\"length\", function(event, length){ ... });\r\n```\r\n\r\nIt's possible that the length was not changed, but an item was [can-define/list/list::set] on the list.\r\nIn this case, a `length` event will still be fired.\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object.\r"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "length",
            "description": "The new length of the list.\r\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "length",
      "description": "The new length of the list.\r\n"
    }
  },
  "can-define/list/list/PropertyNameEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.propertyName.md"
    },
    "body": "\r\n",
    "description": "\r\nEvent fired when a property on the list changes values.\r\n",
    "type": "typedef",
    "title": "propertyName\r",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/PropertyNameEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, newValue, oldValue)",
        "description": "\n\r\nHandlers registered on `propertyName` events will be called\r\nback as follows.\r\n\r\n```\r\nlist.set(\"totalCount\", 500);\r\nlist.on(\"totalCount\", function(event, newVal, oldVal){\r\n  newVal //-> 5\r\n  oldVal //-> 500\r\n});\r\nlist.set(\"totalCount\", 5);\r\n```\r\n\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object.\r"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newVal",
            "description": "The new value of the `propertyName` property.\r"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "oldVal",
            "description": "The old value of the `propertyName` property.\r\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "oldVal",
      "description": "The old value of the `propertyName` property.\r\n"
    }
  },
  "can-define/list/list/RemoveEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.remove.md"
    },
    "body": "\r\n",
    "description": "\r\nEvent fired when items are removed from the list.\r\n",
    "type": "typedef",
    "title": "remove\r",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/RemoveEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, removed, index)",
        "description": "\n\r\nHandlers registered with [can-event] methods on `list` will be called back when\r\nitems are removed to a list.\r\n\r\n```\r\nlist.on(\"remove\", function(event, removed, index){ ... });\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object.\r"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "removed",
            "description": "An array of the items removed from the list.\r"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The location where the items were removed.\r\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "index",
      "description": "The location where the items were removed.\r\n"
    }
  },
  "can-define/list/list.prototype.on": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.on.md"
    },
    "body": "",
    "description": "Add event handlers to a list. \r\n",
    "title": "on\r",
    "name": "can-define/list/list.prototype.on",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "signatures": [
      {
        "code": "list.on(eventType, handler)",
        "description": "\n\r\nListens to `eventType` on `list` and calls `handler` when the event is dispatched.  This is simply\r\na reference to [can-event.on can-event.on] as all of [can-event] methods are available on `DefineMap`.\r\n\r\n```js\r\nvar list = new DefineList([\"CanJS\",\"StealJS\"])\r\nlist.on(\"add\", function(ev, added, index){ ... });\r\nlist.push(\"DoneJS\");\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of event to bind this handler to.\r\n\r"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event"
                  },
                  {
                    "variable": true,
                    "name": "args"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires\r\nThe signature of the handler depends on the type of event being bound.\r\n\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "This list, for chaining.\r\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Event"
                }
              ],
              "name": "event"
            },
            {
              "variable": true,
              "name": "args"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires\r\nThe signature of the handler depends on the type of event being bound.\r\n\r"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "This list, for chaining.\r\n"
    }
  },
  "can-define/list/list.prototype.wildcard": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.wildcard.md"
    },
    "body": "",
    "description": "Define default behavior for all properties and items in the list. Use [can-define/list/list.prototype.wildcardItems] to define the default type of items in the list.\r\n\r\n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\r\nBy defining a wildcard property (`\"*\"`) on the prototype, this will supply a\r\ndefault behavior for every property in the list.  The default wildcard `\"*\"` definition\r\nmakes every property run through the \"observable\" [can-define.types] converter.\r\nIt looks like:\r\n\r\n```js\r\n\"*\": {\r\n  type: \"observable\"\r\n}\r\n```\r\n\r\nSetting the wildcard is useful when all properties should be converted to a particular type.\r\n\r\n```js\r\nvar Person = DefineList.extend({ ... });\r\n\r\nvar People = DefineList.extend({\r\n  \"*\": \"string\"\r\n  \"#\": Person\r\n});\r\n\r\nvar people = new People();\r\n\r\npeople.set(\"age\", 21);\r\npeople.age //-> \"21\"\r\n```\r\n"
      }
    ],
    "title": "*\r",
    "name": "can-define/list/list.prototype.wildcard",
    "type": "property",
    "parent": "can-define/list/list.prototype"
  },
  "can-define/list/list.prototype.wildcardItems": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.wildcardItems.md"
    },
    "body": "",
    "description": "Define default behavior for items in the list. \r\n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\r\nBy defining a wildcard property (`\"#\"`) on the prototype, this will supply a\r\ndefault behavior for items in the list.  The default wildcard (`\"#\"`) definition\r\nmakes every item run through the \"observable\" [can-define.types] converter.\r\nIt looks like:\r\n\r\n```js\r\n\"#\": {\r\n  type: \"observable\"\r\n}\r\n```\r\n\r\nSetting the wildcard is useful when items should be converted to a particular type.\r\n\r\n```js\r\nvar Person = DefineMap.extend({ ... });\r\n\r\nvar People = DefineList.extend({\r\n  \"#\": Person\r\n});\r\n```\r\n\r\nThe wildcard property has optional `added` and `removed` functions that will be called after\r\nan item is added or removed from the list with `this` being the list.\r\n\r\n```js\r\nvar People = DefineList.extend({\r\n  \"#\": {\r\n  \tadded: function(itemsAdded, index) { ... },\r\n  \tremoved: function(itemsRemoved, index) { ... }\r\n  }\r\n});\r\n```\r\n"
      }
    ],
    "title": "#\r",
    "name": "can-define/list/list.prototype.wildcardItems",
    "type": "property",
    "parent": "can-define/list/list.prototype"
  },
  "can-define/list/list.extend": {
    "src": {
      "path": "node_modules/can-define/list/docs/static.extend.md"
    },
    "body": "\n",
    "description": "Define a custom list type. \r\n",
    "title": "extend\r",
    "name": "can-define/list/list.extend",
    "type": "function",
    "parent": "can-define/list/list.static",
    "signatures": [
      {
        "code": "DefineList.extend([name,] [static,] prototype)",
        "description": "\n\r\nExtends DefineList, or constructor functions derived from DefineList,\r\nto create a new constructor function.\r\n\r\n```js\r\nvar DefineList = require(\"can-define/list/list\");\r\n\r\nvar TodoList = DefineList.extend(\r\n  \"TodoList\",\r\n  {\r\n    \"#\": {type: {complete: \"boolean\", name: \"string\"}}\r\n    availableCount: \"number\",\r\n    completedCount: {\r\n      get: function(){\r\n        return this.filter({complete: true}).length;\r\n      }\r\n    },\r\n    completeAll: function(){\r\n      this.forEach(function(todo){\r\n        todo.complete = true;\r\n      })\r\n    }\r\n  });\r\n\r\nvar todos = new TodoList([\r\n  {name: \"dishes\", complete: false},\r\n  {name: \"lawn\", complete: false}\r\n]);\r\ntodos.availableCount = 100;\r\n\r\ntodos.completeAll();\r\ntodos.completeCount //-> 2\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Provides an optional name for this type that will\r\nshow up nicely in debuggers.\r\n\r"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "static",
            "description": "Static properties that are set directly on the\r\nconstructor function.\r\n\r"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      },
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "prototype",
            "description": "A definition of the properties or methods on this type.\r\n\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A DefineList constructor function.\r\n\r\n\r"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                },
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "prototype",
      "description": "A definition of the properties or methods on this type.\r\n\r"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A DefineList constructor function.\r\n\r\n\r"
    },
    "comment": " "
  },
  "can-define/map/map.prototype": {
    "name": "can-define/map/map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map.static": {
    "name": "can-define/map/map.static",
    "title": "static",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map/events": {
    "name": "can-define/map/map/events",
    "title": "events",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map": {
    "src": {
      "path": "node_modules/can-define/map/docs/define-map.md"
    },
    "body": "\r\n## Use\r\n\r\n`can-define/map/map` is used to create easily extensible observable types with well defined\r\nbehavior.\r\n\r\nFor example, a `Todo` type, with a `name` property, `completed` property, and a `toggle` method, might be defined like:\r\n\r\n```js\r\nvar DefineMap = require(\"can-define/map/map\");\r\n\r\nvar Todo = DefineMap.extend({\r\n\tname: \"string\",\r\n\tcompleted: {type: \"boolean\", value: false},\r\n\ttoggle: function(){\r\n\t\tthis.completed = !this.completed;\r\n\t}\r\n})\r\n```\r\n\r\nThe _Object_ passed to `.extend` defines the properties and methods that will be\r\non _instances_ of a `Todo`.  There are a lot of ways to define properties.  The\r\n[can-define.types.propDefinition] type lists them all.  Here, we define:\r\n\r\n - `name` as a property that will be type coerced into a `String`.\r\n - `completed` as a property that will be type coerced into a `Boolean`\r\n   with an initial value of `false`.\r\n\r\nThis also defines a `toggle` method that will be available on _instances_ of `Todo`.\r\n\r\n`Todo` is a constructor function.  This means _instances_ of `Todo` can be be created by\r\ncalling `new Todo()` as follows:\r\n\r\n```js\r\nvar myTodo = new Todo();\r\nmyTodo.name = \"Do the dishes\";\r\nmyTodo.completed //-> false\r\n\r\nmyTodo.toggle();\r\nmyTodo.completed //-> true\r\n```  \r\n\r\nYou can also pass initial properties and their values when initializing a `DefineMap`:\r\n\r\n```js\r\nvar anotherTodo = new Todo({name: \"Mow lawn\", completed: true});\r\nmyTodo.name = \"Mow lawn\";\r\nmyTodo.completed //-> true\r\n```  \r\n\r\n## Declarative properties\r\n\r\nArguably `can-define`'s most important ability is its support of declarative properties\r\nthat functionally derive their value from other property values.  This is done by\r\ndefining [can-define.types.get getter] properties like `fullName` as follows:\r\n\r\n```js\r\nvar Person = DefineMap.extend({\r\n\tfirst: \"string\",\r\n\tlast: \"string\",\r\n\tfullName: {\r\n\t\tget : function(){\r\n\t\t\treturn this.first + \" \" + this.last;\r\n\t\t}\r\n\t}\r\n});\r\n```\r\n\r\n`fullName` can also be defined with the ES5 shorthand getter syntax:\r\n\r\n```js\r\nvar Person = DefineMap.extend({\r\n\tfirst: \"string\",\r\n\tlast: \"string\",\r\n\tget fullName(){\r\n\t\treturn this.first + \" \" + this.last;\r\n\t}\r\n});\r\n```\r\n\r\nNow, when a `person` is created, there is a `fullName` property available like:\r\n\r\n```js\r\nvar me = new Person({first: \"Harry\", last: \"Potter\"});\r\nme.fullName //-> \"Harry Potter\"\r\n```\r\n\r\nThis property can be bound to like any other property:\r\n\r\n```js\r\nme.on(\"fullName\", function(ev, newValue, oldValue){\r\n\tnewValue //-> Harry Henderson\r\n\toldValue //-> Harry Potter\r\n});\r\n\r\nme.last = \"Henderson\";\r\n```\r\n\r\n`getter` properties use [can-compute] internally.  This means that when bound,\r\nthe value of the `getter` is cached and only updates when one of its source\r\nobservables change.  For example:\r\n\r\n```js\r\nvar Person = DefineMap.extend({\r\n\tfirst: \"string\",\r\n\tlast: \"string\",\r\n\tget fullName(){\r\n\t\tconsole.log(\"calculating fullName\");\r\n\t\treturn this.first + \" \" + this.last;\r\n\t}\r\n});\r\n\r\nvar hero = new Person({first: \"Wonder\", last: \"Woman\"});\r\n\r\n// console.logs \"calculating fullName\"\r\nhero.fullName //-> Wonder Woman\r\n\r\n// console.logs \"calculating fullName\"\r\nhero.fullName //-> Wonder Woman\r\n\r\n// console.logs \"calculating fullName\"\r\nhero.on(\"fullName\", function(){});\r\n\r\nhero.fullName //-> \"Wonder Woman\"\r\n\r\n// console.logs \"calculating fullName\"\r\nhero.first = \"Bionic\"\r\n\r\n// console.logs \"calculating fullName\"\r\nhero.last = \"Man\"\r\n\r\nhero.fullName //-> \"Bionic Man\"\r\n```\r\n\r\nIf you want to prevent repeat updates, use [can-event/batch/batch]:\r\n\r\n```js\r\nhero.fullName //-> \"Bionic Man\"\r\n\r\nvar canBatch = require(\"can-event/batch/batch\");\r\n\r\ncanBatch.start();\r\nhero.first = \"Silk\";\r\nhero.last = \"Spectre\";\r\n\r\n// console.logs \"calculating fullName\"\r\ncanBatch.stop();\r\n```\r\n\r\n### Asynchronous getters\r\n\r\n`getters` can also be asynchronous.  These are very useful when you have a type\r\nthat requires data from the server.  This is very common in [can-component]\r\nview-models.  For example, a `view-model` might take a `todoId` value, and want\r\nto make a `todo` property available:\r\n\r\n```js\r\nvar ajax = require(\"can-util/dom/ajax/ajax\");\r\n\r\nvar TodoViewModel = DefineMap.extend({\r\n\ttodoId: \"number\",\r\n\ttodo: {\r\n\t\tget: function(lastSetValue, resolve){\r\n\t\t\t\tajax({url: \"/todos/\"+this.todoId}).then(resolve)\r\n\t\t\t}\r\n\t}\r\n});\r\n```\r\n\r\nAsynchronous getters only are passed a `resolve` argument when bound.  Typically in an application,\r\nyour template will automatically bind on the `todo` property.  But to use it in a test might\r\nlook like:\r\n\r\n```js\r\nvar fixture = require(\"can-fixture\");\r\nfixture(\"GET /todos/5\", function(){\r\n\treturn {id: 5, name: \"take out trash\"}\r\n});\r\n\r\nvar todoVM = new TodoViewModel({id: 5});\r\ntodoVM.on(\"todo\", function(ev, newVal){\r\n\tassert.equal(newVal.name, \"take out trash\");\r\n});\r\n```\r\n\r\n### Getter limitations\r\n\r\nThere's some functionality that a getter or an async getter can not describe\r\ndeclaratively.  For these situations, you can use [can-define.types.set] or\r\neven better, use the [can-define-stream] plugin.\r\n\r\nFor example, consider a __state__ and __city__ locator where you pick a United States\r\n__state__ like _Illinois_ and then a __city__ like _Chicago_.  In this example,\r\nwe want to clear the choice of __city__ whenever the __state__ changes.\r\n\r\nThis can be implemented with [can-define.types.set] like:\r\n\r\n```js\r\nLocator = DefineMap.extend({\r\n\tstate: {\r\n\t\ttype: \"string\",\r\n\t\tset: function(){\r\n\t\t\tthis.city = null;\r\n\t\t}\r\n\t},\r\n\tcity: \"string\"\r\n});\r\n\r\nvar locator = new Locator({\r\n\tstate: \"IL\",\r\n\tcity: \"Chicago\"\r\n});\r\n\r\nlocator.state = \"CA\";\r\nlocator.city //-> null;\r\n```\r\n\r\nThis isn't declarative anymore because changing state imperatively changes\r\nthe value of `city`. The [can-define-stream] plugin can make this functionality\r\nentirely declarative.\r\n\r\n```js\r\nvar Locator = DefineMap.extend({\r\n     state: \"string\",\r\n     city: {\r\n         type: \"string\",\r\n         stream: function(setStream) {\r\n             return this.stream(\".state\").map(function(){\r\n                 return null;\r\n             }).merge(setStream);\r\n         }\r\n     }\r\n});\r\n\r\nvar locator = new Locator({\r\n\tstate: \"IL\",\r\n\tcity: \"Chicago\"\r\n});\r\n\r\nlocator.on(\"city\", function(){});\r\n\r\nlocator.state = \"CA\";\r\nlocator.city //-> null;\r\n```\r\n\r\nNotice, in the `can-define-stream` example, `city` must be bound for it to work.  \r\n\r\n## Sealed instances and strict mode\r\n\r\nBy default, `DefineMap` instances are [can-define/map/map.seal sealed].  This\r\nmeans that setting properties that are not defined when the constructor is defined\r\nwill throw an error in files that are in [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode). For example:\r\n\r\n```js\r\n\"use strict\";\r\n\r\nvar DefineMap = require(\"can-define/map/map\");\r\n\r\nvar MyType = DefineMap.extend({\r\n    myProp: \"string\"\r\n});\r\n\r\nvar myType = new MyType();\r\n\r\nmyType.myProp = \"value\"; // no error thrown\r\n\r\nmyType.otherProp = \"value\" // throws Error!\r\n```\r\n\r\nRead the [can-define/map/map.seal] documentation for more information on this behavior.\r\n\n",
    "description": "Create observable objects. \r\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define/map/map",
    "parent": "can-core",
    "alias": "can.DefineMap",
    "inherits": "can.Construct",
    "signatures": [
      {
        "code": "new DefineMap([props])",
        "description": "\n\r\nThe `can-define/map/map` module exports the `DefineMap` constructor function.  \r\n\r\nCalling `new DefineMap(props)` creates a new instance of DefineMap or an [can-define/map/map.extend extended] DefineMap. Then, assigns every property on `props` to the new instance.  If props are passed that are not defined already, those property definitions are created.  If the instance should be sealed, it is sealed.\r\n\r\n```js\r\nvar DefineMap = require(\"can-define/map/map\");\r\n\r\nvar person = new DefineMap({\r\n  first: \"Justin\",\r\n  last: \"Meyer\"\r\n})\r\n```\r\n\r\n  Custom `DefineMap` types, with special properties and behaviors, can be defined with [can-define/map/map.extend].\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the map with.\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "An instance of `DefineMap` with the properties from _props_.\r\n\r"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "props",
      "description": "Properties and values to seed the map with.\r"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "An instance of `DefineMap` with the properties from _props_.\r\n\r"
    },
    "comment": " "
  },
  "can-define/map/map/KeysEvent": {
    "src": {
      "path": "node_modules/can-define/map/docs/events.keys.md"
    },
    "body": "\r\n",
    "description": "\r\nEvent fired when a property is added.\r\n",
    "type": "typedef",
    "title": "__keys\r",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/map/map/KeysEvent",
    "parent": "can-define/map/map/events",
    "signatures": [
      {
        "code": "handler(event)",
        "description": "\n\r\nHandlers registered on `__keys` events will be called\r\nback as follows.\r\n\r\n```\r\nvar person = new DefineMap({name: \"Justin\"});\r\nlist.on(\"__keys\", function(event){ ... });\r\nperson.set(\"age\", 33);\r\n```\r\n\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object.\r\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Event"
        }
      ],
      "name": "event",
      "description": "An event object.\r\n"
    }
  },
  "can-define/map/map/PropertyNameEvent": {
    "src": {
      "path": "node_modules/can-define/map/docs/events.propertyName.md"
    },
    "body": "\r\n",
    "description": "\r\nEvent fired when a property on the map changes values.\r\n",
    "type": "typedef",
    "title": "propertyName\r",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/map/map/PropertyNameEvent",
    "parent": "can-define/map/map/events",
    "signatures": [
      {
        "code": "handler(event, newValue, oldValue)",
        "description": "\n\r\nHandlers registered on `propertyName` events will be called\r\nback as follows.\r\n\r\n```\r\nvar person = new DefineMap({name: \"Justin\"});\r\nlist.on(\"name\", function(event, newVal, oldVal){\r\n  newVal //-> \"Brian\"\r\n  oldVal //-> \"Justin\"\r\n});\r\nperson.name = \"Brian\";\r\n```\r\n\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object.\r"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newVal",
            "description": "The new value of the `propertyName` property.\r"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "oldVal",
            "description": "The old value of the `propertyName` property.\r\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "oldVal",
      "description": "The old value of the `propertyName` property.\r\n"
    }
  },
  "can-define/map/map.prototype.forEach": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.forEach.md"
    },
    "body": "\r\n## Use\r\n\r\nExample\r\n\r\n```\r\nvar names = [];\r\nnew DefineMap({a: 'Alice', b: 'Bob', e: 'Eve'}).forEach(function(value, key) {\r\n    names.push(value);\r\n});\r\n\r\nnames; // ['Alice', 'Bob', 'Eve']\r\n\r\nnames = [];\r\nnew DefineMap({a: 'Alice', b: 'Bob', e: 'Eve'}).forEach(function(value, key) {\r\n    names.push(value);\r\n    if(key === 'b') {\r\n        return false;\r\n    }\r\n});\r\n\r\nnames; // ['Alice', 'Bob']\r\n```\r\n\n",
    "description": "Call a function on each property of a DefineMap. \r\n",
    "title": "forEach\r",
    "name": "can-define/map/map.prototype.forEach",
    "type": "function",
    "parent": "can-define/map/map.prototype",
    "signatures": [
      {
        "code": "map.forEach( callback(value, propName ) )",
        "description": "\n\r\n`forEach` iterates through the map instance, calling a function\r\nfor each property value and key.\r\n\r\n```js\r\nmap.forEach(function(value, propName){ ... });\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "value"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "propName"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "The function to call for each property\r\nThe value and key of each property will be passed as the first and second\r\narguments, respectively, to the callback. If the callback returns `false`,\r\nthe loop will stop.\r\n\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\r\n\r"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "value"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "propName"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "The function to call for each property\r\nThe value and key of each property will be passed as the first and second\r\narguments, respectively, to the callback. If the callback returns `false`,\r\nthe loop will stop.\r\n\r"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "The map instance for chaining.\r\n\r"
    },
    "comment": " "
  },
  "can-define/map/map.prototype.on": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.on.md"
    },
    "body": "\r\n## Use\r\n\r\n`on` binds event handlers to property changes on `DefineMap`s. When you change\r\na property value, a _property name_ event is fired, allowing other parts\r\nof your application to map the changes to the object.\r\n\r\nThis event is useful for noticing changes to a specific property.\r\n\r\n\r\n    var o = new DefineMap({name: \"Justin\"});\r\n    o.on('name', function(ev, newVal, oldVal) {\r\n        console.log('The value of a changed.');\r\n    });\r\n\r\n\r\nThe parameters of the event handler for the _property name_ event are:\r\n\r\n- _ev_ The event object.\r\n- _newVal_ The value of the property after the change. `\r\n- _oldVal_ The value of the property before the change.\r\n\r\nHere is a concrete tour through the _property name_ event handler's arguments:\r\n\r\n\r\n    var o = new DefineMap({a: undefined, b: undefined});\r\n    o.on('a', function(ev, newVal, oldVal) {\r\n        console.log(newVal + ', ' + oldVal);\r\n    });\r\n\r\n    o.a = 'Alexis';       // Alexis, undefined\r\n    o.set('a', 'Adam');   // Adam, Alexis\r\n    o.set({\r\n        'a': 'Alice',     // Alice, Adam\r\n        'b': 'Bob'\r\n    });\r\n    o.a = undefined;      // undefined, Alice\r\n\n",
    "description": "Add event handlers to a map. \r\n",
    "title": "on\r",
    "name": "can-define/map/map.prototype.on",
    "type": "function",
    "parent": "can-define/map/map.prototype",
    "signatures": [
      {
        "code": "map.on(eventType, handler)",
        "description": "\n\r\nListens to `eventType` on `map` and calls `handler` when the event is dispatched.  This is simply\r\na reference to [can-event.on can-event.on] as all of [can-event] methods are available on `DefineMap`.\r\n\r\n```js\r\nvar map = new DefineMap({name: \"Justin\"})\r\nmap.on(\"name\", function(ev, newVal, oldVal){\r\n    newVal //-> \"Brian\"\r\n    oldVal //-> \"Justin\"\r\n});\r\nmap.name = \"Brian\";\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of event to bind this handler to.\r\n\r"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event"
                  },
                  {
                    "variable": true,
                    "name": "args"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires\r\nThe signature of the handler depends on the type of event being bound. See below\r\nfor details.\r\n\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "This map, for chaining.\r\n\r"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Event"
                }
              ],
              "name": "event"
            },
            {
              "variable": true,
              "name": "args"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires\r\nThe signature of the handler depends on the type of event being bound. See below\r\nfor details.\r\n\r"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "This map, for chaining.\r\n\r"
    },
    "comment": " "
  },
  "can-define/map/map.prototype.wildcard": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.wildcard.md"
    },
    "body": "",
    "description": "Define default behavior for a Map instance. \r\n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\r\nBy defining a wildcard property like `\"*\"` on the prototype, this will supply a\r\ndefault behavior for every property.  The default wildcard `\"*\"` definition\r\nmakes every property run through the \"observable\" [can-define.types] converter.\r\nIt looks like:\r\n\r\n```\r\n\"*\": {\r\n  type: \"observable\"\r\n}\r\n```\r\n\r\nSetting the wildcard is useful when every property on a\r\nmap instance should behave in a particular way.  For example, for map types used\r\nwith [can-route]:\r\n\r\n```\r\nvar MyMap = DefineMap.extend({\r\n  \"*\": {\r\n    type: \"stringOrObservable\"\r\n  }\r\n})\r\n```\r\n\r\nOr if you want to turn off implicit conversion of Objects and Arrays to DefineMap and DefineLists:\r\n\r\n```\r\nvar MyMap = DefineMap.extend({\r\n  \"*\": {\r\n    type: \"*\"\r\n  }\r\n})\r\n```\r\n"
      }
    ],
    "title": "*\r",
    "name": "can-define/map/map.prototype.wildcard",
    "type": "property",
    "parent": "can-define/map/map.prototype"
  },
  "can-define/map/map.extend": {
    "src": {
      "path": "node_modules/can-define/map/docs/static.extend.md"
    },
    "body": "",
    "description": "Define a custom map type. \r\n",
    "title": "extend\r",
    "name": "can-define/map/map.extend",
    "type": "function",
    "parent": "can-define/map/map.static",
    "signatures": [
      {
        "code": "DefineMap.extend([name,] [static,] prototype)",
        "description": "\n\r\nExtends DefineMap, or constructor functions derived from DefineMap,\r\nto create a new constructor function.\r\n\r\n```js\r\nvar DefineMap = require(\"can-define/map/map\");\r\n\r\nvar Person = DefineMap.extend(\r\n  \"Person\",\r\n  {seal: true},\r\n  {\r\n    first: \"string\",\r\n    last: {type: \"string\"},\r\n    fullName: {\r\n      get: function(){\r\n        return this.first+\" \"+this.last;\r\n      }\r\n    },\r\n    age: {value: 0},\r\n  });\r\n\r\nvar me = new Person({first: \"Justin\", last: \"Meyer\"})\r\nme.fullName //-> \"Justin Meyer\"\r\nme.age      //-> 0\r\n```\r\n\r",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Provides an optional name for this type that will\r\nshow up nicely in debuggers.\r\n\r"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "static",
            "description": "Static properties that are set directly on the\r\nconstructor function.\r\n\r"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      },
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "prototype",
            "description": "A definition of the properties or methods on this type.\r\n\r\nIf the property definition is a __plain function__, it's considered a method.\r\n\r\n```js\r\nvar Person = DefineMap.extend({\r\n  sayHi: function(){ console.log(\"hi\"); }\r\n});\r\n\r\nvar me = new Person();\r\nme.sayHi();\r\n```\r\n\r\nIf the property definition is a __string__, it's considered a `type` setting to be looked up in [can-define.types can-define.types].\r\n\r\n```js\r\nvar Person = DefineMap.extend({\r\n  age: 'number',\r\n  isCool: 'boolean',\r\n  hobbies: 'observable'\r\n});\r\n\r\nvar me = new Person({age: '33', isCool: 'false', hobbies: ['js','bball']});\r\nme.age    //-> 33\r\nme.isCool //-> false\r\nme.hobbies instanceof DefineList //-> true\r\n```\r\n\r\n\r\nIf the property definition is a Constructor function, it's considered a `Type` setting.\r\n\r\n```js\r\nvar Address = DefineMap.extend({\r\n  zip: 'number'\r\n});\r\nvar Person = DefineMap.extend({\r\n  address: Address\r\n});\r\n\r\nvar me = new Person({address: {zip: '60048'}});\r\nme.address.zip //-> 60048\r\n```\r\n\r\nIf the property is an __object__, it's considered to be a [can-define.types.propDefinition].\r\n\r\n```js\r\nvar Person = DefineMap.extend({\r\n  fullName: {\r\n    get: function() {\r\n      return this.first+\" \"+this.last;\r\n    },\r\n    set: function(newVal) {\r\n      var parts = newVal.split(\" \");\r\n      this.first = parts[0];\r\n      this.last = parts[1];\r\n    }\r\n  },\r\n  // slick way of creating an 'inline' type.\r\n  address: {\r\n    Type: {\r\n      zip: \"number\"\r\n    }\r\n  }\r\n});\r\n\r\nvar me = new Person({fullName: \"Rami Myer\", address: {zip: '60048'}});\r\nme.first       //-> \"Rami\"\r\nme.address.zip //-> 60048\r\n```\r\n\r"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "A DefineMap constructor function.\r\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                },
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "prototype",
      "description": "A definition of the properties or methods on this type.\r\n\r\nIf the property definition is a __plain function__, it's considered a method.\r\n\r\n```js\r\nvar Person = DefineMap.extend({\r\n  sayHi: function(){ console.log(\"hi\"); }\r\n});\r\n\r\nvar me = new Person();\r\nme.sayHi();\r\n```\r\n\r\nIf the property definition is a __string__, it's considered a `type` setting to be looked up in [can-define.types can-define.types].\r\n\r\n```js\r\nvar Person = DefineMap.extend({\r\n  age: 'number',\r\n  isCool: 'boolean',\r\n  hobbies: 'observable'\r\n});\r\n\r\nvar me = new Person({age: '33', isCool: 'false', hobbies: ['js','bball']});\r\nme.age    //-> 33\r\nme.isCool //-> false\r\nme.hobbies instanceof DefineList //-> true\r\n```\r\n\r\n\r\nIf the property definition is a Constructor function, it's considered a `Type` setting.\r\n\r\n```js\r\nvar Address = DefineMap.extend({\r\n  zip: 'number'\r\n});\r\nvar Person = DefineMap.extend({\r\n  address: Address\r\n});\r\n\r\nvar me = new Person({address: {zip: '60048'}});\r\nme.address.zip //-> 60048\r\n```\r\n\r\nIf the property is an __object__, it's considered to be a [can-define.types.propDefinition].\r\n\r\n```js\r\nvar Person = DefineMap.extend({\r\n  fullName: {\r\n    get: function() {\r\n      return this.first+\" \"+this.last;\r\n    },\r\n    set: function(newVal) {\r\n      var parts = newVal.split(\" \");\r\n      this.first = parts[0];\r\n      this.last = parts[1];\r\n    }\r\n  },\r\n  // slick way of creating an 'inline' type.\r\n  address: {\r\n    Type: {\r\n      zip: \"number\"\r\n    }\r\n  }\r\n});\r\n\r\nvar me = new Person({fullName: \"Rami Myer\", address: {zip: '60048'}});\r\nme.first       //-> \"Rami\"\r\nme.address.zip //-> 60048\r\n```\r\n\r"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "A DefineMap constructor function.\r\n"
    }
  },
  "can-define/map/map.seal": {
    "src": {
      "path": "node_modules/can-define/map/docs/static.seal.md"
    },
    "body": "\r\n",
    "description": "Defines if instances of the map should be [sealed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal) in development. \r\n",
    "types": [
      {
        "type": "Boolean",
        "description": "If `true`, in development, instances of this object will be [sealed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal).  In  [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) errors will be thrown when undefined properties are set.  This is the default\r\nbehavior of [can-define/map/map.extend extended DefineMaps]:\r\n\r\n```js\r\n\"use strict\";\r\nvar Person = DefineMap.extend({});\r\nvar me = new Person();\r\nme.age = 33 //-> throws \"TypeError: Can't add property age, object is not extensible\"\r\n```\r\n\r\nIf `false`, the object will not be sealed.  This is the default behavior of\r\nunextended [can-define/map/map DefineMaps].  Use [can-define/map/map.prototype.get] and [can-define/map/map.prototype.set] to get and set values:\r\n\r\n```js\r\nvar person = new DefineMap();\r\nperson.set(\"first\",\"Justin\");\r\nperson.set(\"last\",\"Meyer\");\r\n\r\nperson.get(\"first\") //-> \"Justin\"\r\nperson.get(\"last\") //-> \"Meyer\"\r\n```\r\n\r\nIt is also possible to extend a sealed object and unseal it:\r\n\r\n```js\r\n\"use strict\";\r\nvar Person = DefineMap.extend({});\r\nvar Programmer = Person.extend({seal: false}, {})\r\nvar me = new Programmer();\r\nme.age = 33; // no error thrown\r\n```\r\n\r\nSet `seal` to `false` on objects that have an indeterminate number of properties:\r\n\r\n```js\r\nvar Style = DefineMap.extend({\r\n  seal: false\r\n},{\r\n  cssText: {\r\n    get: function(){\r\n      return _.map(this.get(), function(val, prop){\r\n        return prop+\": \"+val;\r\n      }).join(\";\")\r\n    }\r\n  }\r\n});\r\nvar style = new Style();\r\nstyle.set(\"color\",\"green\");\r\nstyle.set(\"font\",\"awesome\");\r\nstyle.cssText //-> \"color:green; font: awesome;\"\r\n```\r\n"
      }
    ],
    "title": "seal\r",
    "name": "can-define/map/map.seal",
    "type": "property",
    "parent": "can-define/map/map.static"
  },
  "can-fixture/StoreType.prototype.createData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.createData.md"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-fixture/StoreType.prototype.createData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.createData(request, response)",
        "description": "\n\nA `requestHandler` that creates an item in the store.\n\n```js\nfixture(\"POST /api/todos\", todoStore.createData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.destroyData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.destroyData.md"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-fixture/StoreType.prototype.destroyData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.destroyData(request, response)",
        "description": "\n\nA `requestHandler` that removes an item from the store.\n\n```js\nfixture(\"DELETE /api/todos/{_id}\", todoStore.destroyData)\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.get": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.get.md"
    },
    "body": "",
    "description": "\n",
    "title": "get",
    "name": "can-fixture/StoreType.prototype.get",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.get(params)",
        "description": "\n\nReturns a single item's data from the store.\n\n```js\ntodoStore.get({id: 1}) //-> {id: 1, name: \"dishes\"}\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.getData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getData.md"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-fixture/StoreType.prototype.getData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getData(request, response)",
        "description": "\n\nA `requestHandler` that gets a single item from the store.\n\n```js\nfixture(\"GET /api/todos/{_id}\", todoStore.getData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.getList": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getList.md"
    },
    "body": "",
    "description": "\n",
    "title": "getList",
    "name": "can-fixture/StoreType.prototype.getList",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getList(set)",
        "description": "\n\nReturns the matching items from the store like: `{data: [...]}`.\n\n```js\ntodoStore.get({name: \"dishes\"}) //-> {data: [{id: 1, name: \"dishes\"}]}\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.getListData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getListData.md"
    },
    "body": "",
    "description": "\n",
    "title": "getListData",
    "name": "can-fixture/StoreType.prototype.getListData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getListData(request, response)",
        "description": "\n\nA `requestHandler` that gets multiple items from the store.\n\n```js\nfixture(\"GET /api/todos\", todoStore.getListData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.reset": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.reset.md"
    },
    "body": "",
    "description": "\n",
    "title": "reset",
    "name": "can-fixture/StoreType.prototype.reset",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.reset([baseItems])",
        "description": "\n\nSets the items in the store to their original state or to `baseItems` if it's passed as an argument.\n\n```js\n// Creates a store with one item.\nvar todoStore = fixture.store(\n    [{id: 1, name: \"dishes\"}],\n    new set.Algebra());\nfixture(\"/todos/{id}\", todoStore)\ntodoStore.getList({}).length //-> 1\n\n// delete that item\n$.ajax({url: \"todos/1\", method: \"delete\"}).then(function(){\n    return todoStore.getList({}).length //-> 0\n}).then(function(){\n    // calling reset adds it back\n    todoStore.reset();\n    todoStore.getList({}).length //-> 1\n});\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "baseItems",
            "description": "If provided, adds these items to the store.  \nThis can be useful for setting up particular testing scenarios.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "baseItems",
      "description": "If provided, adds these items to the store.  \nThis can be useful for setting up particular testing scenarios.\n"
    }
  },
  "can-fixture/StoreType.prototype.updateData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.updateData.md"
    },
    "body": "",
    "description": "\n",
    "title": "updateData",
    "name": "can-fixture/StoreType.prototype.updateData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.updateData(request, response)",
        "description": "\n\nA `requestHandler` that updates an item in the store.\n\n```js\nfixture(\"PUT /api/todos/{_id}\", todoStore.updateData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype": {
    "name": "can-fixture/StoreType.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-fixture/StoreType",
    "description": "",
    "order": 0
  },
  "can-fixture/StoreType": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/StoreType.md"
    },
    "body": "",
    "description": "\n",
    "title": "Store",
    "name": "can-fixture/StoreType",
    "type": "function",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "Store",
        "description": "\n\nThe following documents the methods on a store object returned by [can-fixture.store].\n",
        "params": []
      }
    ]
  },
  "can-fixture/types/ajaxSettings": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/ajaxSettings.md"
    },
    "body": "\n",
    "description": "\nAn object used to match incoming [can-fixture/types/request] objects.\n",
    "type": "typedef",
    "title": "ajaxSettings",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "url",
            "description": "The requested url with anything after the querystring taken off in `GET` and `DESTROY` method requests.  For example, you can't match:\n\n```\nfixture({method: \"GET\", url: \"/things?name=Justin\"});\n```\n\nInstead write:\n\n```\nfixture({method: \"GET\", url: \"/things\", data: {name: \"Justin\"}});\n```\n\nThe `url` can have templates like:\n\n```\nfixture({method: \"GET\", url: \"/things/{id}\"})\n```\n\nThe templated values get added to the [can-fixture/types/request] object's `data`.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "method",
            "description": "The method of the request. Ex: `GET`, `PUT`, `POST`, etc. Capitalization is ignored.",
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true
          },
          {
            "name": "data",
            "description": "Match the data of the request. The data of the querystring or the data to `XMLHTTPRequest.prototype.send` is converted to a JavaScript objects with either `JSON.stringify` or [can-util/js/deparam/deparam].  The data must match part of the `request`'s data.",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true
          },
          {
            "name": "async",
            "description": "Write `true` to match asynchronous requests only.  \n",
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true
          }
        ],
        "description": "\n\nThis object is used to match values on [can-fixture/types/request] objects.\nIf there's a match, the fixture handler provided with the\n[can-fixture/types/ajaxSettings] will be invoked.\n\nIf a property on an `ajaxSettings` is not provided, all request values\nwill be matched for that property.\n\nFor example,\nyou can match all `GET` requests, no matter what `url` is passed like:\n\n```\nfixture({method: \"GET\"}, function(){ ... });\n```\n\n"
      }
    ],
    "name": "can-fixture/types/ajaxSettings",
    "parent": "can-fixture.types"
  },
  "can-fixture/types/request": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/request.md"
    },
    "body": "\n",
    "description": "\nAn object with easily digestible values derived from the mock XHR\nobject.  \n",
    "type": "typedef",
    "title": "request",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "url",
            "description": "The requested url with anything after the querystring taken off in `GET` and `DESTROY` method requests.",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "method",
            "description": "The method of the request. Ex: `GET`, `PUT`, `POST`, etc.",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "data",
            "description": "The data of the querystring or the data to `XMLHTTPRequest.prototype.send` converted back to JavaScript objects with either `JSON.stringify` or [can-util/js/deparam/deparam].",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "headers",
            "description": "Headers added to the XHR object with `XMLHTTPRequest.prototype.setRequestHeader`.",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "async",
            "description": "`true` if the request was a synchronous request.",
            "types": [
              {
                "type": "Boolean"
              }
            ]
          },
          {
            "name": "xhr",
            "description": "The mock xhr request.\n",
            "types": [
              {
                "type": "XMLHTTPRequest"
              }
            ]
          }
        ],
        "description": "\n\nThis object is passed to a [can-fixture.requestHandler]\nand can be used to determine the response.\n\n```js\nfixture(\"GET /todos/{id}\", function(request, response){\n    request.url     //-> \"todos/5\"\n    request.method  //-> \"get\"\n    request.data    //-> {id: \"5\", include: [\"owner\"]}\n    request.headers //-> {}\n    request.async   //-> false\n});\n\n$.get(\"/todos/5?include[]=owner\");\n```\n"
      }
    ],
    "name": "can-fixture/types/request",
    "parent": "can-fixture.types"
  },
  "can-fixture.requestHandler": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/requestHandler.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "requestHandler",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/request"
              }
            ],
            "name": "request"
          },
          {
            "types": [
              {
                "type": "can-fixture.response"
              }
            ],
            "name": "response"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "requestHeaders"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "ajaxSettings"
          }
        ]
      }
    ],
    "name": "can-fixture.requestHandler",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "requestHandler(request, response(...), requestHeaders, ajaxSettings)",
        "description": "\n\nDefines the XHR response for a given trapped request.\n\n```js\nfixture({method: \"get\", url: \"/todos\"},\n  function(request, response, headers, ajaxSettings){\n    request //-> {\n            //    method: \"get\",\n            //    url: \"/todos\",\n            //    data: {complete: true}\n            //   }\n\n  }\n});\n\n$.ajax({ method: \"get\", url: \"/todos?complete=true\" })\n```\n\nTemplated `url` data will be added to the `requestHandler`'s `request` argument's `data` property:\n\n```js\nfixture({url: \"/todos/{action}\"},\n  function(request, response, headers, ajaxSettings){\n    request //-> {\n            //    method: \"post\",\n            //    url: \"/todos\",\n            //    data: {action: delete}\n            //   }\n  }\n});\n\n$.post(\"/todos/delete\");\n```",
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/request"
              }
            ],
            "name": "request",
            "description": "Information about the request. The request's data property will contain data from the request's querystring or request body. Also\nany templated values in the [can-fixture/types/ajaxSettings]'s `url` will be added. "
          },
          {
            "types": [
              {
                "type": "can-fixture.response"
              }
            ],
            "name": "response",
            "description": "A callback function that provides response information."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "requestHeaders",
            "description": "Headers used to make the request."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "ajaxSettings",
            "description": "The settings object used to match this request.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "ajaxSettings",
      "description": "The settings object used to match this request.\n"
    }
  },
  "can-fixture.response": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/response.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "response",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-fixture.response",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "response(status, body, headers, statusText)",
        "description": "\n\nUsed to detail a response.\n\nExample:\n\n```js\nfixture({url: \"/todos/{action}\"},\n  function(request, response, headers, ajaxSettings){\n    response(\n        401,\n        { message: \"Unauthorized\"},\n        { \"WWW-Authenticate\": 'Basic realm=\"myRealm\"'},\n        \"unauthorized\");\n  }\n});\n\n$.post(\"/todos/delete\");\n```\n\nYou don't have to provide every argument to `response`. It can be called like:\n\n```js\n// Just body\nresponse({ message: \"Hello World\"});\n// status and body\nresponse(401, { message: \"Unauthorized\"});\n// body and headers\nresponse('{\"message\":\"Unauthorized\"}',{\"WWW-Authenticate\":'Basic realm=\"myRealm\"'});\n// status, body statusText\nresponse(401, '{\"message\":\"Unauthorized\"}','unauthorized');\n```\n\nThe default `statusText` will be `ok` for `200 <= status < 300, status === 304` and `error`\nfor everything else.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "status",
            "description": "The [HTTP response code](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html). Ex: `200`."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "body",
            "description": "A JS object that will be serialized and set as the responseText of the XHR object, or\nthe raw string text that will be set as the responseText of the XHR object."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "headers",
            "description": "An object of HTTP response headers and values."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "statusText",
            "description": "The status text of the response. Ex: ``\"ok\"`` for 200.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "statusText",
      "description": "The status text of the response. Ex: ``\"ok\"`` for 200.\n"
    }
  },
  "can-stache/expressions/bracket": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/bracket.md"
    },
    "body": "\n## Use\n\nA bracket expression can be used to look up a dynamic property in the [can-view-scope scope]. This looks like:\n\n```\nTemplate:\n\t<h1>{{[key]}}</h1>\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tname: \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nThis can be useful for looking up values using keys containing non-alphabetic characters:\n\n```\nTemplate:\n\t<h1>{{[\"person:name\"]}}</h1>\n\nData:\n\t{\n\t\t\"person:name\": \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nBracket expressions can also be used to look up a value in the result of another expression:\n\n```\nTemplate:\n{{getPerson()[key]}}\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tgetPerson: function() {\n\t\t\treturn {\n\t\t\t\tname: \"Kevin\"\n\t\t\t};\n\t\t}\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Bracket Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/bracket",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "[key]",
        "description": "\n\nEvaluates `key` and looks up the result in the [can-view-scope scope].\n\n```\n{{[key]}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the [can-view-scope scope].\n"
          }
        ]
      },
      {
        "code": "CALL_EXPRESSION[key]",
        "description": "\n\nEvaluates `key` and looks up the result in the return value of `CALL_EXPRESSION`.\n\n```\n{{method()[key]}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A [can-stache/expressions/call Call], [can-stache/expressions/helper Helper], or [can-stache/expressions/key-lookup KeyLookup] expression that may or may not return a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the result of `CALL_EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the result of `CALL_EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache/expressions/call": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/call.md"
    },
    "body": "\n\n## Use\n\nA call expression calls a function looked up in the [can-view-scope scope] followed by\nthe [can-view-scope.Options helpers scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize(type,ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return type+(count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nCall expression arguments are comma (,) separated.  If a Hash expression is an argument,\nan object with the hash properties and values will be passed. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize(word=type count=ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(options){\n\t    return options.word+(options.count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Call Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/call",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "{{ method( [EXPRESSION...] ) }}",
        "description": "\n\nCalls `method` with zero or many arguments where each argument\nis a comma separated\n`EXPRESSION`.\n\n```\nmethod(1,key,hashProp=hashValue,call(),helper expression)\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/hash"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be passed as an argument\nto `method`.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/hash"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be passed as an argument\nto `method`.\n\n"
    },
    "comment": " "
  },
  "can-stache.expressions": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/expressions.md"
    },
    "body": "\n```\n{{helper key1 \"string\" method(key2, 1, prop1=key3) prop2=key4}}\n```\n\nThere are 6 expression types stache supports:\n\n - Literal expressions like `{{\"string\"}}`\n - KeyLookup expressions like `{{key}}`\n - Hash expressions like `{{prop=key}}`\n - Call expressions like `{{method(arg)}}`\n - Helper expressions like `{{helper arg}}`\n - Bracket expressions like `{{[key]}}`\n\n## Literal expressions\n\nA [can-stache/expressions/literal] specifies JS primitive values like:\n\n- Strings `\"strings\"`\n- Numbers `5`\n- Booleans `true` or `false`\n- And `null` or `undefined`\n\nThey are usually passed as arguments to Call or Helper expressions like:\n\n```\n{{pluralize \"dog\" 2}}\n{{task.filter(\"completed\", true)}}\n```\n\n## KeyLookup expressions\n\nA [can-stache/expressions/key-lookup] specifies a value in the [can-view-scope scope] or\n[can-view-scope.Options HelperOptions scope] that will be looked up. KeyLookup expressions\ncan be the entire stache expression like:\n\n```\n{{key}}\n```\n\nOr they can make up the method, helper, arguments, and hash value parts of\nCall, Helper, and Hash expressions:\n\n```\n{{method(arg1,arg2}}          Call\n{{helper arg1 arg2}}          Helper\n{{method( prop=hashValue )}}  Hash\n```\n\nThe value returned up by a KeyLookup depends on what the [can-stache.key] looks like, and\nwhat expression type the KeyLookup is within.\n\nFor example, `{{method(~./key)}}` will call `method` with\na [can-compute.computed compute] that looks up the value of `key` only in the top of the [can-view-scope scope].\n\nThe rules are as follows:\n\n - __call expression arguments__ `{{method(key)}}` - values are passed.\n - __helper expression arguments__ `{{helper key}}` - computes are passed.\n - __hash value in call expression__ `{{method(hash=key)}}` - values are set as property values.\n - __hash value in helper expression__ `{{method hash=key}}` - computes are set as property values.\n - __special operator__ `{{%index}}` - lookup values in a special context provided by some helpers.\n - __compute operator__ `{{method(~key)}}` - pass a compute instead of a value.\n - __at operator__ `{{method(@key}}` - pass a function instead of trying to read the value of the function.\n - __current context__ `{{./key}}` - only lookup key at the top of the scope.\n - __parent context__ `{{../key}}` - lookup the value in the parent context.\n - __context__ `{{.}}` - return the current context/top of the scope.\n\n## Hash expressions\n\nA [can-stache/expressions/hash] specifies a property value on a object argument in a call expression\nand property value on the the hash object in a helper expression's [can-stache.helperOptions] argument.\n\nFor example, in a call expression:\n\n```\nTemplate:\n\t{{methodA(prop=key)}}\n    {{methodB(propX=key propY='literal', propZ=5)}}\nData:\n\t{\n\t  methodA: function(arg){},\n      methodB: function(arg1, arg2),\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: \"value\"}` as `arg`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal'}` as `arg1` and `{propZ: 5}` as `arg2`\n\nIn a helper expression:\n\n```\nTemplate:\n\t{{methodA prop=key}}\n    {{methodB(propX=key propY='literal' propZ=5)}}\nData:\n\t{\n\t  methodA: function(options){},\n      methodB: function(options){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: compute(\"value\")}` as `options.hash`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal', propZ: 5}` as `options.hash`.\n\n## Call expressions\n\nA [can-stache/expressions/call] calls a function looked up in the [can-view-scope scope] followed by\nthe [can-view-scope.Options helpers scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize(type, ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return type+(count === 1 ? \"\" : \"s\")\n\t  },\n\t  ages: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nCall expression arguments are comma (,) separated.  If a Hash expression is an argument,\nan object with the hash properties and values will be passed. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize(word=type count=ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(options){\n\t    return options.word+(options.count === 1 ? \"\" : \"s\")\n\t  },\n\t  ages: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n\n## Helper expressions\n\nA [can-stache/expressions/helper] calls a function looked up in the [can-view-scope.Options helpers scope] followed by\nthe [can-view-scope scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize type ages.length}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return \"data-pluralize\"\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(type, count){\n\t    return type+(count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nHelper expression arguments that are observable are passed a compute.  This is\nin contrast to Call expressions that get passed the value.\n\nHelper expression arguments are space seperated.  If a Hash expression is an argument,\nthe hash properties and values will be added to the helper options object. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize word=type count=ages.length}}</h1>\n\nData:\n\t{\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(helperOptions){\n\t    return helperOptions.hash.type+(helperOptions.hash.count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n## Bracket expressions\n\nA [can-stache/expressions/bracket] can be used to look up a dynamic property in the [can-view-scope scope]. This looks like:\n\n```\nTemplate:\n\t<h1>{{[key]}}</h1>\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tname: \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nThis can be useful for looking up values using keys containing non-alphabetic characters:\n\n```\nTemplate:\n\t<h1>{{[\"person:name\"]}}</h1>\n\nData:\n\t{\n\t\t\"person:name\": \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nBracket expressions can also be used to look up a value in the result of another expression:\n\n```\nTemplate:\n{{getPerson()[key]}}\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tgetPerson: function() {\n\t\t\treturn {\n\t\t\t\tname: \"Kevin\"\n\t\t\t};\n\t\t}\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\n",
    "description": "\nIn addition to different magic tag types, stache supports different expression\ntypes.  These can be used in various combinations to call [can-stache.registerHelper helper methods]\nor [can-component.prototype.ViewModel viewModel methods].  The following is an example of all the expressions\ncombined:\n",
    "name": "can-stache.expressions",
    "title": "Expressions",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 2
  },
  "can-stache/expressions/hash": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/hash.md"
    },
    "body": "\n## Use\n\nA hash expression specifies a property value on a object argument in a call expression\nand property value on the the hash object in a helper expression's [can-stache.helperOptions] argument.\n\nFor example, in a call expression:\n\n```\nTemplate:\n\t{{methodA(prop=key)}}\n    {{methodB(propX=key propY='literal', propZ=5)}}\nData:\n\t{\n\t  methodA: function(arg){},\n      methodB: function(arg1, arg2){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: \"value\"}` as `arg`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal'}` as `arg1` and `{propZ: 5}` as `arg2`\n\nIn a helper expression:\n\n```\nTemplate:\n\t{{methodA prop=key}}\n    {{methodB(propX=key propY='literal' propZ=5)}}\nData:\n\t{\n\t  methodA: function(options){},\n      methodB: function(options){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: compute(\"value\")}` as `options.hash`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal', propZ: 5}` as `options.hash`.\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Hash Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/hash",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "[PROPERTY_NAME=EXPRESSION ]+",
        "description": "\n\nA sequence of one or more property names and their values as another expression like:\n\n```\nprop1=1 prop2=key prop3=callExpression()\n```\n\nIn a [can-stache/expressions/call], `Hash` expressions\ncreate an object argument with the specified `PROPERTY_NAME` properties\nand `EXPRESSION` values.\n\nThe following template:\n\n```js\n{{ method( age=5 first=person.firstName last=person.getLastName() ) }}\n```\n\nMight call `method` with:\n\n```js\n{age: 5, first: \"Justin\", last: \"Meyer\"}\n```\n\nIn a [can-stache/expressions/helper], `Hash` expressions\nadd to the [can-stache.helperOptions]'s `hash` object with the specified `PROPERTY_NAME` properties\nand `EXPRESSION` values.\n\nThe following template:\n\n```js\n{{ method age=5 first=person.firstName last=person.getLastName() }}\n```\n\nMight call `method` with:\n\n```js\n{\n\thash: {age: 5, first: compute(\"Justin\"), last: compute(\"Meyer\")}\n}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "PROPERTY_NAME",
            "description": "The property name on the call expression\nargument object or [can-stache.helperOptions]'s `hash` object.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that provides a\nvalue for the property name.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that provides a\nvalue for the property name.\n"
    },
    "comment": " "
  },
  "can-stache/expressions/helper": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/helper.md"
    },
    "body": "\n## Use\n\nA helpers expression calls a function looked up in the [can-view-scope.Options helpers scope] followed by\nthe [can-view-scope scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize type ages.length}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return \"data-pluralize\"\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(type, count){\n\t    return type+(count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nHelper expression arguments that are observable are passed a compute.  This is\nin contrast to Call expressions that get passed the value.\n\nHelper expression arguments are space seperated.  If a Hash expression is an argument,\nthe hash properties and values will be added to the helper options object. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize word=type count=ages.length}}</h1>\n\nData:\n\t{\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(helperOptions){\n\t    return helperOptions.hash.type+(helperOptions.hash.count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Helper Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/helper",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "method [EXPRESSION...]",
        "description": "\n\nCalls `method` with zero or many arguments where each argument\nis a space separated\n`EXPRESSION`.  \n\n\n\n```\n{{method 1 key call() hashProp=hashValue}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/hash"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be passed as an argument\nto `method`.\n\n\nAll [can-stache/expressions/hash]s will be collectively\nadded to the [can-stache.helperOptions]'s `hash` object.\n\nIf an `EXPRESSION` reads an observable, a\n[can-compute.computed] will be passed to `method`.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/hash"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be passed as an argument\nto `method`.\n\n\nAll [can-stache/expressions/hash]s will be collectively\nadded to the [can-stache.helperOptions]'s `hash` object.\n\nIf an `EXPRESSION` reads an observable, a\n[can-compute.computed] will be passed to `method`.\n\n\n"
    },
    "comment": " "
  },
  "can-stache/expressions/key-lookup": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/key-lookup.md"
    },
    "body": "\n## Use\n\n\n\nThe value returned up by a KeyLookup depends on what the [can-stache.key] looks like, and\nwhat expression type the KeyLookup is within.\n\nFor example, `{{method(~./key)}}` will call `method` with\na [can-compute.computed compute] that looks up the value of `key` only in the top of the [can-view-scope scope].\n\nThe rules are as follows:\n\n - __[can-stache/expressions/call] arguments__ `{{method(key)}}` - values are passed.\n - __[can-stache/expressions/helper] arguments__ `{{helper key}}` - computes are passed.\n - __hash value in [can-stache/expressions/call]__ `{{method(hash=key)}}` - values are set as property values.\n - __hash value in [can-stache/expressions/helper]__ `{{method hash=key}}` - computes are set as property values.\n - __[can-stache/keys/special special operator]__ `{{%index}}` - lookup values in a special context provided by some helpers.\n - __[can-stache/keys/compute compute operator]__ `{{method(~key)}}` - pass a compute instead of a value.\n - __[can-stache/keys/special at operator]__ `{{method(@key}}` - pass a function instead of trying to read the value of the function.\n - __[can-stache/keys/current current operator]__ `{{./key}}` - only lookup key at the top of the scope.\n - __[can-stache/keys/parent parent operator]__ `{{../key}}` - lookup the value in the parent context.\n - __[can-stache/keys/this context key]__ `{{this}}` - return the current context/top of the scope.\n\n\n## Default key return values by expression and data types\n\nKeys can have slightly different default behavior depending if they are used in:\n\n - [can-stache/expressions/helper helper arguments] like: `{{helper some.key}}`\n\nwhen compared to the other places they are used:\n\n - [can-stache.tags.escaped insertion tags] like: `{{some.key}}`\n - [can-stache/expressions/call call-expression arguments] like: `{{helper(some.key)}}`\n - [can-stache-bindings.event event bindings] like: `($click)=\"method(some.key)\"`\n - [can-stache-bindings data bindings] like: `{some-attr}=\"some.key\"`\n\nFurthermore keys return different values depending on the data type.\n\nIn general:\n\n - Functions are called to get their return value. (Use the [can-stache/keys/at `@` operator] to prevent this).\n - Keys in helper expression arguments that find observable data return\n   a [can-compute.computed] that represents the value.\n - Keys in other expressions return the value.\n - If no observable data is found, the key's value is returned in all expressions.\n\nThe following illustrates what `some.key` would return given\ndifferent data structures as a [can-stache/expressions/helper] and in all other expressions.\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}};\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A non-observable JS object with intermeidate functions:\n{some: function(){ return {key: \"value\"}}}\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A observable can-map\n{some: new Map({key: \"value\"})}\n   // Helper -> canCompute(\"value\")\n   // Other  -> \"value\"\n\n// A method on an observable can-map that reads observables\nvar Some = Map.extend({key: function(){ return this.attr(\"value\")}})\n{some: new Some({value: \"value\"})}\n   // Helper -> canCompute(\"value\")\n   // Other  -> \"value\"\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "KeyLookup Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/key-lookup",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "key",
        "description": "\n\nA [can-stache.key KeyLookup expression] specifies a value in the [can-view-scope scope] or\n[can-view-scope.Options HelperOptions scope] that will be looked up.  KeyLookup expressions\ncan be the entire stache expression like:\n\n```\n{{key}}\n```\n\nOr they can makeup the method, helper, arguments and hash value parts of\n[can-stache/expressions/call],\n[can-stache/expressions/helper], and [can-stache/expressions/hash]s:\n\n```\n{{method(arg1,arg2}}          Call\n{{helper arg1 arg2}}          Helper\n{{method( prop=hashValue )}}  Hash\n```\n",
        "params": []
      },
      {
        "code": "CALL_EXPRESSION.key",
        "description": "\n\nLooks up `key` on the return value of `CALL_EXPRESSION`.\n\n```\n{{#each Todo.getList(complete=completed).value}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A\ncall expression that may or may not return a value.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A property value to look up on\nthe result of `CALL_EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A property value to look up on\nthe result of `CALL_EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache/expressions/literal": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/literal.md"
    },
    "body": "\n\n## Use\n\nLiteral expressions are usually passed as arguments to [can-stache/expressions/call] or [can-stache/expressions/helper]s like:\n\n```js\n{{task.filter(\"completed\", true)}}\n{{pluralize \"dog\" 2}}\n```\n\n",
    "description": "\nSpecify a JavaScript primitive type.\n",
    "type": "typedef",
    "title": "Literal Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/literal",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "\"string\" | 'string'",
        "description": "\n\nSpecifies a string.\n\n```\n{{myHelper( \"this is a string\" )}}\n```\n",
        "params": []
      },
      {
        "code": "\\-[0-9]+\\.?[0-9]*",
        "description": "\n\nSpecifies a number.\n\n```\n{{myHelper( 5.2 )}}\n```\n",
        "params": []
      },
      {
        "code": "null | undefined | true | false",
        "description": "\n\nSpecifies a JavaScript `null`, `undefined`, `true`, or `false` value.\n\n```\n{{myHelper( false )}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache.helpers.case": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/case.md"
    },
    "body": "\n## Use\n\nThe `case` helper is contextual inside of a [can-stache.helpers.switch] block. The parent switch contains an `expr` that will be matched against the case `expr` and if they are equal the block will be returned.\n\nFor more information on how `{{#case}}` is used check:\n\n- [can-stache.helpers.switch]\n- [can-stache.helpers.default]\n\n",
    "description": "\n",
    "title": "{{#case expression}}",
    "name": "can-stache.helpers.case",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 14,
    "signatures": [
      {
        "code": "{{#case EXPRESSION}}BLOCK{{/case}}",
        "description": "\n\nRenders the `BLOCK` when `EXPRESSION` matches the `EXPRESSION` provided in the parent [can-stache.helpers.switch].\n\n```\n{{#switch user.type}}\n\t{{#case \"admin\"}}\n\t\tPay\n\t{{/case}}\n\t{{#case \"admin\"}}\n\t\t<button/>\n\t{{/case}}\n\t{{#default}}\n\t\tLook at data\n\t{{/default}}\n{{/switch}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression or key that references a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "A subsection that will be rendered if\nthe case `EXPRESSION` matches the switch's `EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "A subsection that will be rendered if\nthe case `EXPRESSION` matches the switch's `EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.default": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/default.md"
    },
    "body": "\n## Use\n\nThe `default` helper is contextual inside of a [can-stache.helpers.switch] block. It acts as a fall-through in case none of the [can-stache.helpers.case] helpers resolved.\n\nFor more information on how `{{#default}}` is used check:\n\n- [can-stache.helpers.switch {{#switch expr}}]\n- [can-stache.helpers.case {{#case expr}}]\n\n",
    "description": "\n",
    "title": "{{#default}}",
    "name": "can-stache.helpers.default",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 15,
    "signatures": [
      {
        "code": "{{#default}}BLOCK{{/default}}",
        "description": "\n\nRenders `BLOCK` if no [can-stache.helpers.case] blocks within the [can-stache.helpers.switch] resolved.\n\n```\n{{#switch user.type}}\n\t{{#case \"admin\"}}\n\t\tPay\n\t{{/case}}\n\t{{#case \"admin\"}}\n\t\t<button/>\n\t{{/case}}\n\t{{#default}}\n\t\tLook at data\n\t{{/default}}\n{{/switch}}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "a template to be rendered.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "a template to be rendered.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.each": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/each.md"
    },
    "body": "\n## Use\n\nUse the `each` helper to iterate over a array\nof items and render the block between the helper and the slash. For example,\n\nThe template:\n\n    <ul>\n      {{#each friends}}\n        <li>{{name}}</li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    {friends: [{name: \"Austin\"},{name: \"Justin\"}]}\n\nRenders:\n\n    <ul>\n      <li>Austin</li>\n      <li>Justin</li>\n    </ul>\n\n## Object iteration\n\nWhen iterating over [can-map] it will only iterate over the\nmap's [can-map.keys] and none of the hidden properties of a Map. For example,\n\nThe template:\n\n    <ul>\n      {{#each person}}\n        <li>{{.}}</li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    {person: {name: 'Josh', age: 27}}\n\nRenders:\n\n    <ul>\n      <li>Josh</li>\n      <li>27</li>\n    </ul>\n\n## Understanding when to use #each with lists\n\n`{{#each key}}` iteration will do basic diffing and aim to only update the DOM where the change occurred. Whereas\n[can-stache.tags.section] default iteration will re-render the entire section for any change in the list.\n[can-stache.tags.section] iteration is the preferred method to use when a list is replaced or changing significantly.\nWhen doing single list item changes frequently, `{{#each expression}}` iteration is the faster choice.\n\nFor example, assuming \"list\" is a [can-define/list/list] instance:\n\n`{{#each list}}` and `{{#list}}` both iterate through an instance of [can-define/list/list], however we setup the bindings differently.\n\n`{{#each list}}` will setup bindings on every individual item being iterated through, while `{{#list}}` will not. This makes a difference in two scenarios:\n\n1) You have a large list, with minimal updates planned after initial render. In this case, `{{#list}}` might be more advantageous as there will be a faster initial render. However, if any part of the list changes, the entire `{{#list}}` area will be re-processed.\n\n2) You have a large list, with many updates planned after initial render. A grid with many columns of editable fields, for instance. In this case, you many want to use `{{#each list}}`, even though it will be slower on initial render(we're setting up more bindings), you'll have faster updates as there are now many sections.\n\n",
    "description": "\n",
    "title": "{{#each expression}}",
    "name": "can-stache.helpers.each",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 5,
    "signatures": [
      {
        "code": "{{#each EXPRESSION}}FN{{else}}INVERSE{{/each}}",
        "description": "\n\nRender `FN` for each item in `EXPRESSION`'s return value.  If `EXPRESSION`\nis falsey or an empty list, render `INVERSE`.\n\n```\n{{#each todos}}\n  <li>{{name}}</li>\n{{else}}\n  <li>No todos, rest easy!</li>\n{{/each}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An\nexpression that typically returns a list like data structure.\n\nIf the value of the EXPRESSION is a [can-define/list/list] or [can-list], the resulting HTML is updated when the list changes. When a change in the list happens, only the minimum amount of DOM\nelement changes occur.  The list itself can also change, and a [can-util/js/diff/diff]\nwill be performed, which also will perform a minimal set of updates. The [can-stache/keys/special special %key key] is available within `FN`.\n\nIf the value of the key is an object, `FN` will be\ncalled for each property on the object. The [can-stache/keys/special special %key key]\nis available within `FN`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered with each\nitem in `EXPRESSION` or property value in `EXPRESSION`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n"
          }
        ]
      },
      {
        "code": "{{#each EXPRESSION as KEY}}FN{{else}}INVERSE{{/each}}",
        "description": "\n\nLike a normal `{{#each EXPRESSION}}`, but adds each item in `EXPRESSION` as\n`KEY` in `FN`'s [can-view-scope].\n\n```\n{{#each todos as todo}}\n    <li>{{todo.name}}</li>\n{{/each}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An\nexpression that returns a list or object like data structure.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "The name that:\n - each item in `EXPRESSION`'s list, or\n - each property value in `EXPRESSION`'s object\nshould take on in `FN`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered with each\nitem in `EXPRESSION` or property value in `EXPRESSION`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n\n"
    },
    "comment": " "
  },
  "can-stache.helpers.if": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/if.md"
    },
    "body": "\n## Use\n\n`{{#if key}}` provides explicit conditional truthy tests. For example,\n\nThe template:\n\n    {{#if user.isFemale}}\n      {{#if user.isMarried}}\n        Mrs\n      {{/if}}\n      {{#if user.isSingle}}\n        Miss\n      {{/if}}\n    {{/if}}\n\nRendered with:\n\n    {user: {isFemale: true, isMarried: true}}\n\nResults in:\n\n    Mrs\n\nIf can be used with [can-stache.helpers.else {{else}}] too. For example,\n\n    {{#if user.isFemale}}\n      {{#if user.isMarried}}\n        Mrs\n      {{else}}\n        Miss\n      {{/if}}\n    {{/if}}\n\nRendered with:\n\n    {user: {isFemale: true, isMarried: false}}\n\nResults in:\n\n    Miss\n\n",
    "description": "",
    "title": "{{#if expression}}",
    "name": "can-stache.helpers.if",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 2,
    "signatures": [
      {
        "code": "{{#if EXPRESSION}}FN{{else}}INVERSE{{/if}}",
        "description": "\n\nRenders `FN` if `EXPRESSION` is truthy or `INVERSE` if `EXPRESSION`\nis falsey. Both `FN` and `INVERSE` will be rendered with the\ncurrent scope.\n\n```\n{{#if person.isAwake() }} Hello {{/if}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a truthy or falsey value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that can be optionally rendered.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey and [can-stache.helpers.else] is used.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey and [can-stache.helpers.else] is used.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.is": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/is.md"
    },
    "body": "\n\n## Use\n\nThe `is` helper compares expr1 and expr2 and renders the blocks accordingly.\n\n\t{{#is expr1 expr2}}\n\t\t// truthy\n\t{{else}}\n\t\t// falsey\n\t{{/is}}\n\n",
    "description": "\nRender something if two values are equal.\n",
    "title": "{{#is expressions}}",
    "name": "can-stache.helpers.is",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 12,
    "signatures": [
      {
        "code": "{{#is [EXPRESSION...]}}FN{{else}}INVERSE{{/is}}",
        "description": "\n\nRenders the `FN` if every `EXPRESSION` argument is equal (`===`).\n\n```\n{{#is user.type \"admin\"}} <button/> {{else}}  Login {{/is}}\n{{#is task.ownerId task.assignedId user.id }} Delegate! {{/is}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "Two or more expressions whose return values will be tested for equality.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered if each\n`EXPRESSION` argument is equal.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif one of the `EXPRESSION` arguments is not equal to one of the others.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif one of the `EXPRESSION` arguments is not equal to one of the others.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.joinBase": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/joinBase.md"
    },
    "body": "\nThe `joinBase` helper is used to create urls within your application for static resources, such as images. An example usage:\n\n    {{joinBase \"hello/\" name \".png\"}}\n\nWhere `name` is a scope value, this might return `http://example.com/app/hello/world.png` if the application is `http://example.com/app`.\n\nThe url to join with is determined by the following factors:\n\n* If attempting to load a relative url, such as `{{joinBase \"../foo.png\"}}` and using StealJS the template's address will be used as a reference to look up the location.\n* If the `can.baseURL` string is set, this will be used.\n* If the `System.baseURL` is set, this will be used.\n* Lastly we fall back to `location.pathname`.\n\n",
    "description": "\n",
    "title": "{{joinBase expressions}}",
    "name": "can-stache.helpers.joinBase",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 16,
    "signatures": [
      {
        "code": "{{joinBase [EXPRESSION...]}}",
        "description": "\n\nReturn an application-relative url for a resource.\n\n```\n{{joinBase \"hello/\" name \".png\"}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "variable": true,
            "description": "Expression or key arguments that reference a value within the current or parent scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "variable": true,
      "description": "Expression or key arguments that reference a value within the current or parent scope.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.log": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/log.md"
    },
    "body": "",
    "description": "\n",
    "title": "{{log}}",
    "name": "can-stache.helpers.log",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 9,
    "signatures": [
      {
        "code": "{{ log([EXPRESSION]) }}",
        "description": "\n\n`console.log`s the current context or the result of the provided expressions.\n\n```\n{{log}}\n{{ log(person.name, person.age)  }}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "\nArguments to `console.log`.  If none are provided, the current context (the top of the [can-view-scope]) will be logged.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "description": "\nArguments to `console.log`.  If none are provided, the current context (the top of the [can-view-scope]) will be logged.\n"
    }
  },
  "can-stache.registerHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/registerHelper.md"
    },
    "body": "\n",
    "description": "Register a helper. \n",
    "title": "registerHelper",
    "name": "can-stache.registerHelper",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerHelper(name, helper)",
        "description": "\n\n\nRegisters a helper function.\nPass the name of the helper followed by the\nfunction to which stache should invoke. See [can-stache.Helpers] for more details on using helpers\nand [can-stache.registerSimpleHelper] to avoid converting computes;\n\n```js\nstache.registerHelper(\"upper\", function(str){\n\tif(str.isComputed) {\n\t\tstr = str();\n\t}\n\treturn str.toUpperCase();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the helper."
          },
          {
            "types": [
              {
                "type": "can-stache.helper"
              }
            ],
            "name": "helper",
            "description": "The helper function.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helper"
        }
      ],
      "name": "helper",
      "description": "The helper function.\n"
    },
    "comment": " "
  },
  "can-stache.registerSimpleHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/registerSimpleHelper.md"
    },
    "body": "\n",
    "description": "Register a helper that gets passed values. \n",
    "title": "registerSimpleHelper",
    "name": "can-stache.registerSimpleHelper",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerSimpleHelper(name, helper)",
        "description": "\n\nRegisters a helper with stache that always returns\nthe arguments value (instead of a compute).\nPass the name of the helper followed by the\nfunction to which Mustache should invoke.\n\nSee [can-stache.Helpers] for more details on using helpers\nand [can-stache.registerHelper] to get computes for observable values.\n\n```js\nstache.registerSimpleHelper(\"upper\", function(str){\n\treturn str.toUpperCase();\n});\n```\n\nSee [can-stache.Helpers] for more details on using helpers.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the helper."
          },
          {
            "types": [
              {
                "type": "can-stache.simpleHelper"
              }
            ],
            "name": "helper",
            "description": "The helper function.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.simpleHelper"
        }
      ],
      "name": "helper",
      "description": "The helper function.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.switch": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/switch.md"
    },
    "body": "\n## Use\n\nThe `switch` helper is used to render a block where one of several cases matches expr. It works just like a JavaScript switch.\n\n\n\t{{#switch page}}\n\n\t\t{{#case \"cart\"}}\n\t\t\t<can-import from=\"cart\">\n\t\t\t\t<cart-page></cart-page>\n\t\t\t</can-import>\n\t\t{{/case}}\n\n\t\t{{#default}}\n\t\t\t<can-import from=\"home\">\n\t\t\t\t<home-page></home-page>\n\t\t\t</can-import>\n\t\t{{/default}}\n\n\t{{/switch}}\n\n",
    "description": "\n",
    "title": "{{#switch expression}}",
    "name": "can-stache.helpers.switch",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 13,
    "signatures": [
      {
        "code": "{{#switch EXPRESSION}}BLOCK{{/switch}}",
        "description": "\n\nRenders the `BLOCK` with contextual [can-stache.helpers.case] and [can-stache.helpers.default] helpers.\n\n```\n{{#switch user.type}}\n\t{{#case \"admin\"}}\n\t\tPay\n\t{{/case}}\n\t{{#case \"admin\"}}\n\t\t<button/>\n\t{{/case}}\n\t{{#default}}\n\t\tLook at data\n\t{{/default}}\n{{/switch}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression or key that references a value that will be switched on.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "a template that is rendered, uses [can-stache.helpers.case] and [can-stache.helpers.default] helpers to match `EXPRESSION`.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "a template that is rendered, uses [can-stache.helpers.case] and [can-stache.helpers.default] helpers to match `EXPRESSION`.\n\n"
    },
    "comment": " "
  },
  "can-stache.helpers.unless": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/unless.md"
    },
    "body": "\n## Use\n\nThe `unless` helper evaluates the inverse of the value\nof the key and renders the block between the helper and the slash.\n\n    {{#unless expr}}\n      // unless\n    {{/unless}}\n\n",
    "description": "\n",
    "title": "{{#unless expression}}",
    "name": "can-stache.helpers.unless",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 4,
    "signatures": [
      {
        "code": "{{#unless EXPRESSION}}FN{{else}}INVERSE{{/unless}}",
        "description": "\n\nRenders `FN` if `EXPRESSION` is falsey or `INVERSE` if `EXPRESSION`\nis truthy. Both `FN` and `INVERSE` will be rendered with the\ncurrent scope.\n\n```\n{{#unless person.isAwake() }} Shhhhh! {{/if}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a truthy or falsey value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that can be optionally rendered.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is truthy and [can-stache.helpers.else] is used.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is truthy and [can-stache.helpers.else] is used.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.with": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/with.md"
    },
    "body": "\n\n## Use\n\n`{{#with}}` renders a subsection with a new context added to the [can-view-scope].\nFor example:\n\n```\nTEMPLATE:\n\t{{#with person.address}}\n\t\tStreet: {{street}}\n\t\tCity: {{city}}\n\t{{/with}}\nDATA:\n\t{person: {address: {street: \"123 Evergreen\", city: \"Springfield\"}}}\n\nRESULT:\n\tStreet: 123 Evergreen\n\tCity: Springfield\n```\n\nThe difference between `{{#with}}` and the default [can-stache.tags.section]\nis that the subsection `BLOCK` is rendered no matter what:\n\n```\nTEMPLATE:\n\t{{#with person.address}}\n\t\tStreet: {{street}}\n\t\tCity: {{city}}\n\t{{/with}}\nDATA:\n\t{person: {}}\n\nRESULT:\n\tStreet:\n\tCity:\n```\n\n",
    "description": "\nChanges the context within a block.\n",
    "title": "{{#with expression}}",
    "name": "can-stache.helpers.with",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 6,
    "signatures": [
      {
        "code": "{{#with EXPRESSION}}BLOCK{{/with}}",
        "description": "\n\nRenders `BLOCK` with the result of `EXPRESSION` added to the top of the [can-view-scope].\n\n```\n{{#with person.address}}\n\tStreet: {{street}}\n\tCity: {{city}}\n{{/with}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "A template that is rendered\nwith the context of the `EXPRESSION`'s value.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "A template that is rendered\nwith the context of the `EXPRESSION`'s value.\n"
    },
    "comment": " "
  },
  "can-stache/keys/at": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/at.md"
    },
    "body": "\n\n\n## Use\n\nThe following illustrates what `some@key` would return given\ndifferent data structures:\n\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}}\n   //-> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   //-> function(){ return \"value\"; }\n\n// A non-observable JS object with intermeidate functions:\n{some: function(){ return {key: \"value\"}}}\n   //-> \"value\"\n\n// A observable can-map\n{some: new Map({key: \"value\"})}\n   //-> \"value\"\n\n// A method on an observable can-map that reads observables\nvar Some = Map.extend({key: function(){ return this.attr(\"value\")}})\n{some: new Some({value: \"value\"})}\n   //-> function(){ return this.attr(\"value\")}\n```\n\nWhere `some@key` returns a function, that function is \"bound\" via `.bind(context)`\nto the parent object.  This means that calling the function will\nhave `this` set to what is expected.\n\nIf the AT key is used at the start of a key like:\n\n```\n{{method(@key)}}\n```\n\nThis will return whatever is at the `key` property on the first context in the scope\nto have a non-undefined `key` value.\n\nThe AT key can be used multiple times within a value lookup expression like:\n\n```\n{{method(models@Todo@getList)}}\n```\n\n",
    "description": "\nReturn whatever value is at a key, regardless\nif it's a function or a compute.\n",
    "type": "typedef",
    "title": "@at",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/at",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "@key",
        "description": "\n\nLookup a `key` value in the scope and return whatever is there.\n\n```\n<paginator {next}=\"@loadNext\"/>\n```\n",
        "params": []
      },
      {
        "code": "key@prop",
        "description": "\n\nLookup `prop` property on `key` and return whatever is there.\n\n```\n<grid {get-data}=\"Todo@getList\"/>\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/compute": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/compute.md"
    },
    "body": "\n\n## Use\n\nThe following illustrates what `~some.key` would return given\ndifferent data structures:\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}}\n   //-> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   //-> \"value\"\n\n// A non-observable JS object with intermediate functions:\n{some: function(){ return {key: \"value\"}}}\n   //-> \"value\"\n\n// A observable can-map\n{some: new DefineMap({key: \"value\"})}\n   //-> canCompute(\"value\")\n\n// A method on an observable can-map that reads observables\nvar Some = DefineMap.extend({\n\tvalue: \"string\",\n\tkey: function(){ return this.value; }\n})\n{some: new Some({value: \"value\"})}\n   //-> compute(function(){ return this.value; })\n```\n\nNotice that `~` should only be used once in a value lookup expression.\n\n",
    "description": "\nPass a compute instead of a value if an observable is found within\n[can-stache/expressions/call].\n",
    "type": "typedef",
    "title": "~compute",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/compute",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "~key",
        "description": "\n\nThis makes non-helper expression arguments behave similarly to helper\nexpression arguments.\n\n```\n{{#each(~todos)}} ... {{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/current": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/current.md"
    },
    "body": "\n\n## Use\n\nSometimes, especially with recursive templates, you want to control which\ncontext is used to lookup.  Adding `./` before the key name will\nonly look up in the current context.\n\nThe following template:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{./last}}\n      {{/children}}\n\nRendered with:\n\n    {\n      first: \"Barry\", last: \"Meyer\",\n      children: [\n        {first: \"Kim\", last: \"Sully\"},\n        {first: \"Justin\"},\n      ]\n    }\n\nWrites out:\n\n    Barry Meyer\n        Kim Sully\n        Justin\n\nNotice that `{{./last}}` returns nothing because there's no `last` property\nin the `{first: \"Justin\"}` object.\n\n",
    "description": "\nLookup a value in only the current context.\n",
    "type": "typedef",
    "title": "./current",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/current",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "./key",
        "description": "\n\nOnly looks up `key` in the current context.  Returns `undefined` if\nnot found.\n\n```\n{{#each todo}}\n  <input {($checked)}=\"./complete\"/> {{./name}}\n{{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache.key": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/key.md"
    },
    "body": "\n\n## Use\n\nA key references a value within the [can-view-scope scope] of a\ntemplate being rendered. In the following example, the\nkey is `name`:\n\n    <h1>{{name}}</h1>\n\nIf this template is rendered with:\n\n    {\n      name: \"Austin\"\n    }\n\nThe template writes out:\n\n    <h1>Austin</h1>\n\nA scope is a collection of multiple contexts. By default, a\nkey walks up the scope to each context until it finds a value. For example,\na template like:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{last}}\n      {{/children}}\n\nRendered with:\n\n    {\n      first: \"Barry\", last: \"Meyer\",\n      children: [\n        {first: \"Kim\", last: \"Sully\"},\n        {first: \"Justin\"},\n      ]\n    }\n\nWrites out:\n\n    Barry Meyer\n        Kim Sully\n        Justin Meyer\n\nWhen `last` is looked up on the `{first: \"Justin\"}` object and not found,\nit will then try to read the parent context's `last` property.  This is\nwhy \"Justin Meyer\" is written out.\n\n",
    "description": "A named reference to a value in the [can-view-scope scope] or [can-view-scope.Options helper scope] in a template.\n\n",
    "type": "typedef",
    "title": "key",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache.key",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "key",
        "description": "\n\nLooks up a value in the [can-view-scope scope] or\n[can-view-scope.Options helper scope].  This results in a\n[can-stache/expressions/key-lookup]. [can-stache/expressions/key-lookup]\nexpressions can provide different values depending on what type of expression they\nare within.  These rules are detailed in [can-stache/expressions/key-lookup].\n\n```\n{{name}}\n{{#canVote(age)}}\n```\n",
        "params": []
      },
      {
        "code": "EXPRESSION.key",
        "description": "\n\nLooks up `key` on the result of a subexpression `EXPRESSION`.\n\n```\n{{person.first.name}}\n{{#if tasks.completed().length}} ... {{/if}}\n```\n",
        "params": []
      },
      {
        "code": "a\\\\.single\\\\.key",
        "description": "\n\nLooks up a value without reading intermediate properties.\n\n\n```\n{{meta\\\\.data}}\n```\n\nThis is deprecated.  If you do have properties with dots in them, use a [can-stache/expressions/bracket Bracket Expression]:\n\n```\n{{[\"meta.data\"]}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/parent": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/parent.md"
    },
    "body": "\n\n## Use\n\nAdding `../` before a key will lookup the key starting in the parent\ncontext.  By changing the previous template to:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{../last}}\n      {{/children}}\n\nIt will write out:\n\n    Barry Meyer\n        Kim Meyer\n        Justin Meyer\n\nYou can use `.././last` to lookup `last` _only_ in the parent context.\n\n",
    "description": "\nStart looking for values in the parent context.\n",
    "type": "typedef",
    "title": "../parent",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/parent",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "../key",
        "description": "\n\nLook for values starting in the parent context.\n\n```\n{{#each todos}}\n\t<div class='{{#if ../isEditing(this)}}editing{{/if}}'>\n\t\t{{./name}}\n\t</div>\n{{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/special": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/special.md"
    },
    "body": "\n",
    "description": "\n[can-stache-bindings.can-EVENT Event bindings] and some helpers like [can-stache.helpers.each]\nprovide special values that start with `%` to prevent potential collisions with\nother values.  \n",
    "type": "typedef",
    "title": "%special",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/special",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "%index",
        "description": "\n\nWhen looping over an array, [can-define/list/list], or [can-list], you an use `%index` to write out the index of each property:\n\n    {{#each tasks}}\n      <li>{{%index}} {{name}}</li>\n    {{/each}}\n\nIndexes start at 0.  If you want to start at 1, you can create a helper like:\n\n    stache.registerHelper('%indexNum', function(options){\n      return options.scope.get(\"%index\")+1;\n    })\n\nAnd use it like:\n\n    {{#each task}}\n      <li>{{%indexNum}} {{name}}</li>\n    {{/each}}\n",
        "params": []
      },
      {
        "code": "%key",
        "description": "\n\nLike `%index`, but provides the key value when looping through an object:\n\n```\n{{#each style}}\n   {{%key}}: {{this}}\n{{/each}}\n```\n\n",
        "params": []
      },
      {
        "code": "%element",
        "description": "\n\nIn an event binding, `%element` references the DOM element the event happened on:\n\n```\n<input ($click)=\"doSomething(%element.value)\"/>\n```\n",
        "params": []
      },
      {
        "code": "%event",
        "description": "\n\nIn an event binding, `%event` references the dispatched event object:\n\n```\n<input ($click)=\"doSomething(%event)/>\"\n```\n",
        "params": []
      },
      {
        "code": "%viewModel",
        "description": "\n\nIn an event binding, `%viewModel` references the view model of the current element:\n\n```\n<my-component (closed)=\"doSomething(%viewModel)\"/>\n```\n",
        "params": []
      },
      {
        "code": "%arguments",
        "description": "\n\nIn an event binding, `%arguments` references the arguments passed when the event was dispatched/triggered.\n\n```\n<input ($click)=\"doSomething(%arguments)\"/>\n```\n",
        "params": []
      }
    ]
  },
  "can-stache/keys/this": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/this.md"
    },
    "body": "\n\n## Use\n\n\nTo write out the current context, write `{{.}}` or `{{this}}`. For example,\na template like:\n\n    {{#each names}}{{this}} {{/each}}\n\nWith data like:\n\n    {names: [\"Jan\",\"Mark\",\"Andrew\"]}\n\nWill write out:\n\n    Jan Mark Andrew\n\n",
    "description": "\nWrite out or return the current context.\n",
    "type": "typedef",
    "title": "this",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/this",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "this",
        "description": "\n\nWrites out or returns the current context.\n\n```\n{{#each names}}{{this}} {{/each}}\n{{#each names}}\n\t{{sanitize(this)}}\n{{/each}}\n```\n\n",
        "params": []
      },
      {
        "code": ".",
        "description": "\n\n  The same as writing `this`, but with 3 fewer characters!\n\n  ```\n  {{#each names}}{{.}} {{/each}}\n  {{#each names}}\n  \t{{sanitize(.)}}\n  {{/each}}\n  ```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/variable": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/variable.md"
    },
    "body": "\n\n## Use  \n\nEvery template contains a context which is able to store values\nlocal to the template. Keys with `*` reference variables in that context.\n\nTemplate variables are often used to pass data between\ncomponents. `<component-a>` exports its `propA` value to the\ntemplate variable `*variable`.  This is, in turn, used to update\nthe value of `propB` in `<component-b>`.\n\n```\n<component-a {^prop-a}=\"*variable\"/>\n<component-b {prop-b}=\"*variable\"/>\n```\n\nTemplate variables are global to the template. Similar to JavaScript `var`\nvariables, template variables do not have block level scope.  The following\ndoes not work:\n\n```\n{{#each something}}\n\t<component-a {^prop-a}=\"*variable\"/>\n\t<component-b {prop-b}=\"*variable\"/>\n{{/each}}\n```\n\nTo work around this, an `localContext` helper could be created as follows:\n\n```\nstache.regsiterHelper(\"localContext\", function(options){\n  return options.fn(new Map());\n});\n```\n\nAnd used like:\n\n```\n{{#each something}}\n\t{{#localContext}}\n\t  <component-a {^prop-a}=\"./variable\"/>\n\t  <component-b {prop-b}=\"./variable\"/>\n\t{{/localContext}}\n{{/each}}\n```\n\n",
    "description": "\nStore a variable local to the template.\n",
    "type": "typedef",
    "title": "*variable",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/variable",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "*variable",
        "description": "\n\nA placeholder for a value that is local to the template.\n\n```\n<drivers-licenses {^selected}=\"*selectedDriver\"/>\n<edit-driver {driver}=\"*selectedDriver\"/>\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/helpers/route": {
    "src": {
      "path": "node_modules/can-stache/docs/route/route.md"
    },
    "body": "\n",
    "description": "\nAdds stache helpers that use [can-route].\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-stache/helpers/route",
    "parent": "can-core"
  },
  "can-stache.helpers.routeCurrent": {
    "src": {
      "path": "node_modules/can-stache/docs/route/routeCurrent.md"
    },
    "body": "\n\n## Use\n\nUse the `routeCurrent` helper like:\n\n```\n<li {{#routeCurrent page=\"recipe\" id=5}}class='active'{{/routeCurrent}}>\n  <a href='{{routeUrl page=\"recipe\" id=5}}'>{{recipe.name}}</a>\n</li>\n```\n\nWith default routes and a url like `#!&page=5&id=5`, this produces:\n\n```\n<li class='active'>\n  <a href='#!&page=5&id=5'>{{recipe.name}}</a>\n</li>\n```\n\nIt this functionality could use call expressions like:\n\n```\n<li {{#routeCurrent(page=\"recipe\" id=5)}}class='active'{{/routeCurrent}}>\n  <a href='{{ routeCurrent(page=\"recipe\" id=5) }}'>{{recipe.name}}</a>\n</li>\n```\n\n\nThe following demo uses `routeCurrent` and [can-stache.helpers.routeUrl] to\ncreate links that update [can-route]'s `page` attribute:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache/route-url.html'></div>\n\n",
    "description": "\nReturns if the hash values match the [can-route]'s current properties.\n",
    "title": "{{#routeCurrent hash}}",
    "name": "can-stache.helpers.routeCurrent",
    "type": "function",
    "parent": "can-stache/helpers/route",
    "signatures": [
      {
        "code": "routeCurrent( hashes... [,subsetMatch] )",
        "description": "\n\n  Calls [can-route.current route.current] with `hashes` and returns the result. This\n  can be used in conjunction with other helpers:\n\n```\n{{linkTo \"Todos\" routeCurrent(page='todos' id=todo.id)}}\n```\n\nOr on its own:\n\n```\n<a class=\"{{#routeCurrent(page='todos',true) }}active{{/routeCurrent}}\">Todos</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "name": "hashes",
            "description": "A hash expression like `page='edit' recipeId=id`.\n"
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If an optional `true` is passed, `routeCurrent` will\nreturn `true` if every value in `hashes` matches the current route data, even if\nthe route data has additional properties that are not matched.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Returns the result of calling [can-route.current route.current].\n"
        }
      },
      {
        "code": "{{#routeCurrent [subsetMatch] hashes...}}FN{{else}}INVERSE{{/routeCurrent}}",
        "description": "\n\nRenders `FN` if the `hashes` passed to [can-route.current route.current] returns `true`.\nRenders the `INVERSE` if [can-route.current route.current] returns `false`.\n\n```\n<a class=\"{{#routeCurrent true page='todos'}}active{{/routeCurrent}}\">Todos</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If an optional `true` is passed, `routeCurrent` will\nreturn `true` if every value in `hashes` matches the current route data, even if\nthe route data has additional properties that are not matched.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "name": "hashes",
            "description": "A hash expression like `page='edit' recipeId=id`.\n\n\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered if the current route matches `hashes`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif the current route does not match `hashes`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The result of `SUBEXPRESSION` or `{{else}}` expression.\n\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The result of `SUBEXPRESSION` or `{{else}}` expression.\n\n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif the current route does not match `hashes`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.routeUrl": {
    "src": {
      "path": "node_modules/can-stache/docs/route/routeUrl.md"
    },
    "body": "\n\n## Use\n\nUse the `routeUrl` helper like:\n\n```\n<a href='{{routeUrl page=\"recipe\" id=5}}'>{{recipe.name}}</a>\n```\n\nThis produces (with no pretty routing rules):\n\n```\n<a href='#!&page=5&id=5'>{{recipe.name}}</a>\n```\n\nIt this functionality could also be written as:\n\n```\n<a href='{{ routeUrl(page=\"recipe\" id=5) }}'>{{recipe.name}}</a>\n```\n\nUsing call expressions/parenthesis lets you pass the `merge` option to `route`.  This\nlets you write a url that only changes specified properties:\n\n```\n<a href='{{ routeUrl(id=5, true) }}'>{{recipe.name}}</a>\n```\n\n\n\n\nThe following demo uses `routeUrl` and [can-stache.helpers.routeCurrent] to\ncreate links that update [can-route]'s `page` attribute:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache/route-url.html'></div>\n\nIt also writes out the current url like:\n\n```\n{{ routeUrl(undefined,true) }}\n```\n\nThis calls `route.url({}, true)` which has the effect of writing out\nthe current url.\n\n",
    "description": "\nReturns a url using [can-route.url route.url].\n",
    "title": "{{routeUrl hashes}}",
    "name": "can-stache.helpers.routeUrl",
    "type": "function",
    "parent": "can-stache/helpers/route",
    "signatures": [
      {
        "code": "routeUrl( hashes... [,merge] )",
        "description": "\n\nCalls [can-route.url] with  `hashes` as it's `data` argument and an\noptional `merge`.\n\nThis can be used on its own to create `<a>` `href`s like:\n\n```\n<a href=\"{{ routeUrl(page='todos' id=todo.id) }}\">details</a>\n```\n\nOr in conjunction with other helpers:\n\n```\n{{makeLink \"details\" routeUrl(page='todos', true)}}\n```\n",
        "params": []
      },
      {
        "code": "{{routeUrl [merge] hashes... }}",
        "description": "\n\nPasses the hashes to `route.url` and returns the result.\n\n```\n<a href=\"{{routeUrl page='todos' id=todo.id}}\">details</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Pass `true` to create a url that merges `hashes` into the\ncurrent [can-route] properties.  \n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "optional": true,
            "name": "hashes",
            "variable": true,
            "description": "A hash expression like `page='edit' recipeId=id`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the result of calling `route.url`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/hash"
        }
      ],
      "optional": true,
      "name": "hashes",
      "variable": true,
      "description": "A hash expression like `page='edit' recipeId=id`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the result of calling `route.url`.\n"
    },
    "comment": " "
  },
  "can-stache.tags.close": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/close.md"
    },
    "body": "",
    "description": "\n",
    "title": "{{/expression}}",
    "name": "can-stache.tags.close",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 4,
    "signatures": [
      {
        "code": "{{/helperKeyOrMethod}}",
        "description": "\n\nEnds a [can-stache.tags.section] block.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "helperKeyOrMethod",
            "description": "A name that matches the opening key, method or helper name. It's also possible to simply write `{{/}}` to end a block.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "helperKeyOrMethod",
      "description": "A name that matches the opening key, method or helper name. It's also possible to simply write `{{/}}` to end a block.\n"
    }
  },
  "can-stache.tags.comment": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/comment.md"
    },
    "body": "\n",
    "description": "A comment that doesn't get inserted into the rendered result. \n",
    "title": "{{!expression}}",
    "name": "can-stache.tags.comment",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 7,
    "signatures": [
      {
        "code": "{{!EXPRESSION}}",
        "description": "\n\nThe comment tag operates similarly to a `<!-- -->` tag in HTML. It exists in your template but never shows up.\n\n```\n{{!getFoo()}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be ignored.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be ignored.\n"
    }
  },
  "can-stache.helpers.else": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/else.md"
    },
    "body": "\n## Use\n\nFor more information on how `{{else}}` is used checkout:\n\n - [can-stache.helpers.if]\n - [can-stache.tags.section]\n\n",
    "description": "\n",
    "title": "{{else}}",
    "name": "can-stache.helpers.else",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 4,
    "signatures": [
      {
        "code": "{{#helper}}BLOCK{{else}}INVERSE{{/helper}}",
        "description": "\n\nCreates an `inverse` block for a [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "A partial stache template\nconverted into a function and set as the [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "INVERSE",
      "description": "A partial stache template\nconverted into a function and set as the [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n"
    },
    "comment": " "
  },
  "can-stache.tags.escaped": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/escaped.md"
    },
    "body": "\n\n## Use\n\nThe following breaks down the behavior of `{{expression}}`.  It groups\nthe behavior of [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s\nbecause their behavior works the same way.  It then details how [can-stache/expressions/helper]s\nwork.\n\n### Key and Call Expressions\n\n`{{key}}` insert data into the template. It most commonly references\nvalues within the current context. For example:\n\nRendering:\n\n    <h1>{{name}}</h1>\n\nWith:\n\n    {name: \"Austin\"}\n\nResults in:\n\n    <h1>Austin</h1>\n\nIf the key value is a String or Number, it is inserted into the template.\nIf it is `null` or `undefined`, nothing is added to the template.\n\n\n### Nested Properties\n\nStache supports nested paths, making it possible to\nlook up properties nested deep inside the current context. For example:\n\nRendering:\n\n    <h1>{{book.author}}</h1>\n\nWith:\n\n    {\n      book: {\n        author: \"Ernest Hemingway\"\n      }\n    }\n\nResults in:\n\n    <h1>Ernest Hemingway</h1>\n\n### Looking up values in parent contexts\n\nSections and block helpers can create their own contexts. If a key's value\nis not found in the current context, it will look up the key's value\nin parent contexts. For example:\n\nRendering:\n\n    {{#chapters}}\n       <li>{{title}} - {{name}}</li>\n    {{chapters}}\n\nWith:\n\n    {\n      title: \"The Book of Bitovi\"\n      chapters: [{name: \"Breakdown\"}]\n    }\n\nResults in:\n\n    <li>The Book of Bitovi - Breakdown</li>\n\n## Helper expressions\n\nThe `{{helper}}` syntax is used to call out to stache [can-stache.helper helper functions] functions\nthat may contain more complex functionality. `helper` is a [can-stache.key key] that must match either:\n\n - a [can-stache.registerHelper registered helper function], or\n - a function in the current or parent [can-stache.scopeAndContext contexts]\n\nThe following example shows both cases.\n\nThe Template:\n\n    <p>{{greeting}} {{user}}</p>\n\nRendered with data:\n\n    {\n      user: function(){ return \"Justin\" }\n    }\n\nAnd a with a registered helper like:\n\n    stache.registerHelper('greeting', function(){\n      return \"Hello\"\n    });\n\nResults in:\n\n    <p>Hello Justin</p>\n\n### Arguments\n\nArguments can be passed from the template to helper function by\nlisting space seperated strings, numbers or other [can-stache.key keys] after the\n`helper` name.  For example:\n\nThe template:\n\n    <p>{{madLib \"Lebron James\" verb 4}}</p>\n\nRendered with:\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements:\n\n    stache.registerHelper('madLib',\n      function(subject, verb, number, options){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n    });\n\nIf an argument `key` value is a [can-map] property, the Observe's\nproperty is converted to a getter/setter [can-compute.computed]. For example:\n\nThe template:\n\n    <p>What! My name is: {{mr user.name}}</p>\n\nRendered with:\n\n    {user: new Map({name: \"Slim Shady\"})}\n\nNeeds the helper to check if name is a function or not:\n\n    stache.registerHelper('mr',function(name){\n      return \"Mr. \"+ (typeof name === \"function\" ?\n                      name():\n                      name)\n    })\n\nThis behavior enables two way binding helpers and is explained in more detail\non the [can-stache.helper helper functions] docs.\n\n### Hash\n\nIf enumerated arguments isn't an appropriate way to configure the behavior\nof a helper, it's possible to pass a hash of key-value pairs to the\n[can-stache.helperOptions helper option argument]'s\nhash object.  Properties and values are specified\nas `hashProperty=hashValue`.  For example:\n\nThe template:\n\n    <p>My {{excuse who=pet how=\"shreded\"}}</p>\n`\nAnd the helper:\n\n    stache.registerHelper(\"excuse\",function(options){\n      return [\"My\",\n        options.hash.who || \"dog\".\n        options.hash.how || \"ate\",\n        \"my\",\n        options.hash.what || \"homework\"].join(\" \")\n    })\n\nRender with:\n\n    {pet: \"cat\"}\n\nResults in:\n\n    <p>My cat shareded my homework</p>\n\n### Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create stache tags that have rich behavior. Read about it\non the [can-stache.helper helper function] page.\n\n",
    "description": "Insert the value of the expression into the output of the template.\n\n",
    "title": "{{expression}}",
    "name": "can-stache.tags.escaped",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 0,
    "signatures": [
      {
        "code": "{{EXPRESSION}}",
        "description": "\n\nGets the value of `EXPRESSION` and inserts the result into the output of the\ntemplate.\n\nIf the expression is clearly of a particular expression type like: `{{myHelper arg}}` or\n`{{myMethod(arg)}}`, that expression's rules will be followed.\n\nAn ambiguous expression type like `{{keyOrHelper}}` will first treat `keyOrHelper`\nas a [can-stache/expressions/key-lookup] and if there is no value in the scope of\n`keyOrHelper`, it will be treated as a [can-stache/expressions/helper].\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "expression",
            "description": "The `expression` can be:\n\n - [can-stache/expressions/literal] - `{{5}}` - Inserts a string representation of the literal.\n - [can-stache/expressions/key-lookup] - `{{key}}` - Looks up the value of `key` in the [can-view-scope].\n - [can-stache/expressions/call] - `{{method()}}` - Calls `method` in the [can-view-scope].\n - [can-stache/expressions/helper] - `{{helper arg}}` - Calls `helper` in the [can-view-scope.Options] and passes it a [can-stache.helperOptions].\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "expression",
      "description": "The `expression` can be:\n\n - [can-stache/expressions/literal] - `{{5}}` - Inserts a string representation of the literal.\n - [can-stache/expressions/key-lookup] - `{{key}}` - Looks up the value of `key` in the [can-view-scope].\n - [can-stache/expressions/call] - `{{method()}}` - Calls `method` in the [can-view-scope].\n - [can-stache/expressions/helper] - `{{helper arg}}` - Calls `helper` in the [can-view-scope.Options] and passes it a [can-stache.helperOptions].\n\n\n"
    },
    "comment": " "
  },
  "can-stache.tags.inverse": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/inverse.md"
    },
    "body": "\n## Use\n\nInverted sections match falsey values. An inverted section\nsyntax is similar to regular sections except it begins with a caret\nrather than a pound. If the value referenced is falsey, the section\nwill render. For example:\n\n\nThe template:\n\n    <ul>\n        {{#friends}}\n            </li>{{name}}</li>\n        {{/friends}}\n        {{^friends}}\n            <li>No friends.</li>\n        {{/friends}}\n    </ul>\n\nAnd data:\n\n    {\n        friends: []\n    }\n\nResults in:\n\n\n    <ul>\n        <li>No friends.</li>\n    </ul>\n\n",
    "description": "Like [can-stache.tags.section], but renders the opposite subsection depending on the type of expression\nor the expression's return value.\n\n",
    "title": "{{^expression}}",
    "name": "can-stache.tags.inverse",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 5,
    "signatures": [
      {
        "code": "{{^EXPRESSION}}FN{{else}}INVERSE{{/key}}",
        "description": "\n\nWorks just like [can-stache.tags.section], but renders `INVERSE`\nwhen it would have rendered the `FN` block and vice-versa.\n\nFor example:\n\n```\n{{^ isOver18(person) }} Can't Vote {{/isOver18}}\n```\n\nRenders `Can't Vote` if `isOver18(person)` returns `falsey`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression type. Behavior depends on the type of expression:\n\n - [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s:\n   - renders `FN` with falsey values and empty lists.\n   - renders `INVERSE` with truthy values or each item in a list.\n - [can-stache/expressions/helper]s: switch the `options.fn` and `options.inverse`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression type. Behavior depends on the type of expression:\n\n - [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s:\n   - renders `FN` with falsey values and empty lists.\n   - renders `INVERSE` with truthy values or each item in a list.\n - [can-stache/expressions/helper]s: switch the `options.fn` and `options.inverse`.\n"
    },
    "comment": " "
  },
  "can-stache.tags.partial": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/partial.md"
    },
    "body": "\n\n## Use\n\nPartials are templates embedded in other templates.  Partials begin with a greater than sign, like `{{>my_partial}}`.  Partials inherit the calling scope.  \n\n\nPartials render at runtime, so recursive partials are possible but make sure you avoid infinite loops.\n\nPartials are typically registered [can-stache.registerPartial] like:\n\n```\nstache.registerPartial(\"address.stache\", \"<p>{{street}} {{city}}</p>\");\n```\n\nAnd called within another template like:\n\n```\nvar template = stache(\"{{#person.address}} {{>address.stache}} {{/person.address}}\");\n```\n\nWith data like `{person: {address: {street: \"123 Evergreen\", city: \"Chicago\"}}}`,\nrendering `template` would produce:\n\n```\n<p>123 Evergreen Chicago</p>\n```\n\nThe 2nd argument to `{{>key}}` can specify a different context for the partial to be rendered\nwith.  The following example renders the same thing as above:\n\n```\nvar template = stache(\"{{#person}} {{>address.stache address}} {{/person}}\");\n```\n\n\n\n## Functions as partials\n\n`{{>key}}` can be used to call [can-stache.renderer] functions in the scope.  For example:\n\n\n```\nDATA\n\t{\n\t\titem: {name: \"Justin\"},\n\t\tmyPartial: stache(\"{{name}}\")\n\t}\n\nTEMPLATE:\n    {{#item}}{{>myPartial}}{{/item}}\n\nRESULT:\n\tJustin\n```\n\n## Script tags as partials\n\n`{{>key}}` can be used to render the contents of script tags.\n\nFor example, if you've embedded a partial like:\n\n```\n<script type='text/stache' id='todo-stache'>\n  <li>{{name}}</li>\n</script>\n```\n\nThis can be rendered like:\n\n```\n{{#each todos}}{{>todo-stache}}{{/each}}\n```\n\n",
    "description": "\nRender another template within the current template.\n",
    "title": "{{>key}}",
    "name": "can-stache.tags.partial",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 6,
    "signatures": [
      {
        "code": "{{>key [EXPRESSION]}}",
        "description": "\n\nLooks up another template with `key` and renders it with the current scope or\n`EXPRESSION` added on top of the current scope.\n\n```js\nstache.registerPartial(\"address.stache\", \"<p>{{street}} {{city}}</p>\");\nvar template = stache(\"{{#each people}} {{>address.stache address}} {{/each}}\")\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A key used to lookup a\n[can-stache.renderer stache renderer function].   \n\nThe behavior is determined by what the key returns.  \n\nIf the key returns\na `function`, that function is used as the __renderer function__.  The __renderer function__\nis called with the current scope (or a scope modified by `EXPRESSION`) and the\nresult is inserted in place of the magic tag.\n\nIf the key returns a `string`, that string is used as the __renderer function name__.\nIf the key returns `undefined`, the key itself is used as the __renderer function name__.\n\nOnce the __renderer function name__ is known, the __renderer function__ is looked for\nby the same name.  A __renderer function__ is looked for in the following places:\n\n 1. In [can-view-scope.Options]'s `partials` property.\n 2. In partials registered with [can-stache.registerPartial].\n 3. For an element whose `id` matches __renderer function name__.  Its `innerHTML` will be converted to a template.\n\nThe __renderer function__\nis called with the current scope (or a scope modified by `EXPRESSION`) and the\nresult is inserted in place of the magic tag.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "An\noptional expression that adds a new context to the [can-view-scope] the template is\nrendered with.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "description": "An\noptional expression that adds a new context to the [can-view-scope] the template is\nrendered with.\n\n\n"
    },
    "comment": " "
  },
  "can-stache.tags.section": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/section.md"
    },
    "body": "\n\n## Use\n\nThe following breaks down the behavior of `{{#expression}}`.  It groups\nthe behavior of [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s\nbecause their behavior works the same way.  It then details how [can-stache/expressions/helper]s\nwork.\n\n\n## KeyLookup and Call expressions\n\nSections contain text blocks and evaluate whether to render it or not.  If\nthe object evaluates to an array it will iterate over it and render the block\nfor each item in the array.  There are four different types of sections.\n\n### Falseys or Empty Arrays\n\nIf the value returns a `false`, `undefined`, `null`, `\"\"` or `[]` we consider\nthat a *falsey* value.\n\nIf the value is falsey, the section will **NOT** render the block.\n\n    {\n      friends: false\n    }\n\n    {{#friends}}\n      Never shown!\n    {{/friends}}\n\n\n### Arrays\n\nIf the value is a non-empty array, sections will iterate over the\narray of items, rendering the items in the block.\n\nFor example, a list of friends will iterate\nover each of those items within a section.\n\n    {\n        friends: [\n            { name: \"Austin\" },\n            { name: \"Justin\" }\n        ]\n    }\n\n    <ul>\n        {{#friends}}\n            <li>{{name}}</li>\n        {{/friends}}\n    </ul>\n\nwould render:\n\n    <ul>\n        <li>Austin</li>\n        <li>Justin</li>\n    </ul>\n\nReminder: Sections will reset the current context to the value for which it is iterating.\nSee the [basics of contexts](#Basics) for more information.\n\n### Truthys\n\nWhen the value is a non-falsey object but not a list, it is considered truthy and will be used\nas the context for a single rendering of the block.\n\n    {\n        friends: { name: \"Jon\" }\n    }\n\n    {{#friends}}\n        Hi {{name}}\n    {{/friends}}\n\nwould render:\n\n    Hi Jon!\n\n## Helper expression\n\n\nA helper like:\n\n```js\nstache.registerHelper('countTo', function(number, options){\n    var out = [];\n    if(number > 0) {\n        for(var i =1; i <= number; i++){\n          var docFrag = options.fn({num: i});\n          out.push( docFrag );\n        }\n        return out;\n    } else {\n        return options.inverse({num: i});\n    }\n});\n```\n\nCould be called like:\n\n```\n<p>\n  {{#countTo number}}\n    {{num}}\n  {{else}}\n    Can't count to {{num}}!\n  {{/countTo}}\n</p>\n```\n\nCalled with data like:\n\n```js\n{number: 3}\n```\n\nProduces:\n\n```\n<p> 1 2 3 </p>\n```\n\nCalled with data like:\n\n```\n{number: -5}\n```\n\nProduces:\n\n```\n<p> Can't count to -5! </p>\n```\n\nNotice how `options` has `.fn` and `.inverse`.\n\n",
    "description": "\nRenders a subsection one or more times depending on the type of expression\nor the expression's return value.\n",
    "title": "{{#expression}}",
    "name": "can-stache.tags.section",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 3,
    "signatures": [
      {
        "code": "{{#KEY_EXPRESSION}}FN{{else}}INVERSE{{/KEY_EXPRESSION}}",
        "description": "\n\nRenders the `FN` or `INVERSE` section one or many times depending on\nthe value in `KEY_EXPRESSION`.\n\nIf `KEY_EXPRESSION` returns an  [can-util/js/is-array-like/is-array-like array like object],\nthe `FN` section will be rendered for each item in the array.  If the array like object is\nempty, the `INVERSE` section will be rendered. The [can-stache.helpers.each] helper\nshould generally be used for observable array-like objects as it has some performance\nadvantages.  \n\n```\n{{#items}}<li>{{name}}</li>{{/items}}\n```\n\nIf `KEY_EXPRESSION` returns a truthy value, the `FN` section will be rendered with\nthe truthy value.\n\nIf `KEY_EXPRESSION` returns a fasley value, the `INVERSE` section will be rendered with\nthe fasley value.\n\n```\n{{#address}} {{street}} {{city}} {{/address}}\n```\n\nThe closing tag can end with `{{/}}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              }
            ],
            "name": "KEY_EXPRESSION",
            "description": "A key expression.\nIf there is no value in the scope of `keyOrHelper`, it will be treated as a [can-stache/expressions/helper]."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n\n"
          }
        ]
      },
      {
        "code": "{{#CALL_EXPRESSION}}FN{{else}}INVERSE{{/CALL_EXPRESSION}}",
        "description": "\n\nWorks like `{{#KEY_EXPRESSION}}`, but uses the return value of\nthe `CALL_EXPRESSION`.\n\n```\n{{#getTasksForPerson(person)}}<li>{{name}}</li>{{/getTasksForPerson}}\n```\n\nTypically, the closing tag only include the method name and not its parameters.\n\nThe closing tag can end with `{{/}}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A function that\nwill be called with any specified arguments."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n\n"
          }
        ]
      },
      {
        "code": "{{#HELPER_EXPRESSION}}FN{{else}}INVERSE{{/HELPER_EXPRESSION}}",
        "description": "\n\nCalls a [can-stache.registerHelper registered helper] or a function in the\n[can-view-scope] with an additional [can-stache.helperOptions] argument\nthat can call the `FN` or `INVERSE` helpers to build the content that\nshould replace these tags.\n\n```\n<p>{{#countTo number}}{{num}}{{/countTo}}</p>\n```\n\nHelpers, with their direct access to subsection renderers and scope\nhave more control over template flow.  However, they are harder to test\nthan methods in the view model or model.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "HELPER_EXPRESSION",
            "description": "Calls a helper method\nor function in the [can-view-scope] with specified arguments."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "INVERSE",
      "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n"
    },
    "comment": " "
  },
  "can-stache.tags.unescaped": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/unescaped.md"
    },
    "body": "\n",
    "description": "Insert the unescaped value of the expression into the output of the template.\n\n",
    "title": "{{{expression}}}",
    "name": "can-stache.tags.unescaped",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 1,
    "signatures": [
      {
        "code": "{{{EXPRESSION}}}",
        "description": "\n\nBehaves just like [can-stache.tags.escaped] but does not\nescape the result.\n\n```js\n<div> {{{ toMarkdown(content) }}} </div>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression whose unescaped result is inserted into the page.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression whose unescaped result is inserted into the page.\n"
    }
  },
  "can-stache.tags.unescaped2": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/unescaped_amp.md"
    },
    "body": "",
    "description": "Insert the unescaped value of the expression into the output of the template.\n\n",
    "title": "{{&key}}",
    "name": "can-stache.tags.unescaped2",
    "type": "function",
    "hide": true,
    "parent": "can-stache.tags",
    "order": 2,
    "signatures": [
      {
        "code": "{{&key}}",
        "description": "\n\nThe `{{&key}}` tag is an alias for [can-stache.tags.unescaped {{{key}}}].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            },
            {
              "type": "*"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        },
        {
          "type": "*"
        }
      ],
      "description": "\n"
    }
  },
  "can-util/dom/ajax/ajax": {
    "name": "can-util/dom/ajax/ajax",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 8,
      "codeLine": 43,
      "path": "node_modules/can-util/dom/ajax/ajax.js"
    },
    "body": "\n",
    "description": "\nMake an asynchronous HTTP (AJAX) request.\n",
    "title": "ajax",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "ajax( ajaxOptions )",
        "description": "\n\n   Is used to make an asynchronous HTTP (AJAX) request similar to [http://api.jquery.com/jQuery.ajax/jQuery.ajax].\n\n   ```\n   var ajax = require(\"can-util/dom/ajax/ajax\");\n\n   ajax({\n     url: \"http://query.yahooapis.com/v1/public/yql\",\n     data: {\n       format: \"json\",\n       q: 'select * from geo.places where text=\"sunnyvale, ca\"'\n     }\n   }).then(function(response){\n     console.log( response.query.count ); // => 2\n   });\n   ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "ajaxOptions",
            "description": "Configuration options for the AJAX request.\n  - __url__ `{String}` The requested url.\n  - __type__ `{String}` The method of the request. Ex: `GET`, `PUT`, `POST`, etc. Capitalization is ignored. _Default is `GET`_.\n  - __data__ `{Object}` The data of the request. If data needs to be urlencoded (e.g. for GET requests or for CORS) it is serialized with [can-util/js/param].\n  - __dataType__ `{String}` Type of data. _Default is `json`_.\n  - __crossDomain__ `{Boolean}` If you wish to force a crossDomain request (such as JSONP) on the same domain, set the value of crossDomain to true. This allows, for example, server-side redirection to another domain. Default: `false` for same-domain requests, `true` for cross-domain requests.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that resolves to the data. The Promise instance is abortable and exposes an `abort` method. Invoking abort on the Promise instance indirectly rejects it.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "ajaxOptions",
      "description": "Configuration options for the AJAX request.\n  - __url__ `{String}` The requested url.\n  - __type__ `{String}` The method of the request. Ex: `GET`, `PUT`, `POST`, etc. Capitalization is ignored. _Default is `GET`_.\n  - __data__ `{Object}` The data of the request. If data needs to be urlencoded (e.g. for GET requests or for CORS) it is serialized with [can-util/js/param].\n  - __dataType__ `{String}` Type of data. _Default is `json`_.\n  - __crossDomain__ `{Boolean}` If you wish to force a crossDomain request (such as JSONP) on the same domain, set the value of crossDomain to true. This allows, for example, server-side redirection to another domain. Default: `false` for same-domain requests, `true` for cross-domain requests.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that resolves to the data. The Promise instance is abortable and exposes an `abort` method. Invoking abort on the Promise instance indirectly rejects it.\n\n"
    }
  },
  "can-util/dom/attr/attr.special.focused": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr-special.focused.md"
    },
    "body": "\n```js\ndomAttr.get(input, \"focused\"); // -> false\n\ndomAttr.set(input, \"focused\", true);\ndomAttr.get(input, \"focused\"); // -> true\n```\n\n\n## One-way binding to set focus\n\nUse `focused` in event bindings to have a way to set focus to an input. In this example we are one-way binding to `focused` to a function that will recompute:\n\n```handlebars\n<input type=\"text\" {$focused}=\"isEditing()\" />\n\n<button></button>\n```\n\n```js\nvar ViewModel = DefineMap.extend({\n\tediting: {\n\t\tvalue: false\n\t},\n\tisEditing: function(){\n\t\treturn this.editing;\n\t}\n});\n\n...\n```\n\nIn this example whenever the `editing` property changes to `true`, `isEditing` will be reevaluated to `true` when will set focus on the input. You can imagine there might be some other use, such as a button, that triggers the editing status to change.\n\n## Two-way binding to focused\n\nAnother scenario is that you would like to know when an element is focused, perhaps to show a message (such as a tooltip) somewhere else in the DOM. The example below two-way binds to a boolean property on the ViewModel. When focus is set, the property is updated.\n\n<div class='demo_wrapper' data-demo-src='demos/can-util/input-focused.html'></div>\n\n",
    "description": "\nSignifies if an element, usually an `<input>` is the focused element on the page.\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "focused",
    "name": "can-util/dom/attr/attr.special.focused",
    "type": "property",
    "parent": "can-util/dom/attr/attr.special",
    "comment": " "
  },
  "can-util/dom/attr/attr.special": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr-special.md"
    },
    "body": "\n```js\nattr.special.foo = {\n\tget: function(){\n\t\treturn this.foo;\n\t},\n\tset: function(val){\n\t\tthis.foo = val;\n\t},\n\taddEventListener: function(){\n\t\t// Listen to this property changing some how\n\t}\n};\n```\n\nCanJS comes with a couple of special properties that can be used in bindings:\n\n* [can-util/dom/attr/attr.special.values]\n* [can-util/dom/attr/attr.special.focused]\n\n",
    "description": "\nAn object used to set up special properties. Each key on `attr.special` is a name of a property/attribute that has special behaviors when being get, set, or bound to.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "special",
    "name": "can-util/dom/attr/attr.special",
    "type": "property",
    "parent": "can-util/dom/attr/attr"
  },
  "can-util/dom/attr/attr": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr.md"
    },
    "body": "\n",
    "description": "\nA module that makes it easy to access attributes and properties of elements.\n",
    "type": "module",
    "title": "attr",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-util/dom/attr/attr",
    "parent": "can-util/dom"
  },
  "can-util/dom/attr/attr.special.values": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr.special.values.md"
    },
    "body": "\n\nBinding to `values` in your [can-stache] template is useful to get a list of the selected values:\n\n```handlebars\n<select multiple {($values)}=\"colors\">\n\t<option value=\"red\">Red</option>\n\t<option value=\"green\">Green</option>\n\t<option value=\"blue\">Blue</option>\n</select>\n```\n\nThis will two-way bind to a \"colors\" property in the ViewModel.\n\n",
    "description": "\nA special property that represents the selected values in a `<select>` element, usually a `<select multiple>`. The special property is needed because the DOM's native `value` property on a multiple select only gives you one of the selected options' values.\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "values",
    "name": "can-util/dom/attr/attr.special.values",
    "type": "property",
    "parent": "can-util/dom/attr/attr.special",
    "comment": " "
  },
  "can-util/dom/child-nodes/child-nodes": {
    "type": "module",
    "name": "can-util/dom/child-nodes/child-nodes",
    "parent": "can-util/dom",
    "src": {
      "line": 2,
      "codeLine": 22,
      "path": "node_modules/can-util/dom/child-nodes/child-nodes.js"
    },
    "body": "",
    "description": "",
    "title": "child-nodes",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "childNodes(node)",
        "description": "\n\nGet all of the childNodes of a given node.\n\n```js\nvar stache = require(\"can-stache\");\nvar childNodes = require(\"can-util/child-nodes/child-nodes\");\n\nvar html = \"<div><h1><span></span></h1></div>\";\nvar frag = stache(html)();\n\nconsole.log(childNodes(frag)[0].nodeName); // -> DIV\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "node",
            "description": "The Node that you want child nodes for.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "node",
      "description": "The Node that you want child nodes for.\n"
    }
  },
  "can-util/dom/class-name/class-name": {
    "name": "can-util/dom/class-name/class-name",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 12,
      "codeLine": 25,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "Allows querying and manipulation of classes on HTML elements \n```js\nvar className = require(\"can-util/dom/class-name/class-name\");\n\nvar fooDiv = document.createElement(\"div\");\nclassName.add(fooDiv, \"foo\");\nfooDiv.outerHTML; //-> '<div class=\"foo\"></div>'\n```\n\n",
    "title": "class-name",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/class-name/class-name.has": {
    "name": "can-util/dom/class-name/class-name.has",
    "type": "function",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 26,
      "codeLine": 43,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.has",
    "signatures": [
      {
        "code": "className.has.call(el, cls)",
        "description": "\n\nDetermine wheter a DOM node has a given class name.\n\n```js\nvar className = require(\"can-util/dom/class-name/class-name\");\n\nvar isContainer = className.has.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "true if the element's class attribute contains the token, false otherwise.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "true if the element's class attribute contains the token, false otherwise.\n "
    }
  },
  "can-util/dom/class-name/class-name.add": {
    "type": "function",
    "name": "can-util/dom/class-name/class-name.add",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 44,
      "codeLine": 61,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.add",
    "signatures": [
      {
        "code": "className.add.call(el, cls)",
        "description": "\n\nAdd a class name to a DOM node if it is not already there.\n\n```js\nvar className = require(\"can-util/dom/class-name/class-name\");\n\nclassName.add.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "void"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "void"
        }
      ],
      "description": "\n "
    }
  },
  "can-util/dom/class-name/class-name.remove": {
    "type": "function",
    "name": "can-util/dom/class-name/class-name.remove",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 69,
      "codeLine": 86,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.remove",
    "signatures": [
      {
        "code": "className.remove.call(el, cls)",
        "description": "\n\nRemove a class name from a DOM node if it exists on the node\n\n```js\nvar className = require(\"can-util/dom/class-name/class-name\");\n\nclassName.remove.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "void"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "void"
        }
      ],
      "description": "\n "
    }
  },
  "can-util/dom/data/data": {
    "name": "can-util/dom/data/data",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 22,
      "codeLine": 32,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "Allows associating data as a key/value pair for a particular DOM Node.\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n```\n\n",
    "title": "data",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/data/data.getCid": {
    "name": "can-util/dom/data/data.getCid",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 33,
      "codeLine": 40,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.getCid",
    "signatures": [
      {
        "code": "domData.getCid.call(el)",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The value of the element's unique CID\n\nReturn the previously set unique identifier for the dom node.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The value of the element's unique CID\n\nReturn the previously set unique identifier for the dom node.\n "
    }
  },
  "can-util/dom/data/data.cid": {
    "name": "can-util/dom/data/data.cid",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 41,
      "codeLine": 55,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "\nIf a unique cid value has not yet been set for this element, set it\nusing the [can-util/dom/data/data.expando expando] property.  Return the\nunique cid whether or not it is newly set\n \n",
    "description": "",
    "title": "domData.cid",
    "signatures": [
      {
        "code": "domData.cid.call(el)",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The value of the element's unique CID\n\nSet a unique identifier for the dom node, using the\n[can-util/dom/data/data.expando expando] property.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The value of the element's unique CID\n\nSet a unique identifier for the dom node, using the\n[can-util/dom/data/data.expando expando] property.\n"
    },
    "comment": " "
  },
  "can-util/dom/data/data.expando": {
    "name": "can-util/dom/data/data.expando",
    "type": "property",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 56,
      "codeLine": 62,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": " \n",
    "description": "\nThe key in which elements' cids are stored\n",
    "types": [],
    "title": "domData.expando"
  },
  "can-util/dom/data/data.clean": {
    "name": "can-util/dom/data/data.clean",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 63,
      "codeLine": 76,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.clean",
    "signatures": [
      {
        "code": "domData.clean.call(el, key)",
        "description": "\n\nRemove data from an element previously added by [can-util/dom/data/data.set set]\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n\ndomData.clean.call(el, \"metadata\");\n```\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/data/data.get": {
    "name": "can-util/dom/data/data.get",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 77,
      "codeLine": 91,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.get",
    "signatures": [
      {
        "code": "domData.get.call(el, key)",
        "description": "\n\nGet data that was stored in a DOM Node using the specified `key`.\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n\nvar metadata = domData.get.call(el, \"metadata\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A string used as a unique key for storing data associated with this DOM Node.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A string used as a unique key for storing data associated with this DOM Node.\n "
    }
  },
  "can-util/dom/data/data.set": {
    "type": "function",
    "name": "can-util/dom/data/data.set",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 92,
      "codeLine": 109,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.set",
    "signatures": [
      {
        "code": "domData.set.call(el, name, value)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "the key to store the value under"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "the value to store under the key\n\nSet data to be associated with a DOM Node using the specified `key`. If data already exists for this key, it will be overwritten.\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n\ndomData.set.call(el, \"metadata\", {\n  foo: \"bar\"\n});\n```\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "the value to store under the key\n\nSet data to be associated with a DOM Node using the specified `key`. If data already exists for this key, it will be overwritten.\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n\ndomData.set.call(el, \"metadata\", {\n  foo: \"bar\"\n});\n```\n "
    }
  },
  "can-util/dom/data/data.delete": {
    "name": "can-util/dom/data/data.delete",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 118,
      "codeLine": 130,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.delete",
    "signatures": [
      {
        "code": "domData.delete.call(el)",
        "description": "\n\nRemove all data for an element previously added by [can-util/dom/data/data.set set]\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n\ndomData.delete.call(el);\n```\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/dispatch/dispatch": {
    "type": "module",
    "name": "can-util/dom/dispatch/dispatch",
    "parent": "can-util/dom",
    "src": {
      "line": 4,
      "codeLine": 16,
      "path": "node_modules/can-util/dom/dispatch/dispatch.js"
    },
    "body": "",
    "description": "",
    "title": "dispatch",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "dispatch.call(el, event, args, bubbles)",
        "description": "\n\nDispatch an event on an element.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "An object specifies options applied to this event."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Arguments passed into this event."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "bubbles",
            "defaultValue": "true",
            "description": "Specifies whether this event should bubble (by default it will).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "bubbles",
      "defaultValue": "true",
      "description": "Specifies whether this event should bubble (by default it will).\n"
    }
  },
  "can-util/dom/document/document": {
    "src": {
      "line": 4,
      "codeLine": 24,
      "path": "node_modules/can-util/dom/document/document.js"
    },
    "type": "module",
    "body": "",
    "description": "",
    "title": "document",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/dom/document/document",
    "parent": "can-util/dom",
    "signatures": [
      {
        "code": "document(document)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "document",
            "description": "An optional document-like object \nto set as the context's document\n\nOptionally sets, and returns, the document object for the context.\n\n```js\nvar documentShim = { getElementById() {...} };\nvar domDocument = require(\"can-util/dom/document/document\");\ndomDocument(documentShim);\n\n...\n\ndomDocument().getElementById(\"foo\");\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "document",
      "description": "An optional document-like object \nto set as the context's document\n\nOptionally sets, and returns, the document object for the context.\n\n```js\nvar documentShim = { getElementById() {...} };\nvar domDocument = require(\"can-util/dom/document/document\");\ndomDocument(documentShim);\n\n...\n\ndomDocument().getElementById(\"foo\");\n```\n"
    }
  },
  "can-util/dom/events/events": {
    "name": "can-util/dom/events/events",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 12,
      "codeLine": 21,
      "path": "node_modules/can-util/dom/events/events.js"
    },
    "body": "",
    "description": "Allows you to listen to a domEvent and special domEvents as well as dispatch domEvents. \n```js\nvar domEvents = require(\"can-util/dom/events/events\");\n```\n\n",
    "title": "events",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/frag/frag": {
    "type": "module",
    "name": "can-util/dom/frag/frag",
    "parent": "can-util/dom",
    "src": {
      "line": 7,
      "codeLine": 40,
      "path": "node_modules/can-util/dom/frag/frag.js"
    },
    "body": "\n\n## Use\n\nContentArrays can be used to combine multiple HTMLElements into a single document fragment.  For example:\n\n    var frag = require(\"can-util/dom/frag/frag\");\n\n    var p = document.createElement(\"p\");\n    p.innerHTML = \"Welcome to <b>CanJS</b>\";\n    var contentArray = [\"<h1>Hi There</h1>\", p];\n    var fragment = frag( contentArray )\n\n`fragment` will be a documentFragment with the following elements:\n\n    <h1>Hi There</h1>\n    <p>Welcome to <b>CanJS</b></p>\n\n \n",
    "description": "\nConvert a String, HTMLElement, documentFragment, or contentArray into a documentFragment.\n",
    "title": "frag",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "frag: function(item, doc)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "HTMLElement"
              },
              {
                "type": "documentFragment"
              },
              {
                "type": "contentArray"
              }
            ],
            "name": "item",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Document"
              }
            ],
            "name": "doc",
            "description": "an optional DOM document in which to build the fragment\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Document"
        }
      ],
      "name": "doc",
      "description": "an optional DOM document in which to build the fragment\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-util/dom/location/location": {
    "src": {
      "line": 4,
      "codeLine": 23,
      "path": "node_modules/can-util/dom/location/location.js"
    },
    "type": "module",
    "body": "",
    "description": "",
    "title": "location",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/dom/location/location",
    "parent": "can-util/dom",
    "signatures": [
      {
        "code": "location(location)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "location",
            "description": "An optional location-like object\nto set as the context's location\n\nOptionally sets, and returns, the location object for the context.\n\n```js\nvar locationShim = { path: '/' };\nvar LOCATION = require(\"can-util/dom/location/location\");\nLOCATION(locationShim);\n\n...\nLOCATION().path; // -> '/'\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "location",
      "description": "An optional location-like object\nto set as the context's location\n\nOptionally sets, and returns, the location object for the context.\n\n```js\nvar locationShim = { path: '/' };\nvar LOCATION = require(\"can-util/dom/location/location\");\nLOCATION(locationShim);\n\n...\nLOCATION().path; // -> '/'\n```\n"
    }
  },
  "can-util/dom/mutate/mutate": {
    "name": "can-util/dom/mutate/mutate",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 96,
      "codeLine": 113,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "Mutate an element by appending, inserting, and removing DOM nodes. Use this so that on the server \"inserted\" will be fired. \n```js\nvar mutate = require(\"can-util/dom/mutate/mutate\");\n\nvar el = document.createElement(\"div\");\n\nel.addEventListener(\"inserted\", function(){\n  console.log(\"Inserted was fired!\");\n});\n\nmutate.appendChild.call(document.body, el);\n```\n\n",
    "title": "mutate",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.appendChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.appendChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 114,
      "codeLine": 119,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "appendChild",
    "signatures": [
      {
        "code": "mutate.appendChild.call(el, child)",
        "description": "\nUsed to append a node to an element and trigger the \"inserted\" event on all of the newly inserted children. Since `mutated` takes an array we convert the child to an array, or in the case of a DocumentFragment we first convert the childNodes to an array and call inserted on those.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.insertBefore": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.insertBefore",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 133,
      "codeLine": 138,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "insertBefore",
    "signatures": [
      {
        "code": "mutate.insertBefore.call(el, ref, child)",
        "description": "\nLike mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"inserted\" event.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.removeChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.removeChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 152,
      "codeLine": 157,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "removeChild",
    "signatures": [
      {
        "code": "mutate.removeChild.call(el, child)",
        "description": "\nLike mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"removed\" event.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.replaceChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.replaceChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 165,
      "codeLine": 170,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "replaceChild",
    "signatures": [
      {
        "code": "mutate.replaceChild.call(el, child)",
        "description": "\nLike mutate.appendChild and mutate.removeChild, used to replace a node with another node and trigger \"removed\" on the removed element and \"inserted\" on the inserted elements.\n ",
        "params": []
      }
    ]
  },
  "can-util/js/assign/assign": {
    "type": "module",
    "name": "can-util/js/assign/assign",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 24,
      "path": "node_modules/can-util/js/assign/assign.js"
    },
    "body": "",
    "description": "",
    "title": "assign",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "assign(target, source)",
        "description": "\n\nA simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.\n\n```js\nvar assign = require(\"can-util/js/assign/assign\");\n\nvar obj = {};\n\nassign(obj, {\n  foo: \"bar\"\n});\n\nconsole.log(obj.foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The destination object. This object's properties will be mutated based on the object provided as `source`."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "The source object whose own properties will be applied to `target`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the `target` argument.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "The source object whose own properties will be applied to `target`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the `target` argument.\n"
    }
  },
  "can-util/js/base-url/base-url": {
    "src": {
      "line": 5,
      "codeLine": 25,
      "path": "node_modules/can-util/js/base-url/base-url.js"
    },
    "type": "module",
    "body": "",
    "description": "",
    "title": "base-url",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/base-url/base-url",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "baseUrl(optionalBaseUrlToSet)",
        "description": "\n\nGet and/or set the \"base\" (containing path) of the document.\n\n```js\nvar baseUrl = require(\"can-util/js/base-url/base-url\");\n\nconsole.log(baseUrl());           // -> \"http://localhost:8080\"\nconsole.log(baseUrl(baseUrl() + \"/foo/bar\")); // -> \"http://localhost:8080/foo/bar\"\nconsole.log(baseUrl());           // -> \"http://localhost:8080/foo/bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "setUrl",
            "description": "An optional base url to override reading the base URL from the known path.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the set or computed base URL\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "setUrl",
      "description": "An optional base url to override reading the base URL from the known path.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the set or computed base URL\n"
    }
  },
  "can-util/js/cid/cid": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/cid/cid.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-cid] instead. \n",
    "title": "cid",
    "name": "can-util/js/cid/cid",
    "parent": "can-util/js"
  },
  "can-util/js/cid-map/cid-map": {
    "src": {
      "path": "node_modules/can-util/js/cid-map/cid-map.md"
    },
    "body": "\n\n## Use\n\nThis module exports the native [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\nobject if `Map` is present.  If not, a `Map`-like constructor function is exported that supports `O(1)` insertion and\ndeletion by adding a [can-cid] property to objects passed to `.set`.\n\n```js\nvar Map = require(\"can-util/js/cid-map/cid-map\");\n\nvar map = new Map();\n\nvar obj = {};\n\nmap.set(obj, \"value\");\nmap.get(obj) //-> \"value\";\n```\n\nThe following methods and properties are supported by the polyfill:\n\n- `clear()`\n- `delete(key)`\n- `forEach(callback[,thisArg])`\n- `get(key)`\n- `has(key)`\n- `set(key, value)`\n- `size`\n\n",
    "description": "\nExports the native [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\nor a polyfill.\n",
    "type": "module",
    "title": "cid-map",
    "types": [
      {
        "type": "Map"
      }
    ],
    "name": "can-util/js/cid-map/cid-map",
    "parent": "can-util/js",
    "comment": " "
  },
  "can-util/js/cid-set/cid-set": {
    "src": {
      "path": "node_modules/can-util/js/cid-set/cid-set.md"
    },
    "body": "\n\n## Use\n\nThis module exports the native [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\nobject if `Set` is present.  If not, a `Set`-like constructor function is exported that supports `O(1)` insertion and\ndeletion by adding a [can-cid] property to objects passed to `.set`.\n\n```js\nvar Set = require(\"can-util/js/cid-set/cid-set\");\n\nvar map = new set();\n\nvar obj = {};\n\nmap.add(obj);\nmap.has(obj) //-> true;\n```\n\nThe following methods and properties are supported by the polyfill:\n\n- `clear()`\n- `delete(value)`\n- `forEach(callback[,thisArg])`\n- `get(value)`\n- `has(value)`\n- `add(value)`\n- `size`\n\n",
    "description": "\nExports the native [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\nor a polyfill.\n",
    "type": "module",
    "title": "cid-set",
    "types": [
      {
        "type": "Map"
      }
    ],
    "name": "can-util/js/cid-set/cid-set",
    "parent": "can-util/js",
    "comment": " "
  },
  "can-util/js/deep-assign/deep-assign": {
    "src": {
      "path": "node_modules/can-util/js/deep-assign/deep-assign.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "deep-assign",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/deep-assign/deep-assign",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "deepAssign(target, [ ... sources ])",
        "description": "\n\nAssign properties from a source object to a target object, deeply copying properties that are objects or arrays.\n\n```js\nvar deepAssign = require(\"can-util/js/deep-assign/deep-assign\");\n\nvar dest = deepAssign({}, {\n  obj: {\n\t\tfoo: \"bar\"\n\t}\n}, {\n  arr: [{ hello: \"world\" }]\n});\n\nconsole.log(dest.obj.foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The target object who's properties will be assigned from the source objects."
          },
          {
            "variable": true,
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "Source objects from which properties will be assigned to the `target` object. Sources will be copied deeply; meaning any object or array properties will be traversed and copied (like a clone).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "variable": true,
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "Source objects from which properties will be assigned to the `target` object. Sources will be copied deeply; meaning any object or array properties will be traversed and copied (like a clone).\n"
    }
  },
  "can-util/js/defaults/defaults": {
    "type": "module",
    "name": "can-util/js/defaults/defaults",
    "parent": "can-util/js",
    "src": {
      "line": 3,
      "codeLine": 28,
      "path": "node_modules/can-util/js/defaults/defaults.js"
    },
    "body": "",
    "description": "",
    "title": "defaults",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "defaults(target, [ ... sources])",
        "description": "\n\nMimics [_.defaults](https://lodash.com/docs/4.16.2#defaults). Assigns first level properties in sources from left to\nright if they are not already defined.\n\n```js\nvar defaults = require(\"can-util/js/defaults/defaults\");\n\nvar obj = {a: 1, b: 2};\nvar src = {b: 3, c: 3};\n\nassign(obj, src, {a: 2, d: 4});\n\nconsole.log(obj); // -> {a: 1, b: 2, c: 3, d: 4}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The destination object. This object's properties will be mutated based on the objects provided as [ ... sources]."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "variable": true,
            "name": "sources",
            "description": "The source objects whose own properties will be applied to `target`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the `target` argument.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "variable": true,
      "name": "sources",
      "description": "The source objects whose own properties will be applied to `target`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the `target` argument.\n"
    }
  },
  "can-util/js/deparam/deparam": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/deparam/deparam.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-deparam] instead. \n",
    "title": "deparam",
    "name": "can-util/js/deparam/deparam",
    "parent": "can-util/js"
  },
  "can-util/js/diff/diff": {
    "name": "can-util/js/diff/diff",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 9,
      "codeLine": 42,
      "path": "node_modules/can-util/js/diff/diff.js"
    },
    "body": "",
    "description": "",
    "title": "diff",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "diff( oldList, newList, [identity] )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "oldList",
            "description": "the array to diff from"
          },
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "newList",
            "description": "the array to diff to"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "identity",
            "description": "an optional identity function for comparing elements"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a list of Patch objects representing the differences\n\nReturns the difference between two ArrayLike objects (that have nonnegative\ninteger keys and the `length` property) as an array of patch objects.\n\nA patch object returned by this function has the following properties:\n- **index**:  the index of newList where the patch begins\n- **deleteCount**: the number of items deleted from that index in newList\n- **insert**: an Array of items newly inserted at that index in newList\n\n```js\nvar diff = require(\"can-util/js/diff/diff\");\n\nconsole.log(diff([1], [1, 2])); // -> [{index: 1, deleteCount: 0, insert: [2]}]\nconsole.log(diff([1, 2], [1])); // -> [{index: 1, deleteCount: 1, insert: []}]\n\n// with an optional identity function:\ndiff(\n    [{id:1},{id:2}],\n    [{id:1},{id:3}],\n    (a,b) => a.id === b.id\n); // -> [{index: 1, deleteCount: 1, insert: [{id:3}]}]\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "identity",
      "description": "an optional identity function for comparing elements"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a list of Patch objects representing the differences\n\nReturns the difference between two ArrayLike objects (that have nonnegative\ninteger keys and the `length` property) as an array of patch objects.\n\nA patch object returned by this function has the following properties:\n- **index**:  the index of newList where the patch begins\n- **deleteCount**: the number of items deleted from that index in newList\n- **insert**: an Array of items newly inserted at that index in newList\n\n```js\nvar diff = require(\"can-util/js/diff/diff\");\n\nconsole.log(diff([1], [1, 2])); // -> [{index: 1, deleteCount: 0, insert: [2]}]\nconsole.log(diff([1, 2], [1])); // -> [{index: 1, deleteCount: 1, insert: []}]\n\n// with an optional identity function:\ndiff(\n    [{id:1},{id:2}],\n    [{id:1},{id:3}],\n    (a,b) => a.id === b.id\n); // -> [{index: 1, deleteCount: 1, insert: [{id:3}]}]\n```\n"
    }
  },
  "can-util/js/dev/dev": {
    "name": "can-util/js/dev/dev",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 12,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "body": "\n",
    "description": "\nUtilities for logging development-mode messages. Use this module for\nanything that should be shown to the user during development but isn't\nneeded in production. In production these functions become noops.\n",
    "title": "dev",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/js/dev/dev.stringify": {
    "type": "function",
    "name": "can-util/js/dev/dev.stringify",
    "parent": "can-util/js/dev/dev",
    "src": {
      "line": 15,
      "codeLine": 34,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "body": "",
    "description": " \nJSON stringifies a value, but unlike JSON, will output properties with\na value of `undefined` (e.g. `{ \"prop\": undefined }`, not `{}`).\n\n```\nvar dev = require('can-util/js/dev/dev');\nvar query = { where: undefined };\n\ndev.warn('No records found: ' + dev.stringify(query));\n```\n\n",
    "title": "stringify",
    "signatures": [
      {
        "code": "dev.stringify(value)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Any"
              }
            ],
            "name": "value",
            "description": "A value to stringify."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A stringified representation of the passed in value.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Any"
        }
      ],
      "name": "value",
      "description": "A value to stringify."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A stringified representation of the passed in value.\n "
    }
  },
  "can-util/js/dev/dev.warn": {
    "type": "function",
    "name": "can-util/js/dev/dev.warn",
    "parent": "can-util/js/dev/dev",
    "src": {
      "line": 43,
      "codeLine": 59,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "body": "",
    "description": " \nAdds a warning message to the console.\n\n```\nvar dev = require('can-util/js/dev/dev');\n\ndev.warn(\"something evil\");\n```\n\n",
    "title": "warn",
    "signatures": [
      {
        "code": "dev.warn(msg)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "msg",
            "description": "The warning message.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "msg",
      "description": "The warning message.\n "
    }
  },
  "can-util/js/dev/dev.log": {
    "type": "function",
    "name": "can-util/js/dev/dev.log",
    "parent": "can-util/js/dev/dev",
    "src": {
      "line": 64,
      "codeLine": 80,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "body": "",
    "description": " \nAdds a message to the console.\n\n```\nvar dev = require('can-util/js/dev/dev');\n\ndev.log(\"hi\");\n```\n\n",
    "title": "log",
    "signatures": [
      {
        "code": "dev.log(msg)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "msg",
            "description": "The message.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "msg",
      "description": "The message.\n "
    }
  },
  "can-util/js/dev/dev.error": {
    "type": "function",
    "name": "can-util/js/dev/dev.error",
    "parent": "can-util/js/dev/dev",
    "src": {
      "line": 85,
      "codeLine": 101,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "body": "",
    "description": " \nAdds an error message to the console.\n\n```\nvar dev = require(\"can-util/js/dev/dev\");\n\ndev.error(new Error(\"Oh no!\"));\n```\n\n",
    "title": "error",
    "signatures": [
      {
        "code": "dev.error(err)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Error"
              }
            ],
            "name": "err",
            "description": "The error to be logged.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Error"
        }
      ],
      "name": "err",
      "description": "The error to be logged.\n "
    }
  },
  "can-util/js/diff-object/diff-object": {
    "type": "module",
    "name": "can-util/js/diff-object/diff-object",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 30,
      "path": "node_modules/can-util/js/diff-object/diff-object.js"
    },
    "body": "",
    "description": "",
    "title": "diff-object",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "diffObject(oldObject, newObject)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "oldObject",
            "description": "the object to diff from"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "newObject",
            "description": "the object to diff to"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "an array of object-patch objects\n\nFind the differences between two objects, based on properties and values\n\nThe object-patch object format has the following keys:\n- **property**: the property key on the new object\n- **type**:     the type of operation on this property: add, remove, or set\n- **value**:    the new value (if type is \"add\" or \"set\")\n\n```js\nvar diffObject = require(\"can-util/js/diff-object/diff-object\");\n\nconsole.log(diffObject({a: 1, b: 2}, {b: 3, c: 4})); // ->\n  [{property: \"a\", type: \"remove\"},\n   {property: \"b\", type: \"set\": value: 3},\n   {property: \"c\", type: \"add\", \"value\": 4}]\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "newObject",
      "description": "the object to diff to"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "an array of object-patch objects\n\nFind the differences between two objects, based on properties and values\n\nThe object-patch object format has the following keys:\n- **property**: the property key on the new object\n- **type**:     the type of operation on this property: add, remove, or set\n- **value**:    the new value (if type is \"add\" or \"set\")\n\n```js\nvar diffObject = require(\"can-util/js/diff-object/diff-object\");\n\nconsole.log(diffObject({a: 1, b: 2}, {b: 3, c: 4})); // ->\n  [{property: \"a\", type: \"remove\"},\n   {property: \"b\", type: \"set\": value: 3},\n   {property: \"c\", type: \"add\", \"value\": 4}]\n```\n"
    }
  },
  "can-util/js/each/each": {
    "src": {
      "path": "node_modules/can-util/js/each/each.md"
    },
    "body": "",
    "description": "\n",
    "type": "module",
    "title": "each",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/each/each",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "each(elements, callback, context)",
        "description": "\n\nA generic iterator function that can be used to iterate over both Array-Like and object data structure. Array-Like data structures are iterated by their numerical index. Objects are iterated by their named properties, i.e. in each stage of iteration the each function emits the key and its corresponding value.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "ArrayLike"
              }
            ],
            "optional": true,
            "name": "elements",
            "description": "the object or Array-Like elements to iterate over"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "element"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "key"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "elements"
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "callback",
            "description": "the function that would be executed in each iteration"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "the context object\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "ArrayLike"
            }
          ],
          "description": "the original elements\n\n```js\n var each = require(\"can-util/js/each/each\");\n \n each([2,1,0], function(i) { console.log(this[i]); }, [4,5,6]); // -> 6 \\n 5 \\n 4\n each({foo: 'bar', abc: 'xyz'}, function(val, key) {\n   console.log(key + ': ' + val);\n }); // -> \"foo: bar\" \\n \"abc: xyz\"\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "context",
      "description": "the context object\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "ArrayLike"
        }
      ],
      "description": "the original elements\n\n```js\n var each = require(\"can-util/js/each/each\");\n \n each([2,1,0], function(i) { console.log(this[i]); }, [4,5,6]); // -> 6 \\n 5 \\n 4\n each({foo: 'bar', abc: 'xyz'}, function(val, key) {\n   console.log(key + ': ' + val);\n }); // -> \"foo: bar\" \\n \"abc: xyz\"\n```\n"
    }
  },
  "can-util/js/get/get": {
    "type": "module",
    "name": "can-util/js/get/get",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 23,
      "path": "node_modules/can-util/js/get/get.js"
    },
    "body": "",
    "description": "\n",
    "title": "get",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "get(obj, path)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to use as the root for property based navigation"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "path",
            "description": "a String of dot-separated keys, representing a path of properties"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value at the property path\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the object passed.\n\n```js\nvar get = require(\"can-util/js/get/get\");\nconsole.log(get({a: {b: {c: \"foo\"}}}, \"a.b.c\")); // -> \"foo\"\nconsole.log(get({a: {}}, \"a.b.c\")); // -> undefined\nconsole.log(get([{a: {}}, {a: {b: \"bar\"}}], \"a.b\")); // -> \"bar\"\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "path",
      "description": "a String of dot-separated keys, representing a path of properties"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value at the property path\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the object passed.\n\n```js\nvar get = require(\"can-util/js/get/get\");\nconsole.log(get({a: {b: {c: \"foo\"}}}, \"a.b.c\")); // -> \"foo\"\nconsole.log(get({a: {}}, \"a.b.c\")); // -> undefined\nconsole.log(get([{a: {}}, {a: {b: \"bar\"}}], \"a.b\")); // -> \"bar\"\n```\n"
    }
  },
  "can-util/js/import/import": {
    "type": "module",
    "name": "can-util/js/import/import",
    "parent": "can-util/js",
    "src": {
      "line": 5,
      "codeLine": 23,
      "path": "node_modules/can-util/js/import/import.js"
    },
    "body": "",
    "description": "",
    "title": "import",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "importModule(moduleName, parentName)",
        "description": "\n\n```js\nvar importModule = require(\"can-util/js/import/import\");\n\nimportModule(\"foo.stache\").then(function(){\n  // module was imported\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "moduleName",
            "description": "The module to be imported."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "parentName",
            "description": "A parent module that will be used as a reference for resolving relative module imports."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that will resolve when the module has been imported.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "parentName",
      "description": "A parent module that will be used as a reference for resolving relative module imports."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that will resolve when the module has been imported.\n"
    }
  },
  "can-util/js/global/global": {
    "body": "",
    "description": "",
    "type": "module",
    "title": "global",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/global/global",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "GLOBAL()",
        "description": "\n\nReturns the global that this environment provides. It will be one of:\n\n* **Browser**: `window`\n* **Web Worker**: `self`\n* **Node.js**: `global`\n\n```js\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nvar g = GLOBAL();\n\n// In a browser\nconsole.log(g === window); // -> true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The global object for this JavaScript environment.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The global object for this JavaScript environment.\n"
    }
  },
  "can-util/js/is-browser-window/is-browser-window": {
    "type": "module",
    "name": "can-util/js/is-browser-window/is-browser-window",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 21,
      "path": "node_modules/can-util/js/is-browser-window/is-browser-window.js"
    },
    "body": "",
    "description": "",
    "title": "is-browser-window",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isBrowserWindow()",
        "description": "\n\nReturns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).\n\n```js\nvar isBrowserWindow = require(\"can-util/js/is-browser-window/is-browser-window\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isBrowserWindow()) {\n  console.log(GLOBAL() === window); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the environment is a Browser window.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the environment is a Browser window.\n"
    }
  },
  "can-util/js/is-array-like/is-array-like": {
    "src": {
      "path": "node_modules/can-util/js/is-array-like/is-array-like.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "is-array-like",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-array-like/is-array-like",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isArrayLike(obj)",
        "description": "\n\nDetermines if an object is \"array like\", meaning it can be looped over. Any object with a `.length` property is array like.\n\n```js\nvar isArrayLike = require(\"can-util/js/is-array-like/is-array-like\");\n\n// Arrays\nconsole.log(isArrayLike([{ foo: \"bar\" }])); // -> true\n\n// Strings\nconsole.log(isArrayLike(\"some string\")); // -> true\n\n// Objects with .length property\nconsole.log(isArrayLike({ length: 11 })); // -> true\n\n// Numbers and Booleans are not.\nconsole.log(isArrayLike(true)); // -> false\nconsole.log(isArrayLike(13)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "Any object type."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True, if the object is similar to an array.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "Any object type."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True, if the object is similar to an array.\n"
    }
  },
  "can-util/js/is-empty-object/is-empty-object": {
    "type": "module",
    "name": "can-util/js/is-empty-object/is-empty-object",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 29,
      "path": "node_modules/can-util/js/is-empty-object/is-empty-object.js"
    },
    "body": "",
    "description": "",
    "title": "is-empty-object",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isEmptyObject(obj)",
        "description": "\n\nUsed to determine if an object is an empty object (an object with no enumerable properties) such as `{}`.\n\n```js\nvar isEmptyObject = require(\"can-util/js/is-empty-object/is-empty-object\");\n\nconsole.log(isEmptyObject({})); // -> true\n\nconsole.log(isEmptyObject({ a: 1 })); // -> false\n\nvar obj = {};\nObject.defineProperty(obj, \"foo\", {\n    enumerable: false,\n    value: \"bar\"\n});\nconsole.log(isEmptyObject(obj)); // -> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "Any object."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is an object with no enumerable properties.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "Any object."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is an object with no enumerable properties.\n"
    }
  },
  "can-util/js/is-function": {
    "type": "module",
    "name": "can-util/js/is-function",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 20,
      "path": "node_modules/can-util/js/is-function/is-function.js"
    },
    "body": "",
    "description": "\n",
    "title": "/is-function is-function",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isFunction(value)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "the item to test for being a function"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the provided argument is a function.\n\n```js\nvar isFunction = require(\"can-util/js/is-function/is-function\");\n\nconsole.log(isFunction(function(){})); // -> true\n\nconsole.log(isFunction({})); // -> false\n```\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "the item to test for being a function"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the provided argument is a function.\n\n```js\nvar isFunction = require(\"can-util/js/is-function/is-function\");\n\nconsole.log(isFunction(function(){})); // -> true\n\nconsole.log(isFunction({})); // -> false\n```\n\n"
    }
  },
  "can-util/js/is-node/is-node": {
    "type": "module",
    "name": "can-util/js/is-node/is-node",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 20,
      "path": "node_modules/can-util/js/is-node/is-node.js"
    },
    "body": "",
    "description": "Determines if your code is running in [Node.js](https://nodejs.org). ",
    "title": "is-node",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isNode()",
        "description": "\n\n```js\nvar isNode = require(\"can-util/js/is-node/is-node\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isNode()) {\n  console.log(GLOBAL() === global); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if running in Node.js\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if running in Node.js\n"
    }
  },
  "can-util/js/is-plain-object/is-plain-object": {
    "src": {
      "path": "node_modules/can-util/js/is-plain-object/is-plain-object.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "is-plain-object",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-plain-object/is-plain-object",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isPlainObject(obj)",
        "description": "\n\nAttempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:\n\n1. Objects with prototypes (created using the `new` keyword).\n2. Booleans.\n3. Numbers.\n4. NaN.\n\n```js\nvar isPlainObject = require(\"can-util/js/is-plain-object/is-plain-object\");\n\n// Created with {}\nconsole.log(isPlainObject({})); // -> true\n\n// new Object\nconsole.log(isPlainObject(new Object())); // -> true\n\n// Custom object\nvar Ctr = function(){};\nvar obj = new Ctr();\n\nconsole.log(isPlainObject(obj)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-util/js/is-promise/is-promise": {
    "type": "module",
    "name": "can-util/js/is-promise/is-promise",
    "parent": "can-util/js",
    "src": {
      "line": 3,
      "codeLine": 24,
      "path": "node_modules/can-util/js/is-promise/is-promise.js"
    },
    "body": "",
    "description": "",
    "title": "is-promise",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isPromise(obj)",
        "description": "\n\nDetermines if object is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar isPromise = require(\"can-util/js/is-promise/is-promise\");\n\nvar promise = new Promise(function(resolve){\n  resolve();\n});\n\nconsole.log(isPromise(promise)); // -> true\nconsole.log(isPromise(\"foo bar\")); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be tested."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be tested."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a Promise.\n"
    }
  },
  "can-util/js/is-promise-like/is-promise-like": {
    "type": "module",
    "name": "can-util/js/is-promise-like/is-promise-like",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 24,
      "path": "node_modules/can-util/js/is-promise-like/is-promise-like.js"
    },
    "body": "",
    "description": "",
    "title": "is-promise-like",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isPromiseLike(obj)",
        "description": "\n\nDetermines if an object is \"Then-able\".\nAlso see `isPromise(obj)` which checks for a standard [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar isPromiseLike = require(\"can-util/js/is-promise-like/is-promise-like\");\n\nvar promise = new Promise(function(resolve){\n  resolve();\n});\n\nconsole.log(isPromiseLike(promise)); // -> true\nconsole.log(isPromiseLike(\"foo bar\")); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be tested."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be tested."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a Promise.\n"
    }
  },
  "can-util/js/is-string/is-string": {
    "type": "module",
    "name": "can-util/js/is-string/is-string",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 20,
      "path": "node_modules/can-util/js/is-string/is-string.js"
    },
    "body": "",
    "description": "Determines if the provided argument is a string. ",
    "title": "is-string",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isString(obj)",
        "description": "\n\n```js\nvar isString = require(\"can-util/js/is-string/is-string\");\n\nconsole.log(isString(\"foo\")); // -> true\nconsole.log(isString(String(\"foo\")); // -> true\n\nconsole.log(isString({})); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "An object to test if is a string."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "An object to test if is a string."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a string.\n"
    }
  },
  "can-util/js/is-web-worker/is-web-worker": {
    "body": "",
    "description": "Determines if the code is running with a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers). ",
    "type": "module",
    "title": "is-web-worker",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-web-worker/is-web-worker",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isWebWorker()",
        "description": "\n\n```js\nvar isWebWorker = require(\"can-util/js/is-web-worker/is-web-worker\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isWebWorker()) {\n  console.log(GLOBAL() === self); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if running in a Web Worker.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if running in a Web Worker.\n"
    }
  },
  "can-util/js/join-uris/join-uris": {
    "src": {
      "path": "node_modules/can-util/js/join-uris/join-uris.md"
    },
    "body": "",
    "description": "Join together a URI path to a base. ",
    "type": "module",
    "title": "join-uris",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/join-uris/join-uris",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "joinURIs(base, href)",
        "description": "\n\nProvides a convenient way to join together URIs handling relative paths.\n\n```js\nvar joinURIs = require(\"can-util/js/join-uris\");\n\nvar base = \"http://example.com/some/long/path\";\nvar href = \"../../images/foo.png\";\n\nvar res = joinURIs(base, href);\n\nconsole.log(res); // -> http://example.com/images/foo.png\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "base",
            "description": ""
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "href",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The result of joining the two parts.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "href",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The result of joining the two parts.\n"
    }
  },
  "can-util/js/log/log": {
    "body": "\n",
    "description": "\nUtilities for logging to the console.\n",
    "type": "module",
    "title": "log",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-util/js/log/log",
    "parent": "can-util/js"
  },
  "can-util/js/log/log.warn": {
    "type": "function",
    "name": "can-util/js/log/log.warn",
    "parent": "can-util/js/log/log",
    "src": {
      "line": 12,
      "codeLine": 28,
      "path": "node_modules/can-util/js/log/log.js"
    },
    "body": "",
    "description": " \nAdds a warning message to the console.\n\n```\nvar canLog = require(\"can-util/js/log/log\");\n\ncanLog.warn(\"something evil\");\n```\n\n",
    "title": "warn",
    "signatures": [
      {
        "code": "canLog.warn(msg)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "msg",
            "description": "the message to be logged.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "msg",
      "description": "the message to be logged.\n"
    }
  },
  "can-util/js/log/log.log": {
    "type": "function",
    "name": "can-util/js/log/log.log",
    "parent": "can-util/js/log/log",
    "src": {
      "line": 42,
      "codeLine": 57,
      "path": "node_modules/can-util/js/log/log.js"
    },
    "body": "",
    "description": " Adds a message to the console.\n\n```\nvar canLog = require(\"can-util/js/log/log\");\n\ncanLog.log(\"hi\");\n```\n\n",
    "title": "log",
    "signatures": [
      {
        "code": "canLog.log(msg)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "msg",
            "description": "the message\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "msg",
      "description": "the message\n"
    }
  },
  "can-util/js/log/log.error": {
    "type": "function",
    "name": "can-util/js/log/log.error",
    "parent": "can-util/js/log/log",
    "src": {
      "line": 69,
      "codeLine": 84,
      "path": "node_modules/can-util/js/log/log.js"
    },
    "body": "",
    "description": " Adds an error message to the console.\n\n```\nvar canLog = require(\"can-util/js/log/log\");\n\ncanLog.error(new Error(\"Oh no!\"));\n```\n\n",
    "title": "error",
    "signatures": [
      {
        "code": "canLog.error(err)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Error"
              }
            ],
            "name": "err",
            "description": "The error to be logged.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Error"
        }
      ],
      "name": "err",
      "description": "The error to be logged.\n"
    }
  },
  "can-util/js/make-array/make-array": {
    "type": "module",
    "name": "can-util/js/make-array/make-array",
    "parent": "can-util/js",
    "src": {
      "line": 5,
      "codeLine": 21,
      "path": "node_modules/can-util/js/make-array/make-array.js"
    },
    "body": "",
    "description": "",
    "title": "make-array",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeArray(element)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "element",
            "description": "any array-like or object data structure"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a JavaScript array object with the same elements as the passed-in ArrayLike\n\nmakeArray takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array\n\n```\nvar makeArray = require(\"can-util/js/make-array/make-array\");\n\nmakeArray({0: \"a\", length: 1}); //-> [\"a\"]\n\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ArrayLike"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "element",
      "description": "any array-like or object data structure"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a JavaScript array object with the same elements as the passed-in ArrayLike\n\nmakeArray takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array\n\n```\nvar makeArray = require(\"can-util/js/make-array/make-array\");\n\nmakeArray({0: \"a\", length: 1}); //-> [\"a\"]\n\n```\n"
    }
  },
  "can-util/js/make-map/make-map": {
    "type": "module",
    "name": "can-util/js/make-map/make-map",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 19,
      "path": "node_modules/can-util/js/make-map/make-map.js"
    },
    "body": "",
    "description": "",
    "title": "make-map",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeMap( string )",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "string",
            "description": "A comma separated list of values"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A JavaScript object with the same keys as the passed-in comma-separated values\n\nmakeMap takes a comma-separated string (can-list, NodeList, etc.) and converts it to a JavaScript object\n\n```\nvar makeMap = require(\"can-util/js/make-map/make-map\");\n\nmakeMap(\"a,b,c\"); //-> { a: true, b: true, c: true }\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "string",
      "description": "A comma separated list of values"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A JavaScript object with the same keys as the passed-in comma-separated values\n\nmakeMap takes a comma-separated string (can-list, NodeList, etc.) and converts it to a JavaScript object\n\n```\nvar makeMap = require(\"can-util/js/make-map/make-map\");\n\nmakeMap(\"a,b,c\"); //-> { a: true, b: true, c: true }\n```\n"
    }
  },
  "can-util/js/make-promise/make-promise": {
    "name": "can-util/js/make-promise/make-promise",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 22,
      "path": "node_modules/can-util/js/make-promise/make-promise.js"
    },
    "body": "",
    "description": "",
    "title": "make-promise",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makePromise(obj)",
        "description": "\n\nWill make isPromiseLike object into [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar makePromise = require(\"can-util/js/make-promise/make-promise\");\n\nvar obj = {};\nvar promise = makePromise(obj);\n\nconsole.log(isPromise(promise)); // -> true\nconsole.log(isPromise(obj)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be made into Promise."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "the object as a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be made into Promise."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "the object as a Promise.\n"
    }
  },
  "can-util/js/omit/omit": {
    "type": "module",
    "name": "can-util/js/omit/omit",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 24,
      "path": "node_modules/can-util/js/omit/omit.js"
    },
    "body": "",
    "description": "",
    "title": "omit",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "omit(source, propsToOmit)",
        "description": "\n\nOmit properties from an object.\n\n```js\nvar omit = require(\"can-util/js/omit/omit\");\n\nvar obj = { a: 1, b: 2, c: 3, d: 4};\n\nvar newObj = omit(obj, [ 'b', 'd' ]);\n\nconsole.log(newObj); // -> { a: 1, c: 3 }\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "The source object whose non-omitted properties will be uses to source the result."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "propsToOmit",
            "description": "List of properties to omit from the result.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns a new object with all of the properties from `source` that were not omitted.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "propsToOmit",
      "description": "List of properties to omit from the result.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns a new object with all of the properties from `source` that were not omitted.\n"
    }
  },
  "can-util/js/param/param": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/param/param.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-param] instead. \n",
    "title": "param",
    "name": "can-util/js/param/param",
    "parent": "can-util/js"
  },
  "can-util/js/set-immediate/set-immediate": {
    "type": "module",
    "name": "can-util/js/set-immediate/set-immediate",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 12,
      "path": "node_modules/can-util/js/set-immediate/set-immediate.js"
    },
    "body": "",
    "description": "",
    "title": "set-immediate",
    "signatures": [
      {
        "code": "setImmediate(function())",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "cb",
            "description": "\n\nPolyfill for setImmediate() if it doesn't exist in the global context\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "cb",
      "description": "\n\nPolyfill for setImmediate() if it doesn't exist in the global context\n"
    }
  },
  "can-util/js/string/string": {
    "name": "can-util/js/string/string",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 12,
      "codeLine": 18,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "String utilities used by CanJS libraries \n",
    "title": "string",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/js/string/string.esc": {
    "type": "function",
    "name": "can-util/js/string/string.esc",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 50,
      "codeLine": 62,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.esc",
    "signatures": [
      {
        "code": "string.esc(content)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "content",
            "description": "a string"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the string safely HTML-escaped\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nstring.esc(\"<div>&nbsp;</div>\"); //-> \"&lt;div&gt;&amp;nbsp;&lt;/div&gt;\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "content",
      "description": "a string"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the string safely HTML-escaped\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nstring.esc(\"<div>&nbsp;</div>\"); //-> \"&lt;div&gt;&amp;nbsp;&lt;/div&gt;\"\n```\n "
    }
  },
  "can-util/js/string/string.getObject": {
    "type": "function",
    "name": "can-util/js/string/string.getObject",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 70,
      "codeLine": 97,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.getObject",
    "signatures": [
      {
        "code": "string.getObject(name, roots)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "a String of dot-separated keys, representing a path of properties"
          },
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "roots",
            "description": "the object to use as the root for property based navigation"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value at the property path descending from `roots`\n\nReturn the result of descending the path `name` through the properties of the object or objects\n`roots`\n\nIf `roots` is an Array, each element of the array is evaluated, in order, until\nthe path is found in an element's properties (and properties-of-properties, etc.).  Otherwise\n`roots` is evaluated as the root object, returning either the object at the property path\ndescended from `roots` or `undefined` if any subpath is not found.\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the first object in `roots`\nif it's an array, `roots` itself otherwise.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.getObject(\"a.b.c\", {a: {b: {c: \"foo\"}}})); // -> \"foo\"\nconsole.log(string.getObject(\"a.b.c\", {a: {}})); // -> undefined\nconsole.log(string.getObject(\"a.b\", [{a: {}}, {a: {b: \"bar\"}}])); // -> \"bar\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "roots",
      "description": "the object to use as the root for property based navigation"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value at the property path descending from `roots`\n\nReturn the result of descending the path `name` through the properties of the object or objects\n`roots`\n\nIf `roots` is an Array, each element of the array is evaluated, in order, until\nthe path is found in an element's properties (and properties-of-properties, etc.).  Otherwise\n`roots` is evaluated as the root object, returning either the object at the property path\ndescended from `roots` or `undefined` if any subpath is not found.\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the first object in `roots`\nif it's an array, `roots` itself otherwise.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.getObject(\"a.b.c\", {a: {b: {c: \"foo\"}}})); // -> \"foo\"\nconsole.log(string.getObject(\"a.b.c\", {a: {}})); // -> undefined\nconsole.log(string.getObject(\"a.b\", [{a: {}}, {a: {b: \"bar\"}}])); // -> \"bar\"\n```\n "
    }
  },
  "can-util/js/string/string.capitalize": {
    "type": "function",
    "name": "can-util/js/string/string.capitalize",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 114,
      "codeLine": 127,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.capitalize",
    "signatures": [
      {
        "code": "string.capitalize(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "s",
            "description": "the string to capitalize"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with the first character uppercased if it is a letter\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.capitalize(\"foo\")); // -> \"Foo\"\nconsole.log(string.capitalize(\"123\")); // -> \"123\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "s",
      "description": "the string to capitalize"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with the first character uppercased if it is a letter\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.capitalize(\"foo\")); // -> \"Foo\"\nconsole.log(string.capitalize(\"123\")); // -> \"123\"\n```\n "
    }
  },
  "can-util/js/string/string.camelize": {
    "type": "function",
    "name": "can-util/js/string/string.camelize",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 132,
      "codeLine": 145,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.camelize",
    "signatures": [
      {
        "code": "string.camelize(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "the string to camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with hyphens removed and following letters capitalized.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\nconsole.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "the string to camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with hyphens removed and following letters capitalized.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\nconsole.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n```\n "
    }
  },
  "can-util/js/string/string.hyphenate": {
    "type": "function",
    "name": "can-util/js/string/string.hyphenate",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 151,
      "codeLine": 164,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.hyphenate",
    "signatures": [
      {
        "code": "string.hyphenate(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string in camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with camelCase converted to hyphen-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\nconsole.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "a string in camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with camelCase converted to hyphen-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\nconsole.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n```\n "
    }
  },
  "can-util/js/string/string.underscore": {
    "type": "function",
    "name": "can-util/js/string/string.underscore",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 171,
      "codeLine": 184,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.underscore",
    "signatures": [
      {
        "code": "string.underscore(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string in camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with camelCase converted to underscore-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\nconsole.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "a string in camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with camelCase converted to underscore-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\nconsole.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n```\n "
    }
  },
  "can-util/js/string/string.sub": {
    "type": "function",
    "name": "can-util/js/string/string.sub",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 191,
      "codeLine": 208,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.sub",
    "signatures": [
      {
        "code": "string.sub(str, data, remove)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string with {curly brace} delimited property names"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "an object from which to read properties"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "null"
            }
          ],
          "description": "the supplied string with delimited properties replaced with their values\n                      if all properties exist on the object, null otherwise\n\nIf `remove` is true, the properties found in delimiters in `str` are removed from `data`.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.sub(\"foo_{bar}\", {bar: \"baz\"}})); // -> \"foo_baz\"\nconsole.log(string.sub(\"foo_{bar}\", {})); // -> null\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "data",
      "description": "an object from which to read properties"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "null"
        }
      ],
      "description": "the supplied string with delimited properties replaced with their values\n                      if all properties exist on the object, null otherwise\n\nIf `remove` is true, the properties found in delimiters in `str` are removed from `data`.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.sub(\"foo_{bar}\", {bar: \"baz\"}})); // -> \"foo_baz\"\nconsole.log(string.sub(\"foo_{bar}\", {})); // -> null\n```\n "
    }
  },
  "can-util/js/string/string.strReplacer": {
    "name": "can-util/js/string/string.strReplacer",
    "type": "property",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 232,
      "codeLine": 237,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": " \n",
    "description": "\nThe regex used to find replacement sections in [can-util/js/string/string.sub string.sub]\n",
    "types": [
      {
        "type": "RegExp"
      }
    ],
    "title": "string.strReplacer"
  },
  "can-util/js/string/string.strUndHash": {
    "name": "can-util/js/string/string.strUndHash",
    "type": "property",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 238,
      "codeLine": 243,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": " \n",
    "description": "\nA regex which matches an underscore or hyphen character\n",
    "types": [
      {
        "type": "RegExp"
      }
    ],
    "title": "string.strUndHash"
  },
  "can-util/js/string-to-any/string-to-any": {
    "src": {
      "path": "node_modules/can-util/js/string-to-any/string-to-any.md"
    },
    "body": "",
    "description": "Turns a string representation of a primitive type back into the associated primitive. \n",
    "type": "module",
    "title": "string-to-any",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/string-to-any/string-to-any",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "stringToAny(string)",
        "description": "\n\nExamines the provided string to see if it can be converted to a primitive type. Supported arguments are:\n\n* \"true\"\n* \"false\"\n* \"null\"\n* \"undefined\"\n* \"NaN\"\n* \"Infinity\"\n* Any [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)\n* Any [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)\n\n```js\nvar stringToAny = require(\"can-util/js/string-to-any/string-to-any\");\n\nstringToAny(\"NaN\"); // -> NaN\nstringToAny(\"44.4\"); // -> 44.4\nstringToAny(\"false\"); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "string",
            "description": "A string to convert back to its primitive type.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The primitive representation of the provided string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "string",
      "description": "A string to convert back to its primitive type.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The primitive representation of the provided string.\n"
    }
  },
  "can-util/js/types/types": {
    "src": {
      "line": 4,
      "codeLine": 10,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "type": "module",
    "body": "",
    "description": "Deprecated. Use [can-types] instead. \n",
    "title": "types",
    "name": "can-util/js/types/types",
    "parent": "can-util/js"
  },
  "_validate": {
    "type": "function",
    "name": "_validate",
    "params": [],
    "parent": "node_modules/can-validate-legacy/map/validate/validate.js",
    "src": {
      "line": 151,
      "codeLine": 156,
      "path": "node_modules/can-validate-legacy/map/validate/validate.js"
    },
    "body": "",
    "description": "Runs validation on the entire map instance. Actual behavior of \"validate all\" is defined by the registered shim (`validate`).\n\n",
    "title": "_Validate"
  },
  "_validateOne": {
    "type": "function",
    "name": "_validateOne",
    "params": [
      {
        "types": [
          {
            "type": "object"
          }
        ],
        "name": "item",
        "description": "A key/value object"
      },
      {
        "types": [
          {
            "type": "object"
          }
        ],
        "name": "opts",
        "description": "Object that contains validation config."
      }
    ],
    "parent": "node_modules/can-validate-legacy/map/validate/validate.js",
    "src": {
      "line": 175,
      "codeLine": 190,
      "path": "node_modules/can-validate-legacy/map/validate/validate.js"
    },
    "body": "",
    "description": "Main method used by `Map.define` setter when a property changes.  Runs validation on a property. Actual behavior of \"validate one\" is defined\n by the registered shim (`once`).\n\n It also handles setting the errors property on the map instance and then\nmanages the errors for the current property within the errors object.\n\n",
    "title": "Validate One",
    "_curParam": {
      "types": [
        {
          "type": "object"
        }
      ],
      "name": "opts",
      "description": "Object that contains validation config."
    },
    "returns": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "True if method found that the property can be saved; if\n validation fails and the property must validate (`mustValidate` property),\n this will be `false`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "True if method found that the property can be saved; if\n validation fails and the property must validate (`mustValidate` property),\n this will be `false`.\n"
    }
  },
  "_processValidateOpts": {
    "type": "function",
    "name": "_processValidateOpts",
    "params": [
      {
        "types": [
          {
            "type": "object"
          }
        ],
        "name": "itemObj",
        "description": "Property to validate"
      },
      {
        "types": [
          {
            "type": "object"
          }
        ],
        "name": "opts",
        "description": "Map of validation options\n"
      }
    ],
    "parent": "node_modules/can-validate-legacy/map/validate/validate.js",
    "src": {
      "line": 221,
      "codeLine": 232,
      "path": "node_modules/can-validate-legacy/map/validate/validate.js"
    },
    "body": "",
    "description": "Allows the ability to pass computes in validation properties, this allows for things like making a property required based on the value on\nanother property.\n\nProcesses validation options, creates computes from functions and adds\nlisteners to computes.\n",
    "title": "Process Validate Opts",
    "_curParam": {
      "types": [
        {
          "type": "object"
        }
      ],
      "name": "opts",
      "description": "Map of validation options\n"
    }
  },
  "can-zone/debug": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/debug.md"
    },
    "body": "\n## Use\n\nThe **debug** zone gives you information about which tasks failed to complete in case of a timeout. It is to be used with [./timeout.md](can-zone/timeout).\n\nWhen a timeout occurs the debug Zone will appending debug information to the Zone's [data](https://github.com/canjs/can-zone/blob/master/docs/data.md) property, which can be retrieved when the Zone's promise is rejected:\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nvar zone = new Zone(debug(5000);\n\nzone.run(function(){\n\n\tsetTimeout(function(){}, 10000);\n\n}).catch(err){\n\n\tvar debugInfo = zone.data.debugInfo;\n\n});\n```\n\n## DebugInfo\n\nThe **DebugInfo** is an array of objects that contain information about which tasks failed to complete. Each object has a shape of:\n\n```js\n{\n\t\"task\": \"setTimeout\",\n\t\"stack\": Error ....\"\n}\n```\n\n### DebugInfo[].task\n\nA *string* identifier of the task that failed to complete. This can be any of the [asynchronous tasks](https://github.com/canjs/can-zone#tasks) supported by can-zone like `setTimeout` or `Promise`.\n\n### DebugInfo[].stack\n\nA *string* stack trace taken as a snapshot when the task was called. This allows you t see the source of the call to help debug why the task never completed.\n\n## debug(timeout)\n\nCreate a debug Zone by passing the debug function a timeout in milliseconds:\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nnew Zone({\n\tplugins: [\n\t\tdebug(5000)\n\t]\n});\n```\n\n## debug(timeoutZone)\n\nCreate a debug Zone by passing in a timeout Zone that was already created:\n\n```js\nvar timeout = require(\"can-zone/timeout\");\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nvar timeoutZone = timeout(5000);\nvar debugZone = debug(timeoutZone);\n\nnew Zone({\n\tplugins: [\n\t\ttimeoutZone,\n\t\tdebugZone\n\t]\n});\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-zone/debug",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone/debug",
    "parent": "can-zone.plugins",
    "signatures": [
      {
        "code": "debug(ms)",
        "description": "\n\nCreates a new [can-zone.ZoneSpec] that can be provided to your Zone, timing out in `ms` (milliseconds).\n\n```js\nvar Zone = require(\"can-zone\");\nvar debug = require(\"can-zone/debug\");\n\nvar zone = new Zone({\n\tplugins: [debug(5000)]\n})\n.catch(function(err){\n\tvar info = zone.data.debugInfo;\n});\n```\n\nSee the [can-zone/debug.DebugInfo] type for a list of properties \n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "ms",
            "description": "The timeout, in milliseconds, before the [can-zone Zone] will be rejected and debug information attached to the [can-zone.prototype.data zone's data] object.\n"
          }
        ]
      },
      {
        "code": "debug(timeoutZone)",
        "description": "\n\nLike the previous signature, but directly pass it a [can-zone/timeout timeout ZoneSpec] object that you create yourself.\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar timeoutZone = timeout(5000);\nvar debugZone = debug(timeoutZone):\n\n...\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-zone/timeout"
              }
            ],
            "name": "timeoutZone",
            "description": "A [can-zone.ZoneSpec] created using the timeout plugin.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-zone/timeout"
        }
      ],
      "name": "timeoutZone",
      "description": "A [can-zone.ZoneSpec] created using the timeout plugin.\n"
    },
    "comment": " "
  },
  "can-zone/debug.DebugInfo": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/debuginfo.md"
    },
    "body": "",
    "description": "An array of objects containing information useful for debugging. Gives you the name of the **task** that failed to complete and a **stack** trace of where the error occured. \nEach object has a shape of:\n\n```js\n{\n\t\"task\": \"setTimeout\",\n\t\"stack\": Error ....\"\n}\n```\n\n",
    "type": "typedef",
    "title": "DebugInfo",
    "types": [
      {
        "type": "Array",
        "template": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ],
        "options": [
          {
            "name": "task",
            "description": "An identifier of the task that failed to complete. This can be any of the [asynchronous tasks](https://github.com/canjs/can-zone#tasks) supported by can-zone like `setTimeout` or `Promise`.\n\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "stack",
            "description": "A stack trace taken as a snapshot when the task was called. This allows you t see the source of the call to help debug why the task never completed.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/debug.DebugInfo",
    "parent": "can-zone/debug"
  },
  "can-zone/timeout": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/timeout.md"
    },
    "body": "\n## Use\n\nThe timeout zone allows you to specify a timeout for your Zone. If the Zone promise doesn't resolve before timing out, the Zone promise will be rejected by the plugin.\n\nThe **timeout** zone is a function that takes a timeout in milliseconds.\n\nThe Promise will reject with a special type of Error, a [can-zone/timeout.TimeoutError].\n\n```js\nvar Zone = require(\"can-zone\");\nvar timeout = require(\"can-zone/timeout\");\nvar TimeoutError = timeout.TimeoutError;\n\nvar zone = new Zone({\n\tplugins: [\n\t\ttimeout(2000)\n\t]\n});\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\n\t}, 5000);\n\n}).then(null, function(err){\n\n\t// err.timeout -> 2000\n\n});\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-zone/timeout",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "ms"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/timeout",
    "parent": "can-zone.plugins",
    "signatures": [
      {
        "code": "timeout(ms)",
        "description": "\n\nCreates a [can-zone.ZoneSpec] that you can use as a plugin for your [can-zone Zone] in order to timeout after a certain length of time (as `ms`).\n\nIf the Zone times out it's [can-zone.prototype.run run promise] will be rejected with a [can-zone/timeout.TimeoutError], a special error that also includes the number of milliseconds waited before timing out.\n\n```js\nvar Zone = require(\"can-zone\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar zone = new Zone({\n\tplugins: [ timeout(5000) ]\n});\n\nzone.run(function(){\n\tsetTimeout(function(){\n\n\t}, 10000); // waiting over 5 sec\n})\n.catch(function(err){\n\t// Called because we exceeded the timeout.\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "ms",
            "description": "The number of milliseconds to wait before timing out the [can-zone Zone].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-zone.ZoneSpec"
            }
          ],
          "description": "A ZoneSpec that can be passed as a plugin.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "ms",
      "description": "The number of milliseconds to wait before timing out the [can-zone Zone].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        }
      ],
      "description": "A ZoneSpec that can be passed as a plugin.\n"
    },
    "comment": " "
  },
  "can-zone/timeout.TimeoutError": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/timeouterror.md"
    },
    "body": "\n",
    "description": "A special type of Error that also includes the number of milliseconds that were waited before timing out. \nThe error object is included with the timeout module:\n\n```js\nvar timeout = require(\"can-zone/timeout\");\n\nvar TimeoutError = timeout.TimeoutError;\n// Maybe use this to check `instanceof`.\n```\n\n",
    "type": "typedef",
    "title": "TimeoutError",
    "types": [
      {
        "type": "Error",
        "options": [
          {
            "name": "timeout",
            "description": "Specifies the timeout that was exceeded.\n",
            "types": [
              {
                "type": "Number"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/timeout.TimeoutError",
    "parent": "can-zone/timeout"
  },
  "guides/recipes/file-navigator-advanced": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/file-navigator-ajax.md"
    },
    "body": "\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/qunuyi/embed?js,output\">JS Bin on jsbin.com</a>\n\n> Note: If you don't see any files show up, run the JSBin again. This\n> JSBin uses randomly generated files so it's possible nothing shows up.\n\n__Start this tutorial by cloning the following JSBin__:\n\n<a class=\"jsbin-embed\" href=\"//justinbmeyer.jsbin.com/xokopog/embed?html,output\">JS Bin on jsbin.com</a>\n\nThis JSBin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\nThe following sections are broken down into:\n\n- Problem - A description of what the section is trying to accomplish.\n- Things to know - Information about CanJS that is useful for solving the problem.\n- Solution - The solution to the problem.\n\n## Build a fixtured service layer\n\n### Problem\n\nMake an `/api/entities` service layer that provides the files and folders for another folder.  An `entity` can be either a file or folder.  A single `entity` looks like:\n\n```js\n{\n  id: \"2\",\n  name: \"dogs\",\n  parentId: \"0\",     // The id of the folder this file or folder is within.\n  type: \"folder\"     // or \"file\",\n  hasChildren: true  // false for a folder with no children, or a file\n}\n```\n\nTo get the list of files and folders within a given folder, a `GET` request should be made as follows:\n\n```\nGET /api/entities?folderId=0\n```\n\nThis should return the list of folders and files directly within that folder like:\n\n```js\n{\n  data: [\n   { id: \"7\", name: \"pekingese.png\", parentId: \"0\", type: \"file\",   hasChildren: false },\n   { id: \"8\", name: \"poodles\",       parentId: \"0\", type: \"folder\", hasChildren: false },\n   { id: \"9\", name: \"hounds\",        parentId: \"0\", type: \"folder\", hasChildren: true }\n  ]\n}\n```\n\nThe first level files and folders should have a `parentId` of `\"0\"`.\n\n### Things to know\n\n- [can-fixture] is used to trap AJAX requests like:\n\n  ```js\n  can.fixture(\"/api/entities\", function(request){\n    request.data.folderId //-> \"1\"\n\n    return {data: [...]}\n  })\n  ```\n\n- [can-fixture.store] can be used to automatically filter records using the querystring.\n\n  ```js\n  var entities = [ .... ];\n  var entitiesStore = can.fixture.store( entities );\n  can.fixture(\"/api/entities\", entitiesStore);\n  ```\n\n- [can-fixture.rand] can be used to create a random integer.\n  ```\n  can.fixture.rand(10) //-> 10\n  can.fixture.rand(10) //-> 0\n  ```\n\n\n\n### Solution\n\nFirst, make a function that generates an array of `entities` that will be stored on our fake server:\n\n```js\n// Stores the next entity id to use.\nvar entityId = 1;\n\n// Returns an array of entities for the given `parentId`.\n// Makes sure the `depth` of entities doesn't exceed 5.\nvar makeEntities = function(parentId, depth){\n  if(depth > 5) {\n    return [];\n  }\n  // The number of entities to create.\n  var entitiesCount = can.fixture.rand(10);\n\n  // The array of entities we will return.\n  var entities = [];\n\n  for(var i = 0 ;  i< entitiesCount; i++) {\n\n    // The id for this entity\n    var id = \"\"+(entityId++),\n        // If the entity is a folder or file\n        isFolder = Math.random() > 0.3,\n        // The children for this folder.\n        children = isFolder ? makeEntities(id, depth+1) : [];\n\n    var entity = {\n      id: id,\n      name: (isFolder ? \"Folder\" : \"File\")+\" \"+id,\n      parentId: parentId,\n      type: (isFolder ? \"folder\" : \"file\"),\n      hasChildren: children.length ? true : false\n    };\n    entities.push(entity);\n\n    // Add the children of a folder\n    [].push.apply(entities,  children)\n\n  }\n  return entities;\n};\n```\n\nThen, make those entities, create a `store` to house them, and trap AJAX requests to use that `store`.\n\n```js\n// Make the entities for the demo\nvar entities = makeEntities(\"0\", 0);\n\n// Add them to a client-like DB store\nvar entitiesStore = can.fixture.store(entities);\n\n// Trap requests to /api/entities to read items from the entities store.\ncan.fixture(\"/api/entities\", entitiesStore);\n\n// Make requests to /api/entities take 1 second\ncan.fixture.delay = 1000;\n```\n\n## Create the `Entity` Model\n\n### The problem\n\nWhen we load entities from the server, it's useful to convert them into `Entity` type instances.  We will want to create an observable `Entity` type using [can-define/map/map] so we can do:\n\n```js\nvar entity = new Entity({\n  id: \"2\",\n  name: \"dogs\",\n  parentId: \"0\",     // The id of the folder this file or folder is within.\n  type: \"folder\"     // or \"file\",\n  hasChildren: true  // false for a folder with no children, or a file\n});\n\nentity.on(\"name\", function(ev, newName){\n  console.log(\"entity name changed to \", newName);\n});\n\nentity.name = \"cats\" //-> logs \"entity name changed to cats\"\n```\n\n### Things to know\n\nYou can create a `DefineMap` type using [can-define/map/map.extend DefineMap.extend] with the type's properties and the properties' types like:\n\n```js\nType = can.DefineMap.extend({\n  id: \"string\",\n  hasChildren: \"boolean\",\n  ...\n})\n```\n\n### The solution\n\nExtend `can.DefineMap` with each property and its type as follows:\n\n```js\nvar Entity = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  parentId: \"string\",\n  hasChildren: \"boolean\",\n  type: \"string\"\n});\n```\n\n## Connect the `Entity` model to the service layer\n\n### The problem\n\nWe want to be able to load a list of `Entity` instances from `GET /api/entities` with:\n\n```js\nEntity.getList({parentId: \"0\"}).then(function(entities){\n    console.log(entities.get()) //-> [ Entity{id: \"1\", parentId: \"0\", ...}, ...]\n})\n```\n\n### Things to know\n\n[can-connect/can/base-map/base-map can.connect.baseMap()] can connect a `Map` type to\na `url` like:\n\n```js\ncan.connect.baseMap({\n  Map: Entity,\n  url: \"URL\"\n})\n```\n\n### The solution\n\nUse `can.connect.baseMap` to connect `Entity` to `/api/entities` like:\n\n```js\ncan.connect.baseMap({\n  Map: Entity\n  url: \"/api/entities\"\n})\n```\n\n## Create the ROOT entity and render it\n\n### The problem\n\nWe need to begin converting the static HTML the designer gave us into live HTML.  This means\nrendering it in a template.  We'll start slow by rendering the `root` parent folder's name\nin the same way it's expected by the designer.\n\n\n### Things to know\n\n- CanJS uses [can-stache] to render data in a template\n  and keep it live.  Templates can be authored in `<script>` tags like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-template\">\n    TEMPLATE CONTENT\n  </script>\n  ```\n\n  A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] magic tags to insert data into\n  the HTML output like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-template\">\n    {{something.name}}\n  </script>\n  ```\n\n- Load a template from a `<script>` tag with [can-stache.from can.stache.from] like:\n  ```js\n  var template = can.stache.from(SCRIPT_ID);\n  ```\n\n- Render the template with data into a documentFragment like:\n\n  ```js\n  var frag = template({\n    something: {name: \"Derek Brunson\"}\n  });\n  ```\n\n- Insert a fragment into the page with:\n\n  ```\n  document.body.appendChild(frag);\n  ```\n\n- You can create an `Entity` instance as follows:\n  ```js\n  var folder = new Entity({...});\n  ```\n\n  Where {...} is an object of the properties you need to create like `{id: \"0\", name: \"ROOT\", ...}`.\n  Pass this to the template.\n\n\n### The solution\n\nUpdate the `HTML` tab to render the `folder`'s name.\n\n```html\n<script type=\"text/stache\" id=\"app-template\">\n<span>{{folder.name}}</span>\n</script>\n```\n\nUpdate the `JS` tab to:\n\n1. Create a `folder` `Entity` instance.\n2. Load the `app-template`.  Renders it with `folder` instance, and inserts the result in the `<body>` element.\n\n```js\nvar folder = new Entity({\n  id: \"0\",\n  name: \"ROOT/\",\n  hasChildren: true,\n  type: \"folder\"\n});\n\nvar template = can.stache.from(\"app-template\"),\n    frag = template({\n      folder: folder\n    });\n\ndocument.body.appendChild( frag );\n```\n\n\n\n## Render the ROOT entities children\n\n### The problem\n\nIn this section, we'll list the files and folders within the root folder.\n\n### Things to know\n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n- Use [can-stache.helpers.each {{#each value}}] to do looping in `can-stache`.\n- Use [can-stache.helpers.is {{#eq value1 value2}}] to test equality in `can-stache`.\n- `Promise`s are observable in `can-stache`.  Given a promise `somePromise`, you can:\n  - Check if the promise is loading like: `{{#if somePromise.isPending}}`.\n  - Loop through the resolved value of the promise like: `{{#each somePromise.value}}`.\n- Write `<div class=\"loading\">Loading</div>` when files are loading.\n- Write a `<ul>` to contain all the files.  Within the `<ul>` there should be:\n  - An `<li>` with a class attribute that includes `file` or `folder` and `hasChildren` if the folder has children.\n  - The `<li>` should have `📝 <span>{{FILE_NAME}}</span>` if a file and `📁 <span>{{FOLDER_NAME}}</span>` if a folder.\n\n### The solution\n\nThe following uses `entitiesPromise` to write `<div class=\"loading\">Loading</div>` while\nthe promise is pending, and then writes out an `<li>` for each entity in the resolved `entitiesPromise`:\n\n```html\n<script type=\"text/stache\" id=\"app-template\">\n<span>{{folder.name}}</span>\n{{#if entitiesPromise.isPending}}\n  <div class=\"loading\">Loading</div>\n{{else}}\n  <ul>\n    {{#each entitiesPromise.value}}\n      <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n        {{#eq type 'file'}}\n          📝 <span>{{name}}</span>\n        {{else}}\n          📁 <span>{{name}}</span>\n        {{/eq}}\n      </li>\n    {{/each}}\n  </ul>\n{{/if}}\n</script>\n```\n\nThe following adds an `entitiesPromise` to data passed to the template.  `entitiesPromise`\nwill contain the files and folders that are directly within the root folder.\n\n```js\n    frag = template({\n      folder: folder,\n      entitiesPromise: Entity.getList({parentId: \"0\"})\n    });\n```\n\n## Toggle children with a ViewModel\n\n### The problem\n\nWe want to hide the root folder's children until the root folder is clicked on.  An subsequent\nclicks on the root folder's name should toggle if the children are displayed.\n\n### Things to know\n\n- CanJS uses [guides/technicalViewModels#MaintainableMVVM ViewModels] to manage the behavior\n  of views.  ViewModels can have their own state, such as if a folder `isOpen` and should be showing\n  its children. `ViewModels` are custructor functions created with [can-define/map/map can.DefineMap].\n\n- `can.DefineMap` can detail the type of a property with another type like:\n  ```js\n  var Address = can.DefineMap.extend({\n    street: \"string\",\n    city: \"string\"\n  });\n  var Person = can.DefineMap.extend({\n    address: Address\n  });\n  ```\n\n- `can.DefineMap` can also specify default values:\n  ```js\n  var Person = can.DefineMap.extend({\n    address: Address,\n    age: {value: 33}\n  });\n  ```\n\n- `can.DefineMap` can also specify a default value and a type:\n  ```js\n  var Person = can.DefineMap.extend({\n    address: Address,\n    age: {value: 33, type: \"number\"}\n  });\n  ```\n\n- `can.DefineMap` can also have methods:\n\n  ```js\n  var Person = can.DefineMap.extend({\n    address: Address,\n    age: {value: 33, type: \"number\"},\n    birthday: function(){\n      this.age++;\n    }\n  });\n  ```\n\n- Use [can-stache-bindings.event] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked.\n\n   ```html\n   <div ($click)=\"doSomething()\"> ... </div>\n   ```\n\n### The solution\n\nThe following:\n\n - Defines a `FolderVM` type that will manage the UI state around a folder.  Specifically `FolderVM` has:\n   - `folder` which references the folder being displayed.\n   - `entitiesPromise` which will be a promise of all files for that folder.\n   - `isOpen` which tracks if the folder's children should be displayed.\n   - `toggleOpen` which changes `isOpen`.\n -  Creates an instance of the `FolderVM` and uses it to render the template.\n\n```js\nvar FolderVM = can.DefineMap.extend({\n  folder: Entity,\n  entitiesPromise: {\n    value: function(){\n      return Entity.getList({parentId: this.folder.id});\n    }\n  },\n  isOpen: {type: \"boolean\", value: false},\n  toggleOpen: function(){\n    this.isOpen = !this.isOpen;\n  }\n});\n\n// Create an instance of `FolderVM` with the root folder\nvar rootFolderVM = new FolderVM({\n  folder: folder\n});\n\nvar template = can.stache.from(\"app-template\"),\n    frag = template(rootFolderVM);\n\ndocument.body.appendChild( frag );\n```\n<span line-highlight='1-17,20'></span>\nThe following wraps the listing of child entities with a `{{#if isOpen}} {{/if}}`:\n\n```html\n<script type=\"text/stache\" id=\"app-template\">\n<span ($click)=\"toggleOpen()\">{{folder.name}}</span>\n{{#if isOpen}}\n  {{#if entitiesPromise.isPending}}\n    <div class=\"loading\">Loading</div>\n  {{else}}\n    <ul>\n      {{#each entitiesPromise.value}}\n        <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n          {{#eq type 'file'}}\n            📝 <span>{{name}}</span>\n          {{else}}\n            📁 <span>{{name}}</span>\n          {{/eq}}\n        </li>\n      {{/each}}\n    </ul>\n  {{/if}}\n{{/if}}      \n</script>\n```\n<span line-highlight='3,19'></span>\n## Create an `<a-folder>` custom element to manage folder behavior\n\n### The problem\n\nNow we want to make all the folders able to open and close.  This means creating a `FolderVM` for every folder entity.\n\n### Things to know\n\n- [can-component can.Component] is used to create custom elements like:\n  ```js\n  var MyComponentVM = DefineMap.extend({\n    message: {value: \"Hello There!\"}\n  });\n\n  can.Component.extend({\n    tag: \"my-component\",\n    ViewModel: MyComponentVM,\n    view: can.stache(\"<h1>{{message}}</h1>\");\n  });\n  ```\n  This component will be created anytime a `<my-component>` element is found in the page.  When the component is created, it creates\n  an instance of it's `ViewModel`, in this case `MyComponentVM`.\n\n- You can pass data to a component's `ViewModel` with [can-stache-bindings.toChild {data-bindings}] like:\n\n  ```html\n  <my-component {message}=\"'Hi There'\"/>\n  ```\n\n  This sets `message` on the ViewModel to `'Hi There'`.  You can also send data within stache like:\n\n  ```html\n  <my-component {message}=\"greeting\"/>\n  ```\n  This sets `message` on the ViewModel to what `greeting` is in the stache template.\n\n- A component's [View] is rendered inside the component.  This means that if the following is in a template:\n\n  ```\n  <my-component {message}=\"'Hi There'\"/>\n  ```\n\n  The following will be inserted into the page:\n\n  ```\n  <my-component {message}=\"'Hi There'\"><h1>Hi There</h1></my-component>\n  ```\n\n- `this` in a stache template refers to the current context of a template or section.  \n\n  For example, the `this` in `this.name` refers to the `context` object:\n\n  ```javascript\n  var template = stache(\"{{this.name}}\");\n  var context = {name: \"Justin\"};\n  template(context);\n  ```\n\n  Or, when looping through a list of items, `this` refers to each item:\n\n  ```html\n  {{#each items}}\n    <li>{{this.name}}</li> <!-- this is each item in items -->\n  {{/each}}\n  ```\n\n\n### The solution\n\nThe following:\n\n1. Changes the `app-template` to use the `<a-folder>` component to render the root folder. It\n   passes the root folder as `folder` to the `<a-folder>` component's ViewModel.  It also sets the\n   `<a-folder>` component's ViewModel's `isOpen` property to `true`.\n2. Moves the content that was in `app-template` to the `folder-template` `<script>` tag.\n3. Recursively renders each child folder with `<a-folder {folder}=\"this\"/>`.\n\n```html\n<script type=\"text/stache\" id=\"app-template\">\n  <a-folder {folder}=\"this\" {is-open}=\"true\"/>        <!-- CHANGED -->\n</script>\n\n<!-- CONTENT FROM app-template-->\n<script type=\"text/stache\" id=\"folder-template\">\n<span ($click)=\"toggleOpen()\">{{folder.name}}</span>\n{{#if isOpen}}\n  {{#if entitiesPromise.isPending}}\n    <div class=\"loading\">Loading</div>\n  {{else}}\n    <ul>\n      {{#each entitiesPromise.value}}\n        <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n          {{#eq type 'file'}}\n            📝 <span>{{name}}</span>\n          {{else}}\n            📁 <a-folder {folder}=\"this\"/>            <!-- CHANGED -->\n          {{/eq}}\n        </li>\n      {{/each}}\n    </ul>\n  {{/if}}\n{{/if}}\n</script>\n```\n<span line-highlight='2,17'></span>\nThe following:\n\n1. Defines a custom `<a-folder>` element that manages its behavior with `FolderVM` and uses it to render a `folder-template`\n   template.\n2. Renders the `app-template` with the root `parent` folder instead of the `rootFolderVM`.\n\n```js\nvar FolderVM = can.DefineMap.extend({\n  folder: Entity,\n  entitiesPromise: {\n    value: function(){\n      return Entity.getList({parentId: this.folder.id});\n    }\n  },\n  isOpen: {type: \"boolean\", value: false},\n  toggleOpen: function(){\n    this.isOpen = !this.isOpen;\n  }\n});\n\ncan.Component.extend({\n  tag: \"a-folder\",\n  ViewModel: FolderVM,\n  view: can.stache.from(\"folder-template\")\n});\n\n/*var rootFolderVM = new FolderVM({          // REMOVED\n  folder: folder\n});*/\n\nvar template = can.stache.from(\"app-template\"),\n    frag = template(folder);\n\ndocument.body.appendChild( frag );\n```\n<span line-highlight='14-22,25,only'></span>\nWhen complete, you should have a working file-navigation widget\nlike the completed JSBin above.\n\n\n<script src=\"//static.jsbin.com/js/embed.min.js?3.39.18\"></script>\n\n",
    "description": "This guide walks you through building a file navigation widget.  It takes about 45 minutes to complete.  It was written with\nCanJS 3.4. Checkout the [guides/recipes/file-navigator-simple]\nfor an easier example that produces similar functionality.\n\n\n",
    "name": "guides/recipes/file-navigator-advanced",
    "title": "File Navigator Guide (Advanced)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes/file-navigator-simple": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/file-navigator-simple.md"
    },
    "body": "\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/sodida/embed?js,output\">JS Bin on jsbin.com</a>\n\nClick `ROOT/` to see its files and folders.\n\n> Note: If you don't see any files show up, run the JSBin again. This\n> JSBin uses randomly generated files so it's possible nothing shows up.\n\n__Start this tutorial by cloning the following JSBin__:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/caquxa/embed?html,output\">JS Bin on jsbin.com</a>\n\nThis JSBin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\nThe following sections are broken down into:\n\n- Problem - A description of what the section is trying to accomplish.\n- Things to know - Information about CanJS that is useful for solving the problem.\n- Solution - The solution to the problem.\n- Test it (uncommon) - How to make sure the solution works.\n\n\n## Understand the data\n\nThere is a randomly generated `rootEntityData` variable that contains a nested structure of\nfolders and files.  It looks like:\n\n\n```js\n{\n  \"id\": \"0\",\n  \"name\": \"ROOT/\",\n  \"hasChildren\": true,\n  \"type\": \"folder\",\n  \"children\": [\n    {\n      \"id\": \"1\", \"name\": \"File 1\",\n      \"parentId\": \"0\",\n      \"type\": \"file\",\n      \"hasChildren\": false\n    },\n    {\n      \"id\": \"2\", \"name\": \"File 2\",\n      \"parentId\": \"0\",\n      \"type\": \"file\",\n      \"hasChildren\": false\n    },\n    {\n      \"id\": \"3\", \"name\": \"Folder 3\",\n      \"parentId\": \"0\",\n      \"type\": \"folder\",\n      \"hasChildren\": true,\n      \"children\": [\n        {\n          \"id\": \"4\", \"name\": \"File 4\",\n          \"parentId\": \"3\",\n          \"type\": \"file\",\n          \"hasChildren\": false\n        },\n        {\n          \"id\": \"5\", \"name\": \"File 5\",\n          \"parentId\": \"3\",\n          \"type\": \"file\",\n          \"hasChildren\": false\n        },\n        {\n          \"id\": \"6\", \"name\": \"File 6\",\n          \"parentId\": \"3\",\n          \"type\": \"file\",\n          \"hasChildren\": false\n        },\n        {\n          \"id\": \"7\", \"name\": \"File 7\",\n          \"parentId\": \"3\",\n          \"type\": \"file\",\n          \"hasChildren\": false\n        },\n        {\n          \"id\": \"8\", \"name\": \"Folder 8\",\n          \"parentId\": \"3\",\n          \"type\": \"folder\",\n          \"hasChildren\": false,\n          \"children\": []\n        }\n      ]\n    },\n    {\n      \"id\": \"9\", \"name\": \"File 9\",\n      \"parentId\": \"0\",\n      \"type\": \"file\",\n      \"hasChildren\": false\n    }\n  ]\n}\n```\nNotice that entities have the following properties:\n\n- __id__ - a unique id\n- __name__ - the name of the file or folder\n- __type__ - if this entity a \"file\" or \"folder\"\n- __hasChildren__ - if this entity has children\n- __children__ - An array of the child file and folder entities for this folder\n\n## Render the root folder and its contents\n\n### The problem\n\nLets render `rootEntityData` in the page with its immediate children.\n\n### What you need to know\n\n- CanJS uses [can-stache] to render data in a template\n  and keep it live.  Templates can be authored in `<script>` tags like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-template\">\n    TEMPLATE CONTENT\n  </script>\n  ```\n\n  A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] magic tags to insert data into\n  the HTML output like:\n\n  ```html\n  <script type=\"text/stache\" id=\"app-template\">\n    {{something.name}}\n  </script>\n  ```\n\n- Load a template from a `<script>` tag with [can-stache.from can.stache.from] like:\n  ```js\n  var template = can.stache.from(SCRIPT_ID);\n  ```\n\n- Render the template with data into a documentFragment like:\n\n  ```js\n  var frag = template({\n    something: {name: \"Derek Brunson\"}\n  });\n  ```\n\n- Insert a fragment into the page with:\n\n  ```\n  document.body.appendChild(frag);\n  ```\n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n- Use [can-stache.helpers.each {{#each value}}] to do looping in `can-stache`.\n- Use [can-stache.helpers.is {{#eq value1 value2}}] to test equality in `can-stache`.\n- [can-stache/keys/current {{./key}}] only returns the value in the current scope.\n- Write a `<ul>` to contain all the files.  Within the `<ul>` there should be:\n  - An `<li>` with a className that includes `file` or `folder` and `hasChildren` if the folder has children.\n  - The `<li>` should have `📝 <span>{{FILE_NAME}}</span>` if a file and `📁 <span>{{FOLDER_NAME}}</span>` if a folder.\n\n### The solution\n\nUpdate the `HTML` tab to:\n\n```html\n<script type=\"text/stache\" id=\"entities-template\">\n  <span>{{name}}</span>\n  <ul>\n    {{#each ./children}}\n      <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n        {{#eq type 'file'}}\n          📝 <span>{{name}}</span>\n        {{else}}\n          📁 <span>{{name}}</span>\n        {{/eq}}\n      </li>\n    {{/each}}\n  </ul>\n</script>\n```\n\nUpdate the `JS` tab to:\n\n```js\nvar template = can.stache.from(\"entities-template\");\n\nvar frag = template( rootEntityData );  \n\ndocument.body.appendChild( frag );\n```\n\n## Render all the files and folders\n\n### The Problem\n\nNow lets render all of the files and folders!  This means we want to render the files and folders recursively.  Every time we\nfind a folder, we need to render its contents.\n\n### Things to know\n\n- A template can call out to another registered _partial_ template with with [can-stache.tags.partial {{>PARTIAL_NAME}}] like the following:\n\n  ```html\n  {{>PARTIAL_NAME}}\n  ```\n\n- You can register partial templates with [can-stache.registerPartial can.stache.registerPartial] like the following:\n\n  ```js\n  var template = can.stache.from(\"TEMPLATE_ID\");\n  can.stache.registerPartial( \"PARTIAL_NAME\", template );\n  ```\n\n### The Solution\n\nUpdate the `HTML` tab to:\n\n- Call to an `{{>entities}}` partial.\n\n```html\n<script type=\"text/stache\" id=\"entities-template\">\n  <span>{{name}}</span>\n  <ul>\n    {{#each ./children}}\n      <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n        {{#eq type 'file'}}\n          📝 <span>{{name}}</span>\n        {{else}}\n          📁 {{>entities}}\n        {{/eq}}\n      </li>\n    {{/each}}\n  </ul>\n</script>\n```\n<span line-highlight='9'></span>\nUpdate the `JS` tab to:\n\n - Register the `entities-template` as a partial:\n\n```js\nvar template = can.stache.from(\"entities-template\");\ncan.stache.registerPartial(\"entities\", template );\n\nvar frag = template(rootEntityData);\n\ndocument.body.appendChild( frag );\n```\n<span line-highlight='2'></span>\n## Make the data observable\n\n### The problem\n\nFor rich behavior, we need to convert the raw JS data into typed observable data.  When\nwe change the data, the UI will automatically change.\n\n### Things to know\n\n- [can-define/map/map.extend DefineMap.extend] allows you to define a type by defining the type's\n  properties and the properties' types like:\n\n  ```js\n  Person = can.DefineMap.extend(\"Person\",{\n    name: \"string\",\n    age: \"number\"\n  })\n  ```\n\n  This lets you create instances of that type and listen to changes like:\n\n  ```js\n  var person = new Person({\n    name: \"Justin\",\n    age: 34\n  });\n\n  person.on(\"name\", function(ev, newName){\n    console.log(\"person name changed to \", newName);\n  });\n\n  person.name = \"Kevin\" //-> logs \"entity name changed to Kevin\"\n  ```\n\n- `can.DefineMap` supports an [can-define.types.propDefinition#Array Array shorthand] that allows one to specify a [can-define/list/list can.DefineList] of typed instances like:\n\n  ```js\n  Person = can.DefineMap.extend(\"Person\",{\n    name: \"string\",\n    age: \"number\",\n    addresses: [Address]\n  });\n  ```\n\n  However, if `Address` wasn't immediately available, you could do the same thing like:\n\n  ```js\n  Person = can.DefineMap.extend(\"Person\",{\n    name: \"string\",\n    age: \"number\",\n    addresses: [{\n      type: function(rawData){\n        return new Address(rawData);\n      }\n    }]\n  });\n  ```\n\n\n### The solution\n\nUpdate the `JS` tab to:\n\n- Define an `Entity` type and the type of its properties.\n- Create an instance of the `Entity` type called `rootEntity`\n- Use `rootEntity` to render the template\n\n```js\nvar Entity = can.DefineMap.extend(\"Entity\",{  \n  id: \"string\",\n  name: \"string\",\n  parentId: \"string\",\n  hasChildren: \"boolean\",\n  type: \"string\",\n  children: [{\n    type: function(entity){\n      return new Entity(entity)\n    }\n  }]\n});\n\nvar rootEntity = new Entity(rootEntityData);\n\n\nvar template = can.stache.from(\"entities-template\");\ncan.stache.registerPartial(\"entities\", template );\n\nvar frag = template(rootEntity);\n\ndocument.body.appendChild( frag );\n```\n<span line-highlight='1-14,18'></span>\n### Test it\n\nRun the following the `console` tab:\n\n```js\nrootEntity.name= \"Something New\";\nrootEntity.children.pop();\n```\n\nYou should see the page change automatically.\n\n\n## Make the folders open and close\n\n### The problem\n\nWe want to be able to toggle if a folder is open or closed.\n\n### Things to know\n\n- `can.DefineMap` can specify a default value and a type:\n  ```js\n  var Person = can.DefineMap.extend({\n    address: Address,\n    age: {value: 33, type: \"number\"}\n  });\n  ```\n\n- `can.DefineMap` can also have methods:\n\n  ```js\n  var Person = can.DefineMap.extend({\n    address: Address,\n    age: {value: 33, type: \"number\"},\n    birthday: function(){\n      this.age++;\n    }\n  });\n  ```\n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n\n- Use [can-stache-bindings.event ($EVENT)] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked.\n\n   ```html\n   <div ($click)=\"doSomething()\"> ... </div>\n   ```\n\n### The solution\n\nUpdate the `JS` tab to:\n\n- Add an `isOpen` property to `Entity`.\n- Add a `toggleOpen` method to `Entity`.\n\n```js\nvar Entity = can.DefineMap.extend(\"Entity\",{\n  id: \"string\",\n  name: \"string\",\n  parentId: \"string\",\n  hasChildren: \"boolean\",\n  type: \"string\",\n  children: [{\n    type: function(entity){\n      return new Entity(entity)\n    }\n  }],\n  isOpen: {type: \"boolean\", value: false},\n  toggleOpen: function(){      \n    this.isOpen = !this.isOpen;\n  }\n});\n\nvar rootEntity = new Entity(rootEntityData);\n\nvar template = can.stache.from(\"entities-template\");\ncan.stache.registerPartial(\"entities\", template );\n\nvar frag = template(rootEntity);              \n\ndocument.body.appendChild( frag );\n```\n<span line-highlight='12-15'></span>\nUpdate the `HTML` tab to:\n\n- Call `toggleOpen()` when clicked.\n- Only show the children `{{#if isOpen}}` is true.\n\n```html\n<script type=\"text/stache\" id=\"entities-template\">\n<span ($click)=\"toggleOpen()\">{{name}}</span>\n{{#if isOpen}}              \n  <ul>\n    {{#each ./children}}\n      <li class=\"{{type}} {{#if hasChildren}}hasChildren{{/if}}\">\n        {{#eq type 'file'}}\n          📝 <span>{{name}}</span>\n        {{else}}\n          📁 {{>entities}}      \n        {{/eq}}\n      </li>\n    {{/each}}\n  </ul>\n{{/if}}                        \n</script>\n```\n<span line-highlight='2,3,15'></span>\nWhen complete, you should have a working file-navigation widget\nlike the completed JSBin above.\n\n<script src=\"//static.jsbin.com/js/embed.min.js?3.39.18\"></script>\n\n",
    "description": "This guide walks you through building a simple file navigation widget.  It takes about 25 minutes to complete.  It was written with\nCanJS 3.4. Checkout the [guides/recipes/file-navigator-advanced]\nfor an example that makes AJAX requests for its data and uses [can-component].\n\n\n",
    "name": "guides/recipes/file-navigator-simple",
    "title": "File Navigator Guide (Simple)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/recipes.md"
    },
    "body": "\n\n## File Navigator\n\nThe [guides/recipes/file-navigator-simple] walks through building a simple navigation\nwidget where you can open and close folders.\n\nThe [guides/recipes/file-navigator-advanced] walks through a navigation widget that uses\n[can-connect] to load the data for a folder from a simulated service layer.\n\n![600_457801363](https://cloud.githubusercontent.com/assets/78602/22888969/273617ca-f1cd-11e6-922f-28bd5514b3dd.jpeg)\n\n## TodoMVC with StealJS\n\nThe [guides/recipes/todomvc-with-steal] guide builds the TodoMVC application, like the [guides/todomvc], but using [StealJS](http://stealjs.com) to load modules.  It is designed to be done in a classroom-like setting and includes links\nto keynote and powerpoint presentations for each section.\n\n\n## Weather Report\n\nThe [guides/recipes/weather-report-simple] walks through building a 10 day forecast widget\nusing YQL. The [guides/recipes/weather-report-advanced] extends the simple widget to\nremove imperative code and automatically lookup the users location using the\nbrowser's [geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation) with\nevent streams.\n\n![Weather Report](../../docs/can-guides/commitment/recipes/weather-report/weather-report.png)\n\n",
    "description": "A listing of small examples that are useful for learning CanJS.\n\n",
    "name": "guides/recipes",
    "title": "Recipes",
    "type": "page",
    "parent": "guides/commitment",
    "order": 4,
    "comment": " "
  },
  "guides/atm": {
    "src": {
      "path": "docs/can-guides/experiment/atm/atm.md"
    },
    "body": "\n\n## Overview\n\nCheck out the final app:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/yayupo/10/embed?js,output\">JS Bin on jsbin.com</a>\n\nNotice it has tests at the bottom of the `Output` tab.\n\n## Setup\n\nThe easiest way to get started is to clone the following JS&nbsp;Bin by clicking the __JS&nbsp;Bin__ button on the top left:\n\n<a class=\"jsbin-embed\" href=\"http://justinbmeyer.jsbin.com/meziyu/3/edit?html,js,output\">JS Bin on jsbin.com</a>\n\nThe JS Bin is designed to run both the application and its tests in the `OUTPUT`\ntab.  To set this up, the `HTML` tab:\n\n - Loads QUnit for its testing library.  It also includes the `<div id=\"qunit\"></div>`\n   element where QUnit’s test results will be written to.\n\n - Loads [can.all.js](https://unpkg.com/can/dist/global/can.all.js), which\n   is a script that includes all of CanJS core under a single global `can` namespace.\n\n   Generally speaking, you should not use the global `can` script, but instead you\n   should import things directly with a module loader like [StealJS](http://stealjs.com),\n   WebPack or Browserify.  Read [guides/setup] for instructions on how to set up CanJS in a real app.\n\n - Includes the content for an `app-template` [can-stache] template. This template\n   provides the title for the ATM app and uses the `<atm-machine>` custom [can-component]\n   element that will eventually provide the ATM functionality.\n\nThe `JavaScript` tab is split into two sections:\n\n - `CODE` - The ATM’s models, view-models and component code will go here.\n - `TESTS` - The ATM’s tests will go here.\n\nNormally, your application’s code and tests will be in separate files and loaded\nby different html pages, but we combine them here to fit within JS&nbsp;Bin’s limitations.\n\nThe `CODE` section renders the `app-template` with:\n\n```js\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n```\n\nThe `TESTS` section labels which module will be tested:\n\n```js\nQUnit.module(\"ATM system\", {});\n```\n\n## Mock out switching between pages\n\nIn this section, we will mock out which pages will be shown as the `state`\nof the `ATM` changes.  \n\nUpdate the `HTML` tab to:\n\n - Switch between different pages of the application as the `ATM` view-model’s `state` property changes\n   with [can-stache.helpers.switch].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='12-60,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Create the `ATM` view-model with a `state` property initialized to `readingCard` with [can-define/map/map].\n - Create an `<atm-machine>` custom element with [can-component].\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {});\n\n```\n<span line-highlight='5-13,only'></span>\nWhen complete, you should see the __“Reading Card”__ title.\n\nThis step includes all the potential pages the `state`\nproperty can transition between:\n\n- readingCard\n- readingPin\n- choosingTransaction\n- pickingAccount\n- depositInfo\n- withdrawalInfo\n- successfulTransaction\n- printingReceipt\n\nEach of those states are present in the following state diagram:\n\n<img src=\"../../docs/can-guides/experiment/atm/1-pages-template/state-diagram.png\">\n\nWe’ll build out these pages once we build the `Card` and `Transaction` sub-models that will make building the ATM view model easier.\n\n## Card tests\n\nIn this section, we will:\n\n - Design an API for an ATM `Card`\n - Write out tests for the card.\n\nAn ATM `Card` will take a card `number` and `pin`. It will start out as\nhaving a `state` of  `\"unverified\"`. It will have a `verify` method\nthat will change the `state` to `\"verifying\"`, and if the response is successful,\n`state` will change to `\"verified\"`.\n\nUpdate the `JavaScript` tab to:\n\n- Make the fake data request delay `1ms` by setting [can-fixture.delay] to `1` before every test and\n  restoring it to `2s` after every test runs.\n- Write a test that creates a valid card, calls `.verify()`, and asserts the `state` is `\"verified\"`.\n- Write a test that creates an invalid card, calls `.verify()`, and asserts the `state` is `\"invalid\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\n```\n<span line-highlight='24-70,only'></span>\nWhen complete, you should have a breaking test.  Now let’s make it pass.\n\n## Card model\n\nIn this section, we will:\n\n- Implement the `Card` model so that all the tests pass.\n\nUpdate the `JavaScript` tab to:\n\n- Simulate the `/verifyCard` with [can-fixture]. It will return a successful response if\n  the request body has a `number` and `pin`, or a `400` if not.\n- Use [can-define/map/map] to define the `Card` model, including:\n  - a `number` and a `pin` property.\n  - a `state` property initialized to `unverified` that is not part of the card’s [can-define.types.serialize]d  data.\n  - a `verify` method that posts the card’s data to `/verifyCard` and updates the `state`\n    accordingly.\n\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\n```\n<span line-highlight='5-42,only'></span>\nWhen complete, all tests should pass.\n\nIn this step, you implemented a `Card` model that encapsulates the behavior of its own state.\n\n## Deposit test\n\nIn this section, we will:\n\n - Design an API retrieving `Account`s.\n - Design an API for a `Deposit` type.\n - Write out tests for the `Deposit` type.\n\nAn `Account` will have an `id`, `name`, and `balance`.  We’ll use [can-connect] to add a\n[can-connect/can/map/map.getList] method that retrieves an account given a `card`.\n\nA `Deposit` will take a `card`, an `amount`, and an `account`.  Deposits will start out having\na `state` of `\"invalid\"`.  When the deposit has a `card`, `amount` and `account`, the `state`\nwill change to `\"ready\"`.  Once the deposit is ready, the `.execute()` method will change the state\nto `\"executing\"` and then to `\"executed\"` once the transaction completes.\n\nUpdate the `JavaScript` tab to:\n\n- Create a `deposit` with an `amount` and a `card`.\n- Check that the `state` is `\"invalid\"` because there is no `account`.\n- Use `Account.getList` to get the accounts for the card and:\n  - set the `deposit.accounts` to the first account.\n  - remember the starting `balance`.\n- Use [can-define/map/map.prototype.on] to listen for `state` changes. When `state` is:\n  - `\"ready\"`, `.execute()` the transaction.\n  - `\"executed\"`, verify the new account balance.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='111-151,only'></span>\nWhen complete, the __Deposit__ test should run, but error because _Deposit is not defined_.\n\n> __Optional:__ Challenge yourself by writing the __Withdrawal__ test on your own.  How is it different than the __Deposit__ test?\n\n## Transaction, Deposit, and Withdrawal models\n\nIn this section, we will:\n\n- Implement the `Account` model.\n- Implement a base `Transaction` model and extend it into `Deposit` and\n`Withdrawal` models.\n- Get the __Deposit__ test to pass.\n\nUpdate the `JavaScript` tab to:\n\n- Simulate `/accounts` to return `Account` data with [can-fixture].\n- Simulate `/deposit` to always return a successful result.\n- Simulate `/withdrawal` to always return a successful result.\n- Define the `Account` model to:\n\t- have an `id` property.\n\t- have a `balance` property.\n\t- have a `name` property.\n- Define an `Account.List` type with [can-define/list/list].\n- Connect `Account` and `Account.List` types to the RESTful `/accounts` endpoint using [can-connect/can/base-map/base-map].\n- Define the `Transaction` model to:\n  - have `account` and `card` properties.\n  - have `executing` and `executed` properties that track if the transaction is executing or has executed.\n  - have a `rejected` property that stores the error given for a failed transaction.\n  - have an __abstract__ `ready` property that `Deposit` and `Withdrawal` will implement to return `true`\n    when the transaction is in an executable state.\n  - have a `state` property that reads other stateful properties and returns a string representation\n    of the state.\n  - have an __abstract__ `executeStart` method that `Deposit` and `Withdrawal` will implement to\n    execute the transaction and return a `Promise` that resolves when the transaction is complete.\n  - have an __abstract__ `executeEnd` method that `Deposit` and `Withdrawal` will implement to\n    update the transactions values (typically the `account` balance) if the transaction is successfully completed.\n  - have an `execute` method that calls `.executeStart()` and `executeEnd()` and keeps the stateful\n    properties updated correctly.\n- Define the `Deposit` model to:\n  - have an `amount` property.\n  - implement `ready` to return `true` when the amount is greater than `0` and there’s an `account`\n    and `card`.\n  - implement `executeStart` to `POST` the deposit information to `/deposit`\n  - implement `executeEnd` to update the account balance.\n- Define the `Withdrawal` model to behave in the same way as `Deposit` except that\n  it `POST`s the withdrawal information to `/withdrawal`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='13-31,63-187,only'></span>\nWhen complete, the __Deposit__ tests will pass.\n\n## Reading Card page and test\n\nIn this section, we will:\n\n - Allow the user to enter a card number and go to the __Reading Pin__ page.\n - Add tests to the __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Allow a user to call `cardNumber` with the `<input>`’s `value`.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='20-26,only'></span>\nUpdate the `JavaScript` tab to:\n\n- Declare a `card` property.\n- Derive a `state` property that changes to `\"readingPin\"` when `card` is defined.\n- Add a `cardNumber` that creates a `card` with the provided `number`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\n\t// derived properties\n\tget state(){\n\t\tif(this.card) {\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tQUnit.start();\n});\n\n```\n<span line-highlight='190-205,313-325,only'></span>\nWhen complete, you should be able to enter a card number and see the __Reading Pin__\npage.\n\n## Reading Pin page and test\n\nIn this section, we will:\n\n- Allow the user to enter a pin number and go to the __Choosing Transaction__ page.\n- Add tests to the __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Call `pinNumber` with the `<input>`’s `value`.\n- Disable the `<input>` while the pin is being verified.\n- Show a loading icon while the pin is being verified.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='31-47,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Define an `accountsPromise` property that will contain a list of accounts for the `card`.\n- Define a `transactions` property that will contain a list of transactions for this session.\n- Update `state` to be in the `\"choosingTransaction\"` state when the `card` is verified.\n- Define a `pinNumber` method that updates the `card`’s `pin`, calls `.verify()`,\n  and initializes the `accountsPromise` and `transactions` properties.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Test whether calling `pinNumber` moves the `state` to `\"choosingTransaction\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\n\t// derived properties\n\tget state(){\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null\n\t\t});\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tQUnit.start();\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='192-193,198-200,212-228,346-356,only'></span>\nWhen complete, you should be able to enter a card and pin number and see the __Choosing Transaction__\npage.\n\n## Choosing Transaction page and test\n\nIn this section, we will:\n\n- Allow the user to pick a transaction type and go to the __Picking Account__ page.\n- Add tests to the __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Have buttons for choosing a deposit, withdrawal, or print a receipt and exit.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='52-59,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Define a `currentTransaction` property that when set, adds the previous `currentTransaction`\n  to the list of `transactions`.\n- Update the `state` property to `\"pickingAccount\"` when there is a `currentTransaction`.\n- Update the `exit` method to clear the `currentTransaction` property.\n- Define `chooseDeposit` that creates a `Deposit` and sets it as the `currentTransaction`.\n- Define `chooseWithdraw` that creates a `Withdraw` and sets it as the `currentTransaction`.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Call `.chooseDeposit()` and verify that the state moves to `\"pickingAccount\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\n\t// derived properties\n\tget state(){\n\n\t\tif (this.currentTransaction) {\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null\n\t\t});\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='194-204,209-211,243,246-255,363,382-389,only'></span>\n\n> __Note:__ We will define `printReceiptAndExit` later!\n\n## Picking Account page and test\n\nIn this section, we will:\n\n- Allow the user to pick an account and go to either the  __Deposit Info__ or\n  __Withdrawal Info__ page.\n- Add tests to the __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Write out a _“Loading Accounts…”_ message while the accounts are loading.\n- Write out the accounts when loaded.\n- Call `chooseAccount()` when an account is clicked.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"http://canjs.com/docs/images/loader.gif\"/>\n                    Loading Accounts…\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='64-78,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Change `state` to check if the `currentTransaction` has an `account` and update the\n  value to `\"depositInfo\"` or `\"withdrawalInfo\"`, depending on the `currentTransaction`’s type.\n- Add a `chooseAccount` method that sets the `currentTransaction`’s `account`.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Call `.chooseAccount()` with the first account loaded.\n- Verify the state changes to `\"depositInfo\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\n\t// derived properties\n\tget state(){\n\n\t\tif (this.currentTransaction) {\n\t\t\tif (this.currentTransaction.account) {\n\t\t\t\tif (this.currentTransaction instanceof Deposit) {\n\t\t\t\t\treturn \"depositInfo\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"withdrawalInfo\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null\n\t\t});\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseAccount: function(account) {\n\t\tthis.currentTransaction.account = account;\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tatm.accountsPromise.then(function(accounts){\n\t\t\t\tatm.chooseAccount(accounts[0]);\n\t\t\t});\n\n\t\t} else if (newVal === \"depositInfo\") {\n\n\t\t\tQUnit.ok(true, \"in depositInfo state\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='210-216,264-266,398-407,only'></span>\n## Deposit Info page and test\n\nIn this section, we will:\n\n- Allow the user to enter the amount of a deposit and go to the __Successful Transaction__ page.\n- Add tests to the __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Ask the user how much they would like to deposit into the account.\n- Update `currentTransaction.amount` with an `<input>`’s `value`.\n- If the transaction is executing, show a spinner.\n- If the transaction is not executed:\n  - show a __Deposit__ button that will be\n    active only once the transaction has a value.\n  - show a __cancel__ button that will clear this transaction.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"http://canjs.com/docs/images/loader.gif\"/>\n                    Loading Accounts…\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='83-104,only'></span>\nUpdate the `ATM` view model in the `JavaScript` tab to:\n\n - Change `state` to `\"successfulTransaction\"` if the `currentTransaction` was executed.\n - Add a `removeTransaction` method that removes the `currentTransaction`, which will revert state\n   to `\"choosingTransaction\"`.\n\nUpdate the `ATM basics` test in the `JavaScript` tab to:\n\n- Add an `amount` to the `currentTransaction`.\n- Make sure the `currentTransaction` is `ready` to be executed.\n- Execute the `currentTransaction` and make sure that the `state` stays as `\"depositInfo\"` until\n  the transaction is successful.\n- Verify the state changed to `\"successfulTransaction\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\n\t// derived properties\n\tget state(){\n\n\t\tif (this.currentTransaction) {\n\t\t\tif (this.currentTransaction.state === \"executed\") {\n\t\t\t\treturn \"successfulTransaction\";\n\t\t\t}\n\n\t\t\tif (this.currentTransaction.account) {\n\t\t\t\tif (this.currentTransaction instanceof Deposit) {\n\t\t\t\t\treturn \"depositInfo\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"withdrawalInfo\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null\n\t\t});\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseAccount: function(account) {\n\t\tthis.currentTransaction.account = account;\n\t},\n\tremoveTransaction: function() {\n\t\tthis.currentTransaction = null;\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tatm.accountsPromise.then(function(accounts){\n\t\t\t\tatm.chooseAccount(accounts[0]);\n\t\t\t});\n\n\t\t} else if (newVal === \"depositInfo\") {\n\n\t\t\tQUnit.ok(true, \"in depositInfo state\");\n\t\t\tvar currentTransaction = atm.currentTransaction;\n\t\t\tcurrentTransaction.amount = 120;\n\t\t\tQUnit.ok(currentTransaction.ready, \"we are ready to execute\");\n\t\t\tcurrentTransaction.execute();\n\t\t\tQUnit.equal(atm.state, \"depositInfo\", \"in deposit state until successful\");\n\n\t\t} else if (newVal === \"successfulTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in successfulTransaction state\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='189,210-212,271-273,381,412-423,only'></span>\nWhen complete, you should be able to enter a deposit amount and see that\nthe transaction was successful.\n\n## Withdrawal Info page\n\nIn this section, we will:\n\n- Allow the user to enter the amount of a withdrawal and go to the __Successful Transaction__ page.\n\nUpdate the `HTML` tab to:\n\n - Add a __Withdraw__ page that works very similar to the __Deposit__ page.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"http://canjs.com/docs/images/loader.gif\"/>\n                    Loading Accounts…\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n        <h2>Withdraw</h2>\n    \t<p>\n    \t\tHow much would you like to withdraw\n    \t\tfrom {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"withdrawl\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tWithdraw\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='109-129,only'></span>\nWhen complete, you should be able to enter a withdrawal amount and see that\nthe transaction was successful.\n\n> __Optional:__ Challenge yourself by adding a test for the `withdrawalInfo` state of an `atm` instance.  Consider the progression of states needed to make it to the `withdrawalInfo` state.  How is it different from the __ATM basics__ test we already have?\n\n## Transaction Successful page\n\nIn this section, we will:\n\n- Show the result of the transaction.\n\nUpdate the `HTML` tab to:\n\n- List out the account balance.\n- Add buttons to:\n  - start another transaction, or\n  - print a receipt and exit the ATM (`printReceiptAndExit` will be implemented in the next section).\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"http://canjs.com/docs/images/loader.gif\"/>\n                    Loading Accounts…\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n        <h2>Withdraw</h2>\n    \t<p>\n    \t\tHow much would you like to withdraw\n    \t\tfrom {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"withdrawl\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tWithdraw\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n        <p>\n    \t\t{{currentTransaction.account.name}} has\n    \t\t${{currentTransaction.account.balance}}.\n    \t</p>\n    \t<p>What would you like to do?</p>\n    \t<nav>\n    \t\t<ul>\n    \t\t\t<li ($click)=\"removeTransaction()\">Another transaction</li>\n    \t\t\t<li ($click)=\"printReceiptAndExit()\">Exit</li>\n    \t\t</ul>\n    \t</nav>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='134-144,only'></span>\nWhen complete, you should be able to make a deposit or withdrawal, see the updated account balance,\nthen start another transaction.\n\n## Printing Recipe page and test\n\nIn this section, we will make it possible to:\n\n - See a receipt of all transactions\n - Exit the ATM.  \n\nUpdate the `HTML` tab to:\n\n - List out all the transactions the user has completed.\n - List out the final value of all accounts.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"http://canjs.com/docs/images/loader.gif\"/>\n                    Loading Accounts…\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n        <h2>Withdraw</h2>\n    \t<p>\n    \t\tHow much would you like to withdraw\n    \t\tfrom {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"withdrawl\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tWithdraw\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n        <p>\n    \t\t{{currentTransaction.account.name}} has\n    \t\t${{currentTransaction.account.balance}}.\n    \t</p>\n    \t<p>What would you like to do?</p>\n    \t<nav>\n    \t\t<ul>\n    \t\t\t<li ($click)=\"removeTransaction()\">Another transaction</li>\n    \t\t\t<li ($click)=\"printReceiptAndExit()\">Exit</li>\n    \t\t</ul>\n    \t</nav>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    \t<h3>Transactions</h3>\n    \t<ul>\n    \t\t{{#if transactions.length}}\n    \t\t\t{{#each transactions}}\n    \t\t\t\t<li>{{actionName(this)}} ${{amount}} {{actionPrep(this)}} {{account.name}}</li>\n    \t\t\t{{/each}}\n    \t\t{{else}}\n    \t\t\t<li>None</li>\n    \t\t{{/if}}\n    \t</ul>\n    \t<h3>Accounts</h3>\n    \t<ul>\n    \t\t{{#each accountsPromise.value}}\n    \t\t\t<li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n    \t\t{{/each}}\n    \t</ul>\n    \t<div class='warn'>\n    \t\t<p>\n    \t\t\t<img src=\"http://canjs.com/docs/images/loader.gif\"/>\n    \t\t\tprinting\n    \t\t</p>\n    \t</div>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='149-170,only'></span>\nUpdate the `ATM` view model in the `JavaScript` tab to:\n\n - Add a `printingReceipt` and `receiptTime` property.\n - Change the `state` to `\"printingReceipt\"` when `printingReceipt` is true.\n - Make `.exit` set `printingReceipt` to `null`.\n - Add a `printReceiptAndExit` method that:\n   - clears the current transaction, which will add the currentTransaction to the list of transactions.\n   - sets `printingReceipt` to `true` for `printingReceipt` time.\n\n\nUpdate the `ATM basics` test in the `JavaScript` tab to:\n\n- Shorten the default `receiptTime` so the tests move quickly.\n- Call `printReceiptAndExit` and make sure that the `state` changes to `\"printingReceipt\"` and\n  then to `\"readingCard\"` and ensure that sensitive information is cleared from the ATM.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there’s an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\tprintingReceipt: \"boolean\",\n\treceiptTime: {\n\t\tvalue: 5000,\n\t\ttype: \"number\"\n\t},\n\n\t// derived properties\n\tget state(){\n\t\tif (this.printingReceipt) {\n\t\t\treturn \"printingReceipt\";\n\t\t}\n\t\tif (this.currentTransaction) {\n\t\t\tif (this.currentTransaction.state === \"executed\") {\n\t\t\t\treturn \"successfulTransaction\";\n\t\t\t}\n\n\t\t\tif (this.currentTransaction.account) {\n\t\t\t\tif (this.currentTransaction instanceof Deposit) {\n\t\t\t\t\treturn \"depositInfo\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"withdrawalInfo\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null,\n\t\t\tprintingReceipt: null\n\t\t});\n\t},\n\tprintReceiptAndExit: function() {\n\t\tthis.currentTransaction = null;\n\t\tthis.printingReceipt = true;\n\t\tvar self = this;\n\t\tsetTimeout(function() {\n\t\t\tself.exit();\n\t\t}, this.receiptTime);\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseAccount: function(account) {\n\t\tthis.currentTransaction.account = account;\n\t},\n\tremoveTransaction: function() {\n\t\tthis.currentTransaction = null;\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tatm.accountsPromise.then(function(accounts){\n\t\t\t\tatm.chooseAccount(accounts[0]);\n\t\t\t});\n\n\t\t} else if (newVal === \"depositInfo\") {\n\n\t\t\tQUnit.ok(true, \"in depositInfo state\");\n\t\t\tvar currentTransaction = atm.currentTransaction;\n\t\t\tcurrentTransaction.amount = 120;\n\t\t\tQUnit.ok(currentTransaction.ready, \"we are ready to execute\");\n\t\t\tcurrentTransaction.execute();\n\t\t\tQUnit.equal(atm.state, \"depositInfo\", \"in deposit state until successful\");\n\n\t\t} else if (newVal === \"successfulTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in successfulTransaction state\");\n\t\t\tatm.receiptTime = 100;\n\t\t\tatm.printReceiptAndExit();\n\n\t\t} else if (newVal === \"printingReceipt\") {\n\n\t\t\tQUnit.ok(true, \"in printingReceipt state\");\n\n\t\t} else if (newVal === \"readingCard\") {\n\n\t\t\tQUnit.ok(true, \"in readingCard state\");\n\t\t\tQUnit.ok(!atm.card, \"card is removed\");\n\t\t\tQUnit.ok(!atm.transactions, \"transactions removed\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='189,205-209,213-215,263,266-273,397,437-451,only'></span>\nWhen complete, you have a working ATM!  Cha-ching!\n\n\n\n<script src=\"//static.jsbin.com/js/embed.min.js?3.39.18\"></script>\n\n",
    "description": "\nThis guide will walk you through __building__ and __testing__ an Automated Teller Machine (ATM) application with CanJS’s\n[can-core Core libraries].  You’ll learn how to do test driven development (TDD)\nand manage complex state.  It takes about 2 hours to complete.\n",
    "name": "guides/atm",
    "title": "ATM Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 3,
    "comment": " "
  },
  "guides/chat": {
    "src": {
      "path": "docs/can-guides/experiment/chat/chat.md"
    },
    "body": "\n## Setup\n\nThe easiest way to get started is to clone the following JS&nbsp;Bin by clicking the __JS&nbsp;Bin__ button on the top left:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/weganur/1/edit?html,output\">JS Bin on jsbin.com</a>\n\nThe JS Bin loads [http://getbootstrap.com/ Bootstrap] for its styles and [http://socket.io/ socket.io] for a socket\nlibrary.  It will be connecting to a RESTful and real-time service layer at [https://chat.donejs.com/api/messages].\n\nThe JS Bin also loads [can.js](https://unpkg.com/can/dist/global/can.js), which is a script that includes all of CanJS core under a\nsingle global `can` namespace.\n\nGenerally speaking, you should not use the global `can` script, but instead you\nshould import things directly with a module loader like [StealJS](http://stealjs.com),\nWebPack or Browserify.  In a real app, your code will look like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Message = DefineMap.extend({ ... });\nMessage.List = DefineList.extend({ ... });\n```\n\nNot:\n\n```js\nvar Message = can.DefineMap.extend({ ... });\nMessage.List = can.DefineList.extend({ ... });\n```\n\nRead [guides/setup] for instructions on how to set up CanJS in a real app.\nCheck out [https://donejs.com/Guide.html the DoneJS version of this guide].\n\n\n\n## Hello World\n\nIn this section, we will:\n\n - Show a big “Chat Home” title within a Bootstrap container.\n - Make it so when “Chat Home” is clicked, an exclamation mark (“!”) is added to the end of the title.\n\nIn your JS Bin, update the `HTML` tab to:\n\n - Create a `<script>` tag containing the contents of the `chat-template` template.\n - Have the content insert a `message` value within a responsive Bootstrap container using [can-stache.tags.escaped].\n - Listen for `click` events and call `addExcitement` with [can-stache-bindings.event].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Hello World\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n        {{message}}\n      </h1>\n    </div>\n  </div>\n</div>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='12-22,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Define an application view-model (`AppVM`) type by extending [can-define/map/map]. Its definition includes:\n   - A `message` property that is a [can-define.types string]\n     value [can-define.types.value initialized] to `\"Chat Home\"`.\n   - An `addExcitement` method that adds `\"!\"` to the end of the `message` property.\n - Create an instance of the `AppVM` type (`appVM`).\n - Compile a [can-stache] [can-stache.renderer template renderer] function from the contents of the `<script>` tag.\n - Render that template with `appVM` as a source of data into a [https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment document fragment].\n - Insert the document fragment into the `<body>` tag.\n\n\n```js\nvar AppVM = can.DefineMap.extend({\n\tmessage: {\n\t\ttype: \"string\",\n\t\tvalue: \"Chat Home\"\n\t},\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-15,only'></span>\nWhen complete, you should see a large “Chat Home” title in the `Output` panel.  Click on it and\nthings will get really exciting!\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/chat/1-hello-world/completed.webm\" type=\"video/webm\">\n   <source src=\"../../docs/can-guides/experiment/chat/1-hello-world/completed.ogg\" type=\"video/ogg\">\n</video>\n\nThis step sets up the essential basics of a CanJS application — a\n[can-stache] template rendered with an observable application view model instance.\n\nThe properties and methods the template uses are defined in the `AppVM`\ntype.  The `AppVM` type extends [can-define/map/map].  We\ndefined a `message` and an `addExcitement` method.\n\nWe then created an instance of the `appVM` with the `new` operator. This created\nan object with a `message` property and `addExcitement` method.  For example, adding:\n\n```\nconsole.log(appVM.message)\nappVM.addExcitement();\nconsole.log(appVM.message)\n```\n\nWill print out `\"Chat Home\"` and then `\"Chat Home!\"`.\n\n`DefineMap` instances are observable.  This is why when `message` changes,\nthe template updates automatically.\n\nThe templates are a dialect of [mustache](https://github.com/janl/mustache.js) and [handlebars](https://github.com/wycats/handlebars.js/) syntax.  The\nmustache syntax allows a very terse writing style for the most common\npatterns within templates:\n\n - inserting data with [can-stache.tags.escaped]\n - looping with [can-stache.helpers.each]\n - branching with [can-stache.helpers.if] or [can-stache.helpers.is]\n\n\n\n> __Key take-away:__ You define types like `AppVM` with method and property behaviors.\n> Instances of those types are observable by [can-stache] templates.\n\n\n## Route between two pages\n\nIn this section we will:\n\n - Create a __home page__ and __chat messages page__ that the user can navigate between\n   with links and the browser’s back and forward button.\n\nUpdate the `HTML` tab to:\n\n - Check if the `appVM`’s `page` property is `\"home\"`.  If it is, render the __home\n   page__’s content.  If it’s not, it will render the __chat messages page__’s content with the [can-stache.helpers.else] helper.\n - Use [can-stache.helpers.routeUrl] to create the right link urls so that `page`\n   will be set on `appVM` to either `\"home\"` or `\"chat\"`.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t  \t <h1 class=\"page-header text-center\">\n\t\t \tChat Messages\n\t\t </h1>\n\t\t <h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='16-29,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Add a `page` property that will be updated when the browser’s URL changes.\n - Prevent the `message` property from becoming part of the URL changes by using `serialize: false`.\n - Connect changes in the url to changes in the `appVM` with [can-route.data].\n - Create a pretty routing rule so if the url looks like `\"#!chat\"`, the `page` property of\n   `appVM` will be set to `chat` with [can-route].  If there is nothing in the hash, `page`\n   will be set to `\"home\"`.\n - Initialize the url’s values on `appVM` and set up the two-way connection with [can-route.ready].\n\n\n```js\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\"{page}\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='2,6,15-17,only'></span>\nWhen complete, you should be able to toggle between the two pages.  If you type:\n\n```\nwindow.location.hash\n```\n\nin JS Bin’s console tab after clicking a new page, you will be able to see the hash change between `!#` and `#!chat`.\n\n\nThis step sets up basic routing between different “pages” in an application.\nCanJS’s routing is based on the properties in the application view model.  When\nthose properties change, different content is shown.  \n\nWe connected the application view model to the routing system with [can-route.data can-route.data]\nand initialized that connection with [can-route.ready can-route.ready].\n\nThis makes it so if the `page` property changes, the browser’s url will change.  If the\nbrowser’s url changes, the `page` property changes.  \n\n> __Key take-away:__  [can-route] two-way binds changes in the browser’s url to\nthe application view model and vice versa.  Use changes in\nthe application view model to control which content is shown.\n\n\n## Chat Messages Component\n\nIn this section, we will:\n\n- Define and use a custom `<chat-message>` element that contains the behavior of the __chat messages page__.\n\nUpdate the `HTML` tab to:\n\n- Use the `<chat-messages/>` element.\n- Create a template for the `<chat-messages/>` element that contains the content of the\n  __chat messages page__.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Chat Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='25,32-37,only'></span>\nUpdate the `JavaScript` tab to:\n\n- Define a view model for the custom element (`ChatMessagesVM`).\n- Use [can-component] to define a custom element that will render its `view` template with\n  an instance of its `ViewModel`.\n\n\n```js\nvar ChatMessagesVM = can.DefineMap.extend({\n\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    route: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\"{page}\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-9,only'></span>\nWhen complete, you should see the same behavior as the previous step. You should\nbe able to click back and forth between the two different pages.\n\n\nThis step creates the `<chat-messages>` custom element.  Custom elements are used\nto represent some grouping of related (and typically visual) functionality such as:\n\n - Widgets like `<my-slider>` or `<acme-navigation>`.\n - Pages like `<chat-login>` or `<chat-messages>`.\n\nCustom elements are the macroscopic building blocks of an application.  They\nare the [orchestration pieces](https://en.wikipedia.org/wiki/Orchestration_(computing))\nused to assemble the application into a whole.  \n\nFor example, an application’s template might assemble many custom elements\nto work together like:\n\n```\n{{#if session}}\n  <app-toolbar {(selected-files)}=\"selectedFiles\"/>\n  <app-directory {(selected-files)}=\"selectedFiles\"/>\n  <app-files {(selected-files)}=\"selectedFiles\"/>\n  <app-file-details {(selected-files)}=\"selectedFiles\"/>\n{{else}}\n  <app-login/>\n{{/if}}\n```\n\nBreaking down an application into many isolated and potentially reusable components\nis a critical piece of CanJS software architecture.\n\nCustom elements are defined with [can-component].  Components render their `view`\nwith a `ViewModel` instance.  By default, their `view` only\nhas access to the data in the `ViewModel`.  You can use [can-stache-bindings event and data bindings]\nlike [can-stache-bindings.toChild] and [can-stache-bindings.twoWay] to pass data\nbetween custom elements.\n\n> __Key take-away:__  [can-component] makes custom elements. Break down your application\ninto many bite-sized custom elements.\n\n## List Messages\n\nIn this section, we will:\n\n - Display messages from [https://chat.donejs.com/api/messages](https://chat.donejs.com/api/messages) when `messagesPromise.isResolved`.\n - Show a “Loading…” message while the messages are loading (`messagesPromise.isPending`).\n - Show an error if those messages fail to load (`messagesPromise.isRejected`).\n\nUpdate the `HTML` tab to:\n\n - Check if the messages are in the process of loading and show a loading indicator.\n - Check if the messages failed to load and display the reason for the failure.\n - If messages successfully loaded, list each message’s name and body.  If there\n   are no messages, write out “No messages”.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - List Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\n{{#if messagesPromise.isPending}}\n  <div class=\"list-group-item list-group-item-info\">\n    <h4 class=\"list-group-item-heading\">Loading…</h4>\n  </div>\n{{/if}}\n{{#if messagesPromise.isRejected}}\n  <div class=\"list-group-item list-group-item-danger\">\n    <h4 class=\"list-group3--item-heading\">Error</h4>\n\t<p class=\"list-group-item-text\">{{messagesPromise.reason}}</p>\n  </div>\n{{/if}}\n{{#if messagesPromise.isResolved}}\n  {{#each messagesPromise.value}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group3--item-heading\">{{name}}</h4>\n  \t  <p class=\"list-group-item-text\">{{body}}</p>\n    </div>\n  {{else}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group-item-heading\">No messages</h4>\n    </div>\n  {{/each}}\n{{/if}}\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='38-60,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Define a `Message` type with [can-define/map/map].\n - Define a `Message.List` type that contains `Message` items.\n - Connect the `Message` and `Message.List` type to\n   the RESTful messages service at `https://chat.donejs.com/api/messages`\n   using [can-connect/can/super-map/super-map].\n - Create a `messagesPromise` property on `ChatMessagesVM` that’s\n   [can-define.types.value] is initialized to a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n   that represents the loading of all messages using [can-connect/can/map/map.getList].\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'https://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\"{page}\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-20,23-27,only'></span>\nWhen complete, you should see a list of messages in the __chat messages page__.\n\nThis step creates a `Message` model by first creating the `Message` type\nand then connecting it to a messages service at `https://chat.donejs.com/api/messages`.\n\n### Explanation\n\nThe [can-connect/can/super-map/super-map super-map module] adds [can-connect/can/map/map methods] to the `Message` type that let you:\n\n - Get a list of messages:\n   ```js\n   Message.getList({}).then(function(messages){})\n   ```\n\n - Get a single message:\n   ```js\n   Message.get({id: 5}).then(function(message){})\n   ```\n - Create a message on the server:\n   ```js\n   message = new Message({name: \"You\", body: \"Hello World\"})\n   message.save()\n   ```\n - Update a message on the server:\n   ```js\n   message.body = \"Welcome Earth!\";\n   message.save();\n   ```\n - Delete message on the server:\n   ```js\n   message.destroy();\n   ```\n\nThere are also methods to let you know when a message\n[can-connect/can/map/map.prototype.isNew],\n[can-connect/can/map/map.prototype.isSaving], and\n[can-connect/can/map/map.prototype.isDestroying].\n\nWith the message model created, it’s used to load and list messages on the server.\n\n\n> __Key take-away:__ Create a model for your data’s schema and use it to communicate with a backend server.\n\n## Create Messages\n\nIn this section, we will:\n\n- Add the ability to create messages on the server and have them added to the list of messages.\n\n\nUpdate the `HTML` tab to:\n\n - Create a form to enter a message’s `name` and `body`.\n - When the form is submitted, call `send` on the `ChatMessagesVM` with [can-stache-bindings.event].\n - Connect the first `<input>`’s `value` to the `ChatMessagesVM`’s `name` property with [can-stache-bindings.twoWay].\n - Connect the second `<input>`’s `value` to the `ChatMessagesVM`’s `body` property with [can-stache-bindings.twoWay].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Create Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\n{{#if messagesPromise.isPending}}\n  <div class=\"list-group-item list-group-item-info\">\n    <h4 class=\"list-group-item-heading\">Loading…</h4>\n  </div>\n{{/if}}\n{{#if messagesPromise.isRejected}}\n  <div class=\"list-group-item list-group-item-danger\">\n    <h4 class=\"list-group3--item-heading\">Error</h4>\n\t<p class=\"list-group-item-text\">{{messagesPromise.reason}}</p>\n  </div>\n{{/if}}\n{{#if messagesPromise.isResolved}}\n  {{#each messagesPromise.value}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group3--item-heading\">{{name}}</h4>\n  \t  <p class=\"list-group-item-text\">{{body}}</p>\n    </div>\n  {{else}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group-item-heading\">No messages</h4>\n    </div>\n  {{/each}}\n{{/if}}\n\n<form class=\"row\" ($submit)=\"send(%event)\">\n\t<div class=\"col-sm-3\">\n\t  <input type=\"text\" class=\"form-control\" placeholder=\"Your name\"\n\t\t\t {($value)}=\"name\"/>\n\t</div>\n\t<div class=\"col-sm-6\">\n\t  <input type=\"text\" class=\"form-control\" placeholder=\"Your message\"\n\t\t\t {($value)}=\"body\"/>\n\t</div>\n\t<div class=\"col-sm-3\">\n\t  <input type=\"submit\" class=\"btn btn-primary btn-block\" value=\"Send\"/>\n\t</div>\n</form>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='62-74,only'></span>\nUpdate the `JavaScript` tab to:\n\n- Define a `name` and `body` property on `ChatMessagesVM`.\n- Define a `send` method on `ChatMessagesVM` that creates a new `Message` and sends it to the server.\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'https://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t},\n\tname: \"string\",\n\tbody: \"string\",\n\tsend: function(event) {\n\t    event.preventDefault();\n\n\t\tnew Message({\n\t\t\tname: this.name,\n\t\t\tbody: this.body\n\t\t}).save().then(function(){\n\t\t\tthis.body = \"\";\n\t\t}.bind(this));\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\"{page}\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='28-39,only'></span>\nWhen complete, you will be able to create messages and have them appear in the list.\n\nThis step sets up a form to create a `Message` on the server.\nNotice that the new `Message` automatically appears in the list of messages. This\nis because [can-connect/can/super-map/super-map] adds the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically inserts newly created messages into\nlists that they belong within.  This is one of CanJS’s best features — automatic list management.\n\n> __Key take-away:__ CanJS will add, remove, and update lists for you automatically.\n\n## Real Time\n\nIn this section, we will:\n\n - Listen to messages created by other users and add them to the list of messages.\n\nUpdate the `JavaScript` tab to:\n\n- Create a [http://socket.io/] connection (`socket`).\n- Listen for when messages are created, updated, and destroyed, and call the\n  corresponding [can-connect/real-time/real-time] methods.\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'https://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar socket = io('https://chat.donejs.com');\n\nsocket.on('messages created', function(message){\n\tMessage.connection.createInstance(message);\n});\nsocket.on('messages updated', function(message){\n\tMessage.connection.updateInstance(message);\n});\nsocket.on('messages removed', function(message){\n\tMessage.connection.destroyInstance(message);\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t},\n\tname: \"string\",\n\tbody: \"string\",\n\tsend: function(event) {\n\t    event.preventDefault();\n\n\t\tnew Message({\n\t\t\tname: this.name,\n\t\t\tbody: this.body\n\t\t}).save().then(function(){\n\t\t\tthis.body = \"\";\n\t\t}.bind(this));\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\"{page}\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='22-32,only'></span>\nWhen complete, you can open up the same JS&nbsp;Bin in another window, create a\nmessage, and it will appear in the first JS&nbsp;Bin’s messages list.\n\nThis step connects to a [https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API WebSocket API]\nthat pushes messages when `Message`s are created, updated or destroyed. By calling the\n[can-connect/real-time/real-time] methods when these events happen, CanJS will automatically\nupdate the messages list.\n\n> __Key take-away:__ CanJS will add, remove, and update lists for you automatically.  It’s\nawesome!\n\n## Result\n\nWhen finished, you should see something like the following JS&nbsp;Bin:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/yexezu/3/embed?html,js,output\">JS Bin on jsbin.com</a>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.1\"></script>\n\n",
    "description": "This guide will walk you through building a real-time chat application with CanJS’s [can-core Core libraries].  It takes about 30 minutes to complete.\n\n",
    "name": "guides/chat",
    "title": "Chat Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 1,
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "guides/todomvc": {
    "src": {
      "path": "docs/can-guides/experiment/todomvc/todomvc.md"
    },
    "body": "\n## Setup\n\nThe easiest way to get started is to clone the following JS&nbsp;Bin by clicking the __JS&nbsp;Bin__ button on the top left:\n\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/sasuje/11/embed?html,output\">JS Bin on jsbin.com</a>\n\nThe JS Bin starts\nwith the static HTML and CSS a designer might turn over to a JS developer. We will be\nadding all the JavaScript functionality.\n\nThe JS Bin also loads [can.all.js](https://unpkg.com/can/dist/global/can.all.js), which is a script that includes all of CanJS core, ecosystem, legacy and infrastructure libraries under a\nsingle global `can` namespace.\n\nGenerally speaking, you should not use the global `can` script, but instead you\nshould import things directly with a module loader like [StealJS](http://stealjs.com),\nWebPack or Browserify.  In a real app, your code will look like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({ ... });\nTodo.List = DefineList.extend({ ... });\n```\n\nNot:\n\n```js\nvar Todo = can.DefineMap.extend({ ... });\nTodo.List = can.DefineList.extend({ ... });\n```\n\nRead [guides/setup] for instructions on how to set up CanJS in a real app.\n\n## Create and render the template\n\nIn this section, we will render the markup in a [can-stache] live-bound template.  \n\nUpdate the `HTML` tab to have a `<script>` tag around the html content.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 Start\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n\t\t\t<li class=\"todo\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Do the dishes</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Do the dishes\">\n\t\t\t</li>\n\t\t\t<li class=\"todo completed\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Mow the lawn</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Mow the lawn\">\n\t\t\t</li>\n\t\t\t<li class=\"todo editing\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Pick up dry cleaning</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Pick up dry cleaning\">\n\t\t\t</li>\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>2</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed (1)\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='11,67,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Use [can-stache.from can-stache.from] to load the contents of the `<script>` tag as\n a [can-stache.renderer template renderer function].\n - Render the template with an empty object into a [document fragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment).\n - Insert the fragment into the document’s `<body>` element.\n\nTo load, render, and add this template to the\nbody, add the following to the `JavaScript` tab:\n\n\n```js\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-3,only'></span>\n\nWhen complete, you should see the same content as before.  Only now, it’s\nrendered with a live-bound stache template.  The live binding means that\nwhen the template’s data is changed, it will update automatically. We’ll see\nthat in the next step.\n\n\n## Define the todos type and show the active and complete count\n\nIn this section, we will:\n\n - Create a list of todos and show them.\n - Show the number of active (`complete === true`) and complete todos.\n - Connect a todo’s `complete` property to a checkbox so that when\n   we toggle the checkbox the number of active and complete todos changes.\n\n\nUpdate the `JavaScript` tab to:\n\n - Define a `Todo` type with [can-define/map/map].\n - Define a `Todo.List` type along with an `active` and `complete` property with [can-define/list/list].\n - Create a list of todos and pass those to the template.\n\n\n```js\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\nvar todos = new Todo.List([\n  { id: 5, name: \"mow lawn\", complete: false },\n  { id: 6, name: \"dishes\", complete: true },\n  { id: 7, name: \"learn canjs\", complete: false }\n]);\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todos: todos});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-21,24,only'></span>\nUpdate the `HTML` tab to:\n\n- Use [can-stache.helpers.each `{{#each todos}}`] to loop through every todo.\n- Add `completed` to the `<li>`’s `className` if the `<li>`’s todo is complete.\n- Use [can-stache-bindings.twoWay `{($checked)}`] to two-way bind the checkbox’s `checked` property to its todo’s `complete` property.  \n- Use [can-stache.tags.escaped `{{name}}`] to insert the value todo’s `name` as the content of the `<label>` and\n  `value` of the text `<input/>`.\n- Insert the active and complete number of todos.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create and render the template\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todos}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todos.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todos.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='21-30,35,49,only'></span>\nWhen complete, you should be able to toggle the checkboxes and see the number of\nitems left and the completed count change automatically.  This is because\n[can-stache] is able to listen for changes in observables like [can-define/map/map],\n[can-define/list/list] and [can-compute].\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/2-items-left/completed.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/2-items-left/completed.webm\" type=\"video/webm\">\n</video>\n\n\n## Get todos from the server\n\nIn this section, we will:\n\n - Load todos from a RESTful service.\n - Fake that RESTful service.\n\n\nUpdate the `JavaScript` tab to:\n\n- Define what the RESTful service layer’s parameters are with [can-set.Algebra can-set.Algebra].\n- Create a fake data store that is initialized with data for 3 todos with [can-fixture.store].\n- Trap AJAX requests to `\"/api/todos\"` and provide responses with the data from the fake data store with [can-fixture].\n- Connect the `Todo` and `Todo.List` types to the RESTful `\"/api/todos\"` endpoint using [can-connect/can/super-map/super-map].  This allows you to load, create, update, and destroy todos\non the server.\n- Use [can-connect/can/map/map.getList] to load a list of all todos on the server. The result\n  of `getList` is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves to a `Todo.List` with the todos returned from the fake data store.  That `Promise`\n  is passed to the template as `todosPromise`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-15,33-39,42,only'></span>\nUpdate the `HTML` tab to:\n\n - Use [can-stache.helpers.each `{{#each todosPromise.value}}`] to loop through the promise’s resolved value, which\n   is the list of todos returned by the server.\n - Read the active and completed number of todos from the promise’s resolved value.\n\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create the todos type and get items left working\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='21,35,49,only'></span>\nWhen complete, you’ll notice a 1 second delay before seeing the list of todos as\nthey load for the first time from the fixtured data store. On future page reloads, the\nlist of todos will load immediately.  This is because [can-connect/can/super-map/super-map] adds the [can-connect/fall-through-cache/fall-through-cache] behavior.  The\n[can-connect/fall-through-cache/fall-through-cache] behavior stores loaded data in\n`localStorage`.  Future requests will hit `localStorage` for data first and present that data\nto the user before making a request to the server and updating the original data with\nany changes.  Use `localStorage.clear()` to see the difference.\n\n\n## Destroy todos\n\nIn this section, we will:\n\n - Delete a todo on the server when its destroy button is clicked.\n - Remove the todo from the page after it’s deleted.\n\nUpdate the `HTML` tab to:\n\n - Add `destroying` to the `<li>`’s `className` if the `<li>`’s todo is being destroyed using [can-connect/can/map/map.prototype.isDestroying].\n - Call the `todo`’s [can-connect/can/map/map.prototype.destroy] method when the `<button>` is clicked using [can-stache-bindings.event `($click)`].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Destroy todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\n                    {{#if isDestroying}}destroying{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\" ($click)=\"destroy()\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='22-23,27,only'></span>\nWhen complete, you should be able to delete a todo by clicking its delete button.  After\nclicking the todo, its name will turn red and italic.  Once deleted, the todo will be\nautomatically removed from the page.  \n\nThe deleted todo is automatically removed from the page because [can-connect/can/super-map/super-map] adds the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically updates lists (like `Todo.List`) when instances\nare created, updated or destroyed.  If you’ve created the right [can-set.Algebra], you\nshouldn’t have to manage lists yourself.\n\nFinally, if you click “Run with JS” after deleting a todo, you’ll notice the page temporarily shows fewer items.\nThis is because the fall-through cache’s data is shown before the response from fixtured data store\nis used.\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/4-destroy/completed.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/4-destroy/completed.webm\" type=\"video/webm\">\n</video>\n\n## Create todos\n\nIn this section, we will:\n\n - Create a custom element that can create todos on the server.\n - Use that custom element.\n\nUpdate the `JavaScript` tab to:\n\n - Use [can-define/map/map] to create a `TodoCreateVM` view model with:\n   - A `todo` property that holds a new `Todo` instance.\n   - A `createTodo` method that [can-connect/can/map/map.prototype.save]s the `Todo` instance\n     and replaces it with a new one once saved.\n - Use [can-component] to create a custom `<todo-create>` component that renders the `todo-create-template` template with an instance of the `TodoCreateVM`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n    todo: {Value: Todo},\n    createTodo: function(){\n        this.todo.save().then(function(){\n            this.todo = new Todo();\n        }.bind(this));\n    }\n});\n\ncan.Component.extend({\n    tag: \"todo-create\",\n    view: can.stache.from(\"todo-create-template\"),\n    ViewModel: TodoCreateVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='42-55,only'></span>\nUpdate the `HTML` tab to:\n\n - Create the `todo-create-template` that:\n   - Updates the `todo`’s `name` with the `<input>`’s `value` using [can-stache-bindings.twoWay `{($value)}`].\n   - Calls `createTodo` when the `enter` key is pressed using [can-stache-bindings.event `($enter)`].\n - Use `<todo-create/>`\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\n                    {{#if isDestroying}}destroying{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\" ($click)=\"destroy()\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='11-16,22,only'></span>\nWhen complete, you will be able to create a todo by typing the name of the todo and pressing\n`enter`. Notice that the new todo automatically appears in the list of todos. This\nis also because [can-connect/can/super-map/super-map] adds the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically inserts newly created items into\nlists that they belong within.\n\n\n## List todos\n\nIn this section, we will:\n\n - Define a custom element for showing a list of todos.\n - Use that custom element by passing it the list of fetched todos.\n\nUpdate the `JavaScript` tab to:\n\n - Create a `TodoListVM` view model type which has a `todos` property of type `Todo.List`.\n - Use [can-component] to define a `<todo-list>` element.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List\n});\n\ncan.Component.extend({\n    tag: \"todo-list\",\n    view: can.stache.from(\"todo-list-template\"),\n    ViewModel: TodoListVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='56-64,only'></span>\nUpdate the `HTML` tab to:\n\n - Create the `todo-list-template` that loops through a list of `todos` (instead of `todosPromise.value`).\n - Create a `<todo-list>` element and set its `todos` property to the resolved value of `todosPromise`\n   using [can-stache-bindings.toChild `{todos}`].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - List todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\">\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\">\n      <div class=\"view\">\n        <input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n        <label>{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='18-32,43,only'></span>\nWhen complete, everything should work the same. We didn’t add any new functionality, we\njust moved code around to make it more isolated, potentially reusable, and more maintainable.\n\n\n## Edit todos\n\nIn this section, we will:\n\n - Make it possible to edit a todo’s `name` and save that change to the server.\n\nUpdate the `JavaScript` tab to:\n\n - Update the `TodoListVM` to include the methods and properties needed to edit a todo’s name, including:\n   - An `editing` property of type `Todo` that stores which todo is being edited.\n   - A `backupName` property that stores the todo’s name before being edited.\n   - An `edit` method that sets up the editing state.\n   - A `cancelEdit` method that undos the editing state if in the editing state.\n   - An `updateName` method that updates the editing todo and [can-connect/can/map/map.prototype.save saves] it to the server.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='58-76,only'></span>\n\nUpdate the `HTML` tab to:\n\n - Use the `isEditing` method to add `editing` to the `className` of the `<li>` being edited.\n - When the checkbox changes, update the todo on the server with [can-connect/can/map/map.prototype.save],\n - Call `edit` with the current context using [can-stache/keys/this].\n - Set up the edit input to:\n   - Two-way bind its value to the current todo’s `name` using [can-stache-bindings.twoWay `{($value)}`].\n   - Call `updateName` when the enter key is pressed using [can-stache-bindings.event `($enter)`].\n   - Focus the input when `isEditing` is true using the special [can-util/dom/attr/attr.special.focused] attribute.\n   - Call `cancelEdit` if the input element loses focus.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - List todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   {($checked)}=\"complete\" ($change)=\"save()\">\n        <label ($dblclick)=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        {($value)}=\"name\"\n        ($enter)=\"updateName()\"\n        {$focused}=\"isEditing(this)\"\n        ($blur)=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='22-23,25-27,30-34,only'></span>\nWhen complete, you should be able to edit a todo’s name.\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/7-edit/edit.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/7-edit/edit.webm\" type=\"video/webm\">\n</video>\n\n## Routing\n\nIn this section, we will:\n\n - Make it possible to use the browser’s forwards and backwards buttons to change\n between showing all todos, only active todos, or only completed todos.\n - Add links to change between showing all todos, only active todos, or only completed todos.\n - Make those links bold when the site is currently showing that link.\n\n\nUpdate the `JavaScript` tab to:\n\n - Create a `AppVM` view model type that will manage the behavior of the `todomvc-template` and\n   will update when the url changes.\n   - Define a `filter` property that will be updated when the route changes.\n   - Define a `route` property that will be updated when the route changes.\n   - Define a `todosPromise` property that uses `filter` to determine what data should be\n   loaded from the server.  \n     - If `filter` is falsey, all data will be loaded.  \n     - If `filter` is `\"complete\"`, only complete todos will be loaded.\n     - If `filter` is any other value, the active todos will be loaded.\n - Create an instance of the application view model (`appVM`).\n - Connect changes in the url to changes in the `appVM` with [can-route.data].\n - Create a pretty routing rule so if the url looks like `\"#!active\"`, the `filter` property of\n   `appVM` will be set to `filter` with [can-route].\n - Initialize the url’s values on `appVM` and set up the two-way connection with [can-route.ready].\n - Render the `todomvc-template` with the `appVM`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false})\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar AppVM = can.DefineMap.extend({\n  filter: \"string\",\n  get todosPromise(){\n    if(!this.filter) {\n      return Todo.getList({});\n    } else {\n      return Todo.getList({complete: this.filter === \"complete\"});\n    }\n  }\n});\n\nvar appVM = new AppVM();\ncan.route.data = appVM;\ncan.route(\"{filter}\");\ncan.route.ready();\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='85-99,102,only'></span>\nUpdate the `HTML` tab to:\n\n - Set `href` to a url that will set the desired properties on `appVM` when clicked.\n - Add `class='selected'` to the link if the current route matches the current properties of the `appVM` using [can-stache.helpers.routeCurrent].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   {($checked)}=\"complete\" ($change)=\"save()\">\n        <label ($dblclick)=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        {($value)}=\"name\"\n        ($enter)=\"updateName()\"\n        {$focused}=\"isEditing(this)\"\n        ($blur)=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter=undefined}}\"\n\t\t\t\t\t{{#routeCurrent filter=undefined}}class='selected'{{/routeCurrent}}>All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='active'}}\"\n\t\t\t\t\t{{#routeCurrent filter='active'}}class='selected'{{/routeCurrent}}>Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='complete'}}\"\n\t\t\t\t\t{{#routeCurrent filter='complete'}}class='selected'{{/routeCurrent}}>Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='57-58,61-62,65-66,only'></span>\nWhen complete, you should be able to click the `All`, `Active`, and `Completed` links and\nsee the right data.  When you click from `All` to `Active` or from `All` to `Completed`,\nyou’ll notice that the list of todos is updated immediately, despite a request being made.\nThis is because the [can-connect/fall-through-cache/fall-through-cache] is able to make use\nof the data loaded for the `All` todos page.  It’s able to filter out the `Active` and\n`Completed` data.\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/8-routing/routing.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/8-routing/routing.webm\" type=\"video/webm\">\n</video>\n\n## Toggle all and clear completed\n\nIn this section, we will:\n\n- Make the `toggle-all` button change all todos to complete or incomplete.\n- Make the `clear-completed` button delete all complete todos.\n\nUpdate the `JavaScript` tab to:\n\n- Add the following properties and methods to `Todo.List`:\n  - An `allComplete` property that returns `true` if every todo is complete.\n  - A `saving` property that returns todos that are being saved using [can-connect/can/map/map.prototype.isSaving].\n  - An `updateCompleteTo` method that updates every todo’s `complete` property to the specified value and updates the compute on the server with [can-connect/can/map/map.prototype.save].\n  - A `destroyComplete` method that deletes every complete todo with [can-connect/can/map/map.prototype.destroy].\n- Adds the following properties to `AppVM`:\n  - A `todosList` property that gets its value from the `todosPromise` using an [can-define.types.get asynchronous getter].\n  - An `allChecked` property that returns `true` if every todo is complete.  The property can also be set to `true` or `false` and it will set every todo to that value.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"number\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  },\n  get allComplete(){\n    return this.length === this.complete.length;\n  },\n  get saving(){\n    return this.filter(function(todo){\n      return todo.isSaving();\n    });\n  },\n  updateCompleteTo: function(value){\n    this.forEach(function(todo){\n      todo.complete = value;\n      todo.save();\n    });\n  },\n  destroyComplete: function(){\n    this.complete.forEach(function(todo){\n      todo.destroy();\n    });\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar AppVM = can.DefineMap.extend({\n  filter: \"string\",\n  get todosPromise(){\n    if(!this.filter) {\n      return Todo.getList({});\n    } else {\n      return Todo.getList({complete: this.filter === \"complete\"});\n    }\n  },\n  todosList: {\n    get: function(lastSetValue, resolve){\n      this.todosPromise.then(resolve);\n    }\n  },\n  get allChecked(){\n    return this.todosList && this.todosList.allComplete;\n  },\n  set allChecked(newVal){\n    this.todosList && this.todosList.updateCompleteTo(newVal);\n  }\n});\n\nvar appVM = new AppVM();\ncan.route.data = appVM;\ncan.route(\"{filter}\");\ncan.route.ready();\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='31-49,113-123,only'></span>\nUpdate the `HTML` tab to:\n\n- Cross bind the `toggle-all`’s `checked` property to the `appVM`’s `allChecked` property.\n- Disable the `toggle-all` button while any todo is saving.\n- Call the `Todo.List`’s `destroyComplete` method when the `clear-completed` button is clicked on.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if ./complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   {($checked)}=\"complete\" ($change)=\"save()\">\n        <label ($dblclick)=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        {($value)}=\"name\"\n        ($enter)=\"updateName()\"\n        {$focused}=\"isEditing(this)\"\n        ($blur)=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\"\n          {($checked)}=\"allChecked\"\n          {$disabled}=\"todosList.saving.length\"/>\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter=undefined}}\"\n\t\t\t\t\t{{#routeCurrent filter=undefined}}class='selected'{{/routeCurrent}}>All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='active'}}\"\n\t\t\t\t\t{{#routeCurrent filter='active'}}class='selected'{{/routeCurrent}}>Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='complete'}}\"\n\t\t\t\t\t{{#routeCurrent filter='complete'}}class='selected'{{/routeCurrent}}>Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\"\n            ($click)=\"todosList.destroyComplete()\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='47-49,71-72,only'></span>\nWhen complete, you should be able to toggle all todos `complete` state and\ndelete the completed todos.  You should also have a really good idea how CanJS works!\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/9-toggle/toggle.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/9-toggle/toggle.webm\" type=\"video/webm\">\n</video>\n\n## Result\n\nWhen finished, you should see something like the following JS&nbsp;Bin:\n\n<a class=\"jsbin-embed\" href=\"//jsbin.com/labajog/1/embed?html,js,output\">JS Bin on jsbin.com</a>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?3.39.15\"></script>\n\n",
    "description": "This guide will walk you through building a slightly modified version of [TodoMVC](http://todomvc.com/) with CanJS’s [can-core Core libraries] and [can-fixture]. It takes about 1 hour to complete.\n\n",
    "name": "guides/todomvc",
    "title": "TodoMVC Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 2,
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "can-util/dom/events/attributes/attributes": {
    "type": "module",
    "name": "can-util/dom/events/attributes/attributes",
    "params": [
      {
        "name": "eventName",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 12,
      "codeLine": 33,
      "path": "node_modules/can-util/dom/events/attributes/attributes.js"
    },
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/attributes/attributes\");\nvar el = document.createElement(\"div\");\n\nfunction attributesHandler() {\n\tconsole.log(\"attributes event fired\");\n}\n\nevents.addEventListener.call(el, \"attributes\", attributesHandler, false);\n\nevents.removeEventListener.call(el, \"attributes\", attributesHandler);\n```\n\n",
    "description": "\nAdds a listenable \"attributes\" event to DOM nodes, which fires when\nthe node's attributes change.\n",
    "title": "attributes",
    "types": [
      {
        "type": "events"
      }
    ]
  },
  "can-util/dom/events/delegate/delegate": {
    "type": "module",
    "name": "can-util/dom/events/delegate/delegate",
    "params": [
      {
        "name": "ev",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 17,
      "codeLine": 43,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/delegate/delegate\");\nvar el = document.createElement(\"div\");\nvar sub = document.createElement(\"div\");\nsub.className = \"foo\"\nel.appendChild(sub);\n\nfunction delegateEventsHandler() {\n\tconsole.log(\"delegate event fired\");\n}\n\nevents.addDelegateListener.call(el, \"click\", \".foo\", delegateEventsHandler, false);\n\nevents.removeDelegateListener.call(el, \"click\", \".foo\", delegateEventsHandler);\n```\n\n",
    "description": "\nAdd delegate listeners to DOM events.  Delegated listeners use a selector on an \nancestor element to determine when to fire the event for an item.  This can help \ncases where large numbers of similar DOM nodes are added into a DOM subtree, since\nevent handlers do not have to be attached to each new node.\n",
    "title": "delegateEvents",
    "types": [
      {
        "type": "events"
      }
    ]
  },
  "can-util/dom/events/delegate/delegate.addDelegateListener": {
    "type": "function",
    "name": "can-util/dom/events/delegate/delegate.addDelegateListener",
    "parent": "can-util/dom/events/delegate/delegate",
    "src": {
      "line": 96,
      "codeLine": 109,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "",
    "description": "",
    "title": "events.addDelegateListener",
    "signatures": [
      {
        "code": "events.addDelegateListener(eventType, selector, handler)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of the event to virtually bind to delegates"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "A CSS selector that matches all intended delegates"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The function to call when the event is dispatched\n\nAdd an event as in [can-util/dom/events/events.addEventListener addEventListener] but with a selector\nmatching child nodes (\"delegates\") for which the event should fire.\n\nDelegate events are limited to firing in the bubble phase.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The function to call when the event is dispatched\n\nAdd an event as in [can-util/dom/events/events.addEventListener addEventListener] but with a selector\nmatching child nodes (\"delegates\") for which the event should fire.\n\nDelegate events are limited to firing in the bubble phase.\n"
    }
  },
  "can-util/dom/events/delegate/delegate.removeDelegateListener": {
    "type": "function",
    "name": "can-util/dom/events/delegate/delegate.removeDelegateListener",
    "parent": "can-util/dom/events/delegate/delegate",
    "src": {
      "line": 136,
      "codeLine": 146,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "",
    "description": "",
    "title": "events.removeDelegateListener",
    "signatures": [
      {
        "code": "events.removeDelegateListener(eventType, selector, handler)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of the event to unbind"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "A CSS selector that matches a delegate selector added for this event type"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The function bound as handler when the listener was added\n\nRemove a delegated event added by in [can-util/dom/delegate/delegate.addDelegateListener addDelegateListener] \n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The function bound as handler when the listener was added\n\nRemove a delegated event added by in [can-util/dom/delegate/delegate.addDelegateListener addDelegateListener] \n"
    }
  },
  "can-util/dom/events/inserted/inserted": {
    "src": {
      "line": 4,
      "codeLine": 21,
      "path": "node_modules/can-util/dom/events/inserted/inserted.js"
    },
    "type": "module",
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/inserted/inserted\");\n\nvar foo = document.createElement(\"div\");\n\nvar log = function() { console.log(\"inserted event fired\"); }\nevents.addEventListener.call(foo, \"inserted\", log);\n\ndocument.body.appendChild(foo); // inserted event fired\n\n",
    "description": " \nThis event fires when the bound element is added to the DOM.\n",
    "title": "inserted",
    "types": [
      {
        "type": "events"
      }
    ],
    "name": "can-util/dom/events/inserted/inserted",
    "parent": "can-util/dom/events/events"
  },
  "can-util/dom/events/enter/enter": {
    "name": "can-util/dom/events/enter/enter",
    "type": "module",
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 6,
      "codeLine": 29,
      "path": "node_modules/can-util/dom/events/enter/enter.js"
    },
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nvar input = document.createElement(\"input\");\n\nfunction enterEventHandler() {\n\tconsole.log(\"enter key pressed\");\n}\n\nevents.addEventHandler.call(input, \"enter\", enterEventHandler);\nevents.dispatch.call(input, {\n  type: 'keyup',\n  keyCode: keyCode\n});\n\n\n\n",
    "description": "\nWatches for when enter keys are pressed on a given element\n",
    "title": "enter",
    "types": [
      {
        "type": "events"
      }
    ]
  },
  "can-util/dom/events/make-mutation-event/make-mutation-event": {
    "type": "module",
    "name": "can-util/dom/events/make-mutation-event/make-mutation-event",
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 16,
      "codeLine": 28,
      "path": "node_modules/can-util/dom/events/make-mutation-event/make-mutation-event.js"
    },
    "body": "",
    "description": "\n",
    "title": "makeMutationEvent",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeMutationEvent(specialEventName, mutationNodesProperty)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "specialEventName",
            "description": "the event to handle as a mutation observer-based event"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "mutationNodesProperty",
            "description": "the property of interest in a DOM mutation\n\nThis function provides a simple interface to bind the DOM events interface to the mutation\nobserver interface, by firing an event when a matching mutation is generated by the client\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "mutationNodesProperty",
      "description": "the property of interest in a DOM mutation\n\nThis function provides a simple interface to bind the DOM events interface to the mutation\nobserver interface, by firing an event when a matching mutation is generated by the client\n"
    }
  },
  "can-util/dom/events/radiochange/radiochange": {
    "src": {
      "line": 5,
      "codeLine": 28,
      "path": "node_modules/can-util/dom/events/radiochange/radiochange.js"
    },
    "type": "module",
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/radiochange/radiochange\");\nvar el = document.createElement(\"div\");\n\nfunction radiochangeHandler() {\n\tconsole.log(\"radiochange event fired\");\n}\n\nevents.addEventListener.call(el, \"radiochange\", radiochangeHandler, false);\n\nevents.removeEventListener.call(el, \"radiochange\", radiochangeHandler);\n```\n\n",
    "description": "\nAdds a listenable \"radiochange\" event to DOM nodes, which fires when\nany radio input changes.\n",
    "hide": true,
    "title": "radiochange",
    "types": [
      {
        "type": "events"
      }
    ],
    "name": "can-util/dom/events/radiochange/radiochange",
    "parent": "can-util/dom/events/events"
  },
  "can-util/dom/events/removed/removed": {
    "src": {
      "line": 4,
      "codeLine": 22,
      "path": "node_modules/can-util/dom/events/removed/removed.js"
    },
    "type": "module",
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/removed/removed\");\n\nvar foo = document.createElement(\"div\");\ndocument.body.appendChild(foo);\n\nvar log = function() { console.log(\"removed event fired\"); }\nevents.addEventListener.call(foo, \"removed\", log);\n\ndocument.body.removeChild(foo); // remove event fired\n\n",
    "description": " \nThis event fires when the bound element is detached or destroyed.\n",
    "title": "removed",
    "types": [
      {
        "type": "events"
      }
    ],
    "name": "can-util/dom/events/removed/removed",
    "parent": "can-util/dom/events/events"
  },
  "guides/recipes/todomvc-with-steal": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/todomvc-with-steal/todomvc-with-steal.md"
    },
    "body": "\n## Setup (Framework Overview)\n\n### The problem\n\n- Setup steal to load a basic CanJS application.  A basic CanJS application has:\n  - A [can-define/map/map] ViewModel and an instance of that ViewModel.\n  - A [can-stache] view that is rendered with the instance of the ViewModel.\n- In addition, this application should load the [can-todomvc-test](https://www.npmjs.com/package/can-todomvc-test) module and\n  pass it the application's `ViewModel` instance.\n\n### What you need to know\n\n- To create a new project with StealJS, run:\n\n  ```\n  npm init\n  npm install steal steal-tools steal-css --save-dev\n  ```\n\n- To host static files, install `http-server` and run it like:\n\n  ```\n  npm install http-server -g\n  http-server -c-1\n  ```\n\n- If you load StealJS plugins, add them to your _package.json_ configuration like:\n\n  ```\n  \"steal\": {\n    \"plugins\": [\n      \"steal-css\"\n    ]\n  }\n  ```\n\n- Define a ViewModel type with [can-define/map/map]:\n\n  ```js\n  var DefineMap = require(\"can-define/map/\");\n  var Type = DefineMap.extend({ ... });\n  ```\n\n- Create an instance of a ViewModel by using `new Type(props)`:\n\n  ```js\n  var instance = new Type({ ... });\n  ```\n\n- Load a view with the [steal-stache] plugin like:\n\n  ```js\n  var view = require(\"./path/to/template.stache\");\n  ```\n\n  Note that [steal-stache] is a StealJS plugin and needs to be configured as such.\n\n- Render a view (or `template`) by passing it data.  It returns a document fragment that can  \n  be inserted into the page like:\n\n  ```js\n  var frag = view(appVM);\n  document.body.appendChild(frag);\n  ```\n\n- Use the following HTML that a designer might have provided:\n\n  ```html\n  <section id=\"todoapp\">\n      <header id=\"header\">\n          <h1>Todos</h1>\n          <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n      </header>\n      <section id=\"main\" class=\"\">\n          <input id=\"toggle-all\" type=\"checkbox\">\n          <label for=\"toggle-all\">Mark all as complete</label>\n          <ul id=\"todo-list\">\n              <li class=\"todo\">\n                  <div class=\"view\">\n                      <input class=\"toggle\" type=\"checkbox\">\n                      <label>Do the dishes</label>\n                      <button class=\"destroy\"></button>\n                  </div>\n                  <input class=\"edit\" type=\"text\" value=\"Do the dishes\">\n              </li>\n              <li class=\"todo completed\">\n                  <div class=\"view\">\n                      <input class=\"toggle\" type=\"checkbox\">\n                      <label>Mow the lawn</label>\n                      <button class=\"destroy\"></button>\n                  </div>\n                  <input class=\"edit\" type=\"text\" value=\"Mow the lawn\">\n              </li>\n              <li class=\"todo editing\">\n                  <div class=\"view\">\n                      <input class=\"toggle\" type=\"checkbox\">\n                      <label>Pick up dry cleaning</label>\n                      <button class=\"destroy\"></button>\n                  </div>\n                  <input class=\"edit\" type=\"text\" value=\"Pick up dry cleaning\">\n              </li>\n          </ul>\n      </section>\n      <footer id=\"footer\" class=\"\">\n          <span id=\"todo-count\">\n              <strong>2</strong> items left\n          </span>\n          <ul id=\"filters\">\n              <li>\n                  <a class=\"selected\" href=\"#!\">All</a>\n              </li>\n              <li>\n                  <a href=\"#!active\">Active</a>\n              </li>\n              <li>\n                  <a href=\"#!completed\">Completed</a>\n              </li>\n          </ul>\n          <button id=\"clear-completed\">\n              Clear completed (1)\n          </button>\n      </footer>\n  </section>\n  ```\n\n- Use [can-todomvc-test](https://www.npmjs.com/package/can-todomvc-test) to load the application's\n  styles and run its tests:\n\n  ```js\n  require(\"can-todomvc-test\")(appVM);\n  ```\n\n\n\n### The solution\n\nCreate a folder:\n\n```cmd\nmkdir todomvc\ncd todomvc\n```\n\nHost it:\n\n```\nnpm install http-server -g\nhttp-server -c-1\n```\n\n\nCreate a new project:\n\n```cmd\nnpm init\n```\n\nHit `Enter` to accept the defaults.\n\n\nInstall `steal`, `steal-tool`, and CanJS's core modules:\n\n```cmd\nnpm install steal steal-tools steal-css --save-dev\nnpm install can-define can-stache steal-stache --save\n```\n\n\n\nAdd __steal.plugins__ to _package.json_:\n\n\n```json\n{\n  \"name\": \"todomvc\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"steal\": \"^1.3.0\",\n    \"steal-css\": \"^1.2.1\",\n    \"steal-tools\": \"^1.2.0\"\n  },\n  \"dependencies\": {\n    \"can-define\": \"^1.0.16\",\n    \"can-stache\": \"^3.0.20\",\n    \"steal-stache\": \"^3.0.5\"\n  },\n  \"steal\": {\n    \"plugins\": [\n      \"steal-stache\", \"steal-css\"\n    ]\n  }\n}\n\n```\n<span line-highlight='21-25'></span>\n\nCreate the starting HTML page:\n\n```html\n<!-- index.html -->\n<script src=\"./node_modules/steal/steal.js\"></script>\n```\n\nCreate the application template:\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>{{appName}}</h1>\n\t\t<input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n\t\t\t<li class=\"todo\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Do the dishes</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Do the dishes\">\n\t\t\t</li>\n\t\t\t<li class=\"todo completed\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Mow the lawn</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Mow the lawn\">\n\t\t\t</li>\n\t\t\t<li class=\"todo editing\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Pick up dry cleaning</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Pick up dry cleaning\">\n\t\t\t</li>\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>2</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed (1)\n\t\t</button>\n\t</footer>\n</section>\n\n```\n\nInstall the test harness:\n\n```cmd\nnpm install can-todomvc-test --save-dev\n```\n\nCreate the main app\n\n\n```js\n// index.js\nvar view = require(\"./index.stache\");\nvar DefineMap = require(\"can-define/map/\");\n\n\nvar AppViewModel = DefineMap.extend(\"AppViewModel\",{\n\tappName: \"string\"\n});\n\nvar appVM = window.appVM = new AppViewModel({\n\tappName: \"TodoMVC\"\n});\n\nvar frag = view(appVM);\ndocument.body.appendChild(frag);\n\nrequire(\"can-todomvc-test\")(appVM);\n\n```\n\n## Define Todo type (DefineMap basics)\n\n### The problem\n\n- Define a `Todo` type as the export of  _models/todo.js_, where:\n  - It is a [can-define/map/map] type.\n  - The id or name property values are coerced into a string.\n  - Its `complete` property is a `Boolean` that defaults to `false`.\n  - It has a `toggleComplete` method that flips `complete` to the opposite value.\n\nExample test code:\n\n```js\nvar todo = new Todo({id: 1, name: 2});\nQUnit.equal(todo.id, \"1\", \"id is a string\");\nQUnit.equal(todo.name, \"2\", \"name is a string\");\nQUnit.equal(todo.complete, false, \"complete defaults to false\");\ntodo.toggleComplete();\nQUnit.equal(todo.complete, true, \"toggleComplete works\");\n```\n\n### What you need to know\n\n- [DefineMap Basics Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeUmlrN2p0Yi1qUzg)\n- [can-define/map/map.extend DefineMap.extend] defines a new `Type`.\n- The [can-define.types.type type] behavior defines a property's type like:\n\n  ```js\n  DefineMap.extend({\n      propertyName: {type: \"number\"}\n  })\n  ```\n\n- The [can-define.types.value] behavior defines a property's initial value like:\n\n  ```js\n  DefineMap.extend({\n      propertyName: {value: 3}\n  })\n  ```\n\n- Methods can be defined directly on the prototype like:\n\n  ```js\n  DefineMap.extend({\n      methodName: function(){}\n  })\n  ```\n\n### The solution\n\nUpdate _models/todo.js_ to:\n\n\n```js\n// models/todo.js\nvar DefineMap = require(\"can-define/map/\");\n\nvar Todo = DefineMap.extend(\"Todo\", {\n\tid: \"string\",\n\tname: \"string\",\n\tcomplete: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\ttoggleComplete: function() {\n\t\tthis.complete = !this.complete;\n\t}\n});\n\nmodule.exports = Todo;\n\n```\n\n## Define Todo.List type (DefineList basics)\n\n### The problem\n\n- Define a `Todo.List` type on the export of  _models/todo.js_, where:\n  - It is a [can-define/list/list] type.\n  - The enumerable indexes are coerced into `Todo` types.\n  - Its `.active` property returns a filtered `Todo.List` of the todos that are __not__ complete.\n  - Its `.complete` property returns a filtered `Todo.List` of the todos that are complete.\n  - Its `.allComplete` property true if all the todos are complete.\n\nExample test code:\n\n```js\nQUnit.ok(Todo.List, \"Defined a List\");\nvar todos = new Todo.List([{complete: true},{},{complete: true}]);\nQUnit.ok(todos[0] instanceof Todo, \"each item in a Todo.List is a Todo\");\nQUnit.equal(todos.active.length, 1);\nQUnit.equal(todos.complete.length, 2);\nQUnit.equal(todos.allComplete, false, \"not allComplete\");\ntodos[1].complete = true;\nQUnit.equal(todos.allComplete, true, \"allComplete\");\n```\n\n### What you need to know\n\n- [DefineList Basics Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeRFUzclNhTlRjMDg)\n- [can-define/list/list.extend DefineList.extend] defines a new `ListType`.\n- The [can-define/list/list.prototype.wildcardItems] property defines the behavior of items in a list like:\n\n  ```js\n  DefineList.extend({\n      #: {type: ItemType}\n  })\n  ```\n\n- The [can-define.types.get] behavior defines observable computed properties like:\n\n  ```js\n  DefineMap.extend({\n      propertyName: {\n          get: function(){\n              return this.otherProperty;\n          }\n      }\n  })\n  ```\n\n- [can-define/list/list.prototype.filter] can be used to filter a list into a new list:\n\n  ```js\n  list = new ListType([...]);\n  list.filter(function(item){\n      return test(item);\n  })\n  ```\n\n### The solution\n\nUpdate _models/todo.js_ to the following:\n\n\n```js\n// models/todo.js\nvar DefineMap = require(\"can-define/map/\"),\n\tDefineList = require(\"can-define/list/\");\n\nvar Todo = DefineMap.extend(\"Todo\", {\n\tid: \"string\",\n\tname: \"string\",\n\tcomplete: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\ttoggleComplete: function() {\n\t\tthis.complete = !this.complete;\n\t}\n});\n\nTodo.List = DefineList.extend(\"TodoList\", {\n\t\"#\": Todo,\n\tget active() {\n\t\treturn this.filter({\n\t\t\tcomplete: false\n\t\t});\n\t},\n\tget complete() {\n\t\treturn this.filter({\n\t\t\tcomplete: true\n\t\t});\n\t},\n\tget allComplete() {\n\t\treturn this.length === this.complete.length;\n\t}\n});\n\nmodule.exports = Todo;\n\n```\n<span line-highlight='3,17-32,only'></span>\n## Render a list of todos (can-stache)\n\n### The problem\n\n- Add a `todosList` property to the `AppViewModel` whose default\n  value will be a `Todo.List` with the following data:\n\n  ```js\n  [\n    { name: \"mow lawn\", complete: false, id: 5 },\n    { name: \"dishes\", complete: true, id: 6 },\n    { name: \"learn canjs\", complete: false, id: 7 }\n  ]\n  ```\n\n- Write out an `<li>` for each todo in `todosList`, including:\n  - write the todo's name in the  `<label>`\n  - add `completed` in the `<li>`'s `class` if the todo is `complete`.\n  - check the todo's checkbox if the todo is `complete`.\n\n- Write out the number of items left and completed count in the \"clear completed\" button.\n\n### What you need to know\n\n- [Stache Basics Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeSjVJMTRJdXRXcWs)\n- CanJS uses [can-stache] to render data in a template\n  and keep it live. Templates can be loaded with [steal-stache].\n\n  A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] magic tags to insert data into\n  the HTML output like:\n\n  ```html\n    {{something.name}}\n  ```\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n- Use [can-stache.helpers.each {{#each value}}] to do looping in `can-stache`.\n\n### The solution\n\nUpdate _index.js_ to the following:\n\n\n```js\n// index.js\nvar view = require(\"./index.stache\");\nvar DefineMap = require(\"can-define/map/\");\nvar Todo = require(\"~/models/todo\");\n\nvar AppViewModel = DefineMap.extend(\"AppViewModel\",{\n\tappName: \"string\",\n    todosList: {\n\t\tvalue: function(){\n\t\t\treturn new Todo.List([\n\t\t\t\t{ name: \"mow lawn\", complete: false, id: 5 },\n\t\t\t\t{ name: \"dishes\", complete: true, id: 6 },\n\t\t\t\t{ name: \"learn canjs\", complete: false, id: 7 }\n\t\t\t]);\n\t\t}\n\t}\n});\n\nvar appVM = window.appVM = new AppViewModel({\n\tappName: \"TodoMVC\"\n});\n\nvar frag = view(appVM);\ndocument.body.appendChild(frag);\n\nrequire(\"can-todomvc-test\")(appVM);\n\n```\n<span line-highlight='4,8-16,only'></span>\nUpdate _index.stache_ to the following:\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        {{#if complete}}checked{{/if}}/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='11-21,26,40,only'></span>\n## Toggle a todo's completed state (event bindings) ##\n\n### The problem\n\n- Call `toggleComplete` when a todo's checkbox is clicked upon.\n\n### What you need to know\n\n- [The can-stache-bindings Presentation's](https://drive.google.com/open?id=0Bx-kNqf-wxZeNDd4aTFNU2g1U0k) _DOM Event Bindings_\n- Use [can-stache-bindings.event ($EVENT)] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked.\n\n   ```html\n   <div ($click)=\"doSomething()\"> ... </div>\n   ```\n\n### The solution\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        {{#if complete}}checked{{/if}}\n                        ($click)=\"toggleComplete()\"/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='14-16,only'></span>\n## Toggle a todo's completed state (data bindings) ##\n\n### The problem\n\n- Update a todo's `complete` property when the checkbox's `checked` property changes with [can-stache-bindings.twoWay two-way bindings].\n\n### What you need to know\n\n- [The can-stache-bindings Presentation's](https://drive.google.com/open?id=0Bx-kNqf-wxZeNDd4aTFNU2g1U0k) _DOM Data Bindings_\n- Use [can-stache-bindings.twoWay {($value)}] to setup a two-way binding in `can-stache`.  For example, the following keeps `name` and the input's `value` in sync:\n\n   ```html\n   <input  {($value)}=\"name\"/>\n   ```\n\n### The solution\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        {($checked)}=\"complete\"/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='14-15,only'></span>\n## Define Todo.algebra (can-set)\n\n### The problem\n\n- Create a `set.Algebra` that understand the parameters of the `/api/todos` service layer.  The `/api/todos` service\n  layer will support the following parameters:\n  - `complete` - Specifies a filter on todos' `complete` field.  Examples: `complete=true`, `complete=false`.\n  - `sort` - Specifies the sorted order the todos should be returned.  Examples: `sort=name`.\n  - `id` - Specifies the `id` property to use in `/api/todos/{id}`\n\n  Example:\n\n  ```\n  GET /api/todos?complete=true&sort=name\n  ```\n\nExample test code:\n\n```js\nQUnit.deepEqual( Todo.algebra.difference({}, {complete: true}), {complete: false} );\nQUnit.deepEqual( Todo.algebra.clauses.id, {id: \"id\"} );\n\nvar sorted = Todo.algebra.getSubset({sort: \"name\"}, {}, [\n    { name: \"mow lawn\", complete: false, id: 5 },\n    { name: \"dishes\", complete: true, id: 6 },\n    { name: \"learn canjs\", complete: false, id: 7 }\n]);\nQUnit.deepEqual(sorted, [\n    { name: \"dishes\", complete: true, id: 6 },\n    { name: \"learn canjs\", complete: false, id: 7 },\n    { name: \"mow lawn\", complete: false, id: 5 }\n]);\n```\n\n### What you need to know\n\n- [The can-set Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeV2lVNl9XanhHZ0k)\n- [can-set] provides a way to describe the parameters used in the service layer.  You use it to create\n  a [can-set.Algebra] like:\n\n  ```js\n  var todoAlgebra = new set.Algebra(\n    set.props.boolean(\"completed\"),\n    set.props.id(\"_id\"),\n    set.props.offsetLimit(\"offset\",\"limit\")\n  );\n  ```\n\n  The algebra can then be used to perform comparisons between parameters like:\n\n  ```js\n  todoAlgebra.difference({}, {completed: true}) //-> {completed: false}\n  ```\n\n- Use [can-set.props set.props] to describe the behavior of your set parameters.\n\n### The solution\n\n```\nnpm install can-set --save\n```\n\n\n```js\n// models/todo.js\nvar DefineMap = require(\"can-define/map/\"),\n\tDefineList = require(\"can-define/list/\"),\n\tset = require(\"can-set\");\n\nvar Todo = DefineMap.extend(\"Todo\", {\n\tid: \"string\",\n\tname: \"string\",\n\tcomplete: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\ttoggleComplete: function() {\n\t\tthis.complete = !this.complete;\n\t}\n});\n\nTodo.List = DefineList.extend(\"TodoList\", {\n\t\"#\": Todo,\n\tget active() {\n\t\treturn this.filter({\n\t\t\tcomplete: false\n\t\t});\n\t},\n\tget complete() {\n\t\treturn this.filter({\n\t\t\tcomplete: true\n\t\t});\n\t},\n\tget allComplete() {\n\t\treturn this.length === this.complete.length;\n\t}\n});\n\nTodo.algebra = new set.Algebra(\n\tset.props.boolean(\"complete\"),\n\tset.props.id(\"id\"),\n\tset.props.sort(\"sort\")\n);\n\nmodule.exports = Todo;\n\n```\n<span line-highlight='4,35-39,only'></span>\n## Simulate the service layer (can-fixture) ##\n\n### The problem\n\nSimulate a service layer that handles the following requests and responses:\n\n__GET /api/todos__\n\n```\n-> GET /api/todos\n\n<- {\n    \"data\": [\n      { \"name\": \"mow lawn\", \"complete\": false, \"id\": 5 },\n      { \"name\": \"dishes\", \"complete\": true, \"id\": 6 },\n      { \"name\": \"learn canjs\", \"complete\": false, \"id\": 7 }\n    ]\n}\n```\n\nThis should also support a `sort` and `complete` params like:\n\n```\n-> GET /api/todos?sort=name&complete=true\n```\n\n\n__GET /api/todos/{id}__\n\n```\n-> GET /api/todos/5\n\n<- { \"name\": \"mow lawn\", \"complete\": false, \"id\": 5 }\n```\n\n__POST /api/todos__\n\n```\n-> POST /api/todos\n   {\"name\": \"learn can-fixture\", \"complete\": false}\n\n<- {\"id\": 8}\n```\n\n__PUT /api/todos/{id}__\n\n```\n-> PUT /api/todos/8\n   {\"name\": \"learn can-fixture\", \"complete\": true}\n\n<- {\"id\": 8, \"name\": \"learn can-fixture\", \"complete\": true}\n```\n\n__DELETE /api/todos/{id}__\n\n```\n-> DELETE /api/todos/8\n\n<- {}\n```\n\n### What you need to know\n\n- [The can-fixture Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeekROYmxvTnUtWmM)\n- [can-fixture] - is used to trap AJAX requests like:\n\n  ```js\n  fixture(\"/api/entities\", function(request){\n    request.data.folderId //-> \"1\"\n\n    return {data: [...]}\n  })\n  ```\n\n- [can-fixture.store can-fixture.store] - can be used to automatically filter records if given a [can-set.Algebra].\n\n  ```js\n  var entities = [ .... ];\n  var entitiesStore = fixture.store( entities, entitiesAlgebra );\n  fixture(\"/api/entities/{id}\", entitiesStore);\n\n### The solution\n\n```\nnpm install can-fixture --save\n```\n\nCreate _models/todos-fixture.js_ as follows:\n\n\n```js\n// models/todos-fixture.js\nvar fixture = require(\"can-fixture\");\nvar Todo = require(\"./todo\");\n\nvar todoStore = fixture.store([\n    { name: \"mow lawn\", complete: false, id: 5 },\n    { name: \"dishes\", complete: true, id: 6 },\n    { name: \"learn canjs\", complete: false, id: 7 }\n], Todo.algebra);\n\nfixture(\"/api/todos\", todoStore);\nfixture.delay = 500;\n\nmodule.exports = todoStore;\n\n```\n\n## Connect the Todo model to the service layer (can-connect) ##\n\n### The problem\n\n- Decorate `Todo` with methods so it can get, create, updated, and delete todos at the `/api/todos` service.  Specifically:\n  - `Todo.getList()` which calls `GET /api/todos`\n  - `Todo.getList({id: 5})` which calls `GET /api/todos/5`\n  - `todo.save()` which calls `POST /api/todos` if `todo` doesn't have an `id` or `PUT /api/todos/{id}` if the `todo` has an id.\n  - `todo.destroy()` which calls `DELETE /api/todos/5`\n\n### What you need to know\n\n- [The can-connect Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZebHFWMElNOVEwSlE) up to and including _Migrate 2 can-connect_.\n- [can-connect/can/base-map/base-map] can decorate a `DefineMap` with methods that connect it to a restful URL like:\n\n  ```js\n  baseMap({\n    Map: Type,\n    url: \"URL\",\n    algebra: algebra\n  })\n  ```\n\n### The solution\n\n```\nnpm install can-connect --save\n```\n\n\n```js\n// models/todo.js\nvar DefineMap = require(\"can-define/map/\"),\n\tDefineList = require(\"can-define/list/\"),\n    set = require(\"can-set\"),\n\tconnectBaseMap = require(\"can-connect/can/base-map/\");\n\nvar Todo = DefineMap.extend(\"Todo\", {\n\tid: \"string\",\n\tname: \"string\",\n\tcomplete: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\ttoggleComplete: function() {\n\t\tthis.complete = !this.complete;\n\t}\n});\n\nTodo.List = DefineList.extend(\"TodoList\", {\n\t\"#\": Todo,\n\tget active() {\n\t\treturn this.filter({\n\t\t\tcomplete: false\n\t\t});\n\t},\n\tget complete() {\n\t\treturn this.filter({\n\t\t\tcomplete: true\n\t\t});\n\t},\n\tget allComplete() {\n\t\treturn this.length === this.complete.length;\n\t}\n});\n\nTodo.algebra = new set.Algebra(\n\tset.props.boolean(\"complete\"),\n\tset.props.id(\"id\"),\n\tset.props.sort(\"sort\")\n);\n\nTodo.connection = connectBaseMap({\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: Todo.List,\n\tname: \"todo\",\n\talgebra: Todo.algebra\n});\n\nmodule.exports = Todo;\n\n```\n<span line-highlight='5,42-48,only'></span>\n## List todos from the service layer (can-connect use) ##\n\n\n### The problem\n\nGet all `todos` from the service layer using the \"connected\" `Todo` type.\n\n### What you need to know\n\n- [The can-connect Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZebHFWMElNOVEwSlE) up to and including _Important Interfaces_.\n- [can-connect/can/map/map.getList Type.getList] gets data using the\n  [can-connect/connection.getList connection's getList] and returns a\n  promise that resolves to the `Type.List` of instances:\n\n  ```js\n  Type.getList({}).then(function(list){\n\n  })\n  ```\n- An async [can-define.types.get getter] property behavior can be used\n  to \"set\" a property to an initial value:\n\n  ```js\n  property: {\n      get: function(lastSet, resolve){\n          SOME_ASYNC_METHOD( function callback(data) {\n              resolve(data);\n          });\n      }\n  }\n  ```\n\n### The solution\n\n\n```js\n// index.js\nvar view = require(\"./index.stache\");\nvar DefineMap = require(\"can-define/map/\");\nvar Todo = require(\"~/models/todo\");\nrequire(\"~/models/todos-fixture\");\n\nvar AppViewModel = DefineMap.extend(\"AppViewModel\",{\n\tappName: \"string\",\n    todosList: {\n\t\tget: function(lastSet, resolve){\n\t\t\tTodo.getList({}).then(resolve);\n\t\t}\n\t}\n});\n\nvar appVM = window.appVM = new AppViewModel({\n\tappName: \"TodoMVC\"\n});\n\nvar frag = view(appVM);\ndocument.body.appendChild(frag);\n\nrequire(\"can-todomvc-test\")(appVM);\n\n```\n<span line-highlight='4-5,9-13,only'></span>\n## Toggling a todo's checkbox updates service layer (can-connect use) ##\n\n\n### The problem\n\nUpdate the service layer when a todo's completed status\nchanges. Also, disable the checkbox while the update is happening.\n\n### What you need to know\n\n- Call [can-connect/can/map/map.prototype.save] to update a \"connected\"\n  `Map` instance:\n\n  ```\n  map.save();\n  ```\n\n  `save()` can also be called by an [can-stache-bindings.event] binding.\n\n- [can-connect/can/map/map.prototype.isSaving] returns true when `.save()`\n  has been called, but has not resolved yet.\n\n  ```\n  map.isSaving()\n  ```\n\n\n### The solution\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        {($checked)}=\"complete\"\n                        ($change)=\"save()\"\n                        {$disabled}=\"isSaving()\"/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='16-17,only'></span>\n\n## Delete todos in the page (can-connect use) ##\n\n### The problem\n\nWhen a todo's __destroy__ button is clicked, we need to delete the\ntodo on the server and remove the todo's element from the page. While\nthe todo is being destroyed, add `destroying` to the todo's `<li>`'s `class`\nattribute.\n\n### Things to know\n\n- The remaining parts of the [can-connect Presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZebHFWMElNOVEwSlE), with an emphasis on how [can-connect/real-time/real-time] behavior works.\n- Delete a record on the server with [can-connect/can/map/map.prototype.destroy] like:\n  ```js\n  map.destroy()\n  ```\n\n- [can-connect/can/map/map.prototype.isDestroying] returns true when `.destroy()`\n  has been called, but has not resolved yet.\n\n  ```js\n  map.isDestroying()\n  ```\n\n### The solution\n\n\n```html\n<!-- index.stache -->\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\n                {{#if isDestroying}}destroying{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        {($checked)}=\"complete\"\n                        ($change)=\"save()\"\n                        {$disabled}=\"isSaving()\"/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\" ($click)=\"destroy()\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='13,20,only'></span>\n## Create todos (can-component) ##\n\n### The problem\n\nMake it possible to create a todo, update the service layer\nand show the todo in the list of todos.\n\nThis functionality should be encapsulated by a `<todo-create/>`\ncustom element.\n\n### What you need to know\n\n- [The  can-component presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeMnlHZzB6ZERUSEk) up to and including how to _define a component_.\n- A [can-component] combines a custom tag name, [can-stache] view and a [can-define/map/map] ViewModel like:\n\n  ```js\n  var Component = require(\"can-component\");\n  var view = require(\"./template.stache\");\n  var ViewModel = DefineMap.extend({\n    ...      \n  });\n\n  Component.extend({\n      tag: \"some-component\",\n      view: view,\n      ViewModel: ViewModel\n  });\n  ```\n\n- You can use `($enter)` to listen to when the user hits the __enter__ key.\n- The [can-define.types.ValueConstructor] behavior creates a default value by using `new Value` to initialize the value when\na `DefineMap` property is read for the first time.\n\n  ```js\n  var SubType = DefineMap.extend({})\n  var Type = DefineMap.extend({\n      property: {Value: SubType}\n  })\n\n  var map = new Type();\n  map.property instanceof SubType //-> true\n  ```\n\n- Use [can-view-import] to import a module from a template like:\n\n  ```\n  <can-import from=\"~/components/some-component/\"/>\n  <some-component>\n  ```\n\n\n\n### The solution\n\n```\nnpm install can-component --save\n```\n\nCreate _components/todo-create/todo-create.stache_ as follows:\n\n\n```html\n<!-- components/todo-create/todo-create.stache -->\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n\n```\n\nCreate _components/todo-create/todo-create.js_ as follows:\n\n\n```js\n// components/todo-create/todo-create.js\nvar Component = require(\"can-component\"); // remember to install\nvar DefineMap = require(\"can-define/map/\");\nvar view = require(\"./todo-create.stache\");\nvar Todo = require(\"~/models/todo\");\n\nvar TodoCreateVM = DefineMap.extend({\n\ttodo: {\n\t\tValue: Todo\n\t},\n\tcreateTodo: function() {\n\t\tthis.todo.save().then(function() {\n\t\t\tthis.todo = new Todo();\n\t\t}.bind(this));\n\t}\n});\n\nmodule.exports = Component.extend({\n\ttag: \"todo-create\",\n\tview: view,\n\tViewModel: TodoCreateVM\n});\n\n```\n\nUpdate _index.stache_ to:\n\n\n```html\n<!-- index.stache -->\n<can-import from=\"~/components/todo-create/\"/>\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <todo-create/>\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <ul id=\"todo-list\">\n            {{#each todosList}}\n            <li class=\"todo {{#if complete}}completed{{/if}}\n                {{#if isDestroying}}destroying{{/if}}\">\n                <div class=\"view\">\n                    <input class=\"toggle\" type=\"checkbox\"\n                        {($checked)}=\"complete\"\n                        ($change)=\"save()\"\n                        {$disabled}=\"isSaving()\"/>\n                    <label>{{name}}</label>\n                    <button class=\"destroy\" ($click)=\"destroy()\"></button>\n                </div>\n                <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n            </li>\n            {{/each}}\n        </ul>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='2,6,only'></span>\n## Edit todo names (can-stache-bindings) ##\n\n### The problem\n\nMake it possible to edit a `todos` name by\ndouble-clicking it's label which should reveal\na _focused_ input element.  If the user hits\nthe __enter__ key, the todo should be updated on the\nserver.  If the input loses focus, it should go\nback to the default list view.\n\nThis functionality should be encapsulated by a `<todo-list {todos}/>`\ncustom element.  It should accept a `todos` property that\nis the list of todos that will be managed by the custom element.\n\n\n### What you need to know\n\n- [The can-stache-bindings presentation](https://drive.google.com/open?id=0Bx-kNqf-wxZeNDd4aTFNU2g1U0k) on _data bindings_.\n\n- The [can-util/dom/attr/attr.special.focused] custom attribute can be used to specify when an element should be focused:\n\n  ```html\n  {$focused}=\"shouldBeFocused()\"\n  ```\n\n- Use [can-stache-bindings.toChild] to pass a value from the scope to a component:\n\n  ```\n  <some-component {name-in-component}=\"nameInScope\"/>\n  ```\n\n- [can-stache/keys/this] can be used to get the current context in stache:\n\n  ```\n  <div ($click)=\"doSomethingWith(this)\"/>\n  ```\n\n### The solution\n\nCreate _components/todo-list/todo-list.stache_ as follows:\n\n\n```html\n<!-- components/todo-list/todo-list.stache -->\n<ul id=\"todo-list\">\n\t{{#each todos}}\n    <li class=\"todo {{#if ./complete}}completed{{/if}}\n\t\t{{#if isDestroying}}destroying{{/if}}\n\t\t{{#if isEditing(this)}}editing{{/if}}\">\n\t\t<div class=\"view\">\n\t\t\t<input class=\"toggle\" type=\"checkbox\"\n\t\t\t\t{($checked)}=\"complete\"\n\t\t\t\t($change)=\"save()\"\n\t\t\t\t{$disabled}=\"isSaving()\"/>\n        \t<label ($dblclick)=\"edit(this)\">{{name}}</label>\n        \t<button class=\"destroy\" ($click)=\"destroy()\"></button>\n\t\t</div>\n\t\t<input class=\"edit\" type=\"text\"\n\t        {($value)}=\"name\"\n\t        ($enter)=\"updateName()\"\n\t        {$focused}=\"isEditing(this)\"\n\t        ($blur)=\"cancelEdit()\"/>\n    </li>\n\t{{/each}}\n</ul>\n\n```\n\nCreate _components/todo-list/todo-list.js_ as follows:\n\n\n```js\n// components/todo-list/todo-list.js\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/\");\nvar view = require(\"./todo-list.stache\");\nvar Todo = require(\"~/models/todo\");\n\nvar TodoListVM = DefineMap.extend({\n\ttodos: Todo.List,\n\tediting: Todo,\n\tbackupName: \"string\",\n\tisEditing: function(todo) {\n\t\treturn todo === this.editing;\n\t},\n\tedit: function(todo) {\n\t\tthis.backupName = todo.name;\n\t\tthis.editing = todo;\n\t},\n\tcancelEdit: function() {\n\t\tif (this.editing) {\n\t\t\tthis.editing.name = this.backupName;\n\t\t}\n\t\tthis.editing = null;\n\t},\n\tupdateName: function() {\n\t\tthis.editing.save();\n\t\tthis.editing = null;\n\t}\n});\n\nmodule.exports = Component.extend({\n\ttag: \"todo-list\",\n\tview: view,\n\tViewModel: TodoListVM\n});\n\n```\n\nUpdate _index.stache_ to:\n\n\n```html\n<!-- index.stache -->\n<can-import from=\"~/components/todo-create/\"/>\n<can-import from=\"~/components/todo-list/\"/>\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <todo-create/>\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\">\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <todo-list {todos}=\"todosList\"/>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='3,12,only'></span>\n## Toggle all todos complete state (DefineMap setter) ##\n\n### The problem\n\nMake the \"toggle all\" checkbox work.  It should be\nunchecked if a single todo is unchecked and checked\nif all todos are checked.\n\nWhen the \"toggle all\" checkbox is changed, the\napplication should update every todo to match\nthe status of the \"toggle all\" checkbox.\n\nThe \"toggle all\" checkbox should be disabled if a\nsingle todo is saving.\n\n### What you need to know\n\n- Using [can-define.types.set setters] and [can-define.types.get getters] a virtual property\ncan be simulated like:\n\n  ```js\n  DefineMap.extend({\n      first: \"string\",\n      last: \"string\",\n      get fullName(){\n          return this.first + \" \" + this.last;\n      },\n      set fullName(newValue){\n          var parts = newValue.split(\" \");\n          this.first = parts[0];\n          this.last = parts[1];\n      }\n  })\n  ```\n\n### The solution\n\n\n```js\n// models/todo.js\nvar DefineMap = require(\"can-define/map/\"),\n\tDefineList = require(\"can-define/list/\"),\n    set = require(\"can-set\"),\n\tconnectBaseMap = require(\"can-connect/can/base-map/\");\n\nvar Todo = DefineMap.extend(\"Todo\", {\n\tid: \"string\",\n\tname: \"string\",\n\tcomplete: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\ttoggleComplete: function() {\n\t\tthis.complete = !this.complete;\n\t}\n});\n\nTodo.List = DefineList.extend(\"TodoList\", {\n\t\"#\": Todo,\n\tget active() {\n\t\treturn this.filter({\n\t\t\tcomplete: false\n\t\t});\n\t},\n\tget complete() {\n\t\treturn this.filter({\n\t\t\tcomplete: true\n\t\t});\n\t},\n\tget allComplete() {\n\t\treturn this.length === this.complete.length;\n\t},\n\tget saving() {\n\t\treturn this.filter(function(todo) {\n\t\t\treturn todo.isSaving();\n\t\t});\n\t},\n\tupdateCompleteTo: function(value) {\n\t\tthis.forEach(function(todo) {\n\t\t\ttodo.complete = value;\n\t\t\ttodo.save();\n\t\t});\n\t}\n});\n\nTodo.algebra = new set.Algebra(\n\tset.props.boolean(\"complete\"),\n\tset.props.id(\"id\"),\n\tset.props.sort(\"sort\")\n);\n\nTodo.connection = connectBaseMap({\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: Todo.List,\n\tname: \"todo\",\n\talgebra: Todo.algebra\n});\n\nmodule.exports = Todo;\n\n```\n<span line-highlight='34-44,only'></span>\n\n```js\n// index.js\nvar view = require(\"./index.stache\");\nvar DefineMap = require(\"can-define/map/\");\nvar Todo = require(\"~/models/todo\");\nrequire(\"~/models/todos-fixture\");\n\nvar AppViewModel = DefineMap.extend(\"AppViewModel\",{\n\tappName: \"string\",\n    todosList: {\n\t\tget: function(lastSet, resolve){\n\t\t\tTodo.getList({}).then(resolve);\n\t\t}\n\t},\n\tget allChecked() {\n\t\treturn this.todosList && this.todosList.allComplete;\n\t},\n\tset allChecked(newVal) {\n\t\tthis.todosList && this.todosList.updateCompleteTo(newVal);\n\t}\n});\n\nvar appVM = window.appVM = new AppViewModel({\n\tappName: \"TodoMVC\"\n});\n\nvar frag = view(appVM);\ndocument.body.appendChild(frag);\n\nrequire(\"can-todomvc-test\")(appVM);\n\n```\n<span line-highlight='14-19,only'></span>\n\n```html\n<!-- index.stache -->\n<can-import from=\"~/components/todo-create/\"/>\n<can-import from=\"~/components/todo-list/\"/>\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <todo-create/>\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\"\n            {($checked)}=\"allChecked\"\n            {$disabled}=\"todosList.saving.length\"/>\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <todo-list {todos}=\"todosList\"/>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{todosList.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a class=\"selected\" href=\"#!\">All</a>\n            </li>\n            <li>\n                <a href=\"#!active\">Active</a>\n            </li>\n            <li>\n                <a href=\"#!completed\">Completed</a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\">\n            Clear completed ({{todosList.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='10-12,only'></span>\n## Setup routing (can-route) ##\n\nMake it so that the following urls display the corresponding\ntodos:\n\n - `#!` or ` ` - All todos\n - `#!active` - Only the incomplete todos\n - `#!complete` - Only the completed todos\n\nAlso, the _All_, _Active_, and _Completed_ buttons should\nlink to those pages and a `class='selected'` property should\nbe added if they represent the current page.\n\n\n### What you need to know\n\n- [can-route] is used to connect a `DefineMap`'s properties\n  to the URL.  This is done with [can-route.data] like:\n\n  ```js\n  route.data = new AppViewModel();\n  ```\n\n- [can-route] can create pretty routing rules.  For example,\n  if `#!login` should set the `page` property of the\n  `AppViewModel` to `\"login\"`, use `route()` like:\n\n  ```js\n  route(\"{page}\");\n  ```\n\n- [can-route.ready] initializes the connection between the\n  url and the `AppViewModel`.  After you've created all\n  your application's pretty routing rules, call it like:\n\n  ```js\n  route.ready()\n  ```\n\n- The [can-stache/helpers/route] module provides helpers\n  that use [can-route].  \n\n  [can-stache.helpers.routeCurrent]\n  returns truthy if the current route matches its first parameters properties.\n\n  ```html\n  {{#if routeCurrent(page='login',true)}}\n    You are on the login page.\n  {{/if}}\n  ```\n\n  [can-stache.helpers.routeUrl] returns a url that will\n  set its first parameters properties:\n\n  ```\n  <a href=\"{{routeUrl page='login'}}\">Login</a>\n  ```\n\n### The solution\n\n```\nnpm install can-route --save\n```\n\n\n```js\n// index.js\nvar view = require(\"./index.stache\");\nvar DefineMap = require(\"can-define/map/\");\nvar Todo = require(\"~/models/todo\");\nvar route = require(\"can-route\");\nrequire(\"~/models/todos-fixture\");\n\nvar AppViewModel = DefineMap.extend(\"AppViewModel\", {\n\tappName: {type: \"string\", serialize: false},\n\tfilter: \"string\",\n\tallTodos: {\n\t\tget: function(lastSet, resolve){\n\t\t\tTodo.getList({}).then(resolve);\n\t\t}\n\t},\n\tget todosList() {\n\t\tif(this.allTodos) {\n\t\t\tif(this.filter === \"complete\") {\n\t\t\t\treturn this.allTodos.complete;\n\t\t\t} else if(this.filter === \"active\") {\n\t\t\t\treturn this.allTodos.active;\n\t\t\t} else {\n\t\t\t\treturn this.allTodos;\n\t\t\t}\n\t\t}\n\t},\n\tget allChecked() {\n\t\treturn this.todosList && this.todosList.allComplete;\n\t},\n\tset allChecked(newVal) {\n\t\tthis.todosList && this.todosList.updateCompleteTo(newVal);\n\t}\n});\n\nvar appVM = window.appVM = new AppViewModel({\n\tappName: \"TodoMVC\"\n});\n\nroute.data = appVM;\nroute(\"{filter}\");\nroute.ready();\n\nvar frag = view(appVM);\ndocument.body.appendChild(frag);\n\nrequire(\"can-todomvc-test\")(appVM);\n\n```\n<span line-highlight='5,9,11-26,39-41,only'></span>\n\n```html\n<!-- index.stache -->\n<can-import from=\"~/components/todo-create/\"/>\n<can-import from=\"~/components/todo-list/\"/>\n<can-import from=\"can-stache/helpers/route\"/>\n<section id=\"todoapp\">\n    <header id=\"header\">\n        <h1>{{appName}}</h1>\n        <todo-create/>\n    </header>\n    <section id=\"main\" class=\"\">\n        <input id=\"toggle-all\" type=\"checkbox\"\n          {($checked)}=\"allChecked\"\n          {$disabled}=\"todosList.saving.length\"/>\n        <label for=\"toggle-all\">Mark all as complete</label>\n        <todo-list {todos}=\"todosList\"/>\n    </section>\n    <footer id=\"footer\" class=\"\">\n        <span id=\"todo-count\">\n            <strong>{{allTodos.active.length}}</strong> items left\n        </span>\n        <ul id=\"filters\">\n            <li>\n                <a href=\"{{routeUrl filter=undefined}}\"\n                    {{#routeCurrent filter=undefined}}class='selected'{{/routeCurrent}}>\n                    All\n                </a>\n            </li>\n            <li>\n                <a href=\"{{routeUrl filter='active'}}\"\n                    {{#routeCurrent filter='active'}}class='selected'{{/routeCurrent}}>\n                    Active\n                </a>\n            </li>\n            <li>\n                <a href=\"{{routeUrl filter='complete'}}\"\n                    {{#routeCurrent filter='complete'}}class='selected'{{/routeCurrent}}>\n                    Completed\n                </a>\n            </li>\n        </ul>\n        <button id=\"clear-completed\"\n            ($click)=\"allTodos.destroyComplete()\">\n            Clear completed ({{allTodos.complete.length}})\n        </button>\n    </footer>\n</section>\n\n```\n<span line-highlight='4,23-26,29-32,35-38,only'></span>\n",
    "description": "This guide walks through building TodoMVC with StealJS.\n\n",
    "name": "guides/recipes/todomvc-with-steal",
    "title": "TodoMVC with StealJS",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes/playlist-editor": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/playlist-editor/playlist-editor.md"
    },
    "body": "\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/xiponom/12/embed?output\">JS Bin on jsbin.com</a>\n\nTo use the widget:\n\n1. _Click_ __Sign In__ to give access to the app to create playlists on your behalf.\n2. _Type_ search terms in __Search for videos__ and hit _enter_.\n3. _Drag_ and _drop_ those videos into the playlist area (__Drag video here__).\n4. _Click_ __Create Playlist__.\n5. _Enter_ a name in the popup.\n6. _Navigate_ to your [YouTube](https://www.youtube.com/) channel to verify the playlist was created.\n\n__Start this tutorial by cloning the following JSBin__:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/ducabam/2/embed?html,output\">JS Bin on jsbin.com</a>\n\nThis JSBin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\nThe following sections are broken down into:\n\n- Problem — A description of what the section is trying to accomplish.\n- Things to know — Information about CanJS that is useful for solving the problem.\n- Solution — The solution to the problem.\n\n## Setup CanJS and Load Google API\n\n### The problem\n\nIn this section, we will:\n\n1. Load Google's JS API client, `gapi`, and initialize it to make requests on behalf of\n   the registered \"CanJS Playlist\" app.\n2. Setup a basic CanJS application.\n3. Use the basic CanJS application to show when Google's JS API has finished loading.\n\n### What you need to know\n\n- The preferred way of loading Google's JS API is with an `async` script tag like:\n\n  ```html\n  <script async defer src=\"https://apis.google.com/js/api.js\"\n    onload=\"this.onload=function(){}; googleScriptLoaded();\"\n    onreadystatechange=\"if (this.readyState === 'complete') this.onload();\">\n  </script>\n  ```\n\n  The `async` attribute allows other JS to execute while the `api.js` file is loading.\n  Once complete, this will call a `googleScriptLoaded` function.\n\n- Once `api.js` is loaded, it adds the   [gapi](https://developers.google.com/api-client-library/javascript/reference/referencedocs)\n  object to the window.  This is Google's JS API.  It can be used to load other APIs that extend the `gapi` library.\n\n  The following can be used to load the OAuth2 GAPI libraries:\n\n  ```js\n  gapi.load('client:auth2', completeCallback);\n  ```\n\n  Once this functionality is loaded, we can tell `gapi` to make requests on behalf of a registered\n  application.  In this case, the following keys enable this client to make requests on behalf of the\n  \"CanJS Playlist\" application:\n\n  ```js\n  gapi.client.init({\n\t  'apiKey': 'AIzaSyAbHbOuFtJRvTX731PQXGSTy59eh5rEiE0',\n      'clientId': '764983721035-85cbj35n0kmkmrba10f4jtte8fhpst84.apps.googleusercontent.com',\n      'discoveryDocs': [ 'https://www.googleapis.com/discovery/v1/apis/youtube/v3/rest' ],\n      'scope': 'https://www.googleapis.com/auth/youtube'\n  }).then( completeCallback )\n  ```\n\n  To use your own key, you can follow the instructions [here](https://developers.google.com/youtube/v3/getting-started). This is not required to complete this guide.\n\n- Instead of callbacks, CanJS favors [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) to manage\n  asynchronous behavior. A promise can be created like:\n\n  ```js\n  var messagePromise = new Promise(function(resolve, reject){\n    setTimeout(function(){\n\t\tresolve(\"Hello There\")\n\t},1000)\n  });\n  ```\n\n  `resolve` should be called once the promise has a value.  `reject` should be called\n  if something goes wrong (like an error).  We say the `messagePromise` _resolves_ with\n  `\"Hello There\"` after one second.\n\n  Anyone can listen to when `messagePromise` resolves with a value like:\n\n  ```js\n  messagePromise.then(function(messageValue){\n\t  messageValue //-> \"Hello There\"\n  });\n  ```\n\n  CanJS can use promises in its [can-stache] templates.  More on that below.\n\n- A basic CanJS application is a live-bound template (or view) rendered with a ViewModel.\n\n- A [can-stache] template is used to render data into a document fragment:\n\n  ```js\n  var template = can.stache(\"<h1>{{message}}</h1>\");\n  var frag = template({message: \"Hello World\"});\n  frag //-> <h1>Hello World</h1>\n  ```\n\n- Load a template from a `<script>` tag with [can-stach.from can.stache.from] like:\n\n  ```js\n  var template = can.stache.from(SCRIPT_ID);\n  ```  \n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n- `Promise`s are observable in `can-stache`.  Given a promise `somePromise`, you can:\n  - Check if the promise is loading like: `{{#if somePromise.isPending}}`.\n  - Loop through the resolved value of the promise like: `{{#each somePromise.value}}`.\n\n\n- [can-define/map/map can.DefineMap] can be used to define the behavior of observable objects like:\n\n  ```js\n  var Type = can.DefineMap.extend({\n\t  message: \"string\"\n  });\n  ```\n\n- Instances of these [can-define/map/map can.DefineMap] types are often used\n  as a ViewModel that controls the behavior of a [can-stache] template (or\n  [can-component]).\n\n  ```js\n  var PlaylistVM = can.DefineMap.extend({\n\t  message: \"string\"\n  });\n\n  var messageVM = new PlaylistVM();\n  var frag = template(messageVM)\n  ```\n\n- `can.DefineMap` can specify a default value and a type:\n  ```js\n  var PlaylistVM = can.DefineMap.extend({\n    count: {value: 33}\n  });\n  new PlaylistVM().count //-> 33\n  ```\n\n\n### The solution\n\nUpdate the `HTML` tab to:\n\n> Note: Please use your own `clientId` if you use this code outside this guide.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.7 - Playlist Editor Final\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    <div>Loaded Google API</div>\n  {{/if}}\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://donejs.com/static/jquerypp.js\"></script>\n<script src=\"https://unpkg.com/can@3/dist/global/can.all.js\"></script>\n\n<script>\nvar googleScriptLoaded;\nvar googleApiLoadedPromise = new Promise(function(resolve){\n  googleScriptLoaded = function(){\n    gapi.load('client:auth2', function() {\n\t\tgapi.client.init({\n\t\t\t'apiKey': 'AIzaSyBcnGGOryOnmjUC09T78VCFEqRQRgvPnAc',\n\t\t\t'clientId': '764983721035-85cbj35n0kmkmrba10f4jtte8fhpst84.apps.googleusercontent.com',\n\t\t\t'discoveryDocs': [ 'https://www.googleapis.com/discovery/v1/apis/youtube/v3/rest' ],\n\t\t\t'scope': 'https://www.googleapis.com/auth/youtube'\n\t\t}).then(resolve);\n\t});\n  }\n})\n</script>\n\n<script async defer src=\"https://apis.google.com/js/api.js\"\n\tonload=\"this.onload=function(){}; googleScriptLoaded();\"\n\tonreadystatechange=\"if (this.readyState === 'complete') this.onload();\">\n</script>\n\n</body>\n</html>\n\n```\n\nUpdate the `JS` tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  }\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n\n\n\n\n\n## Sign in and out\n\n### The problem\n\nIn this section, we will:\n\n1. Show a `Sign In` button that signs a person into their google account.\n2. Show a `Sign Out` button that signs a person out of their google account.\n3. Automatically know via google's API when the user signs in and out, and update the\n   page accordingly.\n4. Show a welcome message with the user's given name.\n\n### What you need to know\n\n- Once the Google API has been fully loaded, information about the\n  currently authenticated user can be found in the `googleAuth` object.  This\n  can be retrieved like:\n\n  ```js\n  googleApiLoadedPromise.then(function(){\n\t  var googleAuth = gapi.auth2.getAuthInstance()\n  });\n  ```\n\n  With `googleAuth`, you can:\n\n  - Know if someone is signed in: `googleAuth.isSignedIn.get()`\n  - Sign someone in: `googleAuth.signIn()`\n  - Sign someone out: `googleAuth.signOut()`\n  - Listen to when someone's signedIn status changes: `googleAuth.isSignedIn.listen(callback)`\n  - Get the user's name: `googleAuth.currentUser.get().getBasicProfile().getGivenName()`\n\n\n\n\n- [ES5 Getter Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) can\n  be used to define a `DefineMap` property that changes when another property changes.  For example,\n  the following defines an `signedOut` property that is the opposite of the `signedIn` property:\n\n  ```js\n  DefineMap.extend({\n    signedIn: \"boolean\",\n    get signedOut(){\n      return !this.signedIn;\n    }\n  });\n  ```\n\n- Use [can-define.types.get asynchronous getters] to get data from asynchronous sources.  For example:\n\n  ```js\n  var PlaylistVM = can.DefineMap.extend({\n    property: {\n      get: function(lastSet, resolve) {\n        apiLoadedPromise.then(function(){\n\t\t\tresolve( api.getValue() );\n\t\t})\n      }\n    }\n  });\n  ```\n\n- DefineMap's `init` method can be used to perform initialization behavior.  For example,\n  the following might initialize `googleApiLoadedPromise`:\n\n  ```js\n  DefineMap.extend({\n\t  init: function(){\n\t\t  this.googleApiLoadedPromise = googleApiLoadedPromise;\n\t  },\n\t  googleApiLoadedPromise: \"any\"\n  })\n  ```\n\n- `DefineMap`'s on [can-define/map/map.prototype.on] lets you listen on changes in a DefineMap.\n  This can be used to change values when other values change.  The following will increment\n  `nameChange` everytime the `name` property changes:\n\n  ```js\n  DefineMap.extend({\n\t  init: function(){\n\t\t  var self = this;\n\t\t  self.on(\"name\", function(){\n\t\t      self.nameChange++;\t  \n\t\t  })\n\t  },\n\t  name: \"string\",\n\t  nameChange: \"number\"\n  })\n  ```\n\n  > NOTE: EventStreams provide a much better way of doing this.  Check out [can-define-stream-kefir].\n\n- Use [can-stache-bindings.event ($EVENT)] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `sayHi()` when the `<div>` is clicked.\n\n   ```html\n   <div ($click)=\"sayHi()\"> … </div>\n   ```\n\n### The solution\n\nUpdate the template in the `HTML` tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n\t  Welcome {{givenName}}! <button ($click)=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n\t  <button ($click)=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n  {{/if}}\n</script>\n\n```\n<span line-highlight='5-9,only'></span>\nUpdate the `JS` tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  }\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='2-11,15-26,only'></span>\n\n\n\n## Search for videos ##\n\n### The problem\n\nIn this section, we will:\n\n1. Create a search `<input>` where a user can type a search query.\n2. When the user types more than 2 characters, get a list of video search results and display\n   them to the user.\n\n### What you need to know\n\n- Use [can-stache-bindings.twoWay {($value)}] to setup a two-way binding in `can-stache`.  For example, the following keeps `searchQuery` and the input's `value` in sync:\n\n   ```html\n   <input {($value)}=\"searchQuery\"/>\n   ```\n\n- Use `gapi.client.youtube.search.list` to search YouTube like:\n\n  ```js\n  var googlePromise = gapi.client.youtube.search.list({\n    q: \"dogs\",\n    part: 'snippet',\n    type: 'video'\n  }).then(function(response){\n    response //-> {\n\t// result: {\n\t//   items: [\n\t//     {\n\t//       id: {videoId: \"ajsadfa\"},\n\t//       snippet: {\n\t//         title: \"dogs\",\n\t//         thumbnails: {default: {url: \"http://..../dog.png\"}}\n\t//       }\n\t//     }\n\t//   ]\n\t// }\t \n\t//}\n  });\n  ```\n\n- To convert a `googlePromise` to a native `Promise` use:\n\n  ```js\n  new Promise(function(resolve, reject){\n    googlePromise.then(resolve, reject);\t  \n  })\n  ```\n\n\n### The solution\n\nUpdate the template in the `HTML` tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n      Welcome {{givenName}}! <button ($click)=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n      <button ($click)=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n\n    <div>\n      <input {($value)}=\"searchQuery\" placeholder=\"Search for videos\"/>\n    </div>\n\n    {{#if searchResultsPromise.isPending}}\n      <div class=\"loading\">Loading videos...</div>\n    {{/if}}\n\n    {{#if searchResultsPromise.isResolved}}\n      <ul class='source'>\n      {{#each searchResultsPromise.value}}\n        <li>\n          <a href=\"https://www.youtube.com/watch?v={{./id.videoId}}\" target='_blank'>\n          <img src=\"{{./snippet.thumbnails.default.url}}\" width=\"50px\"/>\n          </a>\n           {{./snippet.title}}\n        </li>\n      {{/each}}\n      </ul>\n\n    {{/if}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='11-31,only'></span>\nUpdate the `JS` tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  }\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='27-46,only'></span>\n\n## Drag videos ##\n\n### The problem\n\nIn this section, we will:\n\n1. Let a user drag around a cloned representation of the searched videos.\n\n### What you need to know\n\n- The [jQuery++](http://jquerypp.com/) library (which is already included on the page), supports\n  the following `drag` events:\n\n  - `dragdown` - the mouse cursor is pressed down\n  - `draginit` - the drag motion is started\n  - `dragmove` - the drag is moved\n  - `dragend` - the drag has ended\n  - `dragover` - the drag is over a drop point\n  - `dragout` - the drag moved out of a drop point\n\n  You can bind on them manually with jQuery like:\n\n  ```js\n  $(element).on('draginit', function(ev, drag) {\n    drag.limit($(this).parent());\n    drag.horizontal();\n  });\n  ```\n\n  Notice that `drag` is the 2nd argument to the event.  You can listen to\n  `drag` events in [can-stache] and pass the `drag` argument to a function like:\n\n  ```html\n  ($draginit)=\"startedDrag(%arguments[1])\"\n  ```\n\n- The `drag.ghost()` method copies the elements being dragged and drags that\n  instead. The `.ghost()` method returns the copied elements\n  wrapped with jQuery.  Add the `ghost` className to style the ghost elements, like:\n\n  ```js\n  drag.ghost().addClass(\"ghost\");\n  ```\n\n- To add a method to a `DefineMap`, just add a function to one of the properties passed\n  to extend:\n\n  ```js\n  PlaylistVM = DefineMap.extend({\n\tstartedDrag: function(){\n\t  console.log(\"you did it!\")\n\t}\n  });\n  new PlaylistVM().startedDrag();\n  ```\n\n### The solution\n\nUpdate the template in the `HTML` tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n      Welcome {{givenName}}! <button ($click)=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n      <button ($click)=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n\n    <div>\n      <input {($value)}=\"searchQuery\" placeholder=\"Search for videos\"/>\n    </div>\n\n    {{#if searchResultsPromise.isPending}}\n      <div class=\"loading\">Loading videos...</div>\n    {{/if}}\n\n    {{#if searchResultsPromise.isResolved}}\n      <ul class='source'>\n      {{#each searchResultsPromise.value}}\n        <li ($draginit)=\"videoDrag(%arguments[1])\">\n          <a href=\"https://www.youtube.com/watch?v={{./id.videoId}}\" target='_blank'>\n          <img src=\"{{./snippet.thumbnails.default.url}}\" width=\"50px\"/>\n          </a>\n           {{./snippet.title}}\n        </li>\n      {{/each}}\n      </ul>\n\n    {{/if}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='22,only'></span>\nUpdate the `JS` tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  },\n  videoDrag: function(drag) {\n    drag.ghost().addClass(\"ghost\");\n  }\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='47-49,only'></span>\n\n## Drop videos\n### The problem\n\nIn this section, we will:\n\n1. Allow a user to drop videos on a playlist element.\n2. When the user drags a video over the playlist element, a placeholder of the\n   video will appear in the first position of the playlist.\n3. If the video is dragged out of the playlist element, the placeholder will be removed.\n4. If the video is dropped on the playlist element, it will be added to the playlist's\n   list of videos.\n5. Prepare for inserting the placeholder or video in any position in the list.\n\n### What you need to know\n\n- The `PlaylistVM` should maintain a list of playlist videos (`playlistVideos`) and\n  the placeholder video (`dropPlaceholderData`) separately.  It can combine these\n  two values into a single value (`videosWithDropPlaceholder`) of the videos to display to the\n  user.  On a high-level, this might look like:\n\n  ```js\n  PlaylistVM = DefineMap.extend({\n      ...\n      // {video: video, index: 0}\n\t  dropPlaceholderData: \"any\",\n\t  // [video1, video2, ...]\n\t  playlistVideos: {\n\t     Type: [\"any\"],\n\t     Value: can.DefineList\n\t  },\n\t  get videosWithDropPlaceholder() {\n         var copyOfPlaylistVideos = this.placeListVideos.map(...);\n\n         // insert this.dropPlaceholderData into copyOfPlaylistVideos\n\n\t\t return copyOfPlaylistVideos;\n\t  }\n  })\n  ```\n\n- The methods that add a placeholder (`addDropPlaceholder`) and\n  add video to the playlist (`addVideo`) should take an index like:\n\n  ```js\n  addDropPlaceholder: function(index, video) { ... }\n  addVideo: function(index, video) { ... }\n  ```\n\n  These functions will be called with `0` as the index for this section.  \n\n- jQuery++ supports the following [drop](http://jquerypp.com/#drop) events:\n\n  - dropinit - the drag motion is started, drop positions are calculated\n  - dropover - a drag moves over a drop element, called once as the drop is dragged over the element\n  - dropout - a drag moves out of the drop element\n  - dropmove - a drag is moved over a drop element, called repeatedly as the element is moved\n  - dropon - a drag is released over a drop element\n  - dropend - the drag motion has completed\n\n  You can bind on them manually with jQuery like:\n\n  ```js\n  $(element).on('dropon', function(ev, drop, drag) {...});\n  ```\n\n  Notice that `drop` is now the 2nd argument to the event.  You can listen to\n  `drop` events in [can-stache], and pass the `drag` argument to a function, like:\n\n  ```html\n  ($dropon)=\"addVideo(%arguments[2])\"\n  ```\n\n- You will need to associate the drag objects with the video being dragged so\n  you know which video is being dropped when a `drop` happens. The following\n  utilities help create that association:\n\n  - The `drag.element` is the jQuery-wrapped element that the user initiated the\n    drag motion upon.\n\n  - CanJS's `{{data DATANAME}}` helper lets you associate custom data with an element. The following\n    saves the current `context` of the `<li>` as `\"dragData\"` on the `<li>`:\n\n    ```\n    <li ($draginit)=\"videoDrag(%arguments[1])\"\n              {{data \"dragData\"}}>\n    ```\n\n  - [can-util/dom/data/data.get can.data.get] can access this data like:\n\n    ```js\n    can.data.get.call(drag.element[0], \"dragData\");\n    ```\n\n### The solution\n\nUpdate the template in the `HTML` tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n      Welcome {{givenName}}! <button ($click)=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n      <button ($click)=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n\n    <div>\n      <input {($value)}=\"searchQuery\" placeholder=\"Search for videos\"/>\n    </div>\n\n    {{#if searchResultsPromise.isPending}}\n      <div class=\"loading\">Loading videos...</div>\n    {{/if}}\n\n    {{#if searchResultsPromise.isResolved}}\n      <ul class='source'>\n      {{#each searchResultsPromise.value}}\n        <li ($draginit)=\"videoDrag(%arguments[1])\"\n            {{data \"dragData\"}}>\n          <a href=\"https://www.youtube.com/watch?v={{./id.videoId}}\" target='_blank'>\n          <img src=\"{{./snippet.thumbnails.default.url}}\" width=\"50px\"/>\n          </a>\n           {{./snippet.title}}\n        </li>\n      {{/each}}\n      </ul>\n\n      {{#if searchResultsPromise.value.length}}\n        <div class='new-playlist'>\n          <ul\n\t\t    ($dropover)=\"addDropPlaceholder(0,getDragData(%arguments[2]))\"\n\t\t\t($dropout)=\"clearDropPlaceholder()\"\n\t\t\t($dropon)=\"addVideo(0,getDragData(%arguments[2]))\">\n\n            {{#each videosWithDropPlaceholder}}\n              <li class=\"{{#if isPlaceholder}}placeholder{{/if}}\">\n                <a href=\"https://www.youtube.com/watch?v={{./video.id.videoId}}\" target='_blank'>\n                  <img src=\"{{./video.snippet.thumbnails.default.url}}\" width=\"50px\"/>\n                </a>\n\n                {{./video.snippet.title}}\n              </li>\n            {{else}}\n              <div class=\"content\">Drag video here</div>\n            {{/each}}\n          </ul>\n        </div>\n      {{/if}}\n\n    {{/if}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='22-23,32-52,only'></span>\nUpdate the `JS` tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  },\n  videoDrag: function(drag) {\n    drag.ghost().addClass(\"ghost\");\n  },\n  getDragData: function(drag){\n\treturn can.data.get.call(drag.element[0], \"dragData\");\n  },\n  dropPlaceholderData: \"any\",\n  playlistVideos: {\n    Type: [\"any\"],\n    Value: can.DefineList\n  },\n  addDropPlaceholder: function(index, video) {\n    this.dropPlaceholderData = {\n      index: index,\n      video: video\n    };\n  },\n  clearDropPlaceholder: function() {\n    this.dropPlaceholderData = null;\n  },\n  addVideo: function(index, video) {\n    this.dropPlaceholderData = null;\n    if (index >= this.playlistVideos.length) {\n      this.playlistVideos.push(video);\n    } else {\n      this.playlistVideos.splice(index, 0, video);\n    }\n  },\n  get videosWithDropPlaceholder() {\n    var copy = this.playlistVideos.map(function(video) {\n      return {\n        video: video,\n        isPlaceholder: false\n      };\n    });\n    if (this.dropPlaceholderData) {\n      copy.splice(this.dropPlaceholderData.index, 0, {\n        video: this.dropPlaceholderData.video,\n        isPlaceholder: true\n      });\n    }\n    return copy;\n  }\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='50-89,only'></span>\n\n\n## Drop videos in order ##\n### The problem\n\nIn this section, we will:\n\n1. Allow a user to drop videos in order they prefer.\n\n### What you need to know\n\n- ViewModels are best left knowing very little about the DOM. This makes them more\n  easily unit-testable.  To make this interaction, we need to know where the mouse\n  is in relation to the playlist's videos.  This requires a lot of DOM interaction\n  and is best done outside the ViewModel.\n\n  Specifically, we'd like to translate the `dropmove` and `dropon` events\n  into other events that let people know where the `dropmove` and `dropon` events\n  are happening in relationship to the __drop target__'s child elements.\n\n  Our goal is to:\n\n  - Translate `dropmove` into `sortableplaceholderat` events\n    that dispatch events with the `index` where a placeholder should be inserted\n    and the `dragData` of what is being dragged.\n\n  - Translate `dropon` into `sortableinsertat` events\n    that dispatch events with the `index` where the dragged item should be inserted\n    and the `dragData` of what is being dragged.  \n\n- [can-control can.Control] is useful for listening to events on an element in a memory-safe\n  way.  Use [can-control.extend] to define a `can.Control` type, as follows:\n\n  ```js\n  var Sortable = can.Control.extend({\n\t  ... event handlers and methods ...\n  });\n  ```\n\n  To listen to events (like `dragmove`) on a control, use an event handler with `{element} EVENTNAME`,\n  as follows:\n\n  ```js\n  var Sortable = can.Control.extend({\n\t\"{element} dropmove\": function(el, ev, drop, drag) {\n      // do stuff on dropmove like call method:\n      this.method();\n    },\n\tmethod: function(){\n\t  // do something\n\t}\n  });\n  ```\n\n  Use `new Control(element)` to create a control on an element.  The following\n  would setup the `dropmove` binding on `el`:\n\n  ```js\n  new Sortable(el);\n  ```\n\n- [can-view-callbacks.attr can.view.callbacks.attr] can listen to when a custom attribute is\n  found in a [can-stache] template like:\n\n  ```js\n  can.view.callbacks.attr(\"sortable\", function(el, attrData) {});\n  ```\n\n  This can be useful to create controls on an element with that attribute.  For example, if a user has:\n\n  ```html\n  <ul sortable>...</ul>\n  ```\n\n  The following will create the `Sortable` control on that `<ul>`:\n\n  ```js\n  can.view.callbacks.attr(\"sortable\", function(el) {\n    new Sortable(el);\n  });\n  ```\n\n- Use [$.trigger](http://api.jquery.com/trigger/) to fire custom events with jQuery:\n\n  ```js\n  $(element).trigger({\n    type: \"sortableinsertat\",\n    index: 0,\n    dragData: dragData\n  });\n  ```\n\n- Access the event object in a [can-stache-bindings.event] with `%event`, like:\n\n  ```html\n  ($sortableinsertat)=\"addVideo(%event.index, %event.dragData)\"\n  ```\n\n- Mouse events like `click` and `dropmove` and `dropon` have a `pageY` property that\n  tells how many pixels down the page a user's mouse is.\n- [jQuery.offset](http://api.jquery.com/offset/) returns an element's position on the page.\n- [jQuery.height](http://api.jquery.com/height/) returns an element's height.\n- If the mouse position is below an element's center, the placeholder should be inserted\n  after the element.  If the mouse position is above an element's center, it should be inserted\n  before the element.\n\n### The solution\n\nUpdate the template in the `HTML` tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n      Welcome {{givenName}}! <button ($click)=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n      <button ($click)=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n\n    <div>\n      <input {($value)}=\"searchQuery\" placeholder=\"Search for videos\"/>\n    </div>\n\n    {{#if searchResultsPromise.isPending}}\n      <div class=\"loading\">Loading videos...</div>\n    {{/if}}\n\n    {{#if searchResultsPromise.isResolved}}\n      <ul class='source'>\n      {{#each searchResultsPromise.value}}\n        <li ($draginit)=\"videoDrag(%arguments[1])\"\n            {{data \"dragData\"}}>\n          <a href=\"https://www.youtube.com/watch?v={{./id.videoId}}\" target='_blank'>\n          <img src=\"{{./snippet.thumbnails.default.url}}\" width=\"50px\"/>\n          </a>\n           {{./snippet.title}}\n        </li>\n      {{/each}}\n      </ul>\n\n      {{#if searchResultsPromise.value.length}}\n        <div class='new-playlist'>\n          <ul sortable\n            ($sortableplaceholderat)=\"addDropPlaceholder(%event.index, %event.dragData)\"\n            ($sortableinsertat)=\"addVideo(%event.index, %event.dragData)\"\n            ($dropout)=\"clearDropPlaceholder()\">\n\n            {{#each videosWithDropPlaceholder}}\n              <li class=\"{{#if isPlaceholder}}placeholder{{/if}}\">\n                <a href=\"https://www.youtube.com/watch?v={{./video.id.videoId}}\" target='_blank'>\n                  <img src=\"{{./video.snippet.thumbnails.default.url}}\" width=\"50px\"/>\n                </a>\n\n                {{./video.snippet.title}}\n              </li>\n            {{else}}\n              <div class=\"content\">Drag video here</div>\n            {{/each}}\n          </ul>\n        </div>\n      {{/if}}\n\n    {{/if}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='34-37,only'></span>\nUpdate the `JS` tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  },\n  videoDrag: function(drag) {\n    drag.ghost().addClass(\"ghost\");\n  },\n  getDragData: function(drag){\n\treturn can.data.get.call(drag.element[0], \"dragData\");\n  },\n  dropPlaceholderData: \"any\",\n  playlistVideos: {\n    Type: [\"any\"],\n    Value: can.DefineList\n  },\n  addDropPlaceholder: function(index, video) {\n    this.dropPlaceholderData = {\n      index: index,\n      video: video\n    };\n  },\n  clearDropPlaceholder: function() {\n    this.dropPlaceholderData = null;\n  },\n  addVideo: function(index, video) {\n    this.dropPlaceholderData = null;\n    if (index >= this.playlistVideos.length) {\n      this.playlistVideos.push(video);\n    } else {\n      this.playlistVideos.splice(index, 0, video);\n    }\n  },\n  get videosWithDropPlaceholder() {\n    var copy = this.playlistVideos.map(function(video) {\n      return {\n        video: video,\n        isPlaceholder: false\n      };\n    });\n    if (this.dropPlaceholderData) {\n      copy.splice(this.dropPlaceholderData.index, 0, {\n        video: this.dropPlaceholderData.video,\n        isPlaceholder: true\n      });\n    }\n    return copy;\n  }\n});\n\nvar Sortable = can.Control.extend({\n  \"{element} dropmove\": function(el, ev, drop, drag) {\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableplaceholderat\");\n  },\n  \"{element} dropon\": function(el, ev, drop, drag) {\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableinsertat\");\n  },\n  fireEventForDropPosition: function(ev, drop, drag, eventName) {\n    var dragData = can.data.get.call(drag.element[0], \"dragData\");\n\n    var sortables = $(this.element).children();\n\n    for (var i = 0; i < sortables.length; i++) {\n      //check if cursor is past 1/2 way\n      var sortable = $(sortables[i]);\n      if (ev.pageY < Math.floor(sortable.offset().top + sortable.height() / 2)) {\n        // index at which it needs to be inserted before\n        $(this.element).trigger({\n          type: eventName,\n          index: i,\n          dragData: dragData\n        });\n        return;\n      }\n    }\n    if (!sortables.length) {\n      $(this.element).trigger({\n        type: eventName,\n        index: 0,\n        dragData: dragData\n      });\n    } else {\n      $(this.element).trigger({\n        type: eventName,\n        index: i,\n        dragData: dragData\n      });\n    }\n  }\n});\n\ncan.view.callbacks.attr(\"sortable\", function(el) {\n  new Sortable(el);\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='92-135,only'></span>\n\n\n\n## Revert videos not dropped on playlist ##\n\n### The problem\n\nIn this section, we will:\n\n1. Revert videos not dropped on the playlist. If a user drags a video, but does not drop it on the playlist, show\n  an animation returning the video to its original place.\n\n### What you need to know\n\n- If you call `drag.revert()`, the drag element will animate back to its original position.\n\n### The solution\n\nUpdate the `JS` tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  },\n  videoDrag: function(drag) {\n    drag.ghost().addClass(\"ghost\");\n  },\n  getDragData: function(drag){\n\treturn can.data.get.call(drag.element[0], \"dragData\");\n  },\n  dropPlaceholderData: \"any\",\n  playlistVideos: {\n    Type: [\"any\"],\n    Value: can.DefineList\n  },\n  addDropPlaceholder: function(index, video) {\n    this.dropPlaceholderData = {\n      index: index,\n      video: video\n    };\n  },\n  clearDropPlaceholder: function() {\n    this.dropPlaceholderData = null;\n  },\n  addVideo: function(index, video) {\n    this.dropPlaceholderData = null;\n    if (index >= this.playlistVideos.length) {\n      this.playlistVideos.push(video);\n    } else {\n      this.playlistVideos.splice(index, 0, video);\n    }\n  },\n  get videosWithDropPlaceholder() {\n    var copy = this.playlistVideos.map(function(video) {\n      return {\n        video: video,\n        isPlaceholder: false\n      };\n    });\n    if (this.dropPlaceholderData) {\n      copy.splice(this.dropPlaceholderData.index, 0, {\n        video: this.dropPlaceholderData.video,\n        isPlaceholder: true\n      });\n    }\n    return copy;\n  }\n});\n\nvar Sortable = can.Control.extend({\n  \"{element} dropinit\": function() {\n    this.droppedOn = false;\n  },\n  \"{element} dropmove\": function(el, ev, drop, drag) {\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableplaceholderat\");\n  },\n  \"{element} dropon\": function(el, ev, drop, drag) {\n    this.droppedOn = true;\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableinsertat\");\n  },\n  \"{element} dropend\": function(el, ev, drop, drag) {\n    if (!this.droppedOn) {\n      drag.revert();\n    }\n  },\n  fireEventForDropPosition: function(ev, drop, drag, eventName) {\n    var dragData = can.data.get.call(drag.element[0], \"dragData\");\n\n    var sortables = $(this.element).children();\n\n    for (var i = 0; i < sortables.length; i++) {\n      //check if cursor is past 1/2 way\n      var sortable = $(sortables[i]);\n      if (ev.pageY < Math.floor(sortable.offset().top + sortable.height() / 2)) {\n        // index at which it needs to be inserted before\n        $(this.element).trigger({\n          type: eventName,\n          index: i,\n          dragData: dragData\n        });\n        return;\n      }\n    }\n    if (!sortables.length) {\n      $(this.element).trigger({\n        type: eventName,\n        index: 0,\n        dragData: dragData\n      });\n    } else {\n      $(this.element).trigger({\n        type: eventName,\n        index: i,\n        dragData: dragData\n      });\n    }\n  }\n});\n\ncan.view.callbacks.attr(\"sortable\", function(el) {\n  new Sortable(el);\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='93-95,100,103-107,only'></span>\n\n\n## Create a playlist ##\n### The problem\n\nIn this section, we will:\n\n1. Add a `Create Playlist` button that prompts the user for the playlist name.\n2. After the user enters the name, the playlist is saved.\n3. Disable the button while the playlist is being created.\n4. Empty the playlist after it is created.\n\n### What you need to know\n\n- Use [https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt] to prompt a user for a simple string value.\n\n- YouTube _only_ allows you to create a playlist and add items to it.\n\n  To create a playlist:\n\n  ```js\n  var lastPromise = gapi.client.youtube.playlists.insert({\n\tpart: 'snippet,status',\n\tresource: {\n\t  snippet: {\n\t\ttitle: PLAYLIST_NAME,\n\t\tdescription: 'A private playlist created with the YouTube API and CanJS'\n\t  },\n\t  status: {\n\t\tprivacyStatus: 'private'\n\t  }\n\t}\n  }).then(function(response) {\n\tresponse //->{} response.result.id\n\t// result: {\n\t//   id: \"lk2asf8o\"\n\t// }\n  });\n  ```\n\n  To insert something onto the end of it:\n\n  ```js\n  gapi.client.youtube.playlistItems.insert({\n    part: 'snippet',\n    resource: {\n      snippet: {\n        playlistId: playlistId,\n        resourceId: video.id\n      }\n    }\n  }).then();\n  ```\n\n- These requests must run in order.  You can make one request run after another, like:\n\n  ```js\n  lastPromise = makeRequest(1);\n\n  lastPromise = lastPromise.then(function(){\n    return makeRequest(2);\t  \n  })\n\n  lastPromise = lastPromise.then(function(){\n    return makeRequest(3);\t  \n  })\n  ```\n\n  When a callback to `.then` returns a promise, `.then` returns a promise that resolves\n  after the _inner_ promise has been resolved.\n\n- Use [can-stache-bindings.toChild {$disabled}] to make an input disabled, like:\n\n  ```html\n  <button {$disabled}=\"createPlaylistPromise.isPending()\">...\n  ```\n\n- When the promise has finished, set the `playlistVideos` property back to an empty list. This\n  can be done by listening to `createPlaylistPromise`:\n\n  ```js\n  this.on(\"createPlaylistPromise\", function(ev, promise) { ... })\n  ```\n\n### The solution\n\nUpdate the template in the `HTML` tab to:\n\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  {{#if googleApiLoadedPromise.isPending}}\n    <div>Loading Google API ...</div>\n  {{else}}\n    {{#if signedIn}}\n      Welcome {{givenName}}! <button ($click)=\"googleAuth.signOut()\">Sign Out</button>\n    {{else}}\n      <button ($click)=\"googleAuth.signIn()\">Sign In</button>\n    {{/if}}\n\n    <div>\n      <input {($value)}=\"searchQuery\" placeholder=\"Search for videos\"/>\n    </div>\n\n    {{#if searchResultsPromise.isPending}}\n      <div class=\"loading\">Loading videos...</div>\n    {{/if}}\n\n    {{#if searchResultsPromise.isResolved}}\n      <ul class='source'>\n      {{#each searchResultsPromise.value}}\n        <li ($draginit)=\"videoDrag(%arguments[1])\"\n            {{data \"dragData\"}}>\n          <a href=\"https://www.youtube.com/watch?v={{./id.videoId}}\" target='_blank'>\n          <img src=\"{{./snippet.thumbnails.default.url}}\" width=\"50px\"/>\n          </a>\n           {{./snippet.title}}\n        </li>\n      {{/each}}\n      </ul>\n\n      {{#if searchResultsPromise.value.length}}\n        <div class='new-playlist'>\n          <ul sortable\n            ($sortableplaceholderat)=\"addDropPlaceholder(%event.index, %event.dragData)\"\n            ($sortableinsertat)=\"addVideo(%event.index, %event.dragData)\"\n            ($dropout)=\"clearDropPlaceholder()\">\n\n            {{#each videosWithDropPlaceholder}}\n              <li class=\"{{#if isPlaceholder}}placeholder{{/if}}\">\n                <a href=\"https://www.youtube.com/watch?v={{./video.id.videoId}}\" target='_blank'>\n                  <img src=\"{{./video.snippet.thumbnails.default.url}}\" width=\"50px\"/>\n                </a>\n\n                {{./video.snippet.title}}\n              </li>\n            {{else}}\n              <div class=\"content\">Drag video here</div>\n            {{/each}}\n          </ul>\n          {{#if playlistVideos.length}}\n            <button ($click)=\"createPlaylist()\"\n              {$disabled}=\"createPlaylistPromise.isPending()\">\n                Create Playlist\n            </button>\n          {{/if}}\n        </div>\n      {{/if}}\n\n    {{/if}}\n\n  {{/if}}\n</script>\n\n```\n<span line-highlight='51-56,only'></span>\nUpdate the `JS` tab to:\n\n\n```js\nvar PlaylistVM = can.DefineMap.extend(\"PlaylistVM\", {\n  init: function() {\n    var self = this;\n\n    self.on(\"googleAuth\", function(ev, googleAuth) {\n      self.signedIn = googleAuth.isSignedIn.get();\n      googleAuth.isSignedIn.listen(function(isSignedIn) {\n        self.signedIn = isSignedIn;\n      });\n    });\n\n    self.on(\"createPlaylistPromise\", function(ev, promise) {\n      if (promise) {\n        promise.then(function() {\n          self.playlistVideos = [];\n          self.createPlaylistPromise = null;\n        });\n      }\n    });\n  },\n  googleApiLoadedPromise: {\n    value: googleApiLoadedPromise\n  },\n  googleAuth: {\n    get: function(lastSet, resolve) {\n      this.googleApiLoadedPromise.then(function() {\n        resolve(gapi.auth2.getAuthInstance());\n      });\n    }\n  },\n  signedIn: \"boolean\",\n  get givenName() {\n    return this.googleAuth &&\n      this.googleAuth.currentUser.get().getBasicProfile().getGivenName();\n  },\n  searchQuery: {\n    type: \"string\",\n    value: \"\"\n  },\n  get searchResultsPromise() {\n    if (this.searchQuery.length > 2) {\n\n      var results = gapi.client.youtube.search.list({\n          q: this.searchQuery,\n          part: 'snippet',\n          type: 'video'\n        }).then(function(response){\n        console.log(response.result.items);\n        return response.result.items;\n      });\n      return new Promise(function(resolve, reject){\n        results.then(resolve, reject);\n      });\n    }\n  },\n  videoDrag: function(drag) {\n    drag.ghost().addClass(\"ghost\");\n  },\n  getDragData: function(drag){\n\treturn can.data.get.call(drag.element[0], \"dragData\");\n  },\n  dropPlaceholderData: \"any\",\n  playlistVideos: {\n    Type: [\"any\"],\n    Value: can.DefineList\n  },\n  addDropPlaceholder: function(index, video) {\n    this.dropPlaceholderData = {\n      index: index,\n      video: video\n    };\n  },\n  clearDropPlaceholder: function() {\n    this.dropPlaceholderData = null;\n  },\n  addVideo: function(index, video) {\n    this.dropPlaceholderData = null;\n    if (index >= this.playlistVideos.length) {\n      this.playlistVideos.push(video);\n    } else {\n      this.playlistVideos.splice(index, 0, video);\n    }\n  },\n  get videosWithDropPlaceholder() {\n    var copy = this.playlistVideos.map(function(video) {\n      return {\n        video: video,\n        isPlaceholder: false\n      };\n    });\n    if (this.dropPlaceholderData) {\n      copy.splice(this.dropPlaceholderData.index, 0, {\n        video: this.dropPlaceholderData.video,\n        isPlaceholder: true\n      });\n    }\n    return copy;\n  },\n  createPlaylistPromise: \"any\",\n  createPlaylist: function() {\n    var playlistName = prompt(\"What would you like to name your playlist?\");\n    if (!playlistName) {\n      return;\n    }\n\n    var playlistId;\n    var lastPromise = gapi.client.youtube.playlists.insert({\n      part: 'snippet,status',\n      resource: {\n        snippet: {\n          title: playlistName,\n          description: 'A private playlist created with the YouTube API and CanJS'\n        },\n        status: {\n          privacyStatus: 'private'\n        }\n      }\n    }).then(function(response) {\n      playlistId = response.result.id;\n    });\n\n\n    var playlistVideos = this.playlistVideos.slice();\n    playlistVideos.forEach(function(video) {\n      lastPromise = lastPromise.then(function() {\n        return gapi.client.youtube.playlistItems.insert({\n          part: 'snippet',\n          resource: {\n            snippet: {\n              playlistId: playlistId,\n              resourceId: video.id\n            }\n          }\n        }).then();\n      });\n    });\n\n    this.createPlaylistPromise = new Promise(function(resolve, reject) {\n      lastPromise.then(resolve, reject);\n    });\n  }\n});\n\nvar Sortable = can.Control.extend({\n  \"{element} dropinit\": function() {\n    this.droppedOn = false;\n  },\n  \"{element} dropmove\": function(el, ev, drop, drag) {\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableplaceholderat\");\n  },\n  \"{element} dropon\": function(el, ev, drop, drag) {\n    this.droppedOn = true;\n    this.fireEventForDropPosition(ev, drop, drag, \"sortableinsertat\");\n  },\n  \"{element} dropend\": function(el, ev, drop, drag) {\n    if (!this.droppedOn) {\n      drag.revert();\n    }\n  },\n  fireEventForDropPosition: function(ev, drop, drag, eventName) {\n    var dragData = can.data.get.call(drag.element[0], \"dragData\");\n\n    var sortables = $(this.element).children();\n\n    for (var i = 0; i < sortables.length; i++) {\n      //check if cursor is past 1/2 way\n      var sortable = $(sortables[i]);\n      if (ev.pageY < Math.floor(sortable.offset().top + sortable.height() / 2)) {\n        // index at which it needs to be inserted before\n        $(this.element).trigger({\n          type: eventName,\n          index: i,\n          dragData: dragData\n        });\n        return;\n      }\n    }\n    if (!sortables.length) {\n      $(this.element).trigger({\n        type: eventName,\n        index: 0,\n        dragData: dragData\n      });\n    } else {\n      $(this.element).trigger({\n        type: eventName,\n        index: i,\n        dragData: dragData\n      });\n    }\n  }\n});\n\ncan.view.callbacks.attr(\"sortable\", function(el) {\n  new Sortable(el);\n});\n\nvar vm = new PlaylistVM();\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='12-19,99-141,only'></span>\nCongrats! _You now have your very own YouTube Playlist Editor_.\n\n<script src=\"//static.jsbin.com/js/embed.min.js?3.41.6\"></script>\n\n",
    "description": "Learn how to use YouTube's API to search for videos and make a playlist.  This makes authenticated requests with OAuth2. It uses [jQuery++](http://jquerypp.com) for\ndrag/drop events. It shows using custom attributes and custom events.  This guide takes\nan hour to complete.\n\n",
    "name": "guides/recipes/playlist-editor",
    "title": "Playlist Editor (Advanced)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes/weather-report-advanced": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/weather-report/weather-report-advanced.md"
    },
    "body": "\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/jipevu/2/embed?html,js,output\">JS Bin on jsbin.com</a>\n\n__Start this tutorial by cloning the following JS Bin__:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/qowacac/2/embed?html,js,output\">JS Bin on jsbin.com</a>\n\nThis is the ending JS Bin for the [guides/recipes/weather-report-simple Simple Weather Report Guide] with [Kefir.js](https://rpominov.github.io/kefir/) added.\n\nThe following sections are broken down into:\n\n- Problem — A description of what the section is trying to accomplish.\n- Things to know — Information about CanJS that is useful for solving the problem.\n- Solution — The solution to the problem.\n\n\n## Removing Imperative Code\n\n### The problem\n\nCurrently, when a new `location` is set, the `place` property is set to `null`:\n\n```js\nvar WeatherViewModel = can.DefineMap.extend({\n  location: {\n    type: \"string\",\n    set: function(){\n      this.place = null;\n    }\n  },\n  ...\n});\n```\n\nThis is [imperative code](https://en.wikipedia.org/wiki/Imperative_programming).\nIt uses side-effects to change the value\nof `place` when `location` is changed.  The rules for how `place` behaves are not\ndefined in one place, which makes the code harder to follow.\n\nInstead, we want to completely define the behavior of `place` within the place definition, which looks like\nthis:\n\n```js\nvar WeatherViewModel = can.DefineMap.extend({\n  ...\n  place: {\n    type: \"any\",\n    get: function(lastSet){\n      if(lastSet) {\n        return lastSet;\n      } else {\n        if(this.places && this.places.length === 1) {\n          return this.places[0];\n        }\n      }\n    }\n  },\n  ...\n});\n```\n\nWe want to define the behavior of `place` so that it becomes `null` when `location` changes.\n\n### Things to know\n\n- `DefineMap` [can-define.types.get getters] can only derive a value from other values.  They can’t\n  derive a value from the change in other values.  However, event-stream libraries like [KefirJS](https://rpominov.github.io/kefir/)\n  can do this.\n\n  For example, we can create a `Kefir` stream that counts the number of times the following `person` map’s `name`\n  property changes using the [can-stream-kefir] module as follows:\n\n  ```js\n  var person = new can.DefineMap({name: \"Justin\"});\n\n  // Create a stream from person’s name\n  var nameStream = can.streamKefir.toStream(person,\".name\");\n\n  // Every time `.name` changes, increase the count 1.\n  var nameChangeCountStream = nameStream.scan(function(lastValue){\n\t  return lastValue + 1;\n  }, 0);\n\n  // Log the current nameChangeStream value\n  nameChangeStream.onValue(function(newValue){\n\t  console.log(newValue);\n  });\n\n  person.name = \"Ramiya\" // logs 1\n\n  person.name = \"Payal\"  // logs 2\n  ```\n\n- The `toStream` method can take an observable object and a property (or event) and create an event stream. The following creates a stream of the `person.name` property values:\n\n  ```js\n  var person = new can.DefineMap({name: \"Justin\"});\n  var nameStream = can.streamKefir.toStream(person,\".name\");\n\n  nameStream.onValue(function(newValue){\n\t  console.log(newValue);\n  });\n\n  person.name = \"Ramiya\" // logs \"Ramiya\"\n  person.name = \"Payal\" // logs \"Payal\"\n  ```\n\n- Kefir’s [map](https://rpominov.github.io/kefir/#map) method can be used to convert event-stream values into new values.  The following creates an event stream of upper-cased names:\n\n  ```js\n  var person = new can.DefineMap({name: \"Justin\"});\n  var capitalizedNameStream = can.streamKefir.toStream(person,\".name\")\n  \t.map(function(name){\n\t\treturn name.toUpperCase()\n\t});\n\n  nameStream.onValue(function(newValue){\n\t  console.log(newValue);\n  });\n\n  person.name = \"Ramiya\" // logs \"RAMIYA\"\n  person.name = \"Payal\" // logs \"PAYAL\"\n  ```\n\n- The [can-define-stream-kefir] module lets you define a property value using\n  a stream. For example, we can define a `nameChangeCount` property of a `Person` type using `stream` like:\n\n  ```js\n  Person = can.DefineMap.extend({\n\t  name: \"string\",\n\t  nameChangeCount: {\n\t\t  stream: function(){\n\t\t\t  return this.toStream(\".name\").scan(function(lastValue){\n\t\t\t\t  return lastValue + 1;\n\t\t\t  }, 0);\n\t\t  }\n\t  }\n  });\n  can.defineStreamKefir(Person);\n  ```\n\n  Notice that the [can-define-stream-kefir] module is used as a [mixin](https://developer.mozilla.org/en-US/docs/Glossary/Mixin). When called on a type (like `Person`), the mixin\n  looks for [can-define.types.propDefinition]s with `stream`\n  property definition functions.  It uses the stream instance returned by the `stream` property definition function as the value of the property.\n\n  Stream properties, like asynchronous getters, only have a value when\n  bound to.  To read the `nameChangeCount`, first use `.on` like:\n\n  ```js\n  var me = new Person({name: \"Justin\"});\n  me.on(\"nameChangeCount\", function(ev, newValue){\n\t  console.log(newValue);\n  });\n\n  me.nameChangeCount //-> 0\n\n  me.name = \"Ramiya\" // logs 1\n\n  me.nameChangeCount //-> 1\n  ```\n\n- The `stream` property definition function is passed `setStream` which is\n  a stream of values set on the property.  The following allows a\n  user to set `nameChangeCount` to reset the count at some new value:\n\n  ```js\n  Person = can.DefineMap.extend({\n\tname: \"string\",\n\tnameChangeCount: {\n\t\tstream: function(setStream){\n\t\t\tvar reset = setStream.map(function(value){\n\t\t\t\treturn {type: \"reset\", value: value};\n\t\t\t});\n\t\t\tvar increment = this.toStream(\".name\").map(function(){\n\t\t\t\treturn {type: \"increment\"}\n\t\t\t});\n\n\t\t\treturn reset.merge(increment).scan(function(lastValue, next){\n\t\t\t\tif(next.type === \"increment\") {\n\t\t\t\t\treturn lastValue + 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn next.value;\n\t\t\t\t}\n\t\t\t}, 0);\n\t\t}\n\t}\n  });\n  can.defineStreamKefir(Person);\n  ```\n\n  The following shows the behavior of this property:\n\n  ```js\n  var me = new Person({name: \"Justin\"});\n  me.on(\"nameChangeCount\", function(ev, newValue){\n\tconsole.log(newValue);\n  });\n\n  me.nameChangeCount = 10;\n\n  me.name = \"Ramiya\" // logs 11\n\n  me.nameChangeCount //-> 11\n  ```\n\n- The [can-define-stream-kefir] module adds a `map.toStream` method which is an alias for\n  `canStream.toStream`.  Use it to create streams from properties and events on a map instance like:\n\n  ```js\n  var Person = can.DefineMap.extend({\n\t  name: \"string\"\n  });\n\n  var me = new Person({name: \"Justin\"});\n\n  var nameStream = me.toStream(\".name\");\n\n  nameStream.onValue(function(){ ... })\n  ```\n\n### The solution\n\nUpdate the `JS` tab to:\n\n - Mixin [can-define-stream-kefir] into the `WeatherViewModel`.\n - Remove the setter side-effects from `location`\n - Change `place` to derive its value from:\n   - changes in `location` -  `place` should be `null` if `location` changes.\n   - the `.places` value - `place` should be the one and only _place_ in `places` if there is only one _place_ in `places`.\n   - the set `.place` value.\n\n\n```js\nvar yqlURL = \"https://query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n\tlocation: \"string\",\n\tget placesPromise() {\n\t\tif (this.location && this.location.length > 2) {\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from geo.places where text=\"' + this.location + '\"',\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(data);\n\t\t\t\tif (Array.isArray(data.query.results.place)) {\n\t\t\t\t\treturn data.query.results.place;\n\t\t\t\t} else {\n\t\t\t\t\treturn [data.query.results.place];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tplaces: {\n\t\tget: function(latSet, resolve) {\n\t\t\tif (this.placesPromise) {\n\t\t\t\tthis.placesPromise.then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showPlacePicker() {\n\t\treturn !this.place && this.places && this.places.length > 1;\n\t},\n\tplace: {\n\t\tstream: function(setStream) {\n\t\t\tvar resetStream = this.toStream(\".location\").map(function() {\n\t\t\t\treturn null;\n\t\t\t});\n            var onePlaceResultStream = this.toStream(\".places\").map(function(places){\n                if(places.length === 1) {\n                    return places[0];\n                } else {\n                    return null;\n                }\n            });\n\n\t\t\treturn onePlaceResultStream\n\t\t\t\t.merge(setStream)\n\t\t\t\t.merge(resetStream);\n\t\t}\n\t},\n\tpickPlace: function(place) {\n\t\tthis.place = place;\n\t},\n\tget forecastPromise() {\n\t\tif (this.place) {\n            console.log(\"place\", this.place);\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from weather.forecast where woeid=' + this.place.woeid,\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(\"forecast data\", data);\n\t\t\t\tvar forecast = data.query.results.channel.item.forecast;\n\n\t\t\t\treturn forecast;\n\t\t\t});\n\t\t}\n\t},\n\ttoClassName: function(text) {\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n\t}\n});\ncan.defineStreamKefir(WeatherViewModel);\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='4,35-52,79,only'></span>\n## Get the geoLocation’s latitude and longitude\n\n### The problem\n\nInstead of requiring the user to search for their city,\nlet’s change the app to use the browser’s [geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation) API to look up their location.  For this step, we\nwill add the following behaviors:\n\n- If the user enables location services, we will write their latitude and longitude.\n- If the user disables location services or there is some other type of error,\n  we will print the error message.\n\nWe will do this by:\n\n- Creating a Kefir stream of the User’s position or error messages.\n- Using that stream to create the `geoLocation` and `geoLocationError` properties.\n- Displaying the data of those properties in the template.\n\n### What you need to know\n\n- The [geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation)\n  API allows you to _request_ the user’s position as follows:\n\n  ```js\n  navigator.geolocation.getCurrentPosition(\n      function(position){...},\n      function(err){...});\n  ```\n\n- The [geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation)\n  API allows you to _monitor changes_ in the user’s position as follows:\n\n  ```js\n  var watch = navigator.geolocation.watchPosition(\n      function(position){...},\n      function(err){...});\n  ```\n\n  To cancel watching, call:\n\n  ```js\n  navigator.geolocation.clearWatch(watch);\n  ```\n\n- To create a `Kefir` stream, call `Kefir.stream` as follows:\n\n  ```js\n  var myStream = Kefir.stream(function setup(emitter){\n\n      // INITIALIZATION CODE\n\n      return function teardown(){\n          // TEARDOWN CODE\n      }\n  });\n  ```\n\n  `Kefir.stream` is passed an event emitter which can emit values like:\n\n  ```js\n  emitter.value(123);\n  ```\n\n  or errors like:\n\n  ```js\n  emitter.error(\"something went wrong\");\n  ```\n\n  or end the stream of values like:\n\n  ```js\n  emitter.end();\n  ```\n\n  Typically, you listen to sources and emit values in the `setup` function\n  and stop listening to sources in the `teardown` function.  For example,\n  the following might listen to where the user’s mouse is on the page:\n\n  ```js\n  var cursorPosition = Kefir.stream(function(emitter){\n      var handler = function(ev){\n          emitter.emit({pageX: ev.pageX, pageY: pageY});\n      };\n      document.documentElement.addEventListener(\"mousemove\",handler);\n\n      return function(){\n          document.documentElement.removeEventListener(\"mousemove\",handler);\n      }\n  })\n  ```\n\n- Kefir’s `stream.withHandler( handler(emitter, event) )` is able to convert one stream’s events to another stream. All other stream methods like `stream.map` and `stream.scan` can be implemented with `stream.withHandler`. For example, the following maps the `cursorPosition` stream to a `cursorDistance` stream:\n\n  ```js\n  cursorDistance = cursorPosition.withHandler(function(emitter, event){\n      if (event.type === 'end') {\n        emitter.end();\n      }\n      if (event.type === 'error') {\n        emitter.error(event.value);\n      }\n      if (event.type === 'value') {\n        var pageX = event.value.pageX;\n        var pageY = event.value.pageY;\n        emitter.value( Math.sqrt(pageX*pageX + pageY*pageY) );\n      }\n  });\n  ```\n\n  Notice how `withHandler` is called with the emitter of `cursorDistance`\n  and the events of `cursorPosition`.  \n\n### The solution\n\n\n```js\nvar yqlURL = \"https://query.yahooapis.com/v1/public/yql?\";\n\nvar geoLocationStream = Kefir.stream(function(emitter) {\n\tnavigator.geolocation.getCurrentPosition(function(position){\n\t  emitter.value(position);\n\t}, function(err){\n\t\tconsole.log(\"getCurrentPositionErr\",err);\n\t\temitter.error(err);\n\t});\n\n\n\t var watch = navigator.geolocation.watchPosition(function(position){\n\t   emitter.value(position);\n\t }, function(err){\n\t     emitter.error(err);\n     });\n\n\treturn function() {\n\t\tnavigator.geolocation.clearWatch(watch);\n\t};\n});\n\nvar WeatherViewModel = can.DefineMap.extend({\n\tgeoLocation: {\n\t\tstream: function() {\n\t\t\treturn geoLocationStream;\n\t\t}\n\t},\n    geoLocationError: {\n        stream: function() {\n\t\t\treturn geoLocationStream.withHandler(function(emitter, event){\n                if (event.type === 'end') {\n                    emitter.end();\n                }\n                if (event.type === 'error') {\n                    emitter.value(event.value);\n                }\n            });\n\t\t}\n    },\n\tlocation: \"string\",\n\tget placesPromise() {\n\t\tif (this.location && this.location.length > 2) {\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from geo.places where text=\"' + this.location + '\"',\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(data);\n\t\t\t\tif (Array.isArray(data.query.results.place)) {\n\t\t\t\t\treturn data.query.results.place;\n\t\t\t\t} else {\n\t\t\t\t\treturn [data.query.results.place];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tplaces: {\n\t\tget: function(latSet, resolve) {\n\t\t\tif (this.placesPromise) {\n\t\t\t\tthis.placesPromise.then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showPlacePicker() {\n\t\treturn !this.place && this.places && this.places.length > 1;\n\t},\n\tplace: {\n\t\tstream: function(setStream) {\n\t\t\tvar resetStream = this.toStream(\".location\").map(function() {\n\t\t\t\treturn null;\n\t\t\t});\n            var onePlaceResultStream = this.toStream(\".places\").map(function(places){\n                if(places.length === 1) {\n                    return places[0];\n                } else {\n                    return null;\n                }\n            });\n\n\t\t\treturn onePlaceResultStream\n\t\t\t\t.merge(setStream)\n\t\t\t\t.merge(resetStream);\n\t\t}\n\t},\n\tpickPlace: function(place) {\n\t\tthis.place = place;\n\t},\n\tget forecastPromise() {\n\t\tif (this.place) {\n            console.log(\"place\", this.place);\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from weather.forecast where woeid=' + this.place.woeid,\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(\"forecast data\", data);\n\t\t\t\tvar forecast = data.query.results.channel.item.forecast;\n\n\t\t\t\treturn forecast;\n\t\t\t});\n\t\t}\n\t},\n\ttoClassName: function(text) {\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n\t}\n});\ncan.defineStreamKefir(WeatherViewModel);\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='3-21,24-40,only'></span>\n\n```html\nLatitude: {{geoLocation.coords.latitude}},\nLongitude: {{geoLocation.coords.longitude}},\nError: {{geoLocationError.message}}\n\n<div class=\"weather-widget\">\n\n  <div class=\"location-entry\">\n    <label for=\"location\">Enter Your location:</label>\n    <input id=\"location\" {^$value}=\"location\" type=\"text\"/>\n  </div>\n\n  {{#if placesPromise.isPending}}\n    <p class=\"loading-message\">\n      Loading places…\n    </p>\n  {{/if}}\n\n  {{#if showPlacePicker}}\n    <div class=\"location-options\">\n      <label>Pick your place:</label>\n      <ul>\n        {{#each placesPromise.value}}\n          <li ($click)=\"../pickPlace(this)\">{{name}}, {{admin1.content}},\n              {{country.code}} ({{placeTypeName.content}})</li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n  {{#if place}}\n    <div class=\"forecast\">\n      <h1>10 day {{place.name}} Weather Forecast</h1>\n      <ul>\n        {{#each forecastPromise.value}}\n          <li>\n            <span class='date'>{{date}}</span>\n            <span class='description {{toClassName(text)}}'>{{text}}</span>\n            <span class='high-temp'>{{high}}<sup>&deg;</sup></span>\n            <span class='low-temp'>{{low}}<sup>&deg;</sup></span>\n          </li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n</div>\n\n```\n<span line-highlight='1-3,only'></span>\n## Find the user’s place by latitude and longitude\n\n### The problem\n\nWe need to get which place the user is in by their\nlatitude and longitude. We will save this place as the\n`geoPlace` property and use it in the `place` property definition.\n\n### What you need to know\n\nFlickr has an API that can get a place that is recognized by\nYahoo’s weather APIs.  It can be retrieved with `fetch` like:\n\n```js\nfetch(\"https://api.flickr.com/services/rest/?\"+\n    can.param({\n        method: \"flickr.places.findByLatLon\",\n        api_key: \"df0a221bb43ecbc2abb03426bd84e598\",\n        lat: LATITUDE,\n        lon: LONGITUDE,\n        format: \"json\",\n        nojsoncallback: 1\n    })\n).then(function(response){\n    return response.json()\n}).then(function(responseJSON){\n    return responseJSON.places.place[0];\n});\n```\n\n### The solution\n\n\n```js\nvar yqlURL = \"https://query.yahooapis.com/v1/public/yql?\";\n\nvar geoLocationStream = Kefir.stream(function(emitter) {\n\tnavigator.geolocation.getCurrentPosition(function(position){\n\t  emitter.value(position);\n\t}, function(err){\n\t\tconsole.log(\"getCurrentPositionErr\",err);\n\t\temitter.error(err);\n\t});\n\n\n\t var watch = navigator.geolocation.watchPosition(function(position){\n\t   emitter.value(position);\n\t }, function(err){\n\t     emitter.error(err);\n     });\n\n\treturn function() {\n\t\tnavigator.geolocation.clearWatch(watch);\n\t};\n});\n\nvar WeatherViewModel = can.DefineMap.extend({\n\tgeoLocation: {\n\t\tstream: function() {\n\t\t\treturn geoLocationStream;\n\t\t}\n\t},\n    geoLocationError: {\n        stream: function() {\n\t\t\treturn geoLocationStream.withHandler(function(emitter, event){\n                if (event.type === 'end') {\n                    emitter.end();\n                }\n                if (event.type === 'error') {\n                    emitter.value(event.value);\n                }\n            });\n\t\t}\n    },\n\tgeoPlace: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tif (this.geoLocation) {\n\t\t\t\tfetch(\"https://api.flickr.com/services/rest/?\" +\n\t\t\t\t\tcan.param({\n\t\t\t\t\t\tmethod: \"flickr.places.findByLatLon\",\n\t\t\t\t\t\tapi_key: \"df0a221bb43ecbc2abb03426bd84e598\",\n\t\t\t\t\t\tlat: this.geoLocation.coords.latitude,\n\t\t\t\t\t\tlon: this.geoLocation.coords.longitude,\n\t\t\t\t\t\tformat: \"json\",\n\t\t\t\t\t\tnojsoncallback: 1\n\t\t\t\t\t})\n\t\t\t\t).then(function(response){\n\t\t\t\t    return response.json();\n\t\t\t\t}).then(function(responseJSON){\n\t\t\t\t    return responseJSON.places.place[0];\n\t\t\t\t}).then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tlocation: \"string\",\n\tget placesPromise() {\n\t\tif (this.location && this.location.length > 2) {\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from geo.places where text=\"' + this.location + '\"',\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(data);\n\t\t\t\tif (Array.isArray(data.query.results.place)) {\n\t\t\t\t\treturn data.query.results.place;\n\t\t\t\t} else {\n\t\t\t\t\treturn [data.query.results.place];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tplaces: {\n\t\tget: function(latSet, resolve) {\n\t\t\tif (this.placesPromise) {\n\t\t\t\tthis.placesPromise.then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showPlacePicker() {\n\t\treturn !this.place && this.places && this.places.length > 1;\n\t},\n\tplace: {\n\t\tstream: function(setStream) {\n\t\t\tvar resetStream = this.toStream(\".location\").map(function() {\n\t\t\t\treturn null;\n\t\t\t});\n            var onePlaceResultStream = this.toStream(\".places\").map(function(places){\n                if(places.length === 1) {\n                    return places[0];\n                } else {\n                    return null;\n                }\n            });\n\n\t\t\treturn onePlaceResultStream\n\t\t\t\t.merge(setStream)\n\t\t\t\t.merge(resetStream)\n                .merge(this.toStream(\".geoPlace\"));\n\t\t}\n\t},\n\tpickPlace: function(place) {\n\t\tthis.place = place;\n\t},\n\tget forecastPromise() {\n\t\tif (this.place) {\n            console.log(\"place\", this.place);\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from weather.forecast where woeid=' + this.place.woeid,\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(\"forecast data\", data);\n\t\t\t\tvar forecast = data.query.results.channel.item.forecast;\n\n\t\t\t\treturn forecast;\n\t\t\t});\n\t\t}\n\t},\n\ttoClassName: function(text) {\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n\t}\n});\ncan.defineStreamKefir(WeatherViewModel);\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='41-60,108,only'></span>\n## Add \"Enable Location Services\" message\n\n### The problem\n\nWhen a user first views the page, they will be prompted to enable location\nservices. While they are prompted, we will display a `Please Enable Location Services…` message.\n\n### What you need to know\n\nDisplay the message while `geoLocation` and `geoLocationError` are undefined.\n\n### The solution\n\n\n```js\nvar yqlURL = \"https://query.yahooapis.com/v1/public/yql?\";\n\nvar geoLocationStream = Kefir.stream(function(emitter) {\n\tnavigator.geolocation.getCurrentPosition(function(position){\n\t  emitter.value(position);\n\t}, function(err){\n\t\tconsole.log(\"getCurrentPositionErr\",err);\n\t\temitter.error(err);\n\t});\n\n\n\t var watch = navigator.geolocation.watchPosition(function(position){\n\t   emitter.value(position);\n\t }, function(err){\n\t     emitter.error(err);\n     });\n\n\treturn function() {\n\t\tnavigator.geolocation.clearWatch(watch);\n\t};\n});\n\nvar WeatherViewModel = can.DefineMap.extend({\n\tgeoLocation: {\n\t\tstream: function() {\n\t\t\treturn geoLocationStream;\n\t\t}\n\t},\n    geoLocationError: {\n        stream: function() {\n\t\t\treturn geoLocationStream.withHandler(function(emitter, event){\n                if (event.type === 'end') {\n                    emitter.end();\n                }\n                if (event.type === 'error') {\n                    emitter.value(event.value);\n                }\n            });\n\t\t}\n    },\n\tgeoPlace: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tif (this.geoLocation) {\n\t\t\t\tfetch(\"https://api.flickr.com/services/rest/?\" +\n\t\t\t\t\tcan.param({\n\t\t\t\t\t\tmethod: \"flickr.places.findByLatLon\",\n\t\t\t\t\t\tapi_key: \"df0a221bb43ecbc2abb03426bd84e598\",\n\t\t\t\t\t\tlat: this.geoLocation.coords.latitude,\n\t\t\t\t\t\tlon: this.geoLocation.coords.longitude,\n\t\t\t\t\t\tformat: \"json\",\n\t\t\t\t\t\tnojsoncallback: 1\n\t\t\t\t\t})\n\t\t\t\t).then(function(response){\n\t\t\t\t    return response.json();\n\t\t\t\t}).then(function(responseJSON){\n\t\t\t\t    return responseJSON.places.place[0];\n\t\t\t\t}).then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showEnableGeoLocationMessage(){\n        return !this.geoLocation && !this.geoLocationError;\n    },\n\tlocation: \"string\",\n\tget placesPromise() {\n\t\tif (this.location && this.location.length > 2) {\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from geo.places where text=\"' + this.location + '\"',\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(data);\n\t\t\t\tif (Array.isArray(data.query.results.place)) {\n\t\t\t\t\treturn data.query.results.place;\n\t\t\t\t} else {\n\t\t\t\t\treturn [data.query.results.place];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tplaces: {\n\t\tget: function(latSet, resolve) {\n\t\t\tif (this.placesPromise) {\n\t\t\t\tthis.placesPromise.then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showPlacePicker() {\n\t\treturn !this.place && this.places && this.places.length > 1;\n\t},\n\tplace: {\n\t\tstream: function(setStream) {\n\t\t\tvar resetStream = this.toStream(\".location\").map(function() {\n\t\t\t\treturn null;\n\t\t\t});\n            var onePlaceResultStream = this.toStream(\".places\").map(function(places){\n                if(places.length === 1) {\n                    return places[0];\n                } else {\n                    return null;\n                }\n            });\n\n\t\t\treturn onePlaceResultStream\n\t\t\t\t.merge(setStream)\n\t\t\t\t.merge(resetStream)\n                .merge(this.toStream(\".geoPlace\"));\n\t\t}\n\t},\n\tpickPlace: function(place) {\n\t\tthis.place = place;\n\t},\n\tget forecastPromise() {\n\t\tif (this.place) {\n            console.log(\"place\", this.place);\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from weather.forecast where woeid=' + this.place.woeid,\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(\"forecast data\", data);\n\t\t\t\tvar forecast = data.query.results.channel.item.forecast;\n\n\t\t\t\treturn forecast;\n\t\t\t});\n\t\t}\n\t},\n\ttoClassName: function(text) {\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n\t}\n});\ncan.defineStreamKefir(WeatherViewModel);\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='61-63,only'></span>\n\n```html\nLatitude: {{geoLocation.coords.latitude}},\nLongitude: {{geoLocation.coords.longitude}},\nError: {{geoLocationError.message}}\n\n<div class=\"weather-widget\">\n  {{#if showEnableGeoLocationMessage}}\n    <p class=\"loading-message\">\n      Please Enable Location Services…\n    </p>\n  {{/if}}\n\n  <div class=\"location-entry\">\n    <label for=\"location\">Enter Your location:</label>\n    <input id=\"location\" {^$value}=\"location\" type=\"text\"/>\n  </div>\n\n  {{#if placesPromise.isPending}}\n    <p class=\"loading-message\">\n      Loading places…\n    </p>\n  {{/if}}\n\n  {{#if showPlacePicker}}\n    <div class=\"location-options\">\n      <label>Pick your place:</label>\n      <ul>\n        {{#each placesPromise.value}}\n          <li ($click)=\"../pickPlace(this)\">{{name}}, {{admin1.content}},\n              {{country.code}} ({{placeTypeName.content}})</li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n  {{#if place}}\n    <div class=\"forecast\">\n      <h1>10 day {{place.name}} Weather Forecast</h1>\n      <ul>\n        {{#each forecastPromise.value}}\n          <li>\n            <span class='date'>{{date}}</span>\n            <span class='description {{toClassName(text)}}'>{{text}}</span>\n            <span class='high-temp'>{{high}}<sup>&deg;</sup></span>\n            <span class='low-temp'>{{low}}<sup>&deg;</sup></span>\n          </li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n</div>\n\n```\n<span line-highlight='6-10,only'></span>\n\n## Allow user to enter location only if location services failed\n\n### The problem\n\nShow the location entry `<div>` only when geo location has failed.\n\n### What you need to know\n\nNothing, you've learned it all by this point.  Apply what you know!\n\n### The solution\n\n\n```js\nvar yqlURL = \"https://query.yahooapis.com/v1/public/yql?\";\n\nvar geoLocationStream = Kefir.stream(function(emitter) {\n\tnavigator.geolocation.getCurrentPosition(function(position){\n\t  emitter.value(position);\n\t}, function(err){\n\t\tconsole.log(\"getCurrentPositionErr\",err);\n\t\temitter.error(err);\n\t});\n\n\n\t var watch = navigator.geolocation.watchPosition(function(position){\n\t   emitter.value(position);\n\t }, function(err){\n\t     emitter.error(err);\n     });\n\n\treturn function() {\n\t\tnavigator.geolocation.clearWatch(watch);\n\t};\n});\n\nvar WeatherViewModel = can.DefineMap.extend({\n\tgeoLocation: {\n\t\tstream: function() {\n\t\t\treturn geoLocationStream;\n\t\t}\n\t},\n    geoLocationError: {\n        stream: function() {\n\t\t\treturn geoLocationStream.withHandler(function(emitter, event){\n                if (event.type === 'end') {\n                    emitter.end();\n                }\n                if (event.type === 'error') {\n                    emitter.value(event.value);\n                }\n            });\n\t\t}\n    },\n\tgeoPlace: {\n\t\tget: function(lastSet, resolve) {\n\t\t\tif (this.geoLocation) {\n\t\t\t\tfetch(\"https://api.flickr.com/services/rest/?\" +\n\t\t\t\t\tcan.param({\n\t\t\t\t\t\tmethod: \"flickr.places.findByLatLon\",\n\t\t\t\t\t\tapi_key: \"df0a221bb43ecbc2abb03426bd84e598\",\n\t\t\t\t\t\tlat: this.geoLocation.coords.latitude,\n\t\t\t\t\t\tlon: this.geoLocation.coords.longitude,\n\t\t\t\t\t\tformat: \"json\",\n\t\t\t\t\t\tnojsoncallback: 1\n\t\t\t\t\t})\n\t\t\t\t).then(function(response){\n\t\t\t\t    return response.json();\n\t\t\t\t}).then(function(responseJSON){\n\t\t\t\t    return responseJSON.places.place[0];\n\t\t\t\t}).then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showEnableGeoLocationMessage(){\n        return !this.geoLocation && !this.geoLocationError;\n    },\n\tget showEnterLocation(){\n        return !!this.geoLocationError;\n    },\n\tlocation: \"string\",\n\tget placesPromise() {\n\t\tif (this.location && this.location.length > 2) {\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from geo.places where text=\"' + this.location + '\"',\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(data);\n\t\t\t\tif (Array.isArray(data.query.results.place)) {\n\t\t\t\t\treturn data.query.results.place;\n\t\t\t\t} else {\n\t\t\t\t\treturn [data.query.results.place];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tplaces: {\n\t\tget: function(latSet, resolve) {\n\t\t\tif (this.placesPromise) {\n\t\t\t\tthis.placesPromise.then(resolve);\n\t\t\t}\n\t\t}\n\t},\n\tget showPlacePicker() {\n\t\treturn !this.place && this.places && this.places.length > 1;\n\t},\n\tplace: {\n\t\tstream: function(setStream) {\n\t\t\tvar resetStream = this.toStream(\".location\").map(function() {\n\t\t\t\treturn null;\n\t\t\t});\n            var onePlaceResultStream = this.toStream(\".places\").map(function(places){\n                if(places.length === 1) {\n                    return places[0];\n                } else {\n                    return null;\n                }\n            });\n\n\t\t\treturn onePlaceResultStream\n\t\t\t\t.merge(setStream)\n\t\t\t\t.merge(resetStream)\n                .merge(this.toStream(\".geoPlace\"));\n\t\t}\n\t},\n\tpickPlace: function(place) {\n\t\tthis.place = place;\n\t},\n\tget forecastPromise() {\n\t\tif (this.place) {\n            console.log(\"place\", this.place);\n\t\t\treturn fetch(\n\t\t\t\tyqlURL +\n\t\t\t\tcan.param({\n\t\t\t\t\tq: 'select * from weather.forecast where woeid=' + this.place.woeid,\n\t\t\t\t\tformat: \"json\"\n\t\t\t\t})\n\t\t\t).then(function(response) {\n\t\t\t\treturn response.json();\n\t\t\t}).then(function(data) {\n\t\t\t\tconsole.log(\"forecast data\", data);\n\t\t\t\tvar forecast = data.query.results.channel.item.forecast;\n\n\t\t\t\treturn forecast;\n\t\t\t});\n\t\t}\n\t},\n\ttoClassName: function(text) {\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n\t}\n});\ncan.defineStreamKefir(WeatherViewModel);\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='64-66,only'></span>\n\n```html\nLatitude: {{geoLocation.coords.latitude}},\nLongitude: {{geoLocation.coords.longitude}},\nError: {{geoLocationError.message}}\n\n<div class=\"weather-widget\">\n  {{#if showEnableGeoLocationMessage}}\n    <p class=\"loading-message\">\n      Please Enable Location Services…\n    </p>\n  {{/if}}\n\n  {{#if showEnterLocation}}\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" {^$value}=\"location\" type=\"text\"/>\n    </div>\n  {{/if}}\n\n  {{#if placesPromise.isPending}}\n    <p class=\"loading-message\">\n      Loading places…\n    </p>\n  {{/if}}\n\n  {{#if showPlacePicker}}\n    <div class=\"location-options\">\n      <label>Pick your place:</label>\n      <ul>\n        {{#each placesPromise.value}}\n          <li ($click)=\"../pickPlace(this)\">{{name}}, {{admin1.content}},\n              {{country.code}} ({{placeTypeName.content}})</li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n  {{#if place}}\n    <div class=\"forecast\">\n      <h1>10 day {{place.name}} Weather Forecast</h1>\n      <ul>\n        {{#each forecastPromise.value}}\n          <li>\n            <span class='date'>{{date}}</span>\n            <span class='description {{toClassName(text)}}'>{{text}}</span>\n            <span class='high-temp'>{{high}}<sup>&deg;</sup></span>\n            <span class='low-temp'>{{low}}<sup>&deg;</sup></span>\n          </li>\n        {{/each}}\n      </ul>\n    </div>\n  {{/if}}\n\n</div>\n\n```\n<span line-highlight='12,17,only'></span>\n## Result\n\nWhen finished, you should see something like the following JS Bin:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/jipevu/2/embed?html,js,output\">JS Bin on jsbin.com</a>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?4.0.0\"></script>\n\n",
    "description": "This guides you through extending the [guides/recipes/weather-report-simple Simple Weather Report Guide] to remove imperative code and automatically look up the user’s location using the\nbrowser’s [geolocation API](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation).  Both of these will be done with event streams.\n\nThis guide continues where the [guides/recipes/weather-report-simple Simple Weather Report Guide] left off.  It takes about 25 minutes to complete.  It was written with CanJS 3.8.\n\n",
    "name": "guides/recipes/weather-report-advanced",
    "title": "Weather Report Guide (Advanced)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  },
  "guides/recipes/weather-report-simple": {
    "src": {
      "path": "docs/can-guides/commitment/recipes/weather-report/weather-report.md"
    },
    "body": "\nThe final widget looks like:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/vujugel/1/embed?html,js,output\">JS Bin on jsbin.com</a>\n\nTo use the widget:\n\n1. __Enter__ a location (example: _Chicago_)\n2. If the location name isn’t unique, __click__ on the intended location.\n3. See the 10-day forecast for your selected city.\n\n__Start this tutorial by cloning the following JSBin__:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/fudakiz/1/embed?html,output\">JS Bin on jsbin.com</a>\n\nThis JSBin has initial prototype HTML and CSS which is useful for\ngetting the application to look right.\n\nThe following sections are broken down into:\n\n- Problem — A description of what the section is trying to accomplish.\n- Things to know — Information about CanJS that is useful for solving the problem.\n- Solution — The solution to the problem.\n\n\n## Setup\n\n### The problem\n\nGet the basic setup for a CanJS app (in a JSBin) setup by:\n\n1.  Creating a template that outputs the pre-constructed HTML.\n2.  Defining a `WeatherViewModel` constructor function.\n3.  Rendering the template with an instance of `WeatherViewModel`.\n4.  Inserting the result of the rendered template into the page.\n\n### Things to know\n\n- A [can-stache] template is used to render data into a document fragment:\n\n  ```js\n  var template = can.stache(\"<h1>{{message}}</h1>\");\n  var frag = template({message: \"Hello World\"});\n  frag //-> <h1>Hello World</h1>\n  ```\n\n- [can-define/map/map can.DefineMap] can be used to define the behavior of observable objects like:\n\n  ```js\n  var Type = can.DefineMap.extend({\n\t  message: \"string\"\n  });\n  ```\n\n- Instances of these [can-define/map/map can.DefineMap] types are often used\n  as a ViewModel that controls the behavior of a [can-stache] template (or\n  [can-component]).\n\n  ```js\n  var MessageViewModel = can.DefineMap.extend({\n\t  message: \"string\"\n  });\n\n  var messageVM = new MessageViewModel();\n  var frag = template(messageVM)\n  ```\n\n### The solution\n\nUpdate the `HTML` tab to wrap the template in a `script` tag:\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  <div class=\"weather-widget\">\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" type='text'/>\n    </div>\n\n    <p class=\"loading-message\">\n      Loading places…\n    </p>\n\n    <div class=\"location-options\">\n      <label>Pick your place:</label>\n      <ul>\n        <li>Some Place</li>\n        <li>Another Place</li>\n      </ul>\n    </div>\n\n    <div class=\"forecast\">\n      <h1>10-day Chicago Weather Forecast</h1>\n      <ul>\n        <li>\n          <span class='date'>Today</span>\n          <span class='description scattered-showers'>Scattered Showers</span>\n          <span class='high-temp'>100<sup>&deg;</sup></span>\n          <span class='low-temp'>-10<sup>&deg;</sup></span>\n        </li>\n      </ul>\n    </div>\n  </div>\n</script>\n```\n<span line-highlight='1,32,only'></span>\nUpdate the `JS` tab to:\n\n- Define a ViewModel.\n- Create an instance of the ViewModel .\n- Load the `app-template` template.\n- Render the template with the ViewModel instance.\n- Insert the rendered result into the page.\n\n```js\nvar WeatherViewModel = can.DefineMap.extend({\n\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='1-9'></span>\n## Allow a user to enter a location\n\n### The problem\n\nWe want an `input` element to:\n\n- Allow a person to type a location to search for weather.\n- Show the user the location they typed.\n\n### Things to know\n\n- There are [can-define.types.propDefinition many ways] to define a property on\n  a `DefineMap`.  The simplest way is `propName: \"<TYPE>\"` like:\n\n  ```js\n  DefineMap.extend({\n    property: \"string\"\t  \n  })\n  ```\n- The [can-stache-bindings.toParent] can set an input’s `value` to\n  a ViewModel property like:\n\n  ```html\n  <input {^$value}=\"property\"/>\n  ```\n\n- A [can-stache] template uses\n  [can-stache.tags.escaped {{key}}] magic tags to insert data into\n  the HTML output like:\n\n  ```html\n  {{property}}\n  ```\n\n### The solution\n\nUpdate the template in the `HTML` tab to:\n\n1. Update `location` on the ViewModel when the input changes.\n2. Show value of the ViewModel’s `location` property.\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  <div class=\"weather-widget\">\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" {^$value}=\"location\" type=\"text\"/>\n    </div>\n\n    <p class=\"loading-message\">\n      Loading places…\n    </p>\n\n    <div class=\"location-options\">\n      <label>Pick your place:</label>\n      <ul>\n        <li>Some Place</li>\n        <li>Another Place</li>\n      </ul>\n    </div>\n\n    <div class=\"forecast\">\n      <h1>10-day {{location}} Weather Forecast</h1>\n      <ul>\n        <li>\n          <span class='date'>Today</span>\n          <span class='description scattered-showers'>Scattered Showers</span>\n          <span class='high-temp'>100<sup>&deg;</sup></span>\n          <span class='low-temp'>-10<sup>&deg;</sup></span>\n        </li>\n      </ul>\n    </div>\n  </div>\n</script>\n```\n<span line-highlight='5,21,only'></span>\n\nUpdate the `JS` tab to:\n\n1. Define a `location` property as a string.\n\n```js\nvar WeatherViewModel = can.DefineMap.extend({\n  location: \"string\"\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='2'></span>\n## Get and display the places for the user’s location name\n\n### The problem\n\nOnce the user has entered a location name, we need to get which\n“place” it is.  For example, a user might enter Paris, but we don’t know if\nthey mean the Paris in France or the one in Illinois.  We need to get a\nlist of matching places for the location name and display the matching places\non the page.\n\n### Things to know\n\n- [ES5 Getter Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) can\n  be used to define a `DefineMap` property that changes when another property changes.  For example,\n  the following defines an `excitedMessage` property that always has a `!` after the `message` property:\n\n  ```js\n  DefineMap.extend({\n    message: \"string\",\n    get excitedMessage(){\n      return this.message+\"!\";\n    }\n  });\n  ```\n\n- [YQL](https://developer.yahoo.com/yql/console/) provides a service endpoint for\n  retrieving a list of places that match some text.  For example, the following requests all\n  places that match `Paris`:\n\n  ```\n  https://query.yahooapis.com/v1/public/yql?\n    format=json&\n\tq=select * from geo.places where text=\"Paris\"\n  ```\n\n  The list of matched places will be in the response data’s `data.query.results.place` property.\n  If there is only a single match, `place` will be an object instead of an array.\n\n- The [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) is an easy way to make requests\n  to a URL and get back JSON.  Use it like:\n\n  ```js\n  fetch(url).then(function(response){\n\t  return response.json();\n  }).then(function(data){\n\n  });\n  ```\n\n- [can-util/js/param/param can.param] is able to convert an object into a\n  query string format like:\n\n  ```js\n  can.param({format: \"json\", q: \"select\"}) //-> \"format=json&q=select\"\n  ```  \n\n- Use [can-stache.helpers.if {{#if value}}] to do `if/else` branching in `can-stache`.\n- Use [can-stache.helpers.each {{#each value}}] to do looping in `can-stache`.\n- `Promise`s are observable in [can-stache].  Given a promise `somePromise`, you can:\n  - Check if the promise is loading like: `{{#if somePromise.isPending}}`.\n  - Loop through the resolved value of the promise like: `{{#each somePromise.value}}`.\n\n\n### The solution\n\n1. Show a “Loading places…” message while we wait on data.\n2. Once the places are resolved, list each place’s name, state, country and type.\n\nUpdate the template in the `HTML` tab to:\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  <div class=\"weather-widget\">\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" {^$value}=\"location\" type=\"text\"/>\n    </div>\n\n    {{#if placesPromise.isPending}}\n      <p class=\"loading-message\">\n        Loading places…\n      </p>\n    {{/if}}\n\n    {{#if placesPromise.isResolved}}\n      <div class=\"location-options\">\n        <label>Pick your place:</label>\n        <ul>\n          {{#each placesPromise.value}}\n            <li>\n              {{name}}, {{admin1.content}}, {{country.code}} ({{placeTypeName.content}})\n            </li>\n          {{/each}}\n        </ul>\n      </div>\n    {{/if}}\n\n    <div class=\"forecast\">\n      <h1>10-day {{location}} Weather Forecast</h1>\n      <ul>\n        <li>\n          <span class='date'>Today</span>\n          <span class='description scattered-showers'>Scattered Showers</span>\n          <span class='high-temp'>100<sup>&deg;</sup></span>\n          <span class='low-temp'>-10<sup>&deg;</sup></span>\n        </li>\n      </ul>\n    </div>\n  </div>\n</script>\n```\n<span line-highlight='8,12,14,18,19,20,21,22,25,only'></span>\nUpdate the `JS` tab to:\n\n1. Define a `placesPromise` property that will represent the loading places.\n2. If the user has typed in at least two characters, we fetch the matching places.\n3. If only a single place is returned, we still convert it into an array so the data\n   stays consistent.  \n\n```js\nvar yqlURL = \"//query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n  location: \"string\",\n  get placesPromise(){\n    if(this.location && this.location.length > 2) {\n      return fetch(\n        yqlURL +\n        can.param({\n          q: 'select * from geo.places where text=\"'+this.location+'\"',\n          format: \"json\"\n        })\n      ).then(function(response){\n        return response.json();\n      }).then(function(data){\n        console.log(data);\n        if(Array.isArray(data.query.results.place)) {\n          return data.query.results.place;\n        } else {\n          return [data.query.results.place];\n        }\n      });\n    }\n  }\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='1,5-24,only'></span>\n## Allow a user to select a place\n\n### The problem\n\nWhen a user clicks on a place, we need to indicate their selection.\n\n### Things to know\n\n- Use [can-stache-bindings.event ($EVENT)] to listen to an event on an element and call a method in `can-stache`.  For example, the following calls `doSomething()` when the `<div>` is clicked.\n\n   ```html\n   <div ($click)=\"sayHi()\"> … </div>\n   ```\n\n- `this` in a stache template refers to the current context of a template or section.  \n\n  For example, the `this` in `this.name` refers to the `context` object:\n\n  ```javascript\n  var template = stache(\"{{this.name}}\");\n  var context = {name: \"Justin\"};\n  template(context);\n  ```\n\n  Or, when looping through a list of items, `this` refers to each item:\n\n  ```html\n  {{#each items}}\n    <li>{{this.name}}</li> <!-- this is each item in items -->\n  {{/each}}\n  ```\n\n\n- The [can-define.types “any” type] can be used to define a property as\n  accepting any data type like:\n\n  ```js\n  var MessageViewModel = can.DefineMap.extend({\n\t  message: \"string\",\n\t  metaData: \"any\"\n  })\n  ```\n\n- `can.DefineMap` can also have methods:\n\n  ```js\n  var MessageViewModel = can.DefineMap.extend({\n\t  message: \"string\",\n\t  metaData: \"any\",\n\t  sayHi: function(){\n\t    this.message = \"Hello\";\n\t  }\n  });\n  ```\n\n### The solution\n\nUpdate the template in the `HTML` tab to:\n\n1. When a `<li>` is clicked on, call `pickPlace` with the corresponding `place`.\n2. When a `place` has been set, write out the forecast header.\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  <div class=\"weather-widget\">\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" {^$value}=\"location\" type=\"text\"/>\n    </div>\n\n    {{#if placesPromise.isPending}}\n      <p class=\"loading-message\">\n        Loading places…\n      </p>\n    {{/if}}\n\n    {{#if placesPromise.isResolved}}\n      <div class=\"location-options\">\n        <label>Pick your place:</label>\n        <ul>\n          {{#each placesPromise.value}}\n            <li ($click)=\"../pickPlace(this)\">\n              {{name}}, {{admin1.content}}, {{country.code}} ({{placeTypeName.content}})\n            </li>\n          {{/each}}\n        </ul>\n      </div>\n    {{/if}}\n\n    {{#if place}}\n      <div class=\"forecast\">\n        <h1>10-day {{place.name}} Weather Forecast</h1>\n        <ul>\n          <li>\n            <span class='date'>Today</span>\n            <span class='description scattered-showers'>Scattered Showers</span>\n            <span class='high-temp'>100<sup>&deg;</sup></span>\n            <span class='low-temp'>-10<sup>&deg;</sup></span>\n          </li>\n        </ul>\n      </div>\n    {{/if}}\n  </div>\n</script>\n```\n<span line-highlight='19,27,29,39,only'></span>\nUpdate the `JS` tab to:\n\n1.  Define a `place` property as taking any data type.\n2.  Define a `pickPlace` method that sets the place property.\n\n```js\nvar yqlURL = \"//query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n  location: \"string\",\n  get placesPromise(){\n    if(this.location && this.location.length > 2) {\n\t  return fetch(\n\t\t  yqlURL+\n\t\t  can.param({\n\t        q: 'select * from geo.places where text=\"'+this.location+'\"',\n\t        format: \"json\"\n\t      })\n\t  ).then(function(response){\n\t\t  return response.json();\n\t  }).then(function(data){\n\t\t  console.log(data);\n          if(Array.isArray(data.query.results.place)) {\n            return data.query.results.place;\n          } else {\n            return [data.query.results.place];\n          }\n\t  });\n    }\n  },\n  place: \"any\",\n  pickPlace: function(place){\n    this.place = place;\n  }\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='25-28,only'></span>\n## Get and display the forecast\n\n### The problem\n\nOnce we’ve selected a place, we need to get and display the forecast data for the\nselected place.  \n\n### Things to know\n\n- ViewModel methods can be [can-stache/expressions/call called] within a [can-stache] template like:\n\n  ```\n  {{myMethod(someValue)}}\n  ```\n\n- [YQL](https://developer.yahoo.com/yql/console/) provides a service endpoint for\n  retrieving a forecast that matches a `place`’s `woeid`.  For example, the following requests the forecast\n  for Paris, France’s `woeid`:\n\n  ```\n  https://query.yahooapis.com/v1/public/yql?\n    format=json&\n\tq=select * from weather.forecast where woeid=615702\n  ```\n\n- The stylesheet includes icons for classNames that match: `sunny`, `mostly-cloudy`, `scattered-thunderstorms`, etc.\n\n### The solution\n\nUpdate the template in the `HTML` tab to:\n\n1. Display each forecast day’s details (date, text, high, and low).\n2. Use the `toClassName` method to convert the forecast’s `text` into a `className` value that\n   will be matched by the stylesheet.\n\n ```html\n <script id=\"app-template\" type=\"text/stache\">\n   <div class=\"weather-widget\">\n     <div class=\"location-entry\">\n       <label for=\"location\">Enter Your location:</label>\n       <input id=\"location\" {^$value}=\"location\" type=\"text\"/>\n     </div>\n\n     {{#if placesPromise.isPending}}\n       <p class=\"loading-message\">\n         Loading places…\n       </p>\n     {{/if}}\n\n     {{#if placesPromise.isResolved}}\n       <div class=\"location-options\">\n         <label>Pick your place:</label>\n         <ul>\n           {{#each placesPromise.value}}\n             <li ($click)=\"../pickPlace(this)\">\n               {{name}}, {{admin1.content}}, {{country.code}} ({{placeTypeName.content}})\n             </li>\n           {{/each}}\n         </ul>\n       </div>\n     {{/if}}\n\n     {{#if place}}\n       <div class=\"forecast\">\n         <h1>10-day {{place.name}} Weather Forecast</h1>\n         <ul>\n           {{#each forecastPromise.value}}\n             <li>\n               <span class='date'>{{date}}</span>\n               <span class='description {{toClassName(text)}}'>{{text}}</span>\n               <span class='high-temp'>{{high}}<sup>&deg;</sup></span>\n               <span class='low-temp'>{{low}}<sup>&deg;</sup></span>\n             </li>\n           {{/each}}\n         </ul>\n       </div>\n     {{/if}}\n   </div>\n </script>\n ```\n<span line-highlight='31,33,34,35,36,38,only'></span>\nUpdate the `JS` tab to:\n\n1. Define a `forecastPromise` property that gets a list of promises.\n2. Define a `toClassName` method that lowercases and hyphenates any text passed in.\n\n```js\nvar yqlURL = \"//query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n  location: \"string\",\n  get placesPromise(){\n    if(this.location && this.location.length > 2) {\n\t  return fetch(\n\t\t  yqlURL+\n\t\t  can.param({\n\t        q: 'select * from geo.places where text=\"'+this.location+'\"',\n\t        format: \"json\"\n\t      })\n\t  ).then(function(response){\n\t\t  return response.json();\n\t  }).then(function(data){\n\t\t  console.log(data);\n          if(Array.isArray(data.query.results.place)) {\n            return data.query.results.place;\n          } else {\n            return [data.query.results.place];\n          }\n\t  });\n    }\n  },\n  place: \"any\",\n  pickPlace: function(place){\n    this.place = place;\n  },\n  get forecastPromise(){\n    if( this.place ) {\n\t  return fetch(\n  \t\t  yqlURL+\n  \t\t  can.param({\n  \t        q: 'select * from weather.forecast where woeid='+this.place.woeid,\n  \t        format: \"json\"\n  \t      })\n  \t  ).then(function(response){\n  \t\t  return response.json();\n  \t  }).then(function(data){\n        console.log(\"forecast data\", data);\n        var forecast = data.query.results.channel.item.forecast;\n\n        return forecast;\n      });\n    }\n  },\n  toClassName: function(text){\n\treturn text.toLowerCase().replace(/ /g, \"-\");\n  }\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='29-49,only'></span>\n## Hide the forecast if the user changes the entered location\n\n### The problem\n\nCurrently, if the user changes the entered location, the weather forecast for the\nother city is still visible.  Let’s hide it!\n\n### Things to know\n\n- `DefineMap` [can-define.types.set setter]'s can be used to add behavior when a property is set like:\n\n  ```js\n  var MessageViewModel = can.DefineMap.extend({\n    message: {\n\t  type: \"string\",\n\t  set: function(){\n\t    this.metaData = null;\n\t  }\n\t},\n    metaData: \"any\",\n  });\n  ```\n\n### The solution\n\nUpdate the `JS` tab to:\n\n1. Set the `place` property to null when the `location` changes.\n\n```js\nvar yqlURL = \"//query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n  location: {\n    type: \"string\",\n    set: function(){\n      this.place = null;\n    }\n  },\n  get placesPromise(){\n    if(this.location && this.location.length > 2) {\n\t  return fetch(\n\t\t  yqlURL+\n\t\t  can.param({\n\t        q: 'select * from geo.places where text=\"'+this.location+'\"',\n\t        format: \"json\"\n\t      })\n\t  ).then(function(response){\n\t\t  return response.json();\n\t  }).then(function(data){\n\t\t  console.log(data);\n          if(Array.isArray(data.query.results.place)) {\n            return data.query.results.place;\n          } else {\n            return [data.query.results.place];\n          }\n\t  });\n    }\n  },\n  place: \"any\",\n  pickPlace: function(place){\n    this.place = place;\n  },\n  get forecastPromise(){\n    if( this.place ) {\n\t  return fetch(\n  \t\t  yqlURL+\n  \t\t  can.param({\n  \t        q: 'select * from weather.forecast where woeid='+this.place.woeid,\n  \t        format: \"json\"\n  \t      })\n  \t  ).then(function(response){\n  \t\t  return response.json();\n  \t  }).then(function(data){\n        console.log(\"forecast data\", data);\n        var forecast = data.query.results.channel.item.forecast;\n\n        return forecast;\n      });\n    }\n  },\n  toClassName: function(text){\n\treturn text.toLowerCase().replace(/ /g, \"-\");\n  }\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='4-9,only'></span>\n## Skip selecting a place if only one place matches the entered location\n\n### The problem\n\nIf a single place is returned for the entered location, we can skip asking the\nuser to select their place; instead, we should show the forecast immediately.  \n\n### Things to know\n\n- `can.DefineMap` [can-define.types.get getters] are passed their last set value.  This way, the\n  property can be derived from either the set value or other properties.\n\n  ```js\n  var MessageVM = can.DefineMap.extend({\n    username: \"string\",\n    message: {\n      get: function(lastSet) {\n        if(lastSet) {\n          return lastSet;\n        } else {\n          return \"Hello \"+this.username;\n        }\n      }\n    }\n  });\n\n  var messageVM = new MessageVM({username: \"Hank\"});\n  messageVM.message //-> \"Hello Hank\";\n\n  messageVM.message = \"Welcome to Earth\";\n  messageVM.message //-> \"Welcome to Earth\"\n  ```\n\n- Use [can-define.types.get asynchronous getters] to derive data from asynchronous sources.  For example:\n\n  ```js\n  var MessageVM = can.DefineMap.extend({\n    messageId: \"string\",\n    message: {\n      get: function(lastSet, resolve) {\n        fetch(\"/message/\"+this.messageId)\n        .then(function(response){\n          return response.json();\n        }).then(resolve);\n      }\n    }\n  });\n  ```\n\n### The solution\n\nUpdate the template in the `HTML` tab to:\n\n1.  Use a `showPlacePicker` property to determine if we should show the `place` picker list.\n\n```html\n<script id=\"app-template\" type=\"text/stache\">\n  <div class=\"weather-widget\">\n    <div class=\"location-entry\">\n      <label for=\"location\">Enter Your location:</label>\n      <input id=\"location\" {^$value}=\"location\" type=\"text\"/>\n    </div>\n\n    {{#if placesPromise.isPending}}\n      <p class=\"loading-message\">\n        Loading places…\n      </p>\n    {{/if}}\n\n    {{#if placesPromise.isResolved}}\n      {{#if showPlacePicker}}\n        <div class=\"location-options\">\n          <label>Pick your place:</label>\n          <ul>\n            {{#each placesPromise.value}}\n              <li ($click)=\"../pickPlace(this)\">\n                {{name}}, {{admin1.content}}, {{country.code}} ({{placeTypeName.content}})\n              </li>\n            {{/each}}\n          </ul>\n        </div>\n      {{/if}}\n    {{/if}}\n\n    {{#if place}}\n      <div class=\"forecast\">\n        <h1>10-day {{place.name}} Weather Forecast</h1>\n        <ul>\n          {{#each forecastPromise.value}}\n            <li>\n              <span class='date'>{{date}}</span>\n              <span class='description {{toClassName(text)}}'>{{text}}</span>\n              <span class='high-temp'>{{high}}<sup>&deg;</sup></span>\n              <span class='low-temp'>{{low}}<sup>&deg;</sup></span>\n            </li>\n          {{/each}}\n        </ul>\n      </div>\n    {{/if}}\n  </div>\n</script>\n```\n<span line-highlight='15,26,only'></span>\nUpdate the `JS` tab to:\n\n1. Define a `places` property that will have the places list returned by the `YQL` service.\n2. Define a `showPlacePicker` property that is true if there’s more than one place in `places` and\n   the `place` property hasn’t been set yet.\n3. Update the `place` property to default to the first item in `places` if there is only one item.\n\n```js\nvar yqlURL = \"//query.yahooapis.com/v1/public/yql?\";\n\nvar WeatherViewModel = can.DefineMap.extend({\n  location: {\n    type: \"string\",\n    set: function(){\n      this.place = null;\n    }\n  },\n  get placesPromise(){\n    if(this.location && this.location.length > 2) {\n\t  return fetch(\n\t\t  yqlURL+\n\t\t  can.param({\n\t        q: 'select * from geo.places where text=\"'+this.location+'\"',\n\t        format: \"json\"\n\t      })\n\t  ).then(function(response){\n\t\t  return response.json();\n\t  }).then(function(data){\n\t\t  console.log(data);\n          if(Array.isArray(data.query.results.place)) {\n            return data.query.results.place;\n          } else {\n            return [data.query.results.place];\n          }\n\t  });\n    }\n  },\n  places: {\n    get: function(latSet, resolve){\n      if(this.placesPromise) {\n        this.placesPromise.then(resolve)\n      }\n    }\n  },\n  get showPlacePicker(){\n    return !this.place && this.places && this.places.length > 1;\n  },\n  place: {\n    type: \"any\",\n    get: function(lastSet){\n      if(lastSet) {\n        return lastSet;\n      } else {\n        if(this.places && this.places.length === 1) {\n          return this.places[0];\n        }\n      }\n    }\n  },\n  pickPlace: function(place){\n    this.place = place;\n  },\n  get forecastPromise(){\n    if( this.place ) {\n\t  return fetch(\n  \t\t  yqlURL+\n  \t\t  can.param({\n  \t        q: 'select * from weather.forecast where woeid='+this.place.woeid,\n  \t        format: \"json\"\n  \t      })\n  \t  ).then(function(response){\n  \t\t  return response.json();\n  \t  }).then(function(data){\n        console.log(\"forecast data\", data);\n        var forecast = data.query.results.channel.item.forecast;\n\n        return forecast;\n      });\n    }\n  },\n  toClassName: function(text){\n\t\treturn text.toLowerCase().replace(/ /g, \"-\");\n  }\n});\n\nvar vm = new WeatherViewModel();\n\nvar template = can.stache.from(\"app-template\");\nvar frag = template( vm );\ndocument.body.appendChild(frag);\n```\n<span line-highlight='30-51,only'></span>\n## Result\n\nWhen finished, you should see something like the following JS Bin:\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/vujugel/1/embed?js,output\">JS Bin on jsbin.com</a>\n\n<script src=\"https://static.jsbin.com/js/embed.min.js?3.35.5\"></script>\n\n",
    "description": "This guide walks you through building a simple weather report widget.  It takes about 25 minutes to complete.  It was written with\nCanJS 3.5.\n\n",
    "name": "guides/recipes/weather-report-simple",
    "title": "Weather Report Guide (Simple)",
    "type": "page",
    "parent": "guides/recipes",
    "comment": " "
  }
}