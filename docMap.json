{
  "steal-stache": {
    "src": {
      "path": "node_modules/steal-stache/steal-stache.md"
    },
    "body": "\n\n## Use\n\nWith [StealJS](http://stealjs.com) used from `node_modules`, steal-stache will configure Steal so stache modules can be loaded like:\n\n```js\nimport todosStache from \"todos.stache\"\ntodosStache([{name: \"dishes\"}]) //-> <documentFragment>\n```\n\n## Specifying Dependencies\n\nThis plugin allows [can-view-import &lt;can-import&gt;] elements that specify \ntemplate dependencies:\n\n\n```\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\n",
    "description": "\nA [StealJS](http://stealjs.com) extension that allows stache templates as dependencies.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "steal-stache",
    "parent": "can-ecosystem",
    "signatures": [
      {
        "code": "STACHE_MODULE_NAME!steal-stache",
        "description": "\n\nImport a [can-stache stache] module in your code and use it to render.\n\n```js\nvar template = require(\"./main.stache\");\nvar Map = require(\"can-map\");\n\nvar map = new Map();\nvar frag = template(map);\n\n// frag is a live-bound DocumentFragment\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "name": "STACHE_MODULE_NAME",
            "description": "The module name of a stache template. This\nwill typically be something like `templates/main.stache`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A renderer function that will render the template into a document fragment.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "moduleName"
        }
      ],
      "name": "STACHE_MODULE_NAME",
      "description": "The module name of a stache template. This\nwill typically be something like `templates/main.stache`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A renderer function that will render the template into a document fragment.\n"
    },
    "comment": " "
  },
  "can-core": {
    "src": {
      "path": "docs/can-canjs/can-core.md"
    },
    "body": "\n## Use\n\nCanJS's core libraries are the modules most commonly used to build web\napplications.  Each module is part of an independent package, so you\nshould install the ones you use directly:\n\n```\nnpm install can-define can-set can-connect can-component can-stache can-route --save\n```\n\nLets export each one a bit more.\n\n## can-compute\n\n[can-compute]s represent an observable value.  A compute can contain its\nown value and notify listeners of changes like:\n\n```js\nvar compute = require(\"can-compute\");\n\nvar name = compute(\"Justin\");\n\n// read the value\nname() //-> \"Justin\"\n\nname.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Matthew\"\n\toldVal //-> \"Justin\"\n});\n\nname(\"Matthew\");\n```\n\nMore commonly, a compute derives its value from other observables:\n\n```js\nvar DefineMap = require(\"can-define/map/map\"),\n\tDefineList = require(\"can-define/list/list\"),\n\tcompute = require(\"can-compute\");\n\nvar person = new DefineMap({first: \"Justin\", last: \"Meyer\"}),\n\thobbies = new DefineList([\"js\",\"bball\"]),\n\tage = compute(33);\n\nvar info = compute(function(){\n\treturn person.first +\" \"+ person.last+ \" is \"+age()+\n\t\t\"and like \"+hobbies.join(\", \")+\".\";\n});\n\ninfo() //-> \"Justin Meyer is 33 and likes js, bball.\"\n\ninfo.on(\"change\", function(ev, newVal){\n\tnewVal //-> \"Justin Meyer is 33 and likes js.\"\n});\n\nhobbies.pop();\n```\n\n\n## can-define\n\n[can-define/map/map] and [can-define/list/list] allow you to create observable\nmaps and lists with well defined properties.  You can\n[can-define.types.propDefinition define a property's type initial value, enumerability, getter-setters and much more].\nFor example, you can define the behavior of a `Todo` type and a `TodoList` type as follows:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({\n  name: \"string\",\n  complete: {type: \"boolean\", value: false},\n  dueDate: \"date\",\n  isPastDue: {\n    get: function(){\n\t  return new Date() <  this.dueDate;\n\t}\n  },\n  toggleComplete: function(){\n    this.complete = !this.complete;\n  }\n});\n\nvar TodoList = DefineList.extend({\n  \"#\": Todo,\n  completeCount: {\n    get: function(){\n      return this.filter(\"complete\").length;\n    }\n  }\n});\n```\n\nThis allows you to create a Todo, read its properties, and\ncall back its methods like:\n\n```js\nvar dishes = new Todo({\n\tname: \"do dishes\",\n\t// due yesterday\n\tdueDate: new Date() - 1000 * 60 * 60 * 24\n});\ndishes.name      //-> \"do dishes\"\ndishes.isPastDue //-> true\ndishes.complete  //-> false\ndishes.toggleComplete()  \ndishes.complete  //-> true\n```\n\nAnd it allows you to create a `TodoList`, access its items and properties\nlike:\n\n```js\nvar todos = new TodoList( dishes, {name: \"mow lawn\", dueDate: new Date()});\ntodos.length         //-> 2\ntodos[0].complete    //-> true\ntodos.completeCount //-> 1\n```\n\nThese observables provide the foundation\nfor data connection (models), view-models and even routing in your application.\n\n## can-set\n\n[can-set] models a service layer's behavior as a [can-set.Algebra set.Algebra]. Once modeled, other libraries such as [can-connect] or [can-fixture] can\nadd a host of functionality like: real-time behavior, performance optimizations, and\nsimulated service layers.\n\nA `todosAlgebra` set algebra for a `GET /api/todos` service might look like:\n\n```js\nvar set = require(\"can-set\");\nvar todosAlgebra = new set.Algebra(\n    // specify the unique identifier property on data\n    set.prop.id(\"_id\"),  \n    // specify that completed can be true, false or undefined\n    set.prop.boolean(\"complete\"),\n    // specify the property that controls sorting\n    set.prop.sort(\"orderBy\")\n)\n```\n\nThis assumes that the service:\n\n - Returns data where the unique property name is `_id`:\n   ```js\n   GET /api/todos\n   -> [{_id: 1, name: \"mow lawn\", complete: true},\n       {_id: 2, name: \"do dishes\", complete: false}, ...]\n   ```\n - Can filter by a `complete` property:\n   ```js\n   GET /api/todos?complete=false\n   -> [{_id: 2, name: \"do dishes\", complete: false}, ...]\n   ```\n - Sorts by an `orderBy` property:\n   ```js\n   GET /api/todos?orderBy=name\n   -> [{_id: 2, name: \"do dishes\", complete: false},\n       {_id: 1, name: \"mow lawn\", complete: true}]\n   ```\n\n## can-connect\n\n[can-connect] connects a data type, typically a `DefineMap` and its `DefineList`,\nto a service layer. This is often done via the\n[can-connect/can/super-map/super-map] module which bundles many common behaviors\nand performance techniques into a single api:\n\n```js\nvar superMap = require(\"can-connect/can/super-map/super-map\"),\n    DefineMap = require(\"can-define/map/map\"),\n    DefineList = require(\"can-define/list/list\"),\n\tset = require(\"can-set\");\n\nvar Todo = DefineMap.extend({\n\t...\n});\nvar TodosList = DefineMap.extend({\n\t\"#\": Todo,\n\t...\n});\nvar todosAlgebra = new set.Algebra({\n\t...\n});\n\nvar connection = superMap({\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList,\n\talgebra: todosAlgebra,\n\tname: \"todo\"\n});\n```\n\n`superMap` extends the `Map` type, in this case, `Todo`, with\nthe ability to make requests to the service layer.\n\n - [can-connect/can/map/map.getList Get a list] of Todos\n   ```js\n   Todo.getList({complete: true}).then(function(todos){})\n   ```\n - [can-connect/can/map/map.get Get] a single Todo\n   ```js\n   Todo.get({_id: 6}).then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.save Create] a Todo\n   ```js\n   var todo = new Todo({name: \"do dishes\", complete: false})\n   todo.save().then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.save Update] an [can-connect/can/map/map.prototype.isNew already created] Todo\n   ```js\n   todo.complete = true;\n   todo.save().then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.destroy Delete] a Todo\n   ```js\n   todo.destroy().then(function(todo){})\n   ```\n\n[can-connect] is also middleware, so custom connections can\nbe assembled too:\n\n```js\nvar base = require(\"can-connect/base/base\");\nvar dataUrl = require(\"can-connect/data-url/data-url\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar map = require(\"can-connect/can/map/map\");\n\nvar options = {\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList,\n\talgebra: todosAlgebra,\n\tname: \"todo\"\n}\nvar connection = map(constructor(dataUrl(base(options))));\n```\n\n## can-stache\n\n[can-stache] provides live binding mustache and handlebars syntax. While\ntemplates should typically be loaded with a module loader like [steal-stache],\nyou can create a template programmatically that lists out todos within a\npromise loaded from `Todo.getList` like:\n\n```js\nvar stache = require(\"can-stache\");\n\n// Creates a template\nvar template = stache(\n\t\"<ul>\"+\n\t\t\"{{#if todos.isPending}}<li>Loading...</li>{{/if}}\"+\n\t\t\"{{#if todos.isResolved}}\"+\n\t\t\t\"{{#each todos.value}}\"+\n\t\t\t\t\"<li class='{{#complete}}complete{{/complete}}'>{{name}}</li>\"+\n\t\t\t\"{{else}}\"+\n\t\t\t\t\"<li>No todos</li>\"+\n\t\t\t\"{{/each}}\"+\n\t\t\"{{/if}}\"+\n\t\"</ul>\");\n\n// Calls the template with some data\nvar frag = template({\n\ttodos: Todo.getList({})\n});\n\n// Inserts the result into the page\ndocument.body.appendChild(frag);\n```\n\n[can-stache] templates use magic tags like `{{}}` to control what\ncontent is rendered. The most common forms of those magic tags are:\n\n - [can-stache.tags.escaped {{key}}] - Insert the value at `key` in the page. If `key` is a function or helper, run it and insert the result.\n - [can-stache.tags.section {{#key}}...{{/key}}] - Render the content between magic tags based on some criteria.  \n\n[can-stache] templates return document fragments that update whenever\ntheir source data changes.\n\n## can-component\n\n[can-component] creates custom elements with unit-testable view models. It\ncombines a view model created by [can-define/map/map] with a template\ncreated by [can-stache].\n\n```js\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\n// Defines the todos-list view model\nvar TodosListVM = DefineMap.extend({\n\t// An initial value that is a promise containing the\n\t// list of all todos.\n\ttodos: {\n\t\tvalue: function(){\n\t\t\treturn Todo.getList({});\n\t\t}\n\t},\n\t// A method that toggles a todo's complete property\n\t// and updates the todo on the server.\n\ttoggleComplete: function(todo){\n\t\ttodo.complete = !todo.complete;\n\t\ttodo.save();\n\t}\n});\n\nComponent.extend({\n\ttag: \"todos-list\",\n\tViewModel: TodosVM,\n\tview: stache(\n\t\t\"<ul>\"+\n\t\t\t\"{{#if todos.isPending}}<li>Loading...</li>{{/if}}\"+\n\t\t\t\"{{#if todos.isResolved}}\"+\n\t\t\t\t\"{{#each todos.value}}\"+\n\t\t\t\t\t\"<li ($click)='toggleComplete(.)'\"+\n\t\t\t\t\t     \"class='{{#complete}}complete{{/complete}}'>{{name}}</li>\"+\n\t\t\t\t\"{{else}}\"+\n\t\t\t\t\t\"<li>No todos</li>\"+\n\t\t\t\t\"{{/each}}\"+\n\t\t\t\"{{/if}}\"+\n\t\t\"</ul>\");\n});\n```\n\n## can-stache-bindings\n\n[can-stache-bindings] provides [can-view-callbacks.attr custom attributes] for\n[can-stache] event and data bindings.\n\nBindings look like:\n\n - `(event)=\"key()\"` for [can-stache-bindings.event event binding].\n - `{prop}=\"key\"` for [can-stache-bindings.toChild one-way binding to a child].\n - `{^prop}=\"key\"` for [can-stache-bindings.toParent one-way binding to a parent].\n - `{(prop)}=\"key\"` for [can-stache-bindings.twoWay two-way binding].\n\nAdding `$` to a binding like `($event)=\"key()\"` changes the binding from the viewModel to the element's attributes or properties.\n\n[can-stache-bindings.event Event] binding examples:\n\n```html\n<!-- calls `toggleComplete` when the li is clicked -->\n<li ($click)=\"toggleComplete(.)\"/>\n\n<!-- calls `resetData` when cancel is dispatched on `my-modal`'s view model -->\n<my-modal (cancel)=\"resetData()\"/>\n```\n\n[can-stache-bindings.toChild One-way to child] examples:\n\n```html\n<!-- updates input's `checked` property with the value of complete -->\n<input type=\"checkbox\" {$checked}=\"complete\"/>\n\n<!-- updates `todo-lists`'s  `todos` property with the result of `getTodos`-->\n<todos-list {todos}=\"getTodos(complete=true)\"/>\n```\n\n[can-stache-bindings.toChild One-way to parent] examples:\n\n```html\n<!-- updates `complete` with input's `checked` property -->\n<input type=\"checkbox\" {^$checked}=\"complete\"/>\n\n<!-- updates `todosList` with `todo-lists`'s `todos` property -->\n<todos-list {^todos}=\"todosList\"/>\n```\n\n[can-stache-bindings.twoWay Two-way] examples:\n\n```html\n<!-- Updates the input's `value` with `name` and vice versa -->\n<input type=\"text\" {($value)}=\"name\"/>\n\n<!-- Updates `date-picker`'s `date` with `dueDate` and vice versa -->\n<date-picker {(date)}=\"dueDate\"/>\n```\n\n## can-route and can-route-pushstate\n\n[can-route] connects a `DefineMap`'s properties to values in the\nurl. Create a map type, [canjs/doc/can-route.map connect it to the url], and [can-route.ready begin routing] like:\n\n```js\nvar route = require(\"can-route\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar AppViewModel = DefineMap.extend({\n\tseal: false\n},{\n\t// Sets the default type to string\n\t\"#\": \"string\",\n\ttodoId: \"string\",\n\ttodo: {\n\t\tget: function(){\n\t\t\tif(this.todoId) {\n\t\t\t\treturn Todo.get({_id: this.todoId})\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar appViewModel = new AppViewModel();\nroute.map(appViewModel);\n\nroute.ready();\n```\n\nWhen the url changes, to something like `#!&todoId=5`, so will the\n`appViewModel`'s `todoId` and `todo` property:\n\n```js\nappViewModel.todoId //-> \"5\"\nappViewModel.todo   //-> Promise<Todo>\n```\n\nSimilarly, if `appViewModel`'s `todoId` is set like:\n\n```js\nappViewModel.todoId = 6;\n```\n\nThe hash will be updated:\n\n```js\nwindow.location.hash //-> \"#!&todoId=6\"\n```\n\nThe `route` function can be used to specify pretty routing rules that\ntranslate property changes to a url and a url to property changes. For example,\n\n```js\n// a route like:\nroute(\"todo/{todoId}\");\n\n// and a hash like:\nwindow.location.hash = \"#!todo/7\";\n\n// produces an appViewModel like:\nappViewModel.serialize() //-> {route: \"todo/{todoId}\", todoId: \"7\"}\n```\n\n[can-route-pushstate] adds [pushstate](https://developer.mozilla.org/en-US/docs/Web/API/History_API) support. It\nmixes in this behavior so you just need to import the module:\n\n```js\nvar route = require(\"can-route\");\nrequire(\"can-route-pushstate\");\n```\n\n",
    "description": "The best, most hardened and generally useful libraries in CanJS.   \n",
    "name": "can-core",
    "title": "Core",
    "type": "page",
    "parent": "canjs",
    "outline": "0",
    "comment": " "
  },
  "can-ecosystem": {
    "src": {
      "path": "docs/can-canjs/can-ecosystem.md"
    },
    "body": "\n",
    "description": "Useful libraries that extend or add important features to the core collection. \n",
    "name": "can-ecosystem",
    "title": "Ecosystem",
    "type": "page",
    "parent": "canjs",
    "comment": " "
  },
  "canjs": {
    "src": {
      "path": "docs/can-canjs/canjs.md"
    },
    "body": "\n## [can-core Core Collection]\n\n_The best, most hardened and generally useful libraries in CanJS._\n\n<div class=\"module-list\">\n\n- **[can-construct]** <small>{{canjs.package.dependencies.can-construct}}</small> Extensible constructors\n  - `npm install can-construct --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-construct\" data-count-href=\"/canjs/can-construct/stargazers\" data-count-api=\"/repos/canjs/can-construct#stargazers_count\">Star</a>\n- **[can-define]** <small>{{canjs.package.dependencies.can-define}}</small> Observables\n  - `npm install can-define --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-define\" data-count-href=\"/canjs/can-define/stargazers\" data-count-api=\"/repos/canjs/can-define#stargazers_count\">Star</a>\n- **[can-compute]** <small>{{canjs.package.dependencies.can-compute}}</small> Observables\n  - `npm install can-compute --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-compute\" data-count-href=\"/canjs/can-compute/stargazers\" data-count-api=\"/repos/canjs/can-compute#stargazers_count\">Star</a>\n- **[can-connect]** <small>{{canjs.package.dependencies.can-connect}}</small> Data connection\n  - `npm install can-connect --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-connect\" data-count-href=\"/canjs/can-connect/stargazers\" data-count-api=\"/repos/canjs/can-connect#stargazers_count\">Star</a>\n- **[can-set]** <small>{{canjs.package.dependencies.can-set}}</small> Service modeling\n  - `npm install can-set --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-set\" data-count-href=\"/canjs/can-set/stargazers\" data-count-api=\"/repos/canjs/can-set#stargazers_count\">Star</a>\n- **[can-route]** <small>{{canjs.package.dependencies.can-route}}</small> Routing\n  - `npm install can-route --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-route\" data-count-href=\"/canjs/can-route/stargazers\" data-count-api=\"/repos/canjs/can-route#stargazers_count\">Star</a>\n- **[can-route-pushstate]** <small>{{canjs.package.dependencies.can-route-pushstate}}</small> Pushy routing\n  - `npm install can-route-pushstate --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-route-pushstate\" data-count-href=\"/canjs/can-route-pushstate/stargazers\" data-count-api=\"/repos/canjs/can-route-pushstate#stargazers_count\">Star</a>\n- **[can-stache]** <small>{{canjs.package.dependencies.can-stache}}</small> Live binding templates\n  - `npm install can-stache --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stache\" data-count-href=\"/canjs/can-stache/stargazers\" data-count-api=\"/repos/canjs/can-stache#stargazers_count\">Star</a>\n- **[can-component]** <small>{{canjs.package.dependencies.can-component}}</small> Custom elements\n  - `npm install can-component --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-component\" data-count-href=\"/canjs/can-component/stargazers\" data-count-api=\"/repos/canjs/can-component#stargazers_count\">Star</a>\n- **[can-stache-bindings]** <small>{{canjs.package.dependencies.can-stache-bindings}}</small> View bindings\n  - `npm install can-stache-bindings --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stache-bindings\" data-count-href=\"/canjs/can-stache-bindings/stargazers\" data-count-api=\"/repos/canjs/can-stache-bindings#stargazers_count\">Star</a>\n\n</div>\n\n## Ecosystem Collection\n\n_Useful libraries that extend or add important features to the core collection._\n\n- Simulate ajax requests - [can-fixture]\n- A virtual DOM that is able to run CanJS's templates - [can-simple-dom] and [can-vdom]\n- Track async activity - [can-zone]\n\n\n## Infrastructure Collection\n\n_Utility libraries that power the core collection._\n\n- DOM and JS utilities - [can-util]\n- Events - [can-event]\n- Observable notification - [can-observe-info]\n- Simple Observable - [can-simple-map]\n- View helpers\n  - Register custom elements or attributes in templates - [can-view-callbacks]\n  - Read a view model from a custom element - [can-view-model]\n  - Lookup scope within a stache template - [can-view-scope]\n  - Parses HTML and magic tags - [can-view-parser]\n  - A fast-path compile target - [can-view-target]\n  - Keeps part of the DOM up to date with a compute - [can-view-live]\n  - Maintains live binding relationships - [can-view-nodelist]\n\n## Legacy Collection\n\n_Former libraries that are not under active development, but we\nstill accept patches._\n\n- [can-control]\n- [can-map] and [can-list]\n- Adds the ability to define getter and setters on `can.Map` and `can.List` - [can-map-define]\n- Adds live-sorting ability to `can-list` - [can-list-sort]\n- [can-map-backup]\n- [can-map-attributes]\n- [can-view-href]\n- [can-map-setter]\n- [can-ejs]\n- [can-mustache]\n\n## Support / Contributing\n\nBefore you make an issue, please read our [Contributing] guide.\n\nYou can find the core team in [gitter chat](https://gitter.im/canjs/canjs).\n\n\n",
    "description": "CanJS is an evolving and improving set of client side JavaScript architectural libraries that balances\ninnovation and stability.  \n\nCanJS targets experienced developers building complex applications\nwith long futures ahead of them. Read more about CanJS's [guides/mission]\nand its [guides/technical].\n\n<img src=\"docs/can-canjs/tortoise.png\"/>\n\n",
    "name": "canjs",
    "title": "CanJS",
    "type": "page",
    "dest": "../index",
    "outline": "0",
    "package": {
      "name": "can",
      "version": "3.0.0-pre.12",
      "main": "can.js",
      "scripts": {
        "preversion": "npm test",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/",
        "postversion": "git push --tags && git checkout major && git branch -D release && git push",
        "testee": "testee test/index.html --browsers firefox",
        "test": "npm run build && npm run testee",
        "ci": "npm run build && grunt",
        "release:pre": "npm version prerelease && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:major": "npm version major && npm publish",
        "build": "node build.js",
        "document": "bit-docs"
      },
      "title": "CanJS",
      "description": "MIT-licensed, client-side, JavaScript framework that makes building rich web applications easy.",
      "keywords": [
        "CanJS",
        "DoneJS"
      ],
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "web": "http://bitovi.com/"
      },
      "homepage": "http://canjs.com/",
      "repository": {
        "type": "git",
        "url": "git@github.com:canjs/canjs.git",
        "github": "https://github.com/canjs/canjs"
      },
      "dependencies": {
        "can-component": "^3.0.0-pre.18",
        "can-compute": "^3.0.0-pre.14",
        "can-connect": "^0.6.0-pre.21",
        "can-construct": "^3.0.0-pre.8",
        "can-construct-super": "^3.0.0-pre",
        "can-control": "3.0.0-pre.8",
        "can-define": "^0.8.3",
        "can-event": "^3.0.0-pre.15",
        "can-fixture": "^0.4.0-pre.15",
        "can-jquery": "^3.0.0-pre.10",
        "can-list": "^3.0.0-pre.8",
        "can-map": "^3.0.0-pre.11",
        "can-map-define": "^3.0.0-pre.4",
        "can-observation": "^3.0.0-pre.12",
        "can-route": "^3.0.0-pre.18",
        "can-route-pushstate": "^3.0.0-pre.6",
        "can-set": "^0.6.0-pre.9",
        "can-simple-dom": "^0.4.3",
        "can-simple-map": "^3.0.0-pre.4",
        "can-stache": "^3.0.0-pre.23",
        "can-stache-bindings": "^3.0.0-pre.28",
        "can-util": "^3.0.0-pre.62",
        "can-view-autorender": "^3.0.0-pre.4",
        "can-view-callbacks": "^3.0.0-pre.7",
        "can-view-import": "^3.0.0-pre.4",
        "can-view-live": "^3.0.0-pre.4",
        "can-view-model": "^3.0.0-pre.6",
        "can-view-nodelist": "^3.0.0-pre.3",
        "can-view-parser": "^3.0.0-pre.6",
        "can-view-scope": "^3.0.0-pre.17",
        "can-view-target": "^3.0.0-pre.4",
        "can-zone": "^0.5.8"
      },
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "can-fixture": "^0.4.0-pre.5",
        "can-stache-converters": "^3.0.0-pre.1",
        "can-vdom": "^0.0.5",
        "funcunit": "^3.1.0-pre.1",
        "grunt": "^1.0.1",
        "grunt-cli": "^1.2.0",
        "grunt-contrib-connect": "^1.0.2",
        "grunt-saucelabs": "^9.0.0",
        "jquery": "^2.2.3",
        "jquery-ui": "^1.12.0",
        "steal": "^0.16.4",
        "steal-qunit": "^0.1.1",
        "steal-stache": "^3.0.0-pre.1",
        "steal-tools": "pre",
        "testee": "^0.2.5"
      },
      "demos": [
        "http://canjs.us/#examples",
        "http://canjs.us/recipes"
      ],
      "licenses": [
        {
          "type": "MIT",
          "url": "http://opensource.org/licenses/mit-license.php"
        }
      ],
      "system": {
        "npmAlgorithm": "flat",
        "main": "can",
        "npmIgnore": [
          "bit-docs",
          "testee"
        ]
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.6",
          "bit-docs-tag-sourceref": "/Users/Garrett/Development/bit-docs/bit-docs-tag-sourceref",
          "bit-docs-generate-html": "/Users/Garrett/Development/bit-docs/bit-docs-generate-html",
          "bit-docs-html-canjs": "/Users/Garrett/Development/canjs/bit-docs-html-canjs",
          "bit-docs-prettify": "^0.1.0",
          "bit-docs-html-highlight-line": "^0.2.2",
          "bit-docs-tag-demo": "^0.3.0",
          "bit-docs-tag-package": "/Users/Garrett/Development/bit-docs/bit-docs-tag-package"
        },
        "glob": {
          "pattern": "{node_modules,docs}/{can-*,steal-stache}/**/*.{js,md}",
          "ignore": "node_modules/can-*/dist/**/*"
        },
        "parent": "canjs",
        "minifyBuild": false
      }
    },
    "templaterender": "true",
    "comment": " "
  },
  "can-legacy": {
    "src": {
      "path": "docs/can-canjs/can-legacy.md"
    },
    "body": "\n",
    "description": "Former libraries that we still accept patches for, but are not under active development.\n\n",
    "name": "can-legacy",
    "title": "Legacy",
    "type": "page",
    "parent": "canjs",
    "comment": " "
  },
  "can-infrastructure": {
    "src": {
      "path": "docs/can-canjs/can-infrastructure.md"
    },
    "body": "\n## Use\n\nThe infrastructure collection of libraries are lower-level utility libraries that\nare used by the [can-core] and [can-ecosystem] collections.  They can also\nbe used by applications directly.\n\nLets explore what's available.\n\n## can-event\n\n[can-event] is a mixin that adds event dispatching and listening functionality\non your objects. The following shows creating a `Person` constructor function\nwhose instances can produce events that can be listened to.\n\n```js\nvar canEvent = require(\"can-event\");\nvar assign = require(\"can-util/js/assign/assign\");\n\n// Create the Person type\nfunction Person(){ ... };\nPerson.prototype.method = function(){ ... };\n\n// Add event mixin:\nassign(Person.prototype, canEvent);\n\n// Create an instance\nvar me = new Person();\n\n// Now listen and dispatch events!\nme.addEventListener(\"name\", function(){ ... });\n\nme.dispatch(\"name\");\n```\n\n[can-event/batch/batch] adds event batching abilities to the [can-event] event system.\n[can-event/async/async] adds asynchronous batched event dispatching to the [can-event] event system.\n\n## can-observation\n\n[can-observation] provides a mechanism to notify when an observable has been read and a way to observe those reads called within a given function.  [can-observation] provides the foundation for [can-compute]'s abilities.\n\nUse [can-observation.add Observation.add] to signal when an an observable value has been read.\nThe following makes the `Person` type's `getName()` observable:\n\n```js\nvar Observation = require(\"can-observation\");\nvar canEvent = require(\"can-event\");\nvar assign = require(\"can-util/js/assign/assign\");\n\n// Create the Person type\nfunction Person(){};\nPerson.prototype.setName = function(newName){\n\tvar oldName = this.name;\n\tthis.name = newName;\n\tthis.dispatch(\"name\", [newName, oldName]);\n};\nPerson.prototype.getName = function(){\n\tObservation.add(this, \"name\");\n\treturn this.name;\n};\n```\n\nThe `Observation` constructor can be used, similar to a [can-compute] to observe\na function's return value by tracking calls to `Observation.add`\n\n```js\nvar person = new Person();\nperson.setName(\"Justin\");\n\n\nvar greetingObservation = new Observation(function(){\n\treturn person.getName() + \" says hi!\";\n}, null, function(newValue){\n\tconsole.log(newValue);\n});\ngreetingObservation.start();\n\ngreetingObservation.value //-> \"Justin says hi!\"\n\nperson.setName(\"Matt\") //-> console.logs \"Matt says hi!\";\n```\n\n## can-util\n\n[can-util] is a collection of many different modules that provide various JavaScript\nand DOM related utilities.\n\n### DOM Utilities\n\nThe DOM utilities consist of:\n\n - Node and Element helpers: [can-util/dom/child-nodes/child-nodes], [can-util/dom/class-name/class-name], [can-util/dom/data/data], [can-util/dom/frag/frag].\n - Event helpers: [can-util/dom/dispatch/dispatch], [can-util/dom/events/delegate/delegate], [can-util/dom/events/attributes/attributes], [can-util/dom/events/inserted/inserted], [can-util/dom/events/removed/removed].\n - Ajax helpers: [can-util/dom/ajax/ajax].\n - Environment identification helpers: [can-util/dom/document/document].\n\nAnd the [can-util/dom/mutate/mutate] helper which should be used to manipulate DOM\nnodes in elements that do not support [MutationObservers](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver).  \n\n\n### JS Utilities\n\nThe JS utilities consist of:\n\n- Functional helpers: [can-util/js/each/each], [can-util/js/assign/assign], [can-util/js/deep-assign/deep-assign], [can-util/js/make-array/make-array].\n- Type detection helpers: [can-util/js/is-array-like/is-array-like],  [can-util/js/is-empty-object/is-empty-object], [can-util/js/is-function], [can-util/js/is-plain-object/is-plain-object], [can-util/js/is-promise/is-promise], [can-util/js/is-string/is-string], [can-util/js/types/types].\n- Environment detection helpers: [can-util/js/is-browser-window/is-browser-window], [can-util/js/is-node/is-node], [can-util/js/is-web-worker/is-web-worker].\n- Environment identification helpers: [can-util/js/global/global], [can-util/js/import/import], [can-util/js/base-url/base-url].\n- Polyfills - [can-util/js/set-immediate/set-immediate].\n- URL helpers: [can-util/js/param/param], [can-util/js/deparam/deparam], [can-util/js/join-uris/join-uris].\n- Diffing helpers: [can-util/js/diff/diff], [can-util/js/diff-object/diff-object].\n- String helpers: [can-util/js/string/string], [can-util/js/string-to-any/string-to-any].\n- Object identification helpers: [can-util/js/cid/cid].\n\n\n## can-view-callbacks\n\n[can-view-callbacks] Lets you register callbacks for specific elements or attributes found in\ntemplates.\n\n```js\nvar callbacks = require(\"can-view-callbacks\");\n\ncallbacks.tag(\"blue-el\", function(el){\n    el.style.background = \"blue\";\n});\n```\n\n## can-view-live\n\nSets up a live-binding between the DOM and a compute.\n\n```js\nvar live = require(\"can-view-live\");\nvar compute = require(\"can-compute\");\nvar frag = require(\"can-util/dom/frag/frag\");\n\nvar message = compute(\"World\");\n\nvar content = frag(\"Hello\",\"\",\"!\");\n\nlive.text(content.childNodes[1], message);\n\ndocument.body.appendChild(content);\n\nmessage(\"Earth\");\n\ndocument.body.innerHTML //-> Hello Earth!\n```\n\n## can-view-nodelist\n\n[can-view-nodelist] is used to maintain the structure of HTML nodes produced by a\ntemplate. For example, a [can-stache] template like:\n\n```\n{{#if over21}}name:{{{highlight name}}}.{{/if}}\n```\n\nMight result in a nodeList structure that looks like:\n\n```\nif[\n\tTextNode(\"name:\"),\n\thighlight[<b>Justin</b>]\n]\n```\n\nThis is to say that the `#if over21` nodeList will contain a text node for `\"name:\"`\nand the `highlight name` nodeList.  The `highlight name` nodeList will contain the\nhtml content resulting from that helper (`<b>Justin</b>`).\n\n## can-view-parser\n\n[can-view-parser] parses HTML and handlebars/mustache tokens.  \n\n```js\nvar parser = require(\"can-view-parser\");\n\nvar html = '<h1><span first=\"foo\"></span><span second=\"bar\"></span></h1>';\n\nvar attrs = [];\n\nparser(html, {\n    attrStart: function(attrName){\n        attrs.push(attrName)\n    }\n});\n\nattrs //-> [\"first\", \"second\"]\n```\n\n## can-view-scope\n\n[can-view-scope] provides a lookup node within a contextual lookup. This is similar\nto a call object in closure in JavaScript.  Consider how `message`, `first`, and `last` are looked up in the following JavaScript:\n\n```js\nvar message = \"Hello\"\nfunction outer(){\n    var last = \"Abril\";\n\n    function inner(){\n        var first = \"Alexis\";\n        console.log(message + \" \"+ first + \" \" + last);\n    }\n    inner();\n}\nouter();\n```\n\n[can-view-scope] can be used to create a similar lookup path:\n\n```js\nvar globalScope = new Scope({message: \"Hello\"});\nvar outerScope = globalScope.add({last: \"Abril\"});\nvar innerScope = outerScope.add({first: \"Alexis\"});\ninnerScope.get(\"message\") //-> Hello\ninnerScope.get(\"first\")   //-> Alexis\ninnerScope.get(\"last\")    //-> Abril\n```\n\n## can-view-target\n\n[can-view-target] is used to create a document fragment that can be quickly cloned but\nhave callbacks called quickly on specific elements within the cloned fragment.\n\n```js\nvar viewTarget = require(\"can-view-target\");\n\nvar target = viewTarget([\n    {\n        tag: \"h1\",\n        callbacks: [function(data){\n            this.className = data.className\n        }],\n        children: [\n            \"Hello \",\n            function(){\n                this.nodeValue = data.message\n            }\n        ]\n    },\n]);\n\n// target.clone -> <h1>|Hello||</h1>\n// target.paths -> path: [0], callbacks: [], children: {paths: [1], callbacks:[function(){}]}\n\nvar frag = target.hydrate({className: \"title\", message: \"World\"});\n\nfrag //-> <h1 class='title'>Hello World</h1>\n```\n\n",
    "description": "Utility libraries that power the core and ecosystem collection. \n",
    "name": "can-infrastructure",
    "title": "Infrastructure",
    "type": "page",
    "parent": "canjs",
    "outline": "0",
    "comment": " "
  },
  "Routing": {
    "src": {
      "path": "docs/can-guides/route.md"
    },
    "body": "\nHere is how you might use `can.route` without a template:\n\n```\n// Before we start, empty the hash.\nwindow.location.hash = '';\n\n// This means that can.route is empty.\ncan.route.attr(); // {}\n\n// Set the hash...\nwindow.location.hash = '#!id=7';\n// ...and can.route reflects that.\ncan.route.attr(); // {id: 7}\n\n// Set the route...\ncan.route.attr({type: 'todos'}, true);\n// ...and the hash reflects that.\nwindow.location.hash; // #!type=todos\n\n// Set a new property on the route...\ncan.route.attr('id', 6);\n// ...and the has changes again to reflect multiple properties.\nwindow.location.hash; // #!type=todos&id=6\n```\n\nIf you give `can.route` a template, you can make pretty URLs:\n\n```\n// Give can.route a template.\ncan.route(':type/:id');\n\n// If you set a hash that looks like the route...\nwindow.location.hash = '#!todos/5';\n// ... the route data changes accordingly.\ncan.route.attr(); // {type: 'todos', id: 5}\n\n// If the route data is changed...\ncan.route.attr({type: 'users', id: 29});\n// ...the hash is changed using the template.\nwindow.location.hash; // '#!users/7'\n\n// You can also supply defaults for routes.\ncan.route('', {type: 'recipe'});\n\n// Then if you change the hash...\nwindow.location.hash = '';\n// ...the route data reflects the defaults.\ncan.route.attr(); // {type: 'recipe'}\n```\n\n## Listening to events\n\nBecause `can.route` is an Observe, you can bind to it just like normal Observes:\n\n```\ncan.route.bind('id', function(ev, newVal, oldVal) {\n\tconsole.log('The hash\\'s id changed.');\n});\n```\n\nYou can listen to routing events in Controls with the _route_ event:\n\n```\nvar Routing = can.Control({\n\t'route': function() {\n\t\t// Matches every routing change, but gets passed no data.\n\t},\n\t'todos/:id route': function(data) {\n\t\t// Matches routes like #!todos/5,\n\t\t// and will get passed {id: 5} as data.\n\t},\n\t':type/:id route': function(data) {\n\t\t// Matches routes like #!recipes/5,\n\t\t// and will get passed {id: 5, type: 'recipes'} as data.\n\t}\n})\n```\n\n## Making URLs and links\n\n`can.route.url` takes a set of properties and makes a URL according to\n`can.route`'s current route.\n\n```\ncan.route(':type/:id', {type: 'todos'});\ncan.route.url({id: 7}); // #!todos/7\n```\n\n`can.route.link` does the same thing as `can.route.url`, but it returns an\nanchor element (in string form) ready to be inserted into HTML. You can also\nspecify extra propertires to be set on the element.\n\n```\nvar a = can.route.link(\n\t'Todo 5',\n\t{id: 7},\n\t{className: 'button'}\n);\n\na; // <a href=\"#!todos/7\" class=\"button\">Todo 5</a>\n```\n\n",
    "description": "\n[can.route](../docs/can.route.html) is the core of CanJS's routing functionality. It is a special\nObserve that updates `window.location.hash` when its properties change and\nupdates its properties when `window.location.hash` changes. You can give\n`can.route` a template to translate URLs into property values, but if no route\nis provided, it just serializes the route into standard URL-encoded notation.\n",
    "name": "Routing",
    "title": "Routing",
    "type": "page",
    "parent": "Tutorial",
    "order": 9
  },
  "guides/introduction": {
    "name": "guides/introduction",
    "title": "introduction",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 0
  },
  "guides/experiment": {
    "name": "guides/experiment",
    "title": "experiment",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 1
  },
  "guides/commitment": {
    "name": "guides/commitment",
    "title": "commitment",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 2
  },
  "guides/contribute": {
    "name": "guides/contribute",
    "title": "contribute",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 3
  },
  "guides": {
    "src": {
      "path": "docs/can-guides/Guides.md"
    },
    "body": "\n\n## Introduction\n\nIf you're reading this, you've already taken the first step. You've met CanJS!  Maybe you\nheard about it at a meetup, or read about it on a blog. But before you spend any time with it, you want to know, \"who is CanJS?\".\n\nCanJS is part of the DoneJS family of open source projects.  The [DoneJS Team](https://donejs.com/About.html#section=section_Team) along with [Bitovi](http://bitovi.com)\nare the people most responsible for CanJS's direction, adding features, fixing bugs, and helping\nyou become successful. Feel free to say hello anytime on [Gitter chat](https://gitter.im/canjs/canjs) or the [forums](http://forums.donejs.com/c/canjs).\n\nYou'll also want to know what CanJS stands for. Checkout our mission statement:\n\n> CanJS is an evolving and improving set of client side JavaScript architectural libraries that balances innovation and stability.\n> CanJS targets experienced developers building complex applications with long futures ahead of them.\n\nRead more on [guides/mission] about our mission and how we've been accomplishing those goals for\n10 years.\n\nFinally, if CanJS's heart isn't enough to convince you it's a good fit, read up on its\n[guides/technical].\n\n\n## Experimenting\n\nSo now you've decided to give CanJS a try.\nThe best place to start is the [guides/chat].\nIt's only an hour, and CanJS will be showing off all of it's best features while you build\na real time chat application.  You build the whole thing in a JSBin.\n\nNext, you'll want to try the [guides/todomvc].  This takes about 3 hours and touches on\nevery core part of CanJS.  You can also follow the whole guide in a JSBin.\n\nAfter that, you'll want to go through the [guides/pmo].  This is a very in-depth\nlook at how CanJS works.  \n\nFinally, when you're just about to commit, read [guides/setup] to learn how to setup\nCanJS for your particular environment.\n\n## Commitment\n\nOnce you've committed to CanJS, it's important that you keep liking it and\nget better at using it.  \n\nCanJS's community has a wealth of people who can offer advice and tips on\nhow to build an application in the right way. Instead of struggling,\nplease ask for advice on [Gitter chat](https://gitter.im/canjs/canjs) or the [forums](http://forums.donejs.com/c/canjs).  Share a screen-shot of what you're building\nand we'll tell you what needs to be done.\n\nTo stay up on CanJS's latest news, we suggest:\n\n - Following [@CanJS](https://twitter.com/canjs) on twitter.\n - Subscribing to Bitovi's [development blog](http://blog.bitovi.com/category/development/).\n\nTo get hands on instruction, sign up for a DoneJS meetup in your area:\n\n- [Chicago](http://www.meetup.com/DoneJS-Chicago/)\n- [Silicon Valley](http://www.meetup.com/DoneJS-Silicon-Valley/)\n- [Boston](http://www.meetup.com/DoneJS-Boston/)\n- [Ft. Lauderdale](http://www.meetup.com/DoneJS-Fort-Lauderdale/)\n- [Los Angeles](http://www.meetup.com/DoneJS-LA/)\n- [New York](http://www.meetup.com/DoneJS-NYC/)\n- [Phoenix](http://www.meetup.com/DoneJS-Phoenix/)\n- [Raleigh-Durham](http://www.meetup.com/DoneJS-raleigh-durham/)\n- [San Francisco](http://www.meetup.com/DoneJS-San-Francisco/)\n- [Seattle](http://www.meetup.com/DoneJS-Seattle/)\n\nAs you start developing your application, remember to checkout the [guides/examples]\narea.  It shows off how to accomplish common UI and architectural patterns with the framework.\n\nIf you've already committed to CanJS, and are looking to move to 3.0, read [migrate-3].\n\n## Contributing\n\nOnce you've settled down with CanJS, It's time to think about adding extensions and improvements to the framework of your own. There are many ways to contribute to\nCanJS including:\n\n - [guides/contributing/bug-report Report a bug]\n - [guides/contributing/feature-suggestion Suggest a feature]\n - [guides/contributing/code Code changes]\n - [guides/contributing/documentation Documentation improvements]\n - [Create a plugin](https://donejs.com/plugin.html)\n - [guides/contributing/evangelism Evangelism - Blog, meetup and conference talks]\n\nCanJS is managed by the [DoneJS Contributors Team](https://donejs.com/About.html#section=section_Team).\nAll contributions from all types of contributors are welcome. Contributing\nto an Open Source project can be an intimidating experience.  We're\ncommitted to making the experience is pleasant and rewarding as possible.  We're happy to setup a\npairing session to show you how to fix a bug or write a feature.  \n\nIf you have any questions, you can always reach us on [Gitter chat](https://gitter.im/canjs/canjs).\n\nIf you want to become a CanJS contributor, you simply have to:\n\n - [Email](mailto:contact@bitovi.com) the core team expressing your interest.\n - Attend the weekly DoneJS Contributors meeting twice a month. [DoneJS Calendar](https://www.google.com/calendar/embed?src=jupiterjs.com_g27vck36nifbnqrgkctkoanqb4%40group.calendar.google.com&ctz=America/Chicago).\n - Make one small contribution, even a spelling correction, a month.\n\n",
    "description": "Welcome to CanJS! These guides are here to help you develop and improve your relationship with CanJS. After all, picking a JavaScript framework is a commitment.  We want CanJS to be the\nframework you marry.  These guides help you advance through the different stages of this\nrelationship:\n\n",
    "name": "guides",
    "title": "Guides",
    "type": "page",
    "parent": "canjs",
    "comment": " "
  },
  "Plugins": {
    "src": {
      "path": "docs/can-guides/plugins.md"
    },
    "body": "\nIn this guide you'll learn how to build a plugin for CanJS. As is standard with programming tutorials,\nwe’ll build something that says \"Hello World\".\n\n## Setup\n\nWe'll be using [Yeoman](http://yeoman.io) and a generator built to scaffold CanJS plugins. If you don't want to use Yeoman, you will have to create the files mentioned in this guide yourself. The [canjs-hello-world](https://github.com/ccummings/canjs-hello-world) repository is where you can grok all of the files the Yeoman generator creates.\n\n### 1) Install Yeoman\n\nThe first thing you need to do is install Yeoman and [`generator-canjs-plugin`](https://github.com/ccummings/generator-canjs-plugin) which will allow you to quickly scaffold a CanJS plugin.\n\nInstall both by running the following on the command line:\n\n\tnpm install -g yo generator-canjs-plugin\n\n_For help installing or using Yeoman, there is the [Yeoman getting started guide](http://yeoman.io/gettingstarted.html)_\n\n### 2) Run the generator\n\nNext create a directory for your plugin and `cd` into it:\n\n\tmkdir canjs-hello-world && cd canjs-hello-world\n\nThen run the generator:\n\n\tyo canjs-plugin\n\nAfter answering a series of questions about your plugin the generator will create the files and install all of the dependencies you need to develop, test and publish your CanJS plugin.\n\n## Develop\n\nNow that you have a scaffold in place, you'll start building your plugin.\n\n### Modify the Source\n\nA single source file will be placed in the `src` directory. This is where you will add your plugin code. Here's what your plugin should look like:\n\n\tcan.hello = function() {\n\t\treturn 'Hello World';\n\t};\n\n__Notice that the file includes bootstrapping that allows it to work with AMD loaders, Steal or stand alone with no dependency management tool.__\n\n### Write tests\n\nA [QUnit](https://qunitjs.com/) test file and runner are placed in the `test` folder. The `*_tests.js` file is where you will write tests for your plugin. Modify the `Hello World` test so it looks like this:\n\n\ttest('Hello World', function() {\n\t\tequal(can.hello(), 'Hello World', 'Works!');\n\t});\n\nYou can run these tests by opening `test/qunit.html` in a browser or by running `grunt test` on the command line. Do this now and make sure the test passes.\n\n### Create examples\n\nExamples for AMD, Steal and stand alone are placed in the `example` folder. Modify the `index.html` file in each folder to show people how to use your plugin.\n\nIn each of the 3 `index.html` files replace the line `//Demo JS goes here` with:\n\n\tconsole.log(can.hello());\n\nOpen these files in a browser and look at the console to see \"Hello World\" being logged.\n\n### Create Documentation\n\nIt's highly recommended that you create documentation for your plugin. You can use your plugin repo's wiki or generate a website for it using [GitHub pages](https://pages.github.com/).\n\n## Grunt work flow\n\nNow that you have developed a plugin, tests and examples, it’s time to build the plugin using Grunt. The following commands are available:\n\nRun jsbeautifier and JSHint:\n\n\tgrunt quality\n\nRun tests:\n\n\tgrunt test\n\nRun tests and places distributable files in the `dist` folder:\n\n\tgrunt build\n\n## Distribute your plugin with Bower\n\nThe easiest way to distribute your plugin is via [Bower](http://bower.io) In order to create a bower package you'll need:\n\n- A valid manifest file ([bower.json](http://bower.io/#defining-a-package)) in the root of the project\n- All code available at a Git endpoint (hosted at GitHub or BitBucket for example)\n- To register your plugin with Bower\n\n### The manifest\n\nA valid `bower.json` file is created by the generator. If you are coding your plugin from scratch run `bower init` and answer the series of prompts to generate your own.\n\n__Be sure to include relevant keywords in your manifest. For CanJS plugins use `can` and any other keywords that are relevant. For can.Components add a keyword of `can-components`.__\n\n### Git endpoint\n\nEach version of your plugin must have a [semantic version number](http://semver.org/) and a corresponding Git tag with the same version. You create a Git tag like this:\n\n\t$ git tag -a vX.Y.Z -m 'vX.Y.Z'\n\n### Register with Bower\n\nNow that you have a valid manifest a Git endpoint and Git tag you are ready to register your plugin. To do this use the `bower register` command:\n\n\t$ bower register [plugin-name] [git-endpoint]\n\n__[git-endpoint] is the URL to your repository, typically starting with `git://`.__\n\nYour plugin is now available via the [bower registry](http://bower.io/search)!\n\n## Wrapping up\n\nThat's all there is to it. In this guide you developed a CanJS plugin complete with tests and examples and learned how to distribute it via bower.\n\nIf you've created a CanJS plugin we'd love to hear about it over on [BitHub](http://bithub.com) [IRC](http://webchat.freenode.net/?channels=canjs) or our [forums](http://forums.donejs.com/c/canjs).\n",
    "description": "\n",
    "name": "Plugins",
    "title": "Developing Plugins",
    "type": "page",
    "parent": "contributing",
    "order": 0,
    "comment": " "
  },
  "Observables": {
    "src": {
      "path": "docs/can-guides/observables.md"
    },
    "body": "\nCanJS's observables - [can.Map](../docs/can.Map.html), [can.List](../docs/can.List.html), \nand [can.compute](../docs/can.compute.html) - let you make changes to data and listen\nto those changes.  Observables are the subjects in \nthe [observer pattern](http://en.wikipedia.org/wiki/Observer_pattern).  CanJS comes with\nthree forms of observables:\n\n - [can.Map](../docs/can.Map.html) - Used for Objects.\n - [can.List](../docs/can.List.html) - Used for Arrays.\n - [can.compute](../docs/can.compute.html) - Used for values.\n\ncan.Map and can.List are often extended to create observable types. \n[Models](../docs/can.Model.html) and [can.route](../docs/can.route.html) are\nbased on can.Map, and can.Component's [scope](../docs/can.Component.prototype.scope.html) is a \ncan.Map, but observables are useful on their own too.\n\nTo create a Map, call `new can.Map(obj)`. This will give you a map\nwith the same properties and values as _obj_. To create a List, call `new\ncan.List(array)`. This will give you a List with the same elements as\n_array_.\n\n```\nvar pagination = new can.Map({page: 1, perPage: 25, count: 1388});\npagination.attr('perPage'); // 25\n\nvar hobbies = new can.List(['programming', 'bball', 'party rocking']);\nhobbies.attr(2); // 'partying'\n```\n\n## Manipulating properties\n\nThe [attr](../docs/can.Map.prototype.attr.html) method is\nused to read and write a property or properties from a Map or List.\n\n```\npagination.attr('perPage');     // 25\npagination.attr('perPage', 50);\npagination.attr('perPage');     // 50\n\npagination.attr({page: 10, lastVisited: 1});\npagination.attr(); // {page: 10, perPage: 50, count: 1388, lastVisited: 1}\n```\n\nProperties can be removed from Observes with `removeAttr`, which is equivalent\nto the `delete` keyword:\n\n```\npagination.removeAttr('count');\npagination.attr(); // {page: 10, perPage: 50, lastVisited: 1}\n```\n\n## Listening to events\n\nWhen a property on a Map is changed with `attr`, the Map will emit two\nevents: A _change_ event and an event with the same name as the property that\nwas changed. You can listen for these events by using\n[bind](../docs/can.Map.prototype.bind.html):\n\n```\npaginate.bind('change', function(event, attr, how, newVal, oldVal) {\n\tattr;   // 'perPage'\n\thow;    // 'set'\n\tnewVal; // 30\n\toldVal; // 50\n});\npaginate.bind('perPage', function(event, newVal, oldVal) {\n\tnewVal; // 30\n\toldVal; // 50\n});\n\npaginate.attr('perPage', 30);\n```\n\nYou can similarly stop listening to these events by using\n[unbind](../docs/can.Map.prototype.unbind.html):\n\n```\nvar timesChanged = 0,\n\tchangeHandler = function() { timesChanged++; },\n\tobs = new can.Map({value: 10});\n\nobs.bind('change', changeHandler);\nobs.attr('value', 20);\ntimesChanged; // 1\n\nobs.unbind('change', changeHandler);\nobs.attr('value', 30);\ntimesChanged; // 1\n```\n\n## Iterating though a Map\n\nIf you want to iterate through the properties on a Map, use `each`:\n\n```\npaginate.each(function(val, key) {\n\tconsole.log(key + ': ' + val);\n});\n\n// The console shows:\n// page: 10\n// perPage: 30\n// lastVisited: 1\n```\n\n## Extending a Map\n\nExtending a can.Map (or can.List) lets you create custom observable \ntypes. The following extends can.Map to create a Paginate type that\nhas a `.next()` method to change its state:\n\n    Paginate = can.Map.extend({\n      limit: 100,\n      offset: 0,\n      count: Infinity,\n      page: function() {\n        return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n      },\n      next: function() {\n        this.attr('offset', this.attr('offset') + this.attr('limit') );\n      }\n    });\n    \n    var pageInfo = new Paginate();\n    pageInfo.attr(\"offset\") //-> 0\n    \n    pageInfo.next();\n    \n    pageInfo.attr(\"offset\") //-> 100\n    pageInfo.page()         //-> 2\n\n\n## Observable Arrays\n\nAs mentioned above, CanJS also provides observable arrays with can.List.\ncan.List inherits from can.Map, so a List works much the same way an\nMap does, with the addition of several methods useful for working with\narrays:\n\n- [indexOf](../docs/can.List.prototype.indexOf.html), which looks for an item in a\nList.\n- [pop](../docs/can.List.prototype.pop.html), which removes the last item from a\nList.\n- [push](../docs/can.List.prototype.push.html), which adds an item to the end of a\nList.\n- [shift](../docs/can.List.prototype.shift.html), which removes the first item from\na List.\n- [unshift](../docs/can.List.prototype.unshift.html), which adds an item to the front\nof a List.\n- [splice](../docs/can.List.prototype.splice.html), which removes and inserts items\nanywhere in a List.\n\nWhen these methods are used to modify a List, the appropriate events are\nemitted. See [the API for Lists](../docs/can.List.html) for more\ninformation on the arguments passed to those event handlers.\n\n## Computed values\n\nCanJS also provides a way to make values themselves observable with\n[can.compute](../docs/can.compute.html). A Compute represents a dynamic value\nthat can be read, set, and listened to just like a Map.\n\n### Static Computes\n\nA simple static Compute contains a single value, and is created by calling\n`can.compute(value)`. This value can be read, set, and listened to:\n\n```\n// create a Compute\nvar age = can.compute(25),\n\tpreviousAge = 0;\n\n// read the Compute's value\nage(); // 25\n\n// listen for changes in the Compute's value\nage.bind('change', function(ev, newVal, oldVal) {\n\tpreviousAge = oldVal;\n});\n\n// set the Compute's value\nage(26);\n\nage();       // 26\npreviousAge; // 25\n```\n\n### Composite Computes\n\nComputes can also be used to generate a unique value based on values derived\nfrom other observable properties. This type of compute is created by calling\n`can.compute(getterFunction)`. When the observable properties that the compute is\nderived from change, the value of the compute changes:\n\n```\nvar name = new can.Map({\n\tfirst: 'Alice',\n\tlast: 'Liddell'\n});\nvar fullName = can.compute(function() {\n\t// We use attr to read the values\n\t// so the compute knows what to listen to.\n\treturn name.attr('first') + ' ' + name.attr('last');\n});\nvar previousName = '';\n\nfullName();   // 'Alice Liddell'\n\nfullName.bind('change', function(ev, newVal, oldVal) {\n\tpreviousName = oldVal;\n});\n\nname.attr({\n\tfirst: 'Allison',\n\tlast: 'Wonderland'\n});\n\nfullname();   // 'Allison Wonderland'\npreviousName; // 'Alice Liddell'\n```\n\nSince the value of the Compute is cached any time a derived value is\nchanged, reading the value is fast.\n\n### Converted Computes\n\nComputes are also useful for creating links to properties within Observes. One\nof the most frequent examples of this is when converting from one unit to\nanother.\n\n```\n// progress ranges from 0 to 1.\nvar project = new can.Map({ progress: 0.3 });\nvar progressPercentage = can.compute(function(newVal) {\n\tif(newVal !== undefined) {\n\t\t// set a value\n\t\tproject.attr('progress', newVal / 100);\n\t} else {\n\t\t// get the value\n\t\treturn project.attr('progress') * 100;\n\t}\n});\n\npercentage();     // 30\n\n// Setting percentage...\npercentage(75);\n// ...updates project.progress!\nproject.attr('progress'); // .75\n```\n\n",
    "description": "\n",
    "name": "Observables",
    "title": "Observables",
    "type": "page",
    "parent": "Tutorial",
    "order": 1,
    "comment": " "
  },
  "can-component": {
    "src": {
      "path": "node_modules/can-component/docs/component.md"
    },
    "body": "\n\n## Use\n\nTo create a Component, you must first [can-component.extend extend] `Component`\nwith the methods and properties of how your component behaves:\n\n```js\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\nvar HelloWorldVM = DefineMap.extend({\n    visible: {value: false},\n    message: {value: \"Hello There!\"}\n});\n\nComponent.extend({\n  tag: \"hello-world\",\n  view: stache(\"{{#if visible}}{{message}}{{else}}Click me{{/if}}\"),\n  ViewModel: HelloWorldVM,\n  events: {\n    click: function(){\n    \tthis.viewModel.visible = !this.viewModel.visible;\n    }\n  }\n});\n```\n\nThis element says \"Click me\" until a user clicks it and then\nsays \"Hello There!\".  To create a a instance of this component on the page,\nadd `<hello-world/>` to a [can-stache] template, render\nthe template and insert the result in the page like:\n\n    var template = stache(\"<hello-world/>\");\n    document.body.appendChild(template({}));\n\nCheck this out here:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/click_me.html'></div>\n\n\nTypically, you do not append a single component at a time.  Instead,\nyou'll render a template with many custom tags like:\n\n    <srchr-app>\n      <srchr-search {models}=\"models\">\n        <input name=\"search\"/>\n      </srchr-search>\n      <ui-panel>\n        <srchr-history/>\n        <srchr-results {models}=\"models\"/>\n      </ui-panel>\n    </srchr-app>\n\n### Defining a Component\n\nUse [can-component.extend] to define a `Component` constructor function\nthat automatically gets initialized whenever the component's tag is\nfound.\n\nNote that inheriting from components works differently than other CanJS APIs. You\ncan't call `.extend` on a particular component to create a \"subclass\" of that component.\n\nInstead, components work more like HTML elements. To reuse functionality from a base component, build on top of it with parent\ncomponents that wrap other components in their template and pass any needed viewModel properties via attributes.\n\n### Tag\n\nA component's [can-component::tag tag] is the element node name that\nthe component will be created on.\n\n\nThe following matches `<hello-world>` elements.\n\n    Component.extend({\n      tag: \"hello-world\"\n    });\n\n### View\n\nA component's [can-component::view view] is a template that is rendered as\nthe element's innerHTML.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>Hello World</h1>\")\n    });\n\nChanges `<hello-world/>` elements into:\n\n    <hello-world><h1>Hello World</h1></hello-world>\n\nUse the [can-component/content] tag to position the custom element's source HTML.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1><content/></h1>\")\n    });\n\nChanges `<hello-world>Hi There</hello-world>` into:\n\n    <hello-world><h1>Hi There</h1></hello-world>\n\n### ViewModel\n\nA component's [can-component::ViewModel ViewModel] defines a constructor that creates\ninstances used to render the component's template. The instance's properties\nare typically set by attribute [can-stache-bindings data bindings] on the custom element.\nBy default, every data binding's value is looked up in the parent [can-view-scope]\nof the custom element and added to the viewModel object.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\")\n    });\n\nChanges the following rendered template:\n\n    var template = stache(\"<hello-world {message}='greeting'/>\");\n    template({\n      greeting: \"Salutations\"\n    })\n\nInto:\n\n    <hello-world><h1>Salutations</h1></hello-world>\n\nDefault values can be provided. The following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\"),\n      viewModel: {\n        message: \"Hi\"\n      }\n    });\n\nChanges the following rendered template:\n\n    var template = stache(\"<hello-world/>\");\n    template({})\n\nInto:\n\n    <hello-world><h1>Hi</h1></hello-world>\n\nIf you want to set the string value of the attribute on the ViewModel,\nset an attribute without any binding syntax.\n\nThe following template, with the previous `\"hello-world\"` component:\n\n    var template = stache(\"<hello-world message='Howdy'/>\");\n    template({})\n\nRenders to:\n\n    <hello-world><h1>Howdy</h1></hello-world>\n\n### Events\n\nA component's [can-component::events events] object is used to listen to events (that are not\nlistened to with [can-stache-bindings view bindings]). The following component\nadds \"!\" to the message every time `<hello-world>` is clicked:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\"),\n      events: {\n        \"click\" : function(){\n          var currentMessage = this.viewModel.message;\n          this.viewModel.message = currentMessage+ \"!\";\n        }\n      }\n    });\n\nComponents have the ability to bind to special [can-util/dom/events/inserted/inserted],\n[can-component/beforeremove] and [can-util/dom/events/removed/removed] events\nthat are called when a component's tag has been inserted into,\nis about to removed, or was removed from the page.\n\n### Helpers\n\nA component's [can-component::helpers helpers] object provides [can-stache.helper stache helper] functions\nthat are available within the component's template.  The following component\nonly renders friendly messages:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"{{#isFriendly message}}\"+\n                  \"<h1>{{message}}</h1>\"+\n                \"{{/isFriendly}}\"),\n      helpers: {\n        isFriendly: function(message, options){\n          if( /hi|hello|howdy/.test(message) ) {\n            return options.fn();\n          } else {\n            return options.inverse();\n          }\n        }\n      }\n    });\n\nGenerally speaking, helpers should only be used for view related functionality, like\nformatting a date.  Data related methods should be in the view model or models.\n\n## Examples\n\nCheck out the following examples built with `Component`.\n\n### Tabs\n\nThe following demos a tabs widget.  Click \"Add Vegetables\"\nto add a new tab.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/tabs.html'></div>\n\nAn instance of the tabs widget is created by creating `<tabs>` and `<panel>`\nelements like:\n\n    <tabs>\n      {{#each foodTypes}}\n        <panel title='title'>{{content}}</panel>\n      {{/each}}\n    </tabs>\n\nTo add another panel, all we have to do is add data to `foodTypes` like:\n\n    foodTypes.push({\n      title: \"Vegetables\",\n      content: \"Carrots, peas, kale\"\n    })\n\nThe secret is that the `<panel>` element listens to when it is inserted\nand adds its data to the tabs' list of panels with:\n\n    var vm = this.parentViewModel = canViewModel(this.element.parentNode);\n    vm.addPanel(this.viewModel);\n\n\n### TreeCombo\n\nThe following tree combo lets people walk through a hierarchy and select locations.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/treecombo.html'></div>\n\nThe secret to this widget is the viewModel's `breadcrumb` property, which is an array\nof items the user has navigated through, and `selectableItems`, which represents the children of the\nlast item in the breadcrub.  These are defined on the viewModel like:\n\n\n    breadcrumb: [],\n    selectableItems: function(){\n      var breadcrumb = this.attr(\"breadcrumb\");\n\n      // if there's an item in the breadcrumb\n      if(breadcrumb.attr('length')){\n\n        // return the last item's children\n        return breadcrumb.attr(\"\"+(breadcrumb.length-1)+'.children');\n      } else{\n\n        // return the top list of items\n        return this.attr('items');\n      }\n    }\n\nWhen the \"+\" icon is clicked next to each item, the viewModel's `showChildren` method is called, which\nadds that item to the breadcrumb like:\n\n    showChildren: function(item, ev) {\n      ev.stopPropagation();\n      this.attr('breadcrumb').push(item)\n    },\n\n### Paginate\n\nThe following example shows 3\nwidget-like components: a grid, next / prev buttons, and a page count indicator. And, it shows an application component that puts them all together.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate.html'></div>\n\nThis demo uses a `Paginate` [can-define/map/map] to assist with maintaining a paginated state:\n\n    var Paginate = DefineMap.extend({\n    ...\n    });\n\nThe `app` component, using [can-define/map/map], creates an instance of the `Paginate` model\nand a `websitesPromise` that represents a request for the Websites\nthat should be displayed.  Notice how the paginate's `count` value is tied to the\nvalue of the `webistesPromise`'s resolved `value`'s `count`.\n\n```js\nvar AppViewModel = DefineMap.extend({\n\tpaginate: {\n\t\tvalue: function() {\n\t\t\treturn new Paginate({\n\t\t\t\tlimit: 5,\n\t\t\t\tcount: compute(this, \"websitesPromise.value.count\")\n\t\t\t});\n\t\t}\n\t},\n\twebsitesPromise: {\n\t\tget: function() {\n\t\t\tvar params = {\n\t\t\t\t\tlimit: this.paginate.limit,\n\t\t\t\t\toffset: this.paginate.offset\n\t\t\t\t},\n\t\t\t\twebsitesPromise = Website.getList(params),\n\t\t\t\tself = this;\n\n\t\t\twebsitesPromise.then(function(websites) {\n\t\t\t\tself.paginate.count = websites.length;\n\t\t\t});\n\n\t\t\treturn websitesPromise;\n\t\t}\n\t}\n});\n```\n\nThe `app` control passes paginate, paginate's values, and websitesPromise to\nits sub-components:\n\n    <app>\n      <grid {promise-data}='websitesPromise'>\n        {{#each items}}\n          <tr>\n            <td width='40%'>{{name}}</td>\n            <td width='70%'>{{url}}</td>\n          </tr>\n        {{/each}}\n      </grid>\n      <next-prev {paginate}='paginate'></next-prev>\n      <page-count {page}='paginate.page' {count}='paginate.pageCount'/>\n    </app>\n\n",
    "description": "Create a custom element that can be used to manage widgets or application logic.\n\n",
    "name": "can-component",
    "type": "module",
    "title": "can-component",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "download": "can/component",
    "test": "can/component/test.html",
    "parent": "can-core",
    "release": "2.0",
    "link": "../docco/component/component.html docco",
    "signatures": [
      {
        "code": "&lt;TAG BINDINGS...>[LIGHT_DOM]&lt;/TAG>",
        "description": "\n\n  Create an instance of a component on a particular tag in a [can-stache] template.\n  In 2.3, use the [can-stache-bindings bindings] syntaxes to setup bindings.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "TAG",
            "description": "An HTML tag name that matches the [can-component::tag tag]\nproperty of the component. Tag names should include a hypen (`-`) or a colon (`:`) like:\n`acme-tabs` or `acme:tabs`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache-bindings"
              }
            ],
            "optional": true,
            "name": "BINDINGS",
            "description": "Use the following binding syntaxes\nto connect the component's [can-component::ViewModel] to the template's [can-view-scope scope]:\n\n - [can-stache-bindings.toChild]=[can-stache.expressions expression] - one way data binding to child\n - [can-stache-bindings.toParent]=[can-stache.expressions expression] - one way data binding to parent\n - [can-stache-bindings.twoWay]=[can-stache.expressions expression] - two way data binding child to parent\n - [can-stache-bindings.event]=[can-stache/expressions/call expression] - event binding on the view model\n\n Note that because DOM attribute names are case-insensitive, use hypens (`-`) to\n in the attribute name to setup for `camelCase` properties.\n\n Example:\n\n ```\n <my-tag {to-child}=\"expression\"\n         {^to-parent}=\"expression\"\n         {(two-way)}=\"expression\"\n         (event)=\"callExpression()\"></my-tag>\n ```\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "LIGHT_DOM",
            "description": "The content between the starting and ending\ntag. For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `LIGHT_DOM` can be positioned with a component's [can-component.prototype.view] with\nthe [can-component/content] element.  The data accessible to the `LIGHT_DOM` can be controlled\nwith [can-component.prototype.leakScope].\n\n"
          }
        ],
        "release": "2.3"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "LIGHT_DOM",
      "description": "The content between the starting and ending\ntag. For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `LIGHT_DOM` can be positioned with a component's [can-component.prototype.view] with\nthe [can-component/content] element.  The data accessible to the `LIGHT_DOM` can be controlled\nwith [can-component.prototype.leakScope].\n\n"
    },
    "comment": " "
  },
  "Component": {
    "name": "Component",
    "type": "add",
    "description": "undefined\n"
  },
  "Component.static": {
    "src": {
      "line": 40,
      "codeLine": 44,
      "path": "node_modules/can-component/can-component.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "Component.static",
    "parent": "Component",
    "title": "static"
  },
  "Component.prototype": {
    "src": {
      "line": 120,
      "codeLine": 123,
      "path": "node_modules/can-component/can-component.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "Component.prototype",
    "parent": "Component",
    "title": "prototype"
  },
  "can-compute": {
    "src": {
      "path": "node_modules/can-compute/docs/compute.md"
    },
    "body": "\n## Use\n\n`compute` lets you make an observable value. Computes are similar\nto observable maps like [can-define/map/map], but they represent a single value rather than a collection of values.\n\n`compute` returns a [can-compute.computed] function that can\nbe called to read and optionally update the compute's value.\n\nIt's also possible to derive a compute's value from other computes, maps and lists.\nWhen the derived values change, the compute's value will be automatically updated.\n\nUse [can-compute.computed.on] to listen for changes of the\ncompute's value.\n\n## Observing a value\n\nThe simplest way to use a compute is to have it store a single value, and to set it when\nthat value needs to change:\n\n```js\nvar tally = compute(12);\ntally(); // 12\n\ntally.on(\"change\",function(ev, newVal, oldVal){\n\tconsole.log(newVal,oldVal)\n})\n\ntally(13);\ntally(); // 13\n```\n\nAny value can be observed.  The following creates a compute\nthat holds an object and then changes it to an array.\n\n```js\nvar data = compute({name: \"Justin\"})\ndata([{description: \"Learn Computes\"}])\n```\n\n\n## Derived computes\n\nIf you use a compute that derives its\nvalue from properties of an observable map or other [can-compute]s, the compute will listen for changes in those\nproperties and automatically recalculate itself, emitting a _change_ event if its value\nchanges.\n\nThe following example shows creating a `fullName` compute\nthat derives its value from two properties on the `person` observe:\n\n```js\nvar person = new Person({\n\tfirstName: 'Alice',\n\tlastName: 'Liddell'\n});\n\nvar fullName = compute(function() {\n\treturn person.firstName + ' ' + person.lastName;\n});\n\nfullName.on('change', function(ev, newVal, oldVal) {\n\t\tconsole.log(\"This person's full name is now \" + newVal + '.');\n});\n\nperson.firstName = 'Allison'; // The log reads:\n//-> \"This person's full name is now Allison Liddell.\"\n```\n\nBecause Person is an observable [can-define/map/map] can-compute knows to listen for changes because the map's firstName and lastName properties are read.\n\n## Translator computes - computes that update their derived values\n\nSometimes you need a compute to be able to translate one value to another. For example,\nconsider a widget that displays and allows you to update the progress in percent\nof a task. It accepts a compute with values between 0 and 100. But,\nour task observe has progress values between 0 and 1 like:\n\n```js\nvar task = new DefineMap({\n\tprogress: 0.75\n});\n```\n\nUse `compute( getterSetter )` to create a compute that updates itself\nwhen task's `progress` changes, but can also update progress when\nthe compute function is called with a value.  For example:\n\n```js\nvar progressPercent = compute(function(percent){\n\tif(arguments.length){\n\t\ttask.progress = percent / 100;\n\t} else {\n\t\treturn task.progress * 100;\n\t}\n})\n\nprogressPercent() // -> 75\n\nprogressPercent(100)\n\ntask.progress; // -> 1\n```\n\n\nThe following is a similar example that shows converting feet into meters and back:\n\n```js\nvar wall = new DefineMap({\n    material: 'brick',\n    length: 10 // in feet\n});\n\nvar wallLengthInMeters = compute(function(lengthInM) {\n\tif(arguments.length) {\n\t\twall.length = lengthInM / 3.28084;\n\t} else {\n\t\treturn wall.length * 3.28084;\n\t}\n});\n\nwallLengthInMeters(); // 3.048\n\n// When you set the compute...\nwallLengthInMeters(5);\nwallLengthInMeters(); // 5\n\n// ...the original map changes too.\nwall.length;          // 16.4042\n```\n\n## Events\n\nWhen a compute's value is changed, it emits a [can-compute.computed.ChangeEvent] event. You can listen for this change\nevent by using `on` to bind an event handler to the compute:\n\n```js\nvar tally = compute(0);\ntally.on('change', function(ev, newVal, oldVal) {\n    console.log('The tally is now at ' + newVal + '.');\n});\n\ntally(tally() + 5); // The log reads:\n                    // 'The tally is now at 5.'\n```\n\n",
    "description": "Create an observable value. \n",
    "name": "can-compute",
    "type": "module",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-core",
    "release": "1.1",
    "link": "../docco/compute/compute.html docco",
    "signatures": [
      {
        "code": "compute(getterSetter[, context])",
        "description": "\n\nCreate a compute that derives its value from other observables. Uses [can-observation] to call the `getterSetter` and track observables.\n\n```js\nvar age = compute(32);\n\nvar nameAndAge = compute(function(){\n\treturn \"Matthew - \" + age();\n});\n\nconsole.log(nameAndAge()); // -> Matthew - 32\n\nage(33);\n\nconsole.log(nameAndAge()); // -> Matthew - 33\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*+"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*+"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "name": "getterSetter",
            "description": "A function that gets, and optionally sets, the value of the compute. When called with no arguments, _getterSetter_ should return the current value of the compute. When called with a single argument, _getterSetter_ should arrange things so that the next read of the compute produces that value. This compute will automatically update its value when any observables values are read.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "The `this` to use when calling the `getterSetter` function.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n\n"
        }
      },
      {
        "code": "compute(initialValue [, settings])",
        "description": "\n\nCreates a compute from a value and optionally specifies how to read, update, and\nlisten to changes in dependent values. This form of compute can be used to\ncreate a compute that derives its value from any source.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "initialValue",
            "description": "The initial value of the compute. If `settings` is\nnot provided, the compute simply updates its value to whatever the first argument\nto the compute is.\n\n    var age = compute(30);\n    age() //-> 30\n    age(31) //-> fires a \"change\" event\n"
          },
          {
            "types": [
              {
                "type": "can-compute.computeSettings"
              }
            ],
            "optional": true,
            "name": "settings",
            "description": "\n\nConfigures all behaviors of the [can-compute.computed]. The following cross\nbinds an input element to a compute:\n\n```js\nvar input = document.getElementById(\"age\")\nvar value = compute(\"\",{\n\tget: function(){\n\t\treturn input.value;\n\t},\n\tset: function(newVal){\n\t\tinput.value = newVal;\n\t},\n\ton: function(updated){\n\t\tinput.addEventListener(\"change\", updated, false);\n\t},\n\toff: function(updated){\n\t\tinput.removeEventListener(\"change\", updated, false);\n\t}\n})\n```\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The new compute.\n\n"
        }
      },
      {
        "code": "compute(initialValue, setter(newVal,oldVal))",
        "description": "\n\nCreate a compute that has a setter that can adjust incoming new values.\n\n```js\nvar age = compute(6,function(newVal, oldVal){\n\tif(!isNaN(+newVal)){\n\t\treturn +newVal;\n\t} else {\n\t\treturn oldVal;\n\t}\n});\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "initialValue",
            "description": "\n\nThe initial value of the compute.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "name": "setter",
            "description": "\n\nA function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can-compute.computed] and the current value. If\n`set` returns a value, it is used to compare to the current value of the compute. Otherwise,\n`get` is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n"
        }
      },
      {
        "code": "compute(object, propertyName [, eventName])",
        "description": "\n\nCreate a compute from an object's property value. This short-cut\nsignature lets you create a compute on objects that have events\nthat can be listened to with [can-compute.computed.on].\n\n```js\nvar input = document.getElementById('age')\nvar age = compute(input,\"value\",\"change\");\n\nvar me = new DefineMap({name: \"Justin\"});\nvar name = compute(me,\"name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "An object that has an `addEventListener` method and events dispatched on it.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The property value to read on `object`.  The\nproperty will be read via `object.attr(propertyName)` or `object[propertyName]`.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "eventName",
            "defaultValue": "propertyName",
            "description": "Specifies the event name to listen\nto on `object` for `propertyName` updates.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A new compute.\n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "eventName",
      "defaultValue": "propertyName",
      "description": "Specifies the event name to listen\nto on `object` for `propertyName` updates.\n"
    },
    "comment": " "
  },
  "can-construct": {
    "name": "can-construct",
    "type": "module",
    "description": " \nProvides a way to easily use the power of prototypal inheritance\nwithout worrying about hooking up all the particulars yourself. Use\n[can-construct.extend can-construct.extend] to create an inheritable\nconstructor function of your own.\n\n",
    "src": {
      "path": "node_modules/can-construct/docs/construct.md"
    },
    "body": "\n## Use\n\nIn the example below, `Animal` is a constructor function returned by [can-construct.extend can-construct.extend]. All instances of `Animal` will have a `speak`\nmethod, and the `Animal` constructor has a `legs` property.\n\n\n    var Construct = require(\"can-construct\");\n\tvar Animal = Construct.extend({\n        legs: 4\n    }, {\n        init: function(sound) {\n            this.sound = sound;\n        },\n        speak: function() {\n            console.log(this.sound);\n        }\n    });\n\n\nYou can make instances of your object by calling your constructor function with the `new` keyword. When an object is created, the [can-construct::init init]\nmethod gets called (if you supplied one):\n\n    var panther = new Animal('growl');\n    panther.speak(); // \"growl\"\n    panther instanceof Animal; // true\n\n## Plugins\n\nThere are two plugins available to help make using `can-construct` even simpler.\n\n-   [can-construct-super] allows you to easily call base methods by making `this._super` available in inherited methods.\n-   [can-construct-proxy] creates a static callback function that sets the value of `this` to an instance of the constructor function.\n\n",
    "title": "can-construct",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-core",
    "comment": " "
  },
  "can-construct.static": {
    "src": {
      "line": 59,
      "codeLine": 62,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "can-construct.static",
    "parent": "can-construct",
    "title": "static"
  },
  "can-construct.constructorExtends": {
    "name": "can-construct.constructorExtends",
    "type": "property",
    "parent": "can-construct.static",
    "src": {
      "line": 63,
      "codeLine": 130,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n If `constructorExtends` is:\n\n  - `true` - the constructor extends\n  - `false` - a new instance of the constructor is created\n\n This property defaults to false.\n\n Example of constructExtends as `true`:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: true // the constructor extends\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var Pony = Animal({\n   gallop: function () {\n      console.log(\"Galloping!!\");\n   }\n }); // Pony is now a constructor function extended from Animal\n\n var frank = new Animal(); // frank is a new instance of Animal\n\n var gertrude = new Pony(); // gertrude is a new instance of Pony\n gertrude.sayHi(); // \"hai!\" - sayHi is \"inherited\" from Animal\n gertrude.gallop(); // \"Galloping!!\" - gallop is unique to instances of Pony\n```\n\n The default behavior is shown in the example below:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: false // the constructor does NOT extend\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var pony = Animal(); // pony is a new instance of Animal\n var frank = new Animal(); // frank is a new instance of Animal\n\n pony.sayHi() // \"hai!\"\n frank.sayHi() // \"hai!\"\n```\n By default to extend a constructor, you must use [can-construct.extend extend].\n\t \n",
    "description": "  Toggles the behavior of a constructor function called\n without the `new` keyword to extend the constructor function or\n create a new instance.\n\n ```js\n var animal = Animal();\n // vs\n var animal = new Animal();\n ```\n\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "constructorExtends",
    "comment": " "
  },
  "can-construct.newInstance": {
    "type": "function",
    "name": "can-construct.newInstance",
    "parent": "can-construct.static",
    "src": {
      "line": 131,
      "codeLine": 196,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "Creates a new instance of the constructor function. This method is useful for creating new instances\nwith arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n__new__ operator.\n\n## Example\n\nThe following creates a `Person` Construct and overrides `newInstance` to cache all\ninstances of Person to prevent duplication. If the properties of a new Person match an existing one it\nwill return a reference to the previously created object, otherwise it returns a new object entirely.\n\n```js\n// define and create the Person constructor\nvar Person = Construct.extend({\n  init : function(first, middle, last) {\n    this.first = first;\n    this.middle = middle;\n    this.last = last;\n  }\n});\n\n// store a reference to the original newInstance function\nvar _newInstance = Person.newInstance;\n\n// override Person's newInstance function\nPerson.newInstance = function() {\n  // if cache does not exist make it an new object\n  this.__cache = this.__cache || {};\n  // id is a stingified version of the passed arguments\n  var id = JSON.stringify(arguments);\n\n  // look in the cache to see if the object already exists\n  var cachedInst = this.__cache[id];\n  if(cachedInst) {\n    return cachedInst;\n  }\n\n  //otherwise call the original newInstance function and return a new instance of Person.\n  var newInst = _newInstance.apply(this, arguments);\n  this.__cache[id] = newInst;\n  return newInst;\n};\n\n// create two instances with the same arguments\nvar justin = new Person('Justin', 'Barry', 'Meyer'),\n\tbrian = new Person('Justin', 'Barry', 'Meyer');\n\nconsole.log(justin === brian); // true - both are references to the same instance\n```\n\n \n",
    "description": "Returns an instance of `Construct`. This method can be overridden to return a cached instance.\n\n",
    "title": "newInstance",
    "signatures": [
      {
        "code": "Construct.newInstance([...args])",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "args",
            "description": "arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\nthat if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\ninstead."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "class"
            }
          ],
          "description": "instance of the class\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "args",
      "description": "arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\nthat if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\ninstead."
    },
    "_curReturn": {
      "types": [
        {
          "type": "class"
        }
      ],
      "description": "instance of the class\n"
    },
    "comment": " "
  },
  "can-construct.setup": {
    "type": "function",
    "name": "can-construct.setup",
    "parent": "can-construct.static",
    "src": {
      "line": 239,
      "codeLine": 300,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "The static `setup` method is called immediately after a constructor\nfunction is created and\nset to inherit from its base constructor. It is useful for setting up\nadditional inheritance work.\nDo not confuse this with the prototype `[can-construct::setup]` method.\n\n## Example\n\nThis `Parent` class adds a reference to its base class to itself, and\nso do all the classes that inherit from it.\n\n```js\nParent = Construct.extend({\n  setup : function(base, fullName, staticProps, protoProps){\n    this.base = base;\n\n    // call base functionality\n    Construct.setup.apply(this, arguments)\n  }\n},{});\n\nParent.base; // Construct\n\nChild = Parent({});\n\nChild.base; // Parent\n```\n \n",
    "description": "Perform initialization logic for a constructor function. \n",
    "title": "setup",
    "signatures": [
      {
        "code": "Construct.setup(base, fullName, staticProps, protoProps)",
        "description": "\n\nA static `setup` method provides inheritable setup functionality\nfor a Constructor function. The following example\ncreates a Group constructor function.  Any constructor\nfunctions that inherit from Group will be added to\n`Group.childGroups`.\n\n\n    Group = Construct.extend({\n      setup: function(Construct, fullName, staticProps, protoProps){\n        this.childGroups = [];\n        if(Construct !== Construct){\n          this.childGroups.push(Construct)\n        }\n        Construct.setup.apply(this, arguments)\n      }\n    },{})\n    var Flock = Group.extend(...)\n    Group.childGroups[0] //-> Flock\n",
        "params": [
          {
            "types": [
              {
                "type": "constructor"
              }
            ],
            "name": "base",
            "description": "The base constructor that is being inherited from."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "fullName",
            "description": "The name of the new constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "staticProps",
            "description": "The static properties of the new constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "protoProps",
            "description": "The prototype properties of the new constructor.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "protoProps",
      "description": "The prototype properties of the new constructor.\n"
    },
    "comment": " "
  },
  "can-construct.extend": {
    "type": "function",
    "name": "can-construct.extend",
    "parent": "can-construct.static",
    "src": {
      "line": 314,
      "codeLine": 452,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "## Inheritance\nCreating \"subclasses\" with `Construct` is simple. All you need to do is call the base constructor\nwith the new function's static and instance properties. For example, we want our `Snake` to\nbe an `Animal`, but there are some differences:\n\n\n    var Snake = Animal.extend({\n        legs: 0\n    }, {\n        init: function() {\n            Animal.prototype.init.call(this, 'ssssss');\n        },\n        slither: function() {\n            console.log('slithering...');\n        }\n    });\n\n    var baslisk = new Snake();\n    baslisk.speak();   // \"ssssss\"\n    baslisk.slither(); // \"slithering...\"\n    baslisk instanceof Snake;  // true\n    baslisk instanceof Animal; // true\n\n\n## Static properties and inheritance\n\nIf you pass all three arguments to Construct, the second one will be attached directy to the\nconstructor, allowing you to imitate static properties and functions. You can access these\nproperties through the `[can-construct::constructor this.constructor]` property.\n\nStatic properties can get overridden through inheritance just like instance properties. In the example below,\nwe override both the legs static property as well as the the init function for each instance:\n\n```js\nvar Animal = Construct.extend({\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    },\n    speak: function() {\n        console.log(this.sound);\n    }\n});\n\nvar Snake = Animal.extend({\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nAnimal.legs; // 4\nSnake.legs; // 0\nvar dog = new Animal('woof');\nvar blackMamba = new Snake();\ndog.speak(); // 'woof'\nblackMamba.speak(); // 'ssssss'\n```\n \n",
    "description": "\n",
    "title": "extend",
    "signatures": [
      {
        "code": "Construct.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nExtends `Construct`, or constructor functions derived from `Construct`,\nto create a new constructor function. Example:\n\n```js\nvar Animal = Construct.extend({\n  sayHi: function(){\n    console.log(\"hi\")\n  }\n});\n\nvar animal = new Animal()\nanimal.sayHi();\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Adds a name to the constructor function so\nit is nicely labeled in the developer tools. The following:\n\n    Construct.extend(\"ConstructorName\",{})\n\nreturns a constructur function that will show up as `ConstructorName`\nin the developer tools.\nIt also sets \"ConstructorName\" as [can-construct.shortName shortName].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties that are added the constructor\nfunction directly. For example:\n\n```js\nvar Animal = Construct.extend({\n  findAll: function(){\n    return can.ajax({url: \"/animals\"})\n  }\n},{}); // need to pass an empty instanceProperties object\n\nAnimal.findAll().then(function(json){ ... })\n```\n\nThe [can-construct.setup static setup] method can be used to\nspecify inheritable behavior when a Constructor function is created.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [can-construct::init init] and [can-construct::setup setup] properties\nare used for initialization.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceProperties",
      "description": "Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [can-construct::init init] and [can-construct::setup setup] properties\nare used for initialization.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"
    },
    "comment": " "
  },
  "can-construct.shortName": {
    "src": {
      "line": 540,
      "codeLine": 554,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "property",
    "body": "\n```js\nvar MyConstructor = Construct.extend(\"MyConstructor\",{},{});\nMyConstructor.shortName // \"MyConstructor\"\n```\n\t\t \n",
    "description": "\nIf you pass a name when creating a Construct, the `shortName` property will be set to the\nname.\n",
    "types": [
      {
        "type": "String"
      }
    ],
    "title": "shortName",
    "name": "can-construct.shortName",
    "parent": "can-construct.static"
  },
  "can-construct.prototype": {
    "src": {
      "line": 565,
      "codeLine": 568,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "can-construct.prototype",
    "parent": "can-construct",
    "title": "prototype"
  },
  "can-construct.prototype.constructor": {
    "src": {
      "line": 569,
      "codeLine": 598,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "property",
    "body": "\n## Example\n\nThis Construct has a static counter that counts how many instances have been created:\n\n```js\nvar Counter = Construct.extend({\n    count: 0\n}, {\n    init: function() {\n        this.constructor.count++;\n    }\n});\n\nvar childCounter = new Counter();\nconsole.log(childCounter.constructor.count); // 1\nconsole.log(Counter.count); // 1\n```\n\t \n",
    "description": "\nA reference to the constructor function that created the instance. This allows you to access\nthe constructor's static properties from an instance.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "constructor",
    "name": "can-construct.prototype.constructor",
    "parent": "can-construct.prototype",
    "comment": " "
  },
  "can-construct.prototype.setup": {
    "type": "function",
    "name": "can-construct.prototype.setup",
    "parent": "can-construct.prototype",
    "src": {
      "line": 598,
      "codeLine": 643,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n## Deciding between `setup` and `init`\n\n\nUsually, you should use [can-construct::init init] to do your constructor function's initialization.\nYou should, instead, use `setup` when:\n\n  - there is initialization code that you want to run before the inheriting constructor's\n    `init` method is called.\n  - there is initialization code that should run whether or not inheriting constructors\n    call their base's `init` methods.\n  - you want to modify the arguments that will get passed to `init`.\n\n\n",
    "description": "\n",
    "title": "setup",
    "signatures": [
      {
        "code": "construct.setup(...args)",
        "description": "\n\nA setup function for the instantiation of a constructor function.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "The arguments passed to the constructor.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If an array is returned, the array's items are passed as\narguments to [can-construct::init init]. The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n```js\n\tWidgetFactory = Construct.extend({\n\t\t\tsetup: function(element){\n\t\t\t\t\treturn [$(element)]\n\t\t\t}\n\t});\n\n\tMyWidget = WidgetFactory.extend({\n\t\t\tinit: function($el){\n\t\t\t\t\t$el.html(\"My Widget!!\")\n\t\t\t}\n\t});\n ```\n\nOtherwise, the arguments to the\nconstructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "The arguments passed to the constructor.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If an array is returned, the array's items are passed as\narguments to [can-construct::init init]. The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n```js\n\tWidgetFactory = Construct.extend({\n\t\t\tsetup: function(element){\n\t\t\t\t\treturn [$(element)]\n\t\t\t}\n\t});\n\n\tMyWidget = WidgetFactory.extend({\n\t\t\tinit: function($el){\n\t\t\t\t\t$el.html(\"My Widget!!\")\n\t\t\t}\n\t});\n ```\n\nOtherwise, the arguments to the\nconstructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n"
    },
    "comment": " "
  },
  "can-construct.prototype.init": {
    "type": "function",
    "name": "can-construct.prototype.init",
    "parent": "can-construct.prototype",
    "src": {
      "line": 644,
      "codeLine": 703,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "If a prototype `init` method is provided, `init` is called when a new Construct is created---\nafter [can-construct::setup]. The `init` method is where the bulk of your initialization code\nshould go. A common thing to do in `init` is save the arguments passed into the constructor.\n\n## Examples\n\nFirst, we'll make a Person constructor that has a first and last name:\n\n```js\nvar Person = Construct.extend({\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar justin = new Person(\"Justin\", \"Meyer\");\njustin.first; // \"Justin\"\njustin.last; // \"Meyer\"\n```\n\nThen, we'll extend Person into Programmer, and add a favorite language:\n\n```js\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n\nvar brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\nbrian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n```\n\n## Modified Arguments\n\n[can-construct::setup] is able to modify the arguments passed to `init`.\nIf you aren't receiving the arguments you passed to `new Construct(args)`,\ncheck that they aren't being changed by `setup` along\nthe inheritance chain.\n\n",
    "description": "Called when a new instance of a Construct is created. \n",
    "title": "init",
    "signatures": [
      {
        "code": "construct.init(...args)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n"
    },
    "comment": " "
  },
  "connect": {
    "type": "function",
    "name": "connect",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "String"
                  }
                ]
              },
              {
                "types": [
                  {
                    "type": "Behavior"
                  }
                ]
              },
              {
                "types": [
                  {
                    "type": "function",
                    "returns": {
                      "types": [
                        {
                          "type": "undefined"
                        }
                      ]
                    },
                    "params": []
                  }
                ]
              }
            ]
          }
        ],
        "name": "behaviors",
        "description": "- An array of behavior names or custom behaviors.\nThe order of named execution gets run in order."
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "options",
        "description": "\n"
      }
    ],
    "parent": "node_modules/can-connect/connect.js",
    "src": {
      "line": 1,
      "codeLine": 7,
      "path": "node_modules/can-connect/connect.js"
    },
    "body": "",
    "description": "",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "\n"
    }
  },
  "can-connect.behaviors": {
    "name": "can-connect.behaviors",
    "title": "Behaviors",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 1
  },
  "can-connect.modules": {
    "name": "can-connect.modules",
    "title": "Modules",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 2
  },
  "can-connect.types": {
    "name": "can-connect.types",
    "title": "Data Types",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 3
  },
  "can-connect": {
    "src": {
      "path": "node_modules/can-connect/can-connect.md"
    },
    "body": "\n`can-connect` comes with the following behaviors that:\n\nLoad data:\n\n - [can-connect/data/url/url] - Persist data to restful or other types of services.\n - [can-connect/data/parse/parse] - Extract response data into a format needed for other extensions.\n\nConvert data into special types:\n\n - [can-connect/constructor/constructor] - Create instances of a constructor function or list type.\n - [can-connect/constructor/store/store] - Create only a single instance for a given id or a single list for a set.\n\nReal time:\n\n - [can-connect/real-time/real-time] - Update lists and instances with server side events.\n\nCaching strategies:\n\n - [can-connect/fall-through-cache/fall-through-cache] - Respond with data from the [connection.cacheConnection] and\n   then update the response with data from the `raw CRUD Methods`.\n - [can-connect/data/inline-cache/inline-cache] - Use an inline cache for initial ajax requests.\n - [can-connect/cache-requests/cache-requests] - Save response data and use it for future requests.\n - [can-connect/data/combine-requests/combine-requests] - Combine overlapping or reduntant requests.\n\nCaching layers:\n\n - [can-connect/data/localstorage-cache/localstorage-cache] - LocalStorage caching connection.\n - [can-connect/data/memory-cache/memory-cache] - LocalStorage caching connection.\n\nThe following modules glue certain methods together:\n\n - [can-connect/data/callbacks/callbacks] - Glues the result of the `raw CRUD Methods` to callbacks.\n - [can-connect/data/callbacks-cache/callbacks-cache] - Calls [connection.cacheConnection] methods whenever `raw CRUD methods` are called.\n\n\nThe following modules are useful to CanJS specifically:\n\n - [can-connect/can/map/map] - Create instances of a special can.Map or can.List type.\n - [can-connect/can/super-map/super-map] - Create a connection for a can.Map or can.List that uses almost all the plugins.\n - [can-connect/can/model/model] - Inherit from a highly compatable [can.Model](http://canjs.com/docs/can.Model.html) implementation.\n - [can-connect/can/tag/tag] - Create a custom element that can load data into a template.\n\n## Overview\n\nThe \"can-connect\" module exports a `connect` function that is used to assemble different\nbehaviors and some options into a `connection`.  For example, the following uses `connect` and\nthe [can-connect/constructor/constructor] and [can-connect/data/url/url] behaviors to create a `todoConnection`\nconnection:\n\n```js\nvar connect = require(\"can-connect\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\nvar todoConnection = connect(\n  [constructor,dataUrl],\n  {\n    url: \"/services/todos\"\n  });\n```\n\nA connection typically provides the ability to\ncreate, read, update, or delete (CRUD) some data source. That data source is\nusually accessed through the \"Instance Interface\" methods:\n\n - [can-connect/connection.get]\n - [can-connect/connection.getList]\n - [can-connect/connection.save]\n - [can-connect/connection.destroy]\n\nFor example, to get all todos from \"GET /services/todos\", we could write the following:\n\n```\ntodoConnection.getList({}).then(function(todos){ ... });\n```\n\n__Behaviors__, like [can-connect/constructor/constructor] and [can-connect/data/url/url] implement,\nextend, or require some set of [interfaces](#section_Interfaces).  For example, [can-connect/data/url/url] implements\nthe \"Data Interface\" methods, and [can-connect/constructor/constructor] implements the\n\"Instance Interface\" methods.\n\nThe `connect` method calls these behaviors in the right order to create a connection. For instance,\nthe [can-connect/cache-requests/cache-requests] behavior must be applied after the [can-connect/data/url/url]\nconnection.  This is because [can-connect/cache-requests/cache-requests], overwrites [can-connect/data/url/url]'s\n[can-connect/connection.getListData] first check a cache for the data.  Only if the data is not present,\ndoes it call [can-connect/data/url/url]'s [can-connect/connection.getListData]. So even if we write:\n\n```js\nvar dataUrl = require(\"can-connect/data/url/url\");\nvar cacheRequests = require(\"can-connect/cache-requests/cache-requests/cache-requests\");\nconnect([cacheRequests,dataUrl])\n```\n\nor\n\n```\nconnect([dataUrl,cacheRequests])\n```\n\n... our connection will be built in the right order!\n\nA __connection__ is just an object with each behavior object on its prototype chain and\nits options object at the end of the prototype chain.\n\n\n### Basic Use\n\nTo use `can-connect`, it's typically best to start out with the most basic\nbehaviors: [can-connect/data/url/url] and [can-connect/constructor/constructor]. [can-connect/data/url/url]\nconnects the \"Data Interface\" to a restful service. [can-connect/constructor/constructor] adds\nan \"Instance Interface\" that can create, read, update and delete (CRUD) typed data\nusing the lower-level \"Data Interface\".\n\nBy `typed` data we mean data that is more than just plain JavaScript objects.  For\nexample, we might to create `todo` objects with an `isComplete` method:\n\n```js\nvar Todo = function(props){\n  Object.assign(this, props);\n};\n\nTodo.prototype.isComplete = function(){\n  return this.status === \"complete\";\n};\n```\n\nAnd, we might want a special list type with `completed` and `active` methods:\n\n```js\nvar TodoList = function(todos){\n  [].push.apply(this, todos);\n};\nTodoList.prototype = Object.create(Array.prototype);\n\nTodoList.prototype.completed = function(){\n  return this.filter(function(todo){\n    return todo.status === \"complete\";\n  });\n};\n\nTodoList.prototype.active = function(){\n  return this.filter(function(todo){\n    return todo.status !== \"complete\";\n  });\n};\n```\n\nWe can create a connection that connects a restful \"/api/todos\"\nservice to `Todo` instances and `TodoList` lists like:\n\n```js\nvar todoConnection = connect([constructor, dataUrl],{\n  url: \"/api/todos\",\n  list: function(listData, set){\n  \treturn new TodoList(listData.data);\n  },\n  instance: function(props) {\n  \treturn new Todo(props);\n  }\n});\n```\n\nAnd then use that connection to get a `TodoList` of `Todo`s:\n\n```js\ntodoConnection.getList({}).then(function(todos){\n\tvar todosEl = document.getElementById(\"todos-list\");\n\ttodosEl.innerHTML = \"<h2>Active</h2>\"+\n\t\trender(todos.active())+\n\t\t\"<h2>Complete</h2>\"+\n\t\trender(todos.completed());\n});\n\nvar render = function(todos) {\n\treturn \"<ul>\"+todos.map(function(todo){\n\t\treturn \"<li>\"+todo.name+\n\t\t\t\t\"<input type='checkbox' \"+\n\t\t\t\t(todo.isComplete() ? \"checked\" : \"\")+\"/></li>\";\n\t}).join(\"\")+\"</ul>\";\n};\n```\n\nThe following demo shows the result:\n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/basics.html'></div>\n\nThis connection also lets you create, update, and destroy a Todo instance as follows:\n\n```js\nvar todo = new Todo({\n  name: \"take out trash\"\n})\n\n// POSTs to /api/todos name=take out trash\n// server returns {id: 5}\ntodoConnection.save( todo ).then(function(todo){\n  todo.id //-> 5\n  todo.name = 'take out garbage'\n\n  // PUTs to /api/todos/5 name=take out garbage\n  // server returns {id: 5, \"take out garbage\"}\n  todoConnection.save( todo ).then( function(todo){\n\n    // DELETEs to /api/todos/5\n    // server returns {}\n    todoConnection.destroy( todo ).then( function(todo){\n\n    });\n\n  });\n\n});\n```\n\n### Configure behaviors\n\nWhenever `connect` creates a connection, it always adds the [can-connect/base/base]\nbehavior. This behavior defines configurable options that are used by almost\nevery other behavior.  For example, if your data uses an `_id` property\nto uniquely identify todos, you\ncan specify this with [can-connect/base/base.idProp] like:\n\n```js\nvar todoConnection = connect([\"constructor\",\"data-url\"],{\n  url: \"/api/todos\",\n  idProp: \"_id\"\n});\n```\n\nOther behaviors list their configurable options in their own docs page.  \n\n### Overwrite behaviors\n\nIf configurable options are not enough, you can overwrite any behavior with your own behavior.\n\nFor example, the `constructor`'s [can-connect/constructor/constructor.updatedInstance] behavior\nsets the instance's properties to match the result of [can-connect/connection.updateData]. But if\nthe `PUT /api/todos/5 name=take out garbage` request returned `{}`, the following would result in\na todo with only an `id` property:\n\n```js\nvar todo = new Todo({id: 5, name: \"take out garbage\"})\n// PUTs to /api/todos/5 name=take out garbage\n// server returns {}\ntodoConnection.save( todo ).then( function(todo){\n\n  todo.id //-> 5\n  todo.name //-> undefined\n});\n```\n\nThe following overwrites the behavior of `updateData`:\n\n```js\nvar mergeDataBehavior = {\n  updateData: function(instance, data){\n    Object.assign(instance, data);\n  }\n}\n\n\nvar todoConnection = connect([\n    \"constructor\",\n    \"data-url\",\n    mergeDataBehavior\n  ],{\n  url: \"/api/todos\"\n});\n```\n\nYou can add your own behavior that overwrite all base behaviors by adding\nit to the end of the behaviors list.\n\n\n### CanJS use\n\nIf you are using CanJS, you can either:\n\n- use the [can-connect/can/map/map] behavior that overwrites\n  many methods and settings to work with `can.Map` and `can.List`.\n- use the [can-connect/can/super-map/super-map] helper to create a connection that bundles \"can/map\" and\n  many of the other extensions.\n\nUsing [can-connect/can/map/map] to create a connection looks like:\n\n```js\nvar Todo = can.Map.extend({ ... });\nTodo.List = can.List.extend({Map: Todo},{});\n\nvar todoConnection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/can/map/map/map\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/constructor/store/store\")\n  ],{\n  Map: Todo,\n  url: \"/todos\"\n});\n```\n\nWhen you bind on a `Todo` instance or `Todo.List` list, they will automatically call\n[can.connect/constructor-store.addInstanceReference] and [can.connect/constructor-store.addListReference].\n\nUsing [can-connect/can/super-map/super-map] to create a connection looks like:\n\n```\nvar Todo = can.Map.extend({ ... });\nTodo.List = can.List.extend({Map: Todo},{});\n\nvar todoConnection = superMap({\n  Map: Todo,\n  url: \"/todos\"\n});\n```\n\n### ReactJS use\n\nHelp us create a special ReactJS behavior that integrates\na connection with React's observable life-cycle. Read more [here](#section_Otheruse).\n\n### Angular use\n\nHelp us create a special AngularJS behavior that integrates\na connection with Angular's observable life-cycle. Read more [here](#section_Otheruse).\n\n### Backbone use\n\nHelp us create a special BackboneJS behavior that integrates\na connection with Backbone's observable life-cycle. Read more [here](#section_Otheruse).\n\n### Other use\n\nIntegrating `can-connect` with your framework is typically pretty easy.  In general,\nthe pattern involves creating a behavior that integrates with your framework's\nobservable instances. The [can-connect/can/map/map]\nbehavior can serve as a good guide. You'll typically want to implement the following\nin your behavior:\n\n`.instance` - Creates the appropriate observable object type.  \n`.list` - Creates the appropriate observable array type.  \n`.serializeInstance` - Return a plain object out of the observable object type.  \n`.serializeList` - Return a plain array out of the observable array type.  \n\n`.createdInstance` - Update an instance with data returned from `createData`.  \n`.updatedInstance` - Update an instance with data returned from `updateData`.  \n`.destroyedInstance` -  Update an instance with data returned from `destroyData`.  \n`.updatedList` - Update a list with raw data.\n\nAnd, in most frameworks you know when a particular observable is being used, typically\nobserved, and when it can be discarded.  In those places, you should call:\n\n[can-connect/constructor/store/store.addInstanceReference] - Call when an instance is being used.  \n[can-connect/constructor/store/store.deleteInstanceReference] - Call when an instance is no longer being used.  \n[can-connect/constructor/store/store.addListReference] - Call when a list is being used.  \n[can-connect/constructor/store/store.deleteListReference] - Called when a list is no longer being used.  \n\n\n## Interfaces\n\nThe following is a list of the most important interface methods and properties implemented\nor consumed by the core behaviors.\n\n### Identifiers\n\n`.id( props | instance ) -> String` - Returns a unique identifier for the instance or raw data.  \n`.idProp -> String=\"id\"` - The name of the unique identifier property.  \n`.listSet(list) -> set` - Returns the set a list represents.  \n`.listSetProp -> String=\"__listSet\"` - The property on a List that contains its set.  \n\nImplemented by [can-connect/base/base].\n\n### Instance Interface\n\nThe following methods operate on instances and lists.\n\n#### CRUD methods:\n\n`.getList(set) -> Promise<List>` - retrieve a list of instances.  \n`.getList(set) -> Promise<Instance>` - retrieve a single instance.   \n`.save(instance) -> Promise<Instance>` - creates or updates an instance.  \n`.destroy(instance) -> Promise<Instance>` - destroys an instance.  \n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [can-connect/constructor/store/store].\n\n#### Instance callbacks\n\n`.createdInstance(instance, props)` - An instance is created.  \n`.updatedInstance(instance, props)` - An instance is updated.  \n`.destroyedInstance(instance, props)` - An instance is destroyed.  \n`.updatedList(list, updatedListData, set)` - A list has been updated.  \n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [data-connect/real-time/real-time],\n[can-connect/constructor/callbacks-once/callbacks-once].\n\n#### Hydrators and Serializers\n\n`.instance(props) -> Instance` - Creates an instance given raw data.  \n`.list({data: Array<Instance>}) -> List` - Creates a list given an array of instances.  \n`.hydrateInstance(props) -> Instance` - Provides an instance given raw data.  \n`.hydrateList({ListData}, set) -> List` - Provides a list given raw data.  \n`.hydratedInstance(instance)` - Called whenever an instance is created in memory.  \n`.hydratedList(list, set)` - Called whenever a list is created in memory.  \n`.serializeInstance(instance) -> Object` - Returns the serialized form of an instance.  \n`.serializeList(list) -> Array<Object>` - Returns the serialized form of a list and its instances.  \n\n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [can-connect/constructor/store/store],\n[can-connect/fall-through-cache/fall-through-cache].\n\n### Data Interface\n\nThe raw-data connection methods.  \n\n#### CRUD methods\n\n`.getListData(set) -> Promise<ListData>` - Retrieves list data.  \n`.updateListData(listData[, set]) -> Promise<ListData>` - Update a list's data.  \n`.getSets() -> Promise<Array<Set>>` - Returns the sets available to the connection.  \n\n\n`.getData(params) -> Promise<Object>` - Retrieves data for a particular item.  \n`.createData(props, cid) -> Promise<props>` - Creates instance data given the serialized form of the data.\n  A client ID is passed of the\n  instance that is being created.  \n`.updateData(props) -> Promise<props>` - Updates instance data given the\n  serialized form of the data.  \n`.destroyData(props) -> Promise<props>` - Destroys an instance given the seralized\nform of the data.  \n\n`.clear() -> Promise` - Clears all data in the connection.\n\nImplemented by [can-connect/data/url/url],\n[can-connect/data/localstorage-cache/localstorage-cache], [can-connect/data/memory-cache/memory-cache].\nOverwritten by [can-connect/cache-requests/cache-requests], [can-connect/data/combine-requests/combine-requests],\n[can-connect/data/inline-cache/inline-cache], [can-connect/fall-through-cache/fall-through-cache].\nConsumed by [can-connect/constructor/constructor].  \n\n#### Data Callbacks\n\n`.gotListData(listData, set) -> ListaData` - List data is retrieved.  \n`.gotData( props, params) -> props` - Instance data is retreived.  \n`.createdData( props, params, cid) -> props` - An instance's data is created.  \n`.updatedData( props, params) -> props` - An instance's data is updated.  \n`.destroyedData( props, params) -> props` - An instance's data is destroyed.  \n\nImplemented by [can-connect/data/callbacks/callbacks].  Overwritten by [can-connect/data/callbacks-cache/callbacks-cache],\n[can-connect/real-time/real-time].\n\n#### Response parsers\n\n`.parseListData(*) -> ListData` - Given the response of getListData, return the right object format.  \n`.parseInstanceData(*) -> props` - Given the response of getData, createData, updateData, and destroyData,\nreturn the right object format.\n\nImplemented by [can-connect/data/parse/parse].\n\n#### Store Interface\n\n`.addInstanceReference(instance)` - Signal that memory-unsafe actions can be performed on the instance.  \n`.deleteInstanceReference(instance)` - Signal that memory-unsafe actions should be removed.\n`.addListReference(list)` - Signal that memory-unsafe actions can be performed on the list.  \n`.deleteListReference(list)` - Signal that memory-unsafe actions should be removed.\n\nImplemented by [can-connect/constructor/store/store].\n\n#### Real-time Methods\n\n`createInstance( props ) -> Promise<instance>` - Inform the connection an instance has been created.  \n`updateInstance( props ) -> Promise<instance>` - Inform the connection an instance has been updated.  \n`destroyInstance( props ) -> Promise<instance>` - Inform the connection an instance has been destroyed.  \n\nImplemented by [can-connect/real-time/real-time].\n\n## Creating Behaviors\n\nTo create your own behavior, call `connect.behavior` with the name of your behavior and a function that\nreturns an object that defines the hooks you want to overwrite or provide:\n\n```js\nconnect.behavior(\"my-behavior\", function(baseBehavior){\n  return {\n    // Hooks here\n  };\n})\n```\n\nFor example, creating a simple localStorage behavior might look like:\n\n```js\nconnect.behavior(\"localstorage\", function(baseBehavior){\n  return {\n    getData: function(params){\n      var id = this.id(params);\n      return new Promise(function(resolve){\n        var data = localStorage.getItem(baseBehavior.name+\"/\"+id);\n        resolve( JSON.parse(data) )\n      });\n    },\n    createData: function(props){\n      var id = localStorage.getItem(baseBehavior.name+\"-ID\") || \"0\";\n\n      var nextId = ++JSON.parse( id );\n      localStorage.setItem(baseBehavior.name+\"-ID\"), nextId);\n      var id = this.idProp;\n      return new Promise(function(resolve){\n        props[id] = nextId;\n        localStorage.setItem(baseBehavior.name+\"/\"+nextId, props);\n        resolve( props )\n      });\n    },\n    updateData: function(){ ... },\n    destroyData: function(){ ...}\n  };\n})\n```\n\n",
    "description": "`can-connect` provides persisted data middleware. Use it to assemble powerful model layers for any JavaScript project.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect",
    "parent": "can-core",
    "outline": "2",
    "signatures": [
      {
        "code": "connect(behaviors, options)",
        "description": "\n\nGoes through every behavior and assembles them into a final\nconnection.\n\n```js\nvar connect = require(\"can-connect\");\nvar todosConnection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/data/constructor/constructor\")    \n],{\n    url: \"/api/todos\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-connect/Behavior"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "behaviors",
            "description": "An array of\nbehaviors that will be used to compose the final connection.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "options",
            "description": "an object of configuration\noptions.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "an object of configuration\noptions.\n"
    },
    "comment": " "
  },
  "can.Control": {
    "name": "can.Control",
    "type": "add",
    "description": "undefined \n"
  },
  "can.Control.static": {
    "src": {
      "line": 69,
      "codeLine": 72,
      "path": "node_modules/can-control/can-control.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "can.Control.static",
    "parent": "can.Control",
    "title": "static"
  },
  "can.Control.prototype": {
    "src": {
      "line": 266,
      "codeLine": 269,
      "path": "node_modules/can-control/can-control.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "can.Control.prototype",
    "parent": "can.Control",
    "title": "prototype"
  },
  "can.Control.processor": {
    "src": {
      "path": "node_modules/can-control/control.processor.md"
    },
    "body": "",
    "description": "A function that handles the binding and unbinding of a [can.Control]'s declarative event method. \n",
    "type": "typedef",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A callback function that unbinds any event handlers bound within this processor.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "the control's element or the object \nspecified by the templated event handler (`\"{object}\"`).\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "The event type.\n"
          },
          {
            "types": [
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "selector",
            "description": "The selector preceding the event in the binding used on the Control.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ],
                    "name": "element",
                    "description": "foo"
                  },
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event",
                    "description": "bar\n"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "can.Control"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The callback function being bound.\n"
          },
          {
            "types": [
              {
                "type": "can.Control"
              }
            ],
            "name": "control",
            "description": "The Control the event is bound on.\n"
          }
        ]
      }
    ],
    "name": "can.Control.processor",
    "_curParam": {
      "types": [
        {
          "type": "can.Control"
        }
      ],
      "name": "control",
      "description": "The Control the event is bound on.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A callback function that unbinds any event handlers bound within this processor.\n"
    }
  },
  "can-construct-super": {
    "src": {
      "path": "node_modules/can-construct-super/can-construct-super.md"
    },
    "body": "\nWith this plugin, functions that are inheriting from base functions\nare provided with a specialized `this._super` reference to the base\nfunction from which they inherit.\n\nThis is especially useful for calling base classes' `[can-construct::init init]` and `[can-construct::setup setup]`, but it can be used in any inheriting function.\n\nThe `Person` and `Programmer` examples from `[can-construct::init init]` demonstrate `_super`'s use.\nHere's how those classes look without can.Construct.super:\n\n```\nvar Person = Construct.extend({\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\nAnd here's how `Programmer` works using `_super`:\n\n```\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        this._super(first, last);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\nIf you want to pass an array of arguments (or an arguments object) to `_super`, use [apply](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply):\n\n```\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        this._super.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\n## `_super` on constructors\n\ncan.Construct.super also adds `super` to the constructor, so you\ncan use it in static functions.\n\nHere is a base class that has a method that squares numbers and an inherited class that has a method that cubes numbers:\n\n```\nvar Squarer = can.Construct.extend({\n    raise: function(n) {\n        return n*n;\n    }\n}, {});\n\nvar Cuber = Squarer.extend({\n    raise: function(n) {\n        return n * this._super(n);\n    }\n}, {});\n```\n\n",
    "description": "\ncan.Construct.super is a plugin that makes it easier to call base\nfunctions from inside inheriting functions.\n",
    "type": "module",
    "title": "",
    "name": "can-construct-super",
    "parent": "can-construct.plugins",
    "plugin": "can-construct-super",
    "signatures": [
      {
        "code": "construct._super([...args])",
        "description": "\n\nCalls the base constructor function's method.\n",
        "params": [
          {
            "types": [
              {
                "type": "Any"
              }
            ],
            "variable": true,
            "name": "args",
            "description": "parameters to pass to the base function\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Any"
        }
      ],
      "variable": true,
      "name": "args",
      "description": "parameters to pass to the base function\n"
    },
    "comment": " "
  },
  "can-event.static": {
    "name": "can-event.static",
    "title": "static",
    "type": "group",
    "parent": "can-event",
    "description": "",
    "order": 0
  },
  "can-event": {
    "src": {
      "path": "node_modules/can-event/can-event.md"
    },
    "body": "\n## Using as a mixin\n\nThe easiest way to add events to your classes and objects is by mixing [can-event] into your object or prototype.\n\n```\nvar SomeClass = Construct(\"SomeClass\", {\n\tinit: function() {\n\t\tthis.value = 0;\n\t},\n\tincrement: function() {\n\t\tthis.value++;\n\t\tthis.dispatch(\"change\", [this.value]);\n\t}\n});\nObject.assign(SomeClass.prototype, canEvent);\n```\n\nNow that `canEvent` is included in the prototype, we can add/remove/dispatch events on the object instances.\n\n```\nvar instance = new SomeClass();\ninstance.on(\"change\", function(ev, value) {\n\talert(\"The instance changed to \" + value);\n});\n\n// This will dispatch the \"change\" event and show the alert\ninstance.increment();\n```\n\n## Using without mixing in\n\nThe same event functionality from `canEvent` can be used, even if the given object doesn't include `canEvent`. Every method within `canEvent` supports being called with an alternate scope.\n\n```\nvar obj = {};\n\ncanEvent.addEventListener.call(obj, \"change\", function() {\n\talert(\"object change!\");\n});\n\n// This will dispatch the \"change\" event and show the alert\ncanEvent.dispatch.call(obj, \"change\");\n```\n\n",
    "description": " \nAdd event functionality into your objects.\n\nThe `canEvent` object provides a number of methods for handling events in objects. This functionality is best used by mixing the `canEvent` object into an object or prototype. However, event listeners can still be used even on objects that don't include `canEvent`.\n\nAll methods provided by `canEvent` assume that they are mixed into an object -- `this` should be the object dispatching the events.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event",
    "parent": "can-infrastructure",
    "test": "can/event/test.html",
    "link": "../docco/event.html docco",
    "release": "2.1",
    "signatures": [
      {
        "code": "assign(YourClass.prototype, canEvent)",
        "description": "\n\nAdds event functionality to `YourClass` objects. This can also be applied to normal objects: `assign(someObject, canEvent)`.\n\nThe `assign` function can be any function that assigns additional properties on an object such as [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) or lodash's [_.assign](https://lodash.com/docs#assign) or [can-util/js/assign/assign].\n\n```js\nvar assign = require(\"can-util/js/assign/assign\");\nvar canEvent = require(\"can-event\");\n\nfunction Thing(){\n\n}\n\nassign(Thing.prototype, canEvent);\n\nvar thing = new Thing();\nthing.addEventListener(\"prop\", function(){ ... });\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-event.addEventListener": {
    "type": "function",
    "name": "can-event.addEventListener",
    "parent": "can-event.static",
    "src": {
      "line": 29,
      "codeLine": 53,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "addEventListener",
    "signatures": [
      {
        "code": "obj.addEventListener(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\n```js\nvar canEvent = require(\"can-event\");\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.addEventListener.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the `canEvent` mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.removeEventListener": {
    "type": "function",
    "name": "can-event.removeEventListener",
    "parent": "can-event.static",
    "src": {
      "line": 67,
      "codeLine": 82,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "removeEventListener",
    "signatures": [
      {
        "code": "obj.removeEventListener(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.removeEventListener.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.dispatch": {
    "type": "function",
    "name": "can-event.dispatch",
    "parent": "can-event.static",
    "src": {
      "line": 105,
      "codeLine": 133,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "dispatch",
    "signatures": [
      {
        "code": "obj.dispatch(event, [args])",
        "description": "\n\nDispatches/triggers a basic event on an object.\n\n```js\nvar canEvent = require(\"can-event\");\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){\n  console.log(\"FOO BAR!\");\n});\n\nobj.dispatch(\"foo\"); // Causes it to log FOO BAR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "event",
            "description": "The event to dispatch"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Additional arguments to pass to event handlers"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "event The resulting event object\n"
        }
      },
      {
        "code": "canEvent.dispatch.call(obj, event, args)",
        "description": "\n\nThis syntax can be used for objects that don't include the `can.event` mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "event The resulting event object\n"
    }
  },
  "can-event.on": {
    "type": "function",
    "name": "can-event.on",
    "parent": "can-event.static",
    "src": {
      "line": 149,
      "codeLine": 162,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "on",
    "signatures": [
      {
        "code": "obj.on(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\nThis is an alias of [can-event.addEventListener addEventListener].\n",
        "params": []
      },
      {
        "code": "can-event.on.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.off": {
    "type": "function",
    "name": "can-event.off",
    "parent": "can-event.static",
    "src": {
      "line": 171,
      "codeLine": 184,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "off",
    "signatures": [
      {
        "code": "obj.off(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n\nThis is an alias of [can-event.removeEventListener removeEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.off.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.trigger": {
    "type": "function",
    "name": "can-event.trigger",
    "parent": "can-event.static",
    "src": {
      "line": 192,
      "codeLine": 204,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "trigger",
    "signatures": [
      {
        "code": "obj.trigger(event, args)",
        "description": "\n\nDispatches/triggers a basic event on an object.\nThis is an alias of [can-event.dispatch dispatch].\n",
        "params": []
      },
      {
        "code": "canEvent.trigger.call(obj, event, args)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.one": {
    "type": "function",
    "name": "can-event.one",
    "parent": "can-event.static",
    "src": {
      "line": 214,
      "codeLine": 225,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "one",
    "signatures": [
      {
        "code": "obj.one(event, handler)",
        "description": "\n\nAdds a basic event listener that listens to an event once and only once.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n    "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "The handler that will be executed to handle the event."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n    "
    }
  },
  "can-event.listenTo": {
    "type": "function",
    "name": "can-event.listenTo",
    "parent": "can-event.static",
    "src": {
      "line": 245,
      "codeLine": 263,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "listenTo",
    "signatures": [
      {
        "code": "obj.listenTo(other, event, handler)",
        "description": "\n\nListens for an event on another object.\nThis is similar to concepts like event namespacing, except that the namespace\nis the scope of the calling object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "other",
            "description": "The object to listen for events on."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.listenTo.call(obj, other, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.stopListening": {
    "type": "function",
    "name": "can-event.stopListening",
    "parent": "can-event.static",
    "src": {
      "line": 293,
      "codeLine": 309,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "stopListening",
    "signatures": [
      {
        "code": "obj.stopListening(other, event, handler)",
        "description": "\n\nStops listening for an event on another object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "other",
            "description": "The object to listen for events on."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.stopListening.call(obj, other, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.bind": {
    "type": "function",
    "name": "can-event.bind",
    "parent": "can-event.static",
    "src": {
      "line": 365,
      "codeLine": 378,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "bind",
    "signatures": [
      {
        "code": "obj.bind(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\nThis is an alias of [can-event.addEventListener addEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.bind.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ]
  },
  "can-event.unbind": {
    "type": "function",
    "name": "can-event.unbind",
    "parent": "can-event.static",
    "src": {
      "line": 382,
      "codeLine": 395,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "unbind",
    "signatures": [
      {
        "code": "obj.unbind(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n\nThis is an alias of [can-event.removeEventListener removeEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.unbind.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ]
  },
  "can-event.delegate": {
    "name": "can-event.delegate",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 398,
      "codeLine": 418,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "delegate",
    "signatures": [
      {
        "code": "obj.delegate(selector, event, handler)",
        "description": "\n\nProvides a compatibility layer for adding delegate event listeners.\nThis doesn't actually implement delegates, but rather allows\nlogic that assumes a delegate to still function.\n\nTherefore, this is essentially an alias of [can-event.addEventListener addEventListener] with the selector ignored.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "The **ignored** selector to use for the delegate."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.delegate.call(obj, selector, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can.event] mixin.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.undelegate": {
    "name": "can-event.undelegate",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 420,
      "codeLine": 440,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "undelegate",
    "signatures": [
      {
        "code": "obj.undelegate(selector, event, handler)",
        "description": "\n\nProvides a compatibility layer for removing delegate event listeners.\nThis doesn't actually implement delegates, but rather allows\nlogic that assumes a delegate to still function.\n\nTherefore, this is essentially an alias of [can-event.removeEventListener removeEventListener] with the selector ignored.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "The **ignored** selector to use for the delegate."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.undelegate.call(obj, selector, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "static": {
    "src": {
      "line": 330,
      "codeLine": 333,
      "path": "node_modules/can-route/can-route.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "static",
    "parent": null,
    "title": "static"
  },
  "prototype": {
    "src": {
      "line": 141,
      "codeLine": 144,
      "path": "node_modules/can-map/can-map.js"
    },
    "type": "prototype",
    "body": "",
    "description": " \n",
    "name": "prototype",
    "parent": null,
    "title": "prototype"
  },
  "can-map": {
    "src": {
      "path": "node_modules/can-map/docs/map.md"
    },
    "body": "\n## Use\n\nWatch this video to see an example of creating an ATM machine using can.Map:\n\n<iframe width=\"662\" height=\"372\" src=\"https://www.youtube.com/embed/QP9mHyxZNiI\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n`Map` provides a way for you to listen for and keep track of changes\nto objects. When you use the getters and setters provided by `Map`,\nevents are fired that you can react to. `Map` also has support for\nworking with deep properties. Observable arrays are also available with\n`[can-list]`, which is based on `Map`.\n\n## Working with Observes\n\nTo create an Observe, use `new Map([props])`. This will return a\ncopy of `props` that emits events when its properties are changed with\n`[can-map.prototype.attr attr]`.\n\nYou can read the values of properties on Observes directly, but you should\nnever set them directly. You can also read property values using `attr`.\n\n\n    var aName = {a: 'Alexis'},\n        map = new can.Map(aName);\n\n    // Observes are copies of data:\n    aName === map; // false\n\n    // reading from an Observe:\n    map.attr();    // {a: 'Alexis'}\n    map.a;         // 'Alexis'\n    map.attr('a'); // 'Alexis'\n\n    // setting an Observe's property:\n    map.attr('a', 'Alice');\n    map.a; // Alice\n\n    // removing an Observe's property;\n    map.removeAttr('a');\n    map.attr(); // {}\n\n    // Don't do this!\n    map.a = 'Adam'; // wrong!\n\n\nFind out more about manipulating properties of a map under\n[can.Map.prototype.attr attr] and [can.Map.prototype.removeAttr removeAttr].\n\n## Listening to changes\n\nThe real power of maps comes from being able to react to\nproperties being added, set, and removed. Maps emit events when\nproperties are changed that you can bind to.\n\n`Map` has two types of events that fire due to changes on a map:\n- the _change_ event fires on every change to a map.\n- an event named after the property name fires on every change to that property.\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('Something on o changed.');\n    });\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log('a was changed.');\n    });\n\n    o.attr('a', 'Alexis'); // 'Something on o changed.'\n                           // 'a was changed.'\n    o.attr({\n        'a': 'Alice',      // 'Something on o changed.' (for a's change)\n        'b': 'Bob'         // 'Something on o changed.' (for b's change)\n    });                    // 'a was changed.'\n\n    o.removeAttr('a');     // 'Something on o changed.'\n                           // 'a was changed.'\n\n\nFor more detail on how to use these events, see [can.Map.prototype.bind bind] and\n[can.Map.prototype.unbind unbind]. There is also a plugin called [can.Map.delegate]\nthat makes binding to specific types of events easier:\n\n\n    var o = new Map({});\n    o.delegate('a', 'add', function(ev, newVal, oldVal) {\n        console.log('a was added.');\n    });\n    o.delegate('a', 'set', function(ev, newVal, oldVal) {\n        console.log('a was set.');\n    });\n    o.delegate('a', 'remove', function(ev, newVal, oldVal) {\n        console.log('a was removed.');\n    });\n    o.delegate('a', 'change', function(ev, newVal, oldVal) {\n        console.log('a was changed.');\n    });\n\n    o.attr('a', 'Alexis'); // 'a was added.'\n                           // 'a was changed.'\n\n    o.attr('a', 'Alice'); // 'a was set.'\n                          // 'a was changed.'\n\n    o.removeAttr('a'); // 'a was removed.'\n                       // 'a was changed.'\n\n## Object.prototype.watch\n\nDue to a method available on the base Object prototype called \"watch\", refrain from\nusing properties with the same name on Gecko based browsers as there will be a\ncollision. [Source](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/watch)\n\n",
    "description": "Create observable objects. \n",
    "name": "can-map",
    "type": "module",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "inherits": "can",
    "parent": "can-legacy",
    "test": "can/map/test.html",
    "plugin": "can/map",
    "release": "2.0",
    "link": "../docco/map/map.html docco",
    "signatures": [
      {
        "code": "new Map([props])",
        "description": "\n\nCreates a new instance of can.Map.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the Observe with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "An instance of `can.Map` with the properties from _props_.\n"
        }
      },
      {
        "code": "Map.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function.\n\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "An instance of `can.Map` with the properties from _props_.\n"
    },
    "comment": " "
  },
  "can-list": {
    "src": {
      "path": "node_modules/can-list/docs/list.md"
    },
    "body": "\n\nUse for observable array-like objects.\n\n\n## Use\n\n`List` is used to observe changes to an Array.  `List` extends `[can-map]`, so all the \nways that you're used to working with Maps also work here.\n\nUse [can-list::attr attr] to read and write properties of a list:\n\n    var hobbies = new List([\"JS\",\"Party Rocking\"])\n    hobbies.attr(0)        //-> \"JS\"\n    hobbies.attr(\"length\") //-> 2\n    \n    hobbies.attr(0,\"JavaScript\")\n    \n    hobbies.attr()         //-> [\"JavaScript\",\"Party Rocking\"]\n\nJust as you shouldn't set properties of an Map directly, you shouldn't change elements\nof a List directly. Always use `attr` to set the elements of a List, or use [can-list::push push],\n[can-list::pop pop], [can-list::shift shift], [can-list::unshift unshift], or [can-list::splice splice].\n\nHere is a tour through the forms of `List`'s `attr` that parallels the one found under [can-map.prototype.attr attr]:\n\n```\nvar people = new List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\npeople[0] = 'Adam'; // don't do this!\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']\n```\n\n## Listening to changes\n\nAs with `Map`s, the real power of observable arrays comes from being able to\nreact to changes in the member elements of the array. Lists emit five types of events:\n\n- the _change_ event fires on every change to a List.\n- the _set_ event is fired when an element is set.\n- the _add_ event is fired when an element is added to the List.\n- the _remove_ event is fired when an element is removed from the List.\n- the _length_ event is fired when the length of the List changes.\n\nThis example presents a brief concrete survey of the times these events are fired:\n\n```\nvar list = new List(['Alice', 'Bob', 'Eve']);\n\nlist.bind('change', function() { console.log('An element changed.'); });\nlist.bind('set', function() { console.log('An element was set.'); });\nlist.bind('add', function() { console.log('An element was added.'); });\nlist.bind('remove', function() { \n  console.log('An element was removed.'); \n});\nlist.bind('length', function() { \n  console.log('The length of the list changed.'); \n});\n\nlist.attr(0, 'Alexis'); // 'An element changed.'\n                        // 'An element was set.'\n\nlist.attr(3, 'Xerxes'); // 'An element changed.'\n                        // 'An element was added.'\n                        // 'The length of the list was changed.'\n\nlist.attr(['Adam', 'Bill']); // 'An element changed.'\n                             // 'An element was set.'\n                             // 'An element was changed.'\n                             // 'An element was set.'\n\nlist.pop(); // 'An element changed.'\n            // 'An element was removed.'\n            // 'The length of the list was changed.'\n```\n\nMore information about binding to these events can be found under [can-list::attr attr].\n\n",
    "description": "\n",
    "name": "can-list",
    "type": "module",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "inherits": "can",
    "download": "can/list",
    "test": "can/list/test.html",
    "parent": "can-legacy",
    "release": "2.0",
    "link": "../docco/list/list.html docco",
    "signatures": [
      {
        "code": "new List([array])",
        "description": "\n\nCreate an observable array-like object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "array",
            "description": "Items to seed the List with.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "An instance of `List` with the elements from _array_.\n"
        }
      },
      {
        "code": "new List(deferred)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can.Deferred"
              }
            ],
            "name": "deferred",
            "description": "A deferred that resolves to an \narray.  When the deferred resolves, its values will be added to the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "An initially empty `List`.  \n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-list"
        }
      ],
      "description": "An initially empty `List`.  \n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can.Deferred"
        }
      ],
      "name": "deferred",
      "description": "A deferred that resolves to an \narray.  When the deferred resolves, its values will be added to the list.\n"
    },
    "comment": " "
  },
  "can.List": {
    "name": "can.List",
    "type": "add",
    "description": "undefined\n"
  },
  "can.List.static": {
    "src": {
      "line": 38,
      "codeLine": 41,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "can.List.static",
    "parent": "can.List",
    "title": "static"
  },
  "can.List.Map": {
    "name": "can.List.Map",
    "type": "property",
    "parent": "can.List.static",
    "src": {
      "line": 42,
      "codeLine": 78,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "",
    "description": "Specify the Map type used to make objects added to this list observable. \n",
    "types": [
      {
        "type": "can.Map",
        "description": "When objects are added to a can.List, those objects are\nconverted into can.Map instances.  For example:\n\n    var list = new can.List();\n    list.push({name: \"Justin\"});\n\n    var map = list.attr(0);\n    map.attr(\"name\") //-> \"Justin\"\n\nBy changing [can.List.Map], you can specify a different type of Map instance to\ncreate. For example:\n\n    var User = can.Map.extend({\n      fullName: function(){\n        return this.attr(\"first\")+\" \"+this.attr(\"last\")\n      }\n    });\n\n    User.List = can.List.extend({\n      Map: User\n    }, {});\n\n    var list = new User.List();\n    list.push({first: \"Justin\", last: \"Meyer\"});\n\n    var user = list.attr(0);\n    user.fullName() //-> \"Justin Meyer\"\n\n\n\n\t "
      }
    ],
    "title": ""
  },
  "can.Map.extend": {
    "src": {
      "line": 79,
      "codeLine": 102,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "function",
    "body": "\n## Use\n\n\n\t \n",
    "description": "\n",
    "title": "",
    "name": "can.Map.extend",
    "signatures": [
      {
        "code": "can.List.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function. Learn more at [can.Construct.extend].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "If provided, adds the extened List constructor function\nto the window at the given name.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties and methods\ndirectly on the constructor function. The most common property to set is [can.List.Map].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "instanceProperties",
            "description": "Properties and methods on instances of this list type.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "instanceProperties",
      "description": "Properties and methods on instances of this list type.\n"
    },
    "comment": " "
  },
  "can.List.prototype": {
    "src": {
      "line": 102,
      "codeLine": 104,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "prototype",
    "body": "",
    "description": " \n",
    "name": "can.List.prototype",
    "parent": "can.List",
    "title": "prototype"
  },
  "can.List.prototype.serialize": {
    "type": "function",
    "name": "can.List.prototype.serialize",
    "params": [],
    "parent": "can.List.prototype",
    "src": {
      "line": 206,
      "codeLine": 210,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "\t \n",
    "description": "Returns the serialized form of this list.\n",
    "hide": true
  },
  "can.List.prototype.each": {
    "src": {
      "line": 213,
      "codeLine": 250,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "function",
    "body": "```\nvar i = 0;\nnew can.Map([1, 10, 100]).each(function(element, index) {\n    i += element;\n});\n\ni; // 111\n\ni = 0;\nnew can.Map([1, 10, 100]).each(function(element, index) {\n    i += element;\n    if(index >= 1) {\n        return false;\n    }\n});\n\ni; // 11\n```\n\t \n",
    "description": "Call a function on each element of a List. ",
    "title": "each",
    "name": "can.List.prototype.each",
    "signatures": [
      {
        "code": "list.each( callback(item, index) )",
        "description": "\n\n`each` iterates through the Map, calling a function\nfor each element.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "this List, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "this List, for chaining\n"
    },
    "comment": " "
  },
  "can.List.prototype.splice": {
    "type": "function",
    "name": "can.List.prototype.splice",
    "parent": "can.List.prototype",
    "src": {
      "line": 250,
      "codeLine": 313,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`splice` lets you remove elements from and insert elements into a List.\n\nThis example demonstrates how to do surgery on a list of numbers:\n\n```\nvar list = new can.List([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.attr(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n## Events\n\n`splice` causes the List it's called on to emit _change_ events,\n_add_ events, _remove_ events, and _length_ events. If there are\nany elements to remove, a _change_ event, a _remove_ event, and a\n_length_ event will be fired. If there are any elements to insert, a\nseparate _change_ event, an _add_ event, and a separate _length_ event\nwill be fired.\n\nThis slightly-modified version of the above example should help\nmake it clear how `splice` causes events to be emitted:\n\n```\nvar list = new can.List(['a', 'b', 'c', 'd']);\nlist.bind('change', function(ev, attr, how, newVals, oldVals) {\n    console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\nlist.bind('add', function(ev, newVals, where) {\n    console.log('add: ' + newVals + ', ' + where);\n});\nlist.bind('remove', function(ev, oldVals, where) {\n    console.log('remove: ' + oldVals + ', ' + where);\n});\nlist.bind('length', function(ev, length) {\n    console.log('length: ' + length + ', ' + this.attr());\n});\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                   // remove: ['c'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                   // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                   // add: ['Alice', 'Bob'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n```\n\nMore information about binding to these events can be found under [can.List.attr attr].\n\t \n",
    "description": "Insert and remove elements from a List. ",
    "title": "splice",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newElements]])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "where to start removing or inserting elements\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "the number of elements to remove\nIf _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the List.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newElements",
            "description": "elements to insert into the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the elements removed by `splice`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newElements",
      "description": "elements to insert into the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the elements removed by `splice`\n"
    },
    "comment": " "
  },
  "can.List.prototype.push": {
    "name": "can.List.prototype.push",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 411,
      "codeLine": 452,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`push` adds elements onto the end of a List here is an example:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\nIf you have an array you want to concatenate to the end\nof the List, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new can.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\n## Events\n\n`push` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`push` has a counterpart in [can.List::pop pop], or you may be\nlooking for [can.List::unshift unshift] and its counterpart [can.List::shift shift].\n\t \n",
    "description": "Add elements to the end of a list. ",
    "title": "push",
    "signatures": [
      {
        "code": "list.push(...elements)",
        "description": "\n\n`push` adds elements onto the end of a List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the List\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the List\n"
    },
    "comment": " "
  },
  "can.List.prototype.unshift": {
    "name": "can.List.prototype.unshift",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 453,
      "codeLine": 494,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`unshift` adds elements to the front of the list in bulk in the order specified:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\nIf you have an array you want to concatenate to the beginning\nof the List, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new can.List(['Alice']);\n\nlist.unshift.apply(list, names);\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\n## Events\n\n`unshift` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`unshift` has a counterpart in [can.List::shift shift], or you may be\nlooking for [can.List::push push] and its counterpart [can.List::pop pop].\n\t \n",
    "description": "Add elements to the beginning of a List. ",
    "title": "unshift",
    "signatures": [
      {
        "code": "list.unshift(...elements)",
        "description": "\n\n`unshift` adds elements onto the beginning of a List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the List\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the List\n"
    },
    "comment": " "
  },
  "can.List.prototype.pop": {
    "name": "can.List.prototype.pop",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 528,
      "codeLine": 560,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`pop` is the opposite action from `[can.List.push push]`:\n\n```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\nwhen it is called.\n\n## See also\n\n`pop` has its counterpart in [can.List::push push], or you may be\nlooking for [can.List::unshift unshift] and its counterpart [can.List::shift shift].\n\t \n",
    "description": "Remove an element from the end of a List. ",
    "title": "pop",
    "signatures": [
      {
        "code": "list.pop()",
        "description": "\n\n`pop` removes an element from the end of a List.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just popped off the List, or `undefined` if the List was empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just popped off the List, or `undefined` if the List was empty\n"
    },
    "comment": " "
  },
  "can.List.prototype.shift": {
    "name": "can.List.prototype.shift",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 561,
      "codeLine": 595,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`shift` is the opposite action from `[can.List::unshift unshift]`:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n\nlist.shift(); // 'Bob'\nlist.shift(); // 'Eve'\nlist.shift(); // 'Alice'\nlist.shift(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\nwhen it is called.\n\n## See also\n\n`shift` has a counterpart in [can.List::unshift unshift], or you may be\nlooking for [can.List::push push] and its counterpart [can.List::pop pop].\n\t \n",
    "description": "Remove en element from the front of a list. ",
    "title": "shift",
    "signatures": [
      {
        "code": "list.shift()",
        "description": "\n\n`shift` removes an element from the beginning of a List.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just shifted off the List, or `undefined` if the List is empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just shifted off the List, or `undefined` if the List is empty\n"
    },
    "comment": " "
  },
  "can.List.prototype.indexOf": {
    "type": "function",
    "name": "can.List.prototype.indexOf",
    "parent": "can.List.prototype",
    "src": {
      "line": 627,
      "codeLine": 653,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1\n```\n\nIt is trivial to make a `contains`-type function using `indexOf`:\n\n```\nfunction(list, item) {\n    return list.indexOf(item) >= 0;\n}\n```\n \n",
    "description": "Look for an item in a List. ",
    "title": "indexOf",
    "signatures": [
      {
        "code": "list.indexOf(item)",
        "description": "\n\n`indexOf` finds the position of a given item in the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "the item to find\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the position of the item in the List, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "the item to find\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the position of the item in the List, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can.List.prototype.join": {
    "type": "function",
    "name": "can.List.prototype.join",
    "parent": "can.List.prototype",
    "src": {
      "line": 663,
      "codeLine": 684,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n\nvar beatles = new can.List(['John', 'Paul', 'Ringo', 'George']);\nbeatles.join('&'); // 'John&Paul&Ringo&George'\n```\n \n",
    "description": "Join a List's elements into a string. ",
    "title": "join",
    "signatures": [
      {
        "code": "list.join(separator)",
        "description": "\n\n`join` turns a List into a string by inserting _separator_ between the string representations\nof all the elements of the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "separator",
            "description": "the string to seperate elements with\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the joined string\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "separator",
      "description": "the string to seperate elements with\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the joined string\n"
    },
    "comment": " "
  },
  "can.List.prototype.reverse": {
    "type": "function",
    "name": "can.List.prototype.reverse",
    "parent": "can.List.prototype",
    "src": {
      "line": 689,
      "codeLine": 707,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n \n",
    "description": "Reverse the order of a List. ",
    "title": "reverse",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\n`reverse` reverses the elements of the List in place.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "the List, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "the List, for chaining\n"
    },
    "comment": " "
  },
  "can.List.prototype.slice": {
    "type": "function",
    "name": "can.List.prototype.slice",
    "parent": "can.List.prototype",
    "src": {
      "line": 712,
      "codeLine": 743,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList.attr(); // ['Bob', 'Charlie', 'Daniel']\n```\n\n`slice` is the simplest way to copy a List:\n\n```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy.attr();   // ['Alice', 'Bob', 'Eve']\nlist === copy; // false\n```\n \n",
    "description": "Make a copy of a part of a List. ",
    "title": "slice",
    "signatures": [
      {
        "code": "list.slice([start[, end]])",
        "description": "\n\n`slice` creates a copy of a portion of the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "start",
            "defaultValue": "0",
            "description": "the index to start copying from\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "end",
            "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "a new `can.List` with the extracted elements\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "end",
      "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "a new `can.List` with the extracted elements\n"
    },
    "comment": " "
  },
  "can.List.prototype.concat": {
    "type": "function",
    "name": "can.List.prototype.concat",
    "parent": "can.List.prototype",
    "src": {
      "line": 750,
      "codeLine": 772,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`concat` makes a new List with the elements of the List followed by the elements of the parameters.\n\n```\nvar list = new can.List();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new can.List(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n```\n \n",
    "description": "Merge many collections together into a List. ",
    "title": "concat",
    "signatures": [
      {
        "code": "list.concat(...args)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can.List"
              },
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can.List"
        },
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.\n"
    },
    "comment": " "
  },
  "can.List.prototype.forEach": {
    "type": "function",
    "name": "can.List.prototype.forEach",
    "parent": "can.List.prototype",
    "src": {
      "line": 780,
      "codeLine": 800,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`forEach` calls a callback for each element in the List.\n\n```\nvar list = new can.List([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.attr(index, element * element);\n});\nlist.attr(); // [1, 4, 9]\n```\n \n",
    "description": "Call a function for each element of a List. ",
    "title": "forEach",
    "signatures": [
      {
        "code": "list.forEach(callback[, thisArg])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "element"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "a function to call with each element of the List\nThe three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the\ncurrent element of the list, and _list_ the List the elements are coming from."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "the object to use as `this` inside the callback\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "the object to use as `this` inside the callback\n"
    },
    "comment": " "
  },
  "can.List.prototype.replace": {
    "type": "function",
    "name": "can.List.prototype.replace",
    "parent": "can.List.prototype",
    "src": {
      "line": 811,
      "codeLine": 873,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`replace` replaces all the elements of this List with new ones.\n\n`replace` is especially useful when `can.List`s are live-bound into `[can.Control]`s,\nand you intend to populate them with the results of a `[can.Model]` call:\n\n```\ncan.Control({\n    init: function() {\n        this.list = new Todo.List();\n        // live-bind the list into the DOM\n        this.element.html(can.view('list.stache', this.list));\n        // when this AJAX call returns, the live-bound DOM will be updated\n        this.list.replace(Todo.findAll());\n    }\n});\n```\n\nLearn more about [can.Model.List making Lists of models].\n\n## Events\n\nA major difference between `replace` and `attr(newElements, true)` is that `replace` always emits\nan _add_ event and a _remove_ event, whereas `attr` will cause _set_ events along with an _add_ or _remove_\nevent if needed. Corresponding _change_ and _length_ events will be fired as well.\n\nThe differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:\n```\nvar attrList = new can.List(['Alexis', 'Bill']);\nattrList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nvar replaceList = new can.List(['Alexis', 'Bill']);\nreplaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nattrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n                                              // 1, set, Ben, Bill\nreplaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n                                              // 0, add, ['Adam', 'Ben'], ['Alexis', 'Bill']\n\nattrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n                                              // 1, remove, undefined, Ben\nreplaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n                                              // 0, add, Amber, ['Adam', 'Ben']\n\nattrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n                                              // 1, add, ['Bob', 'Eve'], undefined\nreplaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n                                              // 0, add, ['Alice', 'Bob', 'Eve'], Amber\n```\n \n",
    "description": "Replace all the elements of a List. ",
    "title": "replace",
    "signatures": [
      {
        "code": "list.replace(collection)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can.List"
              },
              {
                "type": "can.Deferred"
              }
            ],
            "name": "collection",
            "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can.List`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can.List"
        },
        {
          "type": "can.Deferred"
        }
      ],
      "name": "collection",
      "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can.List`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
    },
    "comment": " "
  },
  "'htmlbool'": {
    "type": "function",
    "name": "'htmlbool'",
    "params": [
      {
        "name": "val",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-map-define/can-map-define.js",
    "src": {
      "line": 227,
      "codeLine": 231,
      "path": "node_modules/can-map-define/can-map-define.js"
    },
    "body": " \n",
    "description": "Implements HTML-style boolean logic for attribute strings, where\nany string, including \"\", is truthy.\n"
  },
  "can-observation.prototype": {
    "name": "can-observation.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation.static": {
    "name": "can-observation.static",
    "title": "static",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation.types": {
    "name": "can-observation.types",
    "title": "types",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation": {
    "type": "module",
    "name": "can-observation",
    "parent": "can-infrastructure",
    "src": {
      "line": 20,
      "codeLine": 92,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "\n\n## Use\n\nInstances of `Observation` are rarely created directly.  Instead, use [can-compute]'s more friendly API to\nobserve when a function's value changes. [can-compute] uses `can-observation` internally.\n\n`Observation`'s static methods like: [can-observation.add], [can-observation.ignore], and [can-observation.trap]\nare used more commonly to control which observable events a compute will listen to.\n\nTo use `can-observation` directly, create something observable (supports `addEventListener`) and\ncalls [can-observation.add] like:\n\n```js\nvar Observation = require(\"can-observation\");\nvar assign = require(\"can-util/js/assign/assign\");\nvar canEvent = require(\"can-event\");\n\nvar me = assign({}, canEvent);\n\nvar name = \"Justin\";\nObject.defineProperty(me,\"name\",{\n  get: function(){\n    Observation.add(this,\"name\");\n    return name;\n  },\n  set: function(newVal) {\n    var oldVal = name;\n    name = newVal;\n    this.dispatch(\"name\", newVal, oldVal);\n  }\n})\n```\n\nNext, create an observation instance with a function that reads the observable value:\n\n```js\nvar observation = new Observation(function(){\n  return \"Hello \"+me.name;\n}, null, function(newVal, oldVal, batchNum){\n  console.log(newVal);\n})\n```\n\nFinally, call `observation.start()` to start listening and be notified of changes:\n\n```js\nobservation.start();\nobservation.value   //-> \"Hello Justin\";\nme.name = \"Ramiya\"; // console.logs -> \"Hello Ramiya\"\n```\n\n",
    "description": "\nProvides a machanism to notify when an observable has been read and a\nway to observe those reads called within a given function.\n",
    "title": "",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "signatures": [
      {
        "code": "new Observation(func, context, compute)",
        "description": "\n\nCreates an observation of a given function called with `this` as\na given context. Calls back `compute` when the return value of `func` changes.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "func",
            "description": "The function whose value is being observed."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "What `this` should be when `func` is called."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "can-compute"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldValue"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "batchNum"
                  }
                ]
              }
            ],
            "name": "updated",
            "description": "A function to call when `func`'s return value changes.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "can-compute"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "oldValue"
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ],
              "name": "batchNum"
            }
          ]
        }
      ],
      "name": "updated",
      "description": "A function to call when `func`'s return value changes.\n"
    },
    "comment": " "
  },
  "can-observation.prototype.start": {
    "type": "function",
    "name": "can-observation.prototype.start",
    "parent": "can-observation.prototype",
    "src": {
      "line": 218,
      "codeLine": 228,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "start",
    "signatures": [
      {
        "code": "observation.start()",
        "description": "\n\nStarts observing changes and adds event listeners. [can-observation.prototype.value] will\nbe available.\n\n ",
        "params": []
      }
    ]
  },
  "can-observation.prototype.stop": {
    "type": "function",
    "name": "can-observation.prototype.stop",
    "parent": "can-observation.prototype",
    "src": {
      "line": 269,
      "codeLine": 278,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "stop",
    "signatures": [
      {
        "code": "observation.stop()",
        "description": "\n\nStops observing changes and removes all event listeners.\n\n ",
        "params": []
      }
    ]
  },
  "can-observation.prototype.value": {
    "src": {
      "line": 287,
      "codeLine": 296,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "type": "property",
    "body": "\n \n",
    "description": "\nThe return value of the function once [can-observation.prototype.start] is called.\n",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "",
    "name": "can-observation.prototype.value"
  },
  "can-observation.observed": {
    "src": {
      "line": 296,
      "codeLine": 311,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "type": "typedef",
    "body": "",
    "description": " \nAn object representing an observation.\n\n```js\n{ \"obj\": map, \"event\": \"prop1\" }\n```\n\n",
    "title": "Observed",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "obj",
            "description": "The observable object",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "event",
            "description": "The event, or more likely property, that is being observed.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-observation.observed",
    "parent": "can-observation.types"
  },
  "can-observation.add": {
    "type": "function",
    "name": "can-observation.add",
    "parent": "can-observation.static",
    "src": {
      "line": 463,
      "codeLine": 483,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "\n",
    "description": "\nSignals that an object's property is being observed, so that any functions\nthat are recording observations will see that this object is a dependency.\n",
    "title": "add",
    "signatures": [
      {
        "code": "Observation.add(obj, event)",
        "description": "\n\nSignals that an event should be observed. Adds the observable being read to\nthe top of the stack.\n\n```js\nObservation.add(obj, \"prop1\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An observable object which is being observed."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event (or property) that is being observed.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "event",
      "description": "The name of the event (or property) that is being observed.\n\n"
    }
  },
  "can-observation.addAll": {
    "type": "function",
    "name": "can-observation.addAll",
    "parent": "can-observation.static",
    "src": {
      "line": 501,
      "codeLine": 520,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "addAll",
    "signatures": [
      {
        "code": "Observation.addAll(observes)",
        "description": "\n\nThe same as `Observation.add` but takes an array of [can-observation.observed] objects.\nThis will most often by used in coordination with [can-observation.trap]:\n\n```js\nvar untrap = Observation.trap();\n\nObservation.add(obj, \"prop3\");\n\nvar traps = untrap();\nOservation.addAll(traps);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-observation.observed"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "observes",
            "description": "An array of [can-observation.observed]s.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-observation.observed"
                }
              ]
            }
          ]
        }
      ],
      "name": "observes",
      "description": "An array of [can-observation.observed]s.\n"
    }
  },
  "can-observation.ignore": {
    "type": "function",
    "name": "can-observation.ignore",
    "parent": "can-observation.static",
    "src": {
      "line": 541,
      "codeLine": 564,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "ignore",
    "signatures": [
      {
        "code": "Observation.ignore(fn)",
        "description": "\n\nCreates a function that, when called, will prevent observations from\nbeing applied.\n\n```js\nvar fn = Observation.ignore(function(){\n  // This will be ignored\n  Observation.add(obj, \"prop1\");\n});\n\nfn();\nObservation.trapCount(); // -> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "Any function that contains potential calls to\n[Observation.add].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function that is free of observation side-effects.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "Any function that contains potential calls to\n[Observation.add].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function that is free of observation side-effects.\n"
    }
  },
  "can-observation.trap": {
    "type": "function",
    "name": "can-observation.trap",
    "parent": "can-observation.static",
    "src": {
      "line": 579,
      "codeLine": 598,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "trap",
    "signatures": [
      {
        "code": "Observation.trap()",
        "description": "\n\nTrap all observations until the `untrap` function is called. The state of\ntraps prior to `Observation.trap()` will be restored when `untrap()` is called.\n\n```js\nvar untrap = Observation.trap();\n\nObservation.add(obj, \"prop1\");\n\nvar traps = untrap();\nconsole.log(traps[0].obj === obj); // -> true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-observation.getTrapped"
            }
          ],
          "description": "A function to get the trapped observations.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-observation.getTrapped"
        }
      ],
      "description": "A function to get the trapped observations.\n"
    }
  },
  "can-observation.getTrapped": {
    "type": "typedef",
    "name": "can-observation.getTrapped",
    "parent": "can-observation.types",
    "src": {
      "line": 611,
      "codeLine": 622,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "getTrapped",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "getTrapped()",
        "description": "\n\n  Returns the trapped observables captured by [can-observation.trap].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-observation.observed"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-observation.observed"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    }
  },
  "can-observation.isRecording": {
    "type": "function",
    "name": "can-observation.isRecording",
    "parent": "can-observation.static",
    "src": {
      "line": 632,
      "codeLine": 641,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "isRecording",
    "signatures": [
      {
        "code": "Observation.isRecording()",
        "description": "\n\nReturns if some function is in the process of recording observes.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if a function is in the process of recording observes.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if a function is in the process of recording observes.\n"
    }
  },
  "can-route.param": {
    "type": "function",
    "name": "can-route.param",
    "parent": "can-route.static",
    "src": {
      "line": 335,
      "codeLine": 363,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Parameterizes the raw JS object representation provided in data.\n\n```js\nroute.param({ type: \"video\", id: 5 });\n  // -> \"type=video&id=5\"\n```\n\nIf a route matching the provided data is found, that URL is built\nfrom the data. Any remaining data is added at the end of the\nURL as &amp; separated key/value parameters.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.param({ type: \"video\", id: 5 }) // -> \"video/5\"\nroute.param({ type: \"video\", id: 5, isNew: false })\n  // -> \"video/5&isNew=false\"\n```\n \n",
    "description": "Get a route path from given data. ",
    "title": "param",
    "signatures": [
      {
        "code": "route.param(data)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "data"
              }
            ],
            "name": "object",
            "description": "The data to populate the route with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The route, with the data populated in it.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "data"
        }
      ],
      "name": "object",
      "description": "The data to populate the route with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The route, with the data populated in it.\n"
    },
    "comment": " "
  },
  "can-route.deparam": {
    "type": "function",
    "name": "can-route.deparam",
    "parent": "can-route.static",
    "src": {
      "line": 431,
      "codeLine": 483,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\nCreates a data object based on the query string passed into it. This is\nuseful to create an object based on the `location.hash`.\n\n```js\nroute.deparam(\"id=5&type=videos\");\n  // -> { id: 5, type: \"videos\" }\n```\n\n\nIt's important to make sure the hash or exclamation point is not passed\nto `route.deparam` otherwise it will be included in the first property's\nname.\n\n```js\nroute.data.id = 5 // location.hash -> #!id=5\nroute.data.type = \"videos\"\n  // location.hash -> #!id=5&type=videos\nroute.deparam(location.hash);\n  // -> { #!id: 5, type: \"videos\" }\n```\n\n`route.deparam` will try and find a matching route and, if it does,\nwill deconstruct the URL and parse out the key/value parameters into the\ndata object.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.deparam(\"videos/5\");\n  // -> { id: 5, route: \"{type}/{id}\", type: \"videos\" }\n```\n \n",
    "description": "Extract data from a route path. ",
    "title": "deparam",
    "signatures": [
      {
        "code": "route.deparam(url)",
        "description": "\n\nExtract data from a url, creating an object representing its values.\n\n```js\nroute(\"{page}\");\n\nvar result = route.deparam(\"page=home\");\nconsole.log(result.page); // -> \"home\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "url",
            "description": "A route fragment to extract data from."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object containing the extracted data.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "url",
      "description": "A route fragment to extract data from."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object containing the extracted data.\n"
    },
    "comment": " "
  },
  "static.routes": {
    "name": "static.routes",
    "type": "property",
    "parent": "static",
    "src": {
      "line": 540,
      "codeLine": 559,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n - test - A regular expression that will match the route when variable values\n   are present; i.e. for {page}/{type} the `RegExp` is /([\\w\\.]*)/([\\w\\.]*)/ which\n   will match for any value of {page} and {type} (word chars or period).\n\n - route - The original URL, same as the index for this entry in routes.\n\n - names - An array of all the variable names in this route\n\n - defaults - Default values provided for the variables or an empty object.\n\n - length - The number of parts in the URL separated by '/'.\n \n",
    "description": "\nA list of routes recognized by the router indixed by the url used to add it.\nEach route is an object with these members:\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "",
    "hide": true
  },
  "can-route.ready": {
    "type": "function",
    "name": "can-route.ready",
    "parent": "can-route.static",
    "src": {
      "line": 560,
      "codeLine": 592,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n\n## Use\n\nAfter setting all your routes, call `route.ready()`.\n\n```js\nroute(\"overview/{dateStart}-{dateEnd}\");\nroute(\"{type}/{id}\");\nroute.ready();\n```\n \n",
    "description": "\nInitializes can-route.\n",
    "title": "ready",
    "signatures": [
      {
        "code": "route.ready()",
        "description": "\n\nSets up the two-way binding between the hash and the can-route observable\nmap and sets the route map to its initial values.\n\n```js\nroute(\"{page}\", { page: \"home\" }));\n\nroute.ready();\nroute.data.page; // -> \"home\"\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-route"
            }
          ],
          "description": "The can-route object.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-route"
        }
      ],
      "description": "The can-route object.\n"
    },
    "comment": " "
  },
  "can-route.url": {
    "type": "function",
    "name": "can-route.url",
    "parent": "can-route.static",
    "src": {
      "line": 601,
      "codeLine": 641,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Similar to [can-route.link], but instead of creating an anchor tag,\n`route.url` creates only the URL based on the route options passed into it.\n\n```js\nroute.url( { type: \"videos\", id: 5 } );\n  // -> \"#!type=videos&id=5\"\n```\n\nIf a route matching the provided data is found the URL is built from the\ndata. Any remaining data is added at the end of the URL as & separated\nkey/value parameters.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.url( { type: \"videos\", id: 5 } ) // -> \"#!videos/5\"\nroute.url( { type: \"video\", id: 5, isNew: false } )\n  // -> \"#!video/5&isNew=false\"\n```\n \n",
    "description": "Creates a URL fragment based on registered routes given a set of data. ",
    "title": "url",
    "signatures": [
      {
        "code": "route.url(data [, merge])",
        "description": "\n\nMake a URL fragment that when set to window.location.hash will update can-route's properties\nto match those in `data`.\n\n```js\nroute.url({ page: \"home\" });\n// -> \"#!page=home\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The data to populate the route with."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Whether the given options should be merged into\nthe current state of the route."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The route URL and query string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "merge",
      "description": "Whether the given options should be merged into\nthe current state of the route."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The route URL and query string.\n"
    },
    "comment": " "
  },
  "can-route.link": {
    "type": "function",
    "name": "can-route.link",
    "parent": "can-route.static",
    "src": {
      "line": 650,
      "codeLine": 700,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Creates and returns an anchor tag with an href of the route\nattributes passed into it, as well as any properties desired\nfor the tag.\n\n```js\nroute.link( \"My videos\", { type: \"videos\" }, {}, false )\n  // -> <a href=\"#!type=videos\">My videos</a>\n```\n\nOther attributes besides href can be added to the anchor tag\nby passing in a data object with the attributes desired.\n\n```js\nroute.link( \"My videos\", { type: \"videos\" },\n  { className: \"new\" }, false )\n    // -> <a href=\"#!type=videos\" class=\"new\">My Videos</a>\n```\n\nIt is possible to utilize the current route options when making anchor\ntags in order to make your code more reusable. If merge is set to true,\nthe route options passed into `canRoute.link` will be passed into the\ncurrent ones.\n\n```js\nlocation.hash = \"#!type=videos\"\nroute.link( \"The zoo\", { id: 5 }, true )\n  // -> <a href=\"#!type=videos&id=5\">The zoo</true>\n\nlocation.hash = \"#!type=pictures\"\nroute.link( \"The zoo\", { id: 5 }, true )\n  // -> <a href=\"#!type=pictures&id=5\">The zoo</true>\n```\n \n",
    "description": "Creates a string representation of an anchor link using data and the registered routes.\n",
    "title": "link",
    "signatures": [
      {
        "code": "route.link(innerText, data, props [, merge])",
        "description": "\n\nMake an anchor tag (`<A>`) that when clicked on will update can-route's\nproperties to match those in `data`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "innerText",
            "description": "The text inside the link."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The data to populate the route with."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "Properties for the anchor other than `href`."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Whether the given options should be merged into the current state of the route."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A string with an anchor tag that points to the populated route.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "merge",
      "description": "Whether the given options should be merged into the current state of the route."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A string with an anchor tag that points to the populated route.\n"
    },
    "comment": " "
  },
  "can-route.current": {
    "type": "function",
    "name": "can-route.current",
    "parent": "can-route.static",
    "src": {
      "line": 706,
      "codeLine": 750,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n\n## Use\n\nChecks the page's current URL to see if the route represents the options\npassed into the function.\n\nReturns true if the options represent the current URL.\n\n```js\nroute.data.id = 5; // location.hash -> \"#!id=5\"\nroute.current({ id: 5 }); // -> true\nroute.current({ id: 5, type: 'videos' }); // -> false\n\nroute.data.type = 'videos';\n  // location.hash -> #!id=5&type=videos\nroute.current({ id: 5, type: 'videos' }); // -> true\n```\n \n",
    "description": "\nCheck if data represents the current route.\n",
    "title": "current",
    "signatures": [
      {
        "code": "route.current(data [,subsetMatch] )",
        "description": "\n\nCompares `data` to the current route. Used to verify if an object is\nrepresentative of the current route.\n\n```\nroute.data.set({page: \"recipes\", id: '5'});\n\nroute.current({page: \"recipes\"});       //-> false\nroute.current({page: \"recipes\"}, true); //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "Data to check agains the current route."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If true, `route.current` will return true\nif every value in `data` matches the current route data, even if\nthe route data has additional properties that are not matched.  Defaults to `false`\nwhere every property needs to be present."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Whether the data matches the current URL.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "subsetMatch",
      "description": "If true, `route.current` will return true\nif every value in `data` matches the current route data, even if\nthe route data has additional properties that are not matched.  Defaults to `false`\nwhere every property needs to be present."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Whether the data matches the current URL.\n"
    },
    "comment": " "
  },
  "can-route.matched": {
    "name": "can-route.matched",
    "type": "function",
    "parent": "can-route.static",
    "src": {
      "line": 832,
      "codeLine": 853,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Use `route.matched()` to find the currently matched route.\n\n```js\nroute(\"{type}\", { type: \"foo\" });\nroute(\"{type}/{subtype}\");\n\nroute.matched(); // \"{type}\"\n\nroute.data.subtype = \"foo\";\n\nroute.matched(); // \"{type}/{subtype}\"\n```\n \n",
    "description": "A compute representing the currently matched route. ",
    "title": "matched",
    "signatures": [
      {
        "code": "route.matched()",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The currently matched route.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The currently matched route.\n"
    },
    "comment": " "
  },
  "can-route.static": {
    "name": "can-route.static",
    "title": "static",
    "type": "group",
    "parent": "can-route",
    "description": "",
    "order": 0
  },
  "can-route": {
    "src": {
      "path": "node_modules/can-route/can-route.md"
    },
    "body": "\n## Use\n\n## Background information\n\nTo support the browser's back button and bookmarking in a JavaScript\n application, most applications use\nthe `window.location.hash`.  By\nchanging the hash (via a link or JavaScript), \none is able to add to the browser's history \nwithout changing the page.\n\nThis provides the basics needed to\ncreate history enabled single-page apps.  However,\n`route` addresses several other needs such as:\n\n  - Pretty urls.\n  - Keeping routes independent of application code.\n  - Listening to specific parts of the history changing.\n  - Setup / Teardown of widgets.\n\n## How it works\n\ncan-route is a map that represents the\n`window.location.hash` as an \nobject.  For example, if the hash looks like:\n\n    #!type=videos&id=5\n    \nthe data in can-route looks like:\n\n    { type: 'videos', id: 5 }\n\ncan-route keeps the state of the hash in-sync with the `data` contained within it.\n\n## data\n\nUnderlying can-route is an observable map: `route.data`. Depending on what type of map your application uses this could be a [can-map], a [can-define/map/map], or maybe even a [can-simple-map].\n\nUnderstanding how maps work is essential to understanding can-route.\n\nYou can listen to changes in a map with `on(eventName, handler(ev, args...))` and change can-route's properties by modifying `route.data`.\n\n### Listening to changes in can-route\n\nListen to changes in history by [can-event.addEventListener listening] to\nchanges in can-route like:\n\n```js\nroute.on('foo', function(ev, attr, how, newVal, oldVal) {\n\t// Foo changed!\n})\n```\n\n - `attr` - the name of the changed attribute\n - `how` - the type of Observe change event (add, set or remove)\n - `newVal`/`oldVal` - the new and old values of the attribute\n\n### Updating can-route\n\nWhen using a [can-define/map/map DefineMap] to back can-route, create changes in the route data by modifying it directly:\n\n```js\nroute.data.type = 'image';\n```\n\nOr change multiple properties at once like:\n\n```js\nroute.data.set({type: 'page', id: 5}, true);\n```\n\nWhen you make changes to can-route, they will automatically\nchange the <code>hash</code>.\n\nIf using [can-map] or [can-simple-map] to back your route, update `route.data` using `attr`.\n\n## Creating a route\n\nUse `route(url, defaults)` to create a \nroute. A route is a mapping from a url to \nan object (that is the route's state). \nIn order to map to a specific properties in the url,\nprepend a colon to the name of the property like:\n\n```js\nroute(\"#!content/{type}\");\n```\n\nIf no routes are added, or no route is matched, \ncan-route's data is updated with the [can-route.deparam deparamed]\nhash.\n\n```js\nlocation.hash = \"#!type=videos\";\n// route -> {type : \"videos\"}\n```\n    \nOnce routes are added and the hash changes,\ncan-route looks for matching routes and uses them\nto update can-route's data.\n\n```js\nroute(\"#!content/{type}\");\nlocation.hash = \"#!content/images\";\n// route -> {type : \"images\"}\nroute.data.type = \"songs\";\n// location.hash -> \"#!content/songs\"\n```\n    \nDefault values can be added to a route:\n\n```js\nroute(\"content/{type}\",{type: \"videos\" });\nlocation.hash = \"#!content/\"\n// route -> {type : \"videos\"}\n// location.hash -> \"#!content/\"\n```\n\nDefaults can also be set on the root page of your app:\n\n```js\nroute(\"\", { page: \"index\" });\nlocation.hash = \"#!\";\n// route -> {page : \"index\"}\n// location.hash -> \"#!\"\n```\n\n## Initializing can-route\n\nAfter your application has created all of its routes, call [can-route.ready]\nto set can-route's data to match the current hash:\n\n```js\nroute.ready();\n```\n\n## Changing the route\n\nTypically, you don't set `location.hash`\ndirectly. Instead, you can change properties on can-route\nlike:\n\n```js\nroute.data.type = 'videos';\n```\n    \nThis will automatically look up the appropriate \nroute and update the hash.\n\nOften, you want to create links. can-route provides\nthe [can-route.link] and [can-route.url] helpers to make this \neasy:\n\n```js\nroute.link(\"Videos\", {type: 'videos'});\n```\n\n## Finding the matched route\n\nThe matched route is stored in the compute `route.matched` and is used to set the `window.location.hash`. The process can-route uses to find the matched route is:\n  - Find all routes with all of their map properties set\n  - If multiple routes are matched, find the route with the highest number of set properties\n  - If multiple routes are still matched, use the route that was registered first\n\n### Find all routes with all of their map properties set\n\nIn order for a route to be matched, all of the map properties it uses must be set. For example, in the following route, `page` and `section` must be set in order for this route to be matched:\n\n```js\nroute('{page}/{section}');\nroute.ready();\n\nroute.data.page = 'contact';\nroute.data.section = 'email';\n\nroute.matched(); // \"{page}/{section}\"\n```\n\nIf a route contains default values, these map properties must also be set to match the default value in order for the route to be matched:\n\n```js\nroute('{page}', { section: 'email' });\nroute.ready();\n\nroute.data.page = 'contact';\nroute.data.section = 'email';\n\nroute.matched(); // \"{page}\"\n```\n\n### Find the route with the highest number of set properties\n\nIf multiple routes have all of their properties set, the route with the highest number of set properties will be used:\n\n```js\nroute('{page}');\nroute('{page}/{section}');\nroute.ready();\n\nroute.data.page = 'two';\nroute.data.section = 'a';\n\nroute.matched(); // \"{page}/{section}\"\n```\n\n### Find the route that was registered first\n\nIf multiple routes are still matched, the route that was registered first will be matched:\n\n```js\nroute('', { page: 'home' });\nroute('{section}');\nroute.ready();\n\nroute.data.page = 'home';\nroute.data.section = 'a';\n\nroute.matched(); // \"\"\n```\n\n",
    "description": "Manage browser history and client state by synchronizing the `window.location.hash` with a map. \n",
    "title": "can-route",
    "name": "can-route",
    "parent": "can-core",
    "type": "function",
    "download": "can/route",
    "test": "can-route/test.html",
    "link": "../docco/route/route.html docco",
    "signatures": [
      {
        "code": "route(template [, defaults])",
        "description": "\n\nCreate a route matching rule. Optionally provide defaults that will be applied to the underlying map when the route matches.\n\n```js\nroute(\"{page}\", { page: \"home\" });\n```\n\nWill apply **cart** when the url is `#cart` and **home** when the url is `#`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "the fragment identifier to match.  The fragment identifier should contain characters (a-Z), optionally wrapped in braces ( { } ). Identifiers wrapped in braces are interpreted as being properties on can-route's map. Examples:\n\n```js\nroute(\"{foo}\")\nroute(\"foo/{bar}\")\n```\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "defaults",
            "description": "An object of default values. These defaults are applied to can-route's map when the route is matched.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-route"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "defaults",
      "description": "An object of default values. These defaults are applied to can-route's map when the route is matched.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-route"
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-route.data": {
    "src": {
      "path": "node_modules/can-route/route_data.md"
    },
    "body": "\n\n## Background\n\nOne of the biggest challenges in a complex application is getting all the different parts of the app to talk to each other simply, cleanly, and reliably. \n\nAn elegant way to solve this problem is using the [Observer Pattern](http://en.wikipedia.org/wiki/Observer_pattern). A single object, which can be called [Application ViewModel](https://www.youtube.com/watch?v=LrzK4exG5Ss), holds the high level state of the application.\n\n## Use\n\nSetting `route.data` is an easy way to cross-bind your Application ViewModel object to `route`. This will serialize your Application ViewModel into the hash (or pushstate URLs).\n\n```js\nvar ViewModel = DefineMap.extend({\n\tpetType: \"string\",\n\tstoreId: \"number\"\n});\n\nvar viewModel = new ViewModel({\n\tpetType: \"string\",\n\tstoreId: \"number\"\n});\n\nroute.data = viewModel;\n```\n\n`route.data` can also be set to a constructor function. A new instance will be created and bound to:\n\n```js\nvar ViewModel = DefineMap.extend({\n    page: {\n        type: \"string\",\n        set: function(page){\n            if(page === \"user\") {\n                this.verifyLoggedIn();\n            }\n            return page;\n        }\n    }\n});\n\nroute.data = ViewModel;\n```\n\n## When to set it\n\nSet `route.data` at the  start of the application lifecycle, before any calls to `route.addEventListener`. This will allow events to correctly bind on this new object.\n\n## Demo\n\nThe following shows creating an Application ViewModel that loads data at page load, has a virtual property 'locationIds' which serializes an array, and synchronizes the viewModel to can-route:\n\n<div class='demo_wrapper' data-demo-src='demos/can-route/data.html'></div>\n\n## Complete example\n\nThe following example shows loading some metadata on page load, which must be loaded as part of the Application ViewModel before the components can be initialized\n\nIt also shows an example of a \"virtual\" property on the AppViewModel, locationIds, which is the serialized version of a non-serializeable can.List, locations.  A setter is defined on locationIds, which will translate changes in locationIds back to the locations can.List.\n\n```js\nvar Location = DefineMap.extend({\n\tselected: \"boolean\",\n\tid: \"any\"\n});\n\nvar LocationList = DefineList.extend({\n\t\"*\": Location\n});\n\nvar AppViewModel = DefineMap.extend({\n\tlocations: {\n\t\ttype: \"any\",\n\t\t// don't serialize this property at all in the route\n\t\tserialize: false\n\t},\n\t// virtual property that contains a comma separated list of ids\n\t// based on locations that are selected\n\tlocationIds: {\n\n\t\t// comma separated list of ids\n\t\tserialize: function(){\n\t\t\tvar selected = thislocations.filter(\n\t\t\t\tfunction(location){\n\t\t\t\t\treturn location.selected;\n\t\t\t\t});\n\t\t\tvar ids = [];\n\t\t\tselected.each(function(item){\n\t\t\t\tids.push(item.id);\n\t\t\t})\n\t\t\treturn selected.join(',');\n\t\t},\n\t\t\n\t\t// toggle selected from a comma separated list of ids\n\t\tset: function(val){\n\t\t\tvar arr = val;\n\t\t\tif(typeof val === \"string\"){\n\t\t\t\tarr = val.split(',')\n\t\t\t}\n\t\t\t// for each id, toggle any matched location\n\t\t\tthis.locations.forEach(function(location){\n\t\t\t\tif(arr.indexOf(location.id) !== -1){\n\t\t\t\t\tlocation.selected = true;\n\t\t\t\t} else {\n\t\t\t\t\tlocation.selected = false;\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n});\n\n// initialize and set route.data first, so anything binding to can-route\n// will work correctly\nvar viewModel = new AppViewModel();\nroute.data = appViewModel;\n\n// GET /locations\nvar locations = new Location.List({});\n\n// when the data is ready, set the locations property\nlocations.done(function(){\n\tviewModel.locations = locations;\n\n\t// call ready after the AppViewModel is fully initialized\n\troute.ready();\n});\n```\n\n## Why\n\nThe Application ViewModel object, which is cross-bound to the can-route via `route.data` and represents the overall state of the application, has several obvious uses:\n\n* It is passed into the various components and used to communicate their own internal state.\n* It provides deep linking and back button support. As the URL changes, Application ViewModel changes cause changes in application components.\n* It provides the ability to \"save\" the current state of the page, by serializing the Application ViewModel object and saving it on the backend, then restoring with that object to load this saved state.\n\n",
    "description": "\nThis is the internal map underlying can-route. It can be set in order to cross-bind a top level state object (Application ViewModel) to can-route.\n",
    "title": "data",
    "name": "can-route.data",
    "type": "function",
    "parent": "can-route.static",
    "comment": " "
  },
  "can-simple-map": {
    "src": {
      "path": "node_modules/can-simple-map/can-simple-map.md"
    },
    "body": "\nA performant live-bound map\n\n",
    "description": "\n# can-simple-map\n",
    "name": "can-simple-map",
    "type": "page"
  },
  "can-map-define": {
    "src": {
      "path": "node_modules/can-map-define/docs/define.md"
    },
    "body": "\n\n## Use\n\nThe [can-map-define define] plugin allows you to completely control the behavior\nof attributes on a [can-map Map]. To use it, you specify \nan `define` object that is a mapping of properties \nto [can-map-define.attrDefinition attribute definitions]. The following example \nspecifies a Paginate Map:\n\n    var Paginate = Map.extend({\n      define: {\n        count: {\n          type: \"number\",\n          value: Infinity,\n          // Keeps count above 0.\n          set: function(newCount){\n            return newCount < 0 ? 0 : newCount;\n          }\n        },\n        offset: {\n          type: \"number\",\n          value: 0,\n          // Keeps offset between 0 and count\n          set: function(newOffset){\n            var count = this.attr(\"count\");\n            return newOffset < 0 ?\n\t\t      0 :\n\t\t      Math.min(newOffset, !isNaN( count - 1) ?\n\t\t        count - 1 :\n\t\t        Infinity);\n          }\n        },\n        limit: {\n          type: \"number\",\n          value: 5\n        },\n        page: {\n          // Setting page changes the offset\n          set: function(newVal){\n            this.attr('offset', (parseInt(newVal) - 1) * \n                                 this.attr('limit'));\n          },\n          // The page value is derived from offset and limit.\n          get: function (newVal) {\n\t\t    return Math.floor(this.attr('offset') / \n\t\t                      this.attr('limit')) + 1;\n\t\t  }\n        }\n      }\n    });\n\n## Default behaviors\n\nThe [can-map-define define] plugin not only allows you to define \nindividual attribute behaviors on a [can-map Map], but you can also define default\nbehaviors that would apply to any unspecified attribute. This is particularly\nhelpful for when you need a particular behavior to apply to every attribute on\na [can-map Map] but won't be certain of what every attribute will be.\n\nThe following example is a [can-map Map] that is tied to [can-route route] where only \nspecified attributes that are serialized will be updated in the location hash:\n\n    var State = Map.extend({\n      define: {\n        foo: {\n          serialize: true\n        },\n        '*': {\n          serialize: false\n        }\n      }\n    });\n\n    var state = new State();\n\n    // tie State map to the route\n    route.map(state);\n    route.ready();\n\n    state.attr('foo', 'bar');\n    state.attr('bar', 'baz');\n\n    window.location.hash; // -> #!foo=bar\n\n\n## Overview\n\nThis plugin is a replacement for the now deprecated [can-map-attributes attributes] and [can-map-setter setter] plugins. It intends to provide a single place to define the behavior of all the properties of a [can-map Map].\n\nHere is the cliffnotes version of this plugin.  To define...\n\n* The default value for a property - use [can-map-define.value value]\n* That default value as a constructor function - use [can-map-define.ValueConstructor Value]\n* What value is returned when a property is read - use [can-map-define.get get]\n* Behavior when a property is set - use [can-map-define.set set]\n* How a property is serialized when [can-map.prototype.serialize serialize] is called on it - use [can-map-define.serialize serialize]\n* Behavior when a property is removed - use [can-map-define.remove remove]\n* A custom converter method or a pre-defined standard converter called whenever a property is set - use [can-map-define._type type]\n* That custom converter method as a constructor function - use [can-map-define.TypeConstructor Type]\n\n## Demo\n\nThe following shows picking cars by make / model / year:\n\n<div class='demo_wrapper' data-demo-src='can/map/define/doc/examples/make-model-year.html'></div>\n\n\n\n\n\n",
    "description": "\nDefines the\n`type`, initial `value`, `get`, `set`, `remove`, and `serialize` behavior for attributes \nof a [can-map Map].\n",
    "name": "can-map-define",
    "type": "module",
    "title": "define",
    "types": [
      {
        "type": "plugin",
        "options": [
          {
            "name": "define",
            "description": "A map of \nattribute names to [can-map-define.attrDefinition attribute definition]\nobjects.\n",
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can.Map.prototype.define.attrDefinition"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "parent": "can-legacy",
    "comment": " "
  },
  "route.pushstate.root": {
    "src": {
      "line": 30,
      "codeLine": 65,
      "path": "node_modules/can-route-pushstate/can-route-pushstate.js"
    },
    "type": "property",
    "body": "\n## Use\n\nBy default, a route like:\n\n    route(\":type/:id\")\n\nMatches urls like:\n\n    http://domain.com/contact/5\n\nBut sometimes, you only want to match pages within a certain directory.  For\nexample, an application that is a filemanager.  You might want to\nspecify root and routes like:\n\n    route.pushstate.root = \"/filemanager/\"\n    route(\"file-:fileId\");\n    route(\"folder-:fileId\")\n\nWhich matches urls like:\n\n    http://domain.com/filemanager/file-34234\n\n\t \n",
    "description": "Configure the base url that will not be modified. \n",
    "types": [
      {
        "type": "String",
        "description": "Represents the base url that pushstate will prepend to all\nroutes.  `root` defaults to: `\"/\"`.\n"
      }
    ],
    "title": "",
    "name": "route.pushstate.root",
    "parent": "route.pushstate",
    "comment": " "
  },
  "can-route-pushstate": {
    "src": {
      "path": "node_modules/can-route-pushstate/can-route-pushstate.md"
    },
    "body": "\n## Use\n\ncan-route-pushstate uses the same API as [can-route]. To start using can-route-pushstate all you need is to import `can-route-pushstate`, it will set itself as default binding on [can-route].\n\nYou can check current binding by inspecting `route.currentBinding`; the default value is `\"hashchange\"`.\n\n### Creating and changing routes\n\nTo create routes use `route(url, defaults)` like:\n\n```js\nroute(\"{page}\", {page: 'homepage'});\nroute(\"contacts/{username}\");\nroute(\"books/{genre}/{author}\");\n\nroute.ready(); // Initializes can-route\n```\n\nDo not forget to [can-route.ready initialize] can-route after creating all routes, do it by calling `route.ready()`.\n\nList of defined routes is contained in `route.routes`, you can examine current route state by calling:\n\n```js\nroute.attr(); //-> {page: \"homepage\", route: \"{page}\"}\n```\n\nAfter creating routes and initializing can-route you can update current route by calling `route.attr(attr, newVal)`:\n\n```js\nroute.attr('page', 'about');\nroute.attr(); //-> {page: \"about\", route: \"{page}\"}\n\n// without cleaning current route state\nroute.attr('username', 'veljko');\nroute.attr(); //-> {page: \"about\", route: \"{page}\", username: 'veljko'}\n\n// with cleaning current can-route state\nroute.attr({username: 'veljko'}, true);\nroute.attr(); //-> {username: \"veljko\", route: \"contacts/{username}\"}\n```\n\nTo update multiple attributes at once pass hash of attributes to `route.attr(hashOfAttrs, true)`. Pass `true` as second argument to clean up current state.\n\n```js\nroute.attr({genre: 'sf', author: 'adams'}, true);\nroute.attr(); //-> {genre: \"sf\", author: \"adams\", route: \"books/{genre}/{author}\"}\n```\n\n`window.location` acts as expected:\n\n```js\nwindow.location.pathname; //-> \"/books/sf/adams\"\nwindow.location.hash; //-> \"\", hash remains unchanged\n```\n\nTo generate urls use `route.url({attrs})`:\n\n```js\nroute.url({username: 'justinbmeyer'}); //-> '/contacts/justinbmeyer'\n```\n\n### Listening changes on matched route\n\nAs can-route contains a map that represents `window.location.pathname`, you can bind on it.\n\nTo bind to specific attributes on can-route:\n\n```js\nroute.bind('username', function(ev, newVal, oldVal) {\n\t//-> ev:     {EventObject}\n\t//-> newVal: 'nikica'\n\t//-> oldVal: 'veljko'\n});\n\nroute.attr({username: nikica}, true);\n```\n\n### Using different pathname root\n\ncan-route-pushstate has one additional property, `route.bindings.pushstate.root`, which specifies the part of that pathname that should not change. For example, if we only want to have pathnames within `http://example.com/contacts/`, we can specify a root like:\n\n```js\nroute.bindings.pushstate.root = \"/contacts/\"\nroute(\"{page}\");\nroute.url({page: \"list\"}) //-> \"/contacts/list\"\nroute.url({foo: \"bar\"})   //-> \"/contacts/?foo=bar\"\n```\n\nNow, all routes will start with `\"/contacts/\"`, the default `route.bindings.pushstate.root` value is `\"/\"`.\n\n## Planning route structure\n\nComplications can arise if your route structure mimics the folder structure inside your app's public directory.  For example, if you have a folder structure like the one in this url for your admin app...\n\n`/admin/users/list.js`\n\n... using a route of /admin/users on the same page that uses the list.js file will require the use of a trailing slash on all routes and links.  The browser already learned that '/admin/users' is folder.  Because folders were originally denoted by a trailing slash in a url, the browser will correct the url to be '/admin/users/'.  While it is possible to add the trailing slash in routes and listen for them, any link to the page that omits the trailing slash will not trigger the route handler.\n\n",
    "description": "Changes [can-route] to use [pushstate](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history)\nto change the window's [pathname](https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.pathname) instead\nof the [hash](https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.hash).\n\n```js\nvar route = require(\"can-route-pushstate\");\n\nroute(\"{page}\", { page: \"home\" });\nroute.ready();\n\nroute.attr(\"page\", \"user\");\n\nlocation.pathname; // -> \"/user\"\n```\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "The",
            "description": "pushstate object comprises several properties that configure the behavior of [can-route] to work with `history.pushstate`.\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can-route-pushstate",
    "parent": "can-core",
    "comment": " "
  },
  "can-util": {
    "src": {
      "path": "node_modules/can-util/doc/can-util.md"
    },
    "body": "\n",
    "description": "\nA set of utilities.\n",
    "name": "can-util",
    "type": "page",
    "parent": "can-infrastructure"
  },
  "can-vdom": {
    "src": {
      "path": "node_modules/can-vdom/can-vdom.md"
    },
    "body": "\nA browser-lite environment for nodejs\n\n",
    "description": "\n# can-vdom\n",
    "name": "can-vdom",
    "type": "page"
  },
  "can/view/autorender": {
    "src": {
      "path": "node_modules/can-view-autorender/autorender.md"
    },
    "body": "\n\n## Use\n\nAs long is this module is part of your CanJS build or imported with RequireJS, StealJS, or SystemJS,\n[can/view/autorender.can-autorender] will automatically look for `can-autorender` tags and render them.  Once\nall templates have finished rendering, it will call any callbacks passed to `can.autorender()`.\n\n\nFor example, you might have a page like:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'\n\t\tmessage=\"Hello World\">\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\n\t<script src='jquery.js'></script>\n\t<!-- A CanJS build that includes this plugin -->\n\t<script src='can.custom.js'></script>\n\t<!-- All your app's code and components -->\n\t<script src='app.js'></script>\n\t<script>\n\t\t// Wait until everything has rendered.\n\t\tcan.autorender(function(){\n\n\t\t\t// Update the viewModel the template was rendred with:\n\t\t\t$(\"#main\").viewModel().attr(\"message\",\"Rendered!\");\n\n\t\t})\n\t</script>\n</body>\n```\n\n## Rendered placement\n\nIf the template source is a `<script>` tag within the `<body>`, the rendered template is placed\nimmediately following the template.\n\nFor example:\n\n```\n<body>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n\t<div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n\tHi!\n\t<div>...</div>\n</body>\n```\n\nIf the `<script>` tag is outside the body, for example in the `<head>`\ntag, the rendered result will be placed just before the closing `</body>` tag.\n\nFor example:\n\n```\n<head>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n</head>\n<body>\n\t<div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<head>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n</head>\n<body>\n\t<div>...</div>\n\tHi!\n</body>\n```\n\nIf the template source is any other element, the element's contents will be replaced with the rendered result.  For example:\n\n```\n<body>\n\t<div type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n\t<div type='text/stache' can-autorender message=\"Hi\">\n\t\tHi!\n\t</div>\n</body>\n```\n\n## Scope\n\nThe template is rendered with a [can.Map] made from the attributes of the\ntemplate source element.  That `map` is available on the\ntemplate source element via [can.viewModel].  You can\nchange the map at any time:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'>\n\t\t{{message}}!\n\t</script>\n\t<script>\n\t\tvar viewModel = can.viewModel(document.getElementById(\"main\"));\n\t\tviewModel.attr(\"message\",\"Hello There!\");\n\t</script>\n</body>\n```\n\nYou can change attributes on the element and it will update the\nviewModel too:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'>\n\t\t{{message}}!\n\t</script>\n\t<script>\n\t\tvar main = document.getElementById(\"main\");\n\t\tmain.setAttribute(\"message\",\"Hello There!\");\n\t</script>\n</body>\n```\n\n\n\n## StealJS Use\n\nFor demo pages that require very little setup:\n\n```\n<body>\n\t<script type='text/stache'>\n\t\t<can-import from=\"components/my-component\"/>\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\t<script src='../node_modules/steal/steal.js'\n\t\t\t\t\tmain='can/view/autorender/'>\n\t</script>\n</body>\n```\n\nFor demo pages that require a little custom setup:\n\n```\n<body>\n\t<script type='text/stache' can-autorender>\n\t\t<can-import from=\"components/my-component\"/>\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\t<script src='../node_modules/steal/steal.js'\n\t\t\t\t\tmain='@empty'>\n\t\tvar can = require('can');\n\t\tvar $ = reqire('jquery');\n\t\trequire('can/view/autorender/autorender');\n\n\t\t$(\"my-component\").viewModel().attr(\"message\", \"Hi\");\n\t</script>\n</body>\n```\n\n\n\n\n\n## Errors\n\nError callbacks will be called if a template has a parsing error or\na [can/view/stache/system.import] fails.\n\n",
    "description": "\nA module that automatically renders script and other elements with\nthe [can/view/autorender.can-autorender] attribute. This function is useful to know when\nthe templates have finished rendering.\n",
    "type": "module",
    "title": "can.autorender",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can/view/autorender",
    "parent": "can.view.plugins",
    "signatures": [
      {
        "code": "can.autorender(succcess, error)",
        "description": "\n\n\tRegisters functions to callback when all templates successfully render or an error in rendering happens.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "success",
            "description": "A function to callback when all autorendered templates have been rendered\nsuccessfully.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function to callback if a template was not rendered successfully.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function to callback if a template was not rendered successfully.\n"
    },
    "comment": " "
  },
  "can-view-autorender": {
    "src": {
      "path": "node_modules/can-view-autorender/can-view-autorender.md"
    },
    "body": "\nAutomatically render templates found in the document\n\n",
    "description": "\n# can-view-autorender\n",
    "name": "can-view-autorender",
    "type": "page"
  },
  "can-view-nodelist/methods": {
    "name": "can-view-nodelist/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-view-nodelist",
    "description": "",
    "order": 0
  },
  "can-view-nodelist/types": {
    "name": "can-view-nodelist/types",
    "title": "types",
    "type": "group",
    "parent": "can-view-nodelist",
    "description": "",
    "order": 0
  },
  "can-view-nodelist": {
    "src": {
      "path": "node_modules/can-view-nodelist/can-view-nodelist.md"
    },
    "body": "",
    "description": "Adds nesting of text nodes \n`can.view.nodeLists` are used to make sure \"directly nested\" live-binding\nsections update content correctly.\n\nConsider the following template:\n\n```html\n<div>\n{{#if items.length}}\n    Items:\n        {{#items}}\n            <label></label>\n        {{/items}}\n{{/if}}\n</div>\n```\n\nThe `{{#if}}` and `{{#items}}` seconds are \"directly nested\" because\nthey share the same `<div>` parent element.\n\nIf `{{#items}}` changes the DOM by adding more `<labels>`,\n`{{#if}}` needs to know about the `<labels>` to remove them\nif `{{#if}}` is re-rendered.  `{{#if}}` would be re-rendered, for example, if\nall items were removed.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-nodelist",
    "parent": "can-infrastructure"
  },
  "can-view-nodelist.id": {
    "type": "function",
    "name": "can-view-nodelist.id",
    "parent": "can-view-nodelist",
    "src": {
      "line": 34,
      "codeLine": 49,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "id",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.id(node, localMap)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "node",
            "description": "an HTML element, text node, or other object"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "localMap",
            "description": "an optional map for text node IDs"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the ID value generated for the node.\n\nGiven a template node, create an id on the node as a expando\nproperty, or if the node is an HTMLTextNode and the browser\ndoesn't support expando properties store the id with a\nreference to the text node in an internal collection then return\nthe lookup id.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "localMap",
      "description": "an optional map for text node IDs"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the ID value generated for the node.\n\nGiven a template node, create an id on the node as a expando\nproperty, or if the node is an HTMLTextNode and the browser\ndoesn't support expando properties store the id with a\nreference to the text node in an internal collection then return\nthe lookup id.\n\n"
    }
  },
  "can-view-nodelist.update": {
    "type": "function",
    "name": "can-view-nodelist.update",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 178,
      "codeLine": 191,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "\n",
    "title": "update",
    "signatures": [
      {
        "code": "nodeLists.update(nodeList, newNodes)",
        "description": "\n\nUpdates a nodeList with new items, i.e. when values for the template have changed.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "The list to update with the new nodes."
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "newNodes",
            "description": "The new nodes to update with.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Node"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The nodes that were removed from `nodeList`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "newNodes",
      "description": "The new nodes to update with.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "description": "The nodes that were removed from `nodeList`.\n"
    }
  },
  "can-view-nodelist.nestReplacements": {
    "type": "function",
    "name": "can-view-nodelist.nestReplacements",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 217,
      "codeLine": 231,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "nestReplacements",
    "signatures": [
      {
        "code": "nodeLists.nestReplacements(list)",
        "description": "\n\nGoes through each node in the list. `[el1, el2, el3, ...]`\nFinds the nodeList for that node in replacements.  el1's nodeList might look like `[el1, [el2]]`.\nReplaces that element and any other elements in the node list with the\nnodelist itself. resulting in `[ [el1, [el2]], el3, ...]`\nIf a replacement is not found, it was improperly added, so we add it as a deepChild.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "list",
            "description": "The nodeList of nodes to go over\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "list",
      "description": "The nodeList of nodes to go over\n\n"
    }
  },
  "can-view-nodelist.nestList": {
    "type": "function",
    "name": "can-view-nodelist.nestList",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 258,
      "codeLine": 271,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "nestList",
    "signatures": [
      {
        "code": "nodeLists.nestList(list)",
        "description": "\n\nIf a given list does not exist in the nodeMap then create an lookup\nid for it in the nodeMap and assign the list to it.\nIf the the provided does happen to exist in the nodeMap update the\nelements in the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "list",
            "description": "The nodeList being nested.\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "list",
      "description": "The nodeList being nested.\n\n "
    }
  },
  "can-view-nodelist.last": {
    "type": "function",
    "name": "can-view-nodelist.last",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 288,
      "codeLine": 301,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "last",
    "signatures": [
      {
        "code": "nodeLists.last(nodeList)",
        "description": "\n\nReturn the last HTMLElement in a nodeList; if the last\nelement is a nodeList, returns the last HTMLElement of\nthe child list, etc.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The last element of the last list nested in this list.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "A nodeList."
    },
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The last element of the last list nested in this list.\n\n "
    }
  },
  "can-view-nodelist.first": {
    "type": "function",
    "name": "can-view-nodelist.first",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 312,
      "codeLine": 326,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "first",
    "signatures": [
      {
        "code": "nodeLists.first(nodeList)",
        "description": "\n\nReturn the first HTMLElement in a nodeList; if the first\nelement is a nodeList, returns the first HTMLElement of\nthe child list, etc.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The first element of the first list nested in this list.\n\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "A nodeList."
    },
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The first element of the first list nested in this list.\n\n\n "
    }
  },
  "can-view-nodelist.register": {
    "type": "function",
    "name": "can-view-nodelist.register",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 348,
      "codeLine": 363,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "\n",
    "title": "register",
    "signatures": [
      {
        "code": "nodeLists.register(nodeList, unregistered, parent, directlyNested)",
        "description": "\n\nRegisters a nodeList and returns the nodeList passed to register.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "unregistered",
            "description": "A callback to call when the nodeList is unregistered."
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "parent",
            "description": "The parent nodeList of this nodeList."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "directlyNested",
            "description": "`true` if nodes in the nodeList are direct children of the parent."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-view-nodelist/types/NodeList"
            }
          ],
          "description": "The passed in nodeList.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "directlyNested",
      "description": "`true` if nodes in the nodeList are direct children of the parent."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "description": "The passed in nodeList.\n\n "
    }
  },
  "can-view-nodelist.unregisterChildren": {
    "type": "function",
    "name": "can-view-nodelist.unregisterChildren",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 392,
      "codeLine": 403,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "unregisterChildren",
    "signatures": [
      {
        "code": "nodeLists.unregisterChildren(nodeList)",
        "description": "\n\nUnregister all childen within the provided list and return the\nunregistred nodes.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "The nodeList of child nodes to unregister."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "The list of all nodes that were unregistered.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "The nodeList of child nodes to unregister."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "The list of all nodes that were unregistered.\n "
    }
  },
  "can-view-nodelist.unregister": {
    "type": "function",
    "name": "can-view-nodelist.unregister",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 430,
      "codeLine": 442,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "unregister",
    "signatures": [
      {
        "code": "nodeLists.unregister(nodeList, isChild)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "nodeList",
            "description": "a nodeList to unregister from its parent"
          },
          {
            "types": [
              {
                "type": "isChild"
              }
            ],
            "name": "true",
            "description": "if the nodeList is a direct child, false if a deep child"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a list of all nodes that were unregistered\n\nUnregister's a nodeList and returns the unregistered nodes.\nCall if the nodeList is no longer being updated. This will\nalso unregister all child nodeLists.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "isChild"
        }
      ],
      "name": "true",
      "description": "if the nodeList is a direct child, false if a deep child"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a list of all nodes that were unregistered\n\nUnregister's a nodeList and returns the unregistered nodes.\nCall if the nodeList is no longer being updated. This will\nalso unregister all child nodeLists.\n"
    }
  },
  "can-view-nodelist.after": {
    "type": "function",
    "name": "can-view-nodelist.after",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 463,
      "codeLine": 475,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "after",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.after(oldElements, newFrag)",
        "description": "\n\n  Inserts `newFrag` after `oldElements`.\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "The elements to use as reference."
          },
          {
            "types": [
              {
                "type": "DocumentFragment"
              }
            ],
            "name": "newFrag",
            "description": "The fragment to insert.\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "newFrag",
      "description": "The fragment to insert.\n\n "
    }
  },
  "can-view-nodelist.replace": {
    "type": "function",
    "name": "can-view-nodelist.replace",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 484,
      "codeLine": 496,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "replace",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.replace(oldElements, newFrag)",
        "description": "\n\nReplaces `oldElements` with `newFrag`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "the list elements to remove"
          },
          {
            "types": [
              {
                "type": "DocumentFragment"
              }
            ],
            "name": "newFrag",
            "description": "the fragment to replace the old elements\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "newFrag",
      "description": "the fragment to replace the old elements\n\n "
    }
  },
  "can-view-nodelist.remove": {
    "type": "function",
    "name": "can-view-nodelist.remove",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 517,
      "codeLine": 528,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "remove",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.remove(elementsToBeRemoved)",
        "description": "\n\nRemove all Nodes in `oldElements` from the DOM.\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "the list of Elements to remove (must have a common parent)\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ArrayLike",
          "template": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "name": "oldElements",
      "description": "the list of Elements to remove (must have a common parent)\n\n "
    }
  },
  "can-view-model": {
    "src": {
      "path": "node_modules/can-view-model/can-view-model.md"
    },
    "body": "\n## Use\n\n**can-view-model** is used to get and set properties on an element's ViewModel. Each element in the DOM can have an associated ViewModel. An example of this is a [can-component] and it's associated [can-component.prototype.ViewModel].\n\nThis shows a Component and getting its ViewModel:\n\n```html\n<my-tabs>\n ...\n</my-tabs>\n```\n\n```js\nvar canViewModel = require(\"can-view-model\");\n\nvar element = document.querySelector(\"my-tabs\");\nvar vm = canViewModel(element);\n```\n\nThe other signatures provide the ability to get and set properties on the ViewModel. For example, this sets the \"foo\" property on a component's viewModel:\n\n```js\nvar canViewModel = require(\"can-view-model\");\n\nvar element = document.querySelector(\"my-tabs\");\nvar vm = canViewModel(element);\n\ncanViewModel(element, \"foo\", \"bar\");\n\nconsole.log(vm.foo, \"bar\");\n```\n\n## Setting an element's ViewModel\n\nOne thing that can-view-model does ***not*** do is provide a way to set what an element's ViewModel should be. To do that, use [can-util/dom/data/data] instead like so:\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar element = document.querySelector(\"#my-id\");\n\nvar myVm = new DefineMap();\n\ndomData.set.call(element, \"viewModel\", myVm);\n```\n\n",
    "description": "Gets the ViewModel of an [element](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement). \n",
    "type": "module",
    "title": "can-view-model",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-model",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "canViewModel(element)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-util/js/types/types.DefaultMap] if it doesn't already exist, and returns the map.\n\n```js\nvar vm = canViewModel(element);\n```",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "Any element in the DOM.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            },
            {
              "type": "can-define/map/map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The ViewModel associated with this elelement.\n"
        }
      },
      {
        "code": "canViewModel(element, property)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-util/js/types/types.DefaultMap] if it doesn't already exist. Then gets the **property** inside of the ViewModel and returns that.\n\n```\nvar foo = canViewModel(element, \"foo\");\n\nconsole.log(foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "Any element in the DOM."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The property to get from the ViewModel.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property on the ViewModel or undefined if the property doesn't exist.\n"
        }
      },
      {
        "code": "canViewModel(element, property, value)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-util/js/types/types.DefaultMap] if it doesn't already exist. Sets the **property** on that map to **value**.\n\n```js\ncanViewModel(element, \"foo\", \"bar\");\n\nvar foo = canViewModel(element, \"foo\");\n\nconsole.log(foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "ANy element in the DOM."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The property that is being set on the ViewModel."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value being set on the property.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The element.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The element.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value being set on the property.\n"
    },
    "comment": " "
  },
  "can-view-target": {
    "src": {
      "path": "node_modules/can-view-target/can-view-target.md"
    },
    "body": "",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-target",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "target(nodes)",
        "description": "\n\nCreate a document fragment that can be cloned but have callbacks be\ncalled quickly on elements within the cloned fragment.\n\n```js\nvar viewTarget = require(\"can-view-target\");\n\nvar target = viewTarget([\n\t{\n\t\ttag: \"h1\",\n\t\tcallbacks: [function(data){\n\t\t\tthis.className = data.className\n\t\t}],\n\t\tchildren: [\n\t\t\t\"Hello \",\n\t\t\tfunction(){\n\t\t\t\tthis.nodeValue = data.message\n\t\t\t}\n\t\t]\n\t},\n]);\n\n// target.clone -> <h1>|Hello||</h1>\n// target.paths -> path: [0], callbacks: [], children: {paths: [1], callbacks:[function(){}]}\n\nvar frag = target.hydrate({className: \"title\", message: \"World\"});\n\nfrag //-> <h1 class='title'>Hello World</h1>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "nodes",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "nodes",
      "description": "\n"
    }
  },
  "cloneNode": {
    "name": "cloneNode",
    "type": "function",
    "parent": "node_modules/can-view-target/can-view-target.js",
    "src": {
      "line": 51,
      "codeLine": 62,
      "path": "node_modules/can-view-target/can-view-target.js"
    },
    "body": "\n",
    "description": "\nA custom cloneNode function to be used in browsers that properly support cloning\nof custom tags (IE8 for example). Fixes it by doing some manual cloning that\nuses innerHTML instead, which has been shimmed.\n",
    "title": "",
    "hide": true,
    "params": [
      {
        "types": [
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "frag",
        "description": "A document fragment to clone"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "frag",
      "description": "A document fragment to clone"
    },
    "returns": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "a new fragment that is a clone of the provided argument\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "a new fragment that is a clone of the provided argument\n"
    }
  },
  "can.view.Scope": {
    "name": "can.view.Scope",
    "type": "add",
    "description": "undefined\n"
  },
  "can.view.Scope.static": {
    "src": {
      "line": 33,
      "codeLine": 36,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "can.view.Scope.static",
    "parent": "can.view.Scope",
    "title": "static"
  },
  "can.view.Scope.prototype": {
    "src": {
      "line": 51,
      "codeLine": 54,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\n",
    "name": "can.view.Scope.prototype",
    "parent": "can.view.Scope",
    "title": "prototype"
  },
  "can.view.Scope.prototype.read": {
    "type": "function",
    "name": "can.view.Scope.prototype.read",
    "params": [
      {
        "types": [
          {
            "type": "can.stache.key"
          }
        ],
        "name": "attr",
        "description": "A dot seperated path.  Use `\".\"` if you have a property name that includes a dot."
      },
      {
        "types": [
          {
            "type": "can.view.Scope.readOptions"
          }
        ],
        "name": "options",
        "description": "that configure how this gets read."
      }
    ],
    "parent": "can.view.Scope.prototype",
    "src": {
      "line": 77,
      "codeLine": 87,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "body": "",
    "description": "",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "can.view.Scope.readOptions"
        }
      ],
      "name": "options",
      "description": "that configure how this gets read."
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "parent",
              "description": "the value's immediate parent",
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            },
            {
              "name": "rootObserve",
              "description": "the first observable to read from.",
              "types": [
                {
                  "type": "can.Map"
                },
                {
                  "type": "can.compute"
                }
              ]
            },
            {
              "name": "reads",
              "description": "An array of properties that can be used to read from the rootObserve to get the value.",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "String"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "value",
              "description": "the found value\n ",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "parent",
              "description": "the value's immediate parent",
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            },
            {
              "name": "rootObserve",
              "description": "the first observable to read from.",
              "types": [
                {
                  "type": "can.Map"
                },
                {
                  "type": "can.compute"
                }
              ]
            },
            {
              "name": "reads",
              "description": "An array of properties that can be used to read from the rootObserve to get the value.",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "String"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "value",
              "description": "the found value\n ",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    }
  },
  "roadmap": {
    "src": {
      "path": "docs/can-guides/commitment/Roadmap.md"
    },
    "body": "\nNow that 3.0 is out, we’re setting our sights on the\nfuture.  Help us get there by ranking issues and features\non bithub and fixing them!\n\n## Community\n\nThere’s more than code that goes into a library.  Checkout\nhow we’re working to improve CanJS's community:\n\n### Bithub.com\n\nWe are developing [bithub.com](http://bithub.com/canjs) to track\nall community content. Earn points that you\ncan trade for swag by posting apps, articles, events\nand plugins. __Rank bugs and features to let us and the\nrest of the community know where to focus.__\n\n### Meetups\n\nWe’ve started meetups across the US.  Bitovi provides\nmonthly training and workshop material.  Checkout\nmeetup for meetups and [bithub.com](http://bithub.com/canjs/events)\nfor other events.\n\n## DOM mutation observers\n\nWith CanJS 2.0, you can listen to \"inserted\" and \"removed\" events in\nevery browser.  We want to make it possible to listen to other DOM\nmutation events, making it easier to create custom elements\nthat feel completely native.\n\n## LazyMap and LazyList\n\nWe want our observable layer to handle anything you throw at\nit.  We’ve started work on a LazyMap and LazyList that\nexperiences almost no initialization penalty.  As you\nread nested objects, it converts them into LazyMaps and LazyLists.\n\nFurthermore, we want to setup bubbling only when it’s necessary and not\nby default. This will reduce the number of events, improving performance.\n\n## Component improvements\n\ncan.Component is designed to resemble web components.  As that\nspecification takes shape, we will make sure can.Component\nmakes use of it.  Future improvements:\n\n - A select attribute on `<content>`.\n - In-page custom elements.\n - Iterable `<content>` for lists.\n\n## Super Model\n\nWe want to create list-store that makes complex real-time apps\neasy to build. It will include a fall-through localStorage cache that\ndecreases page load times.\n\n## Dirty checking computes\n\nWant to use plain old objects in can.Component?  We’re looking to\ncreate a compute that checks its value periodically.  Hopefully\nthis becomes unnecessary as object mutation observers and\nproxies arrive in more browsers.\n\n## Deferreds and Computes\n\nEver had a compute that represents a deferred that represents an\nobservable list?  We have.  We want to make it easy to nest\ncomputes and deferreds like you can with Lists and Maps.\n\n",
    "description": "\n",
    "name": "roadmap",
    "title": "Roadmap",
    "type": "page",
    "parent": "guides/commitment",
    "order": 2,
    "comment": " "
  },
  "guides/contributing/bug-report": {
    "src": {
      "path": "docs/can-guides/contribute/bug-report.md"
    },
    "body": "\n## Overview\n\nCanJS uses [Github Issues](https://github.com/canjs/canjs/issues/new) to track bugs. However,\nCanJS is made up of many individual github repositories. Ideally, bugs are created within the\nrepository whose code is causing the issue.  For example, issues with\n[can-define] can be created at [canjs/can-define/issues/new](https://github.com/canjs/can-define/issues/new).\n\nIf you do not know which repository your issue belongs to, that's totally ok!  Please\ncreate your issue in the main\n[canjs/canjs issues page](https://github.com/canjs/canjs/issues/new).  The core team will\nmove the issue to the correct repository if necessary.\n\nWhen creating an issue, it's very helpful to include:\n\n - Small examples using tools like JSBin. You can clone the following [CanJS bin](http://jsbin.com/ziyiqe/2/edit?html,js,output) that includes everything in CanJS. Make\n   sure it's pointing at the same version of CanJS you are using.  \n - Breaking unit tests (optional). See [guides/contributing/code].\n - Proposed fix solutions (optional)\n\nAlso, please search for previous tickets.  If there's something similar, add to that, or\ngive it a `+1`.\n\nFinally, if there are any questions, reach out to\nus on the [CanJS forums](http://forums.donejs.com/c/canjs) or talk to us on\nthe [Gitter canjs/canjs channel](https://gitter.im/canjs/canjs).\n\n## Priority, Tags, and Complexity\n\nThe [core team](https://donejs.com/About.html#section=section_Team) reviews issues\nand assigns them a `P0` to `P4` tag corresponding to the following priorities:\n\n- `P0` - An issue that will preempt any other issues currently being worked on.\n- `P1` - A critical feature or bug that needs to be fixed to keep CanJS's high degree of quality.\n- `P2` - A feature or bug that is less likely to be encountered, but something we intend to get to.\n- `P3` - A nice to have. The OS team might get to it, but it's helpful if the community assists.\n- `P4` - A nice to have that the OS team will accept, but will be unlikely to prioritize any effort towards.\n\nThere are several ways to influence these priorities:\n\n - Offer to pair with a contributor on a solution.\n - Write a good test.\n - Come to a DoneJS Contributors meeting and make your case.\n - Get others from other organizations to `+1` the issue.\n - Make your case on gitter with a contributor or in the issue.\n - You can always hire [Bitovi](http://bitovi.com) or a contributor to make the change.\n\n\nAlso, the core team will often include a complexity indicator in the title that looks like\n`~NUMBER`.  This is a fibonacci number.  `~1` means its an extremely simple task.  `~8` is about\na half day task.  `~34` might take a week of experimentation.\n\n",
    "description": "Learn how to submit a bug report. \n",
    "name": "guides/contributing/bug-report",
    "title": "Bug Report",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "migrate-3": {
    "src": {
      "path": "docs/can-guides/commitment/migrating_to_3.0.md"
    },
    "body": "\nCanJS 3.0 introduces a new even more modular project structure and several new features, while having a minimal number of deprecations or removals to the existing 2.3 API.\n\nThis guide goes over:\n\n* How to install CanJS 3.0 and how that differs from in the past.\n* The *minimal migration path*. The steps that are required in order to upgrade from 2.x to 3.0 with the fewest number of code changes.\n* A second migration path with more modern conventions (such as the use of NPM packages).\n* The future proof path using all of the modern libraries we are most excited about (such as [can-define]).\n\n## Getting CanJS 3.0\n\nThe recommended way to install CanJS 3.0 is through [npm](https://www.npmjs.com/). If you are already using the [can package](https://www.npmjs.com/package/can) you can continue to do so, but we recommend installing the specific dependencies that you need.\n\n### Using can\n\nIf you haven't installed CanJS through npm in the past please skip to the next section and install the can-* packages.\n\nIf you are already using `can` through npm just change the version in your `package.json` to 3.0:\n\n```js\n{\n  ...\n  \"dependencies\": {\n    \"can\": \"^3.0.0\"\n  }\n}\n```\n\nUsing the *^* ensures you get minor and patch releases as those are released.\n\n### Using can-*\n\nBetter than installing the `can` package is to install just the packages that you are using in your application. For example, if you are using [can-component] you can install it with:\n\n```js\nnpm install can-component --save\n```\n\nA full list of the available packages are shown the [homepage](http://canjs.github.io/canjs/).\n\n## Minimal migration path\n\nAt minimum, to upgrade to 3.0, you must make all of the below changes to your code:\n\n### Use can/legacy\n\nIn your code where you normally would import `can`, instead import `can/legacy`:\n\n```js\nvar can = require(\"can/legacy\");\n```\n\nThis will give you a `can` object with *most* of the same APIs as in 2.3 with the exception of:\n\n* [can-mustache] is not included with can/legacy but can still be installed as a separate package.\n* The former `can.view` functionality no longer exists, see below.\n\n### Set leakScope on Components\n\nIn CanJS 2.2 we introduced [can-component.prototype.leakScope leakScope: false] as a property on a [can-component]. This prevents values in parent templates from leaking into your Component's template. In 3.0 **leakScope** is now false by default.\n\nIf you have a [can-component.prototype.template] like:\n\n```\n<some-component></some-component>\n```\n\nThat you render with a [can-map map] containing a `page` property like so:\n\n```js\nrender(new Map({\n\tpage: \"home\"\n}));\n```\n\nThis `page` property is not available within some-component's own template.\n\nIf the component's template looks like:\n\n```\n<h1>Hello {{page}}</h1>\n```\n\nIt can only look-up the `page` property on some-component's own [can-component.prototype.ViewModel]. To restore the behavior in 2.x, simply set [can-component.prototype.leakScope] to be `true` on the Component:\n\n```js\nComponent.extend({\n\ttag: \"some-component\",\n\tViewModel: ...,\n\n\tleakScope: true\n});\n```\n\n### Asynchronous inserted/removed events\n\nIn your [can-component]s, the [can-util/dom/events/inserted/inserted inserted] and [can-util/dom/events/removed/removed] events were previously fired synchronously as the element was inserted into the DOM. To improve performance these events are now fired async.\n\nThere is now a [can-component/beforeremove] event that fires synchronously in case you need to perform memory cleanup. For example you might need to access the parent's viewModel:\n\n```js\nComponent.extend({\n\ttag: \"my-panel\",\n\n\tevents: {\n\t\t\"beforeremove\": function(){\n\t\t\tcanViewModel(this.element.parentNode).removePanel(this.viewModel);\n\t\t}\n\t}\n}\n```\n\n### can.view is no more\n\nThe `can.view` methods have been removed in 3.0. The most common use was to create a template renderer from a script element with the page. Instead of:\n\n```js\nvar render = can.view('some-id');\n```\n\nJust use the DOM APIs and pass the string directly into [can-stache]:\n\n```js\nvar templateString = document.getElementById('some-id').innerHTML;\nvar render = stache(templateString);\n```\n\nIf you were using `can.view.preload` then use [can-stache.registerPartial] instead.\n\n```js\nstache.registerPartial(\"some-id\", renderer);\n```\n\n### Promises are needed\n\nNative [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) are used instead of jQuery promises which means you need to:\n\n* Include a Promise polyfill if targeting browsers that do not have native support. [Steal](http://stealjs.com/) includes a polyfill for you.\n* Instead of `.fail()` use `.catch()`.\n* Instead of `.done()` use `.then()`.\n* Only a single a value is returned from a native Promise.\n\n### Passing the \"this\" value within each helper\n\nWhen passing the `this` value to a [can-stache.Helpers helper] like:\n\n```\n{{helper .}}\n```\n\nin [can-stache] this now passes a [can-compute] to the helper.\n\nYou can fix this either by having your helpers handle computes, or using [can-stache/expressions/call call expressions] instead:\n\n```\n{{helper(.)}}\n```\n\n### No more global scope names\n\nMost recently-built applications do not depend on adding to the global namespace, but in case you have code that does:\n\n```js\nConstruct.extend(\"foo.bar\", ...)\n```\n\nWhich sets `window.foo.bar`, this argument is no longer accepted by [can-construct]. If you *really* need to set a global you can do so yourself using the return value of [can-construct.extend].\n\nInstead the first argument to [can-construct.extend] is the name of the constructor function. This is nice for development as you'll get named objects in your dev tools.\n\n## Modernized migration path\n\nIn addition to the above, to set your project up to more easily be able to upgrade in the future you can take the following measures:\n\n### Use can-* packages\n\nAs mentioned earlier in the guide, CanJS 3.0 is divided into separate npm packages. This allows us to more quickly updating parts of CanJS without affecting other functionality. You can take advantage of this by installing the individual can-* packages and using them directly.\n\nYou might be using [can-component] like either:\n\n```js\nvar can = require(\"can\");\n\ncan.Component.extend({ ... });\n```\n\nor\n\n```js\nvar Component = require(\"can/component/component\");\n\nComponent.extend({ ... });\n```\n\nWhich you are using, update your code to instead look like:\n\n```js\nvar Component = require(\"can-component\");\n\nComponent.extend({ ... });\n```\n\nUse the same pattern for the other can modules you are using. In general you should not be using the `can.` properties any more, but rather importing (through your module loader / bundler) only the packages and modules that you are using.\n\n### Wrap elements in jQuery objects\n\nIf you are using [can-jquery/legacy] to get automatically jQuery-wrapped elements in [can-control] event handlers, you'll want to remove the usage of [can-jquery/legacy] as it doesn't play well with [can-component]s that do not expect elements to be jQuery-wrapped.\n\nInstead use [can-jquery] directly and handle the wrapping yourself. For example:\n\n```js\nvar Component = require(\"can-component\");\nvar $ = require(\"can-jquery\");\n\nComponent.extend({\n  tag: \"some-component\",\n\n\tevents: {\n\t\tinserted: function(){\n\t\t\tthis.element = $(this.element);\n\t\t},\n\t\t\"li click\": function(li){\n\t\t\tvar $li = $(li);\n\t\t}\n\t}\n});\n```\n\n[can-jquery] will continue to be supported indefinitely but [can-jquery/legacy] will be dropped in a future major version.\n\n### Remove use of \"change\" events\n\nWhen you upgrade to use [can-define] you'll no longer receive \"change\" events on maps. If you had any code that binded on a map's \"change\" event, you'll want to instead bind to the properties that you are interested in. For example:\n\n```js\nroute.bind(\"change\", function(){\n  // The route changed\n});\n```\n\nCan be modified to instead use a compute that calls `serialize` on the route's map:\n\n```js\nvar routeMap = compute(function(){\n\treturn route.map.serialize();\n});\n\nrouteMap.bind(\"change\", function(){\n\tA property on the route's map changed.\n});\n```\n\nAs you might notice, we are also favoring using [can-event.on on()] rather than `bind()` now (although bind() still work the same).\n\n## Future-proof migration path\n\nIn addition to the steps taken in the two above section, if you *really* want to stay ahead of the curve, make the following changes to your application:\n\n### can-define replaces can-map\n\nIf you've used [can-map-define] in the past then using [can-define] should be familiar to you. Using [can-define/map/map] is the easiest migration path and is what we show in all of the examples in CanJS 3.0's docs.\n\nA typical map looks like:\n\n```js\nvar Map = require(\"can-map\");\nrequire(\"can-map-define\");\n\nvar CarOwner = Map.extend({\n\tdefine: {\n\t\tcars: {\n\t\t\tType: Car.List\n\t\t},\n\t\tfavorite: {\n\t\t\tType: Car\n\t\t},\n\t\tcolor: {\n\t\t\ttype: \"string\"\n\t\t},\n\t\tage: {\n\t\t\tvalue: 18\n\t\t}\n\t}\n});\n```\n\nWhich can be replaced by flattening it into a [can-define/map/map] like so:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar CarOwner = DefineMap.extend({\n\tcars: CarList,\n\tfavorite: Car,\n\tcolor: \"string\",\n\tage: {\n\t\ttype: \"number\",\n\t\tvalue: 18\n\t}\n});\n```\n\nUsing [can-define] allows you to use maps without the [can-map.prototype.attr .attr()] method that's needed in [can-map] and [can-list]. To use this with DefineMap just use the dot operator instead:\n\n```js\nvar carOwner = new CarOwner();\n\n// This is observable!\ncarOwner.favorite = new Car({ type: \"Toyota\" });\n```\n\n### Use can-connect directly\n\nWhen using the easy migration path you were secretly using [can-connect/can/model/model], a constructor that is mostly backwards compatible with [can-model].\n\nMost new projects should use can-connect directly, and [can-connect/can/super-map/super-map] is the easiest way to create models with connect's features. Using can-connect directly allows you to use [can-define/map/map]s as your models like so:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\nvar superMap = require(\"can-connect/can/super-map/super-map\");\n\nvar Message = DefineMap.extend({\n  id: \"*\"\n});\n\nMessage.List = DefineList.extend({\n  \"#\": Message\n});\n\nvar messageConnection = superMap({\n  url: 'http://chat.donejs.com/api/messages',\n  idProp: 'id',\n  Map: Message,\n  List: Message.List,\n  name: 'message'\n});\n```\n\n### Update use of binding syntax\n\nIn 2.3 we introduced new binding syntaxes. In 3.0 there are available with [can-stache-bindings]. Although the old binding syntaxes still work, they will likely be dropped in 4.0. View can-stache-binding's documentation to learn how to use the new bindings.\n\nAn example is changing a can-value binding from:\n\n```\n<input type=\"text\" can-value=\"{someProp}\" />\n```\n\nTo:\n\n```\n<input type=\"text\" {($value})=\"someProp\" />\n```\n\n3.0 also introduces new [can-stache.registerConverter stache converters] which are a special type of [can-stache.Helpers helper] that works two-way to update an element when an observable value changes, and also update the observable value when the form element's value changes (from user input).\n\nAn example is the [can-stache-bindings.converters.string-to-any] converter which converts a primitive value to a string to set a `<select>`'s value, and then converts the `<select>` value when a user selects an `<option>` back to the primitive value to update the scope value:\n\n```\n<select {($value)}=\"string-to-any(~favePlayer)\">\n  <option value=\"23\">Michael Jordan</option>\n  <option value=\"32\">Magic Johnson</option>\n</select>\n```\n\n",
    "description": "\n",
    "name": "migrate-3",
    "title": "Migrating to 3.0",
    "type": "page",
    "parent": "guides/commitment",
    "order": 2,
    "comment": " "
  },
  "guides/contributing/code": {
    "src": {
      "path": "docs/can-guides/contribute/code.md"
    },
    "body": "\n## Overview\n\nContributing to any Open Source project can be intimidating.  All contributions from all types of contributors are welcome.  We're\ncommitted to making the experience is pleasant and rewarding as possible.  We're happy to setup a\npairing session to show you how to fix a bug or write a feature.  \n\nIf you have any questions, you can always reach us on [Gitter chat](https://gitter.im/canjs/canjs).\n\n- lots of different repos, but they are mostly similar.\n\n## Getting the code and verify its working\n\nMake sure you have NodeJS greater or equal to version 5 installed.\n\n1. Fork the repo you are working from.\n2. Clone the individual repo:\n\n   ```\n   > git clone git@github.com:<your username>/can-compute.git\n   ```\n\n3. Install dependencies:\n\n   ```\n   > npm install\n   ```\n\n4. Run tests\n\n   ```\n   > npm test\n   ```\n\n## Structure\n\nEvery CanJS repository is slightly different, but they work the same way.\n\n - Identify main module\n - Identify tests\n\n\n##  Make your changes\n\n1. Create a new feature branch - `git checkout -b html5-fix`\n2. Make some changes.\n3. Update tests to accommodate your changes.\n4. Run tests `npm test` and make sure they pass in all browsers.\n5. Update documentation if necessary.\n6. Push your changes to your remote branch - `git push origin html5-fix`\n7. Submit a pull request! Navigate to Pull Requests and click the 'New Pull Request' button. Fill in some\n   details about your potential patch including a meaningful title. When finished, press \"Send pull request\". The core team will be notified about your submission and let you know of any problems or targeted release date.\n\n\n## Publishing a new version\n\n1. Check integration.\n2. `npm run release:pre` (this will be patch after 3.0.0).\n\n",
    "description": "Learn how contribute a code change to CanJS. \n",
    "name": "guides/contributing/code",
    "title": "Code",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/documentation": {
    "src": {
      "path": "docs/can-guides/contribute/documentation.md"
    },
    "body": "\n## Overview\n\nThe CanJS site is generated with [bit-docs](https://github.com/bit-docs/bit-docs),\na modified version of [DocumentJS](http://documentjs.com).  It's\ncontent is hosted using Github pages publishing the [canjs/canjs#gh-pages](https://github.com/canjs/canjs/tree/gh-pages) repo.\n\n`bit-docs` reads JavaScript comments and markdown files within the `canjs` repo as well as\nthe individual repositories within `node_modules` to produce a static site.\n\nThe high level content (Ex: homepage) and the guides content for the site is within the\n`canjs/docs` folder.  Individual repositories contain their own markdown and commented\nJavaScript files used to produce their API pages.\n\n## Generate the documentation locally\n\nTo generate the CanJS site:\n\n1. Clone [https://github.com/canjs/canjs](canjs/canjs)\n\n   ```\n   > git clone git@github.com:canjs/canjs\n   ```\n\n2. Install dependencies:\n\n   ```\n   > npm install\n   ```\n\n3. Run `bit-docs`:\n\n   ```\n   > ./node_modules/.bin/bit-docs -d\n   ```\n\nThis should produce a static site in your `canjs` folder.  Open `canjs/index.html`\nand you should see the site.  You might want to use `http-server` to start\na simple static file server.\n\n## Improve the theme's design and styles\n\nThe CanJS theme is in\n[bit-docs-html-canjs](https://github.com/canjs/bit-docs-html-canjs). It's\n[readme](https://github.com/canjs/bit-docs-html-canjs/blob/master/readme.md)\nhas instructions on how to test out the theme.  Once the theme is updated and published,\n\n1. Open canjs/package.json. Update \"bit-docs-html-canjs\"'s version to the new theme version.\n2. Run `./node_module/.bin/bit-docs -df` to make sure the theme is correctly applied.\n\n## Test out content from other repos\n\nAs noted above, the API docs from each package come from that package.  So if you're\nimproving the docs for say `can-compute`, you want to see what `can-compute`'s docs look like,\ninstall your local `can-compute` and re-run bit-docs like:\n\n```\n> npm install ../can-compute && ./node_module/.bin/bit-docs -d\n```\n\n\n## Publish the documentation\n\nOnce the docs look right locally, commit your changes, then run:\n\n```\n> make\n```\n\nThe make script will generate the documentation again and push out the `gh-pages` branch.\n\n\n## Writing API documentation\n\nOur documentation is modelled off of jQuery's.  Please read\ntheir [guidelines](https://github.com/jquery/api.jquery.com/blob/master/README.md).\n\nGenerally speaking there are three parts to every documentation page:\n\n - Its description\n - Its signatures\n - The body (typically \"Use\" section)\n\n### Description\n\nThe description section should be a one or two sentence explanation of what this\npiece of documentation does from a _user_ centric view.  Descriptions are a quick summary\nof the __why__ and the __what__. It should take on an\nactive voice.  For example, [can-component]'s description:\n\n> Create a custom element that can be used to manage widgets or application logic.\n\nNotice that it uses \"Create\" not \"Creates\".\n\n### Signatures\n\nSignatures are the __what__ and the __how__.  They should include all or most of the following:\n\n - __What the signature does__, if different from the description, especially if there are\n   multiple signatures.\n - High level details on __how the code works__.\n - A simple example showing __how to use the code__.\n\n[can-compute]'s first signature is a good example of this. First, it explains\n__what that signature does__:\n\n> Create a compute that derives its value from other observables.\n\nThen it briefly explains __how the code works__:\n\n> Uses can-observation to call the getterSetter and track observables.\n\nFinally, it provides minimal sample code:\n\n```js\nvar age = compute(32);\n\nvar nameAndAge = compute(function(){\n    return \"Matthew - \" + age();\n});\n\nnameAndAge() // -> \"Matthew - 32\"\n\nage(33);\n\nnameAndAge() // -> \"Matthew - 33\"\n```\n\nNot all signatures need to hit all three points.  For example [can-event/batch/batch]'s\nsignature simply adds a bit more depth to the purpose of [can-event/batch/batch]\nand then details __how the code works__.  __How to use the code__ is\nleft for the `body` section as importing the module is not necessary to show.\n\nMake sure to fully document the a signature's parameters and return\nvalue.  There's a lot of flexibility in documenting the [type expression](http://documentjs.com/docs/documentjs.typeExpression.html) of\na return value or parameters and the [name expression](http://documentjs.com/docs/documentjs.nameExpression.html) of\nparameters.\n\nSignature titles should follow jQuery's conventions:\n\n - Static methods like: `TypeAlias.method()`\n - Prototype methods like: `typeAlias.method()`\n - Spaces in between arguments: `typeAlias.method( arg1, arg2 )`\n - Brackets around optional args: `typeAlias.method( arg1 [, arg2 ], arg3 )` or\n   `typeAlias.method( arg1 [, arg2 ][, arg3 ] )`\n\n\n### body\n\nMost body sections start with an `## Use`.  They should be a mini guide on\nhow to use that piece of code.  Modules should have long bodies that span\nmultiple topics.  For example [can-component]'s body has examples and\ninformation about nearly all of its sub-functions.  However\n[can-component.prototype.tag can-component.prototype.tag] doesn't have a\nuse section because it's covered in [can-component].\n\n",
    "description": "Learn how to improve CanJS's site and documentation. \n",
    "name": "guides/contributing/documentation",
    "title": "Documentation",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/feature-suggestion": {
    "src": {
      "path": "docs/can-guides/contribute/feature-suggestion.md"
    },
    "body": "\n## Overview\n\nCanJS uses [Github Issues](https://github.com/canjs/canjs/issues/new) to track feature requests. However,\nCanJS is made up of many individual github repositories. Ideally, features are created within the\nrepository whose code needs to be modified.  For example, features with\n[can-define] can be created at [canjs/can-define/issues/new](https://github.com/canjs/can-define/issues/new).\n\nIf you do not know which repository your feature belongs to, that's totally ok!  Please\ncreate your issue in the main\n[canjs/canjs issues page](https://github.com/canjs/canjs/issues/new).  The core team will\nmove the issue to the correct repository if necessary.\n\nWhen creating an feature issue, it's very helpful to include:\n\n - Examples of what using the feature will look like.\n - Benefits and drawbacks of the feature.\n - Why the feature is important.\n - Any implementation details around the feature.\n\nHere's some example well written feature requests:\n\n - [Make events fire asynchronously and dispatched during request animation frame or setImmediate](https://github.com/canjs/can-event/issues/11)\n - [Modify key -> argument behavior in stache](https://github.com/canjs/canjs/issues/1699)\n\nAlso, please search for previous feature requests.  If there's something similar, add to that, or\ngive it a `+1`.\n\nFinally, if there are any questions, reach out to\nus on the [CanJS forums](http://forums.donejs.com/c/canjs) or talk to us on\nthe [Gitter canjs/canjs channel](https://gitter.im/canjs/canjs).\n\n## Priority, Tags, and Complexity\n\nThe [core team](https://donejs.com/About.html#section=section_Team) reviews issues\nand assigns them a `P0` to `P4` tag corresponding to the following priorities:\n\n- `P0` - An issue that will preempt any other issues currently being worked on.\n- `P1` - A critical feature or bug that needs to be fixed to keep CanJS's high degree of quality.\n- `P2` - A feature or bug that is less likely to be encountered, but something we intend to get to.\n- `P3` - A nice to have. The OS team might get to it, but it's helpful if the community assists.\n- `P4` - A nice to have that the OS team will accept, but will be unlikely to prioritize any effort towards.\n\nThere are several ways to influence these priorities:\n\n - Offer to pair with a contributor on a solution.\n - Write a good test.\n - Come to a DoneJS Contributors meeting and make your case.\n - Get others from other organizations to `+1` the issue.\n - Make your case on gitter with a contributor or in the issue.\n - You can always hire [Bitovi](http://bitovi.com) or a contributor to make the change.\n\n\nAlso, the core team will often include a complexity indicator in the title that looks like\n`~NUMBER`.  This is a fibonacci number.  `~1` means its an extremely simple task.  `~8` is about\na half day task.  `~34` might take a week of experimentation.\n\n",
    "description": "Learn how to suggest a feature. \n",
    "name": "guides/contributing/feature-suggestion",
    "title": "Feature Suggestion",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/evangelism": {
    "src": {
      "path": "docs/can-guides/contribute/evangelism.md"
    },
    "body": "\n## Overview\n\nHopefully you love CanJS as much as we do and you want to share your\nknowledge about it.  Fantastic!  We can help you.\n\nThere's lots of ways to spread the word about CanJS such as:\n\n - Giving a presentation at a conference or meetup\n - Organizing or speaking at a CanJS or DoneJS meetup\n - Writing a blog article\n\nWhatever you do, please let us know so we can promote you and what you're doing.\n\n## Giving a presentation\n\nThe [Presentations Google Drive Folder](https://drive.google.com/drive/u/1/folders/0Bx-kNqf-wxZeaWc2ay1ZSzZZQXc)\ncontains all of the DoneJS teams talks organized by project.  It contains\na CanJS folder with CanJS presentations.  \n\nSome of the presentations are out dated, but it's a good place to check for\nexisting content.\n\n\n## Meetups\n\nThere are several DoneJS meetups already created:\n\n - [Chicago](http://www.meetup.com/DoneJS-Chicago/)\n - [Silicon Valley](http://www.meetup.com/DoneJS-Silicon-Valley/)\n - [Boston](http://www.meetup.com/DoneJS-Boston/)\n - [Ft. Lauderdale](http://www.meetup.com/DoneJS-Fort-Lauderdale/)\n - [Los Angeles](http://www.meetup.com/DoneJS-LA/)\n - [New York](http://www.meetup.com/DoneJS-NYC/)\n - [Phoenix](http://www.meetup.com/DoneJS-Phoenix/)\n - [Raleigh-Durham](http://www.meetup.com/DoneJS-raleigh-durham/)\n - [San Francisco](http://www.meetup.com/DoneJS-San-Francisco/)\n - [Seattle](http://www.meetup.com/DoneJS-Seattle/)\n\nWe're always looking for people to speak at one of these meetups, become an organizer,\nor start their own meetup.  If you are interested in any of these things,\nplease let Justin Meyer know (`justin@bitovi.com`).\n\n\n## Writing a blog article\n\nIf you're writing something about CanJS and would like us to review it,\nwe're happy to help.  Once it's published, let us know so we can promote it.  \n\n",
    "description": "Learn about resources that can help you spread the word about CanJS. \n",
    "name": "guides/contributing/evangelism",
    "title": "Evangelism",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/setup": {
    "src": {
      "path": "docs/can-guides/experiment/setting-up-canjs.md"
    },
    "body": "\nCanJS can be downloaded or installed in many ways:\n\n - npm\n - the zip download (on the homepage)\n - the download builder (on the homepage)\n - loaded from our cdn\n - bower\n\nOnce downloaded or installed, CanJS can be loaded in a variety of ways:\n\n - StealJS,\n - RequireJS\n - Browserify\n - `<script>` tags\n\nThe following lists how to setup common combinations.  If you don't see yours, please\nask on the [forums](http://forums.donejs.com/c/canjs) or [gitter chat](https://gitter.im/canjs/canjs).\n\n## JSBins\n\nNot yet committed to CanJS? Or just want to play around? Use one of these JSBins:\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/venaje/embed?html,js,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.5\"></script>\n\n  - [jQuery](http://justinbmeyer.jsbin.com/venaje/edit?html,js,output)\n  - [Zepto](http://justinbmeyer.jsbin.com/veqola/edit?html,js,output)\n\n## CDN\n\nAnother quick way to start locally is by loading scripts from our CDN:\n\n    <html>\n    <head>\n        <title>CanJS Test</title>\n    </head>\n    <body>\n        <script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.js\"></script>\n        <script src=\"http://canjs.com/release/latest/can.jquery.js\"></script>\n        <script src=\"http://canjs.com/release/latest/can.map.define.js\"></script>\n        <script src=\"http://canjs.com/release/latest/can.stache.js\"></script>\n        <script type='text/stache' id='app'>\n        \t<hello-world/>\n        </script>\n\n        <script type=\"text/javascript\">\n            can.Component.extend({\n            \ttag: 'hello-world',\n            \ttemplate: can.stache(\"<h1>{{message}}</h1>\"),\n            \tviewModel: {\n            \t\tmessage: \"Hi there!\"\n            \t}\n            });\n            $(\"body\").append(can.view(\"app\",{}));\n        </script>\n    </body>\n    </html>\n\nThis loads CanJS's core and its two most common plugins [define](../docs/can.Map.prototype.define.html)\nand [stache](../docs/can.stache.html).  Checkout the [release folder](https://github.com/bitovi/canjs.com/tree/gh-pages/release/latest)\nfor the list of other plugins you can add.\n\nIf you want to use Zepto instead of jQuery, load Zepto instead of jQuery and `can.zepto.js` instead of `can.jquery.js` like:\n\n    <script src=\"http://zeptojs.com/zepto.js\"></script>\n    <script src=\"http://canjs.com/release/latest/can.zepto.js\"></script>\n\nA list of all available CDN releases and files can be found [here](https://github.com/canjs/canjs.com/tree/gh-pages/release).\n\n__Note:__ We highly recommend to always reference a specific version and never `latest` directly in a production environment.\nLatest can contain backwards incompatible releases __and will break your application__.\n\n## StealJS and NPM\n\nIf you are installing CanJS from npm and using StealJS, you should\ncheckout [DoneJS](http://donejs.com).  It has comprehensive guides on using\nStealJS and CanJS together.\n\nTo use StealJS and CanJS outside DoneJS, install the [can](https://www.npmjs.com/package/can), [steal](https://www.npmjs.com/package/steal) and `jquery` packages:\n\n```\n> npm install can --save\n> npm install steal --save\n> npm install jquery --save\n```\n\nNext, create a `main.stache` template for your app:\n\n```\n<!-- main.stache -->\n<h1>{{message}}</h1>\n```\n\nNext, create a `main` module for your application. Import CanJS's core,\njQuery, and your template to say \"Hello World\":\n\n```\n// main.js\nimport can from \"can\";\nimport $ from \"jquery\";\nimport template from \"./main.stache!\";\n\nvar data = new can.Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nFinally, create a page that loads `steal.js` and specifies `\"main\"` as the main module:\n\n```\n<html>\n  <body>\n    <script src=\"./node_modules/steal/steal.js\" data-main=\"main\"></script>\n  </body>\n</html>\n```\n\nIt's better if you import just what you need.  Instead of loading all of CanJS's core,\nwe can load just `\"can/map/map\"` like:\n\n```\n// main.js\nimport Map from \"can/map/map\";\nimport $ from \"jquery\";\nimport template from \"./main.stache!\";\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nStealJS supports \"modlet\" module names that end with \"/\".  This means that the above could\nalso be written like:\n\n```\n// main.js\nimport Map from \"can/map/\";\nimport $ from \"jquery\";\nimport template from \"./main.stache!\";\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nBesides ES6 modules, StealJS supports AMD, and CommonJS.  You could also write `main.js` like:\n\n```\n// main.js\nvar Map = require(\"can/map/\");\nvar $ = require(\"jquery\");\nvar template = require(\"./main.stache!\");\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\n### Building to production\n\nIf you are using StealJS and CanJS outside of DoneJS, [this guide](http://blog.bitovi.com/using-canjs-2-2-with-stealjs/)\nwalks through getting a production build.\n\n## Browserify and NPM\n\nThe [can npm package](https://www.npmjs.com/package/can) works with browserify. After installing `can`:\n\n```\n> npm install can --save\n```\n\nRequire the core `can` modules like:\n\n```\nvar can = require(\"can\");\n```\n\nYou can also `require` specific modules:\n\n```\nvar Component = require(\"can/component/component\");\nComponent.extend({ ... });\n```\n\nNote that nearly all module names repeat the folder name (ex: `can/view/stache/stache`).\n\n### Requiring templates\n\nYou can require any CanJS templates using the [can-compilify](https://www.npmjs.com/package/can-compilify) Browserify\ntransform. Complete instructions for installing and using the transform are available on [npm](https://www.npmjs.com/package/can-compilify).\n\nInstall can-compilify:\n\n```\n> npm install can --save\n```\n\nRequire a template in your code:\n\n```\n// app.js\nvar Map = require(\"can/map/\");\nvar $ = require(\"jquery\");\nvar template = require(\"./main.stache\");\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nAnd include the can-compilify transform from the command line:\n\n```\n> browserify -t can-compilify app.js > app.bundle.js\n```\n\nYou could also add can-compilify to your package.json.\n\n### Building templates to production\n\nUsing the can-compilify tranform, your production bundle(s) will include a compiled version of your\ntemplates so no extra setup is required.\n\n## RequireJS from NPM, the Download or Bower\n\nThe Zip Download (on the [homepage](http://canjs.com)) contains the following\nAMD formatted scripts that can be loaded with RequireJS.\n\n- `amd/` - CanJS provided as AMD modules\n- `amd-dev/` - CanJS AMD modules with development messages\n\nThese files are also available in the [can NPM package](npmjs.com/package/can)'s `dist` folder.  Install\nthe `can` package like:\n\n```\n> npm install can --save\n```\n\nYou'll find these files in `node_modules/can/dist`.\n\nThese files are also available in the `canjs` bower package.  Install `canjs` like:\n\n> bower install canjs --save\n\nYou'll find these files in `bower_components/can/dist`.\n\nThe following section contains quick how to load CanJS with RequireJS for different libraries.\n\n### jQuery\n\nIn RequireJS a simple configuration looks like this:\n\n    <script type=\"text/javascript\" src=\"require.js\"></script>\n    <script type=\"text/javascript\">\n      require.config({\n        paths : {\n          \"jquery\" : \"http://code.jquery.com/jquery-2.0.3\",\n          \"can\": \"path/to/can/amd\"\n        }\n      });\n\n      require(['can/control', 'can/view/stache'], function(Control, stache) {\n        // Use Stache and Control\n        var MyControl = Control.extend({\n          init: function() {\n            this.element.html(can.view('path/to/view.stache', this.options));\n          }\n        });\n      });\n    </script>\n\nThe `can` module is a shortcut that loads CanJS's core plugins and returns the `can` namespace:\n\n    require(['can'], function(can) {\n      // Use can.Component, can.view etc.\n    });\n\n### Building templates to production\n\nBundling templates with the rest of your JavaScript can dramatically reduce the number of requests.  \n\nUse the [can-compile](https://github.com/canjs/can-compile#loading-with-requirejs) project\nto build templates into an AMD module that can be used by `r.js` to build the app.\n\n\n## Script tags from NPM, the Download, or Bower\n\nThe Zip Download (on the [homepage](http://canjs.com)) contains the following\n\"global\" scripts that can be loaded with just a `<script>` tag.\n\n- `can.<library>.js` (e.g. `can.jquery.js`) - The core build for a supported library\n- `can.<library>.dev.js` - A development build logging useful messages for a supported library\n- `can.<library>.min.js` - The minified core build for a supported library\n- `can.<type>.<plugin>` - Individual builds for each official CanJS plugin\n\n\nThese are also available in the [can NPM package](npmjs.com/package/can)'s `dist` folder.  Install\nthe `can` package like:\n\n```\n> npm install can --save\n```\n\nYou'll find these files in `node_modules/can/dist`.\n\nThese files are also available in the `canjs` bower package.  Install `canjs` like:\n\n> bower install canjs --save\n\nYou'll find these files in `bower_components/can/dist`.\n\nThe following section contains quick how to load CanJS with a `<script>` tag using\nthese files for each library it supports.\n\n### jQuery\n\nCanJS supports jQuery in the latest 1.X and 2.X version. Include jQuery before your CanJS jQuery build to get started:\n\n    <script src=\"//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js\">\n    </script>\n    <script src=\"can.jquery.js\"></script>\n    <script>\n      $(function() {\n        // start using CanJS\n        var Todo = can.Map.extend({\n          ...\n        });\n      });\n    </script>\n\n### Building templates to production\n\nCanJS can pre-compile [Stache](/docs/can.stache.html) views into JavaScript functions contained within a single file in order to avoid\nadditional requests for view files in production. When using\nCanJS standalone use the [can-compile](https://github.com/daffl/can-compile) Node module. Install with\n\n```\n> npm install can-compile -g\n```\n\nAnd in your project root folder run:\n\n```\n> can-compile --out views.production.js\n```\n\nThis will create `views.production.js` in the current folder containing all pre-compiled views. When loaded into your page CanJS will use the per-compiled views instead of making an Ajax request to retrieve them.\n\n\n## Script tags with the download builder\n\nThe download builder on the homepage lets you customize what modules are included in a global\nscript.  After downloading that script, the use of that script is just like [loading CanJS with script tag using the zip download](#section_ScripttagsfromNPM_theDownload_orBower).\n\n",
    "description": "CanJS is packaged in multiple ways so that it can fit into any development workflow. Learn how to setup CanJS in different environments. \n",
    "name": "guides/setup",
    "title": "Setting up CanJS",
    "type": "page",
    "parent": "guides/experiment",
    "order": 5,
    "outline": "2",
    "comment": " "
  },
  "guides/technical": {
    "src": {
      "path": "docs/can-guides/introduction/technical.md"
    },
    "body": "\n- IE9 Support\n- Independent projects / pieces\n- Small size for what you get\n\n- MVVM\n  - state exists somewhere ...\n  - Pagination example (federated state)\n  - ATM example (federated state)\n  - Testable\n\n- Observables\n  - Object oriented and functional\n  - Batched events ... minimal data and DOM updates.\n  - No having to list dependencies.\n  - \"compiled\" property behavior ... so fast.\n  - nice syntax for a lot of expressiveness - get, set, initial value, type conversion.\n\n- View Models\n  - all the benefits of observables and MVVM.\n\n- Views\n  - Handlebars\n  - One, two-way, and event bindings.\n  - Custom elements\n  - Minimal DOM Updates\n\n- Model\n  - Typed data, but separate from connection info.\n  - Parameter awareness. ( [can-set] )\n  - Real time\n  - Instance and List stores\n  - Fall through caching, complete caching.\n  - Works with related data [can-connect/can/ref/ref].\n  - Web worker\n\n- Cool other things\n  - SSR with can-simple-dom and can-zone\n  - StealJS stache integration\n\n",
    "description": "\n",
    "name": "guides/technical",
    "title": "Technical Highlights",
    "type": "page",
    "parent": "guides/introduction",
    "order": 2,
    "comment": " "
  },
  "guides/mission": {
    "src": {
      "path": "docs/can-guides/introduction/mission.md"
    },
    "body": "\nCanJS is an evolving and improving set of client side\nJavaScript architectural libraries that balances\ninnovation and stability.  \n\nCanJS targets experienced developers building complex applications\nwith long futures ahead of them.\n\nIf this is you, checkout the quick start guide\nwhere you build TodoMVC in about an hour.\n\nIf you're not sure if this is you, the importance of\nCanJS's goals, or how CanJS accomplishes these goals, please read on.\n\n\n## CanJS's Goals\n\nThe goal of CanJS can be summarized as follows:\n\n> You shouldn't have to rewrite your application to\n> keep pace with technology.\n\nTechnology changes quickly.  The popular frameworks and tools\nused today will likely not be the same as those used two\nyears from now.  Even those that might still be around will\nprobably not be easy to upgrade to.\n\nBut developers need stable platforms to develop from.\n\nCanJS attempts to strike a balance between these two\nconflicting problems by:\n\n- Providing high quality individually useful and stand-alone libraries.\n- Adopting to new ideas/technology and then integrating as new libraries\n  or features of existing ones.\n\nThe experience of using CanJS should be relatively easy at the start,\nbut extremely rewarding one over time.  \n\nBug fixes should be resolved quickly.\n\nNew features and libraries should be added that keeps pace with\ninnovation.\n\nBreaking changes should be simple to migrate.\n\n",
    "description": "\n",
    "name": "guides/mission",
    "title": "Mission and Goals",
    "type": "page",
    "parent": "guides/introduction",
    "order": 1,
    "comment": " "
  },
  "BuildAnApplicationWithData": {
    "src": {
      "path": "docs/can-guides/recipes/build-an-app-with-remote-data.md"
    },
    "body": "\nIn CanJS, `can.Model` adds functionality to `can.Map` to\nwork with data on a server.  It enables you to:\n\n - Get and modify data from a server\n - Listen to changes made to the data on the server\n - Unify service data with other objects in your application\n\n`can.Model` allows you to access data from a server\neasily:\n\n```\nvar Todo = can.Model.extend({\n  findAll: 'GET /todos',\n  findOne: 'GET /todos/{id}',\n  create:  'POST /todos',\n  update:  'PUT /todos/{id}',\n  destroy: 'DELETE /todos/{id}'\n},{});\n```\n\nUsing *any* server with a [*REST* interface](http://blog.mashape.com/post/60820526317/list-of-40-tutorials-on-how-to-create-an-api),\n `can.Model` enables create, read, update, and destroy functionality.\n\n## Create a Chat Application\n\nTo put together a chat application, we’ll use two methods\nfrom `can.Model` to fetch the messages and create new ones:\n\n```\nvar Message = can.Model({\n\tfindAll : 'GET ' + myServerUrl + '/messages',\n\tcreate : 'POST ' + myServerUrl + '/messages'\n},{});\n```\n\nIn a chat component's scope, we will use the `Message` model to\nsave new messages and observe changes to the Model.\n[`new Message.List({})`](http://canjs.com/docs/can.Model.List.html#sig_newcan_Model_List__models__) is a shortcut to perform\nthe [`findAll`](http://canjs.com/docs/can.Model.findAll.html) operation on a `can.Model` and\nreturn a `can.List`.\n\n```\n...\n\tscope: {\n\t\t\tmessages: new Message.List({}),\n\t\t\tnewMessage: \"\"\n...\n```\n\nThe tabs Component used `can-click` to listen for click events.\nSince this chat application uses a `<form>` for sending messages, we’ll use\n`can-submit` to specify an event handler.\n\nThere’s one more helper used in the template: [`can-value`](http://canjs.com/docs/can.view.bindings.can-value.html).\nThis automatically two-way binds the value of an input field to an observable\nproperty on the `scope` of the component (in this case, `newMessage`).\n\n```\ncan.Component.extend({\n  tag: 'chat',\n  template: '<ul id=\"messages\">' +\n\t\t\t  '{{#each messages}}' +\n\t\t\t  '<li>{{body}}</li>' +\n\t\t\t  '{{/each}}' +\n\t\t\t'</ul>' +\n\t\t\t'<form id=\"create-message\" action=\"\" can-submit=\"submitMessage\">' +\n\t\t\t\t'<input type=\"text\" id=\"body\" placeholder=\"type message here...\"' +\n\t\t\t\t'can-value=\"newMessage\" />' +\n\t\t\t'</form>',\n...\n```\n\nWhen `submitMessage` is called, a new `Message` is created\nwith `new Message()`. Since `can-value` was declared on the `input` element, `newMessage` will\nalways be the current text in the `input` field.\nThe body of the message is fetched from\nthe Component's `newMessage` attribute when a user submits the form.\n\nTo save the new message to the server, call `save()`.\n\n```\nsubmitMessage: function(scope, el, ev){\n\tev.preventDefault();\n\tnew Message({body: this.attr(\"newMessage\")}).save();\n\tthis.attr(\"newMessage\", \"\");\n}\n```\n\nFinally, when a new `Message` is created, the `messages` list\nmust be updated.\n\n```\nevents: {\n\t'{Message} created': function(construct, ev, message){\n\t\tthis.scope.attr('messages').push(message);\n\t}\n}\n```\n\nThere are two ways that messages are added: from the current user,\nor from another user. In the next section, we demonstrate how to use\n[socket.io](http://socket.io/) to update the `Message` model with messages\nfrom other users in real time. Binding to the `created` event for **all**\nmessages allows us to create a single entry point that pushes new messages\nto the `scope`, [regardless of where those messages are from.](http://canjs.com/docs/can.Model.html#section_Listentochangesindata)\n\nWhen the chat Component is loaded, messages are loaded from the server\nusing `can.Model` and `new Message.List({})`.  When a new message is\nsubmitted:\n\n1. `submitMessage` is called via the event handler bound by the `can-submit` attribute\n2. a new `Message` is created and saved to the server\n3. `'{Message} created'` detects this change and adds the new message to `messages`\n4. The template is automatically updated since `messages` is an observable `can.List`\n\n## Add real-time functionality\n\nThis example uses [socket.io](http://socket.io/)\nto enable real-time functionality. This guide won't go\ninto detail on how to use `socket.io`, but for real-time\nchat the application needs two more things.\n\nWhen a message is created on another chat client, `socket.io`\nwill notify this client by triggering the `message-created` event,\nwich will render the new message in the page by adding it to the\n`Message` model.\n\n```\nvar socket = io.connect(myServerUrl);\nsocket.on('message-created', function(message){\n\tnew Message(message).created();\n});\n```\n\nTo keep the `created` event from firing\ntwice, we modify the `create` function in the model.\nIf there was simply a `return` statement, `Model` would\ncreate and fire a `create` event, which `socket` is already\ndoing. By returning a `Deferred`, we prevent firing of\none of these events.\n\n```\nvar Message = can.Model({\n\tfindAll : 'GET ' + myServerUrl + '/messages',\n\tcreate : function(attrs) {\n\t\t$.post(myServerUrl + '/messages', attrs);\n\t\t//keep '{Message} created' from firing twice\n\t\treturn $.Deferred();\n\t}\n},{});\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/afC94/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n",
    "description": "\n",
    "name": "BuildAnApplicationWithData",
    "title": "Build an App with Remote Data",
    "type": "page",
    "parent": "Recipes",
    "order": 6,
    "comment": " "
  },
  "BuildWidgets": {
    "src": {
      "path": "docs/can-guides/recipes/build-widgets.md"
    },
    "body": "\nPrevious recipes have demonstrated how to change page content and introduced\nevent handling. The following recipes will introduce `can.Component`,\nwhich allows for straightforward widget construction by packaging\ntemplate, state, and event handling code in one place.\n\nWhile similar *behavior* can be accomplished with `can.Control`,\nbuilding a Component enables building reusable widgets using custom\nHTML tags.\n\n## Create a Component\n\nThe previous recipe that displays a list of people can instead\nbe represented as a component.\n\n```\n<people></people>\n```\n\nBy specifying `people` as the tag, a component is created wherever `<people></people>`\nappears in a template.\n\n```\ncan.Component.extend({\n\ttag: 'people',\n```\n\nThe `scope` object on a `Component` contains the component's state, data,\nand behavior. Here, it specifies how to `remove` a person from the list:\n\n```\n\tscope: {\n\t\tpeople: people,\n\t\tremove: function( person ) {\n\t\t\tvar people = this.attr(\"people\");\n\t\t\tvar index = people.indexOf(person);\n\t\t\tpeople.splice(index, 1);\n\t\t}\n\t}\n});\n```\n\nThe template for the component itself is passed via the `template`\nproperty. This can either be an external file or a string.\nEach `li` uses `can-click`, [which declares an event binding.](http://canjs.com/docs/can.view.bindings.can-EVENT.html)\nHere, `remove` inside the component's\nscope will be called with the relevant `people` object\nas an argument.\n\n```\nscope: {\n\ttemplate: '<ul>' +\n\t\t\t\t'{{#each people}}' +\n\t\t\t\t'<li can-click=\"remove\">' +\n\t\t\t\t\t'{{lastname}}, {{firstname}}' +\n\t\t\t\t'</li>' +\n\t\t\t\t'{{/each}}' +\n\t\t\t\t'</ul>',\n...\n```\n\nThis behaves similarly to the `can.Control` from above.\nHowever, the `<people>` tag can be used without having\nany knowledge about the inner workings of the widget.\nUsing declarative HTML tags, a component can be used\nwithout writing any javascript. The template, state,\nand behavior are all combined into one Component.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/WBM9z/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n## Build a Tabs Widget\n\nA tabs widget could be instantiated with the following HTML:\n\n```\n<tabs>\n\t<panel title=\"Fruit\">Oranges, Apples, Pears</panel>\n\t<panel title=\"Vegetable\">Carrot, Lettuce, Rutabega</panel>\n\t<panel title=\"Grains\">Bread, Pasta, Rice</panel>\n</tabs>\n```\n\nA designer that understands HTML can put together a template for a `tabs`\nwidget without understanding anything other than the syntax.\nThis is one of the most useful features of components.\n\n## Tabs Widget Behavior\n\nBefore implementing the component itself, we’ll\ndefine an observable *view model*--the `scope` object\nof the UI element. This makes the code modular and easier\nto manage (and also allows for unit testing).\n\nIn order to accurately represent a tabs widget,\na `TabsViewModel` needs:\n<ul>\n<li>An observable list of panels</li>\n<li>A state variable with the active panel</li>\n<li>Helper methods to add, remove, and activate panels</li>\n</ul>\n\nSince TabsViewModel is a `can.Map`, the `panels` property is\nautomatically converted to a `can.List`.\nThe `active` property references the `panel` object\nthat should currently be displayed.\n\n```\nvar TabsViewModel = can.Map.extend({\n\tpanels: [],\n\tactive: null,\n\taddPanel: function( panel ){\n\t\tvar panels = this.attr(\"panels\");\n\t\tpanels.push(panel);\n\t\tpanel.attr(\"visible\", false);\n\t\t//activate panel if it is the first one\n\t\tif ( panels.attr(\"length\") === 1 ){\n\t\t\tthis.activate( panel );\n\t\t}\n\t},\n\tremovePanel: function( panel ){\n\t\tvar panels = this.attr(\"panels\");\n\t\tvar index = panels.indexOf(panel);\n\t\tpanels.splice(index, 1);\n\t\t//activate a new panel if panel being removed was the active panel\n\t\tif( this.attr(\"active\") === panel ){\n\t\t\tpanels.attr(\"length\") ? this.activate(panels[0]) : this.attr(\"active\", null)\n\t\t}\n\t},\n\tactivate: function( panel ){\n\t\tvar active = this.attr(\"active\")\n\t\tif( active !== panel ){\n\t\t\tactive && active.attr(\"visible\", false);\n\t\t\tthis.attr(\"active\", panel.attr(\"visible\", true));\n\t\t}\n\t}\n});\n```\n\n### Tabs Widget Component\n\nNow that the view model is defined, making a component is simply\na matter of defining the way the tabs widget is displayed.\n\nThe template for a `tabs` component needs a list of panel titles\nthat will `activate` that panel when clicked. By calling `activate`\nwith a panel as the argument, the properties of the `panel` can\nbe manipulated. By changing the `visible` property of a panel,\na template can be used to display or hide the panel accordingly.\n\nFor this component, our template should look something like this:\n\n```\n<tabs>\n\t<panel title=\"Fruits\">Apples, Oranges</panel>\n\t<panel title=\"Vegetables\">Carrots, Celery</panel>\n</tabs>\n```\n\nA designer can create a `tabs` component with `panel` components inside it.\nThe `template` object on the tabs component's scope needs to be able to render\nthe content that is inside of the `<tabs>` tag. To do this, we simply use the\n`<content>` tag, which will render everything within the component's tags:\n\n```\ncan.Component.extend({\n\ttag: \"tabs\",\n\tscope: TabsViewModel,\n\ttemplate: \"<ul>\\\n\t\t\t\t{{#each panels}}\\\n\t\t\t\t\t<li can-click='activate'>{{title}}</li>\\\n\t\t\t\t{{/each}}\\\n\t\t\t\t</ul>\\\n\t\t\t\t<content />\"\n});\n```\n\nThe `tabs` component contains panels, which are also defined\nas components. The tabs template contains the logic for whether\nthe panel is visible (`visible` is controlled by the tabs\ncomponent's `activate` method).\n\nEach panel's `scope` contains a title, which should be\ntaken from the `title` attribute in the `<panel>` tag.\nIf you want to set the string value of a Component's\nattribute as a `scope` variable, use  `@'`.\n\n```\ncan.Component.extend({\ntag: \"panel\",\ntemplate: \"{{#if visible}}<content />{{/if}}\",\nscope: {\n\ttitle: \"@\"\n},\n...\n```\n\nIn addition to the `scope` property, a component has an\n[`events` property](http://canjs.com/docs/can.Component.prototype.events.html).\nThis `events` property uses a `can.Control` instantiated inside\nthe component to handle events.\n\nSince we defined behavior for adding panels on the parent\n`tabs` component, we should use this method whenever a `panel`\nis inserted into the page (and an `inserted` event is triggered).\nTo add the panel to the `tabs` component's scope, we call the\n`addPanel` method by accessing the parent scope with `this.element.parent().scope()`:\n\n```\n...\n\tevents: {\n\t\tinserted: function() {\n\t\t\tthis.element.parent().scope().addPanel( this.scope )\n\t\t},\n\t\tremoved: function() {\n\t\t\tthis.element.parent().scope().addPanel( this.scope )\n\t\t}\n\t}\n});\n```\n\nWith this component, any time a `<tabs>` element with\n`<panel>` elements is put in a page, a tabs widget will\nautomatically be created. This allows application behavior\nand design to be compartmentalized from each other.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/x6TJK/2/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n",
    "description": "\n",
    "name": "BuildWidgets",
    "title": "Build Widgets/UI Elements",
    "type": "page",
    "parent": "Recipes",
    "order": 5,
    "comment": " "
  },
  "CreateALiveTimestamp": {
    "src": {
      "path": "docs/can-guides/recipes/create-a-live-timestamp.md"
    },
    "body": "\nThis recipe demonstrates how to generate a 'live' timestamp\nthat displays in a human-readable format. This means handling\napplication state that changes over time, as well as making\ninformation rendered in a template human-readable using a helper function.\n\nFirst, we’ll add a `createdAt` property to the data like:\n\n```\n var data = new can.Map({\n   message: \"Hello World\",\n   createdAt: new Date()\n });\n```\n\nOn the page, this should be displayed as a human readable\ntimestamp:\n\n```\n <h1>Hello World <i>created just now</i></h1>\n```\n\n__and__ as time passes, the timestamp will update to:\n\n```\n<h1>Hello World <i>created a few seconds ago</i></h1>\n```\n\n__and__ then update to \"some seconds ago\" and so forth.\n\nTo accomplish this, create a `prettyDate` [stache helper](../docs/can.stache.helper.html) that converts\ndates into a human readable format.  A helper function is called from within the template where its result\nwill be displayed.  The following calls `prettyDate` with an observable value of `createdAt`.\n\n```\n<h1>\n  {{message}}\n  <i>created {{prettyDate createdAt}}</i>\n</h1>\n```\n\nTo call a function from a template, [register](../docs/can.stache.registerHelper.html) it with `can.view`.\nThe third argument passed to `can.view` is an object with helper functions, so the `dateHelper` function\ncan be registered as `prettyView`.\n\n```\nvar dateHelper = function ( date ) {\n\t//helper function\n};\n\nvar frag = can.view(\"app-template\", data, {prettyDate: dateHelper});\n```\n\nIn this helper, `date` is not a Date object, instead it is an observable [can.compute](../docs/can.compute.html) that\ncontains the `createdAt` value.  A `can.compute` is an observable that contains a single value.  To read the value,\ncall the compute like you would any other function:\n\n```\ndate() //-> Date\n```\n\nWe need to compare `date` with the current time. The current time\nwill be represented by a compute:\n\n```\nvar now = can.compute( new Date() )\n```\n\nAs the current time changes, we update `now` with the new time. To change the value of a `can.compute`,\ncall it with its new value as an argument:\n\n```\n// update that property every second\nsetTimeout(function(){\n\tnow( new Date() );\n\tsetTimeout(arguments.callee, 1000);\n}, 1000)\n```\n\nThe `prettyDate` helper will read and compare the `date` and `now` compute to\nget the time elapsed in seconds:\n\n```\nvar timeElapsed = ( now() - date() ) / 1000\n```\n\nUsing the `timeElapsed`, `prettyDate` returns human readable timestamps:\n\n```\nif(timeElapsed < 1.2){\n\treturn \"just now\"\n} else if (timeElapsed < 10) {\n\treturn \"a couple seconds ago\"\n}\n...\nelse {\n\treturn Math.round(difference/60)+\" minutes ago\"\n}\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/VQNSH/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "CreateALiveTimestamp",
    "title": "Create a Live Timestamp",
    "type": "page",
    "parent": "Recipes",
    "order": 3,
    "comment": " "
  },
  "HandleUserInteraction": {
    "src": {
      "path": "docs/can-guides/recipes/handle-user-interaction.md"
    },
    "body": "\nWhen a user does something, such as clicking, an `event` occurs. Event handlers specify\nhow [JavaScript should respond to an event](http://bitovi.com/blog/2010/10/a-crash-course-in-how-dom-events-work.html).\n\nThis recipe will introduce handling a click event using a [`can.Control`](http://canjs.com/docs/can.Control).\nUsing a list of people like previous recipes, clicking any individual person's name\nwill remove that person from the list.\n\nPrevious examples have used jQuery's event handlers:\n\n```\n$(\"#push\").click(function(){\n  //handle the event\n});\n```\n\nCanJS provides a few different ways to respond to events. As well as\nmaking application code simpler, using CanJS to handle events can help to\nautomatically prevent [memory leaks](http://bitovi.com/blog/2012/04/zombie-apocolypse.html).\n\nTo handle events, extend `can.Control`.\n\n```\nvar PeopleList = can.Control.extend({\n\t//behavior\n});\n```\n\nYou create a `can.Control` by [calling it as a constructor function](http://canjs.com/docs/can.Control.html#sig_newcan_Control_element_options_).\nThe first argument is the element the control will be created on.\nThe second argument is an object of options.\n\n\tnew PeopleList('#my-app', {people: people});\n\nA `can.Control` handles events with functions declared with two arguments: an\nelement or list of elements (using a jQuery-style selector) and a specific event.\nBelow, this is 'li click', meaning when any `li` elements that are `clicked` the\nfunction will be called to handle the click event.\n\n```\nvar PeopleList = can.Control.extend({\n  init: function( element, options ){\n  \tthis.people = new can.List(options.people);\n  \tthis.element.html( can.view('app-template', {\n  \t\t//defines people in the template as the observable can.List\n  \t\tpeople: this.people\n  \t}));\n  },\n  'li click': function( li, event ){\n  \t//Handle the click event\n  }\n};\n```\n\nWhen the constructor function is called and the `can.Control`\nis instantiated:\n\n1. The `init` method is called\n2. An observable `can.List` is created from `people`\n3. The list is rendered using `can.view` so when the list changes, so will the view\n\n```\nvar people = [\n\t{firstname: \"John\", lastname: \"Doe\"},\n\t{firstname: \"Emily\", lastname: \"Dickinson\"},\n\t{firstname: \"William\", lastname: \"Adams\"},\n\t{firstname: \"Stevie\", lastname: \"Nicks\"},\n\t{firstname: \"Bob\", lastname: \"Barker\"}\n];\n```\n\nWhen the event handler for a `click` runs, it needs a way\nto access the object associated with the `li` that was clicked.\nWith the [`data`](http://canjs.com/docs/can.stache.helpers.data.html) helper,\nthe element will retain a reference\nto the object it is associated with (in this case, a `person`).\n\n```\n<ul>\n{{#each people}}\n\t<li {{data 'person'}}>\n\t\t{{lastname}}, {{firstname}}\n\t</li>\n{{/each}}\n</ul>\n```\n\nFinally, the event handler must be defined. In a `can.Control`,\nan event handler function [can be defined with a string containing\na selector and an event](http://canjs.com/docs/can.Control.html#section_Listeningtoevents).\nIn this case, these are `li` and `click`, respectively,\nsince we want to handle click events on each list item.\n\n```\nvar PeopleList = can.Control.extend({\n  init: function(){\n\t...\n  },\n  'li click': function( li, event ) {\n  \tvar people = this.people;\n  \tvar person = li.data('person');\n  \tvar index = people.indexOf(person);\n  \tpeople.splice(index, 1);\n  }\n});\n```\n\nWhen a user clicks a list item:\n\n 1. The function bound to `li click` is called\n 2. The object associated with that list item is accessed using the `data` helper\n 3. That 'person's data is removed from the observable list of `people`\n 4. The template updates automatically\n\nAs a reminder, though event handlers respond to actions on the page,\nthey should *change application state or data* (e.g. make a change to a `can.Map`)\nrather than modifying the DOM directly (e.g. toggling a class).\nThis will update the page automatically, keeping code manageable.\n\nThis is *one* way to handle events. Others will be covered\nin the following recipes while building widgets.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/F9kzt/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "HandleUserInteraction",
    "title": "Handle User Interaction",
    "type": "page",
    "parent": "Recipes",
    "order": 4,
    "comment": " "
  },
  "guides/examples": {
    "src": {
      "path": "docs/can-guides/recipes/examples.md"
    },
    "body": "\n## Get Started\n\nThere are a variety of ways to get CanJS.  Read the [using CanJS guide](http://canjs.com/guides/Using.html)\nfor comprehensive list.  For the following recipes, we will load CanJS\nwith a `<script>` tag pointed to CanJS's CDN.\n\nCreate a file called `myapp.html` and put the following in it to get started:\n\n```\n<script src=\"//code.jquery.com/jquery-1.10.1.min.js\"></script>\n<script src=\"//canjs.com/release/2.0.4/can.jquery.js\"></script>\n<script type=\"text/stache\" id=\"app-template\">\n//Template will go here\n</script>\n<script>\n//Application code will go here\n</script>\n\n<!-- CanJS needs a place to put your application -->\n<div id=\"my-app\"></div>\n```\n\nTo follow along with the other recipes, you can also use\n[this JSFiddle](http://jsfiddle.net/donejs/GE3yf/) as a template.\n\nYou can also [Download CanJS](http://canjs.com/download.html)\nor follow [other tutorials](http://canjs.com/guides/Tutorial.html) to get\nstarted, but for the rest of the examples, we’ll be using this\nsetup.\n\n## Request a Recipe\n\nTo request a new recipe or vote on an upcoming one, [submit an issue](https://github.com/canjs/canjs.com/issues)\nto the `canjs.com` respository on GitHub.\n\n",
    "description": "\n",
    "name": "guides/examples",
    "title": "Examples",
    "type": "page",
    "parent": "guides/commitment",
    "order": 1,
    "comment": " "
  },
  "ShowAList": {
    "src": {
      "path": "docs/can-guides/recipes/recipes-show-a-list.md"
    },
    "body": "\nTo make an Array observable, pass it to [can.List](../docs/can.List.html).\n\n```\nvar people = new can.List([\n\t{firstname: \"John\", lastname: \"Doe\"},\n\t{firstname: \"Emily\", lastname: \"Dickinson\"}\n]);\n\nvar frag = can.view(\"app-template\", {people: people})\n$(\"#my-app\").html(frag);\n```\n\nTo show a list of data within a stache template, use the `#each` operator.\n\n```\n<ul>\n{{#each people}}\n  <li>\n\t{{lastname}}, {{firstname}}\n  </li>\n{{/each}}\n</ul>\n```\n\nInside the `#each` block, the attributes are scoped to individual\nobjects in the list of `people`.\n\nTo make changes to the list, use an Array method such as\n[push](/docs/can.List.prototype.push.html)\nor [pop](/docs/can.List.prototype.pop.html).\n\n```\n// adds a new person\npeople.push({firstname: \"Paul\", lastname: \"Newman\"})\n// removes the last person\npeople.pop()\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/Pgbpa/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "ShowAList",
    "title": "Show a List in a Template",
    "type": "page",
    "parent": "Recipes",
    "order": 3,
    "comment": " "
  },
  "SayHelloWorld": {
    "src": {
      "path": "docs/can-guides/recipes/say-hello-world.md"
    },
    "body": "\nIn CanJS, content is displayed using *templates*.  Instead of manually\nchanging elements in the DOM, you create a template and CanJS\nautomatically updates the page from the data in your application code.\n\n## Template\n\nIn the template section of `myapp.html`, put the following:\n\n```\n<script type=\"text/stache\" id=\"app-template\">\n\t<h1>{{message}}</h1>\n</script>\n```\n\nThis template displays the value of `message`.\n\n## Pass message to the Template\n\nTemplates are rendered with [can.view](../docs/can.view.html), which takes two arguments: the first is the `id` of the template,\nand the second is the data passed to the template (in this case,\nan object with a `message` property).\n\nRender the template with a `message` and insert it into the page with:\n\n```\n<script>\n// Give message a value\nvar data = {message: \"Hello World!\"};\n\n// Pass the id of the template and the data, containing our message to can.view\nvar frag = can.view(\"app-template\", data);\n\n//Load the DocumentFragment in the page\n$(\"#my-app\").html( frag )\n</script>\n```\n\n> `frag` is a [DocumentFragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment). A DocumentFragment\n> is a lightweight container of HTMLElements that can be inserted in the page quickly. They can be used\n> anywhere a normal HTMLElement is used.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/GE3yf/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "SayHelloWorld",
    "title": "Say \"Hello World\"",
    "type": "page",
    "parent": "Recipes",
    "order": 1,
    "comment": " "
  },
  "UpdateText": {
    "src": {
      "path": "docs/can-guides/recipes/update-text.md"
    },
    "body": "\nCanJS will update the page automatically when [observable](http://sourcemaking.com/design_patterns/observer)\ndata changes. To make observable data, pass raw data to [can.Map](../docs/can.Map.html),\n[can.List](../docs/can.List.html) or [can.compute](../docs/can.compute.html) like:\n\n```\nvar data = new can.Map({message: \"Hello World!\"});\n```\n\nTo change the message, use the [attr()](../docs/can.Map.prototype.attr.html) method of `can.Map`.\n\n```\ndata.attr(\"message\", \"Goodbye World!\")\n```\n\nWhen the button is clicked in the example below, the message is\nchanged with `data.attr()`.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/quTtE/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n",
    "description": "\n",
    "name": "UpdateText",
    "title": "Update Text in the Page",
    "type": "page",
    "parent": "Recipes",
    "order": 2,
    "comment": " "
  },
  "ShowAndHideElements": {
    "src": {
      "path": "docs/can-guides/recipes/show-and-hide-elements.md"
    },
    "body": "\nInstead of showing and hiding elements by changing the DOM\ndirectly like:\n\n```\n$(\"h1\").show()\n$(\"h1\").hide()\n```\n\nMake the template show or hide those elements when a value\nchanges.\n\n```\n{{#if visible}}\n  <h1>{{message}}</h1>\n{{/if}}\n```\n\nWhen the button is clicked, change the observable value.\n\n```\ndata.attr(\"visible\", !data.attr(\"visible\"))\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/eFss4/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n### Application State\n\nTypically, it’s not a good idea to mix view state and application data.\nIn the previous example, the `message` is application data, while the\n`visible` property represents view state. In CanJS, state and data\nshould be separated using different observables.\n\n```\nvar data = new can.Map({message: \"Hello World!\"}),\n\tstate = new can.Map({visible: true});\n\nvar frag = can.view(\"app-template\", {\n  data: data,\n  state: state\n});\n```\n\nAs an application gets more complex, separating state from data\nmakes things more maintainable.\n",
    "description": "\n",
    "name": "ShowAndHideElements",
    "title": "Show and Hide Elements",
    "type": "page",
    "parent": "Recipes",
    "order": 3,
    "comment": " "
  },
  "can-component.prototype.ViewModel": {
    "src": {
      "path": "node_modules/can-component/docs/ViewModel.md"
    },
    "body": "\n## Use\n\n[can-component]'s viewModel property is used to define an __object__, typically an instance\nof a [can-map], that will be used to render the component's\ntemplate. This is most easily understood with an example.  The following\ncomponent shows the current page number based off a `limit` and `offset` value:\n\n```js\nvar MyPaginateViewModel = DefineMap.extend({\n  offset: {value: 0},\n  limit: {value: 20},\n  page: function(){\n    return Math.floor(this.offset / this.limit) + 1;\n  }\n});\n\nComponent.extend({\n  tag: \"my-paginate\",\n  ViewModel: MyPaginateViewModel,\n  view: stache(\"Page {{page}}.\")\n})\n```\n\nIf this component HTML was inserted into the page like:\n\n    var template = stache(\"<my-paginate/>\")\n    $(\"body\").append(template())\n\nIt would result in:\n\n    <my-paginate>Page 1</my-paginate>\n\nThis is because the provided viewModel object is used to extend a [can-map] like:\n\n    CustomMap = Map.extend({\n      offset: 0,\n      limit: 20,\n      page: function(){\n        return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n      }\n    })\n\nAny primitives found on a `Map`'s prototype (ex: `offset: 0`) are used as\ndefault values.\n\nNext, a new instance of CustomMap is created with the attribute data within `<my-paginate>`\n(in this case there is none) like:\n\n    componentData = new CustomMap(attrs);\n\nAnd finally, that data is added to the [can-view-scope parentScope] of the component, used to\nrender the component's template, and inserted into the element:\n\n    var newviewModel = parentScope.add(componentData),\n        result = stache(\"Page {{page}}.\")(newviewModel);\n    $(element).html(result);\n\n## Values passed from attributes\n\nValues can be \"passed\" into the viewModel of a component, similar to passing arguments into a function. Using\n[can-stache-bindings], the following binding types can be setup:\n\n- [can-stache-bindings.toChild] - Update the component's viewModel when the parent scope value changes.\n- [can-stache-bindings.toParent] - Update the parent scope when the component's viewModel changes.\n- [can-stache-bindings.twoWay] - Update the parent scope or the component's viewModel when the other changes.\n\nAs mentioned in the deprecation warning above, using [can-stache], values are passed into components like this:\n\n    <my-paginate {offset}='index' {limit}='size'></my-paginate>\n\nThe above would create an offset and limit property on the component that are initialized to whatever index and size are, NOT two-way bind (between component and parent viewModels)\nthe offset and limit properties to the index and size.\n\nThe following component requires an `offset` and `limit`:\n\n    Component.extend({\n      tag: \"my-paginate\",\n      viewModel: {\n        page: function(){\n          return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n        }\n      },\n      view: stache(\"Page {{page}}.\")\n    });\n\nIf `<my-paginate>`'s source html is rendered like:\n\n    var template = stache(\"<my-paginate {offset}='index' {limit}='size'></my-paginate>\");\n\n    var pageInfo = new Map({\n      index: 0,\n      size: 20\n    });\n\n    $(\"body\").append( template( pageInfo ) );\n\n... `pageInfo`'s index and size are set as the component's offset and\nlimit attributes. If we were to change the value of `pageInfo`'s\nindex like:\n\n    pageInfo.attr(\"index\",20)\n\n... the component's offset value will change and its template will update to:\n\n    <my-paginate>Page 1</my-paginate>\n\n### Using attribute values\n\nYou can also pass a literal string value of the attribute. To do this in [can-stache],\nsimply pass any value not wrapped in single brackets, and the viewModel property will\nbe initialized to this string value:\n\n    <my-tag title=\"hello\"></my-tag>\n\nThe above will create a title property in the component's viewModel, which has a string `hello`.  \n\nIf the tag's `title` attribute is changed, it updates the viewModel property\nautomatically.  This can be seen in the following example:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/accordion.html'></div>\n\nClicking the __Change title__ button sets a `<panel>` element's `title` attribute like:\n\n```js\nout.addEventListener(\"click\", function(ev){\n\tvar el = ev.target;\n\tvar parent = el.parentNode;\n\tif(el.nodeName === \"BUTTON\") {\n\t\tparent.setAttribute(\"title\", \"Users\");\n\t\tparent.removeChild(el);\n\t}\n});\n```\n\n## Calling methods on viewModel from events within the template\n\nUsing html attributes like `can-EVENT-METHOD`, you can directly call a viewModel method\nfrom a template. For example, we can make `<my-paginate>` elements include a next\nbutton that calls the viewModel's `next` method like:\n\n```js\nvar ViewModel = DefineMap.extend({\n\toffset: {\n\t\tvalue: 0\n\t},\n\tlimit: {\n\t\tvalue: 20\n\t},\n\tnext: function(){\n\t\tthis.offset = this.offset + this.limit;\n\t},\n\tpage: function(){\n\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t}\n});\n\nComponent.extend({\n\ttag: \"my-paginate\",\n\tViewModel: ViewModel,\n\tview: stache(\"Page {{page}} <button ($click)='next()'>Next</button>\")\n});\n```\n\nviewModel methods get called back with the current context, the element that you are listening to and the event that triggered the callback.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next.html'></div>\n\n## Publishing events on viewModels\n\nMaps can publish events on themselves. For instance, the following `<player-edit>` component,\ndispatches a `\"close\"` event when it's close method is called:\n\n```\nComponent.extend({\n\ttag: \"player-edit\",\n\tview: stache($('#player-edit-stache').html()),\n\tViewModel: DefineMap.extend({\n\t\tplayer: Player,\n\t\tclose: function(){\n\t\t\tthis.dispatch(\"close\");\n\t\t}\n\t}),\n\tleakScope: true\n});\n```\n\nThese can be listened to with [can-stache-bindings.event] bindings like:\n\n```\n<player-edit\n  \t(close)=\"removeEdit()\"\n  \t{player}=\"editingPlayer\"/>\n```\n\nThe following demo uses this ability to create a close button that\nhides the player editor:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next_event.html'></div>\n\n",
    "description": " \nProvides or describes a constructor function that provides values and methods\nto the component's [can-component::view template]. The constructor function\nis initialized with values specified by the component element's [can-stache-bindings data bindings].\n\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A new instance of the corresponding constructor function. This instance is\nadded to the top of the [can-view-scope] the component's [can-component::view] is rendered with.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "properties",
            "description": "The initial properties that are passed by the [can-stache-bindings data bindings].\n\nThe view bindings on a tag control the properties and values used to instantiate the `ViewModel`. For example, calling `<my-tag>` as follows invokes `MyTagViewModel` as shown in the comments:\n\n```\n<my-tag/> <!-- new MyTagViewModel({}) -->\n\n<my-tag\n    {message}=\"'Hi There'\"/> <!-- new MyTagViewModel({message: \"Hi There\"}) -->\n\n```\n"
          }
        ],
        "description": "A constructor function usually defined by [can-define/map/map.extend DefineMap.extend] or\n[can-map Map.extend] that will be used to create an new observable instance accessible by\nthe component's [can-component::view].\n\nFor example, every time `<my-tag>` is found, a new instance of `MyTagViewModel` will\nbe created:\n\n```js\nvar MyTagViewModel = DefineMap.extend(\"MyTagViewModel\",{\n    message: \"string\"\n});\n\nComponent.extend({\n    tag: \"my-tag\",\n    ViewModel: MyTagViewModel,\n    view: stache(\"<h1>{{message}}</h1>\")\n})\n```\n\nUse [can-view-model] to read a component's view model instance.\n"
      },
      {
        "type": "Object",
        "options": [],
        "description": "A short hand for the prototype methods and properties used to extend the\n[can-util/js/types/types.DefaultMap default Map type] (typically [can-define/map/map]) and use\nthat anonymous type as the view model.\n\nThe following:\n\n```js\nComponent.extend({\n    tag: \"my-paginate\",\n    ViewModel: {\n        offset: {value: 0},\n        limit: {value: 20}\n    }\n})\n```\n\nThis is shorthand for:\n\n```js\nvar AnonymousViewModel = DefineMap.extend({\n    offset: {value: 0},\n    limit: {value: 20}\n})\n\nComponent.extend({\n    tag: \"my-paginate\",\n    ViewModel: AnonymousViewModel\n})\n```\n"
      }
    ],
    "title": "ViewModel",
    "name": "can-component.prototype.ViewModel",
    "type": "property",
    "parent": "can-component.prototype",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "properties",
      "description": "The initial properties that are passed by the [can-stache-bindings data bindings].\n\nThe view bindings on a tag control the properties and values used to instantiate the `ViewModel`. For example, calling `<my-tag>` as follows invokes `MyTagViewModel` as shown in the comments:\n\n```\n<my-tag/> <!-- new MyTagViewModel({}) -->\n\n<my-tag\n    {message}=\"'Hi There'\"/> <!-- new MyTagViewModel({message: \"Hi There\"}) -->\n\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A new instance of the corresponding constructor function. This instance is\nadded to the top of the [can-view-scope] the component's [can-component::view] is rendered with.\n"
    },
    "comment": " "
  },
  "can-component/beforeremove": {
    "src": {
      "path": "node_modules/can-component/docs/beforeremove.md"
    },
    "body": "\n",
    "description": "\nAn event called only on component's elements before they are removed from the\ndocument if live binding is performing the removal. It can be listened to\nwithin a component's [can-component.prototype.events] object or on a component\nelement with [can-stache-bindings.event] bindings.  This is an additional\nspecial event only on component elements.  [can-util/dom/events/inserted/inserted]\nand [can-util/dom/events/removed/removed] events are available on all elements.\n",
    "type": "typedef",
    "title": "beforeremove",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-component/beforeremove",
    "parent": "can-component.events",
    "signatures": [
      {
        "code": "\"{element} beforeremove\": function(element, event)",
        "description": "\n\nListens to when the component element is removed.  \nThis is commonly used for cleaning up and tearing down a component.\n\nFor example, the following might remove the component's ViewModel\nfrom a parent component's ViewModel:\n\n```js\nevents: {\n\t\"{element} beforeremove\": function(){\n\t\tcanViewModel(this.element.parentNode)\n\t\t\t.removePanel(this.viewModel);\n\t}\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "The component element."
          },
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "The `beforeremove` event object.\n"
          }
        ]
      },
      {
        "code": "($beforeremove)=\"CALL_EXRESSION\"",
        "description": "\n\nUses [can-stache-bindings.event] bindings to listen for a component's\nbeforeremove event.  \n\n```\n<my-panel ($beforeremove)=\"removePanel(%viewModel)\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXRESSION",
            "description": "A call expression that calls some method when the event happens.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "CALL_EXRESSION",
      "description": "A call expression that calls some method when the event happens.\n"
    }
  },
  "can-component.static": {
    "name": "can-component.static",
    "title": "static",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 0
  },
  "can-component.prototype": {
    "name": "can-component.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 1
  },
  "can-component.elements": {
    "name": "can-component.elements",
    "title": "elements",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 2
  },
  "can-component.events": {
    "name": "can-component.events",
    "title": "special events",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 3
  },
  "can-component/content": {
    "src": {
      "path": "node_modules/can-component/docs/content.md"
    },
    "body": "\n",
    "description": "\nPositions the `LIGHT_DOM` within a component's [can-component.prototype.template].\n",
    "type": "typedef",
    "title": "<content>",
    "types": [
      {
        "type": "can-stache.sectionRenderer"
      }
    ],
    "name": "can-component/content",
    "parent": "can-component.elements",
    "signatures": [
      {
        "code": "&lt;content>DEFAULT_CONTENT&lt;/content>",
        "description": "\n\nWhen a user creates a new component in a template, the content between the tags is the\n`LIGHT_DOM`.  For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `<content>` tag can be used within `my-tag` to position the `LIGHT_DOM`.  For\nexample, to position the `LIGHT_DOM` within an `<h1>`, `<my-tag>` could be defined like:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content/></h1>\")\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "DEFAULT_CONTENT",
            "description": "The content that should be\nused if there is no `LIGHT_DOM` passed to the component.\n\nThe following, makes `my-tag` show `Hi There!` if no `LIGHT_DOM` is passed:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content>Hi There!</content></h1>\")\n});\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "DEFAULT_CONTENT",
      "description": "The content that should be\nused if there is no `LIGHT_DOM` passed to the component.\n\nThe following, makes `my-tag` show `Hi There!` if no `LIGHT_DOM` is passed:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content>Hi There!</content></h1>\")\n});\n```\n"
    }
  },
  "can-component.prototype.events": {
    "src": {
      "path": "node_modules/can-component/docs/events.md"
    },
    "body": "\n\n## Use\n\n[can-component]'s events object allows you to provide low-level [can-control]-like abilities to a `Component`\nwhile still accessing the `Component`'s [can-component::ViewModel].  The following\nexample listens to clicks on elements with `className=\"next\"` and calls `.next()` on the component's viewModel.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_events_next.html'></div>\n\nThe events object can also listen to objects or properties on the component's [can-component::ViewModel] instance. For instance, instead\nof using live-binding, we could listen to when offset changes and update the page manually:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_events_next_update_page.html'></div>\n\nComponents have the ability to bind to special inserted and removed events that are called when a component's tag has been inserted into or removed from the page:\n\n      events: {\n        \"inserted\": function(){\n          // called when the component's tag is inserted into the DOM\n        },\n        \"removed\": function(){\n          // called when the component's tag is removed from the DOM\n        }\n      }\n\n## High performance template rendering\n\nWhile [can-stache-bindings] conveniently allows you to call a [can-component::ViewModel] method from a template like:\n\n    <input ($change)=\"doSomething()\"/>\n\nThis has the effect of binding an event handler directly to this element. Every element that has a `($click)` or similar attribute has an event handler bound to it. For a large grid or list, this could have a performance penalty.\n\nBy contrast, events bound using [can-component]'s events object use event delegation, which is useful for high performance template rendering. In a large grid or list, event delegation only binds a single event handler rather than one per row.\n\n",
    "description": "\nListen to events on elements and observables.\n",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "An object of event names and methods\nthat handle the event. For example:\n\n    Component({\n      events: {\n        \".next click\": function(){\n          this.viewModel.next()\n        }\n      },\n      ViewModel: {\n        next: function(){\n          this.offset = this.offset + this.limit;\n        }\n      }\n    })\n\n\nA component's events object is used as the prototype of a [can-control]. The control gets created on the component's\nelement. The component's viewModel is available within event handlers as `this.viewModel`.\n\n",
        "template": [
          {
            "types": [
              {
                "type": "can-control.eventDescription"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-control.eventHandler"
              }
            ]
          }
        ]
      }
    ],
    "title": "events",
    "name": "can-component.prototype.events",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.extend": {
    "src": {
      "path": "node_modules/can-component/docs/extend.md"
    },
    "body": "\n\n\nNote that inheriting from components works differently than other CanJS APIs. You can't call `.extend` on a particular component to create a \"subclass\" of that component.\n\nInstead, components work more like HTML elements. To reuse functionality from a base component, build on top of it with parent components that wrap other components in their template and pass any needed viewModel properties via attributes.\n\n",
    "description": "\nDefine the behavior of a custom element.\n",
    "title": "extend",
    "name": "can-component.extend",
    "type": "function",
    "parent": "can-component.static",
    "signatures": [
      {
        "code": "Component.extend(prototype)",
        "description": "\n\nExtends the [can-component] [can-construct constructor function] with prototype\nproperties and methods.  Registers the component by its [can-component::tag] with\n[can-view-callbacks.tag can-view-callbacks.tag].\n\n```js\nvar Component = require(\"can-component\");\nvar stache = require(\"can-stache\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar VM = DefineMap.extend({ ... });\n\nComponent.extend({\n  tag: \"tag-name\",\n  ViewModel: VM,\n  view: stache(\" .... \")\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "prototype",
            "description": "An object set as the prototype of the\nconstructor function. You will typically provide the following values\non the prototype object:\n\n  - __tag__ {[can-component.prototype.tag]} - Defines the\n  tag on which instances of the component constructor function will be\n  created.\n\n  - __ViewModel__ {[can-component.prototype.ViewModel]} - Specifies an object\n  that is is used to render the component's template.\n\n  - __view__ {[can-component.prototype.view]} - Specifies the template\n  rendered within the custom element.\n\nAnd sometimes the following values are provided:\n\n  - __events__ {[can-component.prototype.events]} - Defines events on\n  dom elements or observable objects the component listens to.\n\n  - __helpers__ {[can-component.prototype.helpers]} - Specifies mustache helpers\n  used to render the component's template.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "prototype",
      "description": "An object set as the prototype of the\nconstructor function. You will typically provide the following values\non the prototype object:\n\n  - __tag__ {[can-component.prototype.tag]} - Defines the\n  tag on which instances of the component constructor function will be\n  created.\n\n  - __ViewModel__ {[can-component.prototype.ViewModel]} - Specifies an object\n  that is is used to render the component's template.\n\n  - __view__ {[can-component.prototype.view]} - Specifies the template\n  rendered within the custom element.\n\nAnd sometimes the following values are provided:\n\n  - __events__ {[can-component.prototype.events]} - Defines events on\n  dom elements or observable objects the component listens to.\n\n  - __helpers__ {[can-component.prototype.helpers]} - Specifies mustache helpers\n  used to render the component's template.\n\n\n"
    },
    "comment": " "
  },
  "can-component.prototype.helpers": {
    "src": {
      "path": "node_modules/can-component/docs/helpers.md"
    },
    "body": "\n\n## Use\n\n[can-component]'s helper object lets you provide helper functions that are localized to\nthe component's [can-component::view template].  The following example\nuses an `isSelected` helper to render content for selected items. Click\none of the following libraries to toggle them within the `selected` array.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/selected.html'></div>\n\n",
    "description": "\nHelper functions used with the component's template.\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-stache.helper"
              }
            ]
          }
        ],
        "description": "\n\nAn object of [can-stache] helper names and methods. The helpers are only\navailable within the component's template and source html. Helpers\nare always called back with `this` as the [can-component::ViewModel] instance.\n"
      }
    ],
    "title": "helpers",
    "name": "can-component.prototype.helpers",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.leakScope": {
    "src": {
      "path": "node_modules/can-component/docs/leakscope.md"
    },
    "body": "\n## Use\n\nA component's [can-component::leakScope leakScope] option controls if a\ncomponent's template can access the component's outer scope and the\nuser content can read the component's view model.\n\nLets define what __outer scope__, __component's template__ and __user content__ mean.\n\nIf I have a `<hello-world>` component in a template like:\n\n```\n{{#data}}\n\t<hello-world>{{subject}}</hello-world>\n{{/data}}\n```\n\nThe __outer scope__ of `<hello-world>` has `data` as its context.  The __user content__ of\n`<hello-world>` is the template between its tags.  In this case, the __user content__\nis `{{subject}}`.\n\nFinally, if `<hello-world>` is defined like:\n\n```\nComponent.extend({\n  tag: \"hello-world\",\n  view: stache(\"{{greeting}} <content/>{{exclamation}}\")\n})\n```\n\n`{{greeting}} <content/>{{exclamation}}` represents the __component's template__.\n\n## Example\n\nIf the following component is defined:\n\n    Component.extend({\n        tag: \"hello-world\",\n        leakScope: true, // the default value\n        view: stache(\"{{greeting}} <content/>{{exclamation}}\"),\n        viewModel: { subject: \"LEAK\", exclamation: \"!\" }\n    })\n\nAnd used like so:\n\n    <hello-world>{{subject}}</hello-world>\n\nWith the following data in the outer scope:\n\n    { greeting: \"Hello\", subject: \"World\"}\n\nWill render the following if `leakScope` is true:\n\n    <hello-world>Hello LEAK!</hello-world>\n\nBut if `leakScope` is false:\n\n    <hello-world>Hello World</hello-world>\n\nBecause when the scope isn't leaked, the __component's template__\ndoes not see `exclamation`. The __user content__ does not see the\nviewModel's `subject` and uses the outer scope's `subject` which is `\"World\"`.\n\nUsing the `leakScope: false` option is useful for hiding and protecting\ninternal details of `Component`, potentially preventing accidental\nclashes.\n\n",
    "description": "Allow reading the outer scope values from a component's template and a component's viewModel values in the user content.\n\n",
    "types": [
      {
        "type": "Boolean",
        "description": "`false` limits reading to:\n\n- the component's viewModel from the component's template, and\n- the outer scope values from the user content.\n\n`true` adds the ability to read:\n\n- the outer [can-view-scope scope] values from the component's template, and\n- the component's [can-component.prototype.ViewModel] values from the user content.\n\nThe default value is `false`. \n"
      }
    ],
    "title": "leakScope",
    "name": "can-component.prototype.leakScope",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.tag": {
    "src": {
      "path": "node_modules/can-component/docs/tag.md"
    },
    "body": "\n",
    "description": "\nSpecifies the HTML tag (or node-name) the [can-component] will be created on.\n",
    "types": [
      {
        "type": "String",
        "description": "The tag name the [can-component]\nwill be created on.  Tag names are typically lower cased and\nhypenated like: `foo-bar`.  Component's register their\ntag with [can-view-callbacks.tag tag].\n\n\n"
      }
    ],
    "title": "tag",
    "name": "can-component.prototype.tag",
    "type": "property",
    "parent": "can-component.prototype"
  },
  "can-component.prototype.view-model": {
    "src": {
      "path": "node_modules/can-component/docs/view-model.md"
    },
    "body": "\n",
    "description": "\nReturn the view model instance or type with which the component's [can-component.prototype.view]\nis rendered.  This is used when more fine grained control is needed over [can-component::ViewModel].\n",
    "title": "viewModel",
    "name": "can-component.prototype.view-model",
    "type": "function",
    "parent": "can-component.prototype",
    "signatures": [
      {
        "code": "function(properties, parentScope, element)",
        "description": "\n\nThe `viewModel` function takes the `properties` and values that are used to\ntypically initialize a [can-component.prototype.ViewModel], the\n[can-view-scope] the component is rendered within, and the component's element\nand returns either the view-model instance or ViewModel type that the component's [can-component.prototype.view]\nis rendered with.\n\nThis is typically used only for special situations where a custom scope or custom bindings\nneed to be setup.\n\n```\nvar Component = require(\"can-component\");\nvar Scope = require(\"can-view-scope\");\n\nComponent.extend({\n\ttag: \"my-element\",\n\tviewModel: function(properties, scope, element){\n\t\tvar vm =  new DefineMap(properties);\n\t\t// do special stuff ...\n\t\treturn vm;\n\t}\n});\n\nstache(\"<my-element {first}='firstName' last='Meyer'/>\")({\n  firstName: \"Justin\",\n  middleName: \"Barry\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "properties",
            "description": "An object of values specified by the custom element's attributes. For example, a template rendered like:\n\n    stache(\"<my-element title='name'></my-element>\")({\n      name: \"Justin\"\n    })\n\nCreates an instance of following control:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties){\n    \t  properties.title //-> \"Justin\";\n    \t}\n    })\n\nAnd calls the viewModel function with `properties` like `{title: \"Justin\"}`.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope"
              }
            ],
            "name": "parentScope",
            "description": "\n\nThe viewModel the custom tag was found within.  By default, any attribute's values will\nbe looked up within the current viewModel, but if you want to add values without needing\nthe user to provide an attribute, you can set this up here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope){\n    \t  parentScope.get('middleName') //-> \"Barry\"\n    \t}\n    });\n\nNotice how the `middleName` value is looked up in `my-element`'s parent scope.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope, el){\n\t\t  var vm = new DefineMap({clicks: 0});\n    \t  domEvent.addEventListener.call(el, \"click\", function(){\n\t\t    vm.clicks++;\n\t\t  });\n\t\t  return vm;\n    \t}\n    });\n\nThis example should be done with the [can-component::events] object instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns one of the following.\n\n   - An observable map or list type.\n   - The prototype of an observable map or list type that will be used to render the component's template.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "name": "element",
      "description": "The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope, el){\n\t\t  var vm = new DefineMap({clicks: 0});\n    \t  domEvent.addEventListener.call(el, \"click\", function(){\n\t\t    vm.clicks++;\n\t\t  });\n\t\t  return vm;\n    \t}\n    });\n\nThis example should be done with the [can-component::events] object instead.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Map"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns one of the following.\n\n   - An observable map or list type.\n   - The prototype of an observable map or list type that will be used to render the component's template.\n"
    }
  },
  "can-component.prototype.view": {
    "src": {
      "path": "node_modules/can-component/docs/view.md"
    },
    "body": "\n\n\n## Use\n\nThe template specified by the `view` property works similar to\nthe [http://www.w3.org/TR/shadow-dom/ W3C Shadow DOM proposal]. It represents the contents\nof a custom element, while being able to reposition the user provided __source__ elements\nwith the [can-component/content] tag.\n\nThere are three things to understand about a [can-component]'s template:\n\n - It is inserted into the component's tag.\n - It is rendered with access to the component instance's viewModel.\n - [can-component/content] tags within the template act as insertion points for the source elements.\n\nThe following example demonstrates all three features:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/my_greeting_full.html'></div>\n\nThe following explains how each part works:\n\n__Component:__\n\n```js\nComponent({\n\ttag: \"my-greeting\",\n\tview: stache(\"<h1><content/></h1>\"),\n\tViewModel: DefineMap.extend({\n\t\ttitle: {\n\t\t\tvalue: \"can-component\"\n\t\t}\n\t}),\n\tleakScope: true\n});\n```\n\nThis registers a component for elements like `<my-greeting>`. Its template\nwill place an `<h1>` element directly within `<my-greeting>` and put\nthe original contents of `<my-greeting>` within the `<h1>`. The component's\n[can-component::ViewModel] adds a title value.\n\n__Source template:__\n\n    <header>\n      <my-greeting>\n         {{site}} - {{title}}\n      </my-greeting>\n    </header>\n\nThe source template is the template that\nuses `<my-greeting>`.  In the demo, this is defined within a `<script>`\ntag.\n\nNotice:\n\n - There is content within `<my-greeting>`.\n - The content looks for a `site` and `title` value.\n\n__Source data:__\n\n\t\tstache(\"...\")({\n\t\t\tsite: \"CanJS\"\n\t\t})\n\nThis is how we render the source template that uses `<my-greeting>`. The template is rendered with `site` in its [can-component::ViewModel].\n\n__HTML Result:__\n\n    <header>\n      <my-greeting>\n        <h1>CanJS - can-component</h1>\n      </my-greeting>\n    </header>\n\nThis is the result of the template transformations. The\ncontent within the original `<my-greeting>` is placed within the `<h1>`\ntag.  Also, notice that the original content is able to access data from\nthe source data and from the component's viewModel.\n\nThe following sections break this down more.\n\n\n## Template insertion\n\nThe template specified by `view` is rendered directly withing the custom tag.\n\nFor example the following component:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1>Hello There</h1>\")\n    });\n\nWith the following source html:\n\n    <header>\n      <my-greeting></my-greeting>\n    </header>\n\nProduces the following html:\n\n    <header>\n      <my-greeting><h1>Hello There</h1></my-greeting>\n    </header>\n\nHowever, if there was existing content within the source html, like:\n\n    <header>\n      <my-greeting>DO REMOVE ME!!!</my-greeting>\n    </header>\n\nthat content is removed, and replaced by the component's template:\n\n    <header>\n      <my-greeting><h1>Hello There</h1></my-greeting>\n    </header>\n\n### The `<content>` element\n\nUse the `<content>` element to place the source content in the\ncomponent's element within the component's\ntemplate. For example, if we change the component to look like:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1><content/></h1>\")\n    });\n\nand rendered with source html, like:\n\n    <my-greeting>Hello World</my-greeting>\n\nit produces:\n\n    <my-greeting><h1>Hello World</h1></my-greeting>\n\n### `<content>` element default content\n\nIf the user does not provide source content, the html\nbetween the `<content>` tags will be used. For example, if we\nchange the component to look like:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1><content>Hello World</content></h1>\")\n    });\n\nand rendered with source html like:\n\n    <my-greeting></my-greeting>\n\nit produces:\n\n    <my-greeting><h1>Hello World</h1></my-greeting>\n\n",
    "description": "\nProvides a template to render directly within the component's tag. The template is rendered with the\ncomponent's [can-component::ViewModel] instance.  [can-component/content] elements within the template are replaced by the source elements within the component's tag.\n",
    "types": [
      {
        "type": "can-stache.renderer",
        "description": "A [can-stache.renderer] returned by [can-stache]. For example:\n\n    Component({\n      tag: \"my-tabs\",\n      view: stache(\"<ul>{{#panels}}<li>{{title}}</li> ...\")\n    });\n\n"
      }
    ],
    "title": "view",
    "name": "can-component.prototype.view",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-connect/base/base": {
    "type": "module",
    "name": "can-connect/base/base",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 1,
      "codeLine": 25,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\nThe `\"base\"` behavior is added automatically to every connection created by `connect`. So even we do:\n\n```\nvar connection = connect([],{});\n```\n\nThe connection still has `\"base\"` functionality:\n\n```\nconnection.id({id: 1}) //-> 1\n```\n\n",
    "description": "\nThe base behavior added to every `connect` behavior.\n",
    "title": "",
    "signatures": [
      {
        "code": "base(options)",
        "description": "\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/base/base.id": {
    "type": "function",
    "name": "can-connect/base/base.id",
    "parent": "can-connect/base/base",
    "src": {
      "line": 27,
      "codeLine": 82,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\nMany extensions, such as the [can-connect/constructor/store/store], need\nto have a unique identifier for an instance or instance data.  The\n`connection.id` method should return that.\n\nTypically, an item's `id` is a simply propertly value on the object.\nFor example, `todo` data might look like:\n\n```js\n{_id: 5, name: \"do the dishes\"}\n```\n\nIn this case, [can-connect/base/base.algebra]'s `id` comparator should be set to\n\"_id\" like:\n\n```js\nvar algebra = new set.Algebra({\n  set.comparators.id(\"_id\")\n});\nconnect([...],{algebra: algebra});\n```\n\nHowever,\nsome data sources have compound ids.  For example, \"Class Assignment\"\nconnection might be represented by two properties, the `studentId` and the\n`classId`.  For this kind of setup, you can provide your own id function as\nfollows:\n\n```js\nvar classAssignmentConnection = connect(['data-url'],{\n  url: \"/class_assignments\",\n  id: function(classAssignment){\n    return classAssignment.studentId+\"-\"+classAssignment.classId;\n  }\n});\n```\n\t \n",
    "description": "\nUniquely identify an instance or raw instance data.\n",
    "title": "id",
    "signatures": [
      {
        "code": "connection.id(instance)",
        "description": "\n\n  Returns the [can-connect/base/base.idProp] if it exists, otherwise the [can-connect/base/base.algebra]'s\n  id values, otherwise the `id` property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "The instance or raw `props` for an instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "Number"
            }
          ],
          "description": "A string or number uniquely representing `instance`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "The instance or raw `props` for an instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Number"
        }
      ],
      "description": "A string or number uniquely representing `instance`.\n"
    },
    "comment": " "
  },
  "can-connect/base/base.idProp": {
    "name": "can-connect/base/base.idProp",
    "type": "property",
    "parent": "can-connect/base/base",
    "src": {
      "line": 103,
      "codeLine": 128,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n## Use\n\n```\nconnect([\n  require(\"can-connect/data/url/url\")\n],{\n  idProp: \"_id\"\n});\n```\n\n\t \n",
    "description": "\n",
    "types": [
      {
        "type": "String",
        "description": "The name of the property that uniquely identifies\nan instance.  Defaults to `\"id\"`.\n"
      }
    ],
    "title": "idProp",
    "deprecated": [
      {
        "version": "0.5.3",
        "description": "Instead of specifying the idProp it should be\nset on the algebra passed to the connection.\n\nSpecifies the property that uniquely identifies an instance.\n"
      }
    ],
    "comment": " "
  },
  "can-connect/base/base.listSet": {
    "type": "function",
    "name": "can-connect/base/base.listSet",
    "parent": "can-connect/base/base",
    "src": {
      "line": 129,
      "codeLine": 164,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\nMany extensions, such as the [can-connect/constructor/store/store], need\nto have a unique identifier for a list.  The\n`connection.listSet` method should return that.\n\nTypically, an item's `set` is an expando property added to\na list.  For example, a list of todos might looks like todos\nafter the following has run:\n\n```\nvar todos = [{_id: 5, name: \"do the dishes\"}]\ntodos.set = {due: 'today'};\n```\n\nIn this case [can-connect/base/base.listSetProp] should be set to `\"set\"`.\n\n\t \n",
    "description": "\nUniquely identify the set a list represents.\n",
    "title": "listSet",
    "signatures": [
      {
        "code": "connection.listSet(list)",
        "description": "\n\n  Returns the [can-connect/base/base.listSetProp] if it exists.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "A list instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object that can be passed to `JSON.stringify`\nto represent the list.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "A list instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object that can be passed to `JSON.stringify`\nto represent the list.\n"
    },
    "comment": " "
  },
  "can-connect/base/base.listSetProp": {
    "name": "can-connect/base/base.listSetProp",
    "type": "property",
    "parent": "can-connect/base/base",
    "src": {
      "line": 167,
      "codeLine": 194,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\n```\nvar connection = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  listSetProp: \"set\"\n});\n\nvar list = [{id: 1, ...}, {id: 2, ...}]\nlist.set = {complete: true};\n\nconnection.listSet(list) //-> {complete: true}\n```\n\n\t \n",
    "description": "\nSpecifies the property that uniquely identifies a list.\n",
    "types": [
      {
        "type": "String",
        "description": "The name of the property that uniquely identifies\nthe list.  Defaults to `\"__listSet\"`.\n"
      }
    ],
    "title": "listSetProp",
    "comment": " "
  },
  "can-connect/base/base.algebra": {
    "body": "\n## Use\n\n```\nvar algebra = new set.Algebra(set.props.range(\"start\",\"end\"));\n\nconnect([...behavior names...],{\n  algebra: algebra\n});\n```\n\t \n",
    "description": "\n",
    "types": [
      {
        "type": "can-set.Algebra",
        "description": "A set algebra that is used by\nmany behaviors to compare the `set` objects passed to\n[can-connect/connection.getListData] and [can-connect/connection.getList]. By\ndefault no algebra is provided.\n"
      }
    ],
    "title": "algebra",
    "name": "can-connect/base/base.algebra",
    "type": "property",
    "parent": "can-connect/base/base",
    "comment": " "
  },
  "can-connect/base/base.cacheConnection": {
    "body": "\n\n## Use\n\n```\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{});\n\nconnect([...behavior names...],{\n  cacheConnection: cacheConnection\n});\n```\n\t \n",
    "description": "\nA connection used for caching.\n",
    "types": [
      {
        "type": "can-connect/DataInterface",
        "description": "A connection that can be used for\n\"Data Interface\" requests. Several behaviors\nlook for this property.  By `cacheConnection` is null.\n"
      }
    ],
    "title": "cacheConnection",
    "name": "can-connect/base/base.cacheConnection",
    "type": "property",
    "parent": "can-connect/base/base",
    "comment": " "
  },
  "can-compute.async": {
    "src": {
      "path": "node_modules/can-compute/docs/async.md"
    },
    "body": "\n\n## Use\n\nThe following compute is a live list of todos for a given \nuserId. `todos` value would alternate between `null` and a Todo.List as `userId` changes.\n\n\n    var userId = compute(5)\n    \n    var todos = compute.async(null, function(oldTodoList, setValue){\n      Todo.findAll({ userId: userId() }, function(todos){\n        setValue(todos)\n      });\n      return null;\n    });\n\n\nThe following replaces the list in place:\n\n    var userId = compute(5)\n    \n    var todos = compute.async(new Todo.List(), function(todoList, setValue){\n      todoList.replace( Todo.findAll({ userId: userId() })\n      return todoList;\n    });\n\n",
    "description": "\nCreate a compute that can set its value after the computed function has been called.\n",
    "title": "async",
    "name": "can-compute.async",
    "type": "function",
    "parent": "can-compute",
    "release": "2.1",
    "hide": true,
    "signatures": [
      {
        "code": "compute.async(initialValue, computed(currentValue, setValue(newValue) )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "The",
            "description": "initial value of the compute.\n"
          },
          {
            "types": [
              {
                "type": "can-compute.asyncComputer"
              }
            ],
            "name": "computed",
            "description": "A function \nthat returns the current value of the compute and can optionally later call \nits `setValue` callback to update the value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "Returns a compute, but a compute that will \npossibly not have the correct value unless it is bound to.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute.asyncComputer"
        }
      ],
      "name": "computed",
      "description": "A function \nthat returns the current value of the compute and can optionally later call \nits `setValue` callback to update the value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "Returns a compute, but a compute that will \npossibly not have the correct value unless it is bound to.\n"
    },
    "comment": " "
  },
  "can-compute.asyncComputer": {
    "src": {
      "path": "node_modules/can-compute/docs/async_computer.md"
    },
    "body": "\n",
    "description": "\nA function that determines a value for an [can-compute.async async compute].\n",
    "type": "typedef",
    "title": "asyncComputer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "If a `setVal` argument is not provided, the return value\nis set as the current value of the compute.  If `setVal` is provided and\nundefined is returned, the current value remains until `setVal` is called.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The last set value of the compute.  This should be returned\nif you are doing an in-place compute. \n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "setVal",
            "description": "Called to update the value \nof the compute at a later time. \n"
          }
        ],
        "description": "The function callback to [can-compute.async] that determines\nthe value of the compute.\n"
      }
    ],
    "name": "can-compute.asyncComputer",
    "parent": "can-compute",
    "release": "2.1",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newVal"
            }
          ]
        }
      ],
      "optional": true,
      "name": "setVal",
      "description": "Called to update the value \nof the compute at a later time. \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "If a `setVal` argument is not provided, the return value\nis set as the current value of the compute.  If `setVal` is provided and\nundefined is returned, the current value remains until `setVal` is called.\n"
    }
  },
  "can-compute.computed.ChangeEvent": {
    "src": {
      "path": "node_modules/can-compute/docs/change.md"
    },
    "body": "\n```js\nvar age = compute(33);\n\nage.on('change', function(){\n\tconsole.log('Now:', age());\n});\n\nage(34);\n```\n\n",
    "description": "\nEvent fired when the value of the [can-compute.computed] changes.\n",
    "type": "typedef",
    "title": "change",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-compute.computed.ChangeEvent",
    "parent": "can-compute/computed/events"
  },
  "can-compute.computeSettings": {
    "src": {
      "path": "node_modules/can-compute/docs/compute_settings.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "computeSettings",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "description": "A function that retrieves and returns the current value of the compute."
          },
          {
            "name": "set",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "description": "A function that is used when setting a new value of the compute.\n\nA function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can-computed] and the current value. If\n`set` returns a value, it is used to compare to the current value of the compute. Otherwise,\n`get` is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.\n\n`newVal` is the value being set, while `oldVal` is the previous value in the compute.\n"
          },
          {
            "name": "on",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ],
                    "name": "updated"
                  }
                ]
              }
            ],
            "description": "Called to setup binding to dependency events. Call `updated` when the compute's value needs to be updated.\n"
          },
          {
            "name": "off",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "Called to teardown binding.\n"
          }
        ]
      }
    ],
    "name": "can-compute.computeSettings",
    "release": "2.1",
    "parent": "can-compute"
  },
  "can-compute/computed/events": {
    "name": "can-compute/computed/events",
    "title": "events",
    "type": "group",
    "parent": "can-compute.computed",
    "description": "",
    "order": 0
  },
  "can-compute/computed/methods": {
    "name": "can-compute/computed/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-compute.computed",
    "description": "",
    "order": 0
  },
  "can-compute.computed": {
    "src": {
      "path": "node_modules/can-compute/docs/computed.md"
    },
    "body": "\n## Use\n\nA compute instance is created with [can-compute] and used as an observable value. Computes are useful to provide a value representative of multiple other observables:\n\n```js\nvar person = new Person({\n\tfirst: \"Matthew\",\n\tlast: \"Phillips\"\n});\n\nvar fullName = compute(function(){\n\treturn person.first + \" \" + person.last;\n});\n\nconsole.log(fullName()); // -> \"Matthew Phillips\".\n```\n\nCalling the compute with a value will cause it to run as a setter function:\n\n```js\nvar count = compute(0);\n\nconsole.log(count()); // -> 0\n\ncount(5);\n\nconsole.log(count()); // -> 5\n```\n\nThis depends on how the [can-compute getterSetter] is defined, and can adjust how it handles setters:\n\n```js\nvar plusOne = compute(function(val){\n\tif(val) {\n\t\treturn val + 1;\n\t} else {\n\t\treturn 1;\n\t}\n});\n\nconsole.log(plusOne()); // -> 1\n\nplusOne(5);\n\nconsole.log(plusOne()); // -> 6\n```\n\n",
    "description": "A derived value from other computes and observable maps. \n",
    "title": "compute()",
    "name": "can-compute.computed",
    "type": "function",
    "parent": "can-compute",
    "signatures": [
      {
        "code": "compute([newVal])",
        "description": "\n\nGets the compute's value if no arguments are provided, otherwise calls the compute's setter with the value passed as the first argument.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "If the compute is called with an argument, the first argument is used\nto set the compute to a new value. This may trigger a\n`\"change\"` event that can be listened for with [can-computed.bind].\n\nIf the compute is called without any arguments (`compute()`), it simply returns\nthe current value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The current value of the compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "newVal",
      "description": "If the compute is called with an argument, the first argument is used\nto set the compute to a new value. This may trigger a\n`\"change\"` event that can be listened for with [can-computed.bind].\n\nIf the compute is called without any arguments (`compute()`), it simply returns\nthe current value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The current value of the compute.\n"
    },
    "comment": " "
  },
  "can-compute.computed.on": {
    "src": {
      "path": "node_modules/can-compute/docs/on.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "compute().on",
    "name": "can-compute.computed.on",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.on(eventType, handler)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-connect/cache-requests/cache-requests.data": {
    "name": "can-connect/cache-requests/cache-requests.data",
    "title": "Data Interface",
    "type": "group",
    "parent": "can-connect/cache-requests/cache-requests",
    "description": "",
    "order": 0
  },
  "can-connect/cache-requests/cache-requests.algebra": {
    "name": "can-connect/cache-requests/cache-requests.algebra",
    "title": "Algebra",
    "type": "group",
    "parent": "can-connect/cache-requests/cache-requests",
    "description": "",
    "order": 0
  },
  "can-connect/cache-requests/cache-requests": {
    "type": "module",
    "name": "can-connect/cache-requests/cache-requests",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 7,
      "codeLine": 98,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n\n## Use\n\nUse `cache-requests` in combination with a cache\nlike [can-connect/data/memory-cache/memory-cache] or [can-connect/data/localstorage-cache/localstorage-cache].  For example,\n\n```\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/cache-requests/cache-requests\")\n],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\"\n})\n```\n\nThis will make it so response data is cached in memory.  For example, if\ntoday's todos are loaded:\n\n```\ntodoConnection.getListData({due: \"today\"})\n```\n\nAnd later, a subset of those todos are loaded:\n\n```\ntodoConnection.getListData({due: \"today\", status: \"critical\"})\n```\n\nThe original request's data will be used.\n\n## Using Algebra\n\n`cache-requests` can also \"fill in\" the data the cache is mising if you provide\nit the necessary [set algebra](https://github.com/canjs/can-set).\n\nFor example, if you requested paginated data like:\n\n```\ntodoConnection.getListData({start: 1, end: 10})\n```\n\nAnd then later requested:\n\n```\ntodoConnection.getListData({start: 1, end: 20})\n```\n\n... with the appropriate configuration, `cache-requests` will only request `{start: 11, end: 20}`.\nThat configuration looks like:\n\n```\nvar algebra = new set.Algebra( set.comparators.range(\"start\",\"end\") );\n\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{algebra: algebra});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/cache-requests/cache-requests\")\n],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\",\n  algebra: algebra\n})\n```\n\nNotice that `cacheConnection`s often share many of the same options as the\nprimary connection.\n\n",
    "description": "\nCaches reponse data and uses it to prevent future requests or make future requests smaller.\n",
    "title": "",
    "signatures": [
      {
        "code": "cacheRequests( baseConnection )",
        "description": "\n\n  Overwrites [can-connect/cache-requests/cache-requests.getListData] to use set logic to\n  determine which data is already in [can-connect/base/base.cacheConnection] or needs to be loaded from the base connection.\n\n  It then gets data from the cache and/or the base connection, merges it, and returns it.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/cache-requests/cache-requests.getDiff": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getDiff",
    "parent": "can-connect/cache-requests/cache-requests.algebra",
    "src": {
      "line": 102,
      "codeLine": 143,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nCompares the available set data to the requested data and returns\nthe data that should be loaded from the cache and the data loaded\nfrom the base connection.\n",
    "title": "getDiff",
    "signatures": [
      {
        "code": "connection.getDiff( set, availableSets )",
        "description": "\n\n  This attempts to find the minimal amount of data to load by\n  going through each `availableSet` and doing a [subset](https://github.com/canjs/can-set#setsubset)\n  test and a [set difference](https://github.com/canjs/can-set#setdifference) with\n  `set`.\n\n  If `set` is a subset of an `availableSet`, `{cached: set}` will be returned.\n\n  If there is a difference of `set` and an `availableSet`, the difference\n  will be what's `needed`.  The intersection of `set` and that\n  `availableSet` will be what's `cached`.  A `count` will be taken of\n  what's `needed` resulting in an object like:\n\n  ```\n  {\n    needed: {start: 50, end: 99},\n    cached: {start: 0, end: 49},\n    count: 49\n  }\n  ```\n\n  Finally, `getDiff` will pick the diff objet with the lowest count. If there\n  is no diff object, `{needed: set}` is returned.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set that is being loaded."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Set"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "availableSets",
            "description": "An array of available sets in the\n[can-connect/base/base.cacheConnection]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": [
                        {
                          "name": "needs",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        },
                        {
                          "name": "cached",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Set"
                }
              ]
            }
          ]
        }
      ],
      "name": "availableSets",
      "description": "An array of available sets in the\n[can-connect/base/base.cacheConnection]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": [
                    {
                      "name": "needs",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    },
                    {
                      "name": "cached",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\n\n\t "
    }
  },
  "can-connect/cache-requests/cache-requests.getUnion": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getUnion",
    "parent": "can-connect/cache-requests/cache-requests.algebra",
    "src": {
      "line": 181,
      "codeLine": 198,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nReturns the union of the cached and needed data.\n",
    "title": "getUnion",
    "signatures": [
      {
        "code": "connection.getUnion(set, diff, neededData, cachedData)",
        "description": "\n\n  Uses [can-set.getUnion](https://github.com/canjs/can-set#setgetunion) to merge the two sets.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set requested."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "diff",
            "description": "The result of [can-connect/cache-requests/cache-requests.getDiff]."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "neededData",
            "description": "The data loaded from the base connection."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "cachedData",
            "description": "The data loaded from the [can-connect/base/base.cacheConnection].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "Return the merged cached and requested data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "name": "cachedData",
      "description": "The data loaded from the [can-connect/base/base.cacheConnection].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "Return the merged cached and requested data.\n\t "
    }
  },
  "can-connect/cache-requests/cache-requests.getListData": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getListData",
    "parent": "can-connect/cache-requests/cache-requests.data",
    "src": {
      "line": 202,
      "codeLine": 220,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nOnly request data that hasn't already been loaded by [can-connect/base/base.cacheConnection].\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Overwrites a base connection's `getListData` to use data in the [can-connect/base/base.cacheConnection]\n  whenever possible.  This works by [can-connect/connection.getSets getting the stored sets] and doing a\n  [can-connect/cache-requests/cache-requests.getDiff diff] to see what should be loaded from the cache\n  or from the base connection.\n\n  With that information, this `getListData` requests data from the cache and/or the base\n  connection.  Once it has been recieved, it combines the data with [can-connect/cache-requests/cache-requests.getUnion].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.data": {
    "name": "can-connect/fall-through-cache/fall-through-cache.data",
    "title": "Data Callbacks",
    "type": "group",
    "parent": "can-connect/fall-through-cache/fall-through-cache",
    "description": "",
    "order": 0
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrators": {
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "title": "Hydrators",
    "type": "group",
    "parent": "can-connect/fall-through-cache/fall-through-cache",
    "description": "",
    "order": 0
  },
  "can-connect/fall-through-cache/fall-through-cache": {
    "name": "can-connect/fall-through-cache/fall-through-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 71,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n\n## Use\n\nTo use the `fall-through-cache`, create a connection with a\n[can-connect/base/base.cacheConnection] and a behavior that implements\n[can-connect/connection.getData] and [can-connect/connection.getListData].\n\n```\nvar cache = connect([\n  require(\"can-connect/data/localstorage-cache/localstorage-cache\")\n],{\n  name: \"todos\"\n});\n\nvar todoConnection = connect([\n   require(\"can-connect/fall-through-cache/fall-through-cache\"),\n   require(\"can-connect/data/url/url\"),\n   require(\"can-connect/constructor/constructor\"),\n   require(\"can-connect/constructor/store/store\")\n  ], {\n  url: \"/todos\",\n  cacheConnection: cache\n});\n```\n\nThen, make requests.  If the cache has the data,\nit will be returned immediately, and then the item or list updated later\nwith the response from the base connection:\n\n```\ntodoConnection.getList({due: \"today\"}).then(function(todos){\n\n})\n```\n\n## Demo\n\nThe following shows the `fall-through-cache` behavior.\n\n<div class='demo_wrapper' data-demo-src='../../demos/can-connect/fall-through-cache.html'></div>\n\nClicking\n\"Completed\" or \"Incomplete\" will make one of the following requests and\ndisplay the results in the page:\n\n```\ntodoConnection.getList({completed: true});\ntodoConnection.getList({completed: false});\n```\n\nIf you click back and forth between \"Completed\" and \"Incomplete\" multiple times\nyou'll notice that the old data is displayed immediately and then\nupdated after about a second.\n\n\n",
    "description": "\nA fall through cache that checks another `cacheConnection`.\n",
    "title": "",
    "signatures": [
      {
        "code": "fallThroughCache( baseConnection )",
        "description": "\n\n  Implements a `getData` and `getListData` that\n  check their [can-connect/base/base.cacheConnection] for data and then\n  in the background update the instance or list with data\n  retrieved using the base connection.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrateList": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrateList",
    "parent": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "src": {
      "line": 77,
      "codeLine": 94,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nReturns a List instance given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList(listData, set)",
        "description": "\n\n  Calls the base `hydrateList` to create a List for `listData`.\n\n  Then, Looks for registered hydrateList callbacks for a given `set` and\n  calls them.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.getListData": {
    "src": {
      "line": 115,
      "codeLine": 142,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nGet raw data from the cache if available, and then update\nthe list later with data from the base connection.\n",
    "title": "getListData",
    "name": "can-connect/fall-through-cache/fall-through-cache.getListData",
    "parent": "can-connect/fall-through-cache/fall-through-cache.data",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Checks the [can-connect/base/base.cacheConnection] for `set`'s data.\n\n  If the cache connection has data, the cached data is returned. Prior to\n  returning the data, the [can-connect/constructor.hydrateList] method\n  is intercepted so we can get a handle on the list that's being created\n  for the returned data. Once the intercepted list is retrieved,\n  we use the base connection to get data and update the intercepted list and\n  the cacheConnection.\n\n  If the cache connection does not have data, the base connection\n  is used to load the data and the cached connection is updated with that\n  data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that returns the\nraw data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that returns the\nraw data.\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrateInstance": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrateInstance",
    "parent": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "src": {
      "line": 183,
      "codeLine": 199,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nReturns an instance given raw data.\n",
    "title": "hydrateInstance",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  Calls the base `hydrateInstance` to create an Instance for `props`.\n\n  Then, Looks for registered hydrateInstance callbacks for a given [can-connect/base/base.id] and\n  calls them.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.getData": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.getData",
    "parent": "can-connect/fall-through-cache/fall-through-cache.data",
    "src": {
      "line": 219,
      "codeLine": 246,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nGet raw data from the cache if available, and then update\nthe instance later with data from the base connection.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Checks the [can-connect/base/base.cacheConnection] for `params`'s data.\n\n  If the cache connection has data, the cached data is returned. Prior to\n  returning the data, the [can-connect/constructor/constructor.hydrateInstance] method\n  is intercepted so we can get a handle on the instance that's being created\n  for the returned data. Once the intercepted instance is retrieved,\n  we use the base connection to get data and update the intercepted instance and\n  the cacheConnection.\n\n  If the cache connection does not have data, the base connection\n  is used to load the data and the cached connection is updated with that\n  data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "The set to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that returns the\nraw data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "The set to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that returns the\nraw data.\n\t "
    }
  },
  "can-connect/constructor/constructor.crud": {
    "name": "can-connect/constructor/constructor.crud",
    "title": "CRUD Methods",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 0
  },
  "can-connect/constructor/constructor.callbacks": {
    "name": "can-connect/constructor/constructor.callbacks",
    "title": "CRUD Callbacks",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 1
  },
  "can-connect/constructor/constructor.hydrators": {
    "name": "can-connect/constructor/constructor.hydrators",
    "title": "Hydrators",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 2
  },
  "can-connect/constructor/constructor.serializers": {
    "name": "can-connect/constructor/constructor.serializers",
    "title": "Serializers",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 3
  },
  "can-connect/constructor/constructor.helpers": {
    "name": "can-connect/constructor/constructor.helpers",
    "title": "Helpers",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 4
  },
  "can-connect/constructor/constructor": {
    "name": "can-connect/constructor/constructor",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 2,
      "codeLine": 94,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nThe `can-connect/constructor/constructor` behavior allows you to hydrate the raw, serialized representation of\nyour application's data into a typed representation with additional methods and behaviors.\n\nFor example, you might want to be able to load data as a particular JavaScript Constructor\nfunction that has a helper methods that act upon the serialized data.\n\nAn example might be loading data from a `\"/todos\"` service and being able to call `.timeLeft()`\non the todos that you get back like:\n\n```\ntodoConnection.get({id: 6}).then(function(todo){\n  todo.timeLeft() //-> 60000\n})\n```\n\nThe following creates a `todoConnection` that does exactly that:\n\n```\nvar Todo = function(data){\n  for(var prop in data) {\n   this[prop] = data;\n  }\n};\nTodo.prototype.timeLeft = function(){\n  return new Date() - this.dueDate\n};\n\nvar todoConnection = connect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\"\n  instance: function(data){\n    return new Todo(data);\n  }\n});\n```\n\nThe `constructor` extension is still useful even if you want to keep your data as plain\nJavaScript objects (which its default behavior).  The `constructor` extension describes\nthe in-memory representation of your data on the client.  Other extensions need to know this\nrepresentation for advanced behavior like [can-connect/real-time/real-time] or [can-connect/fall-through-cache/fall-through-cache].\n\n## CRUD Methods\n\nThe `constructor` extension supplies methods that create, read, update and\ndelete (CRUD) typed representations of raw connection data.\n\n## CRUD Callbacks\n\nThe `constructor` function \"CRUD Methods\" call \"CRUD Callbacks\" with the\nthe \"data interface\" response data. These callbacks update the state of\nthe typed representation.\n\n## Instantaitors\n\nThese methods are used to create a typed instance or typed list given raw \"data interface\"\nobjects.\n\n## Serializers\n\nThese methods convert the typed instance or typed list into a representation for the\n\"data interface\".\n\n\n\n",
    "description": "\nAdds the ability to operate on special types instead of plain JavaScript Objects\nand Arrays.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructor(baseConnection)",
        "description": "\n\nAdds methods that allow the connection to operate on special types.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "connection"
              }
            ],
            "name": "baseConnection",
            "description": "A connection with most of the\n[can-connect/DataInterface] implemented.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "connection"
            }
          ],
          "description": "A new connection with the additional methods.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "connection"
        }
      ],
      "name": "baseConnection",
      "description": "A connection with most of the\n[can-connect/DataInterface] implemented.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "connection"
        }
      ],
      "description": "A new connection with the additional methods.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.cidStore": {
    "name": "can-connect/constructor/constructor.cidStore",
    "type": "property",
    "parent": "can-connect/constructor/constructor.helpers",
    "src": {
      "line": 108,
      "codeLine": 119,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nA WeakReferenceMap that contains instances being created by their `._cid` property.\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "\n\n  The `cidStore` is used to temporarily hold references to instances by [can-util/js/cid/cid] that don't\n  yet have an id which are in the process of being created.\n\t "
      }
    ],
    "title": "cidStore"
  },
  "can-connect/constructor/constructor.get": {
    "type": "function",
    "name": "can-connect/constructor/constructor.get",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 122,
      "codeLine": 151,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nCall `.get()` with the parameters that identify the instance\nyou want to load.  `.get()` will return a promise that resolves\nto your instance.\n\n```\ntodoConnection.get({id: 6}).then(function(todo){ })\n```\n\n\t \n",
    "description": "\nGet a single instance from the \"data interface\".\n",
    "title": "get",
    "signatures": [
      {
        "code": "connection.get(set)",
        "description": "\n\n  Gets an instance from [can-connect/connection.getData] and runs the resulting data\n  through [can-connect/constructor/constructor.hydrateInstance].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An instance that represents the data that was loaded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "An instance that represents the data that was loaded.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.getList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.getList",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 158,
      "codeLine": 187,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nCall `.getList()` with the parameters that identify the instance\nyou want to load.  `.getList()` will return a promise that resolves\nto your instance.\n\n```\ntodoConnection.getList({due: 'today'}).then(function(todos){ })\n```\n\n\t \n",
    "description": "\nGet a single instance from the \"data interface\".\n",
    "title": "getList",
    "signatures": [
      {
        "code": "connection.getList(set)",
        "description": "\n\n  Gets an instance from [can-connect/connection.getListData] and runs the resulting data\n  through [can-connect/constructor.hydrateList].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "List",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Instance"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An instance that represents the data that was loaded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "List",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Instance"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "An instance that represents the data that was loaded.\n"
    },
    "comment": " "
  },
  "can-connect/constructor.hydrateList": {
    "type": "function",
    "name": "can-connect/constructor.hydrateList",
    "parent": "can-connect/constructor/constructor.hydrators",
    "src": {
      "line": 196,
      "codeLine": 213,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nMakes a list type object given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList(listData, set)",
        "description": "\n\n  Calls [can-connect/constructor/constructor.hydrateInstance] with each raw instance data item and then\n  calls [can-connect/constructor/constructor.list] with an array of the instances.  If [can-connect/constructor/constructor.list]\n  is not provided, a normal array is used.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "Raw list data."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set used to retrieve the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "The data type used to represent the list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set used to retrieve the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "The data type used to represent the list.\n\t "
    }
  },
  "can-connect/constructor/constructor.hydrateInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.hydrateInstance",
    "parent": "can-connect/constructor/constructor.hydrators",
    "src": {
      "line": 233,
      "codeLine": 248,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nMakes a type object given raw data.\n",
    "title": "hydrateInstance",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  If [can-connect/constructor/constructor.instance] is available passes `props` to that\n  and returns that value.  Otherwise, returns a clone of `props`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties returned by [can-connect/connection.getData].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "The data type used to represent the list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties returned by [can-connect/connection.getData].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "The data type used to represent the list.\n\t "
    }
  },
  "can-connect/constructor/constructor.save": {
    "type": "function",
    "name": "can-connect/constructor/constructor.save",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 255,
      "codeLine": 346,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n## Use\n\nTo use `save`, create a connection, then an instance, and call `.save()` with it.\n\n```\n// Create a connection:\nvar todoConnection = connect([\n  require('can-connect/constructor/constructor'),\n  require('can-connect/data/url/url')\n],{\n  url: \"/todos\"\n})\n\n// Create an instance:\nvar todo = {name: \"do dishes\"};\n\n// Call .save():\ntodoConnection.save(todo)\n```\n\nThis will POST to `/todos` with the `todo` data.  The server response data\nmight look something like:\n\n```\n{\n id: 5,\n ownerId: 9\n}\n```\n\nThis data will be passed to [can-connect/constructor/constructor.createdInstance] which will default\nto adding those properties to `todo`, resulting in `todo` looking like:\n\n```\n{\n name: \"do dishes\",\n id: 5,\n ownerId: 9\n}\n```\n\nTo update the todo, change a property and call `.save()` again:\n\n```\n// Change a property:\ntodo.name = \"Do dishes!!\";\n\n// Call .save()\ntodoConnection.save(todo)\n```\n\nThis will PUT to `/todos` with the `todo` data.  The server response data\nshould look something like:\n\n```\n{\n name: \"Do dishes!!\",\n id: 5,\n ownerId: 9\n}\n```\n\nThis data will be passed to [can-connect/constructor/constructor.updatedInstance] which will default\nto setting all of `todos` properties to look like the response data.\n\t \n",
    "description": "Creates or updates an instance using the underlying data interface. \n",
    "title": "save",
    "signatures": [
      {
        "code": "connection.save( instance )",
        "description": "\n\n  Checks if the instance has an [can-connect/base/base.id] or not.  If it\n  has an id, the instance will be updated; otherwise, it will be created.\n\n  To create an instance, the instance is added to the [can-connect/constructor.cidStore],\n  and its [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.createData].  If `createData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor/constructor.createdInstance] is called.\n\n  To update an instance, its [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.updateData]. If `updateData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor/constructor.updatedInstance] is called.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to create or save.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "resolves to the same instance that was passed to `save`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to create or save.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "resolves to the same instance that was passed to `save`.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.destroy": {
    "src": {
      "line": 376,
      "codeLine": 422,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "type": "function",
    "body": "\n## Use\n\nTo use `destroy`, create a connection, then retrieve an instance, and call `.destroy()` with it.\n\n```\n// Create a connection:\nvar todoConnection = connect([\n  require('can-connect/constructor/constructor'),\n  require('can-connect/data/url/url')\n],{\n  url: \"/todos\"\n})\n\n// Get a todo instance\ntodoConnection.get({id: 5}).then(function(todo){\n  // Call .destroy():\n  todoConnection.destroy(todo)\n});\n```\n\nThis will DELETE to `/todos/5` with the `todo` data.  The server response data\nmight look something like:\n\n```\n{}\n```\n\nThis data will be passed to [can-connect/constructor/constructor.destroyedInstance].\n\t \n",
    "description": "Destroys an instance using the underlying data interface. \n",
    "title": "destroy",
    "name": "can-connect/constructor/constructor.destroy",
    "parent": "can-connect/constructor/constructor.crud",
    "signatures": [
      {
        "code": "connection.destroy( instance )",
        "description": "\n\n  To destroy an instance, its [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.destroyData]. If `destroyData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor/constructor.destroyedInstance] is called.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to create or save.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "resolves to the same instance that was passed to `save`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to create or save.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "resolves to the same instance that was passed to `save`.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.createdInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.createdInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 436,
      "codeLine": 450,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being created with the result of [can-connect/connection.createData].\n",
    "title": "createdInstance",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n  Adds every property and value in `props` to `instance`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.createData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.createData].\n\t "
    }
  },
  "can-connect/constructor/constructor.updatedInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.updatedInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 453,
      "codeLine": 468,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being updated with the result of [can-connect/connection.updateData].\n",
    "title": "updatedInstance",
    "signatures": [
      {
        "code": "connection.updatedInstance( instance, props )",
        "description": "\n\n  Sets the properties in `instance` to match the properties and values in `props`\n  with the exception of [can-connect/base/base.idProp], which it leaves alone.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.updateData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.updateData].\n\t "
    }
  },
  "can-connect/constructor/constructor.updatedList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.updatedList",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 471,
      "codeLine": 489,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates a list with new data.\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedList( list, listData, set )",
        "description": "\n\n  [can-connect/constructor/constructor.hydrateInstance Hydrates] instances with `listData`'s data\n  and attempts to merge them into `list`.  The merge is able to identify simple insertions\n  and removals of elements instead of replacing the entire list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "list",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The raw data usd to update `list`.\n"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set of data `listData` represents.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set of data `listData` represents.\n\t "
    }
  },
  "can-connect/constructor/constructor.destroyedInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.destroyedInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 501,
      "codeLine": 516,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being destroyed with the result of [can-connect/connection.destroyData].\n",
    "title": "destroyedInstance",
    "signatures": [
      {
        "code": "connection.destroyedInstance( instance, props )",
        "description": "\n\n  Sets the properties in `instance` to match the properties and values in `props`\n  with the exception of [can-connect/base/base.idProp], which it leaves alone.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.destroyData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.destroyData].\n\t "
    }
  },
  "can-connect/constructor/constructor.serializeInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.serializeInstance",
    "parent": "can-connect/constructor/constructor.serializers",
    "src": {
      "line": 519,
      "codeLine": 533,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "",
    "description": "Returns the serialized form of an instance. \n",
    "title": "serializeInstance",
    "signatures": [
      {
        "code": "connection.serializeInstance( instance )",
        "description": "\n\n  This implementation simply clones the `instance` object.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to serialize.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A serialized representation of the instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to serialize.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A serialized representation of the instance.\n\t "
    }
  },
  "can-connect/constructor/constructor.serializeList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.serializeList",
    "parent": "can-connect/constructor/constructor.serializers",
    "src": {
      "line": 536,
      "codeLine": 552,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "",
    "description": "Returns the serialized form of an list. \n",
    "title": "serializeList",
    "signatures": [
      {
        "code": "connection.serializeList( list )",
        "description": "\n\n  This implementation simply returns an `Array` containing the result of\n  [can-connect/constructor/constructor.serializeInstance] called on each item in the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The instance to serialize.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "A serialized representation of the list.\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "The instance to serialize.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "A serialized representation of the list.\n\n\t "
    }
  },
  "can-connect/constructor/constructor.isNew": {
    "type": "function",
    "name": "can-connect/constructor/constructor.isNew",
    "parent": "can-connect/constructor/constructor.helpers",
    "src": {
      "line": 558,
      "codeLine": 571,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nReturns if this instance has not been persisted.\n",
    "title": "isNew",
    "signatures": [
      {
        "code": "connection.isNew(instance)",
        "description": "\n\n  Checks that the instance has an [can-connect/base/base.id].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "The instance to test."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the instance has not been persisted.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "The instance to test."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the instance has not been persisted.\n\t "
    }
  },
  "can-connect/constructor/constructor.list": {
    "body": "\n\n## Use\n\nIf you have a special type of list with helper functions you'd like to have available,\nyou can do that in `list`.  The following makes it so `getList` resolves to array-like\nobjects that have a `completed` function.\n\n```\nvar MyList = Object.create(Array.prototype);\nMyList.prototype.completed = function(){\n  return this.filter(function(){ return this.completed });\n};\n\nvar todosConnection = connect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"todos\",\n  list: function(listData, set){\n    var collection = Object.create(MyList);\n    Array.apply(collection, listData.data);\n    collection.__listSet = set;\n    return collection;\n  }\n});\n```\n\nThis allows:\n\n```\ntodosConnection.getList({}).then(function(todos){\n  console.log(\"There are\",todos.completed().length, \"completed todos\")\n});\n```\n\n\nNotice that we added the default [can-connect/base/base.listSetProp] (`__listSet`) data on the list. This is useful\nfor other extensions.\n\n\t \n",
    "description": "\nReturns the data in its typed list form.\n",
    "title": "list",
    "name": "can-connect/constructor/constructor.list",
    "type": "property",
    "parent": "can-connect/constructor/constructor.hydrators",
    "signatures": [
      {
        "code": "connection.list( listInstanceData, set )",
        "description": "\n\n  Takes an object with a data property that is an array of instances returned by\n  [can-connect/constructor/constructor.hydrateInstance] and should return the right type of list.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": [
                  {
                    "name": "data",
                    "types": [
                      {
                        "type": "Array",
                        "template": [
                          {
                            "types": [
                              {
                                "type": "Instance"
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "listInstanceData",
            "description": "An object that contains an array\nof instances.\n"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set this list belongs to.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "The instances in the special list type.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set this list belongs to.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "The instances in the special list type.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.instance": {
    "src": {
      "line": 636,
      "codeLine": 688,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\nIf you have a special type with helper functions you'd like to have available,\nyou can convert raw data to that type in `instance`.  The following makes it so\n[can-connect/constructor/constructor.get .get] resolves to objects with a `complete` method.\n\n```\nTodo = function(props){\n  Object.assign(this, props);\n};\nTodo.prototype.complete = function(){\n  this.completed = true;\n}\n\nvar todosConnection = connect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"todos\",\n  instance: function( props ) {\n    return new Todo(props);\n  }\n});\n```\n\nThis allows:\n\n```\ntodosConnection.get({id: 5}).then(function(todo){\n  todo.complete();\n});\n```\n\n\t \n",
    "description": "\nReturns the typed form of the raw data.\n",
    "title": "instance",
    "name": "can-connect/constructor/constructor.instance",
    "parent": "can-connect/constructor/constructor.hydrators",
    "signatures": [
      {
        "code": "connection.instance( props )",
        "description": "\n\n  Takes raw data and runs it through [can-connect/constructor/constructor.hydrateInstance].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "The typed instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "The typed instance.\n"
    },
    "comment": " "
  },
  "can-connect/service-worker": {
    "type": "module",
    "name": "can-connect/service-worker",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect.behaviors",
    "src": {
      "line": 4,
      "codeLine": 9,
      "path": "node_modules/can-connect/service-worker/service-worker.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "hide": true
  },
  "getListData": {
    "type": "function",
    "name": "getListData",
    "params": [
      {
        "name": "params",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 2,
      "codeLine": 6,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "",
    "description": "Get a list of instances\n",
    "returns": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "getData": {
    "type": "function",
    "name": "getData",
    "params": [
      {
        "name": "params",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 9,
      "codeLine": 13,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "",
    "description": "Get an instance\n",
    "returns": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "parseListData": {
    "type": "function",
    "name": "parseListData",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "listData",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 49,
      "codeLine": 55,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "\n",
    "description": "Provided by parse-data\n",
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "listData",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An array that represents the data\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An array that represents the data\n "
    }
  },
  "parseInstanceData": {
    "type": "function",
    "name": "parseInstanceData",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "instanceData",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 56,
      "codeLine": 62,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "\n",
    "description": "Provided by parse-data\n",
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "instanceData",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object of properties on the object\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object of properties on the object\n "
    }
  },
  "can-connect/real-time/real-time.methods": {
    "name": "can-connect/real-time/real-time.methods",
    "title": "Methods",
    "type": "group",
    "parent": "can-connect/real-time/real-time",
    "description": "",
    "order": 0
  },
  "can-connect/real-time/real-time.callbacks": {
    "name": "can-connect/real-time/real-time.callbacks",
    "title": "Data Callbacks",
    "type": "group",
    "parent": "can-connect/real-time/real-time",
    "description": "",
    "order": 1
  },
  "can-connect/real-time/real-time": {
    "name": "can-connect/real-time/real-time",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 131,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n\n## Use\n\nTo use `real-time`, create a connection with its dependent\nbehaviors like:\n\n```\nvar todoConnection = connect(\n   [\"real-time\",\n    \"constructor\",\n    \"constructor-store\",\n    \"constructor-callbacks-once\",\n    \"data-url\"],{\n  url: \"/todos\"\n});\n```\n\nNext, use the connection to load lists and save those lists in the\nstore:\n\n```\ntodoConnection.getList({complete: false}).then(function(todos){\n  todoConnection.addListReference(todos);\n})\n```\n\nFinally, use one of the  [can-connect/real-time/real-time.createInstance],\n[can-connect/real-time/real-time.updateInstance], and\n[can-connect/real-time/real-time.destroyInstance] methods to tell the connection\nthat data has changed.  The connection will update (by calling splice)\neach list accordingly.\n\n\n## Example\n\nThe following demo shows two lists that use this connection.  The\n\"Run Code\" button sends the connection data changes which the\nconnection will then update lists accordingly:\n\n\n<div class='demo_wrapper' data-demo-src='../../demos/can-connect/real-time.html'></div>\n\nThis example creates a `todoList` function and `todoItem` function\nthat manage the behavior of a list of todos and a single todo respectfully.\nIt uses [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe)\nto observe changes in the todo list and individual todo data. Other\nframeworks will typically provide their own observable system.\n\n### todoList\n\nWhen `todoList` is created, it is passed the `set` of data to load.  It uses\nthis to get todos from the `todoConnection` like:\n\n\n```\ntodosConnection.getList(set).then(function(retrievedTodos){\n```\n\nIt then adds those `todos` to the [can-connect/constructor/store/store.listStore] so\nthey can be updated automatically.  And, it listens to changes in `todos` and calls an `update` function:\n\n```\ntodosConnection.addListReference(todos);\nObject.observe(todos, update, [\"add\", \"update\", \"delete\"] );\n```\n\nThe update function is able to inserted new `todoItem`s in the page when items are added\nto or removed from `todos`.  We exploit that by calling `update` as if it just added\neach todo in the list:\n\n```\nupdate(todos.map(function(todo, i){\n  return {\n    type: \"add\",\n    name: \"\"+i\n  };\n}));\n```\n\n### todoItem\n\nThe `todoItem` creates an element that updates with changes\nin its `todo`.  It listens to changes in the `todo` and saves\nthe todo in the [can-connect/constructor/store/store.instanceStore] with the\nfollowing:\n\n```\nObject.observe(todo, update, [\"add\", \"update\", \"delete\"] );\ntodosConnection.addInstanceReference(todo);\n```\n\nA `todoItem` needs to be able to stop listening on the `todo` and remove itself from the\n`instanceStore` if the `todo` is removed from the page.  To provide this teardown\nfunctionality, `todoItem` listens to a `\"removed\"` event on its element and\n`unobserves` the todo and removes it from the `instanceStore`:\n\n```\n$(li).bind(\"removed\", function(){\n  Object.unobserve(todo, update, [\"add\", \"update\", \"delete\"] );\n  todosConnection.deleteInstanceReference(todo);\n});\n```\n\n",
    "description": "\nUpdate lists to include or exclude instances based\non set logic.\n",
    "title": "",
    "signatures": [
      {
        "code": "realTime( baseConnection )",
        "description": "\n\n  Overwrites the \"data callback\" methods and provides\n  [can-connect/real-time/real-time.createInstance],\n  [can-connect/real-time/real-time.updateInstance], and\n  [can-connect/real-time/real-time.destroyInstance] methods\n  that\n  update lists to include or exclude a created,\n  updated, or destroyed instance.\n\n  An instance is put in a list if it is a\n  [set.subset](https://github.com/canjs/can-set#setsubset)\n  of the [can-connect/base/base.listSet].\n\n  Currently, all items are added at the end of the list\n  until [set.add](https://github.com/canjs/can-set/issues/2)\n  is in `can-set`.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/real-time/real-time.createInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.createInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 138,
      "codeLine": 175,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n\n## Use\n\nWith a `real-time` connection, call `createInstance` when an instance is created that\nthe connection itself did not make.  For instance, the following might listen to\n[socket.io](http://socket.io/) for when a `todo` is created and update the connection\naccordingly:\n\n```\nsocket.on('todo created', function(todo){\n  todoConnection.createInstance(order);\n});\n```\n\n\t \n",
    "description": "\nProgramatically indicate a new instance has been created.\n",
    "title": "createInstance",
    "signatures": [
      {
        "code": "connection.createInstance(props)",
        "description": "\n\n  If there is no instance in the [can-connect/constructor/store/store.instanceStore]\n  for `props`'s [can-connect/base/base.id], an instance is [can-connect/constructor/constructor.hydrateInstance hydrated],\n  added to the store, and then [can-connect/real-time/real-time.createdData] is called with\n  `props` and the hydrated instance's serialized data. [can-connect/real-time/real-time.createdData]\n  will add this instance to any lists the instance belongs to.\n\n  If this instance has already been created, calls\n  [can-connect/real-time/real-time.updateInstance] with `props`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/real-time/real-time.createdData": {
    "type": "function",
    "name": "can-connect/real-time/real-time.createdData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "src": {
      "line": 197,
      "codeLine": 218,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nCalled whenever instance data is created.\n",
    "title": "createdData",
    "signatures": [
      {
        "code": "connection.createdData(props, params, [cid])",
        "description": "\n\n  Updates lists with the created instance.\n\n  Gets the instance created for this request. Then, updates the instance with\n  the response data `props`.\n\n  Next, it goes through every list in the [can-connect/constructor/store/store.listStore],\n  test if the instance's data belongs in that list.  If it does,\n  adds the instance's data to the serialized list data and\n  [can-connect/constructor/constructor.updatedList updates the list].\n\n\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/real-time/real-time.updatedData": {
    "src": {
      "line": 232,
      "codeLine": 246,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nCalled whenever instance data is updated.\n",
    "title": "updatedData",
    "name": "can-connect/real-time/real-time.updatedData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "signatures": [
      {
        "code": "connection.updatedData(props, params)",
        "description": "\n\n  Gets the instance that is updated, updates\n  it with `props` and the adds or removes it to\n  lists it belongs in.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ],
          "description": "Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        }
      ],
      "description": "Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t "
    }
  },
  "can-connect/real-time/real-time.updateInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.updateInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 257,
      "codeLine": 273,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nProgramatically indicate a new instance has been updated.\n",
    "title": "updateInstance",
    "signatures": [
      {
        "code": "connection.updateInstance(props)",
        "description": "\n\n  Calls [can-connect/real-time/real-time.updatedData] in the right way so\n  that the instance is updated and added to or removed from\n  any lists it belongs in.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the instance that\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "the updated instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties of the instance that\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "the updated instance.\n\t "
    }
  },
  "can-connect/real-time/real-time.destroyedData": {
    "type": "function",
    "name": "can-connect/real-time/real-time.destroyedData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "src": {
      "line": 290,
      "codeLine": 303,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "",
    "description": "\n",
    "title": "destroyedData",
    "signatures": [
      {
        "code": "connection.destroyedData(props, params)",
        "description": "\n\nGets the instance for this request.  Then tests if the instance\nis in any list in the [can-connect/constructor/store/store.listStore].  If\nit is, removes the instance from the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the destroyed instance."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "params",
            "description": "The parameters used to destroy the data.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "params",
      "description": "The parameters used to destroy the data.\n\t "
    }
  },
  "can-connect/real-time/real-time.destroyInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.destroyInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 314,
      "codeLine": 329,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nProgramatically indicate a new instance has been destroyed.\n",
    "title": "destroyInstance",
    "signatures": [
      {
        "code": "connection.destroyInstance(props)",
        "description": "\n\n  Gets or creates an instance from `props` and uses\n  it to call [can-connect/real-time/real-time.destroyedData]\n  correctly.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the destroyed instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise with the destroyed instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties of the destroyed instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise with the destroyed instance.\n\t "
    }
  },
  "can-connect/helpers/weak-reference-map": {
    "type": "module",
    "name": "can-connect/helpers/weak-reference-map",
    "parent": "can-connect.modules",
    "src": {
      "line": 2,
      "codeLine": 32,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "\n\n## Use\n\n```\nvar WeakReferenceMap = require(\"can-connect/helpers/weak-reference-map\");\nvar wrm = new WeakReferenceMap();\nvar task1 = {id: 1, name: \"do dishes\"};\n\nwrm.addReference(\"1\", task1);\nwrm.has(\"1\") //-> true\nwrm.addReference(\"1\", task1);\nwrm.has(\"1\") //-> true\nwrm.removeReference(\"1\", task1);\nwrm.has(\"1\") //-> true\nwrm.removeReference(\"1\", task1);\nwrm.has(\"1\") //-> false\n```\n\n",
    "description": "\nProvides a map that only contains keys that are referenced.\n",
    "title": "WeakReferenceMap",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "new WeakReferenceMap()",
        "description": "\n\n  Creates a new weak reference map.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/helpers/weak-reference-map.prototype": {
    "src": {
      "line": 40,
      "codeLine": 43,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\n",
    "name": "can-connect/helpers/weak-reference-map.prototype",
    "parent": "can-connect/helpers/weak-reference-map",
    "title": "prototype"
  },
  "can-connect/helpers/weak-reference-map.prototype.has": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.has",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 44,
      "codeLine": 53,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "has",
    "signatures": [
      {
        "code": "weakReferenceMap.has(key)",
        "description": "\n\n  Returns if key is in the set.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A key to look for."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "If the key exists.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A key to look for."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "If the key exists.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.addReference": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.addReference",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 56,
      "codeLine": 65,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "addReference",
    "signatures": [
      {
        "code": "WeakReferenceMap.addReference(key, item)",
        "description": "\n\n  Adds a reference to item as key and increments the reference count. This should be called\n  when a value should be managed by something, typically the [can-connect/constructor/store/store].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.deleteReference": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.deleteReference",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 76,
      "codeLine": 85,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "deleteReference",
    "signatures": [
      {
        "code": "weakReferenceMap.deleteReference(key)",
        "description": "\n\n  Decrements the reference count for key and removes it if the reference count is `0`. This should be called\n  when a value should not be managed by something, typically the [can-connect/constructor/store/store].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.get": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.get",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 94,
      "codeLine": 103,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "get",
    "signatures": [
      {
        "code": "weakReferenceMap.get(key)",
        "description": "\n\n  Returns the value stored at key if it's in the store.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "The item if it's available.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store."
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "The item if it's available.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.forEach": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.forEach",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 109,
      "codeLine": 117,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "forEach",
    "signatures": [
      {
        "code": "weakReferenceMap.forEach(callback)",
        "description": "\n\n  Calls `callback` for every value in the store.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "key"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A callback handler.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "item"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "key"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "A callback handler.\n "
    }
  },
  "can-control.extend": {
    "src": {
      "path": "node_modules/can-control/docs/control.extend.md"
    },
    "body": "\n## Examples\n\n    // Control that writes \"hello world\"\n    HelloWorld = Control.extend({\n      init: function(element){\n        element.text(\"hello world\")  \n      }\n    });\n    new HelloWorld(\"#message\");\n    \n    // Control that shows how many times\n    // the element has been clicked on\n    ClickCounter = Control.extend({\n      init: function(){\n         this.count = 0;\n         this.element.text(\"click me\")\n      },\n      \"{element} click\": function(){\n         this.count++;\n         this.element.text(\"click count = \"+this.count)\n      }\n    })\n    new ClickCounter(\"#counter\");\n \n    // Counter that counts a specified event\n    // type\n    CustomCounter = Control.extend({\n      defaults: {\n        eventType: \"click\"\n      }\n    },{\n      init: function(){\n        this.count = 0;\n        this.element.text(this.options.eventType+\" me\")\n      },\n      \"{element} {eventType}\": function(){\n         this.count++;\n         this.element.text(this.options.eventType+\n           \" count = \"+\n           this.count);\n      }\n    })\n    new CustomCounter(\"#counter\");\n    new CustomCounter(\"#buy\",{\n      eventType: \"mouseenter\"\n    });\n    \n\n",
    "description": "\n",
    "title": "extend",
    "name": "can-control.extend",
    "type": "function",
    "parent": "can-control.static",
    "signatures": [
      {
        "code": "Control.extend([staticProperties,] instanceProperties)",
        "description": "\n\nCreate a new, extended, control constructor \nfunction. \n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "An object of properties and methods that are added the control constructor \nfunction directly. The most common property to add is [can-control.defaults].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "constructs": {
                "types": [
                  {
                    "type": "can-construct"
                  }
                ]
              },
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "element"
                    }
                  ]
                },
                {
                  "types": [
                    {
                      "type": "options"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceProperties",
      "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "constructs": {
            "types": [
              {
                "type": "can-construct"
              }
            ]
          },
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "element"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "options"
                }
              ]
            }
          ]
        }
      ],
      "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n"
    },
    "comment": " "
  },
  "can-control.defaults": {
    "src": {
      "path": "node_modules/can-control/docs/defaults.md"
    },
    "body": "\nDefault options provided for when a new control is created without values set in `options`.\n\n`defaults` provides default values for a Control's options.\nOptions passed into the constructor function will be shallowly merged\ninto the values from defaults in [can-control::setup], and\nthe result will be stored in [can-control::options this.options].\n\n\tMessage = Control.extend({\n\t  defaults: {\n\t\tmessage: \"Hello World\"\n\t  }\n\t}, {\n\t  init: function(){\n\t\tthis.element.text( this.options.message );\n\t  }\n\t});\n\n\tnew Message( \"#el1\" ); //writes \"Hello World\"\n\tnew Message( \"#el12\", { message: \"hi\" } ); //writes hi\n\n## Shared Properties\n\nNew instances of a Control will create a shallow copy of the default\noptions. Be aware as shallow copies keep a reference to object types, such as\nobjects, maps and computes.\n\n```\nvar Sample = Control.extend({\n  defaults: {\n    computedProp: can.compute(),\n    primitiveProp: 'sample'\n  }\n}, {});\n\nvar a = new Sample('div');\nvar b = new Sample('li');\n\n//`computedProp` will be shared across instances of the `Sample` control.\n//a.options.computedProp === b.options.computedProp\n```\n\n",
    "description": "Default values for the Control's options. \n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "defaults",
    "name": "can-control.defaults",
    "type": "property",
    "parent": "can-control.static",
    "comment": " "
  },
  "can-control.prototype.destroy": {
    "src": {
      "path": "node_modules/can-control/docs/destroy.md"
    },
    "body": "## Allowing Garbage Collection\n\nDestroy is called whenever a control's element is removed from the page using\nthe library's standard HTML modifier methods. This means that you\ndon't have to call destroy yourself and it\nwill be called automatically when appropriate.\n\nThe following `Clicker` widget listens on the window for clicks and updates\nits element's innerHTML. If we remove the element, the window's event handler\nis removed auto-magically:\n\n\n\tClicker = Control({\n\t\"{window} click\": function() {\n\t\tthis.element.html( this.count ?\n\t\tthis.count++ : this.count = 0 );\n\t}\n\t});\n\n\t// create a clicker on an element\n\tnew Clicker( \"#clickme\" );\n\n\t// remove the element\n\t$( '#clickme' ).remove();\n\nThe methods you can use that will destroy controls automatically by library:\n\n__jQuery and Zepto__\n\n- `$.fn.remove`\n- `$.fn.html`\n- `$.fn.replaceWith`\n- `$.fn.empty`\n\n__Dojo__\n\n- `dojo.destroy`\n- `dojo.empty`\n- `dojo.place (with the replace option)`\n\n__Mootools__\n\n- `Element.prototype.destroy`\n\n__YUI__\n\n- `Y.Node.prototype.remove`\n- `Y.Node.prototype.destroy`\n\n\n## Teardown in Destroy\n\nSometimes, you want to reset a controlled element back to its\noriginal state when the control is destroyed. Overwriting destroy\nlets you write teardown code of this manner.\n\n__NOTE__: When overwriting destroy, make sure you call Control's base functionality.\n\nThe following example changes an element's text when the control is\ncreated and sets it back when the control is removed:\n\n\tChanger = Control.extend({\n\t\tinit: function() {\n\t\t\tthis.oldText = this.element.text();\n\t\t\tthis.element.text( \"Changed!!!\" );\n\t\t},\n\t\tdestroy: function() {\n\t\t\tthis.element.text( this.oldText );\n\t\t\tcan.Control.prototype.destroy.call( this );\n\t\t}\n\t});\n\n\t// create a changer which changes #myel's text\n\tvar changer = new Changer( '#myel' );\n\n\t// destroy changer which will reset it\n\tchanger.destroy();\n\n## Base Functionality\n\nControl prepares the control for garbage collection by:\n\n- unbinding all event handlers\n- clearing references to this.element and this.options\n- clearing the element's reference to the control\n- removing it's `Control.pluginName` from the element's className\n\n",
    "description": "Remove a Control from an element and clean up the Control. ",
    "title": "destroy",
    "name": "can-control.prototype.destroy",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.destroy()",
        "description": "\n\nPrepares a control for garbage collection and is a place to\nreset any changes the control has made.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-control.static": {
    "name": "can-control.static",
    "title": "static",
    "type": "group",
    "parent": "can-control",
    "description": "",
    "order": 0
  },
  "can-control.prototype": {
    "name": "can-control.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-control",
    "description": "",
    "order": 0
  },
  "can-control": {
    "src": {
      "path": "node_modules/can-control/docs/control.md"
    },
    "body": "\n## The Control Lifecycle\n\nThe following walks through a control's lifecycle\nwith an example todo list widget.  It's broken up into the following\nlifecycle events:\n\n - Extending a control\n - Creating a control instance\n - Listening to events\n - Destroying a control\n\n## Extending a control\n\nThe following example builds up a basic todos widget for listing \nand completing todo items. Start by creating a control constructor \nfunction of your own by extending [can-control] and defining an instance init method.\n\n    var Todos = Control.extend({\n      init: function( element, options ) { ... }\n    });\n\n## Creating a control instance\n\nCreate an instance of the Todos control on the `todos` element with:\n\n    var todosControl = new Todos( '#todos', {} );\n\nThe control's associated [can.ejs EJS] template looks like:\n\n    <% todos.each(function( todo ) { %>\n      <li <%= (el) -> el.data( 'todo', todo ) %> >\n        <%= todo.attr( 'name' ) %>\n        <a href=\"javascript://\" class=\"destroy\">\n      </li>\n    <% }) %>\n\n### `init(element, options)`\n\n[can-control.prototype.init] is called with the below arguments when new instances of [can-control] are created:\n\n- __element__ - The wrapped element passed to the \n                control. Control accepts a\n                raw HTMLElement, a CSS selector, or a NodeList. This is\n                set as `this.element` on the control instance.\n- __options__ - The second argument passed to new Control, extended with\n                the can.Control's static __defaults__. This is set as \n                `this.options` on the control instance. Note that static is used\n                formally to indicate that _default values are shared across control instances_.\n\nAny additional arguments provided to the constructor will be passed as normal. Use [can.view] to produce a document fragment\nfrom your template and inject it in the passed element. Note that the `todos` parameter passed to [can.view] below\nis an instance of [can-list]:\n\n    var Todos = Control.extend({\n\n      //defaults are merged into the options arg provided to the constructor\n      defaults : { view: 'todos.ejs' }\n\n    }, {\n      init: function( element , options ) {\n\n        //create a pointer to the control's scope\n        var self = this;\n\n        //run the Todo model's .findAll() method to produce a can.List\n        Todo.findAll( {}, function( todos ) {\n\n            //create a document fragment with can.view\n            //and inject it into the provided element's body\n    \t\tself.element.html( can.view(self.options.view, todos) );\n        });\n      }\n    });\n    \n    // create a Todos Control with default options\n    new Todos( document.body.firstElementChild );\n    \n    // overwrite the template default\n    new Todos( '#todos', { view: 'specialTodos.ejs' } );\n\n### `this.element`\n\n[can-control::element] is the \nNodeList consisting of the element the control is created on. \n\n    var todosControl = new Todos( document.body.firstElementChild );\n    todosControl.element[0] //-> document.body.firstElementChild\n\nEach library wraps elements differently. If you are using jQuery, for example,\nthe element is wrapped with `jQuery( element )`.\n\n### `this.options`\n\n[can-control::options] is the second argument passed to \n`new Control()`, merged with the control's static __defaults__ property.\n\n## Listening to events\n\nControl automatically binds prototype methods that look\nlike event handlers. Listen to __click__'s on `<li>` elements within [can-control::element this.element] like:\n\n    var Todos = Control.extend({\n      init: function( element , options ) {...},\n\n      '{element} li click': function( li, event ) {\n        console.log( 'You clicked', li.text() );\n        \n        // let other controls know what happened\n        li.trigger( 'selected' );\n      }\n    });\n\nWhen an `<li>` is clicked, `\"{element} li click\"` is called with:\n\n- The library-wrapped __element__ that was clicked\n- The __event__ data\n\nControl uses event delegation, so you can add `<li>`s without needing to rebind\nevent handlers.\n\nTo destroy a todo when its `<a href=\"javascript://\" class=\"destroy\">` link \nis clicked:\n\n    var Todos = can.Control.extend({\n      init: function( element, options ) {...},\n      \n      '{element} li click': function( li ) {...},\n      \n      '{element} li .destroy click': function( el, ev ) {\n        // get the li element that has todo data\n        var li = el.closest( 'li' );\n      \n        // get the model\n        var todo = li.data( 'todo' );\n  \n        //destroy it\n        todo.destroy();\n      }\n    });\n\nWhen the todo is destroyed, EJS's live binding will remove its LI automatically.\n\n### Templated Event Handlers Part 1 `\"{eventName}\"`\n\nCustomize event handler behavior with `\"{NAME}\"` in\nthe event handler name.  The following allows customization \nof the event that destroys a todo:\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n      \n      '{element} li click': function( li ) { ... },\n      \n      '{element} li .destroy {destroyEvent}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // create Todos with this.options.destroyEvent\n    new Todos( '#todos', { destroyEvent: 'mouseenter' } );\n\nValues inside `{NAME}` are looked up on the control's `this.options` first,\nand then the `window`. For example, we could customize it instead like:\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n      \n      '{element} li click': function( li ) { ... },\n  \n      '{element} li .destroy {Events.destroy}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // Events config\n    Events = { destroy: 'click' };\n\n    // Events.destroy is looked up on the window.\n    new Todos( '#todos' );\n\nThe selector can also be templated.\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n      \n      '{element} {listElement} click': function( li ) { ... },\n      \n      '{element} {listElement} .destroy {destroyEvent}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // create Todos with this.options.destroyEvent\n    new Todos( '#todos',  { \n      destroyEvent: 'mouseenter', \n      listElement: 'li' \n    } );\n\n### Templated Event Handlers Part 2 `\"{objectName}\"`\n\nControl can also bind to objects other than `this.element` with\ntemplated event handlers.  This is _critical_\nfor avoiding memory leaks that are so common among MVC applications.  \n\nIf the value inside `{NAME}` is an object, Control will bind to that\nobject to listen for events. For example, the following tooltip listens to \nclicks on the window:\n\n    var Tooltip = Control.extend({\n      '{window} click': function( el, ev ) {\n        // hide only if we clicked outside the tooltip\n        if ( !this.element.has( ev.target ) ) {\n          this.element.remove();\n        }\n      }\n    });\n\n    // create a Tooltip\n    new Tooltip( $( '<div>INFO</div>' ).appendTo( el ) );\n    \nThis is convenient when listening for model changes. If EJS were not\ntaking care of removing `<li>`s after their associated models were destroyed,\nwe could implement it in `Todos` like:\n\n    var Todos = Control.extend({\n      init: function( element, options ) {...},\n      \n      '{element} li click': function( li ) {...},\n      \n      '{element} li .destroy click': function( el, ev ) {\n        // get the li element that has todo data\n        var li = el.closest( 'li' );\n      \n        // get the model\n        var todo = li.data( 'todo' );\n  \n        //destroy it\n        todo.destroy();\n      },\n      \n      '{Todo} destroyed': function( Todo, ev, todoDestroyed ) {\n        // find where the element\n        var index = this.todosList.indexOf( todoDestroyed );\n        this.element.children( ':nth-child(' + ( index + 1 ) + ')' )\n                    .remove();\n      }\n    });\n\n    new Todos( '#todos' );\n\n### `on()`\n\n[can-control::on] rebinds a control's event handlers. This is useful when you want\nto listen to a specific model and change it:\n\n    var Editor = Control.extend({\n      todo: function( todo ) {\n        this.options.todo = todo;\n        this.on();\n        this.setName();\n      },\n      \n      // a helper that sets the value of the input\n      // to the todo's name\n      setName: function() {\n        this.element.val( this.options.todo.name );\n      },\n      \n      // listen for changes in the todo\n      // and update the input\n      '{todo} updated': function() {\n        this.setName();\n      },\n\n      // when the input changes\n      // update the todo instance\n      '{element} change': function() {\n        var todo = this.options.todo;\n        todo.attr( 'name', this.element.val() );\n        todo.save();\n      }\n    });\n\n    var todo1 = new Todo({ id: 6, name: 'trash' }),\n        todo2 = new Todo({ id: 6, name: 'dishes' });\n\n    // create the editor;\n    var editor = new Editor( '#editor' );\n\n    // show the first todo\n    editor.todo( todo1 );\n\n    // switch it to the second todo\n    editor.todo( todo2 );\n    \n\n## Destroying a control\n\n[can-control::destroy] unbinds a control's\nevent handlers and releases its element, but does not remove \nthe element from the page. \n\n    var todo = new Todos( '#todos' );\n    todo.destroy();\n\nWhen a control's element is removed from the page\n__destroy__ is called automatically.\n\n    new Todos( '#todos' );\n    $( '#todos' ).remove();\n    \nAll event handlers bound with Control are unbound when the control \nis destroyed (or its element is removed).\n\n_Brief aside on destroy and templated event binding. Taken \ntogether, templated event binding, and control's automatic\nclean-up make it almost impossible \nto write leaking applications. An application that uses\nonly templated event handlers on controls within the body\ncould free up all \ndata by calling `$(document.body).empty()`._\n\n## Tabs Example\n\nHere is an example of how to build a simple tab widget using Control:\n\n<iframe style=\"width: 100%; height: 300px\"\n        src=\"http://jsfiddle.net/donejs/kXLLt/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n",
    "description": "Create organized, memory-leak free, rapidly performing, stateful controls with declarative event binding. Use `Control` to create UI \ncontrols like tabs, grids, and context menus,\nand organize them into higher-order business rules with\n[can.route]. It can serve as both a traditional view and a traditional controller.\n\n",
    "type": "module",
    "title": "can-control",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "name": "can-control",
    "parent": "can-legacy",
    "download": "can/route",
    "test": [
      "can/route/test.html",
      "can/control/test.html"
    ],
    "inherits": "can",
    "link": "../docco/control/control.html docco",
    "signatures": [
      {
        "code": "Control( [staticProperties,] instanceProperties )",
        "description": "\n\nCreate a new, extended, control constructor \nfunction. This functionality is inherited from [can-construct] and is deprecated in favor of using \n[can-control.extend]. \n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "An object of properties and methods that are added the control constructor \nfunction directly. The most common property to add is [can-control.defaults].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers (see [Listening to events](#section_Listeningtoevents)).\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "constructs": {
                "types": [
                  {
                    "type": "can.Construct"
                  }
                ]
              },
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "element"
                    }
                  ]
                },
                {
                  "types": [
                    {
                      "type": "options"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n\n"
        }
      },
      {
        "code": "new Control( element, options )",
        "description": "\n\nCreate an instance of a control. [can.Control.prototype.setup] processes\nthe arguments and sets up event binding. Write your initialization\ncode in [can.Control.prototype.init]. Note, you never call `new Control()` directly,\ninstead, you call it on constructor functions extended from `Control`.\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "can-view-nodelist"
              },
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "element",
            "description": "Specifies the element the control will be created on.\n"
          },
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "can-map"
              },
              {
                "type": "can-define/map/map"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Option values merged with [can-control.defaults Control.defaults]\nand set as [can-control::options this.options]. If options is an observable ([can-map CanMap] / [can-define/map/map DefineMap]), any values from [can-control.defaults defaults] that do not exist on the observable will be set. The observable will then be set as [can-control::options this.options].\n\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-control"
            }
          ],
          "description": "A new instance of the constructor function extending Control.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-control"
        }
      ],
      "description": "A new instance of the constructor function extending Control.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "can-map"
        },
        {
          "type": "can-define/map/map"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Option values merged with [can-control.defaults Control.defaults]\nand set as [can-control::options this.options]. If options is an observable ([can-map CanMap] / [can-define/map/map DefineMap]), any values from [can-control.defaults defaults] that do not exist on the observable will be set. The observable will then be set as [can-control::options this.options].\n\n"
    },
    "comment": " "
  },
  "can-control.prototype.element": {
    "src": {
      "path": "node_modules/can-control/docs/element.md"
    },
    "body": "\nThe control instance's HTMLElement (or window) wrapped by the\nutil library for ease of use.\n\nIt is set by the first parameter to `new Construct( element, options )`\nin [can.Control::setup].  By default, a control listens to events on `this.element`.\n\n### Example - NodeList\n\nThe following `HelloWorld` control sets the control`s text to \"Hello World\":\n\n\tHelloWorld = Control({\n\t\tinit: function(){\n\t\t\tthis.element.text( 'Hello World' );\n\t\t}\n\t});\n\n\t// create the controller on the element\n\tnew HelloWorld( document.getElementById( '#helloworld' ) );\n\n## Wrapped NodeList\n\n`this.element` is a wrapped NodeList of one HTMLELement (or window).  This\nis for convenience in libraries like jQuery where all methods operate only on a\nNodeList.  To get the raw HTMLElement, write:\n\n\tthis.element[0] //-> HTMLElement\n\nThe following details the NodeList used by each library with\nan example of updating its text:\n\n__jQuery__ `jQuery( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Zepto__ `Zepto( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Dojo__ `new dojo.NodeList( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Mootools__ `$$( HTMLElement )`\n\n this.element.empty().appendText(\"Hello World\")\n\n__YUI__\n\n this.element.set(\"text\", \"Hello World\")\n\n## Changing `this.element`\n\nSometimes you don't want what's passed to `new Control`\nto be `this.element`.  You can change this by overwriting\nsetup or by unbinding, setting this.element, and rebinding.\n\n### Overwriting Setup\n\nThe following Combobox overwrites setup to wrap a\nselect element with a div.  That div is used\nas `this.element`. Notice how `destroy` sets back the\noriginal element.\n\n\tCombobox = Control({\n\t\tsetup: function( el, options ) {\n\t\t\tthis.oldElement = $( el );\n\t\t\tvar newEl = $( '<div/>' );\n\t\t\tthis.oldElement.wrap( newEl );\n\t\t\tcan.Control.prototype.setup.call( this, newEl, options );\n\t\t},\n\t\tinit: function() {\n\t\t\tthis.element //-> the div\n\t\t},\n\t\t\"{element} .option click\": function() {\n\t\t\t// event handler bound on the div\n\t\t},\n\t\tdestroy: function() {\n\t\t\tvar div = this.element; //save reference\n\t\t\tControl.prototype.destroy.call( this );\n\t\t\tdiv.replaceWith( this.oldElement );\n\t\t}\n\t});\n\n### Unbinding, setting, and rebinding.\n\nYou could also change this.element by calling\n[can.Control::off], setting this.element, and\nthen calling [can.Control::on] like:\n\n\tmove: function( newElement ) {\n\t\tthis.off();\n\t\tthis.element = $( newElement );\n\t\tthis.on();\n\t}\n\n",
    "description": "The element passed to the Control when creating a new instance. \n",
    "types": [
      {
        "type": "can-view-nodeList"
      }
    ],
    "title": "element",
    "name": "can-control.prototype.element",
    "type": "property",
    "parent": "can-control.prototype",
    "comment": " "
  },
  "can-control.eventDescription": {
    "src": {
      "path": "node_modules/can-control/docs/eventDescription.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "eventDescription",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-control.eventDescription",
    "parent": "can-control.types",
    "signatures": [
      {
        "code": "\"[CONTEXT ][SELECTOR ]EVENTNAME\"",
        "description": "\n\n",
        "params": []
      }
    ]
  },
  "can-control.eventHandler": {
    "src": {
      "path": "node_modules/can-control/docs/eventHandler.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "eventHandler(element, event)",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-control.eventHandler",
    "parent": "can-control.types",
    "signatures": [
      {
        "code": "function(element, event)",
        "description": "\n\n",
        "params": []
      }
    ]
  },
  "can-control.prototype.on": {
    "src": {
      "path": "node_modules/can-control/docs/on.md"
    },
    "body": "`this.on()` is used to rebind\nall event handlers when [can-control::options this.options] has changed.  It\ncan also be used to bind or delegate from other elements or objects.\n\n## Rebinding\n\nBy using templated event handlers, a control can listen to objects outside\n`this.element`.  This is extremely common in MVC programming.  For example,\nthe following control might listen to a task model's `completed` property and\ntoggle a strike className like:\n\n\tTaskStriker = Control({\n\t\t\"{task} completed\": function(){\n\t\t\tthis.update();\n\t\t},\n\t\tupdate: function(){\n\t\t\tif ( this.options.task.completed ) {\n\t\t\t\tthis.element.addClass( 'strike' );\n\t\t\t} else {\n\t\t\t\tthis.element.removeClass( 'strike' );\n\t\t\t}\n\t\t}\n\t});\n\n\tvar taskstriker = new TaskStriker({\n\t\ttask: new Task({ completed: 'true' })\n\t});\n\nTo update the `taskstriker`'s task, add a task method that updates\nthis.options and rebinds the event handlers for the new task like:\n\n\tTaskStriker = Control({\n\t\t\"{task} completed\": function(){\n\t\t\tthis.update();\n\t\t},\n\t\tupdate: function() {\n\t\t\tif ( this.options.task.completed ) {\n\t\t\t\tthis.element.addClass( 'strike' );\n\t\t\t} else {\n\t\t\t\tthis.element.removeClass( 'strike' );\n\t\t\t}\n\t\t},\n\t\ttask: function( newTask ) {\n\t\t\t\tthis.options.task = newTask;\n\t\t\t\tthis.on();\n\t\t\t\tthis.update();\n\t\t}\n\t});\n\n\tvar taskstriker = new TaskStriker({\n\t\ttask: new Task({ completed: true })\n\t});\n\n\t// Now, add a new task that is not yet completed\n\ttaskstriker.task(new Task({ completed: false }));\n\n## Adding new events\n\nIf events need to be bound to outside of the control and templated event handlers\nare not sufficient, you can call this.on to bind or delegate programmatically:\n\n\tinit: function() {\n\t\t// calls somethingClicked( el, ev )\n\t\tthis.on( 'click', 'somethingClicked' );\n\n\t\t// calls function when the window is clicked\n\t\tthis.on( window, 'click', function( ev ) {\n\t\t\t// do something\n\t\t});\n\t},\n\t\tsomethingClicked: function( el, ev ) {\n\t\t // ...\n\t}\n\n",
    "description": "Bind an event handler to a Control, or rebind all event handlers on a Control. \n",
    "title": "on",
    "name": "can-control.prototype.on",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.on([el,] selector, eventName, func)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "jQuery"
              },
              {
                "type": "collection"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "el",
            "defaultValue": "this.element",
            "description": "\nThe element to be bound.  If no element is provided, the control's element is used instead."
          },
          {
            "types": [
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "selector",
            "description": "A CSS selector for event delegation."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              },
              {
                "type": "String"
              }
            ],
            "name": "func",
            "description": "A callback function or the String name of a control function.  If a control\nfunction name is given, the control function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The id of the binding in this._bindings.\n\n`on(el, selector, eventName, func)` binds an event handler for an event to a selector under the scope of the given element.\n"
        }
      },
      {
        "code": "control.on()",
        "description": "\n\nRebind all of a control's event handlers.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of handlers bound to this Control.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of handlers bound to this Control.\n"
    },
    "comment": " "
  },
  "can-control.prototype.options": {
    "src": {
      "path": "node_modules/can-control/docs/options.md"
    },
    "body": "## Options Object\n\nThe `this.options` property is an Object that contains\nconfiguration data passed to a control when it is\ncreated (`new Control(element, options)`).\n\nIn the following example, an options object with\na message is passed to a `Greeting` control. The\n`Greeting` control changes the text of its [can-control::element element]\nto the options' message value.\n\n\tvar Greeting = Control.extend({\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message )\n\t\t}\n\t});\n\n\tnew Greeting(\"#greeting\",{message: \"I understand this.options\"});\n\nThe options argument passed when creating the control\nis merged with [can-control.defaults defaults] in\n[can-control.prototype.setup setup].\n\nIn the following example, if no message property is provided,\nthe defaults' message property is used.\n\n\tvar Greeting = Control.extend({\n\t\tdefaults: {\n\t\t\tmessage: \"Defaults merged into this.options\"\n\t\t}\n\t},{\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message )\n\t\t}\n\t});\n\n\tnew Greeting(\"#greeting\");\n\n## Options Observable\nAn observable [can-map CanMap] or [can-define/map/map DefineMap] can also be passed instead of an options object.\n\nIn the following example, the defaults' message property is set on the [can-define/map/map DefineMap] options observable, which is then set directly as `this.options`:\n\n```\n\tvar GreetingControl = Control.extend({\n\t\tdefaults: {\n\t\t\tmessage: 'Hello'\n\t\t}\n\t}, {\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message + ' ' + this.options.name )\n\t\t}\n\t});\n\n\tvar GreetingMap = DefineMap.extend({\n\t\tmessage: 'string',\n\t\tname: 'string'\n\t});\n\n\tvar data = new GreetingMap();\n\tdata.name = 'Kevin';\n\n\tnew GreetingControl('#greeting', data);\n```\n\n",
    "description": "Options used to configure a control. \n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "options",
    "name": "can-control.prototype.options",
    "type": "property",
    "parent": "can-control.prototype",
    "comment": " "
  },
  "can-control.processors": {
    "src": {
      "path": "node_modules/can-control/docs/processors.md"
    },
    "body": "\n`processors` is an object that allows you to add new events to bind\nto on a control, or to change how existent events are bound. Each\nkey-value pair of `processors` is a specification that pertains to\nan event where the key is the name of the event, and the value is\na function that processes calls to bind to the event.\n\nThe processor function takes five arguments:\n\n- _el_: The Control's element.\n- _event_: The event type.\n- _selector_: The selector preceding the event in the binding used on the Control.\n- _callback_: The callback function being bound.\n- _control_: The Control the event is bound on.\n\nInside your processor function, you should bind _callback_ to the event, and\nreturn a function for can.Control to call when _callback_ needs to be unbound.\n(If _selector_ is defined, you will likely want to use some form of delegation\nto bind the event.)\n\nHere is a Control with a custom event processor set and two callbacks bound\nto that event:\n\n\tControl.processors.birthday = function(el, ev, selector, callback, control) {\n\tif(selector) {\n\t myFramework.delegate(ev, el, selector, callback);\n\t return function() { myFramework.undelegate(ev, el, selector, callback); };\n\t} else {\n\t myFramework.bind(ev, el, callback);\n\t return function() { myFramework.unbind(ev, el, callback); };\n\t}\n\t};\n\n\tControl(\"EventTarget\", { }, {\n\t'birthday': function(el, ev) {\n\t // do something appropriate for the occasion\n\t},\n\t'.grandchild birthday': function(el, ev) {\n\t // do something appropriate for the occasion\n\t}\n\t});\n\n\tvar target = new EventTarget('#person');\n\nWhen `target` is initialized, can.Control will call `Control.processors.birthday`\ntwice (because there are two event hookups for the _birthday_ event). The first\ntime it's called, the arguments will be:\n\n- _el_: A NodeList that wraps the element with id 'person'.\n- _ev_: `'birthday'`\n- _selector_: `''`\n- _callback_: The function assigned to `' birthday'` in the prototype section of `EventTarget`'s\ndefinition.\n- _control_: `target` itself.\n\nThe second time, the arguments are slightly different:\n\n- _el_: A NodeList that wraps the element with id 'person'.\n- _ev_: `'birthday'`\n- _selector_: `'.grandchild'`\n- _callback_: The function assigned to `'.grandchild birthday'` in the prototype section of `EventTarget`'s\ndefinition.\n- _control_: `target` itself.\n\nControl already has processors for these events:\n\n- change\n- click\n- contextmenu\n- dblclick\n- focusin\n- focusout\n- keydown\n- keyup\n- keypress\n- mousedown\n- mouseenter\n- mouseleave\n- mousemove\n- mouseout\n- mouseover\n- mouseup\n- reset\n- resize\n- scroll\n- select\n- submit\n\n",
    "description": "A collection of hookups for custom events on Controls. ",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "can-control.processor"
              }
            ]
          }
        ]
      }
    ],
    "title": "processors",
    "name": "can-control.processors",
    "type": "property",
    "parent": "can-control.static",
    "comment": " "
  },
  "can-control.prototype.setup": {
    "src": {
      "path": "node_modules/can-control/docs/setup.md"
    },
    "body": "\n## Lifecycle of `setup`\n\nSetup, when called, does the following:\n\n### Sets this.element\n\nThe first parameter passed to new Control( el, options ) is expected to be\nan element.  This gets converted to a Wrapped NodeList element and set as\n[can-control.prototype.element this.element].\n\n### Adds the control's name to the element's className\n\nControl adds it's plugin name to the element's className for easier\ndebugging.  For example, if your Control is named \"Foo.Bar\", it adds\n\"foo_bar\" to the className.\n\n### Saves the control in $.data\n\nA reference to the control instance is saved in $.data.  You can find\ninstances of \"Foo.Bar\" like:\n\n\t$( '#el' ).data( 'controls' )[ 'foo_bar' ]\n\n### Merges Options\n\nMerges the default options with optional user-supplied ones.\nAdditionally, default values are exposed in the static [can-control.static.defaults defaults]\nso that users can change them.\n\n### Binds event handlers\n\nSetup does the event binding described in [can-control].\n\n",
    "description": "Perform pre-initialization logic for control instances and classes.  \n",
    "title": "setup",
    "name": "can-control.prototype.setup",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.setup(element, options)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "NodeList"
              },
              {
                "type": "String"
              }
            ],
            "name": "element",
            "description": "The element as passed to the constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "options",
            "description": "option values for the control.  These get added to\nthis.options and merged with [can-control.static.defaults defaults]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "undefined"
            },
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "options",
      "description": "option values for the control.  These get added to\nthis.options and merged with [can-control.static.defaults defaults]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.\n"
    },
    "comment": " "
  },
  "can-event/async/async.dispatch": {
    "type": "function",
    "name": "can-event/async/async.dispatch",
    "parent": "can-event/async/async",
    "src": {
      "line": 19,
      "codeLine": 39,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "Dispatch events asynchronously. \n",
    "title": "dispatch",
    "signatures": [
      {
        "code": "asych.dispatch.call(target, event, [args])",
        "description": "\n\nDispatches `event` on `target` in a task queue scheduled to\nrun [can-util/js/set-immediate/set-immediate immediately] after the current\nevent loop.\n\nIf [can-event/async/async.async] is called, this will replace\nthe default [can-event.dispatch].\n\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "target",
            "description": "The object to dispatch the event on."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "event",
            "description": "The event to dispatch."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Additional arguments to pass to event handlers"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "event The resulting event object\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "args",
      "description": "Additional arguments to pass to event handlers"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "event The resulting event object\n "
    }
  },
  "can-event/async/async.queue": {
    "type": "function",
    "name": "can-event/async/async.queue",
    "parent": "can-event/async/async",
    "src": {
      "line": 49,
      "codeLine": 64,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "Queues a method to be called asynchronously. \n",
    "title": "queue",
    "signatures": [
      {
        "code": "async.queue(task)",
        "description": "\n\nQueues a method to be run scheduled to\n[can-util/js/set-immediate/set-immediate immediately] after the current\nevent loop.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "task",
            "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                }
              ]
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "task",
      "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
    }
  },
  "can-event/async/async.flush": {
    "type": "function",
    "name": "can-event/async/async.flush",
    "parent": "can-event/async/async",
    "src": {
      "line": 71,
      "codeLine": 80,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "flush",
    "signatures": [
      {
        "code": "async.flush()",
        "description": "\n\nFlushes the task queue immediately so all events or other tasks\nwill be immediately invoked.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async.async": {
    "type": "function",
    "name": "can-event/async/async.async",
    "parent": "can-event/async/async",
    "src": {
      "line": 93,
      "codeLine": 101,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "async",
    "signatures": [
      {
        "code": "async.async()",
        "description": "\n\nMakes event dispatching and event binding happen asynchronously.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async.sync": {
    "type": "function",
    "name": "can-event/async/async.sync",
    "parent": "can-event/async/async",
    "src": {
      "line": 105,
      "codeLine": 113,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "sync",
    "signatures": [
      {
        "code": "async.sync()",
        "description": "\n\nMakes event dispatching and event binding happen synchronously.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async": {
    "src": {
      "path": "node_modules/can-event/async/async.md"
    },
    "body": "\n## Use\n\nUse `can-event/async/async`'s `async` method to make event binding and\ndispatching happen immediately following the current event loop.\n\n```js\nvar canEvent = require(\"can-event\");\nvar canAsync = require(\"can-event/async/async\");\ncanAsync.async();\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){\n  console.log(\"heard foo\");\n});\nobj.dispatch(\"foo\");\nconsole.log(\"dispatched foo\");\n\n// Logs -> \"dispatched foo\" then \"heard foo\"\n```\n\nThis means you never have to call [can-event/batch/batch.start] and [can-event/batch/batch.stop]. Notice\nthat in the following example `\"change\"` is only fired once:\n\n```js\nvar canAsync = require(\"can-event/async/async\");\ncanAsync.async();\n\nvar compute = require(\"can-compute\");\n\nvar first = compute(\"Justin\");\nvar last = compute(\"Meyer\");\n\nvar fullName = compute(function(){\n\treturn first() + \" \" + last();\n});\n\nfullName.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Payal Shah\"\n\toldVal //-> \"Justin Meyer\"\n});\n\nfirst(\"Payal\");\nlast(\"Shah\");\n```\n\n",
    "description": "Makes the event system asynchronous. __WARNING:__ This is experimental technology. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event/async/async",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "Object",
        "description": "\n\nThe `can-event/async/async` module makes the event system asynchronous.  It:\n\n - Provides an [can-event/async/async.async] method which converts event binding and dispatching to happen asynchronously.\n - Provides [can-event/async/async.sync]  method which converts event binding and dispatching to happen synchronously.\n - Provides an asynchronous [can-event/async/async.dispatch], [can-event/async/async.queue],\n  [can-event/async/async.addEventListener] and [can-event/async/async.removeEventListener].\n - Provides a [can-event/async/async.flush] which can be used to immediately run all tasks in the\n   task queue.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-event/batch/batch.start": {
    "type": "function",
    "name": "can-event/batch/batch.start",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 41,
      "codeLine": 147,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "`canBatch.start` begins an event batch. Until `[can-event/batch/batch.stop]` is called, any\nevents that would result from calls to [can-event/batch/batch.trigger] to are held back from firing. If you have\nlots of changes to make to observables, batching them together can help performance - especially if\nthose observables are live-bound to the DOM.\n\nIn this example, you can see how the _first_ event is not fired (and their handlers\nare not called) until `canBatch.stop` is called.\n\n```\nvar person = new DefineMap({\n    first: 'Alexis',\n    last: 'Abril'\n});\n\nperson.on('first', function() {\n    console.log(\"First name changed.\");\n}).on('last', function() {\n    console.log(\"Last name changed.\");\n});\n\ncanBatch.start();\nperson.first = 'Alex';\nconsole.log('Still in the batch.');\ncanBatch.stop();\n\n// the log has:\n// Still in the batch.\n// First name changed.\n```\n\nYou can also pass a callback to `canBatch.start` which will be called after all the events have\nbeen fired:\n\n```\ncanBatch.start(function() {\n    console.log('The batch is over.');\n});\nperson.first = \"Izzy\"\nconsole.log('Still in the batch.');\ncanBatch.stop();\n\n// The console has:\n// Still in the batch.\n// First name changed.\n// The batch is over.\n```\n\n## Calling `canBatch.start` multiple times\n\nIf you call `canBatch.start` more than once, `canBatch.stop` needs to be called\nthe same number of times before any batched events will fire. For ways\nto circumvent this process, see [can-event/batch/batch.stop].\n\nHere is an example that demonstrates how events are affected by calling\n`canBatch.start` multiple times.\n\n```\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  name: \"string\"\n  updatedAt: \"date\",\n  complete: function(){\n    canBatch.start();\n    this.completed = true;\n    this.updatedAt = new Date();\n    canBatch.end();\n  }\n});\n\nTodo.List = DefineList.extend({\n  \"*\": Todo,\n  completeAll: function(){\n    this.forEach(function(todo){\n      todo.complete();\n    });\n  }\n});\n\nvar todos = new Todo.List([\n  {name: \"dishes\", completed: false},\n  {name: \"lawn\", completed: false}\n]);\n\ntodos[0].on(\"completed\", function(ev){\n  console.log(\"todos[0] \"+ev.batchNum);\n})\ntodos[1].on(\"completed\", function(ev){\n  console.log(\"todos[1] \"+ev.batchNum);\n});\n\ntodos.completeAll();\n// console.logs ->\n//        todos[0] 1\n//        todos[1] 1\n```\n \n",
    "description": "Begin an event batch. \n",
    "title": "start",
    "signatures": [
      {
        "code": "canBatch.start([batchStopHandler])",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "batchStopHandler",
            "description": "a callback that gets called after all batched events have been called.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "batchStopHandler",
      "description": "a callback that gets called after all batched events have been called.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.collecting": {
    "type": "function",
    "name": "can-event/batch/batch.collecting",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 176,
      "codeLine": 194,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "\n",
    "title": "collecting",
    "signatures": [
      {
        "code": "batch.collecting()",
        "description": "\n\nReturns the Queue that is currently collecting tasks.\n\n```\nbatch.start();\nbatch.collecting() //-> Queue\n\nbatch.stop();\nbatch.collecting() //-> null\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-event/batch/Queue"
            }
          ],
          "description": "The queue currently collecting tasks.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-event/batch/Queue"
        }
      ],
      "description": "The queue currently collecting tasks.\n "
    }
  },
  "can-event/batch/batch.dispatching": {
    "type": "function",
    "name": "can-event/batch/batch.dispatching",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 197,
      "codeLine": 221,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "\n",
    "title": "dispatching",
    "signatures": [
      {
        "code": "batch.dispatching()",
        "description": "\n\nReturns the Queue that is executing tasks.\n\n```\nvar canEvent = require(\"can-event\");\nvar batch = require(\"can-event/batch/batch\");\n\n\nvar obj = Object.assign({}, canEvent);\n\n\n\nbatch.start();\nobj.dispatch(\"first\");\nbatch.stop();\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-event/batch/Queue"
            }
          ],
          "description": "The queue currently executing tasks.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-event/batch/Queue"
        }
      ],
      "description": "The queue currently executing tasks.\n "
    }
  },
  "can-event/batch/batch.stop": {
    "type": "function",
    "name": "can-event/batch/batch.stop",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 224,
      "codeLine": 249,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "\n`canBatch.stop` matches an earlier `[can-event/batch/batch.start]` call. If `canBatch.stop` has been\ncalled as many times as `canBatch.start` (or if _force_ is true), all batched events will be\nfired and any callbacks passed to `canBatch.start` since the beginning of the batch will be\ncalled. If _force_ and _callStart_ are both true, a new batch will be started when all\nthe events and callbacks have been fired.\n\nSee `[can-event/batch/batch.start]` for examples of `canBatch.start` and `canBatch.stop` in normal use.\n\n \n",
    "description": "End an event batch. \n",
    "title": "stop",
    "signatures": [
      {
        "code": "canBatch.stop([force[, callStart]])",
        "description": "\n\nIf this call to `stop` matches the number of calls to `start`, all of this batch's [can-event/batch/batch.trigger triggered]\nevents will be dispatched.  If the firing of those events creates new events, those new events will be dispatched\nafter the current batch in their own batch.\n",
        "params": [
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "force",
            "defaultValue": "false",
            "description": "Whether to stop batching events immediately."
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "callStart",
            "defaultValue": "false",
            "description": "Whether to call [can-event/batch/batch.start] after firing batched events.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "callStart",
      "defaultValue": "false",
      "description": "Whether to call [can-event/batch/batch.start] after firing batched events.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.dispatch": {
    "type": "function",
    "name": "can-event/batch/batch.dispatch",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 336,
      "codeLine": 360,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "\n \n",
    "description": "Dispatchs an event within the event batching system. ",
    "title": "dispatch",
    "signatures": [
      {
        "code": "canBatch.trigger(item, event [, args])",
        "description": "\n\nMakes sure an event is fired at the appropriate time within the appropriate batch.\nHow and when the event fires depends on the batching state.\n\nThere are three states of batching:\n\n- no queues - `trigger` is called outside of any `start` or `stop` call -> The event is dispatched immediately.\n- collecting batch - `trigger` is called between a `start` or `stop` call -> The event is dispatched when `stop` is called.\n- firing queues -  `trigger` is called due to another `trigger` called within a batch -> The event is dispatched after the current batch has completed in a new batch.\n\nFinally, if the event has a `batchNum` it is fired immediately.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "item",
            "description": "the target of the event."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": [
                  {
                    "name": "type",
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "event",
            "description": "the type of event, or an event object with a type given like `{type: 'name'}`"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "the parameters to trigger the event with.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "args",
      "description": "the parameters to trigger the event with.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.queue": {
    "type": "function",
    "name": "can-event/batch/batch.queue",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 411,
      "codeLine": 436,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "Queues a method to be called. \n",
    "title": "queue",
    "signatures": [
      {
        "code": "batch.queue(task)",
        "description": "\n\nQueues a method to be called in the current [can-event/batch/batch.collecting]\nqueue if there is one.  If there is a [can-event/batch/batch.dispatching] queue,\nit will create a batch and add the task to that batch.\nFinally, if there is no batch, the task will be executed immediately.\n\n```\nvar me = {\n  say: function(message){\n    console.log(this.name,\"says\", message);\n  }\n}\nbatch.queue([me.say, me, [\"hi\"]]);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "task",
            "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                }
              ]
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "task",
      "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
    }
  },
  "can-event/batch/batch.afterPreviousEvents": {
    "src": {
      "line": 461,
      "codeLine": 539,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\nWith batching, it's possible for a piece of code to read some observable, and listen to\nchanges in that observable, but have events fired that it should ignore.\n\nFor example, consider a list widget that creates `<li>`'s for each item in the list and listens to\nupdates in that list and adds or removes `<li>`s:\n\n```js\nvar makeLi = function(){\n  return document.createElement(\"li\")\n};\n\nvar listWidget = function(list){\n  var lis = list.map(makeLi);\n  list.on(\"add\", function(ev, added, index){\n    var newLis = added.map(makeLi);\n    lis.splice.apply(lis, [index, 0].concat(newLis) );\n  }).on(\"remove\", function(ev, removed, index){\n    lis.splice(index, removed.length);\n  });\n\n  return lis;\n}\n```\n\nThe problem with this is if someone calls `listWidget` within a batch:\n\n```js\nvar list = new DefineList([]);\n\ncanBatch.start();\nlist.push(\"can-event\",\"can-event/batch/\");\nlistWidget(list);\ncanBatch.stop();\n```\n\nThe problem is that list will immediately create an `li` for both `can-event` and `can-event/batch/`, and then,\nwhen `canBatch.stop()` is called, the `add` event listener will create duplicate `li`s.\n\nThe solution, is to use `afterPreviousEvents`:\n\n```js\nvar makeLi = function(){\n  return document.createElement(\"li\")\n};\n\nvar listWidget = function(list){\n  var lis = list.map(makeLi);\n  canBatch.afterPreviousEvents(function(){\n    list.on(\"add\", function(ev, added, index){\n      var newLis = added.map(makeLi);\n      lis.splice.apply(lis, [index, 0].concat(newLis) );\n    }).on(\"remove\", function(ev, removed, index){\n      lis.splice(index, removed.length);\n    });\n  });\n\n  return lis;\n}\n```\n\n \n",
    "description": "Run code when all previuos state has settled. \n",
    "title": "afterPreviousEvents",
    "name": "can-event/batch/batch.afterPreviousEvents",
    "parent": "can-event/batch/batch",
    "signatures": [
      {
        "code": "canBatch.afterPreviousEvents(handler)",
        "description": "\n\nCalls `handler` when all previously [can-event/batch/batch.trigger triggered] events have\nbeen fired.  This is useful to know when all fired events match the current state.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "A function to call back when all previous events have fired.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "A function to call back when all previous events have fired.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch": {
    "src": {
      "path": "node_modules/can-event/batch/batch.md"
    },
    "body": "\n## Use\n\nTo batch events, call  [can-event/batch/batch.start], then make changes that\n[can-event/batch/batch.dispatch] batched events, then call [can-event/batch/batch.stop].\n\nFor example, a map might have a `first` and `last` property:\n\n```js\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\"\n});\n\nvar baby = new Person({first: \"Roland\", last: \"Shah\"});\n```\n\nNormally, when `baby`'s `first` and `last` are fired, those events are dispatched immediately:\n\n```js\nbaby.on(\"first\", function(ev, newFirst){\n\tconsole.log(\"first is \"+newFirst);\n}).on(\"last\", function(ev, newLast){\n\tconsole.log(\"last is \"+newLast);\n});\n\nbaby.first = \"Ramiya\";\n// console.logs -> \"first is Ramiya\"\nbaby.last = \"Meyer\";\n// console.logs -> \"first is Meyer\"\n```\n\nHowever, if a batch is used, events will not be dispatched until [can-event/batch/batch.stop] is called:\n\n```js\nvar canBatch = require(\"can-event/batch/batch\");\n\ncanBatch.start();\nbaby.first = \"Lincoln\";\nbaby.last = \"Sullivan\";\ncanBatch.stop();\n// console.logs -> \"first is Lincoln\"\n// console.logs -> \"first is Sullivan\"\n```\n\n\n\n## Performance\n\nCanJS synchronously dispatches events when a property changes.\nThis makes certain patterns easier. For example, if you\nare utilizing live-binding and change a property, the DOM is\nimmediately updated.\n\nOccasionally, you may find yourself changing many properties at once. To\nprevent live-binding from performing unnecessary updates,\nupdate the properties within a pair of calls to `canBatch.start` and\n`canBatch.stop`.\n\nConsider a todo list with a `completeAll` method that marks every todo in the list as\ncomplete and `completeCount` that counts the number of complete todos:\n\n```js\nvar Todo = DefineMap.extend({\n\tname: \"string\",\n\tcomplete: \"boolean\"\n});\n\nvar TodoList = DefineList.extend({\n\t\"*\": Todo,\n\tcompleteAll: function(){\n\t\tthis.forEach(function(todo){\n\t\t\ttodo.complete = true;\n\t\t})\n\t},\n\tcompleteCount: function(){\n\t\treturn this.filter({complete: true}).length;\n\t}\n})\n```\n\nAnd a template that uses the `completeCount` and calls `completeAll`:\n\n```\n<ul>\n{{#each todos}}\n\t<li><input type='checklist' {($checked)}=\"complete\"/> {{name}}</li>\n{{/each}}\n</ul>\n<button ($click)=\"todos.completeAll()\">\n  Complete {{todos.completeCount}} todos\n</button>\n```\n\nWhen `completeAll` is called, the `{{todos.completeCount}}` magic tag will update\nonce for every completed count.  We can prevent this by wrapping `completeAll` with calls to\n`start` and `stop`:\n\n```js\n\tcompleteAll: function(){\n\t\tcanBatch.start();\n\t\tthis.forEach(function(todo){\n\t\t\ttodo.complete = true;\n\t\t});\n\t\tcanBatch.end();\n\t},\n```\n\n\n## batchNum\n\nAll events created within a set of `start` / `stop` calls share the same\nbatchNum value. This can be used to respond only once for a given batchNum.\n\n    var batchNum;\n    person.on(\"name\", function(ev, newVal, oldVal) {\n      if(!ev.batchNum || ev.batchNum !== batchNum) {\n        batchNum = ev.batchNum;\n        // your code here!\n      }\n    });\n\n",
    "description": "Adds task batching abilities to event dispatching. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event/batch/batch",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "Object",
        "description": "\n\nThe `can-event/batch/batch` module adds task batching abilities to\nthe [can-event] module.  It:\n\n - Provides a [can-event/batch/batch.queue] method to add batched work.\n - Provides [can-event/batch/batch.dispatch] and overwrites [can-event.dispatch can-event.dispatch] to use the task queue when dispatching events.\n - Provides a [can-event/batch/batch.start] and [can-event/batch/batch.stop] method that can create a new task queue.\n - Provides [can-event/batch/batch.collecting] which returns the queue collecting tasks.\n - Provides [can-event/batch/batch.dispatching] which returns the queue dispatching tasks.\n - Dispatches `batchEnd` when a queue's tasks have been completed.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can.util.bind": {
    "src": {
      "line": 1,
      "codeLine": 9,
      "path": "node_modules/can-event/lifecycle/lifecycle.js"
    },
    "type": "typedef",
    "body": "\n\n",
    "description": "\nProvides mixin-able bind and unbind methods. `bind()` calls `this._bindsetup`\nwhen the first bind happens and.  `unbind()` calls `this._bindteardown` when there\nare no more event handlers.\n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "bind",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "unbind",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can.util.bind"
  },
  "fixture.types.Store.findOne": {
    "type": "function",
    "name": "fixture.types.Store.findOne",
    "parent": "fixture.types.Store",
    "src": {
      "line": 161,
      "codeLine": 180,
      "path": "node_modules/can-fixture/helpers/legacyStore.js"
    },
    "body": "`store.findOne(request, response(item))` simulates a request to\nget a single item from the server by id.\n\n    todosStore.findOne({\n      url: \"/todos/5\"\n    }, function(todo){\n\n    });\n\n\t \n",
    "description": "Simulate a findOne request on a fixture. ",
    "title": "",
    "signatures": [
      {
        "code": "store.findOne(request, response)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "request",
            "description": "Parameters for the request."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "response",
            "description": "A function to call with the retrieved item.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "response",
      "description": "A function to call with the retrieved item.\n"
    },
    "comment": " "
  },
  "fixture.types.Store.destroy": {
    "type": "function",
    "name": "fixture.types.Store.destroy",
    "parent": "fixture.types.Store",
    "src": {
      "line": 208,
      "codeLine": 226,
      "path": "node_modules/can-fixture/helpers/legacyStore.js"
    },
    "body": "`store.destroy(request, response())` simulates\na request to destroy an item from the server.\n\n```\ntodosStore.destroy({\n  url: \"/todos/5\"\n}, function(){});\n```\n\t \n",
    "description": "Simulate destroying a Model on a fixture. ",
    "title": "",
    "signatures": [
      {
        "code": "store.destroy(request, callback)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "request",
            "description": "Parameters for the request."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "callback",
            "description": "A function to call after destruction.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "callback",
      "description": "A function to call after destruction.\n"
    },
    "comment": " "
  },
  "can-fixture.delay": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.delay.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Number"
      }
    ],
    "title": "delay",
    "name": "can-fixture.delay",
    "type": "property",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.delay",
        "description": "\n\nSets the delay until a response is fired in milliseconds.\n\n```js\nfixture.delay = 1000; // 1 second delay\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture.properties": {
    "name": "can-fixture.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-fixture",
    "description": "",
    "order": 0
  },
  "can-fixture.types": {
    "name": "can-fixture.types",
    "title": "types",
    "type": "group",
    "parent": "can-fixture",
    "description": "",
    "order": 0
  },
  "can-fixture": {
    "src": {
      "path": "node_modules/can-fixture/docs/can-fixture.md"
    },
    "body": "",
    "description": "can-fixture intercepts an AJAX request and simulates the response with a file or function. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-fixture",
    "parent": "can-ecosystem",
    "signatures": [
      {
        "code": "fixture(ajaxSettings, requestHandler(...))",
        "description": "\n\nIf an XHR request matches ajaxSettings, calls requestHandler with the XHR requests data. Makes the XHR request respond with the return value of requestHandler or the result of calling its response argument.\n\nThe following traps requests to GET /todos and responds with an array of data:\n\n```js\nfixture({method: \"get\", url: \"/todos\"},\n        function(request, response, headers, ajaxSettings){\n    return {\n        data: [\n            {id: 1, name: \"dishes\"},\n            {id: 2, name: \"mow\"}\n        ]\n    };\n})\n```\n\nWhen adding a fixture, it will remove any identical fixtures from the list of fixtures. The last fixture added will be the first matched.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/ajaxSettings"
              }
            ],
            "name": "ajaxSettings",
            "description": "An object that is used to match values on an XHR object, namely the url and method. url can be templated like /todos/{_id}."
          },
          {
            "types": [
              {
                "type": "can-fixture.requestHandler"
              }
            ],
            "name": "requestHandler",
            "description": "Handles the request and provides a response. The next section details this function's use.\n"
          }
        ]
      },
      {
        "code": "fixture(ajaxSettings, url)",
        "description": "\n\nRedirects the request to another url.  This can be useful for simulating a response with a file.\n\n```js\nfixture({url: \"/tasks\"}, \"fixtures/tasks.json\");\n```\n\nPlaceholders available in the `ajaxSettings` url will be available in the redirect url:\n\n```js\nfixture({url: \"/tasks/{id}\"}, \"fixtures/tasks/{id}.json\");\n```\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, data)",
        "description": "\n\nResponds with the `JSON.stringify` result of `data`.\n\n```js\nfixture({url: \"/tasks\"}, {tasks: [{id: 1, complete: false}]});\n```\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, delay)",
        "description": "\n\nDelays the ajax request from being made for `delay` milliseconds.\n\n```js\nfixture({url: \"/tasks\"}, 2000);\n```\n\nThis doesn't simulate a response, but is useful for simulating slow connections.\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, null)",
        "description": "\n\nRemoves the matching fixture from the list of fixtures.\n\n```js\nfixture({url: \"/tasks\"}, \"fixtures/tasks.json\");\n\n$.get(\"/tasks\") // requests fixtures/tasks.json\n\nfixture({url: \"/tasks\"}, null);\n\n$.get(\"/tasks\") // requests /tasks\n```\n",
        "params": []
      },
      {
        "code": "fixture(methodAndUrl, url|data|requestHandler)",
        "description": "\n\nA short hand for creating an [can-fixture/types/ajaxSettings] with a `method` and `url`.\n\n```js\nfixture(\"GET /tasks\", requestHandler );\n\n// is the same as\n\nfixture({method: \"get\", url: \"/tasks\"}, requestHandler );\n```\n\nThe format is `METHOD URL`.\n",
        "params": []
      },
      {
        "code": "fixture(url, url|data|requestHandler)",
        "description": "\n\nA short hand for creating an [can-fixture/types/ajaxSettings] with just a `url`.\n\n```js\nfixture(\"/tasks\", requestHandler);\n\n// is the same as\n\nfixture({url: \"/tasks\"}, requestHandler);\n```\n",
        "params": []
      },
      {
        "code": "fixture(fixtures)",
        "description": "\n\nCreate multiple fixtures at once.\n\n```js\nfixture({\n    \"POST /tasks\": function(){\n        return {id: Math.random()}\n    },\n    \"GET /tasks\": {data: [{id: 1, name: \"mow lawn\"}]},\n    \"/people\": \"fixtures/people.json\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "methodAndUrl"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      },
                      {
                        "type": "Object"
                      },
                      {
                        "type": "can-fixture.requestHandler"
                      },
                      {
                        "type": "can-fixture/StoreType"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "fixtures",
            "description": "A mapping of methodAndUrl to\nsome response argument type.\n\n\n"
          }
        ]
      },
      {
        "code": "fixture(restfulUrl, store)",
        "description": "\n\nWire up a restful API scheme to a store.\n\n```js\nvar todoAlgebra = new set.Algebra(\n    set.props.id(\"id\")\n);\nvar todoStore = fixture.store([\n  { id: 1, name: 'Do the dishes'},\n  { id: 2, name: 'Walk the dog'}\n], todoAlgebra);\n\nfixture(\"/api/todos/{id}\", todoStore); // can also be written fixture(\"/api/todos\", todoStore);\n```\n\nThis is a shorthand for wiring up the `todoStore` as follows:\n\n```js\nfixture({\n    \"GET /api/todos\": todoStore.getListData,\n    \"GET /api/todos/{id}\": todoStore.getData,\n    \"POST /api/todos\": todosStore.createData,\n    \"PUT /api/todos/{id}\": todos.updateData,\n    \"DELETE /api/todos/{id}\": todos.destroyData\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "restfulUrl",
            "description": "The url that may include a template for the place of the ID prop.  The `list` url is assumed to be `restfulUrl` with the `/{ID_PROP}` part removed, if provided; otherwise the `item` url is assumed to have the `/{ID_PROP}` part appended to the end."
          },
          {
            "types": [
              {
                "type": "can-fixture/StoreType"
              }
            ],
            "name": "store",
            "description": "A store produced by [can-fixture.store].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-fixture/StoreType"
        }
      ],
      "name": "store",
      "description": "A store produced by [can-fixture.store].\n"
    }
  },
  "can-fixture.fixtures": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.fixtures.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Array",
        "options": []
      }
    ],
    "title": "fixtures",
    "name": "can-fixture.fixtures",
    "type": "property",
    "signatures": [
      {
        "code": "fixture.fixtures",
        "description": "\n\nThe list of currently active fixtures.\n",
        "params": []
      }
    ]
  },
  "can-fixture.on": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.on.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "on",
    "name": "can-fixture.on",
    "type": "property",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.on",
        "description": "\n\nTurns the fixtures on or off. Defaults to `true` for on.\n\n```js\nfixture.on = false; //-> AJAX requests will not be trapped\n```\n\nTo remove a fixture you can also use `fixture(ajaxSetting, null)`.\n",
        "params": []
      }
    ]
  },
  "can-fixture.rand": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.rand.md"
    },
    "body": "",
    "description": "\n",
    "title": "rand",
    "name": "can-fixture.rand",
    "type": "function",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.rand(min, max)",
        "description": "\n\nReturns a random integer in the range [min, max]. If only one argument is provided,\nreturns a random integer from [0, max].\n\n```js\nfixture.rand(1, 10) //-> Random number between 1 and 10 inclusive.\nfixture.rand(10) //-> Random number between 0 and 10 inclusive.\n```",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "min",
            "description": "The lower limit of values that will be returned."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "max",
            "description": "The upper limit of values that will be returned.  `max` is valid return value.\n"
          }
        ]
      },
      {
        "code": "fixture.rand(choices, min, max)",
        "description": "\n\nAn array of between min and max random items from choices. If only `min` is\nprovided, `max` will equal `min`.  If both `max` and `min` are not provided,\n`min` will be 1 and `max` will be `choices.length`.\n\n```js\n// pick a random number of items from an array\nfixture.rand([\"a\",\"b\",\"c\"]) //-> [\"c\"]\nfixture.rand([\"a\",\"b\",\"c\"]) //-> [\"b\",\"a\"]\n\n// pick one item from an array\nfixture.rand([\"a\",\"b\",\"c\"],1) //-> [\"c\"]\n\n// get one item from an array\nfixture.rand([\"a\",\"b\",\"c\"],1)[0] //-> \"b\"\n\n// get 2 or 3 items from the array\nfixture.rand([\"a\",\"b\",\"c\"],2,3) //-> [\"c\",\"a\",\"b\"]\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "choices",
            "description": "An array of values to chose from. The returned array will only include a value once."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "min",
            "description": "The minimum number of items to be in the returned array."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "max",
            "description": "The maximum number of items in the returned array.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "max",
      "description": "The maximum number of items in the returned array.\n"
    }
  },
  "can-fixture.store": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.store.md"
    },
    "body": "",
    "description": "\n",
    "title": "store",
    "name": "can-fixture.store",
    "type": "function",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.store(baseItems, algebra)",
        "description": "\n\nCreate a store that starts with `baseItems` for a service layer\ndescribed by `algebra`.\n\n```js\n// Describe the services parameters:\nvar todoAlgebra = new set.Algebra({\n    set.props.id(\"_id\"),\n    set.props.boolean(\"completed\"),\n    set.props.rangeInclusive(\"start\",\"end\"),\n    set.props.sort(\"orderBy\"),\n});\n\n// Create a store with initial data.\n// Pass [] if you want it to be empty.\nvar todoStore = fixture.store([\n    {\n      _id : 1,\n      name : 'Do the dishes',\n      complete: true\n    }, {\n      _id : 2,\n      name : 'Walk the dog',\n      complete: false\n    }],\n    todoAlgebra );\n\n// Hookup urls to the store:\nfixture(\"/todos/{_id}\", todoStore);\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "baseItems",
            "description": "An array of items that will populate the store."
          },
          {
            "types": [
              {
                "type": "can-set.Algebra"
              }
            ],
            "name": "algebra",
            "description": "A description of the service layer's parameters."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-fixture/StoreType"
            }
          ],
          "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n\n"
        }
      },
      {
        "code": "fixture.store(count, makeItems, algebra)",
        "description": "\n\nSimilar to `fixture.store(baseItems, algebra)`, except that\nit uses `makeItems` to create `count` entries in the store.\n\n```js\n// Describe the services parameters:\nvar todoAlgebra = new set.Algebra({ ... });\n\n// Create a store with initial data.\n// Pass [] if you want it to be empty.\nvar todoStore = fixture.store(\n    1000,\n    function(i){\n        return {\n          _id : i+1,\n          name : 'Todo '+i,\n          complete: fixture.rand([true, false],1)[0]\n        }\n    },\n    todoAlgebra );\n\n// Hookup urls to the store:\nfixture(\"/todos/{_id}\", todoStore);\n```",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "count",
            "description": "TODO describe"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "makeItems",
            "description": "A function that will generate `baseItems`"
          },
          {
            "types": [
              {
                "type": "can-set.Algebra"
              }
            ],
            "name": "algebra",
            "description": "A description of the service layer's parameters."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-fixture/StoreType"
            }
          ],
          "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-fixture/StoreType"
        }
      ],
      "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-set.Algebra"
        }
      ],
      "name": "algebra",
      "description": "A description of the service layer's parameters."
    }
  },
  "can-map.prototype.attr": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.attr.md"
    },
    "body": "`attr` gets or sets properties on the `Map` it's called on. Here's a tour through\nhow all of its forms work:\n\n\n    var people = new Map({});\n\n    // set a property:\n    people.attr('a', 'Alex');\n\n    // get a property:\n    people.attr('a'); // 'Alex'\n\n    // set and merge multiple properties:\n    people.attr({\n        a: 'Alice',\n        b: 'Bob'\n    });\n\n    // get all properties:\n    people.attr(); // {a: 'Alice', b: 'Bob'}\n\n    // set properties while removing others:\n    people.attr({\n        b: 'Bill',\n        e: 'Eve'\n    }, true);\n\n    people.attr(); // {b: 'Bill', e: 'Eve'}\n\n\n## Deep properties\n\n`attr` can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using `attr`.\n\n\n    var people = new Map({names: {}});\n\n    // set a property:\n    people.attr('names.a', 'Alice');\n\n    // get a property:\n    people.attr('names.a'); // 'Alice'\n    people.names.attr('a'); // 'Alice'\n\n    // get all properties:\n    people.attr(); // {names: {a: 'Alice'}}\n\n\nObjects that are added to Observes become Observes themselves behind the scenes,\nso changes to deep properties fire events at each level, and you can bind at any\nlevel. As this example shows, all the same events are fired no matter what level\nyou call `attr` at:\n\n\n    var people = new Map({names: {}});\n\n    people.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    people.names.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    people.bind('names', function(ev, newVal, oldVal) {\n        console.log('people names: ' + newVal + ', ' + oldVal);\n    });\n\n    people.names.bind('a', function(ev, newVal, oldVal) {\n        console.log('people.names a: ' + newVal + ', ' + oldVal);\n    });\n\n    people.bind('names.a', function(ev, newVal, oldVal) {\n        console.log('people names.a: ' + newVal + ', ' + oldVal);\n    });\n\n    people.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined\n                                  // people.names change: a, add, Alice, undefined\n                                  // people.names a: Alice, undefined\n                                  // people names.a: Alice, undefined\n\n    people.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined\n                                  // people.names change: b, add, Bob, undefined\n                                  // people.names b: Bob, undefined\n                                  // people names.b: Bob, undefined\n\n\n## Properties with dots in their name\n\nAs shown above, `attr` enables reading and setting deep properties so special care must be taken when property names include dots '`.`'. To read a property containing dots, escape each one using '`\\`'. This prevents `attr` from performing a deep lookup and throwing an error when the deep property is not found.\n\n```\nvar person = new Map({\n\t'first.name': 'Alice'\n});\n\nperson.attr('first.name'); // throws Error\nperson.attr('first\\.name'); // 'Alice'\n\n```\n\nWhen setting a property containing dots, pass an object to `attr` containing the property name and new value. Setting a property by passing a string to `attr` will attempt to set a deep property and will throw an error.\n\n```\nvar person = new Map({\n\t'first.name': 'Alice'\n});\n\nperson.attr('first.name', 'Bob'); // throws Error\nperson.attr('first\\.name', 'Bob'); // throws Error\nperson.attr({'first.name': 'Bob'}); // Works\n\n```\n\n## See also\n\nFor information on the events that are fired on property changes and how\nto listen for those events, see [can.Map.prototype.bind bind].\n\n",
    "description": "Get or set properties on a Map. \n",
    "title": "attr",
    "name": "can-map.prototype.attr",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 2,
    "signatures": [
      {
        "code": "map.attr()",
        "description": "\n\nGets a collection of all the properties in this `Map`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with all the properties in this `Map`.\n"
        }
      },
      {
        "code": "map.attr(key)",
        "description": "\n\nReads a property from this `Map`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the property to read"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value assigned to _key_.\n"
        }
      },
      {
        "code": "map.attr(key, value)",
        "description": "\n\nAssigns _value_ to a property on this `Map` called _key_.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the property to set"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "the",
            "description": "value to assign to _key_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      },
      {
        "code": "map.attr(obj[, removeOthers])",
        "description": "\n\nAssigns each value in _obj_ to a property on this `Map` named after the\ncorresponding key in _obj_, effectively merging _obj_ into the Map.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "a collection of key-value pairs to set.\nIf any properties already exist on the `Map`, they will be overwritten.\n"
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "removeOthers",
            "defaultValue": "false",
            "description": "whether to remove keys not present in _obj_.\nTo remove keys without setting other keys, use `[can.Map::removeAttr removeAttr]`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "removeOthers",
      "defaultValue": "false",
      "description": "whether to remove keys not present in _obj_.\nTo remove keys without setting other keys, use `[can.Map::removeAttr removeAttr]`.\n"
    },
    "comment": " "
  },
  "can-map.prototype.compute": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.compute.md"
    },
    "body": "\n`compute` is a convenience method for making computes from properties\nof Observes. More information about computes can be found under [can.compute].\n\n\n    var map = new Map({a: 'Alexis'});\n    var name = map.compute('a');\n    name.bind('change', function(ev, nevVal, oldVal) {\n        console.log('a changed from ' + oldVal + 'to' + newName + '.');\n    });\n\n    name(); // 'Alexis'\n\n    map.attr('a', 'Adam'); // 'a changed from Alexis to Adam.'\n    name(); // 'Adam'\n\n    name('Alice'); // 'a changed from Adam to Alice.'\n    name(); // 'Alice'\n\n",
    "description": "Make a can.compute from an observable property. \n",
    "title": "compute",
    "name": "can-map.prototype.compute",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 4,
    "signatures": [
      {
        "code": "map.compute(attrName)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "the property to bind to"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "a [can-compute] bound to _attrName_\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "the property to bind to"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "a [can-compute] bound to _attrName_\n"
    },
    "comment": " "
  },
  "can-map.prototype.bind": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.bind.md"
    },
    "body": "`bind` binds event handlers to property changes on `Map`s. When you change\na property using `attr`, two events are fired on the Map, allowing other parts\nof your application to map the changes to the object.\n\n## The _change_ event\n\nThe first event that is fired is the _change_ event. The _change_ event is useful\nif you want to react to all changes on a Map.\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('Something changed.');\n    });\n\n\nThe parameters of the event handler for the _change_ event are:\n\n- _ev_ The event object.\n- _attr_ Which property changed.\n- _how_ Whether the property was added, removed, or set. Possible values are `'add'`, `'remove'`, or `'set'`.\n- _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n- _oldVal_ This is the value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\nHere is a concrete tour through the _change_ event handler's arguments:\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log(ev + ', ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    o.attr('a', 'Alexis'); // [object Object], a, add, Alexis, undefined\n    o.attr('a', 'Adam');   // [object Object], a, set, Adam, Alexis\n    o.attr({\n        'a': 'Alice',      // [object Object], a, set, Alice, Adam\n        'b': 'Bob'         // [object Object], b, add, Bob, undefined\n    });\n    o.removeAttr('a');     // [object Object], a, remove, undefined, Alice\n\n\n(See also `[can.Map::removeAttr removeAttr]`, which removes properties).\n\n## The _property name_ event\n\nThe second event that is fired is an event whose type is the same as the changed\nproperty's name. This event is useful for noticing changes to a specific property.\n\n\n    var o = new Map({});\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log('The value of a changed.');\n    });\n\n\nThe parameters of the event handler for the _property name_ event are:\n\n- _ev_ The event object.\n- _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n- _oldVal_ The value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\nHere is a concrete tour through the _property name_ event handler's arguments:\n\n\n    var o = new Map({});\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log(ev + ', ' + newVal + ', ' + oldVal);\n    });\n\n    o.attr('a', 'Alexis'); // [object Object], Alexis, undefined\n    o.attr('a', 'Adam');   // [object Object], Adam, Alexis\n    o.attr({\n        'a': 'Alice',      // [object Object], Alice, Adam\n        'b': 'Bob'\n    });\n    o.removeAttr('a');     // [object Object], undefined, Alice\n\n\n## See also\n\nMore information about changing properties on Observes can be found under\n[can.Map.prototype.attr attr].\n\nFor a more specific way to changes on Observes, see the [can.Map.delegate] plugin.\n*/\n\n",
    "description": "Bind event handlers to a Map. \n",
    "title": "bind",
    "name": "can-map.prototype.bind",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 3,
    "signatures": [
      {
        "code": "map.bind(eventType, handler)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "the type of event to bind this handler to"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "comment": " "
  },
  "can-map.prototype": {
    "name": "can-map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-map",
    "description": "",
    "order": 0
  },
  "can-map.static": {
    "name": "can-map.static",
    "title": "static",
    "type": "group",
    "parent": "can-map",
    "description": "",
    "order": 1
  },
  "can-map.prototype.DEFAULT-ATTR": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.default-attr.md"
    },
    "body": "\n## Use\n\nWhen extending [can-map], if a prototype property is not a function,\nit is used as a default value on instances of the extended Map.  For example:\n\n```\nvar Paginate = Map.extend({\n    limit: 20,\n    offset: 0,\n    next: function(){\n        this.attr(\"offset\", this.attr(\"offset\")+this.attr(\"limit\"))\n    }\n});\n\nvar paginate = new Paginate({limit: 30});\n\npaginate.attr(\"offset\") //-> 0\npaginate.attr(\"limit\")  //-> 30\n\npaginate.next();\n\npaginate.attr(\"offset\") //-> 30\n```\n\n",
    "description": "Specify a default property and value. \n",
    "types": [
      {
        "type": "*",
        "description": "A value of any type other than a function that will\nbe set as the `DEFAULT-ATTR` attribute's value.\n"
      }
    ],
    "title": "DEFAULT-ATTR",
    "name": "can-map.prototype.DEFAULT-ATTR",
    "type": "property",
    "parent": "can-map.prototype",
    "order": 1,
    "comment": " "
  },
  "can-map.prototype.removeAttr": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.removeAttr.md"
    },
    "body": "`removeAttr` removes a property by name from a Map.\n\n\n    var people = new Map({a: 'Alice', b: 'Bob', e: 'Eve'});\n\n    people.removeAttr('b'); // 'Bob'\n    people.attr();          // {a: 'Alice', e: 'Eve'}\n\n\nRemoving an attribute will cause a _change_ event to fire with `'remove'`\npassed as the _how_ parameter and `undefined` passed as the _newVal_ to\nhandlers. It will also cause a _property name_ event to fire with `undefined`\npassed as _newVal_. An in-depth description at these events can be found\nunder `[can-map.prototype.attr attr]`.\n\n",
    "description": "Remove a property from a Map. \n",
    "title": "removeAttr",
    "name": "can-map.prototype.removeAttr",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 6,
    "signatures": [
      {
        "code": "map.removeAttr(attrName)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "the name of the property to remove"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value of the property that was removed\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "the name of the property to remove"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value of the property that was removed\n"
    },
    "comment": " "
  },
  "can-map.prototype.each": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.each.md"
    },
    "body": "\n    var names = [];\n    new Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n        names.push(value);\n    });\n\n    names; // ['Alice', 'Bob', 'Eve']\n\n    names = [];\n    new Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n        names.push(value);\n        if(key === 'b') {\n            return false;\n        }\n    });\n\n    names; // ['Alice', 'Bob']\n    \n\n",
    "description": "Call a function on each property of a Map. \n",
    "title": "each",
    "name": "can-map.prototype.each",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 5,
    "signatures": [
      {
        "code": "map.each( callback(item, propName ) )",
        "description": "\n\n`each` iterates through the Map, calling a function\nfor each property value and key.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "propName"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "item"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "propName"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "comment": " "
  },
  "can-map.prototype.serialize": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.serialize.md"
    },
    "body": "",
    "description": "Serialize this object to something that can be passed to `JSON.stringify`. \n",
    "title": "serialize",
    "name": "can-map.prototype.serialize",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 7,
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n\nGet the serialized Object form of the map.  Serialized\ndata is typically used to send back to a server.\n\n\n    o.serialize() //-> { name: 'Justin' }\n\n\nSerialize currently returns the same data\nas [can.Map.prototype.attrs].  However, in future\nversions, serialize will be able to return serialized\ndata similar to [can.Model].  The following will work:\n\n\n    new Map({time: new Date()})\n        .serialize() //-> { time: 1319666613663 }\n\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a JavaScript Object that can be\nserialized with `JSON.stringify` or other methods.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a JavaScript Object that can be\nserialized with `JSON.stringify` or other methods.\n"
    }
  },
  "can-map.prototype.unbind": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.unbind.md"
    },
    "body": "`unbind` unbinds event handlers previously bound with [can-map.prototype.bind bind].\nIf no _handler_ is passed, all handlers for the given event type will be unbound.\n\n\n    var i = 0,\n        increaseBy2 = function() { i += 2; },\n        increaseBy3 = function() { i += 3; },\n        o = new Map();\n\n    o.bind('change', increaseBy2);\n    o.bind('change', increaseBy3);\n    o.attr('a', 'Alice');\n    i; // 5\n\n    o.unbind('change', increaseBy2);\n    o.attr('b', 'Bob');\n    i; // 8\n\n    o.unbind('change');\n    o.attr('e', 'Eve');\n    i; // 8\n\n",
    "description": "Unbind event handlers from a Map. \n",
    "title": "unbind",
    "name": "can-map.prototype.unbind",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 8,
    "signatures": [
      {
        "code": "map.unbind(eventType[, handler])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "the type of event to unbind, exactly as passed to `bind`"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "handler",
            "description": "the handler to unbind\n\n```js\nvar map = new Map({ a: 1 });\n\nfunction log(){\n\tconsole.log(\"val\", map.attr(\"a\");\n}\n\nmap.bind(\"change\", log);\n\nmap.attr(\"a\", 2);\n\n// Bind callback called.\nmap.unbind(\"change\", log);\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "handler",
      "description": "the handler to unbind\n\n```js\nvar map = new Map({ a: 1 });\n\nfunction log(){\n\tconsole.log(\"val\", map.attr(\"a\");\n}\n\nmap.bind(\"change\", log);\n\nmap.attr(\"a\", 2);\n\n// Bind callback called.\nmap.unbind(\"change\", log);\n```\n"
    },
    "comment": " "
  },
  "can-map.keys": {
    "src": {
      "path": "node_modules/can-map/docs/static.keys.md"
    },
    "body": "",
    "description": "Returns an array of the map's keys. \n",
    "title": "keys",
    "name": "can-map.keys",
    "type": "function",
    "parent": "can-map.static",
    "order": 0,
    "signatures": [
      {
        "code": "Map.keys(map)",
        "description": "\n\n```js\nvar people = new Map({\n\t\ta: 'Alice',\n\t\tb: 'Bob',\n\t\te: 'Eve'\n});\n\nMap.keys(people); // ['a', 'b', 'e']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-map"
              }
            ],
            "name": "map",
            "description": "the `Map` to get the keys from"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "array An array containing the keys from _map_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "name": "map",
      "description": "the `Map` to get the keys from"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "array An array containing the keys from _map_.\n"
    }
  },
  "can-list.extend": {
    "src": {
      "path": "node_modules/can-list/docs/extend.md"
    },
    "body": "",
    "description": "\n",
    "title": "extend",
    "name": "can-list.extend",
    "type": "function",
    "parent": "can-list.static",
    "signatures": [
      {
        "code": "List.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function. Learn more at [can.Construct.extend].\n\n```js\nvar MyList = List.extend({}, {\n\t// silly unnecessary method\n\tcount: function(){\n\t\treturn this.attr('length');\n\t}\n});\n\nvar list = new MyList([{}, {}]);\nconsole.log(list.count()); // -> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "If provided, adds the extened List constructor function to the window at the given name.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties and methods directly on the constructor function. The most common property to set is [can-list.Map].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "instanceProperties",
            "description": "Properties and methods on instances of this list type.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "instanceProperties",
      "description": "Properties and methods on instances of this list type.\n"
    }
  },
  "can-list.Map": {
    "src": {
      "path": "node_modules/can-list/docs/Map.md"
    },
    "body": "",
    "description": "Specify the Map type used to make objects added to this list observable. \n",
    "types": [
      {
        "type": "can-map",
        "description": "When objects are added to a `List`, those objects are converted into can.Map instances. For example:\n\n     var list = new List();\n     list.push({name: \"Justin\"});\n\n     var map = list.attr(0);\n     map.attr(\"name\") //-> \"Justin\"\n\nBy changing [can-list.Map], you can specify a different type of Map instance to create. For example:\n\n     var User = Map.extend({\n       fullName: function(){\n         return this.attr(\"first\")+\" \"+this.attr(\"last\")\n       }\n     });\n\n     User.List = List.extend({\n       Map: User\n     }, {});\n\n     var list = new User.List();\n     list.push({first: \"Justin\", last: \"Meyer\"});\n\n     var user = list.attr(0);\n     user.fullName() //-> \"Justin Meyer\"\n"
      }
    ],
    "title": "Map",
    "name": "can-list.Map",
    "type": "property",
    "parent": "can-list.static"
  },
  "can-list.prototype": {
    "name": "can-list.prototype",
    "title": "Prototype",
    "type": "group",
    "parent": "can-list",
    "description": "",
    "order": 0
  },
  "can-list.static": {
    "name": "can-list.static",
    "title": "Static",
    "type": "group",
    "parent": "can-list",
    "description": "",
    "order": 1
  },
  "can-list.prototype.filter": {
    "src": {
      "path": "node_modules/can-list/docs/filter.md"
    },
    "body": "\nA filter function that accepts a function, which is run on every element of the list.  If the \nfilter callback returns true, the list returned will contain this item, false and it will not.\n\nReturns a new List instance.\n\t\n\tvar list = new List([1, 2, 3])\n\n\t// returns new List([1, 2])\n\tvar filtered = list.filter( function(item, index, list)\n\t{\n\t\treturn item < 3;\n\t}); \n\n",
    "description": "Filter the elements of a List, returning a new List instance with just filtered items. \n",
    "title": "filter",
    "name": "can-list.prototype.filter",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.filter(filterFunc, context)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "Boolean"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can.List"
                      }
                    ],
                    "name": "list"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "filterFunc",
            "description": "A function to call with each element of the list. Returning `false` will remove the index."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "The object to use as `this` inside the callback.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "context",
      "description": "The object to use as `this` inside the callback.\n"
    },
    "comment": " "
  },
  "can-list.prototype.each": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.each.md"
    },
    "body": "```\nvar i = 0;\nnew List([1, 10, 100]).each(function(element, index) {\n    i += element;\n});\n\ni; // 111\n\ni = 0;\nnew List([1, 10, 100]).each(function(element, index) {\n    i += element;\n    if(index >= 1) {\n        return false;\n    }\n});\n\ni; // 11\n```\n\n",
    "description": "Call a function on each element of a List. ",
    "name": "can-list.prototype.each",
    "title": "each",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.each( callback(item, index) )",
        "description": "\n\n`each` iterates through the List, calling a function\nfor each element.\n\n```js\nvar list = new List([1, 2, 3]);\n\nlist.each(function(elem){\n\tconsole.log(elem);\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "this List, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "this List, for chaining\n"
    },
    "comment": " "
  },
  "can-list.prototype.map": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.map.md"
    },
    "body": "```\nvar list = new List([1, 10, 100, 1000, 10000, 100000]);\nvar newList = list.map(function(element, index, listReference) {\n  var result;\n\n  switch(index) {\n    case 0: {\n      result = false;\n      break;\n    }\n    case 1: {\n      result = undefined;\n      break;\n    }\n    case 2: {\n      result = element;\n      break;\n    }\n    case 3: {\n      result = element * 5;\n      break;\n    }\n    default: {\n      result = listReference[index] /= 2;\n      break;\n    }\n  }\n\n  return result;\n});\n\nconsole.log(list);    // [    1,        10, 100, 1000, 5000, 50000]\nconsole.log(newList); // [false, undefined, 100, 5000, 5000, 50000]\n```\n\n",
    "description": "Call a function on each element of a List and return a new List instance from the results. ",
    "title": "map",
    "name": "can-list.prototype.map",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.map( callback(item, index, listReference), context )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can.List"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each\nelement of the list."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "An optional object to use as `this` inside the callback.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "A new can.List instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "context",
      "description": "An optional object to use as `this` inside the callback.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "A new can.List instance.\n"
    },
    "comment": " "
  },
  "can-list.prototype.attr": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.attr.md"
    },
    "body": "\n\n## Use\n\n`attr` gets or sets elements on the `List` it's called on. Here's a tour through how all of its forms work:\n\n     var people = new List(['Alex', 'Bill']);\n\n     // set an element:\n     people.attr(0, 'Adam');\n\n     // get an element:\n     people.attr(0); // 'Adam'\n     people[0]; // 'Adam'\n\n     // get all elements:\n     people.attr(); // ['Adam', 'Bill']\n\n     // extend the array:\n     people.attr(4, 'Charlie');\n     people.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n     // merge the elements:\n     people.attr(['Alice', 'Bob', 'Eve']);\n     people.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']\n\n## Deep properties\n\n`attr` can also set and read deep properties. All you have to do is specify the property name as you normally would if you weren't using `attr`.\n\n```\nvar people = new List([{name: 'Alex'}, {name: 'Bob'}]);\n\n// set a property:\npeople.attr('0.name', 'Alice');\n\n// get a property:\npeople.attr('0.name');  // 'Alice'\npeople[0].attr('name'); // 'Alice'\n\n// get all properties:\npeople.attr(); // [{name: 'Alice'}, {name: 'Bob'}]\n```\n\nThe discussion of deep properties under `[can-map.prototype.attr]` may also be enlightening.\n\n## Events\n\n`List`s emit five types of events in response to changes. They are:\n\n- the _change_ event fires on every change to a List.\n- the _set_ event is fired when an element is set.\n- the _add_ event is fired when an element is added to the List.\n- the _remove_ event is fired when an element is removed from the List.\n- the _length_ event is fired when the length of the List changes.\n\n### The _change_ event\n\nThe first event that is fired is the _change_ event. The _change_ event is useful\nif you want to react to all changes on an List.\n\n```\nvar list = new List([]);\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log('Something changed.');\n});\n```\n\nThe parameters of the event handler for the _change_ event are:\n\n- _ev_ The event object.\n- _index_ Where the change took place.\n- _how_ Whether elements were added, removed, or set.\n Possible values are `'add'`, `'remove'`, or `'set'`.\n- _newVal_ The elements affected after the change\n _newVal_ will be a single value when an index is set, an Array when elements\nwere added, and `undefined` if elements were removed.\n- _oldVal_ The elements affected before the change.\n_newVal_ will be a single value when an index is set, an Array when elements\nwere removed, and `undefined` if elements were added.\n\nHere is a concrete tour through the _change_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\nlist.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined\nlist.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined\nlist.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis\nlist.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam\n                               // [object Object], 1, set, Bob, Bill\nlist.removeAttr(1);            // [object Object], 1, remove, undefined, Bob\n```\n\n### The _set_ event\n\n_set_ events are fired when an element at an index that already exists in the List is modified. Actions can cause _set_ events to fire never also cause _length_ events to fire (although some functions, such as `[can-list.prototype.splice splice]` may cause unrelated sets of events to fire after being batched).\n\nThe parameters of the event handler for the _set_ event are:\n\n- _ev_ The event object.\n- _newVal_ The new value of the element.\n- _index_ where the set took place.\n\nHere is a concrete tour through the _set_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('set', function(ev, newVal, index) {\n    console.log(newVal + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');\nlist.attr(0, 'Adam');          // Adam, 0\nlist.attr(['Alice', 'Bob']);   // Alice, 0\n                               // Bob, 1\nlist.removeAttr(1);\n```\n\n### The _add_ event\n\n_add_ events are fired when elements are added or inserted\ninto the List.\n\nThe parameters of the event handler for the _add_ event are:\n\n- _ev_ The event object.\n- _newElements_ The new elements.\n If more than one element is added, _newElements_ will be an array. Otherwise, it is simply the new element itself.\n- _index_ Where the add or insert took place.\n\nHere is a concrete tour through the _add_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('add', function(ev, newElements, index) {\n    console.log(newElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0\nlist.attr(2, 'Eve');           // Eve, 2\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);\n```\n\n### The _remove_ event\n\n_remove_ events are fired when elements are removed from the list.\n\nThe parameters of the event handler for the _remove_ event are:\n\n- _ev_ The event object.\n- _removedElements_ The removed elements.\n If more than one element was removed, _removedElements_ will be an array. Otherwise, it is simply the element itself.\n- _index_ Where the removal took place.\n\nHere is a concrete tour through the _remove_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('remove', function(ev, removedElements, index) {\n    console.log(removedElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);            // Bob, 1\n```\n\n### The _length_ event\n\n_length_ events are fired whenever the list changes.\n\nThe parameters of the event handler for the _length_ event are:\n\n- _ev_ The event object.\n- _length_ The current length of the list.\n If events were batched when the _length_ event was triggered, _length_ will have the length of the list when `stopBatch` was called. Because of this, you may receive multiple _length_ events with the same _length_ parameter.\n\nHere is a concrete tour through the _length_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('length', function(ev, length) {\n    console.log(length);\n});\n\nlist.attr(['Alexis', 'Bill']); // 2\nlist.attr(2, 'Eve');           // 3\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);            // 2\n```\n\n",
    "description": "Get or set elements in a List. \n",
    "title": "attr",
    "name": "can-list.prototype.attr",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.attr()",
        "description": "\n\nGets an array of all the elements in this `List`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "An array with all the elements in this List.\n"
        }
      },
      {
        "code": "list.attr(index)",
        "description": "\n\nReads an element from this `List`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The element to read."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at _index_.\n"
        }
      },
      {
        "code": "list.attr(index, value)",
        "description": "\n\nAssigns _value_ to the index _index_ on this `List`, expanding the list if necessary.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The element to set."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign at _index_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      },
      {
        "code": "list.attr(elements[, replaceCompletely])",
        "description": "\n\nMerges the members of _elements_ into this List, replacing each from the beginning in order. If _elements_ is longer than the current List, the current List will be expanded. If _elements_ is shorter than the current List, the extra existing members are not affected (unless _replaceCompletely_ is `true`). To remove elements without replacing them, use `[can-map::removeAttr removeAttr]`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "elements",
            "description": "An array of elements to merge in.\n"
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "replaceCompletely",
            "defaultValue": "false",
            "description": "whether to completely replace the elements of List\n\nIf _replaceCompletely_ is `true` and _elements_ is shorter than the List, the existing extra members of the List will be removed.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "This list, for chaining.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "replaceCompletely",
      "defaultValue": "false",
      "description": "whether to completely replace the elements of List\n\nIf _replaceCompletely_ is `true` and _elements_ is shorter than the List, the existing extra members of the List will be removed.\n"
    },
    "comment": " "
  },
  "can-list.prototype.reverse": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.reverse.md"
    },
    "body": "```\nvar list = new List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n\n`reverse` calls `replace` internally and triggers corresponding `add`, `remove`, `change` and `length` events respectively.\n\n## Demo\n\n<div class='iframe_wrapper' data-iframe-src='can/list/doc/reverse.html' data-iframe-height='350'></div>\n",
    "description": "Reverse the order of a List. ",
    "title": "reverse",
    "name": "can-list.prototype.reverse",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\n`reverse` reverses the elements of the List in place.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "the List, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-list"
        }
      ],
      "description": "the List, for chaining\n"
    },
    "comment": " "
  },
  "can-define.types.ValueConstructor": {
    "src": {
      "path": "node_modules/can-define/docs/ValueConstructor.md"
    },
    "body": "\n\n## Use\n\n```js\nvar Address = DefineMap.extend({\n    street: {type: \"string\", value: \"321 Longbow\"},\n    city: {type: \"string\", value: \"Dallas\"}\n});\n\nvar Direction = DefineMap.extend({\n    from: {Type: Address, Value: Address},\n    to: {Type: Address, Value: Address}\n});\n\nvar direction = new Direction({\n    to: {street: \"2070 N. Stave\"}\n});\n\ndirection.from.street //-> \"321 Longbow\"\ndirection.to.street   //-> \"2070 N. Stave\"\n```\n\n",
    "description": "\nProvides a constructor function to be used to provide a default value for a property.  \n",
    "title": "Value",
    "name": "can-define.types.ValueConstructor",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Value",
        "description": "\n\nA constructor function can be provided that is called to create a default value used for this property.\nThis constructor will be invoked with `new` for each created instance. The default\nvalue is created on demand when the property is read for the first time.\n\nSpecify `Value` like:\n\n```js\nprop: {\n    Value: Array\n},\nperson: {\n\tValue: Person\n}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-list.prototype.splice": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.splice.md"
    },
    "body": " `splice` lets you remove elements from and insert elements into a List.\n\n This example demonstrates how to do surgery on a list of numbers:\n\n```\n var list = new List([0, 1, 2, 3]);\n\n // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n list.splice(2, 1, 'Alice', 'Bob');\n list.attr(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n ## Events\n\n `splice` causes the List it's called on to emit _change_ events,\n _add_ events, _remove_ events, and _length_ events. If there are\n any elements to remove, a _change_ event, a _remove_ event, and a\n _length_ event will be fired. If there are any elements to insert, a\n separate _change_ event, an _add_ event, and a separate _length_ event\n will be fired.\n\n This slightly-modified version of the above example should help\n make it clear how `splice` causes events to be emitted:\n\n```\n var list = new List(['a', 'b', 'c', 'd']);\n list.bind('change', function(ev, attr, how, newVals, oldVals) {\n     console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n });\n list.bind('add', function(ev, newVals, where) {\n     console.log('add: ' + newVals + ', ' + where);\n });\n list.bind('remove', function(ev, oldVals, where) {\n     console.log('remove: ' + oldVals + ', ' + where);\n });\n list.bind('length', function(ev, length) {\n     console.log('length: ' + length + ', ' + this.attr());\n });\n\n // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n list.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                    // remove: ['c'], 2\n                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                    // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                    // add: ['Alice', 'Bob'], 2\n                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n```\n\n More information about binding to these events can be found under [can.List.attr attr].\n\n",
    "description": "Insert and remove elements from a List. ",
    "title": "splice",
    "name": "can-list.prototype.splice",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newElements]])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "where to start removing or inserting elements\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "the number of elements to remove\n If _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the List.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newElements",
            "description": "elements to insert into the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the elements removed by `splice`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newElements",
      "description": "elements to insert into the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the elements removed by `splice`\n"
    },
    "comment": " "
  },
  "can-define.types.TypeConstructor": {
    "src": {
      "path": "node_modules/can-define/docs/TypeConstructor.md"
    },
    "body": "\n\n## Use\n\n```js\nvar Address = DefineMap.extend({\n    street: \"string\",\n    city: \"string\"\n});\n\nvar Direction = DefineMap.extend({\n    from: {Type: Address},\n    to: Address\n});\n\nvar direction = new Direction({\n    from: {street: \"2060 N. Stave\", city: \"Chicago\"},\n    to: new Address({street: \"123 Greenview\", city: \"Libertyville\"})\n});\n```\n\n",
    "description": "\nProvides a constructor function to be used to convert any set value into an appropriate\nvalue.\n",
    "type": "typedef",
    "title": "Type",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      },
      {
        "type": "can-define.types.propDefinition"
      },
      {
        "type": "Array",
        "options": []
      }
    ],
    "name": "can-define.types.TypeConstructor",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Type",
        "description": "\n\nA constructor function can be provided that is called to convert incoming values set on this property, like:\n\n```js\nprop: {\n  Type: Person\n}\n```    \n\n`Type` is called before [can-define.types.type] and before [can-define.types.set]. It checks if the incoming value\nis an [instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) `Type`. If it is, or if it is `null` or `undefined`, it passes the original value through.  If not, it passes the original value to `new Type(originalValue)` and returns the\nnew instance to be set.\n",
        "params": []
      },
      {
        "code": "{propDefinition}",
        "description": "\n\nA [can-define.types.propDefinition] that defines an inline [can-define/map/map] type.  For example:\n\n```js\naddress: {\n    Type: {\n        street: \"string\",\n        city: \"string\"\n    }\n}\n```\n",
        "params": []
      },
      {
        "code": "[Type|propDefinition]",
        "description": "\n\nDefines an inline [can-define/list/list] type that's an array of `Type` or inline `propDefinition` [can-define/map/map]\ninstances.  For example:\n\n```js\npeople: {\n    Type: [Person]\n},\naddresses: {\n    Type: [{\n        street: \"string\",\n        city: \"string\"\n    }]\n}\n```\n\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define.static": {
    "name": "can-define.static",
    "title": "static",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 0
  },
  "can-define.typedefs": {
    "name": "can-define.typedefs",
    "title": "types",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 1
  },
  "can-define.behaviors": {
    "name": "can-define.behaviors",
    "title": "behaviors",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 2
  },
  "can-define": {
    "src": {
      "path": "node_modules/can-define/docs/define.md"
    },
    "body": "\n\n## Use\n\n`can-define` provides a way to create custom types with observable properties.\nWhere [can-define/map/map] and [can-define/list/list] provide more functionality, they also make\nmore assumptions on the type constructor.  `can-define` can be used\nto create completely customized types.\n\n\nThe following creates a\n`Person` constructor function:\n\n```js\nvar define = require(\"can-define\");\n\nvar Person = function(first, last){\n  this.first = first;\n  this.last = last;\n};\ndefine(Person.prototype,{\n  first: { type: \"string\" },\n  last: { type: \"string\" },\n  fullName: {\n    get: function(){\n      return this.first+\" \"+this.last;\n    }\n  }\n});\n```\n\nThis can be used to create `Person` instances with observable properties:\n\n```js\nvar person = new Person(\"Justin\", \"Meyer\");\nperson.first    //-> \"Justin\"\nperson.last     //-> \"Meyer\"\nperson.fullName //-> \"Justin Meyer\"\n\nperson.on(\"fullName\", function(ev, newVal, oldVal){\n    newVal //-> \"Ramiya Meyer\"\n    oldVal //-> \"Justin Meyer\"\n});\n\nperson.first = \"Ramiya\"\n```\n\nThe observable properties call [can-observation.add Observation.add] so they can be observed by\n[can-compute].\n\n",
    "description": "Exports the `define` method that defines observable properties and their behavior on a prototype object.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define",
    "parent": "can-core",
    "signatures": [
      {
        "code": "define(prototype, propDefinitions)",
        "description": "\n\nDefine observable properties, type conversion, and getter/setter logic on [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain prototype objects].\n\n```js\nvar define = require(\"can-define\");\n\nvar Greeting = function(message){\n    this.message = message;\n};\n\ndefine(Greeting.prototype,{\n    message: {type: \"string\"}\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "prototype",
            "description": "The prototype object of a constructor function or [class](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class). The prototype\nobject will have getter/setters defined on it that carry out the defined behavior.  The prototype will also contain\nall of [can-event]'s methods.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "propDefinitions",
            "description": "An object of\nproperties and their definitions.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "propDefinitions",
      "description": "An object of\nproperties and their definitions.\n\n"
    },
    "comment": " "
  },
  "can-define.types.serialize": {
    "src": {
      "path": "node_modules/can-define/docs/serialize.md"
    },
    "body": "\n\n## Use\n\n[can-define/map/map.prototype.serialize] is useful for serializing an instance into\na more JSON-friendly form.  This can be used for many reasons, including saving a\n[can-connect]ed instance on the server or serializing [can-route.map can-route.map]'s internal\nmap for display in the hash or pushstate URL.\n\nThe serialize property allows an opportunity to define how\neach property will behave when the instance is serialized.  This can be useful for:\n\n- serializing complex types like dates, arrays, or objects into string formats\n- causing certain properties to be ignored when serialize is called\n\nThe following causes a locationIds property to be serialized into\nthe comma separated ID values of the location property on this instance:\n\n```js\nlocationIds: {\n    serialize: function(){\n        return this.locations.map(function(location){\n            ids.push(location.id);\n        }).join(',');\n    }\n}\n```\n\nReturning `undefined` for any property means this property will not be part of the serialized\nobject.  For example, if the property numPages is not greater than zero, the following example\nwon't include it in the serialized object.\n\n```js\nprop: {\n    numPages: {\n        serialize: function( num ){\n            if(num <= 0) {\n            \treturn undefined;\n            }\n            return num;\n        }\n    }\n}\n```\n\n",
    "description": "\nDefines custom serialization behavior for a property.\n",
    "title": "serialize",
    "name": "can-define.types.serialize",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Boolean",
        "description": "\n\nSpecifies if the property should be serialized.  By default, all properties except for\nones with defined [can-define.types.get getters] are serialized. Prevent a property\nfrom being serialized like:\n\n```js\npropertyName: {\n    serialize: false\n}\n```\n\nMake a [can-define.types.get getter] property part of the serialized result like:\n\n```js\npropertyName: {\n    get: function(){ ... },\n    serialize: true\n}\n```\n",
        "params": []
      },
      {
        "code": "serialize( currentValue, propertyName )",
        "description": "\n\nSpecifies the serialized value of a property.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "currentValue",
            "description": "The current value of the attribute.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The name of the property being serialized.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If `undefined` is returned, the value is not serialized.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "propertyName",
      "description": "The name of the property being serialized.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If `undefined` is returned, the value is not serialized.\n"
    },
    "comment": " "
  },
  "can-define.types": {
    "src": {
      "path": "node_modules/can-define/docs/define.types.md"
    },
    "body": "\n\n## Use\n\nUse any of the type names on a [can-define.types.propDefinition]'s `type` or directly on the prototype of a [can-define/map/map DefineMap] or [can-define/map/map DefineList].\n\n```js\nvar define = require(\"can-define\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Animal = function(name){\n    this.name = name;\n};\ndefine(Animal.prototype,{\n    name: {type: \"string\"}\n});\n\nvar Person = DefineMap.extend({\n    name: \"string\"\n});\n```\n\nYou can also pass these functions in directly:\n\n\n```js\nvar define = require(\"can-define\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Animal = function(name){\n    this.name = name;\n};\ndefine(Animal.prototype,{\n    name: {type: define.type.string}\n});\n\nvar Person = DefineMap.extend({\n    name: define.type.string\n});\n```\n\n",
    "description": "Defines the type, initial value, and get, set, and serialize behavior for an\nobservable property. All type converters leave `null` and `undefined` as is except for\nthe `\"htmlbool\"` type converter.\n",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "observable",
            "description": "The default type behavior. It converts plain Objects to\n[can-define/map/map DefineMaps] and plain Arrays to [can-define/list/list DefineLists]. Everything else is left as is.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "any",
            "description": "Leaves the set value as is, performs no type conversion. Aliased as `*`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "string",
            "description": "Converts to a string with `\"\"+val`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "date",
            "description": "Converts to a JavaScript date using `Date.parse(val)` if a string is given or `new Date(val)` if a number is passed.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "number",
            "description": "Converts to a number with `+(val)`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "boolean",
            "description": "Converts to `false` if `val` is falsey, `\"0\"`, or `\"false\"`; otherwise, converts to `true`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "htmlbool",
            "description": "Like `boolean`, but converts to `true` if empty string (`\"\"`) is passed.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "compute",
            "description": "Allows computes to be passed and the property take on the value of the compute.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "stringOrObservable",
            "description": "Converts plain Objects to [can-define/map/map DefineMaps], plain Arrays to [can-define/list/list DefineLists] and everything else to strings.  This is useful for routing.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "title": "types",
    "name": "can-define.types",
    "type": "property",
    "parent": "can-define.static",
    "comment": " "
  },
  "can-define.types.type": {
    "src": {
      "path": "node_modules/can-define/docs/type.md"
    },
    "body": "\n\n## Use\n\nThe `type` property specifies the type of the attribute.  The type can be specified\nas either:\n\n- A type function that returns the type coerced value.\n- A named type in [can-define.types].\n- An object that gets converted into an inline `DefineMap`.\n- An array that gets converted to an inline `DefineList`.\n\n### Basic Example\n\nThe following example converts the `count` property to a number and the `items` property to an array:\n\n```js\nDefineMap.extend({\n    count: {type: \"number\"},\n    items: {\n        type: function(newValue){\n            if(typeof newValue === \"string\") {\n                return newValue.split(\",\")\n            } else if( Array.isArray(newValue) ) {\n                return newValue;\n            }\n        }\n    }\n});\n```\n\nWhen a user tries to set those properties like:\n\n    map.set({count: \"4\", items: \"1,2,3\"});\n\nThe number converter will be used to turn count into 4, and the items type converter function will be used to turn items into [1,2,3].\n\n### Preventing Arrays and Objects from Automatic Conversion\n\nWhen an array value is set, it is automatically converted into a DefineList. Likewise, objects are converted into DefineMap instances. This behavior can be prevented like the following:\n\n\n     locations: {type: \"any\"}\n\n\nWhen a user tries to set this property, the resulting value will remain an array.\n\n    map.locations = [1, 2, 3]; // locations is an array, not a DefineList\n\n### Working with the 'compute' type\n\nSetting type as `compute` allows for resolving a computed property with the .attr()\nmethod.\n\n```\nMyMap = DefineMap.extend({\n    value: {\n        type: \"compute\"\n    }\n});\n\nvar myMap = new MyMap();\nvar c = compute(5);\n\nmyMap.value = c;\nmyMap.value //-> 5\n\nc(6);\nmyMap.value //-> 6\n\n//Be sure if setting to pass the new compute\nvar c2 = compute(\"a\");\nmyMap.value = c2;\nmyMap.value //-> \"a\"\n```\n\n",
    "description": "\nConverts a value set on an instance into an appropriate value.\n",
    "type": "typedef",
    "title": "type",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      },
      {
        "type": "string"
      }
    ],
    "name": "can-define.types.type",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "type(newValue, propertyName)",
        "description": "\n\nGiven the set value, transform it into a value appropriate to be set.\n`type` is called before [can-define.types.set].  \n\n```js\nage: {\n    type: function(newValue, propertyName){\n        return +newValue;\n    }\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newValue",
            "description": "The value set on the property."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The property name being set.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
        }
      },
      {
        "code": "\"typeName\"",
        "description": "\n\nSets the type to a named type in [can-define.types].  The default typeName is `\"observable\"`.\n\n```js\nage: {\n    type: \"number\"\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "typeName",
            "description": "A named type in [can-define.types].\n\n"
          }
        ]
      },
      {
        "code": "{propDefinition}",
        "description": "\n\nA [can-define.types.propDefinition] that defines an inline [can-define/map/map] type.  For example:\n\n```js\naddress: {\n    type: {\n        street: \"string\",\n        city: \"string\"\n    }\n}\n```\n",
        "params": []
      },
      {
        "code": "[Type|propDefinition]",
        "description": "\n\nDefines an inline [can-define/list/list] type that's an array of `Type` or inline `propDefinition` [can-define/map/map]\ninstances.  For example:\n\n```js\npeople: {\n    type: [Person]\n},\naddresses: {\n    type: [{\n        street: \"string\",\n        city: \"string\"\n    }]\n}\n```\n\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
    },
    "comment": " "
  },
  "can-define.types.get": {
    "src": {
      "path": "node_modules/can-define/docs/types.get.md"
    },
    "body": "\n\n\n## Use\n\nGetter methods are useful for:\n\n - Defining virtual properties on a map.\n - Defining property values that change with their _internal_ set value.\n\n## Virtual properties\n\n\nVirtual properties are properties that don't actually store any value, but derive their value\nfrom some other properties on the map.\n\nWhenever a getter is provided, it is wrapped in a [can.compute], which ensures\nthat whenever its dependent properties change, a change event will fire for this property also.\n\n```js\nvar Person = DefineMap.extend({\n    first: \"string\",\n    last: \"string\",\n\tfullName: {\n\t\tget: function () {\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n});\n\nvar p = new Person({first: \"Justin\", last: \"Meyer\"});\n\np.fullName; // \"Justin Meyer\"\n\np.on(\"fullName\", function(ev, newVal){\n  newVal //-> \"Lincoln Meyer\";\n});\n\np.first = \"Lincoln\";\n```\n\n## Asynchronous virtual properties\n\nOften, a virtual property's value only becomes available after some period of time.  For example,\ngiven a `personId`, one might want to retrieve a related person:\n\n```js\nvar AppState = DefineMap.extend({\n    personId: \"number\",\n    person: {\n        get: function(lastSetValue, resolve){\n          Person.get({id: this.personId})\n        \t.then(function(person){\n                       resolve(person);\n        \t});\n        }\n    }\n});\n```\n\nAsynchronous properties should be bound to before reading their value.  If\nthey are not bound to, the `get` function will be called each time.\n\nThe following example will make multiple `Person.get` requests:\n\n```\nvar state = new AppState({personId: 5});\nstate.person //-> undefined\n\n// called sometime later ...\nstate.person //-> undefined\n```\n\nHowever, by binding, the compute only reruns the `get` function once `personId` changes:\n\n```\nvar state = new AppState({personId: 5});\n\nstate.on(\"person\", function(){})\n\nstate.person //-> undefined\n\n// called sometime later\nstate.person //-> Person<{id: 5}>\n```\n\nA template like [can-stache] will automatically bind for you, so you can pass\n`state` to the template like the following without binding:\n\n```\nvar template = stache(\"<span>{{person.fullName}}</span>\");\nvar state = new AppState({});\nvar frag = template(state);\n\nstate.personId = 5;\nfrag.childNodes[0].innerHTML //=> \"\"\n\n// sometime later\nfrag.childNodes[0].innerHTML //=> \"Lincoln Meyer\"\n```\n\nThe magic tags are updated as `personId`, `person`, and `fullName` change.\n\n\n## Properties values that change with their _internal_ set value\n\nA getter can be used to derive a value from a set value. A getter's\n`lastSetValue` argument is the last value set by `instance.propertyName = value`.\n\nFor example, a property might be set to a compute, but when read, provides the value\nof the compute.\n\n```\nvar MyMap = DefineMap.extend({\n    value: {\n        get: function( lastSetValue ){\n            return lastSetValue();\n        }\n    }\n});\n\nvar map = new MyMap();\nvar compute = compute(1);\nmap.value = compute;\n\nmap.value //-> 1\ncompute(2);\nmap.value //-> 2\n```\n\nThis technique should only be used when the `lastSetValue` is some form of\nobservable, that when it changes, can update the `getter` value.\n\nFor simple conversions, [can-define.types.set] or [can-define.types.type] should be used.\n\n## Updating the virtual property value\n\nIt's common to update virtual property values\ninstead of replacing it.\n\nThe following example creates an empty `locationIds` [can-define/list/list] when a new\ninstance of `Store` is created.  However, as `locations` change,\nthe [can-define/list/list] will be updated with the `id`s of the `locations`.\n\n\n```\nvar Store = DefineMap.extend({\n    locations: DefineList,\n\tlocationIds: {\n\t\tValue: DefineList,\n\t\tget: function(initialValue){\n\t\t\tvar ids = this.locations.map(function(location){\n\t\t\t\tids.push(location.id);\n\t\t\t});\n\t\t\treturn initialValue.replace(ids);\n\t\t}\n\t}\n});\n```\n\n",
    "description": "\nSpecify what happens when a certain property is read on a map. `get` functions\nwork like a [can-compute] and automatically update themselves when a dependent\nobservable value is changed.\n",
    "title": "get",
    "name": "can-define.types.get",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "get( [lastSetValue] )",
        "description": "\n\nDefines the behavior when a property value is read on a instance. Used to provide properties that derive their value from\nother properties on the object, or the property value that was set on the object.\n\nSpecify `get` like:\n\n```js\npropertyName: {\n    get: function(){ ... }\n},\npropertyName: {\n    get: function(lastSetValue) { ... }\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The value last set by `instance.propertyName = value`.  Typically, _lastSetValue_\nshould be an observable value, like a [can-compute] or promise. If it's not, it's likely\nthat a [can-define.types.set] should be used instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property.\n"
        }
      },
      {
        "code": "get( lastSetValue, resolve(value) )",
        "description": "\n\nAsynchronously defines the behavior when a value is read on an instance. Used to provide property values that\nare available asynchronously.\n\nOnly observed properties (via [can-event.on], [can-event.addEventListener], etc) will be passed the `resolve` function.  It will be `undefined` if the value is not observed. This is for memory safety.\n\nSpecify `get` like:\n\n```js\npropertyName: {\n  get: function(lastSetValue, resolve){ ... }\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "lastSetValue",
            "description": "The value last set by `instance.propertyName = value`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "name": "value"
                  }
                ]
              },
              {
                "type": "undefined"
              }
            ],
            "name": "resolve",
            "description": "Updates the value of the property. This can be called\nmultiple times if needed. Will be `undefined` if the value is not observed.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property before `resolve` is called.  Or a value for unobserved property reads\nto return.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of the property before `resolve` is called.  Or a value for unobserved property reads\nto return.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "name": "value"
            }
          ]
        },
        {
          "type": "undefined"
        }
      ],
      "name": "resolve",
      "description": "Updates the value of the property. This can be called\nmultiple times if needed. Will be `undefined` if the value is not observed.\n"
    },
    "comment": " "
  },
  "can-define.types.set": {
    "src": {
      "path": "node_modules/can-define/docs/types.set.md"
    },
    "body": "\n\n## Use\n\nA property's `set` function can be used to customize the behavior of when an attribute value is set.  Lets see some common cases:\n\n#### Side effects\n\nThe following makes setting a `page` property update the `offset`:\n\n\n```js\npage: {\n    set: function(newVal){\n        this.offset =  (parseInt(newVal) - 1) * this.limit;\n    }\n}\n```\n\nThe following makes changing `makeId` un-define the `modelId` property:\n\n```\nmakeId: {\n    set: function(newValue){\n        // Check if we are changing.\n        if(newValue !== this.makeId) {\n            this.modelId = undefined;\n        }\n        // Must return value to set as we have a `newValue` argument.\n        return newValue;\n    }\n}\n```\n\n#### Asynchronous Setter\n\nThe following shows an async setter:\n\n```js\nprop: {\n    set: function( newVal, setVal){\n        $.get(\"/something\", {}, setVal );\n    }\n}\n```\n\n\n## Behavior depends on the number of arguments.\n\nWhen a setter returns `undefined`, its behavior changes depending on the number of arguments.\n\nWith 0 arguments, the original set value is set on the attribute.\n\n```js\nMyMap = DefineMap.extend({\n    prop: {set: function(){}}\n})\n\nvar map = new MyMap({prop : \"foo\"});\n\nmap.prop //-> \"foo\"\n```\n\nWith 1 argument, an `undefined` return value will set the property to `undefined`.  \n\n```js\nMyMap = DefineMap.extend({\n    prop: {set: function(newVal){}}\n})\n\nvar map = new MyMap({prop : \"foo\"});\n\nmap.prop //-> undefined\n```\n\nWith 2 arguments, `undefined` leaves the property in place.  It is expected\nthat `resolve` will be called:\n\n```js\nMyMap = DefineMap.extend({\n    prop: {\n        set: function(newVal, resolve){\n            setVal(newVal+\"d\");\n        }\n    }\n});\n\nvar map = new MyMap({prop : \"foo\"});\n\nmap.prop //-> \"food\";\n```\n\n## Side effects\n\nA set function provides a useful hook for performing side effect logic as a certain property is being changed.\n\nFor example, in the example below, Paginator DefineMap includes a `page` property, which derives its value entirely from other properties (limit and offset).  If something tries to set the `page` directly, the set method will set the value of `offset`:\n\n```js\nvar Paginate = DefineMap.extend({\n    limit: 'number',\n    offset: 'number',\n    page: {\n        set: function (newVal) {\n            this.offset = (parseInt(newVal) - 1) * this.limit;\n        },\n        get: function () {\n            return Math.floor(this.offset / this.limit) + 1;\n        }\n    }\n});\n\nvar p = new Paginate({limit: 10, offset: 20});\n```\n\n\n\n## Merging\n\nBy default, if a value returned from a setter is an object the effect will be to replace the property with the new object completely.\n\n```js\nvar Contact = DefineMap.extend({\n    info: {\n        set: function(newVal){\n            return newVal;\n        }\n    }\n})\n\nvar alice = new Contact({\n\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n});\n\nvar info  = alice.info;\n\nalice.info = {name: 'Allison Wonderland', phone: '888-888-8888'};\n\ninfo === alice.info // -> false\n```\n\nIn contrast, you can merge properties with:\n\n```js\nContact = DefineMap.extend({\n    info: {\n        set: function(newVal){\n            if(this.info) {\n                return this.info.set(newVal);\n            } else {\n                return newVal;\n            }\n        }\n    }\n});\n\nvar alice = new Contact({\n\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n});\n\nvar info  = alice.info;\n\nalice.info = {name: 'Allison Wonderland', phone: '888-888-8888'};\n\ninfo === alice.info // -> true\n```\n\n## Batched Changes\n\nBy default, calls to `set` methods are wrapped in a call to [can-event/batch/batch.start canBatch.start] and [can-event/batch/batch.stop canBatch.stop], so if a set method has side effects that set more than one property, all these sets are wrapped in a single batch for better performance.\n\n",
    "description": "\nSpecify what happens when a property value is set.\n",
    "title": "set",
    "name": "can-define.types.set",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "set( [newVal,] [resolve] )",
        "description": "\n\nA set function defines the behavior of what happens when a value is set on an\ninstance. It is typically used to:\n\n - Add or update other properties as side effects\n - Coerce the set value into an appropriate action\n\nThe behavior of the setter depends on the number of arguments specified. This means that a\nsetter like:\n\n```js\nprop: {\n    set: function(){}\n}\n```\n\nbehaves differently than:\n\n```js\nprop: {\n    set: function(newVal){}\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "The [can-define.types.type type function] coerced value the user intends to set on the\ninstance.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "resolve",
            "description": "A callback that can set the value of the property\nasynchronously.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the property value is set to the type converted value.\n - If the setter specifies the `newValue` argument only, the attribute value will be set to `undefined`.\n - If the setter specifies both `newValue` and `resolve`, the value of the property will not be\n   updated until `resolve` is called.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ]
        }
      ],
      "optional": true,
      "name": "resolve",
      "description": "A callback that can set the value of the property\nasynchronously.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the property value is set to the type converted value.\n - If the setter specifies the `newValue` argument only, the attribute value will be set to `undefined`.\n - If the setter specifies both `newValue` and `resolve`, the value of the property will not be\n   updated until `resolve` is called.\n\n"
    },
    "comment": " "
  },
  "can-define.types.value": {
    "src": {
      "path": "node_modules/can-define/docs/value.md"
    },
    "body": "\n\nThere is a third way to provide a default value, which is explained in the [can-define.types.ValueConstructor Value] docs page. `value` lowercased is for providing default values for a property type, while `Value` uppercased is for providing a constructor function, which will be invoked with `new` to create a default value for each instance of this map.\n\n```js\n// A default age of `0`:\nvar Person = DefineMap.extend({\n  age: {\n    value: 0\n  },\n  address: {\n    value: function(){\n      return {city: \"Chicago\", state: \"IL\"};\n    };\n  }\n});\n```\n\n",
    "description": "\nReturns the default value for instances of the defined type.  The default value is defined on demand, when the property\nis read for the first time.\n",
    "title": "value",
    "name": "can-define.types.value",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "value()",
        "description": "\n\nA function can be provided that returns the default value used for this property, like:\n\n```js\nprop: {\n  value: function(){ return []; }\n}\n```\n\n\nIf the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property `value` above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The default value.  This will be passed through setter and type.\n"
        }
      },
      {
        "code": "value",
        "description": "\n\nAny value can be provided as the default value used for this property, like:\n\n```\nprop: {\n  value: 'foo'\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "defaultVal",
            "description": "The default value, which will be passed through setter and type.\n"
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The default value.  This will be passed through setter and type.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "defaultVal",
      "description": "The default value, which will be passed through setter and type.\n"
    },
    "comment": " "
  },
  "can-define.types.propDefinition": {
    "src": {
      "path": "node_modules/can-define/docs/types.propDefinition.md"
    },
    "body": "\n\n\n## Use\n\nA property definition can be defined in several ways.  The `Object` form is the most literal\nand directly represents a `PropDefinition` object.  The other forms\nget converted to a `PropDefinition` as follows:\n\n\n```js\nDefineMap.extend({\n  propertyA: Object      -> PropertyDefinition\n  propertyB: String      -> {type: String}\n  propertyC: Constructor -> {Type: Constructor}\n  propertyD: [PropDefs]  -> {Type: DefineList.extend({\"#\": PropDefs})>}\n  get propertyE(){...}   -> {get: propertyE(){...}}\n  set propertyF(){...}   -> {get: propertyF(){...}}\n  method: Function\n})\n```\n\nWithin a property definition, the available properties and their signatures look like:\n\n```js\nDefineMap.extend({\n  property: {\n    get: function(lastSetValue, resolve){...},\n    set: function(newValue, resolve){...},\n\n    type: function(newValue, prop){...}| Array<PropertyDefinition> | PropertyDefinition,\n    Type: Constructor | Array<PropertyDefinition> | PropertyDefinition,\n\n    value: function(){...},\n    Value: Constructor,\n\n    serialize: Boolean | function(){...}\n  }\n})\n```\n\nFor example:\n\n\n```js\nvar Person = DefineMap.extend(\"Person\",{\n  // a `DefineList` of `Address`\n  addresses: [Address],\n  // A `DefineMap` with a `first` and `last` property\n  name: { type: {first: \"string\", last: \"string\"} },\n  // A `DefineList of a ``DefineMap` with a `make` and `year` property.\n  cars: { Type: [{make: \"string\", year: \"number\"}] }\n});\n\nvar person = new Person({\n  addresses: [{street: \"1134 Pinetree\"}],\n  name: {first: \"Kath\", last: \"Iann\"}\n  cars: [{ make: \"Nissan\", year: 2010 }]\n});\n```\n\n",
    "description": "\nDefines the type, initial value, and get, set, and serialize behavior for an\nobservable property.  These behaviors can be specified with as an `Object`, `String`,\n`Constructor` function, `Array`, a `getter expression`, or `setter expression`.\n",
    "type": "typedef",
    "title": "PropDefinition",
    "types": [
      {
        "type": "Object",
        "description": "Defines multiple behaviors for a single property.\n\n```js\npropertyName: {\n  get: function(){ ... },\n  set: function(){ ... },\n  type: function(){ ... },\n  Type: Constructor,\n  value: function(){ ... },\n  Value: Constructor,\n  serialize: function(){ ... }\n}\n```\n",
        "options": [
          {
            "name": "value",
            "description": "Specifies the initial value of the property or\na function that returns the initial value.\n\n```js\n// A default age of `0`:\nvar Person = DefineMap.extend({\n  age: {\n    value: 0\n  },\n  address: {\n    value: function(){\n      return {city: \"Chicago\", state: \"IL\"};\n    };\n  }\n});\n```\n",
            "types": [
              {
                "type": "can-define.types.value"
              }
            ]
          },
          {
            "name": "Value",
            "description": "Specifies a function that will be called with `new` whose result is\nset as the initial value of the attribute.\n\n```js\n// A default empty DefineList of hobbies:\nvar Person = DefineMap.extend({\n  hobbies: {Value: DefineList}\n});\n\nnew Person().hobbies //-> []\n```\n",
            "types": [
              {
                "type": "can-define.types.ValueConstructor"
              }
            ]
          },
          {
            "name": "type",
            "description": "Specifies the type of the\nproperty.  The type can be specified as either a function\nthat returns the type coerced value or one of the [can-define.types] names.\n\n```js\nvar Person = DefineMap.extend({\n  age: {type: \"number\"},\n  hobbies: {\n    type: function(newValue){\n      if(typeof newValue === \"string\") {\n        return newValue.split(\",\")\n      } else if( Array.isArray(newValue) ) {\n        return newValue;\n      }\n    }\n  }\n});\n```\n",
            "types": [
              {
                "type": "can-define.types.type"
              }
            ]
          },
          {
            "name": "Type",
            "description": "A constructor function that takes\nthe assigned property value as the first argument and called with new. For example, the following will call\n`new Address(newValue)` with whatever non null, undefined, or address type is set as a `Person`'s address property.\n\n```js\nvar Address = DefineMap.extend({\n  street: \"string\",\n  state: \"string\"    \n});\n\nvar Person = DefineMap.extend({\n  address: {Type: Address}    \n});\n```\n",
            "types": [
              {
                "type": "can-define.types.TypeConstructor"
              }
            ]
          },
          {
            "name": "set",
            "description": "A set function that specifies what should happen when a property is set. `set` is called with the result of `type` or `Type`. The following\ndefines a `page` setter that updates the map's offset:\n\n```js\nDefineMap.extend({\n  page: {\n    set: function(newVal){\n      this.offset = (parseInt(newVal) - 1) * this.limit;\n    }\n  }\n});\n```\n",
            "types": [
              {
                "type": "can-define.types.set"
              }
            ]
          },
          {
            "name": "get",
            "description": "A function that specifies how the value is retrieved.  The get function is\nconverted to an [can-compute.async async compute].  It should derive its value from other values on the object. The following\ndefines a `page` getter that reads from a map's offset and limit:\n\n```js\nDefineMap.extend({\n  page: {\n    get: function (newVal) {\n\t  return Math.floor(this.offset / this.limit) + 1;\n\t}\n  }\n});\n```\n\nA `get` definition makes the property __computed__ which means it will not be enumerable by default.\n",
            "types": [
              {
                "type": "can-define.types.get"
              }
            ]
          },
          {
            "name": "serialize",
            "description": "Specifies the behavior of the property when [can-define/map/map::serialize serialize] is called.\n\nBy default, serialize does not include computed values. Properties with a `get` definition\nare computed and therefore are not added to the result.  Non-computed properties values are\nserialized if possible and added to the result.\n\n```js\nvar Todo = DefineMap.extend({\n  date: {\n    type: \"date\",\n    serialize: function(value) {\n      return value.getTime();\n    }\n  }\n});\n",
            "types": [
              {
                "type": "can-define.types.serialize"
              }
            ]
          }
        ]
      },
      {
        "type": "String",
        "description": "Defines a [can-define.types.type] converter as one of the named types in [can-define.types].\n\n```js\npropertyName: \"typeName\"\n```\n"
      },
      {
        "type": "Constructor",
        "description": "Defines a [can-define.types.TypeConstructor Type] setting with a constructor\nfunction.  Constructor functions are identified with [can-util/js/types/types.isConstructor].\n\n```\npropertyName: Constructor\n```\n"
      },
      {
        "type": "Array",
        "description": "Defines an inline [can-define/list/list] Type setting. This is\nused as a shorthand for creating a property that is an [can-define/list/list] of another type.\n\n```\npropertyName: [Constructor | propDefinitions]\n```\n\nFor example:\n\n```js\nusers: [User],\ntodos: [{complete: \"boolean\", name: \"string\"}]\n```\n",
        "options": []
      },
      {
        "type": "GETTER",
        "description": "Defines a property's [can-define.types.get] behavior with the\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get syntax].\n\n```js\nget propertyName(){ ... }\n```\n\nFor example:\n\n```js\nget fullName() {\n    return this.first + \" \" + this.last;\n}\n```\n\nThis is a shorthand for providing an object with a `get` property like:\n\n```\nfullName: {\n    get: function(){\n        return this.first + \" \" + this.last;\n    }\n}\n```\n\nYou must use an object with a [can-define.types.get] property if you want your get to take the `lastSetValue`\nor `resolve` arguments.\n"
      },
      {
        "type": "SETTER",
        "description": "Defines a property's [can-define.types.set] behavior with the\n[set syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set).\n\n```js\nset propertyName(newValue){ ... }\n```\n\nFor example:\n\n```js\nset fullName(newValue) {\n    var parts = newVal.split(\" \");\n    this.first = parts[0];\n    this.last = parts[1];\n}\n```\n\nThis is a shorthand for providing an object with a `set` property like:\n\n```\nfullName: {\n    set: function(newValue){\n        var parts = newVal.split(\" \");\n        this.first = parts[0];\n        this.last = parts[1];\n    }\n}\n```\n\nYou must use an object with a [can-define.types.set] property if you want your set to take the `resolve` argument.\n\n"
      }
    ],
    "name": "can-define.types.propDefinition",
    "parent": "can-define.typedefs",
    "comment": " "
  },
  "can-define/list/list": {
    "name": "can-define/list/list",
    "type": "module",
    "src": {
      "path": "node_modules/can-define/list/docs/define-list.md"
    },
    "body": "\n\n## Use\n\nThe `can-define/list/list` module exports a `DefineList` constructor function.  It can be used\nwith `new` to create observable lists that behave very similar to `Array`s.  For example:\n\n```js\nvar list = new DefineList([\"a\",\"b\", \"c\"]);\nlist[0] //-> \"a\";\n\nlist.push(\"x\");\nlist.pop() //-> \"x\"\n```\n\nIt can also be extended to define custom observable list types with\n[can-define/list/list.extend].  For example, the following defines a `StringList` type\nwhere every item is converted to a string by specifying the [can-define/list/list.prototype.wildcardItems items definition] `(#)`:\n\n```js\nvar StringList = DefineList.extend({\n\t\"#\": \"string\"\n});\n\nvar strings = new StringList([1,new Date(1475370478173),false]);\n\nstrings[0] //-> \"1\"\nstrings[1] //-> \"Sat Oct 01 2016 20:07:58 GMT-0500 (CDT)\"\nstrings[2] //-> \"false\"\n```\n\nNon-numeric properties can also be defined on custom DefineList type.  The following\ndefines a `completed` property that returns the completed todos:\n\n```js\nvar TodoList = DefineList.extend({\n\t\"#\": Todo,\n\tget completed(){\n\t\treturn this.filter({complete: true})\n\t}\n});\n\nvar todos = new TodoList([{complete: true}, {complete:false}]);\ntodos.completed.length //-> 1\n```\n\nFinally, DefineMap instances are observable, so you can use the [canjs/doc/can-event]\nmethods to listen to its [can-define/list/list/AddEvent],\n[can-define/list/list/LengthEvent], [can-define/list/list/RemoveEvent],\nand [can-define/list/list/PropertyNameEvent] events:\n\n```js\nvar people = new DefineList([\"alice\",\"bob\",\"eve\"]);\n\npeople.on(\"add\", function(ev, items, index){\n\tconsole.log(\"add\", items, index);\n}).on(\"remove\", function(ev, items, index){\n\tconsole.log(\"remove\", items, index);\n}).on(\"length\", function(ev, newVal, oldVal){\n\tconsole.log(\"length\", newVal, oldVal);\n})\n\npeople.pop(); // remove [\"eve\"] 2\n              // length 2 3\n\npeople.unshift(\"Xerxes\"); // add [\"Xerxes\"] 1\n                          // length 3 2\n```\n\n",
    "description": "Create observable lists. \n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-core",
    "alias": "can.DefineList",
    "inherits": "can.Construct",
    "signatures": [
      {
        "code": "new can.DefineList([items])",
        "description": "\n\nCreates an instance of a DefineList or an extended DefineList with enumerated properties from `items`.\n\n```js\nvar people = new DefineList([\n  { first: \"Justin\", last: \"Meyer\" },\n  { first: \"Paula\", last: \"Strozak\" }\n])\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "items",
            "description": "An array of items to seed the list with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "An instance of `DefineList` with the values from _items_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "items",
      "description": "An array of items to seed the list with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "An instance of `DefineList` with the values from _items_.\n"
    },
    "comment": " "
  },
  "can-define/list/list.static": {
    "src": {
      "line": 45,
      "codeLine": 46,
      "path": "node_modules/can-define/list/list.js"
    },
    "type": "static",
    "body": "",
    "description": "",
    "name": "can-define/list/list.static",
    "parent": "can-define/list/list",
    "title": "static"
  },
  "can-define/list/list.prototype": {
    "src": {
      "line": 64,
      "codeLine": 65,
      "path": "node_modules/can-define/list/list.js"
    },
    "type": "prototype",
    "body": "",
    "description": "",
    "name": "can-define/list/list.prototype",
    "parent": "can-define/list/list",
    "title": "prototype"
  },
  "can-define/list/list.prototype.get": {
    "type": "function",
    "name": "can-define/list/list.prototype.get",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 122,
      "codeLine": 175,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nGets an item or all items from a DefineList.\n",
    "title": "get",
    "signatures": [
      {
        "code": "list.get()",
        "description": "\n\nReturns the list converted into a plain JS array. Any items that also have a\n`get` method will have their `get` method called and the resulting value will be used as item value.\n\nThis can be used to recursively convert a list instance to an Array of other plain JavaScript objects. Cycles are supported and only create one object.\n\n`get()` can still return other non-plain JS objects like Dates.\nUse [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.get() //-> [\"A\",\"B\"]\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "A plain JavaScript `Array` that contains each item in the list.\n"
        }
      },
      {
        "code": "list.get(index)",
        "description": "\n\nGets the item at `index`. `list.get(index)` should be used instead of\n`list[index]` if the list's items are going to be updated via [can-define/list/list.prototype.set list.set(index, value)]\n(as opposed to [can-define/list/list.prototype.splice] which is the better way).\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.get(1) //-> \"B\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "A numeric position in the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at index.\n"
        }
      },
      {
        "code": "list.get(prop)",
        "description": "\n\nGets the property at `prop` if it might not have already been defined.\n\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(\"count\",1000)\nlist.get(\"count\") //-> 1000\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "A property on the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at `prop`.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value at `prop`.\n\t "
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "prop",
      "description": "A property on the list.\n"
    }
  },
  "can-define/list/list.prototype.set": {
    "type": "function",
    "name": "can-define/list/list.prototype.set",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 183,
      "codeLine": 244,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nSets an item or property or items or properties on a list.\n",
    "title": "set",
    "signatures": [
      {
        "code": "list.set(prop, value)",
        "description": "\n\nSets the property at `prop`. This should be used when the property\nisn't already defined.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(\"count\",1000);\nlist.get(\"count\") //-> 1000;\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "prop",
            "description": "A property name."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to add to the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(newProps)",
        "description": "\n\nUpdates the properties on the list with `newProps`.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set({count: 1000, skip: 2});\nlist.get(\"count\") //-> 1000\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "newProps",
            "description": "An object of properties and values to set on the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(index, value)",
        "description": "\n\nSets the item at `index`.  Typically, [can-define/list/list::splice] should be used instead.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(2,\"C\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "A numeric position in the list."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to add to the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(newItems [,replaceAll])",
        "description": "\n\nReplaces items in the list with `newItems`\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set([\"c\"])        //-> DefineList[\"c\",\"B\"]\nlist.set([\"x\"], true)  //-> DefineList[\"x\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "newItems",
            "description": "Items used to replace existing items in the list."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "replaceAll",
            "description": "If true, will remove items at the end of the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance.\n\t "
    },
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "replaceAll",
      "description": "If true, will remove items at the end of the list."
    }
  },
  "can-define/list/list.prototype.splice": {
    "type": "function",
    "name": "can-define/list/list.prototype.splice",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 298,
      "codeLine": 343,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`splice` lets you remove elements from and insert elements into a DefineList.\n\nThis example demonstrates how to do surgery on a list of numbers:\n\n```\nvar list = new DefineList([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.get(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n## Events\n\n`splice` causes the DefineList it's called on to emit\n_add_ events, _remove_ events, and _length_ events. If there are\nany elements to remove, a _remove_ event, and a\n_length_ event will be fired. If there are any elements to insert, a\nseparate _add_ event, and a separate _length_ event\nwill be fired.\n\n\t \n",
    "description": "Insert and remove elements from a DefineList. ",
    "title": "splice",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newItems]])",
        "description": "\n\nRemoves `howMany` items at `index` and adds `newItems` in their place.\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "Where to start removing or inserting elements.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "The number of elements to remove\nIf _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the DefineList.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newItems",
            "description": "Items to insert into the DefineList\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "The elements removed by `splice`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newItems",
      "description": "Items to insert into the DefineList\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "The elements removed by `splice`.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.serialize": {
    "type": "function",
    "name": "can-define/list/list.prototype.serialize",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 386,
      "codeLine": 410,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nReturns the a serialized version of this list.\n",
    "title": "serialize",
    "signatures": [
      {
        "code": "list.serialize()",
        "description": "\n\nGoes through each item in the list and gets its serialized\nvalue and returns them in a plain Array.\n\nEach items serialized value is the result of calling `.serialize()`\non the item or if the item doesn't have a `serialize` method,\nthe item itself.\n\n```\nvar list = new DefineList([\"first\", {foo: \"bar\"}]);\nvar serializedList = list.serialize();\n\nserializedList //-> [\"first\", {foo: \"bar\"}]\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "An array with each item's serialied value.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "An array with each item's serialied value.\n\t "
    }
  },
  "can-define/list/list.prototype.push": {
    "name": "can-define/list/list.prototype.push",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 423,
      "codeLine": 473,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`push` adds elements onto the end of a DefineList here is an example:\n\n```\nvar list = new DefineList(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.get(); // ['Alice', 'Bob', 'Eve']\n```\n\nIf you have an array you want to concatenate to the end\nof the DefineList, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new DefineList(['Alice']);\n\nlist.push.apply(list, names);\nlist.get(); // ['Alice', 'Bob', 'Eve']\n```\n\n## Events\n\n`push` causes _add_, and _length_ events to be fired.\n\n## See also\n\n`push` has a counterpart in [can-define/list/list::pop pop], or you may be\nlooking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\n\t \n",
    "description": "Add elements to the end of a list. ",
    "title": "push",
    "signatures": [
      {
        "code": "list.push(...elements)",
        "description": "\n\n`push` adds elements onto the end of a DefineList.\n\n```\nvar names = new DefineList(['Alice']);\nnames.push('Bob', 'Eve');\nnames //-> DefineList['Alice','Bob', 'Eve']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the DefineList\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the DefineList\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the DefineList\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the DefineList\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.unshift": {
    "name": "can-define/list/list.prototype.unshift",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 474,
      "codeLine": 518,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n\n\nIf you have an array you want to concatenate to the beginning\nof the DefineList, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new DefineList(['Alice']);\n\nlist.unshift.apply(list, names);\nlist.get(); // ['Bob', 'Eve', 'Alice']\n```\n\n## Events\n\n`unshift` causes _add_ and _length_ events to be fired.\n\n## See also\n\n`unshift` has a counterpart in [can-define/list/list::shift shift], or you may be\nlooking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\n\t \n",
    "description": "Add items to the beginning of a DefineList. ",
    "title": "unshift",
    "signatures": [
      {
        "code": "list.unshift(...items)",
        "description": "\n\n`unshift` adds items onto the beginning of a DefineList.\n\n```\nvar list = new DefineList(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist; // DefineList['Bob', 'Eve', 'Alice']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "items",
            "description": "The items to add to the DefineList.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The new length of the DefineList.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "items",
      "description": "The items to add to the DefineList.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The new length of the DefineList.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.pop": {
    "name": "can-define/list/list.prototype.pop",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 552,
      "codeLine": 591,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`pop` is the opposite action from [can-define/list/list::push push]:\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined\n```\n\n## Events\n\n`pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\nwhen it is called.\n\n## See also\n\n`pop` has its counterpart in [can-define/list/list::push push], or you may be\nlooking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\n\t \n",
    "description": "Remove an element from the end of a DefineList. ",
    "title": "pop",
    "signatures": [
      {
        "code": "list.pop()",
        "description": "\n\n`pop` removes an element from the end of a DefineList.\n\n```js\nvar names = new DefineList(['Alice', 'Bob', 'Eve']);\nnames.pop() //-> 'Eve'\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The element just popped off the DefineList, or `undefined` if the DefineList was empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The element just popped off the DefineList, or `undefined` if the DefineList was empty\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.shift": {
    "name": "can-define/list/list.prototype.shift",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 592,
      "codeLine": 624,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`shift` is the opposite action from `[can-define/list/list::unshift unshift]`:\n\n## Events\n\n`pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\nwhen it is called.\n\n## See also\n\n`shift` has a counterpart in [can-define/list/list::unshift unshift], or you may be\nlooking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\n\t \n",
    "description": "Remove an item from the front of a list. ",
    "title": "shift",
    "signatures": [
      {
        "code": "list.shift()",
        "description": "\n\n`shift` removes an element from the beginning of a DefineList.\n\n```\nvar list = new DefineList(['Alice','Adam']);\nlist.shift(); //-> 'Alice'\nlist.shift(); //-> 'Adam'\nlist.shift(); //-> undefined\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The element just shifted off the DefineList, or `undefined` if the DefineList is empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The element just shifted off the DefineList, or `undefined` if the DefineList is empty\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.indexOf": {
    "type": "function",
    "name": "can-define/list/list.prototype.indexOf",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 652,
      "codeLine": 672,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Look for an item in a DefineList. ",
    "title": "indexOf",
    "signatures": [
      {
        "code": "list.indexOf(item)",
        "description": "\n\n`indexOf` finds the position of a given item in the DefineList.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "The item to find.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "The item to find.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.join": {
    "type": "function",
    "name": "can-define/list/list.prototype.join",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 681,
      "codeLine": 699,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "",
    "description": "Join a DefineList's elements into a string. ",
    "title": "join",
    "signatures": [
      {
        "code": "list.join(separator)",
        "description": "\n\n`join` turns a DefineList into a string by inserting _separator_ between the string representations\nof all the elements of the DefineList.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "separator",
            "description": "The string to seperate elements.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The joined string.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "separator",
      "description": "The string to seperate elements.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The joined string.\n\n "
    }
  },
  "can-define/list/list.prototype.reverse": {
    "type": "function",
    "name": "can-define/list/list.prototype.reverse",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 704,
      "codeLine": 724,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Reverse the order of a DefineList. ",
    "title": "reverse",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\nReverses the elements of the DefineList in place.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList; //-> DefineList['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The DefineList, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The DefineList, for chaining.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.slice": {
    "type": "function",
    "name": "can-define/list/list.prototype.slice",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 730,
      "codeLine": 764,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`slice` is the simplest way to copy a DefineList:\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy           //-> DefineList['Alice', 'Bob', 'Eve']\nlist === copy; //-> false\n```\n \n",
    "description": "Make a copy of a part of a DefineList. ",
    "title": "slice",
    "signatures": [
      {
        "code": "list.slice([start[, end]])",
        "description": "\n\n`slice` creates a copy of a portion of the DefineList.\n\n```js\nvar list = new DefineList(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList //-> DefineList['Bob', 'Charlie', 'Daniel']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "start",
            "defaultValue": "0",
            "description": "The index to start copying from. Defaults to `0`.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "end",
            "description": "The first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A new `DefineList` with the extracted elements.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "end",
      "description": "The first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A new `DefineList` with the extracted elements.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.concat": {
    "type": "function",
    "name": "can-define/list/list.prototype.concat",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 771,
      "codeLine": 801,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`concat` makes a new DefineList with the elements of the DefineList followed by the elements of the parameters.\n\n```\nvar list = new DefineList();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new DefineList(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.get(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n```\n \n",
    "description": "Merge many collections together into a DefineList. ",
    "title": "concat",
    "signatures": [
      {
        "code": "list.concat(...args)",
        "description": "\n\nReturns a `DefineList` with the `list`'s items and the additional `args`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can-define/list/list"
              },
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a DefineList, each of its elements will be added to\nthe end of the concatenated DefineList. Otherwise, the parameter itself will be added.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A DefineList of the same type.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can-define/list/list"
        },
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a DefineList, each of its elements will be added to\nthe end of the concatenated DefineList. Otherwise, the parameter itself will be added.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A DefineList of the same type.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.forEach": {
    "type": "function",
    "name": "can-define/list/list.prototype.forEach",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 828,
      "codeLine": 864,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`forEach` calls a callback for each element in the DefineList.\n\n```\nvar list = new DefineList([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.get(index, element * element);\n});\nlist.get(); // [1, 4, 9]\n```\n \n",
    "description": "Call a function for each element of a DefineList. ",
    "title": "forEach",
    "signatures": [
      {
        "code": "list.forEach(callback[, thisArg])",
        "description": "\n\nLoops through the values of the list, calling `callback` for each one until the list ends\nor `false` is returned.\n\n```\nlist.forEach(function(item, index, list){ ... })\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe three parameters that callback gets passed are:\n   - item - the element at index.\n   - index - the current element of the list.\n   - list - the DefineList the elements are coming from.\n\nIf the callback returns `false` the looping stops.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.replace": {
    "type": "function",
    "name": "can-define/list/list.prototype.replace",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 875,
      "codeLine": 901,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`replace` is essentially a shortcut for [can-define/list/list.prototype.splice].\n\n## Events\n\n`replace` causes _remove_, _add_, and _length_ events.\n \n",
    "description": "Replace all the elements of a DefineList. ",
    "title": "replace",
    "signatures": [
      {
        "code": "list.replace(collection)",
        "description": "\n\nReplaces every item in the list with `collection`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"eve\"]);\nnames.replace([\"Justin\",\"Xena\"]);\nnames //-> DefineList[\"Justin\",\"Xena\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can-define/list/list"
              }
            ],
            "name": "collection",
            "description": "The collection of items that will be in `list`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "Returns the `list`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can-define/list/list"
        }
      ],
      "name": "collection",
      "description": "The collection of items that will be in `list`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "Returns the `list`.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.filter": {
    "type": "function",
    "name": "can-define/list/list.prototype.filter",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 905,
      "codeLine": 951,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nFilter a list to a new list of the matched items.\n",
    "title": "filter",
    "signatures": [
      {
        "code": "list.filter( callback [,thisArg] )",
        "description": "\n\nFilters `list` based on the return value of `callback`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\nvar aNames = list.filter(function(name){\n  return name[0] === \"a\"\n});\naNames //-> DefineList[\"alice\",\"adam\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can-define/list/list"
                      }
                    ],
                    "name": "list"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A\nfunction to call with each element of the DefineList. The three parameters that callback gets passed are:\n - item - the element at index.\n - index - the current element of the list.\n - list - the DefineList the elements are coming from.\n\nIf `callback` returns a truthy result, `item` will be added to the result.  Otherwise, the `item` will be\nexcluded.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "thisArg",
            "description": "What `this` should be in the `callback`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A `DefineList` of the same type.\n"
        }
      },
      {
        "code": "list.filter( props )",
        "description": "\n\nFilters items in `list` based on the property values in `props`.\n\n```\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar complete = todos.filter({complete: true});\ncomplete //-> DefineList[{name: \"lawn\", complete: true}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to be in the returned list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A `DefineList` of the same type.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A `DefineList` of the same type.\n "
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to be in the returned list."
    }
  },
  "can-define/list/list.prototype.map": {
    "type": "function",
    "name": "can-define/list/list.prototype.map",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 966,
      "codeLine": 999,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Map the values in this list to another list. \n",
    "title": "map",
    "signatures": [
      {
        "code": "list.map(callback[, thisArg])",
        "description": "\n\nLoops through the values of the list, calling `callback` for each one until the list\nends.  The return values of `callback` are used to populate the returned list.\n\n```js\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar names = todos.map(function(todo){\n  return todo.name;\n});\nnames //-> DefineList[\"dishes\",\"lawn\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe three parameters that callback gets passed are:\n   - item - the element at index.\n   - index - the current element of the list.\n   - list - the DefineList the elements are coming from.\n\nThe return value of `callback`, including `undefined` values are used to populated the resulting list.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.sort": {
    "type": "function",
    "name": "can-define/list/list.prototype.sort",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1009,
      "codeLine": 1053,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "```\n \n",
    "description": "Sort the properties of a list. \n",
    "title": "sort",
    "signatures": [
      {
        "code": "list.sort([compareFunction])",
        "description": "\n\nSorts the elements of a list in place and returns the list. The API is the\nsame as the native JavaScript `Array.prototype.sort` API.\n\n```js\nvar accounts = new Account.List([\n  { name: \"Savings\", amount: 20.00 },\n  { name: \"Checking\", amount: 103.24 },\n  { name: \"Kids Savings\", amount: 48155.13 }\n]);\naccounts.sort(function(a, b){\n  if (a.name < b.name) {\n    return -1;\n  } else if (a.name > b.name){\n    return 1;\n  } else {\n    return 0;\n  }\n});\naccounts[0].name === \"Checking\"\naccounts[1].name === \"Kids Savings\"\naccounts[2].name === \"Savings\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "a"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "b"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "compareFunction",
            "description": "Specifies a function that defines the sort order.\n\nIf `compareFunction` is supplied, the list elements are sorted according to the return\nvalue of the compare function. If `a` and `b` are two elements being compared, then:\n\n - If `compareFunction(a, b)` returns a value less than 0, `a` will be sorted to\n a lower index than `b`, so `a` will now come first.\n - If `compareFunction(a, b)` returns 0, the order of the two values will not be changed.\n - If `compareFunction(a, b)` returns a value greater than 0, `a` will be sorted to\n a higher index than `b`, so `b` will now come first.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "a"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "b"
                }
              ]
            }
          ]
        }
      ],
      "name": "compareFunction",
      "description": "Specifies a function that defines the sort order.\n\nIf `compareFunction` is supplied, the list elements are sorted according to the return\nvalue of the compare function. If `a` and `b` are two elements being compared, then:\n\n - If `compareFunction(a, b)` returns a value less than 0, `a` will be sorted to\n a lower index than `b`, so `a` will now come first.\n - If `compareFunction(a, b)` returns 0, the order of the two values will not be changed.\n - If `compareFunction(a, b)` returns a value greater than 0, `a` will be sorted to\n a higher index than `b`, so `b` will now come first.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance."
    },
    "comment": " "
  },
  "can-define/map/map.prototype.get": {
    "type": "function",
    "name": "can-define/map/map.prototype.get",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 111,
      "codeLine": 149,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Get a value or all values from a DefineMap. \n",
    "title": "get",
    "signatures": [
      {
        "code": "map.get()",
        "description": "\n\nReturns a plain JavaScript object that contains the properties and values of the map instance.  Any property values\nthat also have a `get` method will have their `get` method called and the resulting value will be used as\nthe property value.  This can be used to recursively convert a map instance to an object of other plain\nJavaScript objects.  Cycles are supported and only create one object.\n\n`.get()` can still return other non plain JS objects like Date.\nUse [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\n\n```js\nvar map = new DefineMap({foo: new DefineMap({bar: \"zed\"})});\nmap.get() //-> {foo: {bar: \"zed\"}};\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A plain JavaScript `Object` that contains all the properties and values of the map instance.\n"
        }
      },
      {
        "code": "map.get(propName)",
        "description": "\n\nGet a single property on a DefineMap instance.\n\n`.get(propName)` only should be used when reading properties that might not have been defined yet, but\nwill be later via [can-define/map/map.prototype.set].\n\n```js\nvar map = new DefineMap();\nmap.get(\"name\") //-> undefined;\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "The property name of a property that may not have been defined yet."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of that property.\n  "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of that property.\n  "
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "propName",
      "description": "The property name of a property that may not have been defined yet."
    }
  },
  "can-define/map/map.prototype.set": {
    "type": "function",
    "name": "can-define/map/map.prototype.set",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 162,
      "codeLine": 190,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Sets multiple properties on a map instance or a property that wasn't predefined. \n",
    "title": "set",
    "signatures": [
      {
        "code": "map.set(props [,removeProps])",
        "description": "\n\nAssigns each value in `props` to a property on this map instance named after the\ncorresponding key in `props`, effectively merging `props` into the Map. If `removeProps` is true, properties not in\n`props` will be set to `undefined`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "removeProps",
            "defaultValue": "false",
            "description": "Whether to set keys not present in `props` to `undefined`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\n"
        }
      },
      {
        "code": "map.set(propName, value)",
        "description": "\n\nAssigns _value_ to a property on this map instance called _propName_.  This will define\nthe property if it hasn't already been predefined.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "The property to set."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign to `propName`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "This map instance, for chaining.\n  "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "This map instance, for chaining.\n  "
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value to assign to `propName`."
    }
  },
  "can-define/map/map.prototype.serialize": {
    "type": "function",
    "name": "can-define/map/map.prototype.serialize",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 200,
      "codeLine": 232,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Get a serialized representation of the map instance and its children. \n",
    "title": "serialize",
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n\nGet the serialized Object form of the map.  Serialized\ndata is typically used to send back to a server.  Use [can-define.types.serialize]\nto customize a property's serialized value or if the property should be added to\nthe result or not.\n\n`undefined` serialized values are not added to the result.\n\n```js\nvar MyMap = DefineMap.extend({\n  date: {\n    type: \"date\",\n    serialize: function(date){\n      return date.getTime()\n    }\n  }\n});\n\nvar myMap = new MyMap({date: new Date(), count: 5});\nmyMap.serialize() //-> {date: 1469566698504, count: 5}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A JavaScript Object that can be serialized with `JSON.stringify` or other methods.\n\n  "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A JavaScript Object that can be serialized with `JSON.stringify` or other methods.\n\n  "
    }
  },
  "exports": {
    "name": "exports",
    "type": "property",
    "parent": "node_modules/can-set/src/clause.js",
    "src": {
      "line": 5,
      "codeLine": 12,
      "path": "node_modules/can-set/src/clause.js"
    },
    "body": "\nnew clause.Where()\n\nThis is so we can tell what type of clause some properties are for.\n\n",
    "description": "Exports a clause constructor functions like:\n"
  },
  "subsetComparesType": {
    "type": "function",
    "name": "subsetComparesType",
    "params": [
      {
        "name": "a",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "b",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "aParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "bParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "prop",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "compares",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-set/src/compare.js",
    "src": {
      "line": 171,
      "codeLine": 177,
      "path": "node_modules/can-set/src/compare.js"
    },
    "body": " \n",
    "description": "Checks if A is a subset of B.  If A is a subset of B if:\n- A \\ B = undefined\n- A ∩ B = defined\n- B ∩ A = defined\n"
  },
  "properSubsetComparesType": {
    "type": "function",
    "name": "properSubsetComparesType",
    "params": [
      {
        "name": "a",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "b",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "aParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "bParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "prop",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "compares",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-set/src/compare.js",
    "src": {
      "line": 238,
      "codeLine": 241,
      "path": "node_modules/can-set/src/compare.js"
    },
    "body": " \n",
    "description": "Checks if A is a subset of B.  If A is a subset of B, A \\ B will be undefined. But B \\ A will be defined.\n"
  },
  "can-set.props.enum": {
    "type": "function",
    "name": "can-set.props.enum",
    "parent": "can-set.props",
    "src": {
      "line": 136,
      "codeLine": 148,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "\n",
    "title": "enum",
    "signatures": [
      {
        "code": "set.props.enum(property, propertyValues)",
        "description": "\n\nMakes a prop for a set of values.\n\n```\nvar compare = set.props.enum(\"type\", [\"new\",\"accepted\",\"pending\",\"resolved\"])\n```\n ",
        "params": []
      }
    ]
  },
  "can-set.props.boolean": {
    "type": "function",
    "name": "can-set.props.boolean",
    "parent": "can-set.props",
    "src": {
      "line": 256,
      "codeLine": 278,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports boolean properties. \n",
    "title": "boolean",
    "signatures": [
      {
        "code": "set.props.boolean(property)",
        "description": "\n\nMakes a compare object with a `property` function that has the following logic:\n\n```js\nA(true) ∪ B(false) = undefined\n\nA(undefined) \\ B(true) = false\nA(undefined) \\ B(false) = true\n```\n\nIt understands that `true` and `false` are complementary sets that combined to `undefined`. Another way to think of this is that if you load `{complete: false}` and `{complete: true}` you've loaded `{}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The name of the boolean property."
          },
          {
            "types": [
              {
                "type": "can-set.compares"
              }
            ],
            "name": "A",
            "description": "`Compares` object that can be an argument to [can-set.Algebra]\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "name": "A",
      "description": "`Compares` object that can be an argument to [can-set.Algebra]\n "
    }
  },
  "can-set.props.sort": {
    "type": "function",
    "name": "can-set.props.sort",
    "parent": "can-set.props",
    "src": {
      "line": 303,
      "codeLine": 333,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Defines the sortable property and behavior. \n",
    "title": "sort",
    "signatures": [
      {
        "code": "set.props.sort(prop, [sortFunc])",
        "description": "\n\nDefines the sortable property and behavior.\n\n```js\nvar algebra = new set.Algebra(set.props.sort(\"sortBy\"));\nalgebra.index(\n  {sortBy: \"name desc\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 1\n\nalgebra.index(\n  {sortBy: \"name\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "The sortable property."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "sortPropValue"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "item1"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "item2"
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "sortFunc",
            "description": "The\nsortable behavior. The default behavior assumes the sort property value\nlooks like `PROPERTY DIRECTION` (ex: `name desc`)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "sortPropValue"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "item1"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "item2"
                }
              ]
            }
          ]
        }
      ],
      "optional": true,
      "name": "sortFunc",
      "description": "The\nsortable behavior. The default behavior assumes the sort property value\nlooks like `PROPERTY DIRECTION` (ex: `name desc`)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
    }
  },
  "can-set.props.id": {
    "type": "function",
    "name": "can-set.props.id",
    "parent": "can-set.props",
    "src": {
      "line": 341,
      "codeLine": 370,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Defines the identify property. \n",
    "title": "id",
    "signatures": [
      {
        "code": "set.props.id(prop)",
        "description": "\n\nDefines the property name on items that uniquely\nidentifies them. This is the default sorted property if no\n[can-set.props.sort] is provided.\n\n```js\nvar algebra = new set.Algebra(set.props.id(\"_id\"));\nalgebra.index(\n  {sortBy: \"name desc\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 1\n\nalgebra.index(\n  {sortBy: \"name\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "The property name that defines the unique property id."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "prop",
      "description": "The property name that defines the unique property id."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
    }
  },
  "can-set.props.offsetLimit": {
    "type": "function",
    "name": "can-set.props.offsetLimit",
    "parent": "can-set.props",
    "src": {
      "line": 407,
      "codeLine": 427,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports sets that include a limit and offset. \n",
    "title": "offsetLimit",
    "signatures": [
      {
        "code": "set.props.offsetLimit( [offsetProperty][, limitProperty] )",
        "description": "\n\nMakes a prop for two ranged properties that specify a range of items\nthat includes both the offsetProperty and limitProperty.  For example, set like:\n`{offset: 20, limit: 10}` loads 10 items starting at index 20.\n\n```\nnew set.Algebra( set.props.offsetLimit(\"offset\",\"limit\") );\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "offsetProperty",
            "description": "The offset property name on sets.  Defaults to `\"offset\"` if none is provided."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "limitProperty",
            "description": "The offset limit name on sets. Defaults to `\"limit\"` if none is provided."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a comparator used to build a set algebra.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "limitProperty",
      "description": "The offset limit name on sets. Defaults to `\"limit\"` if none is provided."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a comparator used to build a set algebra.\n"
    }
  },
  "can-set.props.rangeInclusive": {
    "type": "function",
    "name": "can-set.props.rangeInclusive",
    "parent": "can-set.props",
    "src": {
      "line": 439,
      "codeLine": 459,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports ranged properties. \n",
    "title": "rangeInclusive",
    "signatures": [
      {
        "code": "set.props.rangeInclusive(startIndexProperty, endIndexProperty)",
        "description": "\n\nMakes a prop for two ranged properties that specify a range of items\nthat includes both the startIndex and endIndex.  For example, a range of\n[0,20] loads 21 items.\n\n```\nset.props.rangeInclusive(\"start\",\"end\")\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "startIndexProperty",
            "description": "The starting property name"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "endIndexProperty",
            "description": "The ending property name"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a prop\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "endIndexProperty",
      "description": "The ending property name"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a prop\n"
    }
  },
  "can-set.Translate": {
    "type": "function",
    "name": "can-set.Translate",
    "parent": "can-set.properties",
    "src": {
      "line": 9,
      "codeLine": 33,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "",
    "title": "Translate",
    "signatures": [
      {
        "code": "new set.Translate(clauseType, propertyName)",
        "description": "\n\nLocalizes a clause's properties within another nested property.\n\n```js\nvar algebra = new set.Algebra(\n  new set.Translate(\"where\",\"$where\")\n);\nalgebra.has(\n  {$where: {complete: true}},\n  {id: 5, complete: true}\n) //-> true\n```\n\nThis is useful when filters (which are `where` clauses) are\nwithin a nested object.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "clause",
            "description": "A clause type.  One of `'where'`, `'order'`, `'paginate'`, `'id'`."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "propertyName",
            "description": "The property name which contains the clauses's properties."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "A set compares object that can do the translation.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "propertyName",
      "description": "The property name which contains the clauses's properties."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "A set compares object that can do the translation.\n"
    }
  },
  "Algebra": {
    "type": "function",
    "name": "Algebra",
    "params": [],
    "parent": "node_modules/can-set/src/set-core.js",
    "src": {
      "line": 49,
      "codeLine": 56,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "\nnew set.Algebra(Where(),Paginate(),Sort())\n\n\n",
    "description": "An `Algebra` internally keeps different properties organized by clause type.\nIf an object comes in that isn't a clause type, it's assuemd to be a where.\n"
  },
  "can-set.Algebra.prototype.equal": {
    "type": "function",
    "name": "can-set.Algebra.prototype.equal",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 249,
      "codeLine": 265,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "equal",
    "signatures": [
      {
        "code": "algebra.equal(a, b)",
        "description": "\n\n  Returns true if the two sets the exact same.\n\n  ```js\n  algebra.equal({type: \"critical\"}, {type: \"critical\"}) //-> true\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the two sets are equal.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the two sets are equal.\n "
    }
  },
  "can-set.Algebra.prototype.subset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.subset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 268,
      "codeLine": 285,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "subset",
    "signatures": [
      {
        "code": "algebra.subset(a, b)",
        "description": "\n\nReturns true if _A_ is a subset of _B_ or _A_ is equal to _B_ (_A_ ⊆ _B_).\n\n```js\nalgebra.subset({type: \"critical\"}, {}) //-> true\nalgebra.subset({}, {}) //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `a` is a subset of `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `a` is a subset of `b`.\n "
    }
  },
  "can-set.Algebra.prototype.properSubset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.properSubset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 308,
      "codeLine": 325,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "properSubset",
    "signatures": [
      {
        "code": "algebra.properSubset(a, b)",
        "description": "\n\nReturns true if _A_ is a strict subset of _B_ (_A_ ⊂ _B_).\n\n```js\nalgebra.properSubset({type: \"critical\"}, {}) //-> true\nalgebra.properSubset({}, {}) //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `a` is a subset of `b` and not equal to `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `a` is a subset of `b` and not equal to `b`.\n "
    }
  },
  "can-set.Algebra.prototype.difference": {
    "type": "function",
    "name": "can-set.Algebra.prototype.difference",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 328,
      "codeLine": 360,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "difference",
    "signatures": [
      {
        "code": "algebra.difference(a, b)",
        "description": "\n\nReturns a set that represents the difference of sets _A_ and _B_ (_A_ \\ _B_), or\nreturns if a difference exists.\n\n```js\nalgebra1 = new set.Algebra(set.props.boolean(\"completed\"));\nalgebra2 = new set.Algebra();\n\n// A has all of B\nalgebra1.difference( {} , {completed: true} ) //-> {completed: false}\n\n// A has all of B, but we can't figure out how to create a set object\nalgebra2.difference( {} , {completed: true} ) //-> true\n\n// A is totally inside B\nalgebra2.difference( {completed: true}, {} )  //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set/Set"
            },
            {
              "type": "Boolean"
            }
          ],
          "description": "If an object is returned, it is difference of sets _A_ and _B_ (_A_ \\ _B_).\n\nIf `true` is returned, that means that _B_ is a subset of _A_, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is no difference or the sets are not comparable.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set/Set"
        },
        {
          "type": "Boolean"
        }
      ],
      "description": "If an object is returned, it is difference of sets _A_ and _B_ (_A_ \\ _B_).\n\nIf `true` is returned, that means that _B_ is a subset of _A_, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is no difference or the sets are not comparable.\n "
    }
  },
  "can-set.Algebra.prototype.union": {
    "type": "function",
    "name": "can-set.Algebra.prototype.union",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 392,
      "codeLine": 413,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "union",
    "signatures": [
      {
        "code": "algebra.union(a, b)",
        "description": "\n\nReturns a set that represents the union of _A_ and _B_ (_A_ ∪ _B_).\n\n```js\nalgebra.union(\n  {start: 0, end: 99},\n  {start: 100, end: 199},\n) //-> {start: 0, end: 199}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set/Set"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If an object is returned, it is the union of _A_ and _B_ (_A_ ∪ _B_).\n\nIf `undefined` is returned, it means a union can't be created.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set/Set"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If an object is returned, it is the union of _A_ and _B_ (_A_ ∪ _B_).\n\nIf `undefined` is returned, it means a union can't be created.\n "
    }
  },
  "can-set.Algebra.prototype.intersection": {
    "type": "function",
    "name": "can-set.Algebra.prototype.intersection",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 446,
      "codeLine": 467,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "intersection",
    "signatures": [
      {
        "code": "algebra.count(set)",
        "description": "\n\nReturns the number of items that might be loaded by the `set`. This makes use of set.Algebra's\nBy default, this returns Infinity.\n\n```js\nvar algebra =  new set.Algebra({\n  set.props.rangeInclusive(\"start\", \"end\")\n});\nalgebra.count({start: 10, end: 19}) //-> 10\nalgebra.count({}) //-> Infinity\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "[description]"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of items in the set if known, `Infinity`\nif unknown.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "[description]"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of items in the set if known, `Infinity`\nif unknown.\n "
    }
  },
  "can-set.Algebra.prototype.has": {
    "type": "function",
    "name": "can-set.Algebra.prototype.has",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 470,
      "codeLine": 493,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "has",
    "signatures": [
      {
        "code": "algebra.has(set, props)",
        "description": "\n\nUsed to tell if the `set` contains the instance object `props`.\n\n```\nvar algebra = new set.Algebra(\n  new set.Translate(\"where\",\"$where\")\n);\nalgebra.has(\n  {\"$where\": {playerId: 5}},\n  {id: 5, type: \"3pt\", playerId: 5, gameId: 7}\n) //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An instance's raw data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Returns `true` if `props` belongs in `set` and\n`false` it not.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An instance's raw data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Returns `true` if `props` belongs in `set` and\n`false` it not.\n "
    }
  },
  "can-set.Algebra.prototype.index": {
    "type": "function",
    "name": "can-set.Algebra.prototype.index",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 520,
      "codeLine": 549,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "index",
    "signatures": [
      {
        "code": "algebra.index(set, items, item)",
        "description": "\n\nReturns where `item` should be inserted into `items` which is represented by `set`.\n\n```js\nalgebra = new set.Algebra(\n  set.props.sort(\"orderBy\")\n);\nalgebra.index(\n  {orderBy: \"age\"},\n  [{id: 1, age: 3},{id: 2, age: 5},{id: 3, age: 8},{id: 4, age: 10}],\n  {id: 6, age: 3}\n)  //-> 2\n```\n\nThe default sort property is what is specified by\n[can-set.props.id]. This means if that if the sort property\nis not specified, it will assume the set is sorted by the specified\nid property.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The `set` that describes `items`."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "items",
            "description": "An array of data objects."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "item",
            "description": "The data object to be inserted."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The position to insert `item`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "item",
      "description": "The data object to be inserted."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The position to insert `item`.\n "
    }
  },
  "can-set.Algebra.prototype.getSubset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.getSubset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 573,
      "codeLine": 597,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "getSubset",
    "signatures": [
      {
        "code": "algebra.getSubset(a, b, bData)",
        "description": "\n\nGets `a` set's items given a super set `b` and its items.\n\n```js\nalgebra.getSubset(\n  {type: \"dog\"},\n  {},\n  [{id: 1, type:\"cat\"},\n   {id: 2, type: \"dog\"},\n   {id: 3, type: \"dog\"},\n   {id: 4, type: \"zebra\"}]\n) //-> [{id: 2, type: \"dog\"},{id: 3, type: \"dog\"}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "The set whose data will be returned."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A superset of set `a`."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "bData",
            "description": "The data in set `b`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The data in set `a`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "bData",
      "description": "The data in set `b`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "The data in set `a`.\n "
    }
  },
  "can-set.Algebra.prototype.getUnion": {
    "type": "function",
    "name": "can-set.Algebra.prototype.getUnion",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 613,
      "codeLine": 639,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "getUnion",
    "signatures": [
      {
        "code": "algebra.getUnion(a, b, aItems, bItems)",
        "description": "\n\nUnifies items from set A and setB into a single array of items.\n\n```js\nalgebra = new set.Algebra(\n  set.props.rangeInclusive(\"start\",\"end\")\n);\nalgebra.getUnion(\n  {start: 1,end: 2},\n  {start: 2,end: 4},\n  [{id: 1},{id: 2}],\n  [{id: 2},{id: 3},{id: 4}]);\n  //-> [{id: 1},{id: 2},{id: 3},{id: 4}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "aItems",
            "description": "Set `a`'s items."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "bItems",
            "description": "Set `b`'s items."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns items in both set `a` and set `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "bItems",
      "description": "Set `b`'s items."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns items in both set `a` and set `b`.\n "
    }
  },
  "can-set/Set": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.Set.md"
    },
    "body": "\n",
    "description": "\nAn object that represents a set of data.\n",
    "type": "typedef",
    "title": "Set",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nA `Set` is a plain JavaScript object used to represent a\n[https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation set] of data usually returned by the server.  For example,\na list of all completed todos might be represented by:\n\n```\n{complete: true}\n```\n\nThis set might be passed to [can-connect/can/map/map.getList] like:\n\n```\nTodo.getList({complete: true})\n```\n\nA [can-set.Algebra] is used to detail the behavior of these sets like:\n\n```\nvar todoAlgebra = new set.Algebra(\n  set.props.boolean(\"complete\")    \n);\n```\n\nUsing an algebra, all sorts of special behaviors can be performed:\n\n```\ntodoAlgebra.union({complete: true}, {complete: false}) //-> {}\n```\n"
      }
    ],
    "name": "can-set/Set",
    "parent": "can-set.types"
  },
  "can-set.Algebra.prototype": {
    "name": "can-set.Algebra.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-set.Algebra",
    "description": "",
    "order": 0
  },
  "can-set.Algebra": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.algebra.md"
    },
    "body": "",
    "description": "Creates an object that can perform binary operations on sets with an awareness of how certain properties represent the set.\n\n",
    "title": "Algebra",
    "name": "can-set.Algebra",
    "type": "function",
    "parent": "can-set.properties",
    "signatures": [
      {
        "code": "new set.Algebra(compares...)",
        "description": "\n\nCreates an object that can perform binary operations on sets with\nan awareness of how certain properties represent the set.\n\n```js\nvar set = require(\"can-set\");\nvar algebra = new set.Algebra(\n  set.props.boolean(\"completed\"),\n  set.props.id(\"_id\")\n);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.compares"
              }
            ],
            "name": "compares",
            "description": "Each argument is a compares. These\nare returned by the functions on [can-set.props] or can be created\nmanually. \n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.Algebra"
            }
          ],
          "description": "Returns an instance of an algebra.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "name": "compares",
      "description": "Each argument is a compares. These\nare returned by the functions on [can-set.props] or can be created\nmanually. \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.Algebra"
        }
      ],
      "description": "Returns an instance of an algebra.\n"
    }
  },
  "can-set.types": {
    "name": "can-set.types",
    "title": "types",
    "type": "group",
    "parent": "can-set",
    "description": "",
    "order": 0
  },
  "can-set.properties": {
    "name": "can-set.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-set",
    "description": "",
    "order": 0
  },
  "can-set": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.md"
    },
    "body": "\n## Use\n\nA [can-set/Set] is a plain JavaScript object used to represent a\n[https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation set] of data usually returned by the server.  For example,\na list of all completed todos might be represented by:\n\n```\n{complete: true}\n```\n\nThis set might be passed to [can-connect/can/map/map.getList] like:\n\n```\nTodo.getList({complete: true})\n```\n\nA [can-set.Algebra] is used to detail the behavior of these sets,\noften using already provided [can-set.props] comparators:\n\n```\nvar todoAlgebra = new set.Algebra(\n  set.props.boolean(\"complete\"),\n  set.props.id(\"_id\")\n);\n```\n\nUsing an algebra, all sorts of special behaviors can be performed. For\nexample, if we already loaded the incomplete todos (`{complete: false}`) and\nwanted to load all todos (`{}`), we could use a set [can-set.Algebra.prototype.difference] to figure out how to load\nonly the data that hasn't been loaded.\n\n```js\ntodoAlgebra.difference({}, {complete: false}) //-> {complete: true}\n```\n\nThese algebra's are typically used internally by either [can-connect] or\n[can-fixture] to provide these special behaviors:\n\n```js\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{\n  algebra: todoAlgebra\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/cache-requests/cache-requests\")\n],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\",\n  algebra: todoAlgebra\n});\n```\n\n```js\nvar todoStore = fixture.store([\n    { _id : 1, name : 'Do the dishes', complete: true },\n    { _id : 2, name : 'Walk the dog', complete: false }\n  ],\n  todoAlgebra );\n\nfixture(\"/todos/{_id}\", todoStore);\n```\n\nThe best way to think about `can-set` is that its a way to detail\nthe behavior of your service layer so other utilities can benefit.\n\n",
    "description": " \ncan-set is a utility for comparing [can-set/Set sets] that are represented by the parameters commonly passed to service requests.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nOnce you've imported the `can-set` module into your project, use it to create a `set.Algebra` and then use that to compare and perform operations on sets.  \n\n```js\nvar set = require('can-set');\n// create an algebra\nvar algebra = new set.Algebra(\n    // specify the unique identifier on data\n    set.props.id(\"_id\"),  \n    // specify that completed can be true, false or undefined\n    set.props.boolean(\"completed\"),\n    // specify properties that define pagination\n    set.props.rangeInclusive(\"start\",\"end\"),\n    // specify the property that controls sorting\n    set.props.sort(\"orderBy\"),\n)\n\n// compare two sets\nalgebra.subset({start: 2, end: 3}, {start: 1, end: 4}) //-> true\nalgebra.difference({} , {completed: true}) //-> {completed: false}\n\n// perform operations on sets\nalgebra.getSubset({start: 2,end: 3},{start: 1,end: 4},\n            [{id: 1},{id: 2},{id: 3},{id: 4}])\n//-> [{id: 2},{id: 3}]\n```\n"
      }
    ],
    "name": "can-set",
    "parent": "can-core",
    "comment": " "
  },
  "can-set.compares": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.compares.md"
    },
    "body": "\n",
    "description": "An object of property names and `prop` functions. \n```js\n{\n  // return `true` if the values should be considered the same:\n  lastName: function(aValue, bValue){\n    return (\"\"+aValue).toLowerCase() === (\"\"+bValue).toLowerCase();\n  }\n}\n```\n\n\n",
    "type": "typedef",
    "title": "Compares",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-set.prop"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-set.compares",
    "parent": "can-set.types"
  },
  "can-set.prop": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.comparator.md"
    },
    "body": "\n",
    "description": "\n",
    "type": "typedef",
    "title": "Prop",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-set.prop",
    "parent": "can-set.types",
    "signatures": [
      {
        "code": "prop(aValue, bValue, a, b, prop, algebra)",
        "description": "\n\nA prop function returns algebra values for two values for a given property.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "aValue",
            "description": "The value of A's property in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "bValue",
            "description": "The value of A's property in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "a",
            "description": "The A set in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "b",
            "description": "The B set in a set difference A and B (A  B)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "Boolean"
            }
          ],
          "description": "A prop function should either return a Boolean which indicates if `aValue` and `bValue` are\nequal or an `AlgebraResult` object that details information about the union, intersection, and difference of `aValue` and `bValue`.\n\nAn `AlgebraResult` object has the following values:\n\n- `union` - A value the represents the union of A and B.\n- `intersection` - A value that represents the intersection of A and B.\n- `difference` - A value that represents all items in A that are not in B.\n- `count` - The count of the items in A.\n\nFor example, if you had a `colors` property and A is `[\"Red\",\"Blue\"]` and B is `[\"Green\",\"Yellow\",\"Blue\"]`, the\nAlgebraResult object might look like:\n\n```js\n{\n  union: [\"Red\",\"Blue\",\"Green\",\"Yellow\"],\n  intersection: [\"Blue\"],\n  difference: [\"Red\"],\n  count: 2000\n}\n```\n\nThe count is `2000` because there might be 2000 items represented by colors \"Red\" and \"Blue\".  Often\nthe real number can not be known.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "b",
      "description": "The B set in a set difference A and B (A  B)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Boolean"
        }
      ],
      "description": "A prop function should either return a Boolean which indicates if `aValue` and `bValue` are\nequal or an `AlgebraResult` object that details information about the union, intersection, and difference of `aValue` and `bValue`.\n\nAn `AlgebraResult` object has the following values:\n\n- `union` - A value the represents the union of A and B.\n- `intersection` - A value that represents the intersection of A and B.\n- `difference` - A value that represents all items in A that are not in B.\n- `count` - The count of the items in A.\n\nFor example, if you had a `colors` property and A is `[\"Red\",\"Blue\"]` and B is `[\"Green\",\"Yellow\",\"Blue\"]`, the\nAlgebraResult object might look like:\n\n```js\n{\n  union: [\"Red\",\"Blue\",\"Green\",\"Yellow\"],\n  intersection: [\"Blue\"],\n  difference: [\"Red\"],\n  count: 2000\n}\n```\n\nThe count is `2000` because there might be 2000 items represented by colors \"Red\" and \"Blue\".  Often\nthe real number can not be known.\n"
    }
  },
  "can-set.props": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.props.md"
    },
    "body": "",
    "description": "Contains a collection of prop generating functions. \nThe following functions create `compares` objects that can be mixed together to create a set `Algebra`.\n\n```js\nvar set = require(\"can-set\");\nvar algebra = new set.Algebra(\n  {\n    // ignore this property in set algebra\n    sessionId:  function(){ return true }\n  },\n  set.props.boolean(\"completed\"),\n  set.props.rangeInclusive(\"start\",\"end\")\n);\n```\n\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "props",
    "name": "can-set.props",
    "type": "property",
    "parent": "can-set.properties"
  },
  "can-jquery.modules": {
    "name": "can-jquery.modules",
    "title": "Modules",
    "type": "group",
    "parent": "can-jquery",
    "description": "",
    "order": 0
  },
  "can-jquery.fns": {
    "name": "can-jquery.fns",
    "title": "Methods",
    "type": "group",
    "parent": "can-jquery",
    "description": "",
    "order": 1
  },
  "can-jquery": {
    "src": {
      "path": "node_modules/can-jquery/docs/can-jquery.md"
    },
    "body": "\nUsing can-jquery causes the two event systems to be cross-bound. You can listen to special events within can using jQuery and you can listen to custom jQuery events within [can-control]s.\n\n## Listening to inserted/removed events\n\nUsing can-jquery you can listen to the removed/inserted event on an element.\n\n```js\nvar $ = require(\"can-jquery\");\n\nvar el = $(\"<div>\");\n\nel.on(\"inserted\", function(){\n\t// The element was inserted.\n});\n\n$(document.body).append(el);\n```\n\n## Listening to jQuery events within Controls\n\nInside a [can-control] you can listen to any custom jQuery events.\n\n```js\nvar $ = require(\"can-jquery\");\nvar Control = require(\"can-control\");\n\nvar MyControl = Control.extend({\n\t\"names-added\": function(el, ev, first, second, third){\n\t\t// first is \"Matthew\"\n\t\t// second is \"David\"\n\t\t// third is \"Brian\"\n\t}\n});\n\nvar dom = $(\"<div><ul></ul></div>\");\n\nnew MyControl(dom);\n\ndom.find(\"ul\").trigger(\"names-added\", [\n\t\"Matthew\",\n\t\"David\",\n\t\"Brian\"\n]);\n```\n\n",
    "description": "Extensions to the event system so that can events and jQuery events are cross-bound. \nImporting can-jquery will return the [jQuery object](http://api.jquery.com/jquery/) and wire up the event system.\n\n```js\nvar $ = require(\"can-jquery\");\n\nvar div = $(\"<div>\");\n\ndiv.on(\"inserted\", function(){\n\t// it inserted!\n});\n\n$(\"body\").append(div);\n```\n\n",
    "type": "module",
    "title": "can-jquery",
    "types": [
      {
        "type": "jQuery"
      }
    ],
    "name": "can-jquery",
    "parent": "can-ecosystem",
    "signatures": [
      {
        "code": "jQuery",
        "description": "Exports the [jQuery object](http://api.jquery.com/jquery/) after setting up bindings between the event systems.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-jquery/legacy": {
    "src": {
      "path": "node_modules/can-jquery/docs/legacy.md"
    },
    "body": "\nImporting can-jquery/legacy will also bring in [can-jquery], but also has the side effect of enabling jQuery wrappers being applied to places such as [can-control]s and [can-stache-bindings.event] callbacks.\n\n***Note*** that simply importing can-jquery-legacy will enable this, so any [can-control]s expecting to receive the raw [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) will break.\n\n```js\nvar $ = require(\"can-jquery/legacy\");\nvar Control = require(\"can-control\");\n\nvar MyControl = Control.extend({\n\t\"li click\": function(el){\n\t\t// `el` is jQuery wrapped!\n\t}\n});\n\nvar dom = $(\"<div><ul><li>First</li><li>Second</li></ul></div>\");\nnew MyControl(dom);\n\ndom.find(\"li:first\").trigger(\"click\");\n```\n\n",
    "description": "Enables legacy integrations between CanJS and jQuery. \nImporting can/jquery/legacy will return the [jQuery object](http://api.jquery.com/jquery/). It will also import [can-jquery] so that the event system hooks are set up.\n\nAdditionally it will force element callbacks (such as those in [can-control]) to be jQuery wrapped.\n\n```js\nvar $ = require(\"can-jquery/legacy\");\n```\n\n",
    "type": "module",
    "title": "can-jquery/legacy",
    "types": [
      {
        "type": "jQuery"
      }
    ],
    "name": "can-jquery/legacy",
    "parent": "can-jquery.modules",
    "comment": " "
  },
  "can-jquery.fns.viewModel": {
    "src": {
      "path": "node_modules/can-jquery/docs/viewModel.md"
    },
    "body": "",
    "description": "Gets an element's View Model. \n",
    "title": "viewModel",
    "name": "can-jquery.fns.viewModel",
    "type": "function",
    "parent": "can-jquery.fns",
    "signatures": [
      {
        "code": ".viewModel()",
        "description": "\n\nCalls [can-view-model] with the unwrapped HTMLElement.\n\n```js\nvar vm = $(\"my-component\").viewModel();\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            },
            {
              "type": "can-map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the View Model set for this element.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        },
        {
          "type": "can-map"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the View Model set for this element.\n"
    }
  },
  "can-map-define.ValueConstructor": {
    "src": {
      "path": "node_modules/can-map-define/docs/ValueConstructor.md"
    },
    "body": "\n\nSimilar to [can-map-define.value value], this uppercase version provides a mechanism for providing a default value.  If the default value is an object, providing a constructor is a good way to ensure a copy is made for each instance.\n\n",
    "description": "\nProvides a constructor function to be used to provide a default value for a certain property of a [can-map Map].  This constructor will be invoked with `new` each time a new instance of the map is created.\n",
    "title": "Value",
    "name": "can-map-define.ValueConstructor",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "constructorFunc",
        "description": "\n\nA constructor function can be provided that is called to create a default value used for this property, like:\n\n    define: {\n      prop: {\n        Value: Array\n      },\n      person: {\n      \tValue: Person\n      }\n    }\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-map-define.TypeConstructor": {
    "src": {
      "path": "node_modules/can-map-define/docs/TypeConstructor.md"
    },
    "body": "\n\n\nSimilar to [can-map-define._type type], this uppercase version provides a mechanism for converting incoming values to another format or type.\n\nSpecifically, this constructor will be invoked any time this property is set, and any data passed into the setter will be passed as arguments for the constructor.\n\nIf the call to attr passes an object that is already an instance of the constructor specified with `Type`, no conversion is done.\n\n",
    "description": "\nProvides a constructor function to be used to convert any value passed into [can-map.prototype.attr attr] into an appropriate value\n",
    "title": "Type",
    "name": "can-map-define.TypeConstructor",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "constructorFunc",
        "description": "\n\nA constructor function can be provided that is called to convert incoming values set on this property, like:\n\n    define: {\n      prop: {\n        Type: Person\n      }\n    }\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-map-define.attrDefinition": {
    "src": {
      "path": "node_modules/can-map-define/docs/attrDefinition.md"
    },
    "body": "\n",
    "description": "\nDefines the type, initial value, and get, set, and remove behavior for an attribute of a [can-map Map].\n",
    "type": "typedef",
    "title": "attribute definition",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "value",
            "description": "Specifies the initial value of the attribute or\na function that returns the initial value. For example, a default value of `0` can be \nspecified like:\n\n    define: {\n      prop: {\n        value: 0\n      }\n    }\n\n`Object` types should not be specified directly on `value` because that same object will\nbe shared on every instance of the Map.  Instead, a [can-map-define.value value function] that \nreturns a fresh copy can be provided:\n\n    define: {\n      prop: {\n        value: function(){\n          return {foo: \"bar\"}\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.value"
              },
              {
                "type": "*"
              }
            ]
          },
          {
            "name": "Value",
            "description": "Specifies a function that will be called with `new` whose result is\nset as the initial value of the attribute. For example, if the default value should be a [can-list List]:\n\n    define: {\n      prop: {\n        Value: Map.List\n      }\n    }\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "type",
            "description": "Specifies the type of the \nattribute.  The type can be specified as either a [can-map-define._type type function] \nthat returns the type coerced value or one of the following strings:\n\n - `\"string\"` - Converts the value to a string.\n - `\"date\"` - Converts the value to a date or `null if the date can not be converted.\n - `\"number\"` - Passes the value through `parseFloat`.\n - `\"boolean\"` - Converts falsey, `\"false\"` or `\"0\"` to `false` and everything else to true.\n - `\"*\"` - Prevents the default type coersion of converting Objects to [can-map Map]s and Arrays to [can-list List]s.\n\nThe following example converts the `count` property to a number and the `items` property to an array:\n\n     define: {\n       count: {type: \"number\"},\n       items: {\n         type: function(newValue){\n           if(typeof newValue === \"string\") {\n             return newValue.split(\",\")\n           } else if( can.isArray(newValue) ) {\n             return newValue;\n           }\n         }\n       }\n     }\n",
            "types": [
              {
                "type": "can-map-define._type"
              },
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "Type",
            "description": "A constructor function that takes \nthe value passed to [can-map.prototype.attr attr] as the first argument and called with \nnew. For example, if you want whatever\ngets passed to go through `new Array(newValue)` you can do that like:\n\n    define: {\n      items: {\n        Type: Array\n      }\n    }\n\nIf the value passed to [can-map.prototype.attr attr] is already an Array, it will be left as is.\n",
            "types": [
              {
                "type": "can-map-define.TypeConstructor"
              }
            ]
          },
          {
            "name": "set",
            "description": "A set function that specifies what should happen when an attribute\nis set on a [can-map]. `set` is called with the result of `type` or `Type`. The following\ndefines a `page` setter that updates the map's offset:\n\n    define: {\n      page: {\n        set: function(newVal){\n          this.attr('offset', (parseInt(newVal) - 1) * \n                               this.attr('limit'));\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.set"
              }
            ]
          },
          {
            "name": "get",
            "description": "A function that specifies how the value is retrieved.  The get function is \nconverted to an [can-compute.async async compute].  It should derive its value from other values\non the map. The following\ndefines a `page` getter that reads from a map's offset and limit:\n\n    define: {\n      page: {\n        get: function (newVal) {\n\t\t  return Math.floor(this.attr('offset') / \n\t\t                    this.attr('limit')) + 1;\n\t\t}\n      }\n    }\n    \nA `get` definition makes the property __computed__ which means it will not be serialized by default.\n",
            "types": [
              {
                "type": "can-map-define.get"
              }
            ]
          },
          {
            "name": "remove",
            "description": "A function that specifies what should happen when an attribute is removed\nwith [can-map.prototype.removeAttr removeAttr]. The following removes a `modelId` when `makeId` is removed:\n\n    define: {\n      makeId: {\n        remove: function(){\n          this.removeAttr(\"modelId\");\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.remove"
              }
            ]
          },
          {
            "name": "serialize",
            "description": "Specifies the behavior of the \nproperty when [can-map.prototype.serialize serialize] is called. \n\nBy default, serialize does not include computed values. Properties with a `get` definition\nare computed and therefore are not added to the result.  Non-computed properties values are\nserialized if possible and added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        pageNum: {\n          get: function(){ return this.offset() / 20 }\n        }\n      }\n    });\n    \n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 40}\n\nIf `true` is specified, computed properties will be serialized and added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        pageNum: { \n          get: function(){ return this.offset() / 20 },\n          serialize: true\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 40, pageNum: 2}\n    \n    \nIf `false` is specified, non-computed properties will not be added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        offset: {\n          serialize: false\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {}\n\nIf a [can-map-define.serialize serialize function] is specified, the result\nof the function is added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        offset: {\n          serialize: function(offset){\n            return (offset / 20)+1\n          }\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 3}\n    \n",
            "types": [
              {
                "type": "can-map-define.serialize"
              },
              {
                "type": "Boolean"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-map-define.attrDefinition",
    "parent": "can-map-define"
  },
  "can-map-define.serialize": {
    "src": {
      "path": "node_modules/can-map-define/docs/serialize.md"
    },
    "body": "\n\n## Use\n\n[can-map.prototype.serialize serialize] is useful for serializing a Map instance into \na more JSON-friendly form.  This can be used for many reasons, including saving a \n[can-model Model] instance on the server or serializing [can-route route]'s internal \nMap for display in the hash or pushstate URL.\n\nThe serialize property allows an opportunity to define how \neach attribute will behave when the map is serialized.  This can be useful for:\n\n- serializing complex types like dates, arrays, or objects into string formats\n- causing certain properties to be ignored when serialize is called\n\nThe following causes a locationIds property to be serialized into \nthe comma separated ID values of the location property on this map:\n\n    define: {\n      locationIds: {\n        serialize: function(){\n\t\t  var ids = [];\n\t\t  this.attr('locations').each(function(location){\n\t\t    ids.push(location.id);\n\t\t  });\n\t\t  return ids.join(',');\n        }\n      }\n    }\n\nReturning `undefined` for any property means this property will not be part of the serialized \nobject.  For example, if the property numPages is not greater than zero, the following example \nwon't include it in the serialized object.\n\n    define: {\n      prop: {\n        numPages: function( num ){\n          if(num <= 0) {\n          \treturn undefined;\n          }\n          return num;\n        }\n      }\n    }\n\n",
    "description": "\nCalled when an attribute is removed.\n",
    "title": "serialize",
    "name": "can-map-define.serialize",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "serialize( currentValue )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The current value of the attribute. \n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attr",
            "description": "The name of the attribute being serialized.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If `undefined` is returned, the value is not serialized.\n"
        },
        "context": {
          "types": [
            {
              "type": "Map"
            }
          ],
          "description": "The map instance being serialized.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attr",
      "description": "The name of the attribute being serialized.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If `undefined` is returned, the value is not serialized.\n"
    },
    "comment": " "
  },
  "can-map-define.remove": {
    "src": {
      "path": "node_modules/can-map-define/docs/remove.md"
    },
    "body": "\n\n## Use\n\nThe following prevents removing the _prop_ attribute if someone tries to remove the value 0:\n\n\n    define: {\n      prop: {\n        remove: function( currentVal ){\n          return currentVal !== 0;\n        }\n      }\n    }\n\n\n",
    "description": "\nCalled when an attribute is removed.\n",
    "title": "remove",
    "name": "can-map-define.remove",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "remove( currentValue )",
        "description": "\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "false"
            }
          ],
          "description": "If `false` is returned, the value is not removed.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "false"
        }
      ],
      "description": "If `false` is returned, the value is not removed.\n"
    },
    "comment": " "
  },
  "can-map-define.get": {
    "src": {
      "path": "node_modules/can-map-define/docs/get.md"
    },
    "body": "\n\n\n## Use\n\nGetter methods are useful for:\n\n - Defining virtual properties on a map.\n - Defining property values that change with their _internal_ set value. \n \n## Virtual properties\n\n\nVirtual properties are properties that don't actually store any value, but derive their value \nfrom some other properties on the map.\n\nWhenever a getter is provided, it is wrapped in a [can-compute compute], which ensures \nthat whenever its dependent properties change, a change event will fire for this property also.\n\n```\nvar Person = Model.extend({\n\tdefine: {\n\t\tfullName: {\n\t\t\tget: function () {\n\t\t\t\treturn this.attr(\"first\") + \" \" + this.attr(\"last\");\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar p = new Person({first: \"Justin\", last: \"Meyer\"});\n\np.attr(\"fullName\"); // \"Justin Meyer\"\n\np.bind(\"fullName\", function(ev, newVal){\n  newVal //-> \"Lincoln Meyer\";\n});\n\np.attr(\"first\",\"Lincoln\");\n```\n\n## Asyncronous virtual properties\n\nOften, a virtual property's value only becomes available after some period of time.  For example,\ngiven a `personId`, one might want to retrieve a related person:\n\n```\nvar AppState = Map.extend({\n  define: {\n    person: {\n      get: function(lastSetValue, setAttrValue){\n        Person.findOne({id: this.attr(\"personId\")})\n        \t.then(function(person){\n        \t\tsetAttrValue(person);\n        \t});\n      }\n    }\n  }\n});\n```\n\nAsyncronous properties should be bound to before reading their value.  If \nthey are not bound to, the `get` function will be called each time.\n\nThe following example will make multiple `Person.findOne` requests: \n\n```\nvar state = new AppState({personId: 5});\nstate.attr(\"person\") //-> undefined\n\n// called sometime later ...\nstate.attr(\"person\") //-> undefined\n```\n\nHowever, by binding, the compute only reruns the `get` function once `personId` changes:\n\n```\nvar state = new AppState({personId: 5});\n\nstate.bind(\"person\", function(){})\n\nstate.attr(\"person\") //-> undefined\n\n// called sometime later\nstate.attr(\"person\") //-> Person<{id: 5}>\n```\n\nA template like [can-stache stache] will automatically bind for you, so you can pass\n`state` to the template like the following without binding:\n\n```\nvar template = stache(\"<span>{{person.fullName}}</span>\");\nvar state = new AppState({});\nvar frag = template(state);\n\nstate.attr(\"personId\",5);\nfrag.childNodes[0].innerHTML //=> \"\"\n\n// sometime later\nfrag.childNodes[0].innerHTML //=> \"Lincoln Meyer\"\n\n```\n\nThe magic tags are updated as `personId`, `person`, and `fullName` change.\n\n\n## Properties values that change with their _internal_ set value \n\nA getter can be used to derive a value from a set value. A getter's\n`lastSetValue` argument is the last value set by [can-map.prototype.attr attr]. \n\nFor example, a property might be set to a compute, but when read, provides the value\nof the compute.\n\n```\nvar MyMap = Map.extend({\n  define: {\n    value: {\n      get: function( lastSetValue ){\n        return lastSetValue();\n      }\n    }\n  }\n});\n\nvar map = new MyMap();\nvar compute = can.compute(1);\nmap.attr(\"value\", compute);\n\nmap.attr(\"value\") //-> 1\ncompute(2);\nmap.attr(\"value\") //-> 2\n```\n\nThis technique should only be used when the `lastSetValue` is some form of\nobservable, that when it changes, can update the `getter` value.\n\nFor simple conversions, [can-map-define.set set] or [can-map-define._type type] should be used.\n\n## Updating the virtual property value\n\nIt's very common (and better performing) to update the virtual property value \ninstead of replacing it. \n\nThe following example creates an empty `locationIds` [can-list List] when a new\ninstance of `Store` is created.  However, as `locations` change,\nthe [can-list List] will be updated with the `id`s of the `locations`.\n\n\n```\nvar Store = Map.extend({\n\tdefine: {\n\t\tlocationIds: {\n\t\t\tValue: Map.List,\n\t\t\tget: function(initialValue){\n\t\t\t\tvar ids = [];\n\t\t\t\tthis.attr('locations').each(function(location){\n\t\t\t\t\tids.push(location.attr(\"id\"));\n\t\t\t\t});\n\t\t\t\treturn initialValue.replace(ids);\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n",
    "description": "\nSpecify what happens when a certain property is read on a map. `get` functions\nwork like a [can-compute compute] and automatically update themselves when a dependent\nobservable value is changed.\n",
    "title": "get",
    "name": "can-map-define.get",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "get( [lastSetValue] )",
        "description": "\n\n  Defines the behavior when a value is read on a [can-map Map]. Used to provide properties that derive their value from \n  other properties of the map, or __update__ their value from \n  the changes in the value that was set. \n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The value last set by `.attr(property, value)`.  Typically, _lastSetValue_ \nshould be an observable value, like a [can-compute compute] or promise. If it's not, it's likely \nthat a [can-map-define.set define.set] should be used instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property.\n"
        }
      },
      {
        "code": "get( lastSetValue, setAttrValue(value) )",
        "description": "\n\n  Asynchronously defines the behavior when a value is read on a [can-map Map]. Used to provide property values that\n  are available asynchronously. \n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "lastSetValue",
            "description": "The value last set by `.attr(property, value)`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "value"
                  }
                ]
              }
            ],
            "name": "setAttrValue",
            "description": "Updates the value of the property. This can be called\nmultiple times if needed.\n "
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of the property.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "value"
            }
          ]
        }
      ],
      "name": "setAttrValue",
      "description": "Updates the value of the property. This can be called\nmultiple times if needed.\n "
    },
    "comment": " "
  },
  "can-map-define.set": {
    "src": {
      "path": "node_modules/can-map-define/docs/set.md"
    },
    "body": "\n\n## Use\n\nAn attribute's `set` function can be used to customize the behavior of when an attribute value is set\nvia [can-map.prototype.attr `.attr()`].  Lets see some common cases:\n\n#### Side effects\n\nThe following makes setting a `page` property update the `offset`:\n\n    define: {\n      page: {\n        set: function(newVal){\n          this.attr('offset', (parseInt(newVal) - 1) *\n                               this.attr('limit'));\n        }\n      }\n    }\n\nThe following makes changing `makeId` remove the `modelId` property:\n\n    define: {\n      makeId: {\n        set: function(newValue){\n          // Check if we are changing.\n          if(newValue !== this.attr(\"makeId\")) {\n            this.removeAttr(\"modelId\");\n          }\n          // Must return value to set as we have a `newValue` argument.\n          return newValue;\n        }\n      }\n    }\n\n#### Asynchronous Setter\n\nThe following shows an async setter:\n\n    define: {\n      prop: {\n        set: function( newVal, setVal){\n          $.get(\"/something\", {}, setVal );\n        }\n      }\n    }\n\n\n## Behavior depends on the number of arguments.\n\nWhen a setter returns `undefined`, its behavior changes depending on the number of arguments.\n\nWith 0 arguments, the original set value is set on the attribute.\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    map.attr(\"prop\") //-> \"foo\"\n\nWith 1 argument, `undefined` will remove the property.  \n\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(newVal){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    Map.keys(map) //-> []\n\nWith 2 arguments, `undefined` leaves the property in place.  It is expected\nthat `setValue` will be called:\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(newVal, setValue){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    map.attr(\"prop\") //-> \"foo\"\n\n## Side effects\n\nA set function provides a useful hook for performing side effect logic as a certain property is being changed.\n\nFor example, in the example below, Paginator can.Map includes a `page` property, which derives its value entirely from other properties (limit and offset).  If something tries to set the `page` directly, the set method will set the value of `offset`:\n\n\n    var Paginate = Map.extend({\n      define: {\n        page: {\n          set: function (newVal) {\n            this.attr('offset', (parseInt(newVal) - 1) * this.attr('limit'));\n          },\n          get: function () {\n            return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n          }\n        }\n      }\n    });\n\n    var p = new Paginate({limit: 10, offset: 20});\n\n## Merging\n\nBy default, if a value returned from a setter is an object, array, can.Map, or can.List, the effect will be to replace the property with the new object completely.\n\n    Contact = Map.extend({\n      define: {\n        info: {\n          set: function(newVal){\n            return newVal;\n          }\n        }\n      }\n    })\n\n    var alice = new Contact({\n\t\t\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n\t\t});\n    alice.attr(); // {name: 'Alice Liddell', 'email': 'alice@liddell.com'}\n    alice.info._cid; // '.map1'\n\n    alice.attr('info', {name: 'Allison Wonderland', phone: '888-888-8888'});\n    alice.attr(); // {name: 'Allison Wonderland', 'phone': '888-888-8888'}\n    alice.info._cid; // '.map2'\n\nBy contrast, if you access a property of a Map using `.attr`, then change it by calling `.attr` on it directly, the new properties will be merged with the existing nested Map, not replaced.\n\n    var contact = new Map({\n      'info' : {'breath' : 'smells like roses'}\n    });\n    var newInfo = {'teeth' : 'shiny and clean'};\n    contact.attr('info').attr(newInfo); // info is now a merged object\n\nIf you would rather have the new Map or List merged into the current value, not replaced, call\n`.attr` inside the setter:\n\n\n    Contact = Map.extend({\n      define: {\n        info: {\n          set: function(newVal){\n            this.info.attr(newVal);\n            return this.info;\n          }\n        }\n      }\n    })\n\n    var alice = new Contact({\n\t\t\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n\t\t});\n    alice.attr(); // {name: 'Alice Liddell', 'email': 'alice@liddell.com'}\n    alice.info._cid; // '.map1'\n\n    alice.attr('info', {name: 'Allison Wonderland', phone: '888-888-8888'});\n    alice.attr();\n    //{\n    //  name: 'Allison Wonderland',\n    //  email: 'alice@liddell.com',\n    //  phone: '888-888-8888'\n    //}\n    alice.info._cid; // '.map1'\n\n## Batched Changes\n\nBy default, calls to set methods are wrapped in a call to [can-event/batch/batch.start batch.start] and [can-event/batch/batch.stop batch.stop], so if a set method has side effects that set more than one property, all these sets are wrapped in a single batch for better performance.\n\n",
    "description": "\nSpecify what happens when a value is set on a map attribute.\n",
    "title": "set",
    "name": "can-map-define.set",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "set( [newVal,] [setValue] )",
        "description": "\n\nA set function defines the behavior of what happens when a value is set on a\n[can-map Map]. It is typically used to:\n\n - Add or remove other attributes as side effects\n - Coerce the set value into an appropriate action\n\nThe behavior of the setter depends on the number of arguments specified. This means that a\nsetter like:\n\n    define: {\n      prop: {\n        set: function(){}\n      }\n    }\n\nbehaves differently than:\n\n    define: {\n      prop: {\n        set: function(newVal){}\n      }\n    }\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "The [can-map-define._type type function] coerced value the user intends to set on the\n[can-map Map].\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "setValue",
            "description": "A callback that can set the value of the property\nasyncronously.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the attribute value is set\n   to whatever was passed to [can-map.prototype.attr attr].\n - If the setter specifies the `newValue` argument only, the attribute value will be removed.\n - If the setter specifies both `newValue` and `setValue`, the value of the property will not be\n   updated until `setValue` is called.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ]
        }
      ],
      "optional": true,
      "name": "setValue",
      "description": "A callback that can set the value of the property\nasyncronously.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the attribute value is set\n   to whatever was passed to [can-map.prototype.attr attr].\n - If the setter specifies the `newValue` argument only, the attribute value will be removed.\n - If the setter specifies both `newValue` and `setValue`, the value of the property will not be\n   updated until `setValue` is called.\n\n"
    },
    "comment": " "
  },
  "can-map-define._type": {
    "src": {
      "path": "node_modules/can-map-define/docs/type.md"
    },
    "body": "\n\n## Use\n\nThe `type` property specifies the type of the attribute.  The type can be specified\nas either a type function that returns the type coerced value or one of the following strings:\n\n - `\"string\"` - Converts the value to a string except `null` or `undefined`.\n - `\"date\"` - Converts the value to a date or `null` if the date can not be converted.\n - `\"number\"` - Passes the value through `parseFloat` except for `null` or `undefined`.\n - `\"boolean\"` - Converts falsey, `\"false\"` or `\"0\"` to `false` and everything else to true.\n - `\"htmlbool\"` - Like `boolean`, but also converts empty strings to\n   `true`. Used, for example, when input is from component attributes like\n   `<can-tabs reverse/>`\n - `\"compute\"` - If the value set is a compute, will allow the returning of the computed value.\n - `\"*\"` - Prevents the default type coersion of converting Objects to [can-map Map]s and Arrays to [can-list List]s.\n\n### Basic Example\n\nThe following example converts the `count` property to a number and the `items` property to an array:\n\n     define: {\n       count: {type: \"number\"},\n       items: {\n         type: function(newValue){\n           if(typeof newValue === \"string\") {\n             return newValue.split(\",\")\n           } else if( can.isArray(newValue) ) {\n             return newValue;\n           }\n         }\n       }\n     }\n\nWhen a user tries to set those properties like:\n\n    map.attr({count: \"4\", items: \"1,2,3\"});\n\nThe number converter will be used to turn count into 4, and the items type converter function will be used to turn items into [1,2,3].\n\n### Preventing Arrays and Objects from Automatic Conversion\n\nWhen an array is passed into a Map setter, it is automatically converted into a List. Likewise, objects are converted into Map instances. This behavior can be prevented like the following:\n\n     define: {\n       locations: {type: \"*\"}\n     }\n\nWhen a user tries to set this property, the resulting value will remain an array.\n\n    map.attr('locations', [1, 2, 3]); // locations is an array, not a List\n\n### Working with the 'compute' type\n\nSetting type as [can-compute `compute`] allows for resolving a computed property with the .attr()\nmethod.\n\n```js\nMyMap = Map.extend({\n  define: {\n    value: {\n      type: \"compute\"\n    }\n  }\n});\n\nvar myMap = new MyMap();\nvar c = compute(5);\n\nmyMap.attr(\"value\",c);\nmyMap.attr(\"value\"); //-> 5\n\nc(6);\nmyMap.attr(\"value\"); //-> 6\n\n//Be sure if setting to pass the new compute\nvar c2 = compute(\"a\");\nmyMap.attr(\"value\",c2);\nmyMap.attr(\"value\"); //-> \"a\"\n```\n\n",
    "description": "\nConverts a value passed to [can-map.prototype.attr attr] into an appropriate value.\n",
    "title": "type",
    "name": "can-map-define._type",
    "type": "function",
    "parent": "can-map-define",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "newValue",
        "description": "The value passed to `attr`."
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "attrName",
        "description": "The attribute name being set."
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The attribute name being set."
    },
    "context": {
      "types": [
        {
          "type": "Map"
        }
      ],
      "description": "the instance of the [can-map Map]."
    },
    "returns": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
    },
    "comment": " "
  },
  "can-map-define.value": {
    "src": {
      "path": "node_modules/can-map-define/docs/value.md"
    },
    "body": "\n\nThere is a third way to provide a default value, which is explained in the [can-map-define.ValueConstructor Value] docs page. `value` lowercased is for providing default values for a property type, while `Value` uppercased is for providing a constructor function, which will be invoked with `new` to create a default value for each instance of this map.\n\n",
    "description": "\nReturns the default value for instances of this [can-map Map].  This is called before `init`.\n",
    "title": "value",
    "name": "can-map-define.value",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "defaulter()",
        "description": "\n\nA function can be provided that returns the default value used for this property, like:\n\n    define: {\n      prop: {\n        value: function(){ return []; }\n      }\n    }\n\nIf the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property `value` above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).\n",
        "params": [],
        "context": {
          "types": [
            {
              "type": "Map"
            }
          ],
          "description": "the instance of the [can-map Map].\n"
        },
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The default value.  This will be passed through setter and type.\n"
        }
      },
      {
        "code": "defaulVal",
        "description": "\n\nAny value can be provided as the default value used for this property, like:\n\n    define: {\n      prop: {\n        value: 'foo'\n      }\n    }\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "defaultVal",
            "description": "The default value, which will be passed through setter and type.\n"
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The default value.  This will be passed through setter and type.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "defaultVal",
      "description": "The default value, which will be passed through setter and type.\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages": {
    "name": "can-stache-converters.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-stache-converters",
    "description": "",
    "order": 0
  },
  "can-stache-converters.converters": {
    "name": "can-stache-converters.converters",
    "title": "Converters",
    "type": "group",
    "parent": "can-stache-converters",
    "description": "",
    "order": 0
  },
  "can-stache-converters": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/can-stache-converters.md"
    },
    "body": "\n\n## Use\n\nThe **can-stache-converters** plugin provides a set of useful converters useful for binding to form elements.\n\n",
    "description": "\nProvides a set of [can-stache.registerConverter converters] useful for two-way binding with form elements such as `<input>` and `<select>`.\n",
    "type": "module",
    "title": "",
    "name": "can-stache-converters",
    "parent": "can-ecosystem",
    "comment": " "
  },
  "can-stache-converters.boolean-to-inList": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/boolean-to-inList.md"
    },
    "body": "\n## Use\n\nUse this converter when two-way binding to an element with a boolean attribute, such as a checkbox.\n\n```js\nvar map = new DefineMap({\n\titem: 5,\n\tlist: [1, 2, 3, 4, 5]\n});\n\nvar template = stache('<input type=\"checkbox\" {($value)}=\"boolean-to-inList(item, list)\" />');\n\ndocument.body.appendChild(template(map));\n\nvar input = document.querySelector('input[type=checkbox]');\n\nconsole.log(input.checked); // -> true\n\nmap.item = 6;\n\nconsole.log(input.checked); // -> false\n\nmap.list.push(6);\n\nconsole.log(input.checked); // -> true\n```\n\n\n",
    "description": "A [can-stache.registerConverter converter] that binds a boolean attribute, such as an `<input>` value to whether or not an item is in a list. \n",
    "title": "boolean-to-inList",
    "name": "can-stache-converters.boolean-to-inList",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "boolean-to-inList(item, list)",
        "description": "\n\nWhen the getter is called, returns true if **item** is within the **list**, determined using `.indexOf`.\n\nWhen the setter is called, if the new value is truthy then the item will be added to the list using `.push`; if it is falsey the item will removed from the list using `.splice`.\n\n```handlebars\n<input type=\"checkbox\" {($value)}=\"boolean-to-inList(item, list)\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "The item to which to check"
          },
          {
            "types": [
              {
                "type": "can-define/list/list"
              },
              {
                "type": "can-list"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "list",
            "description": "The list"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element's value changes.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-define/list/list"
        },
        {
          "type": "can-list"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "list",
      "description": "The list"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element's value changes.\n"
    },
    "comment": " "
  },
  "can-stache-converters.either-or": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/either-or.md"
    },
    "body": "\n## Use\n\n**either-or** is made to be used with `<input type=checkbox>` elements when there is a binary decision that can be made (so that multiple radio buttons are not needed).\n\nYou pass 3 arguments to this [can-stache.registerConverter converter]. The first argument is a compute that represents the chosen value. The second argument is the default, truthy, value. And the third argument is the falsey value.\n\n\n```handlebars\n<p>\n\t<input type=\"checkbox\"\n\t\t({$checked})=\"either-or(~pref, 'Star Trek', 'Star Wars')\" />\n\t<span>Star Trek</span>\n</p>\n\n<p>Your fandom: {{pref}}</p>\n```\n\n```js\nvar template = stache.from(\"demo-template\");\n\nvar fan = new DefineMap({\n\tpref: \"Star Trek\"\n});\n\ndocument.body.appendChild(template(fan));\n\n// User unchecks the checkbox\nfan.pref === \"Star Wars\";\n\n// Changing the value in code:\nfan.pref === \"Star Trek\";\n\n// Checkbox is now checked again.\n```\n\n",
    "description": "a [can-stache-registerConverter converter] that two-way binds to a checkbox two values provided as arguments. This converter is useful when you have a binary decision that your user will implicitly understand. \n",
    "title": "either-or",
    "name": "can-stache-converters.either-or",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "either-or(~chosen, a, b)",
        "description": "\n\nWhen the getter is called, gets the value of the **chosen** compute and if it is equal to **a** returns true, otherwise it returns false.\n\nWhen the setter is called, if the new value is truthy, sets the **chosen** [can-compute] to **a**'s value, otherwise sets it to **b**'s value.\n\n```handlebars\n<span>Favorite superhero:</span>\n<input type=\"checkbox\" {($checked)}=\"either-or(~chosen, 'Batman', 'Superman')\"> Batman?\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "chosen",
            "description": "A compute where the chosen value (between `a` and `b` is stored). When the setter is called, this compute's value will be updated.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "a",
            "description": "The `true` value. If the checkbox is checked, then **a**'s value will be stored in the **chosen** compute.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "b",
            "description": "The `false` value. If the checkbox is unchecked, then **b**'s value will be stored in the **chosen** compute.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter bound to the element.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "b",
      "description": "The `false` value. If the checkbox is unchecked, then **b**'s value will be stored in the **chosen** compute.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter bound to the element.\n"
    },
    "comment": " "
  },
  "can-stache-converters.equal": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/equal.md"
    },
    "body": "\n## Use\n\nThis [can-stache.converter converter] will most often be used in conjunction with a radio input in order to bind a scope's value (such as string, but could be any value) based on the selection of the radio group.\n\nIn this example we are using objects, to select a captain from one of three players:\n\n```handlebars\n{{#each players}}\n\t<input type=\"radio\" {($checked)}=\"equal(~captain, this)\" /> {{name}}\n{{/each}}\n```\n\n```js\nvar template = stache.from(\"demo\");\nvar vm = new DefineMap({\n\tcaptain: null,\n\tplayers: [\n\t\t{ name: \"Matthew\" },\n\t\t{ name: \"Wilbur\" },\n\t\t{ name: \"Anne\" }\n\t]\n});\nvm.captain = vm.players[0];\n\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that is usually for binding to a `<input type=\"radio\">` group, so that a scope value can be set the radio group's selected value. \n",
    "title": "equal",
    "name": "can-stache-converters.equal",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "equal(~compute, value)",
        "description": "\n\nWhen the getter is called **compute**, a [can-compute.computed], is compared to **value** and if they are equal, returns true.\n\nWhen the setter is called, if the radio is now checked the **compute**'s setter is called with **value** as the value.\n\n```handlebars\n<input type=\"radio\" {($checked)}=\"equal(~color, 'red')\" /> Red\n<input type=\"radio\" {($checked)}=\"equal(~color, 'blue')\" /> Blue\n```\n\nIn this example, the `color` scope value will be set to 'red' when the first radio is selected and 'blue' when the second radio is selected.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "A compute whose value will be compared to the second argument."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "A value of any type, that will be compared to the compute's internal value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound to the radio's checked property.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "A value of any type, that will be compared to the compute's internal value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be two-way bound to the radio's checked property.\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages.input-checkbox": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/input-checkbox.md"
    },
    "body": "\n\n## Binding to checkboxes\n\nTo bind to a checkbox and set a boolean value within your [can-view-scope scope], set up a [can-stache-bindings.twoWay two way] binding to the input's `checked` property like so:\n\n```\n<input type=\"checkbox\" {($checked)}=\"val\" />\n```\n\n[can-stache-converters provides a couple of convenience converters that handle common use cases for binding to a checkbox.\n\n## Binding based on whether an item is in a list\n\nUsing [can-stache-converters.boolean-to-inList] is useful to two-way bind to a checkbox based on whether an item is in a list or not. When the checkbox is checked/unchecked, the list will be updated and that item will either be removed or added to the list.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-checkbox.html'></div>\n\n## Binding based on a binary decision\n\nAn alternative true and false value can be specified by using [can-stache.converters.either-or]. This is used for setting up a \"boolean\" property that only has two possible valid values, whose values are modelled by the true/false checked property of a checkbox, as in the following example:\n\n\n```\n<input type=\"checkbox\" {($checked)}=\"either-or=(~val, 'a', 'b')\" />\n```\n\nIn this case, the data passed in as `val` is a [can-compute] that contains either the value **a** or **b**. If the value of `val` is **a** then the checkbox will be checked. When the user checks/unchecks the checkbox then the value of `val` is set to be either **a** or **b** depending on whether it is checked.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-checkbox-binary.html'></div>\n\n",
    "description": "\nCross bind a value to a checkbox.\n",
    "name": "can-stache-converters.pages.input-checkbox",
    "title": "input[type=checkbox]",
    "type": "page",
    "parent": "can-stache-converters.pages",
    "comment": " "
  },
  "can-stache-converters.index-to-selected": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/index-to-selected.md"
    },
    "body": "\n## Use\n\nThis will most often be used in conjunction with a `<select>` element and a bunch of options.\n\nThe provided `item` **must** be a [can-compute] so that its value can be set when the user selects own of the dropdown options.\n\nYou **must** use the indexes from the list as your `<option>` values. This is how it looks up items in the list both in the getter and the setter.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/select-by-index.html'></div>\n\n",
    "description": "A [can-stache.registerConverter converter] that binds to a `<select>` value in order to two-way bind a selected item from a list using the index as the key. \n",
    "title": "index-to-selected",
    "name": "can-stache-converters.index-to-selected",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "index-to-selected(~item, list)",
        "description": "\n\nWhen the getter is called, returns the index of the passed in item (which should be a [can-compute] from the provided list.\n\nWhen the setter is called, takes the selected index value and finds the item from the list with that index and passes that to set the compute's value.\n\n```handlebars\n<select {($value)}=\"index-to-selected(~person, people)\">\n\n\t{{#each people}}\n\n\t\t<option value=\"{{%index}}\">{{name}}</option>\n\n\t{{/each}}\n\n</select>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "item",
            "description": "A compute whose item is in the list."
          },
          {
            "types": [
              {
                "type": "can-define/list/list"
              },
              {
                "type": "can-list"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "list",
            "description": "A list used to find the `item`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound to the select's value.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-define/list/list"
        },
        {
          "type": "can-list"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "list",
      "description": "A list used to find the `item`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be two-way bound to the select's value.\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages.input-radio": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/input-radio.md"
    },
    "body": "\n\n## Binding to radios\n\nTo bind to a radio input, if you have a set of boolean values you can bind to the input's `checked` property as you do with [can-stache-converters.pages.input-checkbox].\n\n```handlebars\n<input type=\"radio\" {($checked)}=\"one\" /> One\n<input type=\"radio\" {($checked)}=\"two\" /> Two\n```\n\n```js\nvar template = stache.from(\"demo\");\nvar map = new DefineMap({\n\tone: true,\n\ttwo: false\n});\n\ndocument.body.appendChild(template(map));\n```\n\n## Binding to a selected value\n\nMore often than binding to boolean values of each radio's `checked` value, you will want to know what the `value` is of the radio group. Since each radio has it's own `value`, the radio's selected value is the value of the radio item that is selected.\n\nUsing the [can-stache.registerConverter converter] [can-stache-converters.equal] you can bind a value within your scope to the radio group's selected value:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-radio.html'></div>\n\n",
    "description": "\nCross bind a value to a radio input.\n",
    "name": "can-stache-converters.pages.input-radio",
    "title": "input[type=radio]",
    "type": "page",
    "parent": "can-stache-converters.pages",
    "comment": " "
  },
  "can-stache-converters.pages.select": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/select.md"
    },
    "body": "\n\n## Use\n\nThe following cross bind's a `<select>` to a `person` map's `attending` property:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/select.html'></div>\n\n",
    "description": "\nCross bind a value to a `<select>` element.\n",
    "title": "select ",
    "name": "can-stache-converters.pages.select",
    "type": "function",
    "parent": "can-stache-converters.pages",
    "signatures": [
      {
        "code": "{($value)}=\"KEY\"",
        "description": "\n\nCross binds the selected option value with an observable value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY` should specify either a [can-map]/[can-define/map/map] property or a [can-compute.computed].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "KEY",
      "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY` should specify either a [can-map]/[can-define/map/map] property or a [can-compute.computed].\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages-select-multiple": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/select-multiple.md"
    },
    "body": "\n\n## Use\n\nSelect elements with the multiple attribute (`<select multiple {($values)}=\"KEY\"/>`)\nhave a specified behavior if the value of KEY is Array like, or \nundefined.\n\n## Cross binding to Arrays\n\n`<select>` tags with a multiple attribute cross bind\na [can-map] property, [can-compute.computed] or [can-list]\nin sync with the selected items of the `<select>` element.\n\nFor example, the following template:\n\n    <select multiple {($values)}=\"colors\">\n      <option value='red'>Red</option>\n      <option value='green'>Green</option>\n      <option value='yellow'>Yellow</option>\n    </select>\n\nCould be rendered with one of the following:\n\n    // A can-map property\n    new DefineMap({colors: []})\n\n    // A compute\n    { colors: compute([]) }\n\n    // A DefineList\n    { colors: new DefineList() }\n    \n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/multi-values.html'></div>\n\n",
    "description": "\nCross bind a value to a `<select>` element with multiple selections permitted.\n",
    "title": "select[multiple]",
    "name": "can-stache-converters.pages-select-multiple",
    "type": "function",
    "parent": "can-stache-converters.pages",
    "signatures": [
      {
        "code": "<select multiple {($values)}=\"KEY\"/>",
        "description": "\n\nCross binds the selected option values with an observable value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can.stache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY`'s value should be an Array-like,\nor `undefined`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can.stache.key"
        }
      ],
      "name": "KEY",
      "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY`'s value should be an Array-like,\nor `undefined`.\n"
    },
    "comment": " "
  },
  "can-stache-converters.string-to-any": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/string-to-any.md"
    },
    "body": "\n## Use\n\nThis is usually used with `<select>`s where you would like to two-way bind a string to a primitive value.\n\n```handlebars\n<select {($value)}=\"string-to-any(~someValue)\">\n  <option value=\"2\">Number</option>\n  <option value=\"null\">Null</option>\n  <option value=\"foo\">String</option>\n  <option value=\"true\">Boolean</option>\n  <option value=\"NaN\">NaN</option>\n  <option value=\"Infinity\">Infinity</option>\n</select>\n```\n\n```js\nvar str = document.getElementById('select-template').innerHTML;\nvar template = stache(str);\n\nvar map = new DefineMap({\n\tsomeValue: \"foo\"\n});\n\ndocument.body.appendChild(template(map));\n\nmap.item = NaN; // select.value becomes \"NaN\"\n\n// Click the select box and choose Boolean\nmap.item === true; // -> true\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that binds a value to a primitive value, two way converted back to that primitive value when the attribute changes. \n",
    "title": "string-to-any",
    "name": "can-stache-converters.string-to-any",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "string-to-any(~item)",
        "description": "\n\nWhen the getter is called, gets the value of the compute and calls `.toString()` on that value.\n\nWhen the setter is called, takes the new value and converts it to the primitive value using [can-util/js/string-to-any/string-to-any] and sets the compute using that converted value.\n\n```handlebars\n<select {($value)}=\"string-to-any(~favePlayer)\">\n  <option value=\"23\">Michael Jordan</option>\n\t<option value=\"32\">Magic Johnson</option>\n</select>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "item",
            "description": "A compute holding a primitive value."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element's value changes.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "item",
      "description": "A compute holding a primitive value."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element's value changes.\n"
    },
    "comment": " "
  },
  "can-stache-converters.not": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/not.md"
    },
    "body": "\n## Use\n\nUse this converter to two-way bind to the negation of some value. For example:\n\n```handlebars\n<input type=\"checkbox\" {($checked)}=\"not(~val)\" />\n```\n\n```js\nvar map = new DefineMap({\n\tval: true\n});\n\ndocument.body.appendChild(template(map));\n\nvar input = document.querySelector('input');\n\ninput.checked; // -> false\n\nmap.val = false;\n\ninput.checked; // -> true\n\n// Now if you click the checkbox\nmap.val === true; // because the checkbox is now false.\n```\n\n### Combined with other converters\n\n`not()` can be useful when used in combination with other converters that deal with boolean conversion. [can-stache-converters.boolean-to-inList] determines if an item is in a list. Here we wrap `not()` around this conversion so that the inverse is what is saved in the map's value:\n\n```handlebars\n<input type=\"checkbox\" {($checked)}=\"not(~boolean-to-inList(item, list))\" />\n```\n\n```js\nvar map = new DefineMap({\n\titem: 2,\n\tlist: new DefineList([ 1, 2, 3 ])\n});\n\ndocument.body.appendChild(template(map));\nvar input = document.querySelector('input');\n\n\ninput.checked; // -> false\n\n// Set `item` to a value not in the list\nmap.item = 4;\n\ninput.checked; // -> true\n\n// Check the input, whick will set it's value to `false`\n// This will be converted to `true` by not() and pushed into the list\n\nmap.list.indexOf(4); // -> 3\n\n// Remove it from the list, which will be converted to true by not()\nmap.list.splice(3, 1);\n\ninput.checked; // -> true\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that two-way binds the negation of a value. \n",
    "title": "not",
    "name": "can-stache-converters.not",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "not(~value)",
        "description": "\n\nWhen the getter is called, gets the value of the compute and returns the negation.\n\nWhen the setter is called, sets the compute's value to the negation of the new value derived from the element.\n\n*Note* that `not` needs a compute so that it can update the scope's value when the setter is called.\n\n```handlebars\n<input type=\"checkbox\" {($checked)}=\"not(~val)\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "value",
            "description": "A value stored in a [can-compute]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound by [can-stache-bindings] as a getter/setter on the element.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "value",
      "description": "A value stored in a [can-compute]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be two-way bound by [can-stache-bindings] as a getter/setter on the element.\n"
    },
    "comment": " "
  },
  "can.stache.Lookup": {
    "src": {
      "line": 21,
      "codeLine": 28,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "type": "typedef",
    "body": "",
    "description": "",
    "hide": true,
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "types": [
              {
                "type": "String"
              }
            ],
            "description": "A value in the scope to look up.\n"
          }
        ]
      }
    ],
    "name": "can.stache.Lookup"
  },
  "makeEvaluator": {
    "type": "function",
    "name": "makeEvaluator",
    "params": [
      {
        "name": "scope",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "helperOptions",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "nodeList",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": "Either null, #, ^. > is handled elsewhere"
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "exprData",
        "description": "Data about what was in the mustache expression"
      },
      {
        "types": [
          {
            "type": "renderer"
          }
        ],
        "optional": true,
        "name": "truthyRenderer",
        "description": "Used to render a subsection"
      },
      {
        "types": [
          {
            "type": "renderer"
          }
        ],
        "optional": true,
        "name": "falseyRenderer",
        "description": "Used to render the inverse subsection"
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "optional": true,
        "name": "stringOnly",
        "description": "A flag to indicate that only strings will be returned by subsections."
      },
      {
        "types": [
          {
            "type": "can.view.Options"
          }
        ],
        "name": "The",
        "description": "option helpers in which the expression is evaluated."
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 43,
      "codeLine": 55,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Given a mode and expresion data, returns a function that evaluates that expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "stringOnly",
      "description": "A flag to indicate that only strings will be returned by subsections."
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "An 'evaluator' function that evaluates the expression.\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "An 'evaluator' function that evaluates the expression.\n "
    }
  },
  "makeLiveBindingPartialRenderer": {
    "type": "function",
    "name": "makeLiveBindingPartialRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "expressionString",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The html state of where the expression was found."
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 165,
      "codeLine": 173,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns a renderer function that live binds a partial.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The html state of where the expression was found."
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            }
          ],
          "context": {
            "types": [
              {
                "type": "HTMLElement"
              }
            ]
          }
        }
      ],
      "description": "A renderer function\nlive binds a partial.\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            }
          ],
          "context": {
            "types": [
              {
                "type": "HTMLElement"
              }
            ]
          }
        }
      ],
      "description": "A renderer function\nlive binds a partial.\n "
    }
  },
  "makeStringBranchRenderer": {
    "type": "function",
    "name": "makeStringBranchRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": ""
      },
      {
        "name": "expressionString",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 243,
      "codeLine": 250,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Return a renderer function that evaluates to a string.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "can.stache.Expression"
        }
      ],
      "name": "expression",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can.view.Scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-stache.renderer"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.renderer"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can.view.Scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-stache.renderer"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.renderer"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "makeLiveBindingBranchRenderer": {
    "type": "function",
    "name": "makeLiveBindingBranchRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": ""
      },
      {
        "name": "expressionString",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The html state of where the expression was found.\n "
      },
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 284,
      "codeLine": 291,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns a renderer function that evaluates the mustache expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The html state of where the expression was found.\n "
    }
  },
  "splitModeFromExpression": {
    "type": "function",
    "name": "splitModeFromExpression",
    "params": [
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The state of HTML where the expression was found.\n "
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 386,
      "codeLine": 392,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns the mustache mode split from the rest of the expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The state of HTML where the expression was found.\n "
    }
  },
  "cleanLineEndings": {
    "type": "function",
    "name": "cleanLineEndings",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "template",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 412,
      "codeLine": 418,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Prunes line breaks accoding to the mustache specification.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "template",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    }
  },
  "Options": {
    "name": "Options",
    "type": "property",
    "parent": "node_modules/can-stache/src/utils.js",
    "src": {
      "line": 10,
      "codeLine": 14,
      "path": "node_modules/can-stache/src/utils.js"
    },
    "body": " \n",
    "description": "The Options scope.\n",
    "hide": true
  },
  "can-stache.Acquisition": {
    "src": {
      "path": "node_modules/can-stache/docs/acquisition.md"
    },
    "body": "\n## Raw Text\n\nRaw text can be templated by passing the text containing your template.  For example:\n\n\tvar text = \"My body lies over the {{.}}\",\n\t\ttemplate = stache(text),\n\t\tfragment = template(\"ocean\");\n\n\tdocument.body.appendChild(fragment);\n\n## Module Loaders\n\nFor [http://stealjs.com StealJS], use [steal-stache] to import stache templates directly.\n\n\n## Script Tags\n\nYou can embed a `<script>` tag and use its text as a stache template like:\n\n```html\n<script type='text/stache' id='my-template'>\n  <h1>{{message}}</h1>\n</script>\n```\n\nLoad this template like:\n\n```js\nvar stache = require(\"can-stache\");\nvar text = document.getElementById(\"my-template\");\nvar template = stache(text);\n```\n\n",
    "description": "\nThere are number of ways to acquire templates such as: raw text,\na module loader, or script tags in the markup.\n",
    "name": "can-stache.Acquisition",
    "title": "Template Acquisition",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 3
  },
  "can-stache.helper": {
    "src": {
      "path": "node_modules/can-stache/docs/helper.md"
    },
    "body": "\n\n## Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create stache tags that have rich behavior.\n\nIf the helper is called __within a tag__ like:\n\n    <ul {{sortable}}/>\n\nThe returned function is called with the `<ul>` element:\n\n    stache.registerHelper(\"sortable\",function(){\n      return function(el){\n        $(el).slider();\n      }\n    });\n\nIf the helper is called __between tags__ like:\n\n    <ul>{{items}}</ul>\n\nThe returned function is called with a temporary text node:\n\n    stache.registerHelper(\"items\",function(){\n      return function(textNode){\n\t\t  // do something, probably replace textNode\n      }\n    });\n\nWhile this form of helper is still supported, it's more common\nto create similar functionality with [can-component] or [can-view-callbacks].\n\n",
    "description": "A helper function passed to [can-stache.registerHelper]. \nGiven the arguments, returns the content that should be shown in the DOM\nor a function that will be called on the DOM element the helper was\ncalled on.\n\n",
    "type": "typedef",
    "title": "helper",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            },
            {
              "type": "String"
            },
            {
              "type": "Array"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "Node"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The content to be inserted into the template or a callback function.  The content can be a:\n\n - `documentFragment` like those returned by [can-stache.helperOptions].fn.\n - `String` like `\"Hello World\"`\n - `Array` of strings and nodes like `[\"Hello\", document.createElement('div')]`\n\nIf a `function(Node)` is returned, it will be called back with an HTML Element or text node.  \n\nIf the helper is called on an element like:\n\n```\n<div {{myHelper}}>\n```\n\n... the callback function will be called with the `div`.  \n\nIf the helper is called\noutside of an element's tag like:\n\n```\n<div> {{myHelper}} </div>\n```\n\n... the callback function will be called with a placeholder text node.  \n\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-compute"
              }
            ],
            "optional": true,
            "variable": true,
            "name": "arg",
            "description": "Arguments passed from the tag. After the helper\nname, any space separated [can-stache.key keys], numbers or\nstrings are passed as arguments. [can-stache.key Keys] that\nread an observable value in [can-stache/expressions/helper helpers] are passed as [can-compute.computed]s .\n"
          },
          {
            "types": [
              {
                "type": "can-stache.helperOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "An options object\nthat is an additional argument in `Helper` expressions that is populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "can-stache.context"
            }
          ],
          "description": "The context the helper was\ncalled within.\n"
        }
      }
    ],
    "name": "can-stache.helper",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helperOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "An options object\nthat is an additional argument in `Helper` expressions that is populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        },
        {
          "type": "String"
        },
        {
          "type": "Array"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "description": "The content to be inserted into the template or a callback function.  The content can be a:\n\n - `documentFragment` like those returned by [can-stache.helperOptions].fn.\n - `String` like `\"Hello World\"`\n - `Array` of strings and nodes like `[\"Hello\", document.createElement('div')]`\n\nIf a `function(Node)` is returned, it will be called back with an HTML Element or text node.  \n\nIf the helper is called on an element like:\n\n```\n<div {{myHelper}}>\n```\n\n... the callback function will be called with the `div`.  \n\nIf the helper is called\noutside of an element's tag like:\n\n```\n<div> {{myHelper}} </div>\n```\n\n... the callback function will be called with a placeholder text node.  \n\n"
    },
    "comment": " "
  },
  "can-stache.from": {
    "src": {
      "path": "node_modules/can-stache/docs/from.md"
    },
    "body": "\n",
    "description": "Return a template loaded from an element. \n",
    "title": "from",
    "name": "can-stache.from",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.from(id)",
        "description": "\n\nLoad a template from an HTML element (usually a `<script>` element)\nspecified by id.  This is used typically for demo purposes.\n\nFor example, with a `<script>` tag as follows in your HTML:\n\n```\n<script type='text/stache' id='my-template'>\n<h1>{{message}}</h1>\n</script>\n```\n\nLoad and render that template like:\n\n```\nvar template = stache.from(\"my-template\");\ntemplate({message: \"Hello There!\"});\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "id",
            "description": "The id of the element, whose `innerHTML` will be used to create a template."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A renderer function that will render the\ntemplate.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "id",
      "description": "The id of the element, whose `innerHTML` will be used to create a template."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A renderer function that will render the\ntemplate.\n"
    },
    "comment": " "
  },
  "can-stache.scopeAndContext": {
    "src": {
      "path": "node_modules/can-stache/docs/context.md"
    },
    "body": "\nEvery part of a stache template is rendered with a\ngiven [can-view-scope scope]. The scope is used to lookup\nvalues. A scope can contain multiple places to lookup values. Each of those\nplaces is called a `context`.  \n\nThis is very similar to how `last` is looked up in the following JavaScript:\n\n```js\nvar message = \"Hello\"\nfunction outer(){\n\tvar last = \"Abril\";\n\n\tfunction inner(){\n\t\tvar first = \"Alexis\";\n\t\tconsole.log(message + \" \"+ first + \" \" + last);\n\t}\n\tinner();\n}\nouter();\n```\n\nJavaScript looks for `last` looks in the `inner` context and then walks up the\nscope to the `outer` context to find a `last` variable.\n\n\nLets look at what happens with the scope the following example:\n\n```\nTemplate:\n\t<h1>{{message}} {{#person}}{{first}} {{last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\"},\n\t  last: \"Abril\",\n\t  message: \"Hello\" }\n\nResult:\n\t<h1>Hello Alexis Abril</h1>\n```\n\n1. The template is rendered with `Data` as the only item in the scope. `scope:[Data]`\n2. `{{message}}` is looked up within `Data`.\n3. `{{#person}}` adds the `person` context to the top of the scope. `scope:[Data,Data.person]`\n4. `{{first}}` is looked up in the scope.  It will be found on `Data.person`.\n5. `{{last}}` is looked up in the scope.  \n   1. `last` is looked in `Data.person`, it's not found.\n   2. `last` is looked up in `Data` and returned.\n6. `{{/person}}` removes `person` from the scope. `scope:[Data]`\n\n\n\nThe context used to lookup a value can be controlled with adding `../` or `./` before a\nkey. For instance, if we wanted to make sure `last` was only going to lookup on `person`,\nwe could change the template to:\n\n```\nTemplate:\n\t<h1>{{message}} {{#person}}{{first}}  {{./last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\"},\n\t  last: \"Abril\",\n\t  message: \"Hello\" }\n\nResult:\n\t<h1>Hello Alexis </h1>\n```\n\n[can-stache.tags.section Sections], [can-stache.Helpers Helpers],\nand [can-component custom elements] can modify the scope used to render a subsection.\n\n[can-stache.key] modifiers  like `../` and `@key` can control the context and value that\ngets returned.\n\n",
    "description": "\n",
    "name": "can-stache.scopeAndContext",
    "title": "Scope and Context",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 1,
    "comment": " "
  },
  "can-stache.getterSetter": {
    "src": {
      "path": "node_modules/can-stache/docs/getterSetter.md"
    },
    "body": "\n",
    "description": "The getterSetter argument passed to [can-stache.registerConverter registerConverter]. \n",
    "type": "typedef",
    "title": "getterSetter",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "description": "Takes the arguments from a [can-stache/expressions/call]\nand returns a value.\n\nAn argument is a compute if the argument has been marked with a tilde (`~`) prefix, otherwise the\nvalue of the argument is the same as the value of the corresponding scope property.\nAt least one argument should be a compute so `set` can update the value.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "args",
                    "variable": true
                  }
                ]
              }
            ]
          },
          {
            "name": "set",
            "description": "Takes the new value of the `left` side of a\n[can-stache-bindings.twoWay {(two-way)} binding] followed by the other arguments to the\n[can-stache/expressions/call].  This should change one of the compute arguments.\n\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "setValue"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "args",
                    "variable": true
                  }
                ]
              }
            ]
          }
        ],
        "description": "\n\nAn object with a `get` and `set` method that get converted to a two-way helper.\n\n```js\nstache.registerConverter(\"numberToString\", {\n get: function(fooCompute) {\n \treturn \"\" + fooCompute();\n },\n set: function(newVal, fooCompute) {\n \tfooCompute(+newVal);\n }\n});\n```\n\n\nA `getterSetter` object provides:\n\n - A `get` method that returns the value\n  of the `left` value given the arguments passed on the `right`.\n - a `set` method that updates one or multiple of the `right` arguments\n   computes given a new `left` value.\n"
      }
    ],
    "name": "can-stache.getterSetter",
    "parent": "can-stache.types",
    "comment": " "
  },
  "can-stache.Binding": {
    "src": {
      "path": "node_modules/can-stache/docs/livebinding.md"
    },
    "body": "\nLive binding lets you focus on changing data and state without having to worry about also updating the\nDOM to reflect those changes.\n\nIn this example, we have a simple user welcome screen.\n\n\t<h1>Welcome {{user}}!</h1>\n\t<p>\n\t\t{{#if messages}}\n\t\t\tYou have {{messages}} new messages.\n\t\t{{else}}\n\t\t\tYou no messages.\n\t\t{{/messages}}\n\t</p>\n\n\tvar data = new DefineMap({\n\t\tuser: 'Tina Fey',\n\t\tmessages: 0\n\t});\n\n\tvar template = stache( document.getElementById(\"template\").innerHTML );\n\tvar frag = template( data );\n\tdocument.body.appendChild( frag );\n\n\nThe template evaluates the `messages` and adds the hooks for live binding automatically.\nSince we have no message it will render:\n\n\t<h1>Welcome Tina Fey!</h1>\n\t<p>You no messages.</p>\n\nNow say we have a request that updates\nthe `messages` attribute to have `5` messages.\n\n\tdata.message = 5;\n\n\nAfter the template receives this update, it will automatically\nupdate the paragraph tag to reflect the new value.\n\n\t<p>You have 5 new message.</p>\n\n\nFor more information visit the [can-define/map/map] documentation.\n\n### Binding between components\n\nIf you are looking for information on bindings between components like this:\n```\n(event)=\"key()\" for event binding.\n{prop}=\"key\" for one-way binding to a child.\n{^prop}=\"key\" for one-way binding to a parent.\n{(prop)}=\"key\" for two-way binding.\n```\nSee [can-stache-bindings].\n\n",
    "description": "\nLive binding refers to templates which update themselves when their state or data changes.\n[can-stache] templates are able to listen to observables\n(like [can-define/map/map], [can-define/list/list], and [can-compute]) changing and update the page\nto reflect those changes.\n",
    "name": "can-stache.Binding",
    "title": "Live Binding",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 5
  },
  "can-stache.helperOptions": {
    "src": {
      "path": "node_modules/can-stache/docs/helperOptions.md"
    },
    "body": "",
    "description": "The options argument passed to a [can-stache.helper helper function] when called by a [can-stache/expressions/helper].\n\n",
    "type": "typedef",
    "title": "helperOptions",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "fn",
            "description": "Renders the \"truthy\" subsection\nBLOCK.  `options.fn` is only available if the helper is called as a\n[can-stache.tags.section] or [can-stache.tags.inverse]. Read about\n[can-stache.sectionRenderer section renderer] for more information.\n",
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true
          },
          {
            "name": "inverse",
            "description": "Renders the \"falsey\" subsection\nINVERSE.  `options.inverse` is only available if the helper is called as a\n[can-stache.tags.section] or [can-stache.tags.inverse] and [can-stache.helpers.else]\nis used. Read about\n[can-stache.sectionRenderer section renderer] for more information.\n",
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true
          },
          {
            "name": "hash",
            "description": "An object containing all of the\n[can-stache.expressions Hash expression] keys and values. For example:\n\n```\n{{helper arg1 arg2 name=value other=3 position=\"top\"}}\n```\n\nmight provide a `hash` like:\n\n```\n{\n\t\tname: compute(\"Mr. Pig\"),\n\t\tother: 3,\n\t\tposition: \"top\"\n}\n```\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "context",
            "description": "The current context the stache helper is called within. Read\n[can-stache.scopeAndContext] for more information.\n\n",
            "types": [
              {
                "type": "*"
              }
            ]
          },
          {
            "name": "scope",
            "description": "An object that represents the current context and all parent\ncontexts. It can be used to look up [can-stache.key key] values in the current scope.\nRead [can-stache.scopeAndContext] and [can-view-scope] for more information.\n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "It can be used to look up [can-stache.key key] values in the current options scope.\nRead [can-stache.scopeAndContext] and [can-view-scope.Options] for more information.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          }
        ],
        "description": "\n\nWhen a [can-stache.helper helper function]\nis called by a [can-stache/expressions/helper], a `helperOptions`\nobject is passed with the following properties:\n\n```\nstache.registerHelper(\"myHelper\", function(helperOptions){\n  helperOptions.fn      //-> sectionRenderer(){}\n  helperOptions.inverse //-> sectionRenderer(){}\n  helperOptions.hash    //-> Object\n  helperOptions.context //-> *\n  helperOptions.scope   //-> Scope\n  helperOptions.option  //-> Scope.Options\n});\n```\n"
      }
    ],
    "name": "can-stache.helperOptions",
    "parent": "can-stache.types"
  },
  "can-stache.Helpers": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers.md"
    },
    "body": "\nExample custom helpers might include:\n\n - Converting a raw `Date` to a more user friendly timestamp. `{{timestamp birthday}}`\n - Internationalization. `{{i18n 'Hello'}}`\n - Convert markdown into HTML. `{{markdown(comment)}}`\n\nStache includes a number of built-in helpers, but custom helpers can be registered as well.\n\n## Built-in Helpers\n\nThe `[can-stache.tags.section {{#if key}}]` helper is used for **if** statements. The **if** helper is similar\nto using a `[can-stache.tags.section {{#key}}]` section. If they key passed to the helper is **truthy**, the\nsection will be rendered.\n\n\tTemplate:\n\t\t{{#if friends}}\n\t\t\tI have friends!\n\t\t{{/if}}\n\n\tData:\n\t\t{\n\t\t\tfriends: true\n\t\t}\n\n\tResult:\n\t\tI have friends!\n\nWhen using the `[can-stache.helpers.if {{#if key}}]` helper, or any other helper for that matter,\nthe special `[can-stache.helpers.else {{else}}]` helper is available. `{{else}}` is equivalent to\nan [can-stache.tags.inverse {{^key}}] inverse section (renders if given **falsey** data), except that it\nonly uses a single tag and exists inside a helper section.\n\n\tTemplate:\n\t\t<ul>\n\t\t\t{{#if friends}}\n\t\t\t\t</li>{{name}}</li>\n\t\t\t{{else}}\n\t\t\t\t<li>No friends.</li>\n\t\t\t{{/if}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tfriends: false\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>No friends.</li>\n\t\t</ul>\n\nThe `[can-stache.helpers.unless {{#unless key}}]` helper is equivalent to using a\n`[can-stache.tags.inverse {{^key}}]` inverse section. If they key passed to the helper is **falsey**, the\nsection will be rendered.\n\n\tTemplate:\n\t\t{{#unless friends}}\n\t\t\tYou don't have any friends!\n\t\t{{/unless}}\n\n\tData:\n\t\t{\n\t\t\tfriends: []\n\t\t}\n\n\tResult:\n\t\tYou don't have any friends!\n\nThe `[can-stache.helpers.each {{#each key}}]` helper is similar to using a\n`[can-stache.tags.section {{#key}}]` section for iterating an array. In this case, the entire array\nwill be rendered using the inner text item by item.\n\n\tTemplate:\n\t\t<ul>\n\t\t\t{{#each friends}}\n\t\t\t\t<li>{{name}}</li>\n\t\t\t{{/each}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tfriends: [\n\t\t\t\t{ name: \"Austin\" },\n\t\t\t\t{ name: \"Justin\" }\n\t\t\t]\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>Austin</li>\n\t\t\t<li>Justin</li>\n\t\t</ul>\n\nThe `[can-stache.helpers.with {{#with key}}]` helper is equivalent to using a\n`[can-stache.tags.section {{#key}}]` section for regular objects. The helper will change\nthe current context so that all tags inside will look for keys on the local context first.\n\n\tTemplate:\n\t\t<h1>Hi {{name}}</h1>\n\t\t{{#with friend}}\n\t\t\t<p>You have a new friend: {{name}}</p>\n\t\t{{/with}}\n\n\tData:\n\t\t{\n\t\t\tname: \"Andy\",\n\t\t\tfriend: { name: \"Justin\" }\n\t\t}\n\n\tResult:\n\t\t<h1>Hi Austin</h1>\n\t\t<p>You have a new friend: Justin</p>\n\nWhen using the `[can-stache.helpers.is {{#is key1 key2}}]` helper you can simply compare\nkey1 and key2. If the result of comparsion is **truthy**, the section will be rendered.\n\n\tTemplate:\n\t\t<ul>\n\t\t{{#is name 'Alex'}}\n\t\t\t</li>Your name is {{name}}</li>\n\t\t{{else}}\n\t\t\t<li>Your name is not Alex!</li>\n\t\t{{/is}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tname: 'John'\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>Your name is not Alex!</li>\n\t\t</ul>\n\n## Registering Helpers\n\nYou can register your own global helper with the `[can-stache.registerSimpleHelper registerSimpleHelper]`\n`[can-stache.registerHelper registerHelper]` or\n methods.\n\n`[can-stache.registerSimpleHelper registerSimpleHelper]` calls the registered helper function with\nvalues, while `[can-stache.registerHelper registerHelper]` calls the registered helper function with\n[can-compute.computed computes] if observable data is passed. `registerSimpleHelper` is\neasiser to use for basic helper functionality.\n\n\nLocalization is a good example of a custom helper you might implement\nin your application. The below example takes a given key and\nreturns the localized value using\n[jQuery Globalize](https://github.com/jquery/globalize).\n\n\tstache.registerSimpleHelper('l10n', function(str, options){\n\t\treturn Globalize != undefined\n\t\t\t? Globalize.localize(str)\n\t\t\t: str;\n\t});\n\n\nIn the template, invoke the helper by calling the helper\nname followed by any additional arguments.\n\n\tTemplate:\n\t\t<span>{{l10n 'mystring'}}</span>\n\n\tResult:\n\t\t<span>my string localized</span>\n\n### Helper Arguments\n\nThe type of arguments passed to a `registerHelper` function depends on how the helper was called and the values\npassed to the helper. In short, observables will be passed as [can-compute.computed compute] arguments\nin helper expressions.  In any other circumstance,  values will be passed.\n\nHelpers can be called as either a [can-stache.expressions Call or Helper Expression]:\n\n - Call expression - `{{myHelper(firstValue, secondValue)}}`\n - Helper expression - `{{myHelper firstValue secondValue}}`\n\nHelpers can also be called with observable values or non-observable values.\n\nConsidering a helper like:\n\n```js\nstache.registerHelper(\"myHelper\", function(value){ ... })\n```\n\nThe following details what `value` is depending on how the helper is called\nand the data passed.\n\n#### Call expression with non-observable data\n\n\tData:\n\t\t{ name: 'John' }\n\n\tTemplate:\n\t\t{{ myHelper(name) }}\n\n\tvalue:\n\t\t'John'\n\n#### Call expression with observable data\n\n\tData:\n\t\tnew DefineMap({ name: 'John' })\n\n\tTemplate:\n\t\t{{ myHelper(name) }}\n\n\tvalue:\n\t\t'John'\n\n#### Helper expression with non-observable data\n\n\tData:\n\t\t{ name: 'John' }\n\n\tTemplate:\n\t\t{{ myHelper name }}\n\n\tvalue:\n\t\t'John'\t    \n\n#### Helper expression with observable data\n\n\tData:\n\t\tnew DefineMap({ name: 'John' })\n\n\tTemplate:\n\t\t{{ myHelper name }}\n\n\tvalue:\n\t\tcompute('John')\n\n\n### Evaluating Helpers\n\nIf you want to use a helper with a [can-stache.tags.section] tag, you need to call\n`options.fn(context)` in your return statement. This will return a\ndocument fragment or string with the resulting evaluated subsection.\n\nSimilarly, you can call `options.inverse(context)` to evaluate the\ntemplate between an `{{else}}` tag and the closing tag.\n\nFor example, when a route matches the string passed to our\nrouting helper it will show/hide the text.\n\n\tstache.registerHelper('routing', function(str, options){\n\t\tif (route.attr('filter') === str)\n\t\t\treturn options.fn(this);\n\t\t}\n\t});\n\n\t{{#routing 'advanced'}}\n\t\tYou have applied the advanced filter.\n\t{{/routing}}\n\n__Advanced Helpers__\n\nHelpers can be passed normal objects, native objects like numbers and strings,\nas well as a hash object. The hash object will be an object literal containing\nall ending arguments using the `key=value` syntax. The hash object will be provided\nto the helper as `options.hash`. Additionally, when using [can-stache.tags.section] tags with a helper,\nyou can set a custom context by passing the object instead of `this`.\n\n\tstache.registerHelper('exercise', function(group, action,\n\t\t\t\t\t\t\t\t\t\t\tnum, options){\n\t\tif (group && group.length > 0 && action && num > 0) {\n\t\t\treturn options.fn({\n\t\t\t\tgroup: group,\n\t\t\t\taction: action,\n\t\t\t\twhere: options.hash.where,\n\t\t\t\twhen: options.hash.when,\n\t\t\t\tnum: num\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\treturn options.inverse(this);\n\t\t}\n\t});\n\n\t{{#exercise pets 'walked' 3 where='around the block' when=time}}\n\t\tAlong with the {{#group}}{{.}}, {{/group}}\n\t\twe {{action}} {{where}} {{num}} times {{when}}.\n\t{{else}}\n\t\tWe were lazy today.\n\t{{/exercise}}\n\n\t{\n\t\tpets: ['cat', 'dog', 'parrot'],\n\t\ttime: 'this morning'\n\t}\n\nThis would output:\n\n\tAlong with the cat, dog, parrot, we walked around the block\n\t3 times this morning.\n\nWhereas an empty data object would output:\n\n\tWe were lazy today.\n\n",
    "description": "\nHelpers are functions that can be registered and called from within templates.  These functions\nare typically used to provide functionality that is more appropriate for\nthe `view` than the `viewModel`.\n",
    "name": "can-stache.Helpers",
    "title": "Helpers",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 4
  },
  "can-stache.magicTagTypes": {
    "src": {
      "path": "node_modules/can-stache/docs/magicTagTypes.md"
    },
    "body": "\nRendering behavior is controlled with magic tags that look like `{{}}`.  There\nare two main forms of magic tags:\n\n - Insertion tags - insert their value into the result like `{{expression}}` and `{{{expression}}}`.\n - Section tags - optional render a sub-section like `{{#expression}} ... {{/expression}}`.\n\nLets see the general behavior of each tag type:\n\n### Insertion Tags\n\nInsertion tags render a value into result.\n\n#### [can-stache.tags.escaped]\n\nInserts the escaped value of `expression` into the result. This is your most common tag.\n\n```\nTemplate:\n\t<div>{{name}}</div>\n\nData:\n\t{ name: \"<b>Justin</b>\" }\n\nResult:\n\t<div>&lt;b&gt;Justin&lt;/b&gt;</div>\n```\n\n#### [can-stache.tags.unescaped]\n\nInserts the unescaped value of `expression` into the result.\n\n```\nTemplate:\n\t<div>{{{name}}}</div>\n\nData:\n\t{ name: \"<b>Justin</b>\" }\n\nResult:\n\t<div><b>Justin</b></div>\n```\n\n#### [can-stache.tags.partial]\n\nRenders another template with the same context as the current context.\n\n```\nvar template = stache(\"<h1>{{>title}}</h1>\");\n\n\nvar frag = template(\n\t{message: \"Hello\"},\n\t{\n\t\tpartials: { title: \tstache(\"<blink>{{message}}</blink>”) }\n\t});\n\n\tfrag //-> <h1><blink>Hello</blink></h1>\n```\n\nOther ways to load and reference partials are discussed [can-stache.tags.partial here].\n\n#### [can-stache.tags.comment]\n\nIgnores the magic tag.\n\n```\nTemplate:\n\t<h1>{{!message}}</h1>\n\nData:\n\t{ message: \"<blink>Hello</blink>\" };\n\nResult:\n\t<h1></h1>\n```\n\n### Section Tags\n\nSection tags are passed a subsection and an optional inverse subsection. They\noptionally render the subsections and insert them into the result.\n\n#### [can-stache.tags.section {{#expression}} ... {{/expression}}]\n\nRenders the subsection or inverse subsection depending on the value of expression.\n\nIf `expression` is truthy, renders the subsection:\n\n```\nTemplate:\n\t<h1>{{#shown}}Hello{{/shown}}</h1>\n\nData:\n\t{ shown: true };\n\nResult:\n\t<h1>Hello</h1>\n```\n\nThe subsection is rendered with the `expression` value as the top of the scope:\n\n```\nTemplate:\n\t<h1>{{#person}}Hello {{first}}  {{person.last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\", last: \"Abril\"} };\n\nResult:\n\t<h1>Hello Alexis Abril</h1>\n```\n\n\nIf `expression` is falsey, renders the inverse subsection if present:\n\n```\nTemplate:\n\t<h1>{{#shown}}Hello{{else}}Goodbye{{/shown}}</h1>\n\nData:\n\t{ shown: false };\n\nResult:\n\t<h1>Goodbye</h1>\n```\n\nIf `expression` is array-like and its `length` is greater than 0, the subsection\nis rendered with each item in the array as the top of the scope:\n\n```\nTemplate:\n\t<p>{{#items}}{{.}} {{/items}}</p>\n\nData:\n\t{items: [2,4,8,16]}\n\nResult:\n\t<p>2 4 8 16 </p>\n```\n\nIf `expression` is array-like and its `length` is 0, the inverse subsection\nis rendered:\n\n```\nTemplate:\n\t<p>{{#items}}{{.}} {{else}}No items{{/items}}</p>\n\nData:\n\t{items: []}\n\nResult:\n\t<p>No items</p>\n```\n\n#### [can-stache.tags.inverse {{^expression}} ... {{/expression}}]\n\nThe [can-stache.tags.inverse inverse] section does the opposite of the\nnormal [can-stache.tags.section] tag.  That is, it renders\nthe subsection when [can-stache.tags.section] would render the inverse subsection\nand it renders the inverse subsection when [can-stache.tags.section] would\nrender the subsection.\n\n```\nTemplate:\n\t<h1>{{^shown}}Hello{{/shown}}</h1>\n\nData:\n\t{ shown: false };\n\nResult:\n\t<h1>Hello</h1>\n```\n\n",
    "description": "\n",
    "name": "can-stache.magicTagTypes",
    "title": "Magic Tag Types",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 0,
    "comment": " "
  },
  "can-stache.registerConverter": {
    "src": {
      "path": "node_modules/can-stache/docs/registerConverter.md"
    },
    "body": "\n## Use\n\nThese helpers are useful for avoiding creating [can-define/map/map] getters and setters that do similar conversions on the view model.  Instead,\na converter can keep your viewModels more ignorant of the demands of the\nview.  Especially as the view's most common demand is that everything\nmust be converted to a string.\n\nThat being said, the following is a richer example of a converter,\nbut one that should probably be part of a view model.\n\n```handlebars\n<input {($value)}='fullName(~first, ~last)'/>\n```\n\nThe following might converts both ways `first` and `last` to `value`.\n\n```js\nvar canBatch = require(\"can-event/batch/batch\");\n\nstache.registerConverter(\"fullName\", {\n get: function(first, last) {\n \treturn first() + last();\n },\n set: function(newFullName, first, last) {\n\tcanBatch.start();\n\tvar parts = newFullName.split(\" \");\n\tfirst(parts[0]);\n\tlast(parts[1]);\n\tcanBatch.stop();\n }\n});\n```\n\n",
    "description": "Register a helper for bidirectional value conversion. \n",
    "title": "registerConverter",
    "name": "can-stache.registerConverter",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerConverter(converterName, getterSetter)",
        "description": "\n\nCreates a helper that can do two-way conversion between two\nvalues.  This is especially useful with\n[can-stache-bindings.twoWay {($two-way)} bindings] like:\n\n```handlebars\n<input {($value)}='numberToString(~age)'/>\n```\n\nA converter helper provides:\n\n - a `get` method that returns the value\n  of the `left` value given the arguments passed on the `right`.\n - a `set` method that updates one or multiple of the `right` arguments\n   computes given a new `left` value.\n\n`numberToString` might converts a number (`age`)\nto a string (`value`), and the string (`value`) to a number (`age`)\nas follows:\n\n\n```js\nstache.registerConverter(\"numberToString\", {\n get: function(fooCompute) {\n \treturn \"\" + fooCompute();\n },\n set: function(newVal, fooCompute) {\n \tfooCompute(+newVal);\n }\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "converterName",
            "description": "The name of the converter helper."
          },
          {
            "types": [
              {
                "type": "can-stache.getterSetter"
              }
            ],
            "name": "getterSetter",
            "description": "An object containing get() and set() functions.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.getterSetter"
        }
      ],
      "name": "getterSetter",
      "description": "An object containing get() and set() functions.\n"
    },
    "comment": " "
  },
  "can-stache.safeString": {
    "src": {
      "path": "node_modules/can-stache/docs/safeString.md"
    },
    "body": "\n## Use\n\nIf you write a helper that generates its own HTML, you will\nusually want to return a `stache.safeString.` In this case,\nyou will want to manually escape parameters with [can-util/js/string/string.esc].\n\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nstache.registerHelper('link', function(text, url) {\n  text = string.esc(text);\n  url  = string.esc(url);\n\n  var result = '<a href=\"' + url + '\">' + text + '</a>';\n  return stache.safeString(result);\n});\n```\n\n\nRendering:\n\n```\n<div>{{link \"Google\", \"http://google.com\"}}</div>\n```\n\nResults in:\n\n```\n<div><a href=\"http://google.com\">Google</a></div>\n```\n\nAs an anchor tag whereas if we would have just returned the result rather than a\n`stache.safeString` our template would have rendered a div with the escaped anchor tag.\n\n",
    "description": "Indicate that a string does not need to be escaped to be safely inserted into the page.\n\n",
    "title": "safeString",
    "name": "can-stache.safeString",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.safeString(str)",
        "description": "\n\nBy default, stache tries to prevent some common forms of [cross site scripting attacks](https://en.wikipedia.org/wiki/Cross-site_scripting) by escaping content passed\nto tags like [can-stache.tags.escaped] and the result of helpers.  However,\none will often need to create helpers that return HTML content that shouldn't be escaped.\n\n`stache.safeString` can be used to indicate that a returned string from a helper is safe:\n\n```js\nstache.registerHelper(\"myHelper\", function(){\n  return stache.safeString(\"<blink>Hello There!</blink>\");\n})\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "A string you don't want to become escaped."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A string flagged by `stache` as safe, which will\nnot become escaped, even if you use [can-stache.tags.escaped].\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "A string you don't want to become escaped."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A string flagged by `stache` as safe, which will\nnot become escaped, even if you use [can-stache.tags.escaped].\n"
    },
    "comment": " "
  },
  "can-stache.renderer": {
    "src": {
      "path": "node_modules/can-stache/docs/renderer.md"
    },
    "body": "\n",
    "description": "A function returned by [can-stache] that renders a template into an html documentFragment.\n\n",
    "type": "typedef",
    "title": "renderer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "helpers"
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList"
          }
        ]
      }
    ],
    "name": "can-stache.renderer",
    "parent": "can-stache.types",
    "signatures": [
      {
        "code": "renderer(data, [helpers], [nodeList])",
        "description": "\n\n  A \"renderer\" function is a function returned by templates that can be used\n  to render data into a documentFragment.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "An object of data used to render the template.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "helpers",
            "description": "Local helper functions used by the template.\n"
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "optional": true,
            "name": "nodeList",
            "description": "Local helper functions used by the template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ],
          "description": "A documentFragment that contains the HTML rendered by the template.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "optional": true,
      "name": "nodeList",
      "description": "Local helper functions used by the template.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        }
      ],
      "description": "A documentFragment that contains the HTML rendered by the template.\n"
    },
    "comment": " "
  },
  "can-stache.registerPartial": {
    "src": {
      "path": "node_modules/can-stache/docs/registerParital.md"
    },
    "body": "\n",
    "description": "Register a partial. \nRegister a partial template that can be rendered with [can-stache.tags.partial].\n\n",
    "title": "registerPartial",
    "name": "can-stache.registerPartial",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerPartial(name, template)",
        "description": "\n\nRegisters a template so it can be rendered with `{{>name}}`.\n\n```js\nstache.registerHelper(\"item.stache\", \"<li>{{name}}</li>\");\n\nvar itemsTemplate = stache(\"{{#each items}}{{>item.stache}}{{/each}}\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the partial."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "can-stache.renderer"
              }
            ],
            "name": "template",
            "description": "The string of a stache template or the\nreturned result of a stache template.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "can-stache.renderer"
        }
      ],
      "name": "template",
      "description": "The string of a stache template or the\nreturned result of a stache template.\n"
    },
    "comment": " "
  },
  "can-stache.sectionRenderer": {
    "src": {
      "path": "node_modules/can-stache/docs/sectionRenderer.md"
    },
    "body": "\n## Use\n\nRenderer functions are provided to stache [can-stache.helper helpers] on \nthe [can-stache.helperOptions options] argument and are used to render the\ncontent between sections. The `context` and `helpers` option let you control\nthe data and helpers used to render the section.\n\nThe following example adds `{first: \"Justin\"}` to the lookup \ndata. Notice how the section has access to `first` and `last`.\n\n    stache.registerHelper(\"myhelper\", function(options){\n      var section = options.fn({first: \"Justin\"});\n      return $(\"<h1>\").append( section );\n    })\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1>Justin Meyer</h1>\n\nIf no `context` is provided, the current context is passed.  Notice\nhow the section has access to `last`:\n\n    stache.registerHelper(\"myhelper\", function(options){\n      \n       var section = options.fn();\n       return $(\"<h1>\").append( section );\n      \n    });\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1> Meyer</h1>\n    \nIf a [can-view-scope] is provided, it is used to render the \nsection. Notice how `last` is not available in the section:\n\n    stache.registerHelper(\"myhelper\", function(options){\n      \n      var section = options.fn( new Scope( {first: \"Justin\"}) );\n      return $(\"<h1>\").append( section );\n      \n    });\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1>Justin </h1>\n\n\n\n\n",
    "description": "Renders a section. These functions are usually provided as `.fn` and `.inverse` on a stache helper's [can-stache.helperOptions options].\n\n",
    "type": "typedef",
    "title": "sectionRenderer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            },
            {
              "type": "String"
            }
          ],
          "description": "Returns the rendered result of the helper. If the\nsection is within a tag, like:\n\n    <h1 {{#helper}}class='power'{{/helper}}>\n\na String is returned.  \n\nIf the section is outside a tag like: \n\n    <div> {{#helper}}<h2>Tasks</h2>{{/helper}} </div>\n    \na documentFragment is returned.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-view-scope"
              }
            ],
            "optional": true,
            "name": "context",
            "description": "Specifies the data the section is rendered \nwith.  If a [can-view-scope] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current scope as it's parent.  If nothing is provided, the current\nscope is used to render the section.\n"
          },
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-view-scope.Options"
              }
            ],
            "optional": true,
            "name": "helpers",
            "description": "Specifies the helpers the section is rendered \nwith.  If a [can-view-scope.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.\n"
          }
        ]
      }
    ],
    "name": "can-stache.sectionRenderer",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "can-view-scope.Options"
        }
      ],
      "optional": true,
      "name": "helpers",
      "description": "Specifies the helpers the section is rendered \nwith.  If a [can-view-scope.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        },
        {
          "type": "String"
        }
      ],
      "description": "Returns the rendered result of the helper. If the\nsection is within a tag, like:\n\n    <h1 {{#helper}}class='power'{{/helper}}>\n\na String is returned.  \n\nIf the section is outside a tag like: \n\n    <div> {{#helper}}<h2>Tasks</h2>{{/helper}} </div>\n    \na documentFragment is returned.\n"
    },
    "comment": " "
  },
  "can-stache.Sections": {
    "src": {
      "path": "node_modules/can-stache/docs/sections.md"
    },
    "body": "\nThe most basic form of section will simply render a section of code if the key referenced is considered **truthy** (has a value):\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\n\tData:\n\t\t{\n\t\t\tperson: {\n\t\t\t\tname: \"Andy\"\n\t\t\t}\n\t\t}\n\n\tResult:\n\t\tHello!\n\t\tAndy\n\nWhenever the key doesn't exist or the value is **falsey**, the section won't be rendered:\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\n\tData:\n\t\t{}\n\n\tResult:\n\t\tHello!\n\nHowever, this scenario can be covered through the use of an inverse section \n(`[can-stache.tags.inverse {{^key}}]` followed by `[can-stache.tags.close {{/key}}]`):\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\t\t{{^person}}\n\t\t\tNo one is here.\n\t\t{{/person}}\n\n\tData:\n\t\t{}\n\n\tResult:\n\t\tHello!\n\t\tNo one is here.\n\n## Iteration\n\nThere is a special case for sections where the key references an array. In this case, the section iterates \nthe entire array, rendering the inner text for each item in the array. Arrays are considered **truthy** if \nthey aren't empty. The `{{.}}` tag will reference the current item within the array during iteration (which is \nprimarily used when the items in the array are primitives like strings and numbers).\n\n\tTemplate:\n\t\t{{#people}}\n\t\t\t{{.}} \n\t\t{{/people}}\n\n\tData:\n\t\t{\n\t\t\tpeople: [\"Andy\", \"Austin\", \"Justin\"]\n\t\t}\n\n\tResult:\n\t\tAndy Austin Justin\n\n## Understanding when to use Sections with lists\n\nSection iteration will re-render the entire section for any change in the list. It is the prefered method to\nuse when a list is replaced or changing significantly. Whereas [can-stache.helpers.each {{#each key}}] iteration\nwill do basic diffing and aim to only update the DOM where the change occured. When doing single list item\nchanges frequently, [can-stache.helpers.each {{#each key}}] iteration is the faster choice.\n\nFor example, assuming \"list\" is a [can-list] instance:\n\n{{#if list}} will check for the truthy value of list. This is akin to checking for the truthy value of any JS object and will result to true, regardless of list contents or length.\n\n{{#if list.length}} will check for the truthy value of the length attribute. If you have an empty list, the length will be 0, so the #if will result to false and no contents will be rendered. If there is a length >= 1, this will result to true and the contents of the #if will be rendered.\n\n{{#each list}} and {{#list}} both iterate through an instance of [can-list], however we setup the bindings differently.\n\n{{#each list}} will setup bindings on every individual item being iterated through, while {{#list}} will not. This makes a difference in two scenarios:\n\n1) You have a large list, with minimal updates planned after initial render. In this case, {{#list}} might be more advantageous as there will be a faster initial render. However, if any part of the list changes, the entire {{#list}} area will be re-processed.\n\n2) You have a large list, with many updates planned after initial render. A grid with many columns of editable fields, for instance. In this case, you many want to use {{#each list}}, even though it will be slower on initial render(we're setting up more bindings), you'll have faster updates as there are now many sections.\n\n",
    "description": "\nSections (`[can-stache.tags.section {{#key}}]` followed by `[can-stache.tags.close {{/key}}]`) have multiple uses \ndepending on what type of object is passed to the section. In all cases, using a section will change \nthe current [can-stache.context context].\n",
    "name": "can-stache.Sections",
    "title": "Sections",
    "type": "page"
  },
  "can-stache.simpleHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/simplehelper.md"
    },
    "body": "\n\n## Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create mustache tags that have rich behavior.\n\nIf the helper is called __within a tag__ like:\n\n    <ul {{sortable}}/>\n\nThe returned function is called with the `<ul>` element:\n\n    stache.registerSimpleHelper(\"sortable\",function(){\n      return function(el){\n        $(el).slider();\n      }\n    });\n\nIf the helper is called __between tags__ like:\n\n    <ul>{{items}}</ul>\n\nThe returned function is called with a temporary element. The\nfollowing helper would be called with a temporary `<li>` element:\n\n    stache.registerSimpleHelper(\"items\",function(){\n      return function(li){\n\n      }\n    });\n\nThe temporary element depends on the parent element. The default temporary element\nis a `<span>` element.\n\n",
    "description": "A helper function passed to [can-stache.registerSimpleHelper]. \n",
    "type": "typedef",
    "title": "simpleHelper",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "HTMLElement"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The content to be inserted into\nthe template.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "variable": true,
            "name": "arg",
            "description": "Arguments passed from the tag. After the helper\nname, any space separated [can-stache.key keys], numbers or\nstrings are passed as arguments.\n\nThe following template:\n\n    <p>{{madLib \"Lebron James\" verb 4}}</p>\n\nRendered with\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements.\n\n    stache.registerSimpleHelper('madLib',\n      function(subject, verb, number){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n    });\n\nUnlike [can-stache.helper] simple helpers will always pass the actual\nvalue (instead of a compute).\n"
          },
          {
            "types": [
              {
                "type": "can-stache.helperOptions"
              }
            ],
            "name": "options",
            "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "can-stache.context"
            }
          ],
          "description": "The context the helper was\ncalled within.\n"
        }
      }
    ],
    "name": "can-stache.simpleHelper",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helperOptions"
        }
      ],
      "name": "options",
      "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ]
            }
          ]
        }
      ],
      "description": "The content to be inserted into\nthe template.\n"
    },
    "comment": " "
  },
  "can-stache.pages": {
    "name": "can-stache.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 0
  },
  "can-stache.static": {
    "name": "can-stache.static",
    "title": "Methods",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 1
  },
  "can-stache.tags": {
    "name": "can-stache.tags",
    "title": "Tags",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 2
  },
  "can-stache/expressions": {
    "name": "can-stache/expressions",
    "title": "Expressions",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 3
  },
  "can-stache/keys": {
    "name": "can-stache/keys",
    "title": "Key Operators",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 4
  },
  "can-stache.htags": {
    "name": "can-stache.htags",
    "title": "Helpers",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 5
  },
  "can-stache.types": {
    "name": "can-stache.types",
    "title": "Types",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 6
  },
  "can-stache": {
    "src": {
      "path": "node_modules/can-stache/docs/stache.md"
    },
    "body": "\n\n\n## Use\n\nStache templates are a [mustache](https://mustache.github.io/mustache.5.html) and [handlebars](http://handlebarsjs.com/) compatible\nsyntax.  Stache templates are used to:\n\n- Convert data into HTML.\n- Update the HTML when observable data changes.\n- Enable [can-component custom elements] and [can-stache-bindings bindings].\n\nThe following\ncreates a stache template, renders it with data, and inserts\nthe result into the page:\n\n```js\nvar stache = require(\"can-stache\");\n// renderer is a \"renderer function\"\nvar renderer = stache(\"<h1>Hello {{subject}}</h1>\");\n\n// \"renderer functions\" render a template and return a\n// document fragment.\nvar fragment = renderer({subject: \"World\"})\n\n// A document fragment is a collection of elements that can be\n// used with jQuery or with normal DOM methods.\nfragment //-> <h1>Hello World</h1>\ndocument.body.appendChild(fragment)\n```\n\nRender a template with observable data like [can-define/map/map DefineMap]s or [can-define/list/list DefineList]s and the\nresulting HTML will update when the observable data changes.\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\n\nvar renderer = stache(\"<h1>Hello {{subject}}</h1>\");\nvar map = new DefineMap({subject: \"World\"});\nvar fragment = renderer(map)\ndocument.body.appendChild(fragment)\n\nmap.subject = \"Earth\";\n\ndocument.body.innerHTML //-> <h1>Hello Earth</h1>\n```\n\nThere's a whole lot of behavior that `stache` provides.  The following walks through\nthe most important stuff:\n\n- [can-stache.magicTagTypes] - The different tag types like `{{key}}` and `{{#key}}...{{/key}}`\n- [can-stache.scopeAndContext] - How key values are looked up.\n- [can-stache.expressions] - Supported expression types like `{{helper arg}}` and `{{method(arg)}}`\n- [can-stache.Acquisition] - How to load templates into your application.\n- [can-stache.Helpers] - The built in helpers and how to create your own.\n- [can-stache.Binding] - How live binding works.\n\n## See also\n\n[can-view-scope] is used by `stache` internally to hold and lookup values.  This is similar to\nhow JavaScript's closures hold variables, except you can use it programmatically.\n\n[can-component] and [can-view-callbacks.tag can-view-callbacks.tag] allow you to define custom\nelements for use within a stache template.  [can-view-callbacks.attr can-view-callbacks.attr] allow\nyou to define custom attributes.\n\n[can-stache-bindings] sets up __element and bindings__ between a stache template's [can-view-scope],\ncomponent [can-component.prototype.ViewModel viewModels], or an element's attributes.\n\n",
    "description": "Live binding Mustache and Handlebars-comptable templates. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-stache",
    "parent": "can-core",
    "release": "2.1",
    "link": "../docco/view/stache/mustache_core.html docco",
    "test": "can/view/stache/test/test.html",
    "plugin": "can/view/stache",
    "download": "http://canjs.us/release/latest/can.stache.js",
    "signatures": [
      {
        "code": "stache(template)",
        "description": "\n\nProcesses the template and returns a [can-stache.renderer renderer function].\nUse [steal-stache] to import template renderer functions with [http://stealjs.com StealJS].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "The text of a stache template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A [can-stache.renderer renderer] function that returns a live document fragment\nthat can be inserted in the page.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "template",
      "description": "The text of a stache template.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A [can-stache.renderer renderer] function that returns a live document fragment\nthat can be inserted in the page.\n"
    },
    "comment": " "
  },
  "can-util/dom": {
    "name": "can-util/dom",
    "type": "module",
    "parent": "can-util",
    "src": {
      "line": 0,
      "codeLine": 6,
      "path": "node_modules/can-util/dom/dom.js"
    },
    "body": "",
    "description": "A collection of modules that operate on DOM. \n",
    "title": "dom",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-stache-bindings.can-EVENT": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/can-event.md"
    },
    "body": "\n\n## Use\n\nBy adding `can-EVENT='methodKey'` to an element, the function pointed to\nby `methodKey` is bound to the element's `EVENT` event. The function can be\npassed any number of arguments from the surrounding scope, or `name=value`\nattributes for named arguments. Direct arguments will be provided to the\nhandler in the order they were given, except `name=value` arguments, which\nwill all be given as part of a `hash` argument inserted after all direct\narguments.\n\nIf no `argKey`s or `hashKey`s are provided, the methodKey will be called with the\n`@content`, `@element` and `@event` as arguments.\n\nThe following uses `can-click={items.splice @index 1}` to remove a\nitem from `items` when that item is clicked on.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/can-event-args.html'></div>\n\n## Special Event Types\n\ncan.view.bindings supports creating special event types \n(events that aren't natively triggered by the DOM), which are \nbound by adding attributes like `can-SPECIAL='KEY'`. This is \nsimilar to [$.special](http://benalman.com/news/2010/03/jquery-special-events/).\n\n### can-enter / (enter)\n\ncan-enter is a special event that calls its handler whenever the enter \nkey is pressed while focused on the current element. For example: \n\n\t<input type='text' can-enter='{save}' />\n\nThe above template snippet would cause the save method \n(in the [can.mustache Mustache] [can-view-scope scope]) whenever \nthe user hits the enter key on this input.\n\n",
    "description": "\n",
    "title": "can-EVENT",
    "name": "can-stache-bindings.can-EVENT",
    "type": "function",
    "deprecated": [
      {
        "version": "2.2",
        "description": "Use [can.view.bindings.event event binding] (`($EVENT)=\"METHOD()\"`) instead.\n"
      }
    ],
    "signatures": [
      {
        "code": "(EVENT)='{methodKey [argKey..] [hashName=hashKey...]}'",
        "description": "\n\nSpecify a callback function to be called on a particular event. This is a shorthand for `can-EVENT` attributes.\n",
        "params": []
      },
      {
        "code": "can-EVENT='{methodKey [argKey..] [hashName=hashKey...]}'",
        "description": "\n\nSpecify a callback function to be called on a particular event. You can create your own special event types.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "EVENT",
            "description": "A event name like `click` or `keyup`.  If you are\nusing jQuery, you can listen to jQuery special events too.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "methodKey",
            "description": "A named key value in the current scope.  The value\nshould be a function.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "optional": true,
            "name": "argKey",
            "variable": true,
            "description": "Key values that will be passed as\narguments to the `methodKey` function value.  Key values can \nbe read from the scope, or literals like `\"foo\"`, `1`, etc.\n\nThe following key values are also supported:\n\n - `@element` - The element the event happened upon.\n - `@event` - The event object.\n - `@viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `@context` - The current context.\n - `@scope` - The current [can-view-scope Scope].\n\nIf no `argKey`s or `hashKey`s are provided, the methodKey will be called with the\n`@context`, `@element` and `@event` as arguments.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "hashName",
            "description": "A property name \nthat gets added to the `hash` argument.  The hash argument is the\nlast value passed to the function specified by `methodKey`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "hashKey",
            "description": "Specifies value that is added \nto the `hash` argument for a `hashName` value.  `hashKey` supports\nthe same key values as `argKey`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "hashKey",
      "description": "Specifies value that is added \nto the `hash` argument for a `hashName` value.  `hashKey` supports\nthe same key values as `argKey`.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.syntaxes": {
    "name": "can-stache-bindings.syntaxes",
    "title": "Syntaxes",
    "type": "group",
    "parent": "can-stache-bindings",
    "description": "",
    "order": 0
  },
  "can-stache-bindings": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/bindings.md"
    },
    "body": "\n\n## Use\n\nThe `can-stache-bindings` plugin provides [can-view-callbacks.attr custom attributes] useful for template declarative event, one-way and two-way \nbindings on element attributes, component [can-component::viewModel viewModels], and the [can-view-scope scope]. Bindings look like:\n\n- `(event)=\"key()\"` for event binding.\n- `{prop}=\"key\"` for one-way binding to a child.\n- `{^prop}=\"key\"` for one-way binding to a parent.\n- `{(prop)}=\"key\"` for two-way binding.\n\nPrepending $ to a binding like `($event)=\"key()\"` changes the binding from the `viewModel` to the element's attributes or properties.\n\nThe following are the bindings that should be used with [can-stache] and are compatible with the upcoming \n3.0 release:\n\n#### [can-stache-bindings.event event]\n\nBinds to `childEvent` on `<my-component>`'s [can-component::viewModel viewModel] and calls \n`method` on the [can-view-scope scope] with the specified arguments:\n\n```\n<my-component (child-event)=\"method('primitive', key, hash1=key1)\"/>\n```\n\nBinds to `domEvent` on `<my-component>` and calls \n`method` on the [can-view-scope scope] with the specified arguments.\n\n```\n<my-component ($dom-event)=\"method('primitive', key, hash1=key1)\"/>\n```\n\n#### [can-stache-bindings.toChild one-way to child]\n\nUpdates `childProp` in `<my-component>`'s [can-component::viewModel viewModel] with `value` in the [can-view-scope scope]:\n\n```\n<my-component {child-prop}=\"value\"/>\n```\n\nUpdates the `child-attr` attribute or property on `<my-component>` with `value` \nin the [can-view-scope scope]:\n\n```\n<my-component {$child-attr}=\"value\"/>\n```\n\n#### [can-stache-bindings.toParent one-way to parent]\n\nUpdates `value` in the [can-view-scope scope]  with `childProp` \nin `<my-component>`'s [can-component::viewModel viewModel]:\n\n```\n<my-component {^child-prop}=\"value\"/>\n```\n\nUpdates `value` \nin the [can-view-scope scope] with the `child-attr` attribute or property on `<my-component>`:\n\n```\n<my-component {^$child-attr}=\"value\"/>\n```\n\n#### [can-stache-bindings.twoWay two-way]\n\nUpdates `childProp` in `<my-component>`'s [can-component::viewModel viewModel] with `value` in the [can-view-scope scope] and vice versa:\n\n```\n<my-component {(child-prop)}=\"value\"/>\n```\n\nUpdates the `child-attr` attribute or property on `<my-component>` with `value` \nin the [can-view-scope scope] and vice versa:\n\n```\n<my-component {($child-attr)}=\"value\"/>\n```\n\n\n",
    "description": "\nProvides template event, one-way, and two-way bindings. \n",
    "type": "module",
    "title": "",
    "name": "can-stache-bindings",
    "parent": "can-core",
    "comment": " "
  },
  "can-stache-bindings.can-value": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/can-value.md"
    },
    "body": "\n\n## Use\n\nAdd a `can-value=\"KEY\"` attribute to an input or select element and\nthe element's value will be cross-bound to an observable value specified by `KEY`.\n\nDepending on the element and the element's type, `can-value` takes on\ndifferent behaviors.  If an input element has a type\nnot listed here, the behavior is the same as the `text` type.\n\n## input type=text\n\nCross binds the input's string text value with the observable value.\n\nThe value of the observable is changed after the input's `change` event,\nwhich is after `blur`.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/hyperloop.html'></div>\n\n## input type=checkbox\n\nCross binds the checked property to a true or false value. An alternative\ntrue and false value can be specified by setting `can-true-value` and\n`can-false-value` attributes.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/input-checkbox.html'></div>\n\n## input type='radio'\n\nIf the radio element is checked, sets the observable specified by `can-value` to match the value of `value` attribute.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/input-radio.html'></div>\n\n## select\n\nCross binds the selected option value with an observable value.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/select.html'></div>\n\n## textarea\n\nCross binds the textarea's string text value with the observable value.\n\nThe value of the observable is changed after the textarea's `change` event,\nwhich is after `blur`.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/textarea.html'></div>\n\n",
    "description": "\nSets up two way bindings in a template.\n",
    "title": "can-value",
    "name": "can-stache-bindings.can-value",
    "type": "function",
    "deprecated": [
      {
        "version": "2.3",
        "description": "Use [can-stache-bindings.twoWay two way binding] like `{($value)}=\"KEY\"` instead.\n"
      }
    ],
    "signatures": [
      {
        "code": "can-value='KEY'",
        "description": "\n\nBinds the element's value or checked property to the value specified by\nkey. Example:\n\n    <input type='text' can-value='first.name'/>\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A named value in the current scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-mustache.key"
        }
      ],
      "name": "key",
      "description": "A named value in the current scope.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.event": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/event.md"
    },
    "body": "\n## Use\n\nThe use of `(event)` bindings changes between listening on __DOM events__ and __viewModel events__.\n\n## DOM events\n\nTo listen on a DOM event, wrap the event name with `($event)` like:\n\n```\n<div ($click)=\"doSomething()\"/>\n```\n\nBy adding `($EVENT)='methodKey()'` to an element, the function pointed to\nby `methodKey` is bound to the element's `EVENT` event. The function can be\npassed any number of arguments from the surrounding scope, or `name=value`\nattributes for named arguments. Direct arguments will be provided to the\nhandler in the order they were given.\n\nThe following uses `($click)=\"items.splice(%index,1)\"` to remove a\nitem from `items` when that item is clicked on.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/event-args.html'></div>\n\n### Special Event Types\n\n[can-stache-bindings] supports creating special event types \n(events that aren't natively triggered by the DOM), which are \nbound by adding attributes like `($SPECIAL)='KEY'`. This is \nsimilar to [$.special](http://benalman.com/news/2010/03/jquery-special-events/).\n\n### ($enter)\n\n`($enter)` is a special event that calls its handler whenever the enter \nkey is pressed while focused on the current element. For example: \n\n\t<input type='text' ($enter)='save()' />\n\nThe above template snippet would call the save method \n(in the [can-view-scope scope]) whenever \nthe user hits the enter key on this input.\n\n## viewModel events\n\nTo listen on a [can-component Component's] [can-component::viewModel viewModel], wrap the event name with `(event)` like:\n\n```\n<player-edit \n  \t(close)=\"removeEdit()\" \n  \t{player}=\"editingPlayer\"/>\n```\n\nViewModels can publish events on themselves. The following `<player-edit>` component\n dispatches a `\"close\"` event on itself when its `close` method is called:\n\n```\nComponent.extend({\n  tag: \"player-edit\",\n  template: can.view('player-edit-stache'),\n  viewModel: {\n    close: function(){\n      this.dispatch(\"close\");\n    }\n  }\n});\n```\n\nThe following demo uses this ability to create a close button that \nhides the player editor:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next_event.html'></div>\n\n",
    "description": "Response to events on elements or component ViewModels. \n",
    "title": "(event)",
    "name": "can-stache-bindings.event",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 0,
    "signatures": [
      {
        "code": "($DOM_EVENT)='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on the element and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<div ($click)=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "DOM_EVENT",
            "description": "A DOM event name like \"click\".\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression like `method(key)` that is called when the `DOM_EVENT` is fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `$element` - The [can-jquery can.$] wrapped element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n"
          }
        ]
      },
      {
        "code": "(VIEW_MODEL_EVENT)='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on the element's [can-component::viewModel viewModel] and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<my-component (show)=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "DOM_EVENT",
            "description": "A DOM event name like \"click\". jQuery custom events can also\nbe given. \n"
          },
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression like `method(key)` that is called when the `DOM_EVENT` \nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `$element` - The [can-jquery can.$] wrapped element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.expressions"
        }
      ],
      "name": "CALL_EXPRESSION",
      "description": "A call expression like `method(key)` that is called when the `DOM_EVENT` \nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `$element` - The [can-jquery can.$] wrapped element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n\n"
    },
    "comment": " "
  },
  "can-stache-bindings.toChild": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/to-child.md"
    },
    "body": "\n## Use\n\n`{child-prop}=\"key\"` is used to pass values from the scope to a component.  You can use CallExpressions like:\n\n```\n<player-scores {scores}=\"game.scoresForPlayer('Alison')\"/>\n<player-scores {scores}=\"game.scoresForPlayer('Jeff')\"/>\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-child.html'></div>\n\n",
    "description": "One-way bind a value in the parent scope to the [can-component::viewModel viewModel]. \n",
    "title": "{to-child}",
    "name": "can-stache-bindings.toChild",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 1,
    "signatures": [
      {
        "code": "{child-prop}=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` in [can-component::viewModel viewModel]. It also updates `childProp` with the value of `key` when `key` changes.\n\n  ```\n  <my-component {some-prop}=\"value\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property to set in the \ncomponent's viewmodel.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression whose resulting value is used to set as `childProp`. \n"
          }
        ]
      },
      {
        "code": "{$child-prop}=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` property or attribute on the element. \n\n  ```\n  <input {$value}=\"name\"/>\n  ```\n\n  This signature works, but the following should be used instead:\n  \n  ```\n  <input value=\"{{name}}\"/>\n  ```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache-bindings.twoWay": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/two-way.md"
    },
    "body": "\n## Use\n\n`{(child-prop)}=\"key\"` is used to two-way bind a value in a [can-component::viewModel viewModel] to\na value in the  [can-view-scope scope].  If one value changes, the other value is updated.\n\nThe following two-way binds the `<edit-plate>` element's `plateName` to the `editing.licensePlate`\nvalue in the scope.  This allows `plateName` to update if `editing.licensePlate` changes and\n`editing.licensePlate` to update if `plateName` changes.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/two-way.html'></div>\n\nThis demo can be expressed a bit easier with the references scope:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/reference.html'></div>\n\n## Initialization\n\nWhen a binding is being initialized, the behavior of what the viewModel and scope properties\nare set to depends on their initial values.\n\nIf the viewModel value is `not undefined` and the scope is `undefined`, scope will be set to the viewModel value.\n\nIf the viewModel value is `undefined` and the scope is `not undefined`, viewModel will be set to the scope value.\n\nIf both the viewModel and scope are `not undefined`, viewModel will be set to the scope value.\n\n\n",
    "description": "Two-way bind a value in the [can-component::viewModel viewModel] or the element to the parent scope. \n",
    "title": "{(two-way)}",
    "name": "can-stache-bindings.twoWay",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 3,
    "signatures": [
      {
        "code": "{(child-prop)}=\"key\"",
        "description": "\n\n  Two-way binds `childProp` in the  [can-component::viewModel viewModel] to \n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n  \n  ```\n  <my-component {(some-prop)}=\"value\"/>\n  ```\n  \n  When setting up the binding:\n  \n  - If `childProp` is `undefined`, `key` will be set to `childProp`.\n  - If `key` is `undefined`, `childProp` will be set to `key`.\n  - If both `childProp` and `key` are defined, `key` will be set to `childProp`.\n  \n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property of the viewModel to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
          }
        ]
      },
      {
        "code": "{($child-prop)}=\"key\"",
        "description": "\n\n  Two-way binds the element's `childProp` property or attribute to \n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n\n  ```\n  <input {($value)}=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element's property or attribute to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.reference": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/reference.md"
    },
    "body": "\n## Use\n\nExport a view model to the references scope by adding an attribute with the \nhypenated name of the reference scope property:\n\n```\n<year-selector *year-selector />\n```\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/reference-one-way.html'></div>\n\n",
    "description": "Export a viewModel into a template's references scope. \n",
    "title": "*REFERENCE",
    "name": "can-stache-bindings.reference",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 4,
    "signatures": [
      {
        "code": "*ref-prop",
        "description": "\n\n  A shorthand for exporting an element's viewModel to the reference scope.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "ref-prop",
            "description": "The name of the property to set in the template's 'references' scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "ref-prop",
      "description": "The name of the property to set in the template's 'references' scope.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.toParent": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/to-parent.md"
    },
    "body": "\n## Use\n\nThe use of `{^to-parent}` bindings changes between exporting __viewModel properties__ or __DOM properties__.\n\n## Exporting ViewModel properties\n\n`{^child-prop}=\"key\"` can be used to export single values or the complete view model from a \nchild component into the parent scope. Typically, the values are exported to the references scope.\n\nIn the following example, it connects the __selected__ driver in `<drivers-list>` with an editable __plateName__ in\n`<edit-plate>`:\n\n    <drivers-list {^selected}=\"*editing\"/>\n    <edit-plate {(plate-name)}=\"*editing.licensePlate\"/>\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-parent.html'></div>\n\t\n## Exporting DOM properties\n\n`{^$child-prop}=\"key\"` can be used to export an attribute value into the scope.  For example:\n\n```\n<input {^$value}=\"name\"/>\n```\n\nUpdates `name` in the scope when the `<input>` element's `value` changes.\n\n## Exporting Functions\n\nYou can export a function to the parent scope with a binding like:\n\n```\n<my-tabs {^@add-panel}=\"@*addPanel\">\n```\n\nAnd pass the method like:\n\n```\n<my-panel {add-panel}=\"@*addPanel\" title=\"CanJS\">CanJS Content</my-panel>\n```\n\nCheck it out in this demo:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-parent-function.html'></div>\n\nNotice that `@` is used to prevent reading the function.  \n\n\n",
    "description": "One-way bind a value in the current [can-component::viewModel viewModel] to the parent scope. \n",
    "title": "{^to-parent}",
    "name": "can-stache-bindings.toParent",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 2,
    "signatures": [
      {
        "code": "{^child-prop}=\"key\"",
        "description": "\n\nExports `childProp` in the [can-component::viewModel viewModel] to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n`key` with the value of `childProp` when `childProp` changes.\n\n```\n<my-component {^some-prop}=\"value\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property to export from the \nchild components viewmodel. Use `{^this}` or `{^.}` to export the entire viewModel.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression that will be used to set in the parent scope.\n"
          }
        ]
      },
      {
        "code": "{^$child-prop}=\"key\"",
        "description": "\n\n  Exports the element's `childProp` property or attribute to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n  `key` with the value of `childProp` when `childProp` changes.\n\n  ```\n  <input {^$value}=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element's property or attribute to export.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression whose resulting value with be used to set in the parent scope.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "An expression whose resulting value with be used to set in the parent scope.\n\n"
    },
    "comment": " "
  },
  "can-util/js": {
    "name": "can-util/js",
    "type": "module",
    "parent": "can-util",
    "src": {
      "line": 0,
      "codeLine": 6,
      "path": "node_modules/can-util/js/js.js"
    },
    "body": "",
    "description": "Utilities for manipulating JavaScript data structures. \n",
    "title": "js",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-vdom/make-parser/": {
    "name": "can-vdom/make-parser/",
    "type": "module",
    "parent": "node_modules/can-vdom/make-parser/make-parser.js",
    "src": {
      "line": 0,
      "codeLine": 7,
      "path": "node_modules/can-vdom/make-parser/make-parser.js"
    },
    "body": "\n",
    "description": "\nReturns a function that can generate a HTML->TOKENs parser\ngiven a document.\n",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ]
  },
  "can-vdom/make-document/": {
    "name": "can-vdom/make-document/",
    "type": "function",
    "parent": "node_modules/can-vdom/make-document/make-document.js",
    "src": {
      "line": 0,
      "codeLine": 5,
      "path": "node_modules/can-vdom/make-document/make-document.js"
    },
    "body": "\n",
    "description": "\nExports a function that when called, returns a dom-light document object.\n",
    "title": ""
  },
  "can-view-live.attr": {
    "type": "function",
    "name": "can-view-live.attr",
    "parent": "can-view-live",
    "src": {
      "line": 2,
      "codeLine": 21,
      "path": "node_modules/can-view-live/lib/attr.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "live.attr(el, attributeName, compute)",
        "description": "\n\nKeep an attribute live to a [can-compute].\n\n```js\nvar div = document.createElement('div');\nvar compute = canCompute(\"foo bar\");\nlive.attr(div,\"class\", compute);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "The element whos attribute will be kept live."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attributeName",
            "description": "The attribute name."
          },
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "The compute.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "compute",
      "description": "The compute.\n\n"
    }
  },
  "can-view-live.html": {
    "type": "function",
    "name": "can-view-live.html",
    "parent": "can-view-live",
    "src": {
      "line": 6,
      "codeLine": 38,
      "path": "node_modules/can-view-live/lib/html.js"
    },
    "body": "\n",
    "description": "\nLive binds a compute's value to a collection of elements.\n",
    "title": "",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.html(el, compute, [parentNode])",
        "description": "\n\n`live.html` is used to setup incremental live-binding on a block of html.\n\n```js\n// a compute that change's it's list\nvar greeting = compute(function(){\n  return \"Welcome <i>\"+me.attr(\"name\")+\"</i>\"\n});\n\nvar placeholder = document.createTextNode(\" \");\n$(\"#greeting\").append(placeholder);\n\nlive.html(placeholder, greeting);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "An html element to replace with the live-section.\n"
          },
          {
            "types": [
              {
                "type": "can.compute"
              }
            ],
            "name": "compute",
            "description": "A [can.compute] whose value is HTML.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "optional": true,
            "name": "parentNode",
            "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "optional": true,
      "name": "parentNode",
      "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
    }
  },
  "can-view-live": {
    "name": "can-view-live",
    "type": "module",
    "parent": "can-infrastructure",
    "src": {
      "line": 11,
      "codeLine": 38,
      "path": "node_modules/can-view-live/lib/core.js"
    },
    "body": "\n\n\n## Use\n\n[can-view-live] is an object with utlitiy methods for setting up\nlive-binding in relation to different parts of the DOM and DOM elements.  For\nexample, to make an `<h2>`'s text stay live with\na compute:\n\n    var text = canCompute(\"Hello World\");\n    var textNode = $(\"h2\").text(\" \")[0].childNodes[0];\n    live.text(textNode, text);\n\n\n\n",
    "description": "\nSetup live-binding between the DOM and a compute manually.\n",
    "title": "can-view-live",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "An",
            "description": "object with the live-binding methods:\n[can-view-live.html], [can-view-live.list], [can-view-live.text],\n[can-view-live.attr] and [can-view-live.attrs].\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "release": "2.0.4",
    "comment": " "
  },
  "can.view.live.replace": {
    "type": "function",
    "name": "can.view.live.replace",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "HTMLElement"
                  }
                ]
              }
            ]
          }
        ],
        "name": "nodes",
        "description": "An array of elements.  There should typically be one element."
      },
      {
        "types": [
          {
            "type": "String"
          },
          {
            "type": "HTMLElement"
          },
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "val",
        "description": "The content that should replace\n`nodes`.  If a string is passed, it will be [can.view.hookup hookedup].\n"
      },
      {
        "types": [
          {
            "type": "function",
            "returns": {
              "types": [
                {
                  "type": "undefined"
                }
              ]
            },
            "params": []
          }
        ],
        "optional": true,
        "name": "teardown",
        "description": "A callback if these elements are torn down.\n "
      }
    ],
    "parent": "can.view.live",
    "src": {
      "line": 112,
      "codeLine": 126,
      "path": "node_modules/can-view-live/lib/core.js"
    },
    "body": "\n",
    "description": "\nReplaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\ncorrect.\n",
    "title": "",
    "release": "2.0.4",
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "teardown",
      "description": "A callback if these elements are torn down.\n "
    }
  },
  "can-view-live.list": {
    "type": "function",
    "name": "can-view-live.list",
    "parent": "can-view-live",
    "src": {
      "line": 64,
      "codeLine": 104,
      "path": "node_modules/can-view-live/lib/list.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.list(el, list, render, context, [parentNode])",
        "description": "\n\nLive binds a compute's list incrementally.\n\n```js\n// a compute that change's it's list\nvar todos = compute(function(){\n  return new Todo.List({page: can.route.attr(\"page\")})\n})\n\nvar placeholder = document.createTextNode(\" \");\n$(\"ul#todos\").append(placeholder);\n\ncan.view.live.list(\n  placeholder,\n  todos,\n  function(todo, index){\n    return \"<li>\"+todo.attr(\"name\")+\"</li>\"\n  });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "An html element to replace with the live-section.\n"
          },
          {
            "types": [
              {
                "type": "can-compute"
              },
              {
                "type": "can-list"
              },
              {
                "type": "can-define/list/list"
              }
            ],
            "name": "list",
            "description": "An observable list type.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "String"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ],
                    "name": "index"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "render",
            "description": "A function that when called with\nthe incremental item to render and the index of the item in the list.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "The `this` the `render` function will be called with.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "optional": true,
            "name": "parentNode",
            "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "optional": true,
      "name": "parentNode",
      "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
    }
  },
  "can-view-live.text": {
    "type": "function",
    "name": "can-view-live.text",
    "parent": "can-view-live",
    "src": {
      "line": 3,
      "codeLine": 12,
      "path": "node_modules/can-view-live/lib/text.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.text(el, compute, [parentNode], [nodeList])",
        "description": "\n\nReplaces one element with some content while keeping [can-view-live.nodeLists nodeLists] data correct.\n",
        "params": []
      }
    ]
  },
  "can-view-import.pages.dynamic": {
    "src": {
      "path": "node_modules/can-view-import/docs/dynamic.md"
    },
    "body": "\nTo make your import be loaded dynamically it *cannot* but self closing like `/>` but rather must have a closing tag `</can-import>`.\n\n### Example\n\n```\n<can-import from=\"components/foobar\">\n  {{#if isResolved}}\n  <foobar/>\n  {{/if}}\n</can-import>\n```\n\nwhich is equivalent to a Steal import like:\n\n```\nsteal.import('components/foobar').then(function(foobar) {\n // access to the module you loaded.\n // e.g. access to a component's ViewModel \n // foobar.ViewModel\n});\n```\n\nPlease notice that when dynamically importing modules in a stache file, the scope inside [can-view-import <can-import>] is a Promise, so you have to wait until it is resolved before injecting something like a [can-component].\n\nUse the `{{#if isResolved}}` helper for that.\n\n",
    "description": "\nDynamic imports are used in conditional situations such as within a [can-stache.helpers.if], to prevent unnecessarily fetching resources that might not be needed in all cases.\n",
    "name": "can-view-import.pages.dynamic",
    "title": "Dynamic Imports",
    "type": "page",
    "parent": "can-view-import.pages"
  },
  "can-view-import.can-tag": {
    "src": {
      "path": "node_modules/can-view-import/docs/can-tag.md"
    },
    "body": "\n## Use\n\n**can-tag** allows for injecting a component, using the imported promise as the\ninjected component's view model.\n\nThe example below shows a loading graphic until the cart component has been loaded.\nOnce the cart promise is resolved, `<shopping-cart></shopping-cart>` is injected\ninto the page.\n\nLoading Indicator Component\n\n```\nvar template = stache('{{#isResolved}}<content/>{{else}}<img src=\"loading.gif\"/>{{/isResolved}}');\n\nComponent.extend({\n  tag: \"loading-indicator\",\n  template: template\n});\n```\n\nMain Template\n\n```\n<can-import from=\"cart\" can-tag=\"loading-indicator\">\n  <shopping-cart></shopping-cart>\n</can-import>\n```\n\n",
    "description": "Use another [can-view-callbacks.tag] (such as a [can-component]) to control the `<content>` of a [can-view-import].  \n",
    "title": "can-tag",
    "name": "can-view-import.can-tag",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "can-tag=\"TAG_NAME\"",
        "description": "\n\nInstantiates the provided [can-view-callbacks.tag] and sets its [can-component::viewModel viewModel] to be the Promise for the import.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "TAG_NAME",
            "description": "The tag name (usually a [can-component]) to use.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "TAG_NAME",
      "description": "The tag name (usually a [can-component]) to use.\n"
    },
    "comment": " "
  },
  "can-view-import.pages": {
    "name": "can-view-import.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-view-import",
    "description": "",
    "order": 0
  },
  "can-view-import.attributes": {
    "name": "can-view-import.attributes",
    "title": "Attributes",
    "type": "group",
    "parent": "can-view-import",
    "description": "",
    "order": 1
  },
  "can-view-import": {
    "src": {
      "path": "node_modules/can-view-import/docs/can-view-import.md"
    },
    "body": "\n## Use\n\nA template might depend on component or helper modules. `<can-import>` allows\nyou to specify these dependencies.\n\nExample:\n\n```\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\nCurrently this __only__ works with [can-view-autorender] or the [steal-stache] plugin.\n\n## Progressive Loading\n\nA template may load or conditionally load a module after the initial page load. `<can-import>` allows progressive loading by using an end tag.\n\nThe first example below shows a component being loaded ad hoc. The second illustrates conditionally loading modules based on some application state.\n\nExample:\n\n```\n<can-import from=\"components/home\"></can-import>\n```\n\n```\n{{#eq location 'home'}}\n<can-import from=\"components/home\">\n ...\n</can-import>\n{{/eq}}\n\n{{#eq location 'away'}}\n<can-import from=\"components/away\">\n  ...\n</can-import>\n{{/eq}}\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-view-import",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-import",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "&lt;can-import from=\"MODULE_NAME\" /&gt;",
        "description": "\n\nStatically import a module from with a [can-stache] template. *MODULE_NAME* will be imported before the template renders.\n\n```\n<can-import from=\"components/tabs\" />\n<tabs-widget />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "optional": true,
            "name": "MODULE_NAME",
            "description": "A module that this template depends on.\n"
          }
        ]
      },
      {
        "code": "&lt;can-import from=\"MODULE_NAME\"&gt;content&lt;/can-import&gt;",
        "description": "\n\nDynamically import a module. *MODULE_NAME* will be imported dynamically; the scope within the template is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```\n<can-import from=\"components/tabs\">\n\t{{#if isResolved}}\n\t\t<tabs-widget />\n\t{{/if}}\n</can-import>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "optional": true,
            "name": "MODULE_NAME",
            "description": "A module that this template depends on.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "moduleName"
        }
      ],
      "optional": true,
      "name": "MODULE_NAME",
      "description": "A module that this template depends on.\n"
    },
    "comment": " "
  },
  "can-view-import.from": {
    "src": {
      "path": "node_modules/can-view-import/docs/from.md"
    },
    "body": "",
    "description": "Set the module name that will be imported into the template. \n",
    "title": "from",
    "name": "can-view-import.from",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "from=\"MODULE_NAME\"",
        "description": "\n\nPasses MODULE_NAME to [can-util/js/import/import] and sets the [can-view-import <can-import>]'s viewModel to be the returned Promise.\n\n```js\n<can-import from=\"bootstrap/bootstrap.css\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "MODULE_NAME",
            "description": "The name of the module to import.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "MODULE_NAME",
      "description": "The name of the module to import.\n"
    }
  },
  "can-view-import.value": {
    "src": {
      "path": "node_modules/can-view-import/docs/value.md"
    },
    "body": "",
    "description": "Set the value that is returned from the [can-view-import can-import] Promise to a [can-stache-bindings.reference reference scope] variable. \n",
    "title": "{^value}",
    "name": "can-view-import.value",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "{^value}=\"*NAME\"",
        "description": "\n\nSets up a [can-stache-bindings.toParent] binding to \\*NAME in the references scope.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "NAME",
            "description": "The variable name to assign to the references scope. This can be any string name you want to use, but must be preceded by `*` or it will be placed on the template's View Model.\n\n```html\n<can-import from=\"app/person\" {^value}=\"*person\" />\n\t\n<section>\n\thello {{*person.name}}\n</section>\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "NAME",
      "description": "The variable name to assign to the references scope. This can be any string name you want to use, but must be preceded by `*` or it will be placed on the template's View Model.\n\n```html\n<can-import from=\"app/person\" {^value}=\"*person\" />\n\t\n<section>\n\thello {{*person.name}}\n</section>\n```\n"
    }
  },
  "can-view-import.pages.static": {
    "src": {
      "path": "node_modules/can-view-import/docs/static.md"
    },
    "body": "\nTo make your import be static, it *must* be self closing like `/>`.\n\n## Example\n\n```\n<can-import from=\"mymodule\" />\n```\n\nwhich is equivalent to a ES6 import like:\n\n```\nimport from \"mymodule\";\n```\n\n",
    "description": "\nStatic imports reflect direct dependencies of this template. Most uses of [can-view-import] will be to static imports.\n",
    "name": "can-view-import.pages.static",
    "title": "Static Imports",
    "type": "page",
    "parent": "can-view-import.pages"
  },
  "can-view-callbacks.attr": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/attr.md"
    },
    "body": "\n\n## Use\n\n`canViewCallbacks.attr` is used to add custom behavior to elements that contain a\nspecified html attribute. Typically it is used to mixin behavior (whereas\n[can-view-callbacks.tag] is used to define behavior).\n\nThe following example adds a jQueryUI tooltip to any element that has\na `tooltip` attribute like `<div tooltip=\"Click to edit\">Name</div>`.\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/tooltip.html'></div>\n\n## Listening to attribute changes\n\nIn the previous example, the content of the tooltip was static. However,\nit's likely that the tooltip's value might change. For instance, the template\nmight want to dynamically update the tooltip like:\n\n    <button tooltip=\"{{deleteTooltip}}\">\n      Delete\n    </button>\n\nWhere `deleteTooltip` changes depending on how many users are selected:\n\n    deleteTooltip: function(){\n      var selectedCount = selected.length;\n      if(selectedCount) {\n        return \"Delete \"+selectedCount+\" users\";\n      } else {\n        return \"Select users to delete them.\";\n      }\n    }\n\n\nThe [can-util/dom/events/attributes/attributes attributes] event can be used to listen to when\nthe toolip attribute changes its value like:\n\n```js\ncanViewCallbacks.attr(\"tooltip\", function( el, attrData ) {\n\t// A helper that updates or sets up the tooltip\n\tvar updateTooltip = function(){\n\t\t$(el).tooltip({\n\t\t\tcontent: el.getAttribute(\"tooltip\"),\n\t\t\titems: \"[tooltip]\"\n\t\t})\n\t}\n\t// When the tooltip attribute changes, update the tooltip\n\tdomEvents.addEventListener.call(el, \"attributes\", function(ev){\n\t\tif(ev.attributeName === \"tooltip\") {\n\t\t\tupdateTooltip();\n\t\t}\n\t});\n\t// Setup the tooltip\n\tupdateTooltip();\n\n});\n```\n\nTo see this behavior in the following demo, hover the mouse over the \"Delete\" button.  Then\nselect some users and hover over the \"Delete\" button again:\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/dynamic_tooltip.html'></div>\n\n\n## Reading values from the scope.\n\nIt's common that attribute mixins need complex, observable data to\nperform rich behavior. The attribute mixin is able to read\ndata from the element's [can.view.Scope scope]. For example,\n__toggle__ and __fade-in-when__ will need the value of `showing` in:\n\n    <button toggle=\"showing\">\n      {{#showing}}Show{{else}}Hide{{/showing}} more info</button>\n    <div fade-in-when=\"showing\">\n      Here is more info!\n    </div>\n\nThese values can be read from [can-view-callbacks.attrData]'s scope like:\n\n    attrData.scope.attr(\"showing\")\n\nBut often, you want to update scope value or listen when the scope value\nchanges. For example, the __toggle__ mixin might want to update `showing`\nand the __fade-in-when__ mixin needs to know when\nthe `showing` changes.  Both of these can be achived by\nusing [can-view-scope::compute compute] to get a get/set compute that is\ntied to the value in the scope:\n\n    var showing = attrData.scope.compute(\"showing\")\n\nThis value can be written to by `toggle`:\n\n\n    canViewCallbacks.attr(\"toggle\", function(el, attrData){\n\n      var attrValue = el.getAttribute(\"toggle\")\n          toggleCompute = attrData.scope.compute(attrValue);\n\n      $(el).click(function(){\n        toggleCompute(! toggleCompute() )\n      })\n\n    })\n\nOr listened to by `fade-in-when`:\n\n    canViewCallbacks.attr(\"fade-in-when\", function( el, attrData ) {\n      var attrValue = el.getAttribute(\"fade-in-when\");\n          fadeInCompute = attrData.scope.compute(attrValue),\n          handler = function(ev, newVal, oldVal){\n            if(newVal && !oldVal) {\n              $(el).fadeIn(\"slow\")\n            } else if(!newVal){\n              $(el).hide()\n            }\n          }\n\n      fadeInCompute.on(\"change\",handler);\n\n      ...\n    });\n\nWhen you listen to something other than the attribute's element, remember to\nunbind the event handler when the element is [can-util/dom/events/removed/removed removed] from the page:\n\n```js\ndomEvents.addEventListener.call(el,\"removed\", function(){\n\tfadeInCompute.off(handler);\n});\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/fade_in_when.html'></div>\n\n## When to call\n\n`canViewCallbacks.attr` must be called before a template is processed. When [using `can.view` to create a renderer function](http://canjs.com/docs/can.view.html#sig_can_view_idOrUrl_), `canViewCallbacks.attr` must be called before the template is loaded, not simply before it is rendered.\n\n\t\t//Call canViewCallbacks.attr first\n\t\tcanViewCallbacks.attr('tooltip', tooltipFunction);\n\t\t//Preload a template for rendering\n\t\tvar renderer = stache(\"<div tooltip='Hi There'>...</div>\");\n\t\t//No calls to canViewCallbacks.attr after this will be used by `renderer`\n\n",
    "description": "\nRegister custom behavior for an attribute.\n",
    "title": "attr",
    "name": "can-view-callbacks.attr",
    "type": "function",
    "parent": "can-view-callbacks/methods",
    "signatures": [
      {
        "code": "callbacks.attr(attributeName, attrHandler(el, attrData))",
        "description": "\n\nRegisters the `attrHandler` callback when `attributeName` is found\nin a template.\n\n```js\nvar canViewCallbacks = require(\"can-view-callbacks\");\n\ncanViewCallbacks.attr(\"show-when\", function(el, attrData){\n\tvar prop = el.getAttribute(\"show-when\");\n\tvar compute = attrData.compute(prop);\n\n\tvar showOrHide = function(){\n\t\tvar val = compute();\n\t\tif(val) {\n\t\t\tel.style.display = 'block';\n\t\t} else {\n\t\t\tel.style.display = 'hidden';\n\t\t}\n\t};\n\n\tcompute.on(\"change\", showOrHide);\n\tshowOrHide();\n\n\tdomEvents.addEventListener.call( el, \"removed\", function onremove(){\n\t\tcompute.off(\"change\", showOrHide);\n\t\tdomEvents.removeEventListener.call(\"removed\", onremove);\n\t});\n});\n```\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "RegExp"
              }
            ],
            "name": "attributeName",
            "description": "A lower-case attribute name or regular expression\nthat matches attribute names. Examples: `\"my-fill\"` or `/my-\\w/`.  \n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "HTMLElement"
                      }
                    ],
                    "name": "el"
                  },
                  {
                    "types": [
                      {
                        "type": "can-view-callbacks.attrData"
                      }
                    ],
                    "name": "attrData"
                  }
                ]
              }
            ],
            "name": "attrHandler",
            "description": "\nA function that adds custom behavior to `el`.  \n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ],
              "name": "el"
            },
            {
              "types": [
                {
                  "type": "can-view-callbacks.attrData"
                }
              ],
              "name": "attrData"
            }
          ]
        }
      ],
      "name": "attrHandler",
      "description": "\nA function that adds custom behavior to `el`.  \n"
    },
    "comment": " "
  },
  "can-view-callbacks/methods": {
    "name": "can-view-callbacks/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-view-callbacks",
    "description": "",
    "order": 0
  },
  "can-view-callbacks/types": {
    "name": "can-view-callbacks/types",
    "title": "types",
    "type": "group",
    "parent": "can-view-callbacks",
    "description": "",
    "order": 0
  },
  "can-view-callbacks": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/can-view-callbacks.md"
    },
    "body": "\n\nAllows registering callback functions that will be called when tags and attributes are rendered in [can-view-target].\n\n## Registering tags\n\n[can-view-callbacks.tag callbacks.tag] allows you to register a tag that custom behavior will be attached to.\n\nThis will style elements using the *blue-el* tag with a blue background.\n\n```js\nvar callbacks = require(\"can-view-callbacks\");\n\ncallbacks.tag(\"blue-el\", function(el){\n\tel.style.background = \"blue\";\n});\n```\n\n```html\n<blue-el><p>Some content with a blue background, gross!</p></blue-el>\n```\n\n## Registering attributes\n\nSimilarly you can register a callback for an attribute. Here we are using a regular expression to match an attribute that starts with `foo-`:\n\n```js\ncallbacks.attr(/foo-[\\w\\.]+/, function(el, attrData){\n\t// Get the part after foo-\n\tvar attrValue = attrData.attributeName.substr(4);\n\n\t// Set it's content\n\tel.textContent = attrValue;\n});\n```\n\nSo that:\n\n```html\n<div foo-bar></div>\n```\n\nRenders as:\n\n```html\n<div foo-bar>bar</div>\n```\n\n",
    "description": "Registered callbacks for behaviors \n",
    "type": "module",
    "title": "can-view-callbacks",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-callbacks",
    "parent": "can-infrastructure",
    "comment": " "
  },
  "can-view-callbacks.tag": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/tag.md"
    },
    "body": "\n\n## Use\n\n`canViewCallbacks.tag` is a low-level way to add custom behavior to custom elements. Often, you\nwant to do this with [can-component]. However, [can-view-callbacks.tag callbacks.tag] is\nuseful for when [can-component] might be considered overkill.  For example, the\nfollowing creates a [jQueryUI DatePicker](http://api.jqueryui.com/datepicker/) everytime a\n`<jqui-datepicker>` element is found:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker()\n    })\n\n\nThe `tagHandler`'s [can-view-callbacks.tagData] argument is an object\nthat contains the stache [can-view-scope Scope] and helper [can-view-scope.Options]\nwhere `el` is found and a [can-stache.renderer subtemplate] that renders the contents of the\ntemplate within the custom tag.\n\n## Getting values from the template\n\n`tagData.scope` can be used to read data from the template.  For example, if I wanted\nthe value of `\"format\"` within the current template, it could be read like:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker({format: tagData.scope.get(\"format\")})\n    })\n\n    var template = mustache(\"<jqui-datepicker></jqui-datepicker>\")\n    template({format: \"mm/dd/yy\"})\n\n`tagData.options` contains the helpers and partials provided\nto the template.  A helper function might need to be called to get the current value of format like:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker({format: tagData.options.get(\"helpers.format\")()})\n    })\n\n    var template = mustache(\"<jqui-datepicker></jqui-datepicker>\")\n    template({},{format: function(){\n      return \"mm/dd/yy\"\n    }})\n\n## Responding to changing data\n\nOften, data passed to a template is observable.  If you use [can-view-callbacks.tag], you must\nlisten and respond to chagnes yourself.  Consider if format is property on a\n`settings` [can.Map] like:\n\n    var settings = new Map({\n      format: \"mm/dd/yy\"\n    })\n\nYou want to update the datepicker if `format` changes.  The easiest way to do this\nis to use [can-view-scope::compute Scope's compute] method which returns a get-set\ncompute that is tied to a key value:\n\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n\n      var formatCompute = tagData.scope.compute(\"format\"),\n          changeHandler = function(ev, newVal){\n            $(el).datepicker(\"option\",\"format\", newVal});\n          }\n\n      formatCompute.bind(\"change\",changeHandler)\n\n      changeHandler({}, formatCompute());\n\n      ...\n\n    })\n\n    var template = mustache(\"<jqui-datepicker/>\")\n    template(settings)\n\nIf you listen on something outside the tag, it's a good practice to stop listening\nwhen the element is [can-util/dom/events/removed/removed removed] from the page:\n\n\tdomEvents.addEventListener.call( el, \"removed\", function onremove(){\n\t\tcompute.off(\"change\", showOrHide);\n\t\tformatCompute.unbind(\"change\",changeHandler)\n\t});\n\n\n## Subtemplate\n\nIf content is found within a custom tag like:\n\n    var template = stache(\n      \"<my-form>\\\n         <input value=\"{{first}}\"/>\\\n         <input value=\"{{last}}\"/>\\\n       </my-form>\")\n\nA separate template function is compiled and passed\nas `tagData.subtemplate`.  That subtemplate can\nbe rendered with custom data and options. For example:\n\n    callbacks.tag(\"my-form\", function(el, tagData){\n       var frag = tagData.subtemplate({\n         first: \"Justin\"\n       }, tagData.options)\n\n       $(el).html( frag )\n    })\n\n    template({\n      last: \"Meyer\"\n    })\n\n\nIn this case, the sub-template will not get a value for `last`.  To\ninclude the original data in the subtemplate's scope, [can-view-scope::add] to\nthe old scope like:\n\n    callbacks.tag(\"my-form\", function(el, tagData){\n       var frag = tagData.subtemplate(\n         tagData.scope.add({ first: \"Justin\" }),\n         tagData.options)\n\n       $(el).html( frag )\n    })\n\n    template({\n      last: \"Meyer\"\n    })\n\n",
    "description": "\n",
    "title": "tag",
    "name": "can-view-callbacks.tag",
    "type": "function",
    "parent": "can-view-callbacks/methods",
    "signatures": [
      {
        "code": "callbacks.tag(tagName, tagHandler(el, tagData))",
        "description": "\n\nRegisters the `tagHandler` callback when `tagName` is found\nin a template.\n\n```js\nvar $ = require(\"jquery\");\nrequire(\"jquery-datepicker\");\nvar canViewCallbacks = require(\"can-view-callbacks\");\n\ncanViewCallbacks.tag(\"date-picker\", function(el, tagData){\n\t$(el).datePicker();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "A lower-case, hypenated or colon-seperated html\ntag. Example: `\"my-widget\"` or `\"my:widget\"`.  It is considered a best-practice to\nhave a hypen or colon in all custom-tag names.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "can.view.Scope"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "HTMLElement"
                      }
                    ],
                    "name": "el"
                  },
                  {
                    "types": [
                      {
                        "type": "can.view.tagData"
                      }
                    ],
                    "name": "tagData"
                  }
                ]
              }
            ],
            "name": "tagHandler",
            "description": "\n\nAdds custom behavior to `el`.  If `tagHandler` returns data, it is used to\nrender `tagData.subtemplate` and the result is inserted as the childNodes of `el`.\n"
          }
        ],
        "release": "2.1"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "can.view.Scope"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ],
              "name": "el"
            },
            {
              "types": [
                {
                  "type": "can.view.tagData"
                }
              ],
              "name": "tagData"
            }
          ]
        }
      ],
      "name": "tagHandler",
      "description": "\n\nAdds custom behavior to `el`.  If `tagHandler` returns data, it is used to\nrender `tagData.subtemplate` and the result is inserted as the childNodes of `el`.\n"
    },
    "comment": " "
  },
  "can-view-callbacks.attrData": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/attrData.md"
    },
    "body": "\n",
    "description": "\nThe data provided to [can-view-callbacks.attr].\n",
    "type": "typedef",
    "title": "attrData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "scope",
            "description": "The scope of the element.\n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "The mustache helpers and other non-data values passed to the template.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          },
          {
            "name": "attributeName",
            "description": "The attribute name that was matched.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ],
        "description": "\n\n  ```js\n  var canViewCallbacks = require(\"can-view-callbacks\");\n  var stache = require(\"can-stache\");\n\n  canViewCallbacks.attr(\"my-attr\", function(el, attrData){\n    attrData.scope.peak(\"value\") //-> 123\n\tattrData.attributeName       //-> \"my-attr\"\n\n  });\n\n  stache(\"<div my-attr='value'/>\")({\n\t  value: 123\n  });\n  ```\n"
      }
    ],
    "name": "can-view-callbacks.attrData",
    "parent": "can-view-callbacks/types"
  },
  "can-view-callbacks.tagData": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/tagData.md"
    },
    "body": "\n",
    "description": "\nThe data passed to [can-view-callbacks.tag].\n",
    "type": "typedef",
    "title": "tagData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "subtemplate",
            "description": "If the special tag has content,\nthe content can be rendered with subtemplate.  For example:\n\n```js\ncallbacks.tag(\"foo-bar\", function(el, tagData){\n  var frag = tagData.subtemplate(tagData.scope, tagData.options);\n  $(el).html(frag);\n});\n```\n",
            "types": [
              {
                "type": "can-stache.renderer"
              }
            ],
            "optional": true
          },
          {
            "name": "scope",
            "description": "The scope of the element.  \n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "The mustache helpers and other non-data values passed to the template.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          }
        ],
        "description": "\n"
      }
    ],
    "name": "can-view-callbacks.tagData",
    "parent": "can-view-callbacks/types"
  },
  "can-view-nodelist/types/NodeList": {
    "src": {
      "path": "node_modules/can-view-nodelist/doc/NodeList.md"
    },
    "body": "\n",
    "description": "\nA collection of nodes being managed by a part of a live-bound template and\nreferences to other collections.\n",
    "type": "typedef",
    "title": "NodeList",
    "types": [
      {
        "type": "Array",
        "options": [],
        "description": "\n\n  A `NodeList` is an array of nodes that a part of a live-bound template manages.  For\n  example `{{name}}` might manage a single text node while something\n  like `{{#each todos}}{{name}}{{/each}}` might manage multiple nodes and other child.\n\n  NodeLists are primarily used to teardown live binding.  When a \"parent\" section of a template\n  is updated, every sub-section needs to be torn down.  NodeLists provide this structure.\n\n  __NOTE: The structure of a NodeList is purposefully not documented as it's subject to change.__\n"
      }
    ],
    "name": "can-view-nodelist/types/NodeList",
    "parent": "can-view-nodelist/types"
  },
  "can-view-parser.ParserHandler.attrEnd": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrEnd.md"
    },
    "body": "",
    "description": "",
    "title": "attrEnd",
    "name": "can-view-parser.ParserHandler.attrEnd",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "attrEnd(attrName)",
        "description": "\n\nCalled at the end of parsing an attribute; after the [can-view-parser.ParserHandler.attrStart] and [can-view-parser.ParserHandler.attrValue] functions have been called.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "The name of the attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The name of the attribute.\n"
    }
  },
  "can-view-parser": {
    "src": {
      "path": "node_modules/can-view-parser/docs/can-view-parser.md"
    },
    "body": "",
    "description": "Parse HTML and mustache tokens. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-parser",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "parse(html, handler, [returnIntermediate])",
        "description": "\n\nParse an html string:\n\n```js\nvar parser = require(\"can-view-parser\");\n\nvar html = '<h1><span bob=\"phillips\"></span><span bob=\"meyers\"></span>' +\n\t'</h1>';\n\nvar bobs = {};\nvar curAttr;\n\nparser(html, {\n\tattrStart: function(attrName){\n\t\tcurAttr = attrName;\n\t},\n\tattrValue: function(value){\n\t\tbobs[curAttr] = value;\n\t}\n});\n\nfor(var first in bobs) {\n\tvar last = bobs[first];\n\tconsole.log(\"Hello\", first, last);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "html",
            "description": "A mustache and html string to parse or an intermediate object the represents a previous parsing."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "handler",
            "description": "An object of callbacks."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "returnIntermediate",
            "defaultValue": "false",
            "description": "If true, returns a JS object representation of the parsing.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "returnIntermediate",
      "defaultValue": "false",
      "description": "If true, returns a JS object representation of the parsing.\n"
    }
  },
  "can-view-parser.ParserHandler.attrStart": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrStart.md"
    },
    "body": "",
    "description": "",
    "title": "attrStart",
    "name": "can-view-parser.ParserHandler.attrStart",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "attrStart(attrName)",
        "description": "\n\nCalled when an attribute is found on an element.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "The name of the attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The name of the attribute.\n"
    }
  },
  "can-view-parser.ParserHandler.attrValue": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrValue.md"
    },
    "body": "",
    "description": "",
    "title": "attrValue",
    "name": "can-view-parser.ParserHandler.attrValue",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "attrValue(value)",
        "description": "\n\nCalled when an attribute's **value** has been found.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The value discovered associated with an attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The value discovered associated with an attribute.\n"
    }
  },
  "can-view-parser.ParserHandler.chars": {
    "src": {
      "path": "node_modules/can-view-parser/docs/chars.md"
    },
    "body": "",
    "description": "",
    "title": "chars",
    "name": "can-view-parser.ParserHandler.chars",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "chars(value)",
        "description": "\n\nCalled when [CharacterData](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData) is found within a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The character data within the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The character data within the tag.\n"
    }
  },
  "can-view-parser.ParseHandler.close": {
    "src": {
      "path": "node_modules/can-view-parser/docs/close.md"
    },
    "body": "",
    "description": "",
    "title": "close",
    "name": "can-view-parser.ParseHandler.close",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "close(tagName)",
        "description": "\n\nCalled when a closing tag is found. If no closing tag exists for this tag (because it is self-closing) this function will not be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "tagName",
      "description": "The name of the tag.\n"
    }
  },
  "can-view-parser.ParserHandler.comment": {
    "src": {
      "path": "node_modules/can-view-parser/docs/comment.md"
    },
    "body": "",
    "description": "",
    "title": "comment",
    "name": "can-view-parser.ParserHandler.comment",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "comment(value)",
        "description": "\n\nCalled when a [Comment](https://developer.mozilla.org/en-US/docs/Web/API/Comment) is found within a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The Comment within the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The Comment within the tag.\n"
    }
  },
  "can-view-parser.ParserHandler.done": {
    "src": {
      "path": "node_modules/can-view-parser/docs/done.md"
    },
    "body": "",
    "description": "",
    "title": "done",
    "name": "can-view-parser.ParserHandler.done",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "done()",
        "description": "\n\nCalled at the end of parsing the template.\n",
        "params": []
      }
    ]
  },
  "can-view-parser.ParseHandler.end": {
    "src": {
      "path": "node_modules/can-view-parser/docs/end.md"
    },
    "body": "",
    "description": "",
    "title": "end",
    "name": "can-view-parser.ParseHandler.end",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "end(tagName, unary)",
        "description": "\n\nCalled at the end of parsing a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "unary",
            "description": "If this tag is unary (has no closing tag).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "unary",
      "description": "If this tag is unary (has no closing tag).\n"
    }
  },
  "can-view-parser.ParseHandler.start": {
    "src": {
      "path": "node_modules/can-view-parser/docs/start.md"
    },
    "body": "",
    "description": "",
    "title": "start",
    "name": "can-view-parser.ParseHandler.start",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "start(tagName, unary)",
        "description": "\n\nCalled when parsing a tag begins.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "unary",
            "description": "If this tag is unary (has no closing tag).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "unary",
      "description": "If this tag is unary (has no closing tag).\n"
    }
  },
  "can-view-parser.ParseHandler": {
    "src": {
      "path": "node_modules/can-view-parser/docs/parse-handler.md"
    },
    "body": "",
    "description": "An object consisting of callback functions that handle stages in the parsing process. \n",
    "type": "typedef",
    "title": "ParseHandler",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-parser.ParseHandler"
  },
  "can-view-scope.attr": {
    "src": {
      "path": "node_modules/can-view-scope/docs/attr.md"
    },
    "body": "\n## Use\n\n`scope.attr(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.attr(\"name\"); //-> \"Justin\"\n    curScope.attr(\"length\"); //-> 2\n\nPrefixing a key with `\"./\"` prevents any parent scope look ups.\nPrefixing a key with one or more `\"../\"` shifts the lookup path\nthat many levels up.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}];\n    list.name = \"Programmers\";\n    list.surname = \"CanJS\";\n\n    var justin = list[0];\n    var brian = list[1];\n    var curScope = new Scope(list).add(justin).add(brian);\n\n    curScope.attr(\"name\"); //-> \"Brian\"\n    curScope.attr(\"surname\"); //-> \"CanJS\"\n    curScope.attr(\"./surname\"); //-> undefined\n    curScope.attr(\"../name\"); //-> \"Justin\"\n    curScope.attr(\"../surname\"); //-> \"CanJS\"\n    curScope.attr(\".././surname\"); //-> \"undefined\"\n    curScope.attr(\"../../name\"); //-> \"Programmers\"\n\n",
    "description": "\n",
    "title": "attr",
    "name": "can-view-scope.attr",
    "type": "function",
    "signatures": [
      {
        "code": "scope.attr(key)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-mustache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.static": {
    "name": "can-view-scope.static",
    "title": "static",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope.prototype": {
    "name": "can-view-scope.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope.types": {
    "name": "can-view-scope.types",
    "title": "types",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope": {
    "src": {
      "path": "node_modules/can-view-scope/docs/can-view-scope.md"
    },
    "body": "\n## Use\n\nA [can-view-scope] represents a lookup context and parent contexts\nthat can be used to lookup a [can-stache.key key] value.\n\nIf no parent scope is provided, only the scope's context will be\nexplored for values.  For example:\n\n    var data = {name: {first: \"Justin\"}},\n    \tscope = new Scope(data);\n\n    scope.get(\"name.first\") //-> \"Justin\"\n    scope.get(\"length\")     //-> undefined\n\nHowever, if a `parent` scope is provided, key values will be\nsearched in the parent's context after the initial context is explored.  For example:\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n    \tjustin = list[0];\n\n    var listScope = new Scope(list),\n    \tcurScope = new Scope(justin, listScope)\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\nUse [can-view-scope::add add] to easily create a new scope from a parent scope like:\n\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n    \tjustin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\n",
    "description": "Create a lookup node for [can-mustache.key keys]. \n\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-scope",
    "parent": "can-infrastructure",
    "inherits": "can",
    "test": "can/view/scope/test.html",
    "signatures": [
      {
        "code": "new Scope(context, [parent], [meta] )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "A value that represents the\ncurrent context. This is often an object or observable and is the first\nplace a `key` is looked up.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope"
              }
            ],
            "optional": true,
            "name": "parent",
            "description": "The parent scope. If a `key` value\nis not found in the current scope, it will then look in the parent\nscope.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope/Meta"
              }
            ],
            "optional": true,
            "name": "meta",
            "description": "A configuration object that\ncan specify special behavior of the context.\n"
          }
        ],
        "release": "2.0.1",
        "returns": {
          "types": [
            {
              "type": "can-view-scope"
            }
          ],
          "description": "Returns a scope instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope/Meta"
        }
      ],
      "optional": true,
      "name": "meta",
      "description": "A configuration object that\ncan specify special behavior of the context.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-view-scope"
        }
      ],
      "description": "Returns a scope instance.\n"
    },
    "comment": " "
  },
  "can-view-scope.computeData": {
    "src": {
      "path": "node_modules/can-view-scope/docs/compute_data.md"
    },
    "body": "\n## Use\n\n`scope.computeData(key, options)` is used heavily by [can-mustache] to get the value of\na [can-mustache.key key] value in a template. Configure how it reads values in the\nscope and what values it returns with the [can-view-scope.readOptions options] argument.\n\n    var context = new Map({\n      name: {first: \"Curtis\"}\n    })\n    var scope = new Scope(context)\n    var computeData = scope.computeData(\"name.first\");\n\n    computeData.scope === scope //-> true\n    computeData.initialValue    //-> \"Curtis\"\n    computeData.compute()       //-> \"Curtis\"\n\nThe `compute` value is writable.  For example:\n\n    computeData.compute(\"Andy\")\n    context.attr(\"name.first\") //-> \"Andy\"\n\n",
    "description": "\n",
    "title": "computeData",
    "name": "can-view-scope.computeData",
    "type": "function",
    "signatures": [
      {
        "code": "scope.computeData(key)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope.readOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options that configure how the `key` gets read.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": [
                {
                  "name": "compute",
                  "description": "A compute that returns the\nvalue of `key` looked up in the scope's context or parent context. This compute can\nalso be written to, which will set the observable attribute or compute value at the\nlocation represented by the key.\n",
                  "types": [
                    {
                      "type": "can-compute.computed"
                    }
                  ]
                },
                {
                  "name": "scope",
                  "description": "The scope the key was found within. The key might have\nbeen found in a parent scope.\n",
                  "types": [
                    {
                      "type": "can-view-scope"
                    }
                  ]
                },
                {
                  "name": "initialData",
                  "description": "The initial value at the key's location.\n",
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An object with the following values:\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope.readOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options that configure how the `key` gets read.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "compute",
              "description": "A compute that returns the\nvalue of `key` looked up in the scope's context or parent context. This compute can\nalso be written to, which will set the observable attribute or compute value at the\nlocation represented by the key.\n",
              "types": [
                {
                  "type": "can-compute.computed"
                }
              ]
            },
            {
              "name": "scope",
              "description": "The scope the key was found within. The key might have\nbeen found in a parent scope.\n",
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "name": "initialData",
              "description": "The initial value at the key's location.\n",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An object with the following values:\n"
    },
    "types": [],
    "comment": " "
  },
  "can-view-scope.compute": {
    "src": {
      "path": "node_modules/can-view-scope/docs/compute.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "compute",
    "name": "can-view-scope.compute",
    "type": "function",
    "signatures": [
      {
        "code": "scope.compute(key, [options])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope.readOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options that configure how the `key` gets read.\n"
          }
        ],
        "release": "2.1",
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute that can get or set `key`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope.readOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options that configure how the `key` gets read.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute that can get or set `key`.\n"
    }
  },
  "can-view-scope.prototype.add": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.add.md"
    },
    "body": "\n## Use\n\n`scope.add(context)` creates a new scope object that\nfirst looks up values in context and then in the\nparent `scope` object.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\n",
    "description": "\n",
    "title": "add",
    "name": "can-view-scope.prototype.add",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.add(context [,meta])",
        "description": "\n\nCreates a new scope and sets the current scope to be the parent.\n\n```js\nvar scope = new Scope([\n   {name:\"Chris\"},\n   {name: \"Justin\"}\n]).add({name: \"Brian\"});\nscope.get(\"name\") //-> \"Brian\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "The context to add on top of the current scope."
          },
          {
            "types": [
              {
                "type": "can-view-scope/Meta"
              }
            ],
            "name": "meta",
            "description": "A meta option that can be used to configure special behaviors of this context.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope/Meta"
        }
      ],
      "name": "meta",
      "description": "A meta option that can be used to configure special behaviors of this context.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.compute": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.compute.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "compute",
    "name": "can-view-scope.prototype.compute",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.compute(key [, options])",
        "description": "\n\nGet a compute that is two-way bound to the `key` value in the scope. These computes\ncan be optimized beyond wrapping a compute around a call to [can-view-scope::get].\n\n```js\nscope.compute(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.peak": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.peak.md"
    },
    "body": "\n\n## Use\n\n`scope.peak(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.peak(\"name\"); //-> \"Justin\"\n    curScope.peak(\"length\"); //-> 2\n\n",
    "description": "\nRead a value from the scope without being observable.\n",
    "title": "peak",
    "name": "can-view-scope.prototype.peak",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.peak(key [, options])",
        "description": "\n\nWorks just like [can-view-scope.prototype.get], but prevents any calls to [can-observation.add].\n\n\nWalks up the scope to find a value at `key`.  Stops at the first context where `key` has\na value.\n\n```js\nscope.peak(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.get": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.get.md"
    },
    "body": "\n## Use\n\n`scope.get(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\"); //-> \"Justin\"\n    curScope.get(\"length\"); //-> 2\n\nPrefixing a key with `\"./\"` prevents any parent scope look ups.\nPrefixing a key with one or more `\"../\"` shifts the lookup path\nthat many levels up.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}];\n    list.name = \"Programmers\";\n    list.surname = \"CanJS\";\n\n    var justin = list[0];\n    var brian = list[1];\n    var curScope = new Scope(list).add(justin).add(brian);\n\n    curScope.get(\"name\"); //-> \"Brian\"\n    curScope.get(\"surname\"); //-> \"CanJS\"\n    curScope.get(\"./surname\"); //-> undefined\n    curScope.get(\"../name\"); //-> \"Justin\"\n    curScope.get(\"../surname\"); //-> \"CanJS\"\n    curScope.get(\".././surname\"); //-> \"undefined\"\n    curScope.get(\"../../name\"); //-> \"Programmers\"\n\n",
    "description": "\n",
    "title": "get",
    "name": "can-view-scope.prototype.get",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.get(key [, options])",
        "description": "\n\nWalks up the scope to find a value at `key`.  Stops at the first context where `key` has\na value.\n\n```js\nscope.get(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.Options": {
    "src": {
      "path": "node_modules/can-view-scope/docs/static.Options.md"
    },
    "body": "\nA Scope that can be used to lookup stache helpers.\n\n",
    "description": "\n",
    "title": "Options",
    "name": "can-view-scope.Options",
    "type": "function",
    "parent": "can-view-scope.static"
  },
  "can-view-scope.prototype.set": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.set.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "set",
    "name": "can-view-scope.prototype.set",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.set(key, value [, options])",
        "description": "\n\nTries to set `key` in the scope to `value`.  This looks for the first context in the value where\n`key` can be set.  For example, if `key` is `\"person.first.name\"`, it will find the first\ncontext where `person.first` is some type of Object whose `name` property can be set.\n\n```js\nscope.set(\"person.first.name\", \"Justin\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to be set.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value to be set.\n"
    },
    "comment": " "
  },
  "can-view-scope.Refs": {
    "src": {
      "path": "node_modules/can-view-scope/docs/static.Refs.md"
    },
    "body": "",
    "description": "\n",
    "title": "Refs",
    "name": "can-view-scope.Refs",
    "type": "function",
    "parent": "can-view-scope.static",
    "hide": true
  },
  "can-view-scope/Meta": {
    "src": {
      "path": "node_modules/can-view-scope/docs/types.Meta.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "Meta",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "notContext",
            "description": "The context should not be reference-able with `./` or `../`.\n",
            "types": [
              {
                "type": "Boolean"
              }
            ]
          }
        ],
        "description": "\n\n  Specify special behavior of a scope.\n\n"
      }
    ],
    "name": "can-view-scope/Meta",
    "parent": "can-view-scope.types"
  },
  "can-zone.prototype.addWait": {
    "src": {
      "path": "node_modules/can-zone/docs/addWait.md"
    },
    "body": "",
    "description": "\n",
    "title": "addWait",
    "name": "can-zone.prototype.addWait",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.addWait()",
        "description": "\n\nAdds a wait to the [can-zone Zone]. Adding a wait will delay the Zone's Promise from resolving (the promise created by calling [can-zone.prototype.run zone.run]) by incrementing its internal counter.\n\nUsually a corresponding [can-zone.prototype.removeWait] will be called to decrement the counter.\n\n```js\nnew Zone().run(function(){\n\n\tvar zone = Zone.current;\n\n\tzone.addWait(); // counter at 1\n\tzone.removeWait(); // counter at 0, Promise resolves\n\n}).then(function(){\n\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.ZoneSpec": {
    "src": {
      "path": "node_modules/can-zone/docs/ZoneSpec.md"
    },
    "body": "",
    "description": " A ZoneSpec is the way you tap into the lifecycle hooks of a [can-zone Zone]. The hooks are described below.\n\nUsing these hooks you can do things like create timers and override global variables that will change the *shape* of code that runs within the Zone.\n\n",
    "type": "typedef",
    "title": "ZoneSpec",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "created",
            "description": "\n\nCalled when the zone is first created, after all ZoneSpecs have been parsed. this is useful if you need to do setup behavior that covers the entire zone lifecycle.\n\n```js\nnew Zone({\n\tcreated: function(){\n\t\t// Called as soon as `new Zone` is called\n\t}\n});\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "beforeRun",
            "description": "\n\nCalled immediately before the **Zone.prototype.run** function is called.\n\n```js\nvar zone = new Zone({\n\tbeforeRun: function(){\n\t\t// Setup that needs to happen immediately before running\n\t\t// the zone function\n\t}\n});\n\nzone.run(function() { ... });\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "beforeTask",
            "description": "\n\nCalled before each Task is called. Use this to override any globals you want to exist during the execution of the task:\n\n```js\nnew Zone({\n\tbeforeTask: function(){\n\t\twindow.setTimeout = mySpecialSetTimeout;\n\t}\n});\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "ended",
            "description": "\n\nCalled when the Zone has ended and is about to exit (it's Promise will resolve).\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "hooks",
            "description": "\n\n**hooks** allows you to specify custom hooks that your plugin calls. This is mostly to communicate between plugins that inherit each other.\n\n```js\nvar barZone = {\n\tcreated: function(){\n\t\tthis.execHook(\"beforeBar\");\n\t},\n\n\thooks: [\"beforeBar\"]\n};\n\nvar fooZone = {\n\tbeforeBar: function(){\n\t\t// Called!\n\t},\n\tplugins: [barZone]\n};\n\nnew Zone({\n\tplugins: [fooZone]\n});\n\nzone.run(function() { ... });\n```\n",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "string"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "name": "plugins",
            "description": "\n\nAllows specifying nested [can-zone.ZoneSpec ZoneSpecs] that the current depends on. This allows creating rich plugins that depend on other plugins (ZoneSpecs). You can imagine having a bunch of tiny plugins that do one thing and then composing them together into one meta-plugin that is more end-user friendly.\n\nSimilar to the [can-zone Zone] constructor you can either specify [can-zone.ZoneSpec] objects or functions that return ZoneSpec objects. The former gives you a closure specific to the Zone, which is often needed for variables. These two forms are equivalent:\n\n```js\nvar specOne = {\n\tcreated: function(){\n\n\t}\n};\n\nvar specTwo = function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t}\n};\n\nvar zone = new Zone({\n\tplugins: [ specOne, specTwo ]\n});\n```\n",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-zone.ZoneSpec"
                      },
                      {
                        "type": "can-zone.makeZoneSpec"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone.ZoneSpec",
    "parent": "can-zone.types"
  },
  "can-zone.static": {
    "name": "can-zone.static",
    "title": "static",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.prototype": {
    "name": "can-zone.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.types": {
    "name": "can-zone.types",
    "title": "types",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.modules": {
    "name": "can-zone.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.plugins": {
    "name": "can-zone.plugins",
    "title": "plugins",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone": {
    "src": {
      "path": "node_modules/can-zone/docs/can-zone.md"
    },
    "body": "\n## Use\n\n**can-zone** is a library that aids in tracking asynchronous calls in your application. To create a new Zone call it's constructor function with `new`:\n\n```js\nvar zone = new Zone();\n```\n\nThis gives you a [can-zone Zone] from which you can run code using [can-zone.prototype.run zone.run]:\n\n```js\nzone.run(function(){\n\t\n\tsetTimeout(function(){\n\n\t}, 500);\n\n})\nthen(function(){\n\n});\n```\n\nThe function you provide to [can-zone.prototype.run] will be run within the Zone. This means any calls to asynchronous functions (in this example `setTimeout`)\twill be waited on.\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone",
    "parent": "can-ecosystem",
    "signatures": [
      {
        "code": "new Zone()",
        "description": "\n\nCreates a new Zone with no additional overrides. Can then call [can-zone.prototype.run zone.run] to call a function within the Zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar zone = new Zone();\n\nzone.run(function(){\n\n\treturn \"hello world\";\n\n}).then(function(data){\n\tdata.result // -> \"hello world\"\n});\n```\n",
        "params": []
      },
      {
        "code": "new Zone(zoneSpec)",
        "description": "\n\nCreate a new Zone using the provided [can-zone.ZoneSpec] to configure the Zone. The following examples configures a Zone that will time out after 5 seconds.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar timeoutSpec = function(){\n\tvar timeoutId;\n\n\treturn {\n\t\tcreated: function(){\n\t\t\ttimeoutId = setTimeout(function(){\n\t\t\t\tZone.error(new Error(\"This took too long!\"));\n\t\t\t}, 5000);\n\t\t},\n\t\tended: function(){\n\t\t\tclearTimeout(timeoutId);\n\t\t}\n\t};\n};\n\nvar zone = new Zone(timeoutSpec);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-zone.ZoneSpec"
              },
              {
                "type": "can-zone.makeZoneSpec"
              }
            ],
            "name": "zoneSpec",
            "description": "A [can-zone.ZoneSpec] object or a [can-zone.makeZoneSpec function that returns] a ZoneSpec object.\n\nThese two are equivalent:\n\n```js\nnew Zone({\n\tcreated: function(){\n\t\t\n\t}\n});\n\nnew Zone(function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t};\n});\n```\n\nThe latter form is useful so that you have a closure specific to that [can-zone Zone].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        },
        {
          "type": "can-zone.makeZoneSpec"
        }
      ],
      "name": "zoneSpec",
      "description": "A [can-zone.ZoneSpec] object or a [can-zone.makeZoneSpec function that returns] a ZoneSpec object.\n\nThese two are equivalent:\n\n```js\nnew Zone({\n\tcreated: function(){\n\t\t\n\t}\n});\n\nnew Zone(function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t};\n});\n```\n\nThe latter form is useful so that you have a closure specific to that [can-zone Zone].\n"
    },
    "comment": " "
  },
  "can-zone.current": {
    "src": {
      "path": "node_modules/can-zone/docs/current.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "can-zone"
      }
    ],
    "title": "current",
    "name": "can-zone.current",
    "type": "property",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.current",
        "description": "\n\nRepresents the currently running [can-zone zone]. If the code using **Zone.current** is not running within a zone the value will be undefined.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar myZone = new Zone();\n\nmyZone.run(function(){\n\n\tZone.current === myZone;\n\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.prototype.data": {
    "src": {
      "path": "node_modules/can-zone/docs/data.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "data",
    "name": "can-zone.prototype.data",
    "type": "property",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.data",
        "description": "\n\nYou might want to get data back from can-zone, for example if you are using the library to track asynchronous rendering requests. Each zone contains a **data** object which can be used to store artibitrary values.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"http://example.com\");\nxhr.onload = function(){\n\t// Save this data for later\n\tZone.current.data.xhr = xhr.responseText;\n};\nxhr.send();\n```\n\n",
        "params": []
      }
    ]
  },
  "can-zone/register": {
    "src": {
      "path": "node_modules/can-zone/docs/register.md"
    },
    "body": "",
    "description": " \nIn order to do it's magic, [can-zone] has to register handlers for all of the common JavaScript async operations. If you have code (or a dependency with this code) that does:\n\n```js\nvar st = setTimeout;\n```\n\nAnd this module loads before can-zone, any time `st` is used we won't be able to track that within the Zone.\n\nTo work around this, **can-zone/register** is used as a script that you run before any other modules.\n\n### In Node\n\n```js\nrequire(\"can-zone/register\");\n```\n\nAt the top of your entry-point script.\n\n### In the Browser\n\nYou can either add a script tag above all others:\n\n```js\n<script src=\"node_modules/can-zone/register.js\"></script>\n```\n\nOr, if you're using a module loader / bundler, configure it so that can-zone/register is placed above all others in the bundle.\n\n",
    "type": "module",
    "title": "can-zone/register",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone/register",
    "parent": "can-zone.modules"
  },
  "can-zone.error": {
    "src": {
      "path": "node_modules/can-zone/docs/error.md"
    },
    "body": "",
    "description": "\n",
    "title": "error",
    "name": "can-zone.error",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.error(err)",
        "description": "\n\nAllows you to add an error to the currently running zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\n\tsetTimeout(function(){\n\t\tZone.error(new Error(\"oh no\"));\n\t}, 100);\n\n}).then(null, function(error){\n\terror; // -> {message: \"oh no\"}\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Error"
              }
            ],
            "name": "err",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Error"
        }
      ],
      "name": "err",
      "description": "\n"
    }
  },
  "can-zone.ignore": {
    "src": {
      "path": "node_modules/can-zone/docs/ignore.md"
    },
    "body": "\n## Use\n\n**Zone.ignore** is used to prevent a function from being waited on within a Zone. Normally a Zone's calls to functions like `setTimeout` and `XMLHttpRequest` are waited on before the [can-zone.prototype.run run promise] is resolved, but in some cases you might not want to wait on these calls; for example if there is a very long delay or a delay that will not result in rendering to take place.\n\nProvide Zone.ignore a function and it will return a function that can be called in it's place.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar fn = Zone.ignore(function(){\n\t// do any asynchronous stuff here\n});\n\nfn(); // waits ignored\n```\n\n",
    "description": "\n",
    "title": "ignore",
    "name": "can-zone.ignore",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.ignore(fn)",
        "description": "\n\nCreates a function that, when called, will not track any calls. This might be needed if you are calling code that does unusual things, like using setTimeout recursively indefinitely.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\tfunction recursive(){\n\t\tsetTimeout(function(){\n\t\t\trecursive();\n\t\t}, 20000);\n\t}\n\n\tvar fn = Zone.ignore(recursive);\n\n\t// This call will not be waited on.\n\tfn();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "A function that contains calls to asynchronous functions that are needing to be ignored.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function in which calls to [can-zone.prototype.addWait] and [can-zone.prototype.removeWait] will be ignored, preventing the Zone's promise from remaining unresolved while asynchronous activity continues within.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "A function that contains calls to asynchronous functions that are needing to be ignored.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function in which calls to [can-zone.prototype.addWait] and [can-zone.prototype.removeWait] will be ignored, preventing the Zone's promise from remaining unresolved while asynchronous activity continues within.\n"
    },
    "comment": " "
  },
  "can-zone.prototype.removeWait": {
    "src": {
      "path": "node_modules/can-zone/docs/removeWait.md"
    },
    "body": "",
    "description": "\n",
    "title": "removeWait",
    "name": "can-zone.prototype.removeWait",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.removeWait()",
        "description": "\n\nDecrements the [can-zone Zone's] internal counter that is used to decide when its [can-zone.prototype.run run Promise] will resolve.\n\nUsually used in conjuction with [can-zone.prototype.addWait]. Most of the time you'll want to use [can-zone.waitFor], but in some cases where a callback is not enough to know waiting is complete, using addWait/removeWait gives you finer grained control.\n\n```js\nvar zone = new Zone();\n\nvar obj = new SomeObject();\n\n// This is only done when the event.status is 3\nobj.onprogress = function(ev){\n\tif(ev.status === 3) {\n\t\tzone.removeWait();\n\t}\n};\n\nzone.addWait();\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.prototype.run": {
    "src": {
      "path": "node_modules/can-zone/docs/run.md"
    },
    "body": "",
    "description": "\n",
    "title": "run",
    "name": "can-zone.prototype.run",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.run(fn)",
        "description": "\n\nRuns a function within a [can-zone Zone]. Calling run will set the Zone's internal Promise which will only resolve once all asynchronous calls within `fn` are complete.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "Any function which needs to run within the Zone. The function will be executed immediately.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-zone.prototype.data"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that will resolve with the Zone's [can-zone.prototype.data] object.\n\n```js\nvar zone = new Zone();\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\t\tzone.data.foo = \"bar\";\n\t});\n\n}).then(function(data){\n\tdata.foo // -> \"bar\"\n});\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "Any function which needs to run within the Zone. The function will be executed immediately.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-zone.prototype.data"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that will resolve with the Zone's [can-zone.prototype.data] object.\n\n```js\nvar zone = new Zone();\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\t\tzone.data.foo = \"bar\";\n\t});\n\n}).then(function(data){\n\tdata.foo // -> \"bar\"\n});\n```\n"
    }
  },
  "can-zone.waitFor": {
    "src": {
      "path": "node_modules/can-zone/docs/waitFor.md"
    },
    "body": "",
    "description": "\n",
    "title": "waitFor",
    "name": "can-zone.waitFor",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.waitFor(fn)",
        "description": "\n\n**Zone.waitFor** is a function that creates a callback that can be used with any async functionality. Calling Zone.waitFor registers a wait with the currently running request and returns a function that, when called, will decrement the wait count.\n\nThis is useful if there is async functionality other than what [we implement](#tasks). You might be using a library that has C++ bindings and doesn't go through the normal JavaScript async APIs.\n\n```js\nvar Zone = require(\"can-zone\");\nvar fs = require(\"fs\");\n\nfs.readFile(\"data.json\", \"utf8\", Zone.waitFor(function(){\n\t// We waited on this!\n}));\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "\n"
    }
  },
  "can-zone.makeZoneSpec": {
    "src": {
      "path": "node_modules/can-zone/docs/makeZoneSpec.md"
    },
    "body": "\nUsing a function rather than a ZoneSpec object gives you a closure where you can store local variables that will be specific to the [can-zone Zone] you are running in.\n\n",
    "description": "\nA function that returns a [can-zone.ZoneSpec] object. This can be used any place where a [can-zone.ZoneSpec] is accepted.\n",
    "type": "typedef",
    "title": "makeZoneSpec",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "can-zone.ZoneSpec"
            }
          ],
          "description": "A [can-zone.ZoneSpec]\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-zone.prototype.data"
              }
            ],
            "name": "data",
            "description": "The [can-zone Zone's] data object, useful when you want to append data to the Zone.\n\nThis examples wraps [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to keep count of how many elements are created, and appends the count to [can-zone.prototype.data] when the Zone ends.\n\n```js\nvar mySpec = function(data){\n\tvar realCreateElement,\n\t\tcount = 0;\n\n\treturn {\n\t\tbeforeTask: function(){\n\t\t\trealCreateElement = document.createElement;\n\t\t\tdocument.createElement = function(){\n\t\t\t\tcount++;\n\t\t\t\treturn realCreateElement.apply(this, arguments);\n\t\t\t};\n\t\t},\n\t\tafterTask: function(){\n\t\t\tdocument.createElement = realCreateElement;\n\t\t},\n\t\tended: function(){\n\t\t\tdata.elementsCreated = count;\n\t\t}\n\t};\n};\n\nvar zone = new Zone(mySpec);\n\nzone.run(function(){\n\t// Do stuff here\n})\n.then(function(data){\n\tdata.elementsCreated; // -> 5\n});\n```\n"
          }
        ]
      }
    ],
    "name": "can-zone.makeZoneSpec",
    "parent": "can-zone.types",
    "_curParam": {
      "types": [
        {
          "type": "can-zone.prototype.data"
        }
      ],
      "name": "data",
      "description": "The [can-zone Zone's] data object, useful when you want to append data to the Zone.\n\nThis examples wraps [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to keep count of how many elements are created, and appends the count to [can-zone.prototype.data] when the Zone ends.\n\n```js\nvar mySpec = function(data){\n\tvar realCreateElement,\n\t\tcount = 0;\n\n\treturn {\n\t\tbeforeTask: function(){\n\t\t\trealCreateElement = document.createElement;\n\t\t\tdocument.createElement = function(){\n\t\t\t\tcount++;\n\t\t\t\treturn realCreateElement.apply(this, arguments);\n\t\t\t};\n\t\t},\n\t\tafterTask: function(){\n\t\t\tdocument.createElement = realCreateElement;\n\t\t},\n\t\tended: function(){\n\t\t\tdata.elementsCreated = count;\n\t\t}\n\t};\n};\n\nvar zone = new Zone(mySpec);\n\nzone.run(function(){\n\t// Do stuff here\n})\n.then(function(data){\n\tdata.elementsCreated; // -> 5\n});\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        }
      ],
      "description": "A [can-zone.ZoneSpec]\n"
    }
  },
  "guides/chat": {
    "src": {
      "path": "docs/can-guides/experiment/chat/chat.md"
    },
    "body": "\n\n## Setup\n\nThe easiest way to get started is to clone the following JSBin by clicking the __JS Bin__ button on the top left:\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/fezewi/3/edit?html,output\">JS Bin on jsbin.com</a>\n\nThe JSBin loads [http://getbootstrap.com/ Bootstrap] for its styles. And [http://socket.io/ socket.io] for a socket\nlibrary.  It will be connecting to a restful and real-time service layer at [http://chat.donejs.com/api/messages].\n\nThe JSBin also loads [can.all.js](https://github.com/canjs/canjs/blob/v3.0.0-pre.11/dist/global/can.js), which is a script that includes all of CanJS core under a\nsingle global `can` namespace.\n\nGenerally speaking, you should not use the global can script and instead\nshould import things directly with a module loader like [StealJS](http://stealjs.com),\nWebPack or Browserify.  In a real app your code will look like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({ ... });\nTodo.List = DefineList.extend({ ... });\n```\n\nNot:\n\n```js\nvar Todo = can.DefineMap.extend({ ... });\nTodo.List = can.DefineList.extend({ ... });\n```\n\nRead [guides/setup] on how to setup CanJS in a real app.\nCheckout [https://donejs.com/Guide.html the DoneJS version of this guide].\n\n\n\n## Hello World\n\nIn this section, we will:\n\n - Show a big \"Chat Home\" within a bootstrap container.\n - Make it when \"Chat Home\" is clicked, a \"!\" is added to the end of the title.\n\nUpdate the `HTML` tab to:\n\n - To create a `<script>` tag containing the content of the `chat-template` template.\n - Have the content insert a `message` value within a responsive Bootstrap container using [can-stache.tags.escaped].\n - Listen for `click` events and call `addExcitement` with [can-stache-bindings.event].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Hello World\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n        {{message}}\n      </h1>\n    </div>\n  </div>\n</div>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='12-22,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Define an application view-model (`AppVM`) type by extending [can-define/map/map]. Its definition includes:\n   - A `message` property that is a [can-define.types string]\n     value [can-define.types.value initialized] to `\"Chat Home\"`.\n   - An `addExcitement` method that adds `\"!\"` to the end of the `message` property.\n - Create an instance of the `AppVM` type (`appVM`).\n - Compile a [can-stache] [can-stache.renderer template renderer] function from the contents of the `<script>` tag.\n - Render that template with `appVM` as a source of data into a [https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment document fragment].\n - Insert the document fragment into the `<body>` tag.\n\n\n```js\nvar AppVM = can.DefineMap.extend({\n\tmessage: {\n\t\ttype: \"string\",\n\t\tvalue: \"Chat Home\"\n\t},\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-15,only'></span>\nWhen complete, you should see a large \"Chat Home\" in the `Output` panel.  Click on it and\nthings will get really exciting!\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/chat/1-hello-world/completed.webm\" type=\"video/webm\">\n   <source src=\"../../docs/can-guides/experiment/chat/1-hello-world/completed.ogg\" type=\"video/ogg\">\n</video>\n\nThis step sets up the essential basics of a CanJS application - a\n[can-stache] template rendered with an observable application view model instance.\n\nThe properties and methods the template uses are defined in the `AppVM`\ntype.  The `AppVM` type extends [can-define/map/map].  We\ndefined a `message` and an `addExcitement` method.\n\nWe then created an instance of the `appVM` with the `new` operator. This created\nan object with a `message` property and `addExcitement` method.  For example, adding:\n\n```\nconsole.log(appVM.message)\nappVM.addExcitement();\nconsole.log(appVM.message)\n```\n\nWill print out `\"Chat Home\"` and then `\"Chat Home!\"`.\n\n`DefineMap` instances are observable.  This is why when `message` changes,\nthe template updates automatically.\n\nThe templates are a dialect of [mustache] and [handlebars] syntax.  The\nmustache syntax allows a very terse writing style for the most common\npatterns within templates:\n\n - inserting data with [can-stache.tags.escaped]\n - looping with [can-stache.helpers.each]\n - branching with [can-stache.helpers.if] or [can-stache.helpers.is]\n\n\n\n> __Key take away:__ You define types like `AppVM` with method and property behaviors.\n> Instances of those types are observable by [can-stache] templates.\n\n\n## Route between two pages\n\nIn this section we will:\n\n - Create a __home page__ and __chat messages page__ that the user can navigate between\n   with links and the browser's back and forward button.\n\nUpdate the `HTML` tab to:\n\n - Check if the `appVM`'s `page` property is 'home'.  If it is, render the __home\n   page__'s content.  If it's not, it will render the __chat messages page__'s content (using [can-stache.helpers.else]).\n - Use [can-stache.helpers.routeUrl] to create the right link urls so that `page`\n   will be set on `appVM` to either `\"home\"` or `\"chat\"`.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t  \t <h1 class=\"page-header text-center\">\n\t\t \tChat Messages\n\t\t </h1>\n\t\t <h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='16-29,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Add a `page` property that will be updated when the browser's URL changes.\n - Prevent the `message` property from becoming part of the URL changes.\n - Connect changes in the url to changes in the `appVM` with [can-route.data].\n - Create a pretty routing rule so if the url looks like `\"#!chat\"`, the `page` property of\n   `appVM` will be set to `chat` with [can-route].  If there is nothing in the hash, `page`\n   will be set to `\"home\"`.\n - Initialize the url's values on `appVM` and setup the two way connection with [can-route.ready].\n\n\n```js\nvar AppVM = can.DefineMap.extend({\n    route: \"string\",\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\":page\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='2-3,7,16-18,only'></span>\nWhen complete, you should be able to toggle between the two pages.  If you type:\n\n```\nwindow.location.hash\n```\n\nin JSBin's console tab after clicking a new page, you will be able to see the hash change between `!#` and `#!chat`.\n\n\nThis step sets up a basic routing between different \"pages\" in an application.\nCanJS's routing is based on the properties in the application view model.  When\nthose properties change, different content is shown.  \n\nWe connected the application view model to the routing system with [can-route.data can-route.data]\nand initialized that connection with [can-route.ready can-route.ready].\n\nThis makes it so if the `page` property changes, the browser's url will change.  If the\nbrowser's url changes, the `page` property changes.  \n\n> __Key take away:__  [can-route] connects changes in the browser's url to\nchanges in the application view model and vice versa.  Use changes in\nthe application view model to control which content is shown.\n\n\n## Chat Messages Component\n\nIn this section, we will:\n\n- Define and use a custom `<chat-message>` element that contains the behavior of the __chat messages page__.\n\nUpdate the `HTML` tab to:\n\n- Use the `<chat-messages/>` element.\n- Create a template for the `<chat-messages/>` element that contains the content of the\n  __chat messages page__.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Chat Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='25,32-37,only'></span>\nUpdate the `JavaScript` tab to:\n\n- Define a view model for the custom element (`ChatMessagesVM`).\n- Using [can-component] define a custom element that will render its `view` template with\n  an instance of its `ViewModel`.\n\n\n```js\nvar ChatMessagesVM = can.DefineMap.extend({\n\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    route: \"string\",\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\":page\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-9,only'></span>\nWhen complete, you should see the same behavior as the previous step. You should\nbe able to click back and forth between the two different pages.\n\n\nThis step creates the `<chat-messages>` custom element.  Custom elements are used\nto represent some grouping of related (and typically visual) functionality such as:\n\n - Widgets like `<my-slider>`, or `<acme-navigation>`.\n - Pages like `<chat-login>` or `<chat-messages>`.\n\nCustom elements are the macroscopic building blocks of an application.  They\nare the [orchestration pieces](https://en.wikipedia.org/wiki/Orchestration_(computing))\nused to assemble the application into a whole.  \n\nFor example, an application's template might assemble many custom elements\nto work together like:\n\n```\n{{#if session}}\n  <app-toolbar {(selected-files)}=\"selectedFiles\"/>\n  <app-directory {(selected-files)}=\"selectedFiles\"/>\n  <app-files {(selected-files)}=\"selectedFiles\"/>\n  <app-file-details {(selected-files)}=\"selectedFiles\"/>\n{{else}}\n  <app-login/>\n{{/if}}\n```\n\nBreaking down an application into many isolated, and potentially reusable components\nis a critical piece of CanJS software architecture.\n\nCustom elements are defined with [can-component].  Components render their `view` within\nthe element with an instance of their `ViewModel`.  By default their `view` only\nhas access to that data in the `ViewModel`.  You can use [can-stache-bindings event and data bindings] like [can-stache-bindings.toChild] and [can-stache-bindings.twoWay] to pass data\nbetween custom elements.\n\n> __Key take away:__  [can-component] makes custom elements. Break down your application\ninto many bit-sized custom elements.\n\n## List Messages\n\nIn this section, we will:\n\n - Display messages from [http://chat.donejs.com/api/messages](http://chat.donejs.com/api/messages)\n - Show a \"Loading...\" message while the messages are loading.\n - Show an error if those messages fail to load.\n\nUpdate the `HTML` tab to:\n\n - Check if the messages are in the process of loading and show a loading indicator.\n - Check if the messages failed to load and display the reason for the failure.\n - If messages successfully loaded, list each message's name and body.  If there\n   are no messages, write out \"No messages\".\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - List Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\n{{#if messagesPromise.isPending}}\n  <div class=\"list-group-item list-group-item-info\">\n    <h4 class=\"list-group-item-heading\">Loading...</h4>\n  </div>\n{{/if}}\n{{#if messagesPromise.isRejected}}\n  <div class=\"list-group-item list-group-item-danger\">\n    <h4 class=\"list-group3--item-heading\">Error</h4>\n\t<p class=\"list-group-item-text\">{{messagesPromise.reason}}</p>\n  </div>\n{{/if}}\n{{#if messagesPromise.isResolved}}\n  {{#each messagesPromise.value}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group3--item-heading\">{{name}}</h4>\n  \t  <p class=\"list-group-item-text\">{{body}}</p>\n    </div>\n  {{else}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group-item-heading\">No messages</h4>\n    </div>\n  {{/each}}\n{{/if}}\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='38-60,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Define a `Message` type with [can-define/map/map].\n - Define a `Message.List` type that contains `Message` items.\n - Connect the `Message` and `Message.List` type to\n   the restful messages service at `http://chat.donejs.com/api/messages`\n   using [can-connect/can/super-map/super-map].\n - Create a `messagesPromise` property on `ChatMessagesVM` that's\n   [can-define.types.value] is initialized to a [ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise]\n   that represents the loading of all messages using [can-connect/can/map/map.getList].\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'http://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    route: \"string\",\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\":page\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-20,23-27,only'></span>\nWhen complete, you should see a list of messages in the __chat messages page__.\n\nThis step creates a `Message` model, by first creating the `Message` type\nand then connecting it to a messages service at `http://chat.donejs.com/api/messages`. This\nadds [can-connect/can/map/map methods] to the `Message` type that let you:\n\n - Get a list of messages:\n   ```js\n   Message.getList({}).then(function(messages){})\n   ```\n\n - Get a single message:\n   ```js\n   Message.get({id: 5}).then(function(message){})\n   ```\n - Create a message on the server:\n   ```js\n   message = new Message({name: \"You\", body: \"Hello World\"})\n   message.save()\n   ```\n - Update a message on the server:\n   ```js\n   message.body = \"Welcome Earth!\";\n   message.save();\n   ```\n - Delete message on the server:\n   ```js\n   message.destroy();\n   ```\n\nThere are also methods to let you know when a message\n[can-connect/can/map/map.prototype.isNew],\n[can-connect/can/map/map.prototype.isSaving], and\n[can-connect/can/map/map.prototype.isDestroying].\n\nWith the message model created, it's used to load and list messages on the server.\n\n\n> __Key take away:__ Create a model to connect to backend data.\n\n## Create Messages\n\nIn this section, we will:\n\n- Add the ability to create messages on the server and have them added to the list of messages.\n\n\nUpdate the `HTML` tab to:\n\n - Create a form to enter a message's `name` and `body`.\n - When the form is submitted, call `send` on the `ChatMessagesVM` with [can-stache-bindings.event].\n - Connect the first `<input>`'s `value` to the `ChatMessagesVM`'s `name` property with [can-stache-bindings.twoWay].\n - Connect the second `<input>`'s `value` to the `ChatMessagesVM`'s `body` property with [can-stache-bindings.twoWay].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Create Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\n{{#if messagesPromise.isPending}}\n  <div class=\"list-group-item list-group-item-info\">\n    <h4 class=\"list-group-item-heading\">Loading...</h4>\n  </div>\n{{/if}}\n{{#if messagesPromise.isRejected}}\n  <div class=\"list-group-item list-group-item-danger\">\n    <h4 class=\"list-group3--item-heading\">Error</h4>\n\t<p class=\"list-group-item-text\">{{messagesPromise.reason}}</p>\n  </div>\n{{/if}}\n{{#if messagesPromise.isResolved}}\n  {{#each messagesPromise.value}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group3--item-heading\">{{name}}</h4>\n  \t  <p class=\"list-group-item-text\">{{body}}</p>\n    </div>\n  {{else}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group-item-heading\">No messages</h4>\n    </div>\n  {{/each}}\n{{/if}}\n\n<form class=\"row\" ($submit)=\"send(%event)\">\n\t<div class=\"col-sm-3\">\n\t  <input type=\"text\" class=\"form-control\" placeholder=\"Your name\"\n\t\t\t {($value)}=\"name\"/>\n\t</div>\n\t<div class=\"col-sm-6\">\n\t  <input type=\"text\" class=\"form-control\" placeholder=\"Your message\"\n\t\t\t {($value)}=\"body\"/>\n\t</div>\n\t<div class=\"col-sm-3\">\n\t  <input type=\"submit\" class=\"btn btn-primary btn-block\" value=\"Send\"/>\n\t</div>\n</form>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='62-74,only'></span>\nUpdate the `JS` tab to:\n\n- Define a `name` and `body` property on `ChatMessagesVM`.\n- Define a `send` method on `ChatMessagesVM` that creates a new `Message` and saves it to the server.\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'http://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t},\n\tname: \"string\",\n\tbody: \"string\",\n\tsend: function(event) {\n\t    event.preventDefault();\n\n\t\tnew Message({\n\t\t\tname: this.name,\n\t\t\tbody: this.body\n\t\t}).save().then(function(){\n\t\t\tthis.body = \"\";\n\t\t}.bind(this));\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    route: \"string\",\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\":page\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='28-39,only'></span>\nWhen complete, you will be able to create messages and have them appear in the list.\n\nThis step sets up a form to create a `Message` on the server.\nNotice that the new `Message` automatically appears in the list of messages. This\nis because [can-connect/can/super-map/super-map] ads the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically will inserted newly created messages into\nlists that they belong within.  This is one of CanJS's best features - automatic list management.\n\n> __Key take away:__ CanJS will add, remove, and update lists for you automatically.\n\n## Real Time\n\nIn this section, we will:\n\n - Listen to messages created by other users and add them to the list of messages.\n\nUpdate the `JavaScript` tab to:\n\n- Create a [http://socket.io/] connection (`socket`).\n- Listen to when messages are created, updated, and destroyed and and call the\n  corresponding [can-connect/real-time/real-time] methods.\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'http://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar socket = io('http://chat.donejs.com');\n\nsocket.on('messages created', function(message){\n\tMessage.connection.createInstance(message);\n});\nsocket.on('messages updated', function(message){\n\tMessage.connection.updateInstance(message);\n});\nsocket.on('messages removed', function(message){\n\tMessage.connection.destroyInstance(message);\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t},\n\tname: \"string\",\n\tbody: \"string\",\n\tsend: function(event) {\n\t    event.preventDefault();\n\n\t\tnew Message({\n\t\t\tname: this.name,\n\t\t\tbody: this.body\n\t\t}).save().then(function(){\n\t\t\tthis.body = \"\";\n\t\t}.bind(this));\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    route: \"string\",\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\":page\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='22-32,only'></span>\nWhen complete, you can open up the same JSBin in another window, create a\nmessage, and it will appear in the first JSBin's messages list.\n\nThis step connects to a [https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API WebSocket API]\nthat pushes messages when `Message`s are created, updated or destroyed. By calling the\n[can-connect/real-time/real-time] methods when these events happen, CanJS will automatically\nupdate the messages list.\n\n> __Key take away:__ CanJS will add, remove, and update lists for you automatically.  It's\nawesome!\n\n## Result\n\nWhen finished, you should see something like the following JSBin:\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/mopiyu/2/embed?html,js,output\">JS Bin on jsbin.com</a>\n\n\n\n<script src=\"http://static.jsbin.com/js/embed.min.js?3.39.18\"></script>\n\n",
    "description": "\nThis guide walks through building real time chat application with CanJS's\n[can-core Core libraries].  It takes about 30 minutes to complete.\n",
    "name": "guides/chat",
    "title": "Chat Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 1,
    "comment": " "
  },
  "guides/pmo/AppStateAndRouting": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/app-state-and-routing.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - AppState\n - Basic Routing\n - Binding the AppState Object to the Application and Routes\n\nGet the code for: [chapter: app state and routing](/guides/examples/PlaceMyOrder/ch-3_canjs-getting-started.zip)\n- - -\n\nAs mentioned in the [introduction](Tutorial.html), CanJS suggests using a global\n`appState` object to manage the state of your application. The `appState` object\nis bound to two things:\n\n1. The application’s base template\n2. The application’s routing\n\nSince you already know about creating instances of `can.Map`, creating an\n`appState` object, which is a `can.Map`, will be easy. Let’s see how this works.\nOpen up your `app.js` file and update it as shown below.\n\n```\n$(function () {\n\tvar AppState = can.Map.extend({});\n\n\tvar appState = new AppState();\n\n\t// Bind the application state to the root of the application\n\t$('#can-main').html(can.view('main.stache', appState));\n\n\t// Set up the routes\n\tcan.route(':page', { page: 'home' });\n\tcan.route(':page/:slug', { slug: null });\n\tcan.route(':page/:slug/:action', { slug: null, action: null });\n\n\t$('body').on('click', 'a[href=\"javascript://\"]', function(ev) {\n\t\tev.preventDefault();\n\t});\n\n\t// Bind the application state to the can.route\n\tcan.route.map(appState);\n\n\tcan.route.ready();\n\n\t//appState.attr('page', 'restaurants');\n\n\tappState.bind('change', function(ev, prop, change, newVal, oldVal) {\n\t\talert('Changed the “' + prop + '” property from “' + oldVal + '” to “' + newVal + '”.');\n\t});\n});\n```\n\n## Routing\nBefore we dive into the details of the `appState` object, let’s quickly discuss\nrouting. Routing in CanJS allows us to manage browser history and client state by\nsynchronizing the `window.location.hash` with a `can.Map`. In other words, we can\nuse routing to reflect the state of our application or set the state of our application.\nOne of the things that makes routing powerful is that it records the state of the\napplication in the browser’s history. We’ll see some specific examples of this\nas we proceed.\n\nIn our application, we setup routing by:\n\n- defining the possible routes by calling `can.route`,\n- binding our `appState` object to the route with a call to `can.route.map`, and\n- calling `can.route.ready()`, which sets up two-way binding between the\n  browser’s `window.location.hash` and the `can.route`’s internal `can.Map`.\n\nOn lines 10–12, we define all the potential routes in our application and the\nproperties on the `appState` object. Let’s look at each line individually.\n\n```\ncan.route(':page', { page: 'home' });\n```\n\nThis line does two things:\n\n1. Creates a base route that is bound to one property: `page`.\n2. Sets the default value of the `page` property to `'home'`.\n\nIn our app, this will allow the following URLs:\n\n- `#!` (which will set `page` to `'home'` because that’s the default)\n- `#!orders/` (which will set `page` to `'orders'`)\n- `#!restaurants/` (which will set `page` to `'restaurants'`)\n\n```\ncan.route(':page/:slug', { slug: null });\n```\n\nThis line does two things:\n\n1. Binds a new `slug` property to our `appState` object.\n2. Sets the default value of the `slug` property to `null`.\n\nThis makes the following URLs possible:\n\n- `#!restaurants/spago/` (`page` will be `'restaurants'` and `slug` will be `'spago'`)\n\nAnything in the second part of the URL will be the `slug` property on our\n`appState` object.\n\n```\ncan.route(':page/:slug/:action', { slug: null, action: null });\n```\n\nThis line does two things:\n\n1. Binds a new `action` property to our `appState` object.\n2. Sets the default value of the `action` property to `null`.\n\nThis makes the following URLs possible:\n\n- `#!restaurants/spago/order/` for order confirmation; again, `action` will be `'order'`\n\nLet’s take a moment to see how these routes are bound to our `appState` object.\nNotice the `//appState.attr('page', 'restaurants');` line at the end of our\n`app.js` file; let’s uncomment that line so it looks like\n`appState.attr('page', 'restaurants');`\n\nNow, refresh the app in your browser. The path will now be `#!restaurants`,\nand you’ll notice that the Restaurants link in the navigation is highlighted.\n\n![place-my-order.com home page](../can/guides/images/app-state-routing/app_state_route_rest.png)\n\nNote that, after we initialized our routes, updating the value of our\n`appState`’s `page` property caused the route to update as well.\nThe value of the `page` property was serialized and appended\nto the `window.location.hash`.\n\nLet’s see what happens if we adjust the value of the hash. To monitor this\nchange, we’ve included the following lines:\n\n```\nappState.bind('change', function(ev, prop, change, newVal, oldVal) {\n\talert('Changed the “' + prop + '” property from “' + oldVal + '” to “' + newVal + '”.');\n});\n```\n\nThese lines use [`can.Map.bind`](../docs/can.Map.prototype.bind.html) to\nwatch for changes to the `appState` object. Go ahead and change the URL from\n`#!restaurants` to `#!orders`. You should see an alert with this message:\n\n![place-my-order.com home page](../can/guides/images/app-state-routing/change_state_alert.png)\n\nIt was mentioned earlier that we bound our AppState to the application’s `main.stache`.\nThis is the key to connecting the AppState to our [components](Components.html).\nBecause the `appState` object is bound to our main template, which includes the rest of\nthe components in the app, *these attributes will automatically be included in the scope of\nthe components*.\n\nBefore moving on, let’s remove the following lines from our application:\n\n```\nappState.attr('page', 'restaurants');\n\nappState.bind('change', function(ev, prop, change, newVal, oldVal) {\n\talert('Changed the “' + prop + '” property from “' + oldVal + '” to “' + newVal + '”.');\n});\n```\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Stache Templates](StacheTemplates.html)</span>\n<span class=\"pull-right\">[Components &rsaquo;](Components.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/AppStateAndRouting",
    "title": "App State and Routing",
    "type": "page",
    "parent": "guides/pmo",
    "order": 6,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/ApplicationDesign": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/application-design.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - Designing an Application\n- - -\n\nThe first step in putting together a CanJS app is sketching out the states of your application.\n\nWe’ll be building a small application called “Place My Order”. Place My Order is a\nwebsite that lets you select from available restaurants in your area, view their\nmenus, and purchase items for delivery. For this sample application, we’ll keep\nthings pretty simple. We won’t worry about registration, authentication, or\npayment processing.\n\nLet’s walk through the different states of our application.\n\n## Home\n\n![place-my-order.com home page](../can/guides/images/application-design/Home.png)\n\nThe Home state includes a header for navigation and a quick summary of the website’s\npurpose. You can see the main purposes of the website:\n\n - order from a restaurant\n - see your order history.\n\n## Restaurants\n\n![Restaurant locator page](../can/guides/images/application-design/RestaurantLocator.png)\n\nThe Restaurants state is the starting point for finding a restaurant from which you\nwant to order. Restaurants are displayed by region. To show a list of restaurants,\nfirst select a (U.S.) state and city.\n\n### Finding a Restaurant\n\n![Restaurant list page](../can/guides/images/application-design/RestaurantList.png)\n\nThe list of restaurants includes details about each restaurant, such as its rating\nand hours, as well as a “Place My Order” button.\n\n### Restaurant Details\n\n![Restaurant details page](../can/guides/images/application-design/RestaurantDetails.png)\n\nThe restaurant details state displays more information about a selected restaurant and an\norder button to start the ordering process.\n\n### Ordering from a Restaurant\n\n![Restaurant order form](../can/guides/images/application-design/RestaurantOrderForm.png)\n\nThe order state has a simple menu and form for collecting the user’s information.\nAt the bottom of the page, we show a total amount for the order and a button to\nplace the order.\n\n### Order Confirmation\n\n![Restaurant order confirmation page](../can/guides/images/application-design/RestaurantOrderConfirmation.png)\n\nThe order confirmation state shows the items the user selected, a total,\nand the personal information they’ve provided with the order. Note that this state\nalso has a link to restart the ordering process, should the user want to place another\norder at the same restaurant.\n\n## Order History\n\n![Order history page](../can/guides/images/application-design/OrderHistory.png)\n\nThe order history state has a list of orders with different statuses: new, preparing,\nin delivery, and delivered. This state allows you to mark orders with different\nstatuses as they move through the workflow.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Setup](Setup.html)</span>\n<span class=\"pull-right\">[Constructors &rsaquo;](Constructors.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/ApplicationDesign",
    "title": "Application Design",
    "type": "page",
    "parent": "guides/pmo",
    "order": 2,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/atm": {
    "src": {
      "path": "docs/can-guides/experiment/atm/atm.md"
    },
    "body": "\n\n## Overview\n\nCheckout the final app:\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/rujacuy/2/embed?output\">JS Bin on jsbin.com</a>\n\n - pages and state diagram\n - state diagram\n\n## Setup\n\nThe easiest way to get started is to clone the following JSBin by clicking the __JS Bin__ button on the top left:\n\n<a class=\"jsbin-embed\" href=\"http://justinbmeyer.jsbin.com/meziyu/2/edit?html,js,output\">JS Bin on jsbin.com</a>\n\nThe JSBin is designed to run both the application and its tests in the `OUTPUT`\ntab.  To set this up, the `HTML` tab:\n\n - Loads QUnit for its testing library.  It also includes the `<div id=\"qunit\"></div>`\n   element where QUnit's test results will be written to.\n\n - Loads [can.all.js](https://github.com/canjs/canjs/blob/v3.0.0-pre.12/dist/global/can.js), which\n   is a script that includes all of CanJS core under a single global `can` namespace.\n\n   Generally speaking, you should not use the global can script and instead\n   should import things directly with a module loader like [StealJS](http://stealjs.com),\n   WebPack or Browserify.  Read [guides/setup] on how to setup CanJS in a real app.\n\n - Includes the content for a `app-template` [can-stache] template. This template\n   provides the title for the ATM app, and uses the `<atm-machine>` custom [can-component]\n   element that will eventually provide the ATM functionality.\n\nThe `JS` tab is split into two sections:\n\n - `CODE` - The ATM's models, view-models and component code will go here.\n - `TESTS` - The ATM's tests will go here.\n\nNormally, your application's code and test will be in separate files and loaded\nby different html pages.  But we combine them here to fit within JSBin's limitations.\n\nThe `CODE` section is rendering the `app-template` with:\n\n```js\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n```\n\nThe `TESTS` section is labeling which module will be tested:\n\n```js\nQUnit.module(\"ATM system\", {});\n```\n\n## Mock out switching between pages\n\nIn this section, we will mock out which pages will be shown as the `state`\nof the `ATM` changes.  \n\nUpdate the `HTML` tab to:\n\n - Switch between different pages of the application as the `ATM` view-model's `state` property changes\n   with [can-stache.helpers.switch\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"sucessfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.12/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='12-60,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Create the `ATM` view-model with a `state` property initialized to `readingCard` with [can-define/map/map].\n - Create an `<atm-machine>` custom element with [can-component].\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {});\n\n```\n<span line-highlight='5-13,only'></span>\nWhen complete, you should see the __\"Reading Card\"__ title.\n\nThis step outlines the page transitions we're going to make the `state`\nproperty transition between:\n\n- readingCard\n- readingPin\n- choosingTransaction\n- pickingAccount\n- depositInfo\n- withdrawalInfo\n- transactionSucessful\n- printingReceipt\n\nEach of those states are present in the following state diagram.\n\n<img src=\"../../docs/can-guides/experiment/atm/1-pages-template/state-diagram.png\">\n\nWe'll build out these pages once we build the `Card` and `Transaction` sub-models that will make building the ATM view model easier.\n\n## Card tests\n\nIn this section, we will:\n\n - Design an API for an ATM `Card`\n - Write out tests for the card.\n\nAn ATM `Card` will take a card `number` and `pin`. It will start out as\nhaving a `state` of  `\"unverified\"`. It will have a `verify` method\nthat will change the `state` to `\"verifying\"` and if the response is successful,\n`state` will change to `\"verified\"`.\n\nUpdate the `JS` tab to:\n\n- Make the fake data request delay `1ms` by setting [can-fixture.delay] to `1` before every test and\n  restoring it to `2md` after every test runs.\n- Write a test that creates a valid card, calls `.verify()`, and asserts the `state` is `\"verified\"`.\n- Write a test that creates a invalid card, calls `.verify()`, and asserts the `state` is `\"invalid\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\n```\n<span line-highlight='24-70,only'></span>\nWhen complete you should have a breaking test.  Now lets make it pass.\n\n## Card model\n\nIn this section, we will:\n\n- Implement the `Card` model so that all tests pass.\n\nUpdate the `JavaScript` tab to:\n\n- Simulate the `/verifyCard` with [can-fixture]. It return a successful response if\n  the request body has a `number` and `pin` and a 400 if not.\n- Use [can-define/map/map] to define the `Card` model, including:\n  - a `number` and  `pin` property.\n  - a `state` property initialized to `unverified` that is not part of the card's [can-define.types.serialize]d  data.\n  - a `verify` method that posts the card's data to `/verifyCard` and updates the `state`\n    accordingly.\n\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\n```\n<span line-highlight='5-42,only'></span>\nWhen complete, all tests should pass.\n\nIn this step, you implemented a `Card` model that encapsulates the behavior of its own state.\n\n## Deposit test\n\nIn this section, we will:\n\n - Design an API retrieving `Account`s.\n - Design an API for a `Deposit` type.\n - Write out tests for the `Deposit` type.\n\nAn `Account` will have an `id`, `name`, and `balance`.  We'll use [can-connect] to add a\n[can-connect/can/map/map.getList] method that retrieves an account given a `card`.\n\nA `Deposit` will take a `card`, an `amount`, and an `account`.  Deposits will start out having\na `state` of `\"invalid\"`.  When the deposit has a `card`, `amount` and `account`, the `state`\nwill change to `\"ready\"`.  Once the deposit is ready, the `.execute()` method will change the state\nto `\"executing\"` and then to `\"executed\"` once the transaction completes.\n\nUpdate the `JS` tab to:\n\n- Create a `deposit` with an `amount` and a `card`.\n- Check that the `state` is `\"invalid\"` because there is no `account`.\n- Use `Account.getList` to get the accounts for the card and:\n  - set the `deposit.accounts` to the first account.\n  - remember the starting `balance`.\n- Use [can-define/map/map.prototype.on] to listen for `state` changes. When `state` is:\n  - `\"ready\"`, `.execute()` the transaction.\n  - `\"executed\"`, verify the new account balance.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='111-151,only'></span>\nWhen complete, the __Deposit__ test should run, but error because _Deposit is not defined_.\n\n## Transaction, Deposit, and Withdrawal models\n\nIn this section, we will:\n\n- Implement the `Account` model.\n- Implement a base `Transaction` model and extend it into a `Deposit` and\n`Withdrawal` model.\n- Get the __Deposit__ test to pass.\n\nUpdate the `JavaScript` tab to:\n\n- Simulate `/accounts` to return `Account` data with [can-fixture].\n- Simulate `/deposit` to always return a successful result.\n- Simulate `/withdrawal` to always return a successful result.\n- Define the `Transaction` model to:\n  - have an `account` and `card` property.\n  - have an `executing` and `executed` property that track if the transaction is executing or has executed.\n  - have a `rejected` property that stores the error given for a failed transaction.\n  - have an __abstract__ `ready` property that `Deposit` and `Withdrawal` will implement to return `true`\n    when the transaction is in a state able to be executed.\n  - have a `state` property that reads other stateful properties and returns a string representation\n    of the state.\n  - have an __abstract__ `executeStart` method that `Deposit` and `Withdrawal` will implement to\n    execute the transaction and return a `Promise` the resolves when the transaction completes.\n  - have an __abstract__ `executeEnd` method that `Deposit` and `Withdrawal` will implement to\n    update the transactions values (typically the `account` balance) if the transaction completed\n    successfully.\n  - have an `execute` method that calls `.executeStart()` and `executeEnd()` and keeps the stateful\n    properties updated correctly.\n- Define the `Deposit` model to:\n  - have an `amount` property.\n  - implement `ready` to return `true` when the amount is greater than `0` and there's an `account`\n    and `card`.\n  - implement `executeStart` to `POST` the deposit information to `/deposit`\n  - implement `executeEnd` to update the account balance.\n- Define the `Withdrawal` model to behave in the same way as `Deposit` except that\n  it `POST`s the withdrawal information to `/withdrawal`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='13-31,79-187,only'></span>\nWhen complete, the __Deposit__ tests will pass.\n\n## Reading Card page and test\n\nIn this section, we will:\n\n - Allow the user to enter a card number and go to the __Reading Pin__ page.\n - Add tests to __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Allow a user to call `cardNumber` with the `<input>`'s `value`.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"sucessfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.12/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='20-26,only'></span>\nUpdate the `JavaScript` tab to:\n\n- Declare a `card` property.\n- Derive a `state` property that changes to `\"readingPin\"` when `card` is defined.\n- Add a `cardNumber` that creates a `card` with the `number` provided.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\n\t// derived properties\n\tget state(){\n\t\tif(this.card) {\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tQUnit.start();\n});\n\n```\n<span line-highlight='190-205,313-325,only'></span>\nWhen complete, you should be able to enter a card number and see the __Reading Pin__\npage.\n\n## Reading Pin page and test\n\nIn this section, we will:\n\n- Allow the user to enter a pin number and go to the __Choosing Transaction__ page.\n- Add tests to __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Call `pinNumber` with the `<input>`'s `value`.\n- Disable the `<input>` while the pin is being verified.\n- Show a loading icon while the pin is being verified.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"sucessfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.12/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='31-47,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Define an `accountsPromise` property that will contain a list of accounts for the `card`.\n- Define a `transactions` property that will contain a list of transactions for this session.\n- Update `state` to be in the `\"choosingTransaction\"` state when the `card` is verified.\n- Define a `pinNumber` method that updates the `card`'s `pin`, calls `.verify()`,\n  and then initializes the `accountsPromise` and `transactions` property.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Test calling `pinNumber` moves the `state` to `\"choosingTransaction\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\n\t// derived properties\n\tget state(){\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null\n\t\t});\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tQUnit.start();\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='192-193,198-200,212-228,346-356,only'></span>\nWhen complete, you should be able to enter a card and pin number and see the __Choosing Transaction__\npage.\n\n## Choosing Transaction page and test\n\nIn this section, we will:\n\n- Allow the user to pick a transaction type and go to the __Picking Account__ page.\n- Add tests to __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Have buttons for choosing a deposit, withdrawal, or print a receipt and exit.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"sucessfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.12/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='52-59,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Define a `currentTransaction` property that when set, adds the previous `currentTransaction`\n  to the list of `transactions`.\n- Define a `printingReceipt` property which is set to true the the receipt should be printed.\n- Define a `receiptTime` property that controls how long the receipt should be shown.\n- Update the `state` property to `\"pickingAccount\"` when there is a `currentTransaction`.\n- Update the `exit` method to clear the `printingReceipt` and `currentTransaction` method.\n- Define `chooseDeposit` that creates a `Deposit` and sets it as the `currentTransaction`.\n- Define `chooseWithdraw` that creates a `Withdraw` and sets it as the `currentTransaction`.\n- Define `printReceiptAndExit` that sets `printingReceipt` and calls exit.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Call `.chooseDeposit()` and verify the state moves to `\"pickingAccount\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\tprintingReceipt: \"boolean\",\n\treceiptTime: {\n\t\tvalue: 5000,\n\t\ttype: \"number\"\n\t},\n\n\t// derived properties\n\tget state(){\n\n\t\tif (this.currentTransaction) {\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tprintingReceipt: null,\n\t\t\tcurrentTransaction: null\n\t\t});\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tprintReceiptAndExit: function() {\n\t\tthis.printingReceipt = true;\n\t\tvar self = this;\n\t\tsetTimeout(function() {\n\t\t\tself.exit();\n\t\t}, this.receiptTime);\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='194-209,214-216,248-249,252-268,395-402,only'></span>\n\n## Picking Account page and test\n\nIn this section, we will:\n\n- Allow the user to pick an account and go to either the  __Deposit Info__ or\n  __Withdrawal Info__ page.\n- Add tests to __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Write out a _\"Loading Accounts  ...\"_ message while the accounts are loading.\n- Write out the accounts when loaded.\n- Call `chooseAccount()` when an account is clicked.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n                    Loading Accounts ...\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"sucessfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.12/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='64-78,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Change `state` to check if the `currentTransaction` has an `account` and update the\n  value to `\"depositInfo\"` or `\"withdrawalInfo\"` depending on the type of the `currentTransaction`.\n- Add a `chooseAccount` method that sets the `currentTransaction`'s `account`.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Call `.chooseAccount()` with the first account loaded.\n- Verify the state changes to `\"depositInfo\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\tprintingReceipt: \"boolean\",\n\treceiptTime: {\n\t\tvalue: 5000,\n\t\ttype: \"number\"\n\t},\n\n\t// derived properties\n\tget state(){\n\n\t\tif (this.currentTransaction) {\n\t\t\tif (this.currentTransaction.account) {\n\t\t\t\tif (this.currentTransaction instanceof Deposit) {\n\t\t\t\t\treturn \"depositInfo\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"withdrawalInfo\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tprintingReceipt: null,\n\t\t\tcurrentTransaction: null\n\t\t});\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tprintReceiptAndExit: function() {\n\t\tthis.printingReceipt = true;\n\t\tvar self = this;\n\t\tsetTimeout(function() {\n\t\t\tself.exit();\n\t\t}, this.receiptTime);\n\t},\n\tchooseAccount: function(account) {\n\t\tthis.currentTransaction.account = account;\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tatm.accountsPromise.then(function(accounts){\n\t\t\t\tatm.chooseAccount(accounts[0]);\n\t\t\t});\n\n\t\t} else if (newVal === \"depositInfo\") {\n\n\t\t\tQUnit.ok(true, \"in depositInfo state\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='215-221,277-279,411-418,only'></span>\n## Deposit Info page and test\n\n\n\n## Withdrawal Info page\n\n## Transaction Successful page and test\n\n## Printing Recipe page and test\n\n\n\n\n\n\n<script src=\"http://static.jsbin.com/js/embed.min.js?3.39.18\"></script>\n\n",
    "description": "\nThis guide walks through building and __testing__ an ATM application with CanJS's\n[can-core Core libraries].  It teaches how to do test driven development (TDD)\nand manage complex state.  It takes about 2 hours to complete.\n",
    "name": "guides/atm",
    "title": "ATM Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 3,
    "comment": " "
  },
  "guides/pmo/Components": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/components.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - First `can.Component`\n  - Auto Instantiation\n  - Anatomy of a `can.Component`\n\nGet the code for: [chapter: components](/guides/examples/PlaceMyOrder/ch-4_canjs-getting-started.zip)\n\n- - -\n\n<a name=\"first-component\"></a>\n## First can.Component\nIf you recall from the introduction, a [`can.Component`](../docs/can.Component.html) is like a self-contained,\nmini web application; in other words, it’s encapsulated. Because `can.Component`’s are\nencapsulated, they should each contain their own:\n\n- View template file (.stache file)\n- JavaScript file\n- CSS file\n\nThis is why we created a `components` folder for our app&mdash;instead of, say, a\n`js` folder. Each component we develop will be in a folder that contains all\nthe files that support that component. This makes components portable,\nenabling you to reuse them across projects. It also isolates them, making\nthem easier to test and maintain.\n\nPut the following code inside `components/restaurant_list/restaurant_list.js`:\n\n```\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: {\n    currentRestaurant: 'Hello Restaurant Customer'\n  }\n});\n```\n\nAdd the following code to `components/restaurant_list/restaurant_list.stache`:\n\n```\n<h1>{{currentRestaurant}}</h1>\n```\n\nFinally, we need to add a reference to `components/restaurant_list/restaurant_list.js`\nin the index.html file. Find this line:\n\n```\n<!-- Replace with restaurant list component script -->\n```\n\nand replace it with this line:\n\n```\n<script src=\"components/restaurant_list/restaurant_list.js\"></script>\n```\n\nNow, go back out to your app in the browser and refresh it. On the Restaurants page, you should\nsee it printing: \"Hello Restaurant Customer\".\n\n![Hello Restaurant Customer message](../can/guides/images/components/HelloRestaurantCustomer.png)\n\n### Auto Instantiation\n\nIf you recall from [our previous discussion regarding `can.Construct`](Constructors.html), whenever you\ndeclare an object using `can.Construct`, it must be instantiated. Normally, you\nwould either directly instantiate objects using the `new` keyword, or pass the\nconstructor to an object that would create instances of it. *`can.Component` is\nan exception.*\n\nAll we have to do is declare the `can.Component` using its `extend` function.\nOnce you declare your `can.Component`, you’ve registered your component with CanJS.\nWhen CanJS parses the `main.stache` file and encounters the\n`<pmo-restaurant-list>` tag, it will automatically instantiate the `can.Component`\nassociated with it, generate the component’s view inside of its custom tag,\nand bind that view to your component’s scope.\n\n### Basic Anatomy of a can.Component\n\nThe `can.Component` we created above had three properties.\n\n- [tag](#tag),\n- [template](#template), and\n- [viewModel](#viewmodel)\n\n```\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: {\n    currentRestaurant: 'Hello Restaurant Customer'\n  }\n});\n```\n\n<a name=\"tag\"></a>\n#### The “tag” Property\nThe `can.Component`’s `tag` property associates that\n`can.Component` with a specific, custom HTML tag.\n\nAs mentioned above, when the template containing the `can.Component`’s tag is\nparsed, the `can.Component` is instantiated and the contents of its rendered\ntemplate are inserted as the HTML contents of the custom tag.\n\n<a name=\"template\"></a>\n#### Template\nThe `template` property of the `can.Component` contains the string\nvalue of the `can.Component`’s template. Note that the template property just\ncontains a string value. You can inline the template, if it is small. However,\nthe recommended way of working with templates, to maintain separation of\nconcerns, is to keep them in their own files and load them using `can.view`, as\nwe have done here.\n\n<a name=\"viewmodel\"></a>\n#### View Model\nThe `viewModel` object is the `can.Component`’s view model. The view\nmodel is an abstraction of the view that exposes public properties and\nfunctions. Any property or function defined on the view model object is available\nfrom the `can.Component`’s template as either a Stache data key, or a function.\nIn our example above, we created the property `currentRestaurant` and then\nreferenced it as a Stache data key in our template.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; App State and Routing](AppStateAndRouting.html)</span>\n<span class=\"pull-right\">[View Models &rsaquo;](ViewModels.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/Components",
    "title": "Components",
    "type": "page",
    "parent": "guides/pmo",
    "order": 7,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/EventHandling": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/event-handling.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Event Handling\n\nGet the code for: [chapter: event handling](/guides/examples/PlaceMyOrder/ch-8_canjs-getting-started.zip)\n\n- - -\n\nCanJS makes it easy to handle any\n[any standard DOM event](https://developer.mozilla.org/en-US/docs/Web/Events),\nsuch as a `change` event, in your component. To add an event handler, we\nhave to make changes in two places:\n\n1. The view template\n2. The `can.Component` view model\n\nBefore we can work with an example, let’s get the restaurant details page\nworking. When you go to the Restaurants page in your browser, then select\na state and city, then click the “Place My Order” button next to a restaurant,\nthe page will have a `pmo-restaurant-details` element without any content.\n\n![Empty pmo-restaurant-details element](../can/guides/images/event-handling/EmptyRestaurantDetails.png)\n\nAs we’ve discussed earlier, you need to include the component’s script\nfile to register the component with CanJS. While we’re at it, we’re going to\ninclude the scripts for the rest of the components that we’re going to use.\nLet’s edit the `index.html` file by replacing these lines:\n\n```html\n\t<!-- Replace with order component script -->\n\t<!-- Replace with order details component script -->\n\t<!-- Replace with order history component script -->\n\t<!-- Replace with order list component script -->\n\t<!-- Replace with order phone component script -->\n```\n\nwith these lines:\n\n```html\n\t<script src=\"components/order/order.js\"></script>\n\t<script src=\"components/order_details/order_details.js\"></script>\n\t<script src=\"components/order_list/order_list.js\"></script>\n\t<script src=\"components/order_history/order_history.js\"></script>\n\t<script src=\"components/order_phone/order_phone.js\"></script>\n```\n\nWe have just one more file we need to include before we move on. This\nsection is going to introduce orders from a restaurant, and\nwe’ll want to have an `Order` model. Find this line:\n\n```\n\t<!-- Replace with order model script -->\n```\n\nand replace it with this line:\n\n```\n    <script src=\"models/order.js\"></script>\n```\n\nNow, if you refresh the page, you’ll see the details for Spago.\n\n![Restaurant details page](../can/guides/images/application-design/RestaurantDetails.png)\n\nIf you click the “Order from Spago” button, you’ll find yourself with a menu, a\nname field, and an address field; however, we’re missing one important piece of\ncustomer information: a phone number. Let’s build a `phone-validator`\ncomponent to collect this information, and add some event handling to\nvalidate the field as the user types.\n\nThere are two ways you can add event handling to an element:\n - by adding an attribute with the event name prefixed by `can-`.\n - by adding an attribute with the event name surrounded in parenthesis, e.g., `(click)`.\n\n```html\n<!--Example using can- syntax-->\n<input name=\"phone\" type=\"text\" can-keyup=\"{setPhoneValue @element.val}\">\n\n<!--Example using () syntax-->\n<input name=\"phone\" type=\"text\" ($keyup)=\"setPhoneValue(@element.val)\">\n```\n\nOf these, the preferred method is to use parenthesis to surround the event name.\nAgain, [any standard DOM event](https://developer.mozilla.org/en-US/docs/Web/Events) is supported.\nMore information about `can.stache's` event and two-way binding syntaxes can be found at [can.view.bindings](http://localhost:8080/docs/can.view.bindings.html).\n\nIn addition to defining an event, you can pass certain predefined parameters\nto the method that handles the event. These parameters include:\n\n   - @element - The can.$ wrapped element where the event occurred.\n   - @event - The event object&mdash;or properties off of that object.\n   - @viewModel - If the element is a can.Component, the component's viewModel.\n   - @context - The current context.\n\nYou are not limited to these parameters. Any valid value can be passed in to the\nhandler method. Separate method parameters with a space, e.g. `{{myMethod arg1 arg2}}`\n\nLet’s open the `components/order_phone/order_phone.stache` file and add the\nfollowing:\n\n```html\n<div class=\"form-group{{#if error}} has-error{{/if}}\">\n  <label>Phone:</label>\n  <input name=\"phone\" type=\"text\" ($keyup)=\"setPhoneValue(@element.val)\">\n  {{#if error}}\n    {{#eq order.phone '911'}}\n      <p>That's not your real number :-(</p>\n    {{else}}\n      <p>Please enter a phone number in the format 555-555-5555</p>\n    {{/eq}}\n  {{/if}}\n</div>\n```\n\nNotice the `<input />` element with a `($keyup)` event handler. Whenever there\nis a `keyup` event in the `input`, the code in the value will be executed. We’re\nalso passing `@element.val` to the `setPhoneValue` helper. Let’s\nadd the component’s JavaScript to the `components/order_phone/order_phone.js`\nfile:\n\n```\nvar PhoneViewModel = can.Map.extend({\n  error: function(){\n    var phone = this.attr(\"order\").attr(\"phone\");\n    return phone && (!/^(\\d|-)*$/.test(phone) || phone === \"911\");\n  },\n\n  setPhoneValue: function(val){\n    this.attr('order').attr('phone', val);\n  }\n});\n\ncan.Component.extend({\n  tag: 'phone-validator',\n  viewModel: PhoneViewModel,\n  template: can.view('components/order_phone/order_phone.stache')\n});\n```\n\nHere you can see the `setPhoneValue` helper function, which takes the `val`\npassed to it by the template and sets the `phone` property of the\ncomponent’s `order` property to `val`.\n\nBut how do errors show up? The template is using the `error` property on the\ncomponent, which looks like this:\n\n```\n  error: function(){\n    var phone = this.attr(\"order\").attr(\"phone\");\n    return phone && (!/^(\\d|-)*$/.test(phone) || phone === \"911\");\n  },\n```\n\nNotice that the `error` property uses `this.attr(\"order\").attr(\"phone\")` in\nits getter. Because of CanJS’s [observables](Observables.html), CanJS is\naware of us setting that value in our `setPhoneValue` helper, and thus only\nruns the getter again (called “recomputing the value”) when\nthe value has changed. When the `setPhoneValue` helper sets the value, CanJS\nrecomputes the `error` property’s value, which will return an error if you\ntype “911” or anything that doesn’t look like a phone number.\n\n![Restaurant order error when you type 911 as your phone number](../can/guides/images/event-handling/RestaurantOrderError911.png)\n\nNote that you can place as many event handlers as you need on an element. Adding event\nhandlers in this way directly binds the events to the element. This can impact\nperformance in situations where you have many elements to bind events to. For\nmore performant event binding, you can use the `can.Component`’s [events\nproperty](../docs/can.Component.prototype.events.html). Discussing this is beyond\nthe scope of this introduction. See the API for more details.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Loading States](LoadingStates.html)</span>\n<span class=\"pull-right\">[Web Service Communication &rsaquo;](WebServiceCommunication.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/EventHandling",
    "title": "Event Handling",
    "type": "page",
    "parent": "guides/pmo",
    "order": 11,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/LoadingStates": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/loading-states.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Loading States\n\nGet the code for: [chapter: loading states](/guides/examples/PlaceMyOrder/ch-7_canjs-getting-started.zip)\n\n- - -\n\nLoading data from a remote server never happens immediately, so it’s a best\npractice to show some sort of indicator to improve the user’s experience.\nCanJS makes this easy with observable promises.\n\nNow that we have the cities and states loading from our fixtures, let’s get\na list of restaurants when a city is selected. Let’s start by modifying\nthe `components/restaurant_list/restaurant_list.js` file. Find this line:\n\n```\n\t\t// Restaurant code will go here\n```\n\nand replace it with these lines:\n\n```\n\t\trestaurants: {\n\t\t\tget: function(){\n\t\t\t\tvar city = this.attr('city'),\n\t\t\t\t\tstate = this.attr('state');\n\n\t\t\t\treturn state && city ?\n\t\t\t\t\tRestaurant.findAll({\n\t\t\t\t\t\t'address.state': state,\n\t\t\t\t\t\t'address.city': city\n\t\t\t\t\t}) : null;\n\t\t\t}\n\t\t}\n```\n\nHere, we’re adding a new `restaurants` property that is a promise returned\nby `can.Model.findAll()` (if a city and state are selected). This promise\nhas a few properties:\n\n- `isPending`: indicates that the promise hasn’t been resolved or rejected\n- `isResolved`: indicates that the promise has been resolved\n- `value`: the value of the resolved promise\n\nNow let’s make use of this new property and it’s attributes in our\n`components/restaurant_list/restaurant_list.stache` template. Find this line:\n\n```\n  <!-- Restaurants code will go here -->\n```\n\nand replace it with these lines:\n\n```\n  {{#if restaurants.isPending}}\n  <div class=\"restaurant loading\"></div>\n  {{/if}}\n\n  {{#if restaurants.isResolved}}\n    {{#each restaurants.value}}\n    <div class=\"restaurant\">\n      <img src=\"{{images.thumbnail}}\" width=\"100\" height=\"100\">\n      <h3>{{name}}</h3>\n      {{#address}}\n      <div class=\"address\">\n        {{street}}<br />{{city}}, {{state}} {{zip}}\n      </div>\n      {{/address}}\n\n      <div class=\"hours-price\">\n        $$$<br />\n        Hours: M-F 10am-11pm\n        <span class=\"open-now\">Open Now</span>\n      </div>\n\n      <a class=\"btn\" href=\"{{ routeUrl(page='restaurants' slug=slug) }}\">Place My Order</a>\n      <br />\n    </div>\n    {{/each}}\n  {{/if}}\n```\n\nYou’ll notice the `{{#if restaurants.isPending}}` and\n`{{#if restaurants.isResolved}}` lines; the first is for showing a loading\nindicator while the restaurants are being loaded, and the second is for\nshowing the list of restaurants once they’ve been fetched from the server\n(or in our case, from the fixtures). After they have,\n`{{#each restaurants.value}}` iterates over the list of restaurants to show\nthem on the page.\n\nSpeaking of fixtures, let’s modify our `models/fixtures.js` file. Add the\nfollowing lines:\n\n```\ncan.fixture('GET /api/restaurants', 'models/restaurants.json');\ncan.fixture('GET /api/restaurants/{_id}', 'models/spago.json');\n```\n\nThe first line will let us make a `GET` request to `/api/restaurants` to\nfetch the list of restaurants. The second line will return data for\na specific restaurant. Normally, this would be dynamic, depending on which\nrestaurant we want info for. For simplicity, however, we’re\nresponding with the same fixture data regardless of which restaurant is\nrequested.\n\nGo ahead and refresh the Restaurants page in your browser. Now, we can\nselect a state, a city, and then immediately see a list of restaurants!\n\n![Restaurant list](../can/guides/images/application-design/RestaurantList.png)\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Data Models and Fixtures](DataModelsAndFixtures.html)</span>\n<span class=\"pull-right\">[Event Handling &rsaquo;](EventHandling.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/LoadingStates",
    "title": "Loading States",
    "type": "page",
    "parent": "guides/pmo",
    "order": 10,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/Constructors": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/constructors.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - Constructors in CanJS\n  - The `extend` function\n  - The `init` function\n- - -\n\nBefore we work with any of the objects in CanJS, it will be helpful for us to\nunderstand [can.Construct](../docs/can.Construct.html). We won’t be working\nwith `can.Construct` directly. However, many of the objects in CanJS are derived from\n`can.Construct`. Understanding it will make it easier for you to understand other\nconcepts we’re going to cover.\n\n`can.Construct` provides a way to easily use the power of prototypal\ninheritance without worrying about hooking up all the particulars\nyourself. Without going into exhaustive detail, `can.Construct` contains\na few functions we’ll encounter frequently in other objects:\n\n- Prototype\n  - init\n- Static\n  - extend\n\nWe’ll look at the extend function first.\n\n## The extend function\n`can.Construct`’s `extend` function is used to create\n“constructor functions” that inherit from the base constructor function.\nTo create a constructor function of your own, call __can.Construct__ with the:\n\n- __staticProperties__ that are attached directly to the constructor, and\n- instance __prototypeProperties__.\n\n__can.Construct__ sets up the prototype chain so subclasses can be further\nextended and sub-classed as far as you like:\n\n```\nvar Order = can.Construct.extend({\n  init: function(){},\n\n  customer: function() { ... },\n\n  needAddress: function( account ) {\n    return false;\n  }\n});\n\nvar CarryOutOrder = Order.extend({\n  needAddress: function( account ) {\n    return account.hasAddress();\n  }\n});\n```\n\nIf only one set of properties is passed to __can.Construct__, it's assumed to\nbe the prototype properties.  If two sets of properties are passed, the\nfirst argument are static properties, the second argument are prototype\nproperties.\n\n```\ncan.Construct.extend({\n  // Static properties here\n}, {\n  // Blank object as second parameter\n});\n```\n\nThis example is highlighted because calling a `can.Construct` with two parameters,\nthe last of which is an empty object, is common. Also common is the mistake of\nommitting the last parameter of the call, which can lead to unexpected behavior.\n\n\n## The init function\n\nWhen a constructor is called with the `new` keyword, __can.Construct__ creates the instance and\ncalls [init](../docs/can.Construct.prototype.init.html) with\nthe arguments passed to `new Constructor(...)`. `init` is where initialization code\nshould go. Inside of the `init` function, the `this` keyword will refer to the\nnew object instance created by the constructor. Additionaly, `this` will contain\nthe instance properties you pass to the constructor. A common thing to do in `init`\nis save the arguments passed into the constructor. An example is below:\n\n```\nvar Order = can.Construct.extend({\n  init: function(price, item) {\n    this.price = price;\n    this.item = item;\n  }\n});\n\nvar order = new Order(20, 'Green Eggs & Ham');\n```\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Application Design](ApplicationDesign.html)</span>\n<span class=\"pull-right\">[Observables &rsaquo;](Observables.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/Constructors",
    "title": "Constructors",
    "type": "page",
    "parent": "guides/pmo",
    "order": 3,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/DataModelsAndFixtures": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/data-models-and-fixtures.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - `can.Model`\n - `can.fixture`\n - Connecting `can.Model` with `can.Component`\n\nGet the code for: [chapter: data models and fixtures](/guides/examples/PlaceMyOrder/ch-6_canjs-getting-started.zip)\n\n- - -\n\nThe next item we’re going to go over is [can.Model](../docs/can.Model.html).\nModels make interacting with JSON REST services *really easy*. They do this by\nencapsulating most of the code required to connect to a service and managing\nthe data the service returns. Additionally, `can.Model` extends\n[can.Map](../docs/can.Map.html), meaning that the objects returned have all of\nthe features of a `can.Map`, such as being [observable](Observables.html).\n\nFor applications requiring real-time, high performance, restful data connections\nyou should check out [can-connect](http://connect.canjs.com/). For our simple case,\nwe’ll use `can.Model` to provide data for our state and city elements from\nthe last chapter.\n\nFirst, let’s open the `models/state.js` file and add the following code:\n\n```\nvar State = can.Model.extend({\n  findAll: 'GET /api/states'\n}, {\n  // Include second, empty parameter object to set instanceProperties\n});\n```\n\nThen add the following to `models/city.js`:\n\n```\nvar City = can.Model.extend({\n  findAll: 'GET /api/cities'\n}, {\n  // Include second, empty parameter object to set instanceProperties\n});\n```\n\nBecause it is a [can.Construct](../docs/can.Construct.html), `can.Model.extend`\ncan take up to three parameters:\n\n1. `name`\n2. `staticProperties`\n3. `instanceProperties`\n\nA `can.Model`’s `staticProperties` parameter has several reserved properties you\ncan add that simplify accessing data from a JSON REST service. These\nproperties are:\n\n1. `findAll`\n2. `findOne`\n3. `create`\n4. `update`\n5. `destroy`\n\nThe `find*`, `create`, `update`, and `destroy` functions are available directly\noff of the object definition (i.e., they are static). The `destroy` function is\navailable off of specific instances of a `can.Model`. We’ll see how to\nuse these below.\n\n**Reminder**: The number of parameters you pass in to an `extend` function is\nimportant. If you pass in a single parameter object, the `extend` function will\nuse that to set the `instanceProperties`. If you pass in two parameter\nobjects, the *first* object passed in will be used to set the\n`staticProperties`. The second parameter will be used to set the\n`instanceProperties`. Here, we only want to set the `staticProperties`, so we\nmust pass in a second, empty object.\n\nA few examples below illustrate this important point:\n\n```\nvar MyModel = can.Model.extend({\n  findAll: function () {\n    // Static function\n  }\n}, {\n  destroy: function () {\n    // Instance function\n  }\n});\n\nMyModel.findAll(); // Reference a function defined on the constructor\n\nvar modelInstance = new MyModel();\nmodelInstance.destroy(); // Reference a function defined on the prototype\n```\n\n## The Data for Our Model\n\nWe’re not going to connect to a server to retrieve our data; however, we’re\ngoing to code our model as if we were. How can this possibly work? CanJS\nprovides a handy utility, `can.fixture`, that we can use to easily mimic the\nfunctionality of connecting to a server. `can.fixture`\nintercepts an AJAX request and simulates a server response with a file or a\nfunction. You can use `can.fixture` to develop JavaScript independently of\nbackend services.\n\n`can.fixture` is not included with the base CanJS package. It’s a good practice\nto keep it separate from your production CanJS library, which is why we\ndownloaded and used it a separate script tag, rather than including it\nwith our custom download. *If you use `can.fixture` during development, remember\nto remove it once you need to connect to your REST services*.\n\nLet’s create a fixture that will respond to our requests for the list of states.\nAdd the following code to the `models/fixtures.js` file:\n\n```\ncan.fixture('GET /api/states', 'models/states.json');\n```\n\nThe first argument to `can.fixture`, `GET /api/states`, tells CanJS to\nintercept any `GET` requests to the resource `/api/states`. The second argument\nis a path to a file with the data the fixture will return. Because we’re simulating\na `findAll` function, we need to return an array. The `findAll` function\nexpects an array. By default, if it does not receive one, it will throw an error.\nIf you need to connect to services that return data that doesn’t match the expected\nreturn type of the `find*` functions, don’t fret. There are ways to manage this,\nwhich we’ll work with later on.\n\nLet’s also create a fixture that will respond to our requests for the list\nof cities for each state. This one is going to be a little different because\nwe want to be able to return a different list depending on which state is\nincluded in the request. Thankfully, `can.fixture` is flexible and allows\nyou to dynamically respond to requests. Let’s add the following code to the\n`models/fixtures.js` file:\n\n```\ncan.fixture('GET /api/cities', function(request, response) {\n\tcan.ajax({\n\t\turl: 'models/' + request.data.state + '.json',\n\t\tsuccess: function(data) {\n\t\t\tresponse(data);\n\t\t}\n\t});\n});\n```\n\nThe first argument to `can.fixture`, `GET /api/cities`, is similar to our\nrestaurants example: we’re setting up this fixture to intercept any `GET`\nrequests to `/api/cities`. The second argument, however, is different: it\nis a function that returns the data we want to get when the application makes\na service call. In our example, we’re making an AJAX request (via\n[can.ajax](../docs/can.ajax.html)) to get the fixture data from a JSON file,\nthen responding to the request with the data we fetched.\n\n## Connecting the Model to the Component\n\nIt’s time to connect all of this together in our view model. Simply open up\n`components/restaurant_list/restaurant_list.js`, find the states property:\n\n```\n\t\tstates: {\n\t\t\tvalue: [\n\t\t\t\t{\n\t\t\t\t\tcities: ['Green Bay', 'Milwaukee'],\n\t\t\t\t\tname: 'Wisconsin'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcities: ['Detroit', 'Ann Arbor'],\n\t\t\t\t\tname: 'Michigan'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcities: ['Chicago', 'Peoria'],\n\t\t\t\t\tname: 'Illinois'\n\t\t\t\t}\n\t\t\t]\n\t\t},\n```\n\nand replace it with this:\n\n```\n\t\tstates: {\n\t\t\tget: function() {\n\t\t\t\treturn State.findAll({});\n\t\t\t}\n\t\t},\n```\n\nIn the same file, find the cities property:\n\n```\n\t\tcities: {\n\t\t\tget: function() {\n\t\t\t\tvar state = this.attr('state');\n\t\t\t\treturn state && this.attr('citiesByState')[state];\n\t\t\t}\n\t\t},\n```\n\nand replace it with this:\n\n```\n\t\tcities: {\n\t\t\tget: function() {\n\t\t\t\tvar state = this.attr('state');\n\t\t\t\treturn state ? City.findAll({ state: state }) : null;\n\t\t\t}\n\t\t},\n```\n\nYou can remove the `citiesByState` property since we won’t be using it anymore.\nLet’s also update the `components/restaurant_list/restaurant_list.stache` file\nto match the changes we made in the view model. The most significant change is\nthat our `cities` and `states` properties now return a [promise](../docs/can.List.plugins.promise.html)\ninstead of just an array. Find the `form` element:\n\n```\n  <form class=\"form\">\n    <div class=\"form-group\">\n      <label>State</label>\n      <select {($value)}=\"state\">\n        {{^if state}}\n        <option value=\"\">Choose a state</option>\n        {{/if}}\n        {{#each states}}\n        <option value=\"{{name}}\">{{name}}</option>\n        {{/each}}\n      </select>\n    </div>\n    <div class=\"form-group\">\n      <label>City</label>\n      <select {($value)}=\"city\">\n        {{^if city}}\n        <option value=\"\">Choose a city</option>\n        {{/if}}\n        {{#each cities}}\n        <option>{{.}}</option>\n        {{/each}}\n      </select>\n    </div>\n  </form>\n```\n\nand replace it with this new one:\n\n```\n  <form class=\"form\">\n    <div class=\"form-group\">\n      <label>State</label>\n      <select {($value)}=\"state\" {{#if states.isPending}}disabled{{/if}}>\n        {{#if states.isPending}}\n          <option value=\"\">Loading...</option>\n        {{else}}\n          {{^if state}}\n          <option value=\"\">Choose a state</option>\n          {{/if}}\n          {{#each states.value}}\n          <option value=\"{{short}}\">{{name}}</option>\n          {{/each}}\n        {{/if}}\n      </select>\n    </div>\n    <div class=\"form-group\">\n      <label>City</label>\n      <select {($value)}=\"city\" {{^if state}}disabled{{/if}}>\n        {{#if cities.isPending}}\n          <option value=\"\">Loading...</option>\n        {{else}}\n          {{^if city}}\n          <option value=\"\">Choose a city</option>\n          {{/if}}\n          {{#each cities.value}}\n          <option>{{name}}</option>\n          {{/each}}\n        {{/if}}\n      </select>\n    </div>\n  </form>\n```\n\nNote that there are a few ways to call a `findAll` function on a `can.Model`. The\nfirst way is to call the function explicitly. Using the `State` model as an\nexample, that would look like this:\n\n```\nState.findAll({ /* paramsObject */ },\n  function(returnedObject){\n    // ...\n  },\n  function(errorObject){\n    // ...\n  });\n```\n\nWe also have the ability to use `can.Deferred`, which allows us to chain\ncallback functions off of each other. You can read more about this from the\n[jQuery API](https://api.jquery.com/category/deferred-object/). Using this\nmethod, we could write our `findAll` like this:\n\n```\nState.findAll({ /* paramsObject */ })\n  /* When the API call succeeds, .done() is called */\n  .done(function(returnedObject) {\n    // ...\n  })\n  /* When the API call errors, .fails() is called */\n  .fail(function(errorObject) {\n    // ...\n  });\n```\n\nBoth are acceptable, but throughout the guide we will use the Deferred method\nas it more explicitly states which callback function is which.\n\nFinally, let’s add the scripts we modified to our `index.html` file.\nFind these lines:\n\n```\n\t<!-- Replace with city model script -->\n\t<!-- Replace with fixtures script -->\n\t<!-- Replace with state model script -->\n```\n\nand replace it with these lines:\n\n```\n\t<script src=\"models/city.js\"></script>\n\t<script src=\"models/fixtures.js\"></script>\n\t<script src=\"models/state.js\"></script>\n```\n\nLet’s go back to our app now and see what happens! If everything went\naccording to plan, you should be able to refresh the Restaurants page\nand see the same list that we had before. Selecting a state, then a city,\nshould work the same as well.\n\n![set up state selector](../can/guides/images/view-models/view_model_city.png)\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; View Models](ViewModels.html)</span>\n<span class=\"pull-right\">[Loading States &rsaquo;](LoadingStates.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/DataModelsAndFixtures",
    "title": "Data Models and Fixtures",
    "type": "page",
    "parent": "guides/pmo",
    "order": 9,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/Observables": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/observables.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - `can.Map`, and\n - `can.List`\n- - -\n\nObservables are the subjects in the\n[observer pattern](http://en.wikipedia.org/wiki/Observer_pattern).\nThey let you create relationships between objects\nwhere one object (or objects) listens for and responds to changes in another object.\nMost of the core objects in CanJS are observables. Understanding how to effectively\nwork with observables lies at the heart of understanding how to build successful\nCanJS applications.\n\nIn this section, we’ll review the two observables that make up the core of most CanJS objects:\n\n - [`can.Map`](../docs/can.Map.html) - Used for Objects.\n - [`can.List`](../docs/can.List.html) - Used for Arrays.\n\n`can.Map` and `can.List` are often extended to create observable types. For example,\n[can.Model](../docs/can.Model.html) and [can.route](../docs/can.route.html) are\nbased on `can.Map`, and a `can.Component`’s [`viewModel`](../docs/can.Component.prototype.viewModel.html)\nis a `can.Map`.\n\n## Creating Instances\n\nTo create a Map, call `new can.Map(object)`. This will give you a map\nwith the same properties and values as the _object_ you passed in to the `can.Map` constructor.\n\nTo create a List, call `new can.List(array)`. This will give you a List with the same elements as the\n_array_ you passed into the `can.List` constructor.\n\n```\nvar pagination = new can.Map({page: 1, perPage: 25, count: 1388});\npagination.attr('perPage'); // 25\n\nvar hobbies = new can.List(['programming', 'bball', 'party rocking']);\nhobbies.attr(2); // 'party rocking'\n```\n\n## Manipulating properties\n\nThe [`attr`](../docs/can.Map.prototype.attr.html) method is\nused to read a property from, or write a property to a `can.Map` or `can.List`.\nWhile you can read the properties of a `can.Map` or `can.List` directly off\nof the object, to take advantage of the observable functionality you must\nuse the `.attr` syntax.\n\n```\nvar pagination = new can.Map({page: 1, perPage: 25, count: 1388});\n\npagination.attr('perPage');     // 25\npagination.attr('perPage', 50);\npagination.attr('perPage');     // 50\n\npagination.attr({page: 10, lastVisited: 1});\npagination.attr(); // {page: 10, perPage: 50, count: 1388, lastVisited: 1}\n```\n\nProperties can be removed by using [`removeAttr`](../docs/can.Map.prototype.removeAttr.html),\nwhich is equivalent to the `delete` keyword:\n\n```\npagination.removeAttr('count');\npagination.attr(); // {page: 10, perPage: 50, lastVisited: 1}\n```\n\n## Extending a Map\n\nExtending a `can.Map` (or `can.List`) lets you create custom observable\ntypes. The following extends `can.Map` to create a Paginate type that\nhas a `.next()` method:\n\n```\nPaginate = can.Map.extend({\n  define: {\n    limit: {\n      value: 100\n    },\n    offset: {\n      value: 100\n    },\n    count: {\n      value: Infinity\n    }\n  },\n  next: function() {\n\tthis.attr('offset', this.attr('offset') + this.attr('limit') );\n  }\n});\n\nvar pageInfo = new Paginate();\npageInfo.attr(\"offset\") //-> 100\n\npageInfo.next();\n\npageInfo.attr(\"offset\") //-> 200\n```\n\n## Responding to changes\n\nWhen a property on a Map is changed with `attr`, it will emit an event with the\nname of the changed property.  You can [bind](../docs/can.Map.prototype.bind.html)\nto those events and perform some action:\n\n```\npagination.bind('page', function(event, newVal, oldVal) {\n\tnewVal; // 11\n\toldVal; // 10\n\n\t$(\"#page\").text(\"Page: \"+newVal);\n});\n\npagination.attr('page', 11);\n```\n\nAlthough `bind` and its corresponding `unbind` method exist, __there's almost no\nreason to ever use them!__  This is because there are better ways to perform\nthe common actions that would require binding to an observable.\n\nFor example, `stache` templates will automatically update when an observable changes:\n\n```\nvar template = can.stache(\"<span id='page'>{{page}}</span>\");\n$(\"body\").append(template(pagination));\n\ndocument.getElementById(\"page\").innerHTML //-> \"11\"\n\npagination.attr('page', 12);\n\ndocument.getElementById(\"page\").innerHTML //-> \"12\"\n```\n\nThe other common use case is to create some new, derived value.  [can.compute](../docs/can.compute.html)\nor [define getters](../docs/can.Map.prototype.define.get.html) lets you use functional\n(and reactive) programming techniques to derive new values from source\nstate.\n\nFor example, we can create a virtual `page` observable that derives its value from the\n`offset` and `limit`:\n\n```\nvar pagination = new Paginate({\n  limit: 10,\n  offset: 20\n});\n\nvar page = can.compute(function(){\n  return Math.floor(pagination.attr('offset') /\n                    pagination.attr('limit')) + 1;\n});\n\npage() //-> 3\n\npage.bind(\"change\", function(ev, newValue){\n  newValue //-> 4\n});\n\npagination.attr(\"offset\",30);\n```\n\nIn this example `page` will automatically be updated when either `offset` or `limit` change.\n\n\nHowever, `page` is more commonly created as a \"virtual\" property of the `Paginate` Map type\nusing a [define getter](../docs/can.Map.prototype.define.get.html):\n\n```\nPaginate = can.Map.extend({\n  define: {\n    ...\n    page: {\n      get: function() {\n\t    return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n      }\n    }\n  },\n  ...\n});\n\nvar pageInfo = new Paginate({\n  limit: 10,\n  offset: 20,\n  count: 30\n});\npageInfo.attr(\"page\") //-> 3\n\npageInfo.bind(\"page\", function(ev, newVal){\n  newVal //-> 4\n});\n\npageInfo.next();\n```\n\nUsing computes and define getters are very similar to using functional-reactive programming\nevent streams.  Given some source state, they are able to derive and combine it into new values.\n\nComputes and define getters are easier, but less powerful than event streams.  Computes\nand define getters only respond to changes in values where event streams\nare also able to respond to events. However, computes and define getters\nare eaiser to express and automatically manage subscriptions to source values.\n\nFor example, consider deriving a total for one of two menus depending on the time\nof day:\n\n```\nvar lunch = new can.List([\n  {name: \"nachos\", price: 10.25},\n  {name: \"water\", price: 0},\n  {name: \"taco\", price: 3.25}\n]);\n\nvar dinner = new can.List([\n  {name: \"burrito\", price: 12.25},\n  {name: \"agua\", price: 1.20}\n]);\n\nvar timeOfDay = can.compute(\"lunch\");\n\nvar total = can.compute(function(){\n  var list = timeOfDay() === \"lunch\" ? lunch : dinner;\n  var sum = 0;\n  list.forEach(function(item){\n    sum += item.attr(\"price\");\n  });\n  return sum;\n});\n```\n\nIn this example, `total` will listen to not only `timeOfDay`, but\nalso when items are added or removed to `lunch` or `dinner`, and each item's\n`price`.  Furthermore, it only listens to just what needs to be listened to. It will\nlisten to either `lunch` or `dinner`, but not both.\n\nIn the [next chapter](TheDefinePlugin.html) we'll expand on the use of the define plugin\nand show how it can handle asyncronous derived data like AJAX requests.\n\n## Iterating though a Map\n\nIf you want to iterate through the properties on a Map, use `each`:\n\n```\nvar pagination = new can.Map({page: 10, perPage: 25, count: 1388});\n\npagination.each(function(val, key) {\n\tconsole.log(key + ': ' + val);\n});\n\n// The console shows:\n// page: 10\n// perPage: 25\n// count: 1388\n```\n\n\n\n## Observable Arrays\n\nCanJS also provides observable arrays with `can.List`.\n`can.List` inherits from `can.Map`. A `can.List` works much the same way a\n`can.Map` does, with the addition of methods useful for working with\narrays:\n\n- [`indexOf`](../docs/can.List.prototype.indexOf.html), which looks for an item in a\nList.\n- [`pop`](../docs/can.List.prototype.pop.html), which removes the last item from a\nList.\n- [`push`](../docs/can.List.prototype.push.html), which adds an item to the end of a\nList.\n- [`shift`](../docs/can.List.prototype.shift.html), which removes the first item from\na List.\n- [`unshift`](../docs/can.List.prototype.unshift.html), which adds an item to the front\nof a List.\n- [`splice`](../docs/can.List.prototype.splice.html), which removes and inserts items\nanywhere in a List.\n\nWhen these methods are used to modify a List events are\nemitted that you can listen for, as well. See [the API for Lists](../docs/can.List.html) for more\ninformation.\n\n\n\n<span class=\"pull-left\">[&lsaquo; Application Foundations](ApplicationFoundations.html)</span>\n<span class=\"pull-right\">[The Define Plugin &rsaquo;](TheDefinePlugin.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/Observables",
    "title": "Observables",
    "type": "page",
    "parent": "guides/pmo",
    "order": 3,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/Recap": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/recap.md"
    },
    "body": "\n<div class=\"getting-started\">\n\nWe’ve come a long way since we started developing our first CanJS application.\nNice work! Together, we’ve covered:\n\n- The recommended application structure.\n- Building a `can.Component`.\n- Binding to templates with `can.view`.\n- Accessing service-exposed data with `can.Model`.\n- Interrupting service calls to mimic server responses with `can.fixture`.\n- Tying the application together with an Application State object.\n- Binding the Application State object with the base template, and the\n  application's route to enable routing.\n\nThose are all the pieces you need to start building applications with CanJS\ntoday.\n\n<!--\nIf you're interested in more advanced topics, like using CanJS with\nDependency Management utilities like StealJS, Require, or Browserify, see the\n[appendices](#appendices) for more information.\n-->\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Web Service Communication](WebServiceCommunication.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/Recap",
    "title": "Recap",
    "type": "page",
    "parent": "guides/pmo",
    "order": 13,
    "comment": " "
  },
  "pmo/Setup": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/setup.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - Configuring and Downloading CanJS\n - Recommended folder structure\n - Applicaiton Bootstrap\n\nGet the code for: [chapter 1](https://github.com/canjs/canjs/blob/minor/guides/examples/PlaceMyOrder/ch-1_canjs-getting-started.zip?raw=true)\n\n- - -\n\nTo begin, we’ll make sure we have everything we need to make our application.\nThe first thing to do is get CanJS. The easiest way to get CanJS is to use\nthe the custom download page, which allows you to\ndownload the specific parts of CanJS you need for your application.\n\nThe custom download page loads with all the elements in the core CanJS library\nalready selected. We want all of those in our build, so leave them checked.\nCanJS relies on an external core library for some of its functionality. The default option is\njQuery; and that's what we’ll be working with here.\n\nThe right side of the page lists all of the plugins. From the list of plugins,\nselect the following:\n\n![CanJS plugins to select](../can/guides/images/setup/DownloadOptions.png)\n\nAt the bottom of the page, click the download button. You'll be prompted to\ndownload a file called `can.custom.js`. Save that file to your local machine.\n\nYou can access the custom download page here: <a href=\"../download.html\" target=\"_blank\">Custom downloader</a>\n\nThere is one additional file we need, which we won't download, yet. This file is\nspecial. You normally wouldn't want it to be a part of your final application,\nbut it can be very helpful during development. The file is `can.fixture.js`.\n[can.fixture](../docs/can.fixture.html) allows you to simulate RESTful services. We'll cover how to\ninclude `can.fixture` in the next chapter.\n\nIn the next step, we’ll set up the application's folder structure, and move the\n`can.custom.js` file into its appropriate folder in the app.\n\n## Folder Structure\n\nWhen building a CanJS app, because our application will be built using\ncomponents, we use a component-based folder structure. This structure makes it\neasier to both manage the contents of the component and port the component,\nshould you want to use it in another application.\n\nOff of a root folder called `PlaceMyOrder`, create the following subfolders:\n\n<pre>\n└── PlaceMyOrder\n    └── app\n        ├── components\n        ├── libs\n        ├── models\n        └── site_css\n</pre>\n\nCopy the <a href=\"https://raw.githubusercontent.com/canjs/canjs/guides-overhaul/guides/examples/PlaceMyOrder/chapter_9/app/site_css/place_my_order.css\" target=\"_blank\">CSS file</a>\nthat accompanies this guide into your `site_css` folder. We won't be covering\nany of the CSS here. Next, copy the `can.custom.js` file you downloaded in\nthe previous step into the `libs` folder.\n\nFinally, you'll need to download the supporting libraries. They are:\n\n- <a href=\"http://jquery.com/download/\" target=\"_blank\">jQuery 2.x</a>\n- <a href=\"http://canjs.com/release/2.1.4/can.fixture.js\" target=\"_blank\">can.fixture</a>\n\nOnce you've downloaded these files, rename the jQuery file to `jquery.js` and\ncopy both files to the `libs` directory in your application folder.\n\n## index.html <a name=\"index-file\"></a>\nCreate a file called \"index.html\" in the app folder.\n\n<pre>\n└── app\n    └── index.html\n</pre>\n\nIt should look like this:\n\n```html\n<!DOCTYPE html>\n<html>\n  <head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css\"/>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"site_css/place_my_order.css\"/>\n  </head>\n  <body>\n\n    <!-- CanJS application root -->\n    <div id=\"can-app\"></div>\n\n    <script src=\"libs/jquery.js\"></script>\n    <script src=\"libs/can.custom.js\"></script>\n    <script src=\"libs/can.fixture.js\"></script>\n    <script src=\"app.js\"></script>\n  </body>\n</html>\n```\n\nAt the bottom of the page, just before the body tag, are all of the script\ntags. We’re using the jQuery edition of CanJS, so the first script tag\nloaded must be jQuery. Following jQuery, we load `can.custom.js`.\n\nIn the last chapter, we mentioned including `can.fixture.js`. In a\nnormal project, once you connected to the actual REST services, you would\nremove `can.fixture.js`. In addition, to simplify things, we’re using the\nBootstrap framework for our CSS; however Bootstrap is not required to use CanJS.\n\n### Base Template\nCreate a file in the `app` folder called `base_template.stache`. We'll edit the\ncontents of that file as we build out our application. For now, you can\nleave it blank.\n\n## Application Bootstrap\nThe first script we need to create is the script that will bootstrap our\napplication. Create a file in the app folder called `app.js`. Edit the\nfile as follows:\n\n```\n$(function () {\n  $('#can-app').html('The Requisite \"Hello World\" Message');\n});\n```\n\nIf you open up your application in a browser, you should see:\n\n> The Requisite \"Hello World\" Message\n\nAt this point, we haven't done much. We aren't using CanJS at all yet.\nWe’re just using jQuery to set the HTML contents of a DOM element.\n\nSo, how do we get the application to actually *do something*? Building apps\nwith CanJS centers around building can.Components, read on to the next\nchapter to learn more.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Getting Started](Tutorial.html)</span>\n<span class=\"pull-right\">[Application Foundations &rsaquo;](ApplicationFoundations.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "pmo/Setup",
    "title": "Setup",
    "type": "page",
    "parent": "guides/pmo",
    "order": 2,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/StacheTemplates": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/stache-templates.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Stache Templates\n\nGet the code for: [chapter: stache templates](/guides/examples/PlaceMyOrder/ch-2_canjs-getting-started.zip)\n\n- - -\n\nNow that we have a basic sketch of our application, and we've covered a few CanJS fundamentals,\nit’s time for us to start working with the sample application. We'll begin with the\napplication's templates.\n\nAs mentioned in the [introduction](./Tutorial.html), we’re using Stache templates in\nour app. Remember that when we downloaded our custom build of CanJS, we\nincluded the [can.stache](../docs/can.stache.html) plugin.\n\nWe can create a simple template, render it to a document fragment and insert it into the page like\nthe following:\n\n```\nvar template = can.stache(\"<h1>{{message}}</h1>\");\nvar frag = template({message: \"Hello World\"});\n$(\"body\").append(frag);\n```\n\nStache templates look similar to normal HTML, except they contain magic tags that contain\na very simple language that can be used to:\n\n- [lookup and insert values into the html output](#context)\n- [loop over arrays and can.Lists](#enumeration)\n- [control-flow behavior like if and switch](#conditionallogic)\n- [render other templates with partials](#partials)\n- perform custom control-flow behavior\n\n\nStache templates support both [Mustache](https://github.com/janl/mustache.js/)\nand [Handlebar](http://handlebarsjs.com/) syntax. For more\ninformation on the details of these formats, see their respective websites.\n\nIt will be easiest for us to look at these with an example, so let’s work with\none. Open up your `components/order_details/order_details.stache` file.\nIt should look like this:\n\n\n```html\n{{#with order}}\n  <h3>Thanks for your order {{name}}!</h3>\n  <div>\n  \t<label class=\"control-label\">Confirmation Number: {{_id}}</label>\n  </div>\n\n  <h4>Items ordered:</h4>\n  <ul class=\"list-group panel\">\n    {{#each items}}\n      <li class=\"list-group-item\">\n        <label>\n          {{name}} <span class=\"badge\">${{price}}</span>\n        </label>\n      </li>\n    {{/each}}\n\n    <li class=\"list-group-item\">\n      <label>Total <span class=\"badge\">${{total}}</span></label>\n    </li>\n  </ul>\n\n  <div><label class=\"control-label\">Phone: {{phone}}</label></div>\n  <div><label class=\"control-label\">Address: {{address}}</label></div>\n{{/with}}\n```\n\n<a name=\"context\"></a>\n## Value lookup\n\nAssume for the moment that we have the following `customerOrder` map passed in to our Stache template:\n\n```\n{\n   customerNumber: 12543,\n   customerType: 'Business',\n   order: {\n      name: 'Rudloph Steiner',\n      _id: 837267,\n      items: [\n         {\n            name: 'Garden Gnome',\n            price: 23.70\n         }\n      ],\n      total: 23.70,\n      phone: '+49 170 345 6789',\n      address: 'Beuselstrasse 15, Berlin',\n\n      total: function(){\n        var sum = 0;\n        this.items.forEach(function(item){\n          sum += item.price;\n        });\n        return sum;\n      }\n   }\n}\n```\n\nIf we want to show the `customerType` in a `<span>` we can do that in a stache template like the following:\n\n```\n<span>{{customerType}}</span>\n```\n\nWhat's inside the magic tags, in this case `customerType`, is a\n[key lookup expression](../docs/can.stache.expressions.html#section_KeyLookupexpressions).\n[Keys](../docs/can.stache.key.html) are used to lookup values in the\n[template scope](../docs/can.view.Scope.html).  \n\nA DOT(`.`) operator\ncan be used to lookup nested values.  For example:\n\n```\n<h3>Thanks for your order {{order.name}}!</h3>\n<span>{{customerType}}</span>\n```\n\nSimilar to variable lookup JavaScript, a stache key lookup can search for a value in multiple places.\nEach of these places is called a __context__.  The collection of all available contexts for a key lookup\nis called a [scope](../docs/can.view.Scope.html).\n\nThe root context is\nthe data passed to a template. In this case, the root context is the `customerOrder`\nobject at the begining of this section.  This is why `{{customerType}}` outputs `Business`.\n\n[Sections](../docs/can.stache.tags.section.html)\ncreate contexts in Stache.  A section begins with `{{#EXPRESSION}}` or `{{^EXPRESSION}}`\nand ends with `{{/EXPRESSION}}`.  In the following example `{{#with order}}`\ndefines a section whose scope lookup starts finding values in the\n`customerOrder`'s `order` object first:\n\n```html\n{{#with order}}\n  <h3>Thanks for your order {{name}}!</h3>\n  <span>{{customerType}}</span>\n{{#with order}}\n```\n\nIn between `{{#with order}}` and `{{/with}}`, the scope's contexts look like:\n\n```\n[\n  customerOrder.order,\n  customerOrder\n]\n```\n\nThe top of the scope is called the __current context__.  In this case it is `customerOrder.order`.\n\n\nWhen `{{name}}` is looked up, it will first look for `name` on the __current context__.  As that value\nexists, `Rudloph Steiner` will be returned.\n\nWhen `{{customerType}}` is looked up, it will look for `customerType` on the __current context__.  As\nthat value does not exist, the next context, `customerOrder`, will be searched. The value of\n`customerOrder.customerType` will be returned.\n\nFrom within a given scope, you can reference the __current context__ or control which context\nshould be used to find values.\n\nSee examples below:\n\n```html\n{{#with order}}\n   <div>My Current Context Object: {{.}}</div> <!-- references the order object-->\n   <div>My Parent Context Object: {{../.}}</div>  <!-- references the customerOrder object-->\n   <div>An Item on my Parent Context's Object: {{../customerNumber}}</div>\n   <div>My Parent's Parent Context Object: {{../../.}}</div> <!-- example of how you might access the parent of a parent -->\n{{/with}}\n```\n\n<a name=\"enumeration\"></a>\n## Looping over arrays\nEnumerating allows you to loop through the contents of an iterable item. We’ve done this above for\nthe options in our select dropdown. The `{{#each key}} ... {{/each}}` tag set\nis used to iterate over an enumerable collection, such as an array. In the\nexample above, we are looping over an array of objects. As with [sections](#context),\nthe properties of the objects we are iterating over are accessible\nfrom data keys inside the `#each` scope without dot notation. In the example\nabove, we saw:\n\n```html\n{{#each items}}\n  <li class=\"list-group-item\">\n\t<label>\n\t  {{name}} <span class=\"badge\">${{price}}</span>\n\t</label>\n  </li>\n{{/each}}\n```\n\nBecause the context of the `{{#each}}` block is `items`, we can reference\nthe `name` and `price` properties of `items` directly&mdash;i.e, we don't need to\nwrite `{{items.name}}` or `{{items.price}}`, we can just write `{{name}}` or `{{price}}`.\n\nCall expressions can also be passed\nto [#each](../docs/can.stache.helpers.each.html). For example, a ViewModel might\nhave a method to get menu items for a particular menu like `\"dinner\"` or\n`\"lunch\"` like:\n\n```\nvar OrderViewModel = can.Map.extend({\n  itemsForMenuType: function(type){\n    return this.attr(\"menu.items\").filter(function(item){\n      return item.attr(\"type\") === type;\n    })\n  }\n})\n```\n\nCall this method and return its result to `#each` like:\n\n```\n{{#each itemsForMenuType(\"lunch\")}}\n  <li>...</li>\n{{/each}}\n```\n\nNote that [#key](../docs/can.stache.tags.section.html) can also\nbe used to loop through objects with enumerable properties. In general,\n[#each](../docs/can.stache.helpers.each.html) should be used if the key references\n[can.List](../docs/can.List.html) or Arrays that have or often have incremental updates. [#key](../docs/can.stache.tags.section.html)\nshould be used when the list is replaced by a list with items that look\nnothing like the previous list's items.\n\n<a name=\"conditionallogic\"></a>\n## Conditional Logic\nStache templates have a limited capacity for conditional logic. Open up your\n`main.stache` file. It should look like this:\n\n```\n{{> header.stache}}\n\n{{#eq page \"home\"}}\n  {{> home.stache}}\n{{/eq}}\n\n{{#eq page \"restaurants\"}}\n  {{#if slug}}\n    {{#eq action 'order'}}\n      <pmo-order {(slug)}=\"slug\"></pmo-order>\n    {{/eq}}\n    {{^if action}}\n      <pmo-restaurant-details {(slug)}=\"slug\"></pmo-restaurant-details>\n    {{/if}}\n  {{else}}\n    <pmo-restaurant-list></pmo-restaurant-list>\n  {{/if}}\n{{/eq}}\n\n{{#eq page \"orders\"}}\n  <pmo-order-history></pmo-order-history>\n{{/eq}}\n```\n\nYou’ll see two different helpers: `eq` and `if`. The `eq` helper takes two\narguments: the first being the key that is within the current section, and\nthe second a value to compare to the first argument to see if they are equal.\nThe `if` helper checks for one truthy argument before rendering what the\n`if` block contains.\n\nYou might also notice the use of the `^` character, which will render the\nsection if the result of the helper is false. In other words, you can write\n`{{^if action}}content{{/if}}` instead of `{{#if action}}{{else}}content{{/if}}`\n\nIn general, it’s best to keep complex logic out of your templates. Their main function\nshould be to display data from the view model. If you need to use more complex logic\nto display data in your templates, you can use a helper. Helpers are not covered in detail\nin this guide; but you can get more information on them in the API: [Helpers](../docs/can.Component.prototype.helpers.html)\n\n<a name=\"partials\"></a>\n## Partials\nYou can nest templates in other templates by using partials. Partials inherit\nthe context from which they are called. They are evaluated at render time, so you\nshould be careful to avoid infinite loops. To include a partial, put its URL or\nID inside `{{> }}`.\n\nIn our example above, you can see that `{{> header.stache}}` includes the\n`header.stache` file into the template.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; The Define Plugin](TheDefinePlugin.html)</span>\n<span class=\"pull-right\">[App State and Routing &rsaquo;](AppStateAndRouting.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/StacheTemplates",
    "title": "Stache Templates",
    "type": "page",
    "parent": "guides/pmo",
    "order": 5,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/TheDefinePlugin": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/the-define-plugin.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - The Define Plugin\n\n*There is no code to download for this chapter*\n- - -\n\nThe `define` plugin allows you to finely control the the behavior of the\nattributes on a `can.Map`. For any property you declare in the `define` plugin,\nyou can control its:\n\n- [set](#set)\n- [get](#get)\n- [type](#type)\n- [value](#value)\n- [remove](#remove)\n- [serialization](#serialization)\n\nBefore we get into the properties of the define plugin, however, let’s look at how to set it up.\nCreating a define is as simple as adding a define property to the instance properties\nof the `can.Map`. This property is an object literal. Remember from our conversation on\n[`can.Construct`](Constructors.html) that passing in one argument to a `can.Construct` will set\nits instance properties. This is important to know should you create a `can.Map` that has both\ninstance and static properties, and you want to use the define plugin. Below are two examples:\n\n```\n//can.Map with one argument\nvar Person = can.Map.extend({\n    define: {\n        //define properties go here\n        myProperty: {\n           //property attributes\n        }\n    }\n});\n\n//can.Map with two arguments\nvar Person = can.Map.extend(\n{\n   //static properties go here\n},\n{\n    define: {\n        //define properties go here\n        myProperty: {\n           //property attributes\n        }\n    }\n});\n```\n\n<a name=\"set\"></a>\n### set\nA [set](../docs/can.Map.prototype.define.set.html) function defines what happens when a value is set on a `can.Map`.\nIt is typically used to update other attributes on the `can.Map` as a side\neffect, or coerce the set value into specific format.\n\nThe setter function can take two optional arguments:\n\n- `newVal`: The type function coerced value the user intends to set on the `can.Map`\n- `setVal`: A callback that can set the value of the property asynchronously.\n\nWhen using a setter function, the final value of the attribute is determined\nby the value the setter function returns. If the function returns a value,\nthat value is used as the value of the attribute. If `undefined` is\nreturned, the behavior depends on the number of arguments the setter\n*declares*, as below:\n\n```\n// If the setter does not specify the newValue argument,\n// the attribute value is set to whatever was passed to attr.\nset: function() { ... }\n\n// If the setter specifies the newValue argument only,\n// the attribute value will be removed\nset: function(newValue) { ... }\n\n// If the setter specifies both newValue and setValue, the value of\n// the property will not be updated until setValue is called\nset: function(newValue, setValue) { ... }\n```\n\n<a name=\"get\"></a>\n### get\nA [get](../docs/can.Map.prototype.define.get.html) function defines what happens when a value is read on a `can.Map`.\nIt is typically used to provide properties that derive their value from other\nproperties of the map, as below:\n\n```\nvar Person = can.Map.extend({\n    define: {\n        fullName: {\n            get: function () {\n                return this.attr(\"first\") + \" \" + this.attr(\"last\");\n            }\n        }\n    }\n});\n```\n\n`get` is passed two optional arguments: `lastSetValue` and `resolve`.  \n\n`lastSetValue` is the last value the property was set to.  This, among other uses,\ncan be used to update a list in place instead of replacing it.  The following\nkeeps `taskIds` updated with all of `tasks`' ids:\n\n```\nvar Person = can.Map.extend({\n    define: {\n        taskIds: {\n            Value: can.List,\n            get: function(initialValue){\n                var ids = this.attr('tasks').map(function(task){\n                    return task.attr(\"id\");\n                });\n                return initialValue.replace(ids);\n            }\n        }\n    }\n});\n```\n\n\n\n`resolve` can asynchronously set the retrived value of a\n\"bound\" property.  The following makes `person` update when `personId` changes.\n`person` will be a `Person` instance retrieved from the server.\n\n```\nvar AppViewModel = can.Map.extend({\n  define: {\n    person: {\n      get: function(lastSetValue, resolve){\n        Person.findOne({id: this.attr(\"personId\")})\n            .then(resolve);\n      }\n    }\n  }\n});\n```\n\nAsynchronous getters must be bound to to behave correctly.  In most apps, this happens\nautomatically because observables are \"bound\" by a template.  However,\nwhen testing, you'll need to remember to [bind](../docs/can.Map.prototype.bind.html)\non that property before reading it. Here's how one might test the previous `AppViewModel`:\n\n```\nvar appVM = new AppViewModel({\n  personId: 5\n});\n\nappVM.bind(\"person\", function(ev, newVal, oldVal){\n  // `person` will change from undefined to a\n  // Person instance.\n  ok(newVal instanceof Person)\n});\n\n// appVM is `undefined` here because\n// `Person.findOne` hasn't returned yet\nappVM.attr(\"person\") //-> undefined\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n<a name=\"type\"></a>\n### type\nThe [type](/docs/can.Map.prototype.define.type.html) property converts a value passed to an `attr` setter function\ninto a specific value type. The type can be specified as either a type\nfunction, or one of the following strings:\n\n- `string` - Converts the value to a string.\n- `date` - Converts the value to a date or `null` if the date can not be converted.\n- `number` - Passes the value through `parseFloat`.\n- `boolean` - Converts falsey values (such as `\"\"` or `0`) to `false` and everything else to `true`.\n- `*` - Prevents the default coercion of Objects to can.Maps and Arrays to can.Lists.\n\nThere are two ways to define the `type` property:\n\n - `Type`\n - `type`\n\n`Type`, uppercase, makes sure that the set value is an\n[instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) the provided\nconstructor function.  If not, the constructor function will be called with `new` and passed the set value as the first\nargument.\n\nIn contrast, `type`, lowercase, is called no matter what and expected to return the value that should be set on the map.\n\n```\ndefine: {\n  items: {\n    type: function(newValue){\n      return typeof newValue === \"string\" ?  newValue.split(\",\") : newValue;\n    }\n  }\n}\n```\n\n<a name=\"value\"></a>\n### value\n\nSets the default value for instances of the `can.Map`. If the default\nvalue should be an object of some type, it should be specified as the return\nvalue of a function, so that all instances of the map don't point to the same\nobject. This is because JavaScript passes primitives by value, and all other\nvalues (objects, arrays, etc.) by reference.\n\n```\ndefine: {\n  prop: {\n    value: function(){ return []; }\n  }\n}\n```\n\nAs with `type`, above, there are two ways to define the `value` property: `Value`,\nor `value`. [Value](../docs/can.Map.prototype.define.ValueConstructor.html), uppercase, provides a constructor function, ensuring that\na new instance of `Value` is made for each map instance. If [value](../docs/can.Map.prototype.define.value.html) is not an function,\nthat value will be the default value of the attribute. If `value` is a function,\nthat function's return value will be used as the default value of the attribute.\n\n<a name=\"remove\"></a>\n### remove\n\nThe [remove](../docs/can.Map.prototype.define.remove.html) property is called  when an attribute is removed. This is often used to remove other related properties.\n\n<a name=\"serialization\"></a>\n### serialization\nThe last property we’ll talk about is [serialization](https://en.wikipedia.org/wiki/Serialization). The\n[serialize](../docs/can.Map.prototype.define.serialize.html) property defines how the attribute will behave when the map is\nserialized. Managing this property can be useful when serializing complex types like dates,\narrays, or objects into strings. You can also control whether or not a\ngiven property can be serialized. Returning `undefined` from a serialization\nfunction for any property means this property will not be part of the\nserialized object. Managing serialization is an important consideration in [routing](AppStateAndRouting.html).\nWe’ll see how this works when we discuss routing in a later chapter.\n\n```\ndefine: {\n  locationIds: {\n    serialize: false\n  }\n}\n```\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Observables](Observables.html)</span>\n<span class=\"pull-right\">[Stache Templates &rsaquo;](StacheTemplates.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/TheDefinePlugin",
    "title": "The Define Plugin",
    "type": "page",
    "parent": "guides/pmo",
    "order": 4,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/tutorial.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n*Better Apps, Faster*\n\nCanJS is a lightweight, modern JavaScript <a href=\"https://en.wikipedia.org/wiki/Model_View_ViewModel\" target=\"_blank\">MVVM</a>\nframework that’s fast and easy to use, while remaining robust and extensible\nenough to power some of the most trafficked websites in the world. This guide\nwill walk you through an analysis of a small e-commerce app built with CanJS called __Place My Order__.\nIn each relevant section, we’ll give you some code to play with\nso you will have hands on experience working with CanJS.\n\n![place-my-order.com home page](../can/guides/images/application-design/Home.png)\n\nFor a version of this guide that walks through testing, documenting, building, and deploying the same\napplication, checkout [DoneJS's In Depth Guide](http://donejs.com/place-my-order.html).  This\nguide focuses more on the CanJS parts.\n\n## The Basics\n\nEvery CanJS application contains:\n\n- [Observables](#observables),\n- [Models](#models),\n- [ViewModels](#view-models)\n- [Views](#views),\n- [Custom Elements](#custom_elements), and\n- [Routing with an AppViewModel](#routing)\n\n<a name=\"observables\"></a>\n### Observables\nObservable objects provide a way for you to make changes to data and listen to\nthose changes. Observables such as [can.List](../docs/can.List.html), [can.Map](../docs/can.Map.html), and\n[can.compute](../docs/can.compute.html) provide the\nfoundation for models, view-models, view bindings, and even routing in your app. [can.compute](../docs/can.compute.html)\nis able to combine observable values into new observable values.\n\n[Example: Creating a derived value from source observables.](http://justinbmeyer.jsbin.com/koqaxe/edit?js,console)\n\n```\nvar info = can.compute(function(){\n  return person.attr(\"first\")+\" \"+person.attr(\"last\")+\n    \" likes \"+ hobbies.join(\", \")+\".\";\n});\n```\n\nThe [define plugin](../docs/can.Map.prototype.define.html) allows you to define rich property behaviors on\ncustom Map types.\n\n[Example: Creating a derived value as part of a custom type.](http://justinbmeyer.jsbin.com/wuwifaf/edit?js,console)\n```\nPerson = can.Map.extend({\n  define: {\n    fullName: {\n      get: function(){\n        return this.attr(\"first\")+\" \"+this.attr(\"last\");\n      }\n    }\n  }\n});\n```\n\n\n<a name=\"models\"></a>\n### Models\nModels let you get and modify data from the server. They also hydrate\nraw, serialized service data into more useful (and observable) typed\ndata in the client. [can.Model](../docs/can.Model.html) makes it easy to connect to restful services\nand perform Create, Retrieve, Update, and Delete (CRUD) operations.\n\nFor applications requiring real-time, high performance, restful data connections you should check out [can-connect](http://connect.canjs.com/).\n\n[Example: Simulate a restful service and create, update, and delete its data.](http://justinbmeyer.jsbin.com/codubev/edit?js,console)\n```\n// Create an order.\nvar order = new Order({\n  price: 20\n});\n\n// Create it on the server.\norder.save().then(function(order){\n  // Change its values and\n  // update it on the server.\n  return order.attr(\"price\",22)\n       .save();\n}).then(function(order){\n  // Destroy it on the server.\n  return order.destroy();\n});\n```\n\n<a name=\"view-models\"></a>\n### ViewModels\n\nViewModels contain the state and model data used by views to create HTML. They also\ncontain methods that the views can call. Custom [can.Map](../docs/can.Map.html) types\nare used as easily unit-testable view-models.  \n\n[Example: Define and test a view-model that derives values from source state.](http://jsbin.com/sotero/edit?js,output)\n```\nvar RestaurantListVM = can.Map.extend({\n  define: {\n    restaurants: {\n      get: function() {\n        var state = this.attr('state'),\n            city = this.attr('city');\n\n        if(state && city) {\n          return Restaurant.findAll({\n            'address.state': state,\n            'address.city': city\n          });\n        }\n\n        return null;\n      }\n    }\n  }\n});\n```\n\n<a name=\"views\"></a>\n### Views\n\nViews are passed a view-model and generate visual output that’s meaningful to a user - in our case that\noutput is HTML.  Views are able to:\n\n- Listen to changes in view-models and models and update the HTML (__one-way bindings__).\n- Listen to HTML events, like clicks, and call methods on the view-models and models (__event bindings__).\n- Listen to form elements changing and update view-model and model data (__two-way bindings__).\n\nIn CanJS, the preferred method for creating views is using [can.stache](../docs/can.stache.html)\ntemplates. `can.stache` uses mustache/handlebars syntax. `can.stache`'s event and two-way binding\nsyntaxes can be found at [can.view.bindings](../docs/can.view.bindings.html).\n\nAt this time, `can.stache` is supplied as a supporting\nlibrary, which means you must explicitly add it to your application. We’ll see\nhow to do that when we set up our application in the next chapter. In 3.0,\nStache will part of the core CanJS lib.\n\n[Example: Generate HTML for the previous example's view-model.](http://justinbmeyer.jsbin.com/gewavi/edit?html,output)\n```\n<label>State</label>\n{{#if states.isPending}}\n  <select disabled><option>Loading...</option></select>\n{{else}}\n  <select {($value)}=\"state\">\n    {{^if state}}\n      <option value=\"\">Choose a state</option>\n    {{/if}}\n    {{#each states.value}}\n      <option value=\"{{short}}\">{{name}}</option>\n    {{/each}}\n  </select>\n{{/if}}\n```\n\n<a name=\"custom_elements\"></a>\n### Custom Elements\n\nCustom HTML Elements are how CanJS encapsulates and orchestrates different pieces of\nfunctionality within an application. Custom elements are built with\n[can.Component](../docs/can.Component.html) and combine a\nview-model and view.\n\n[Example: Encapsulate rich select behavior with a custom <select-loader> element.](http://justinbmeyer.jsbin.com/sonuwuc/edit?html,js,output)\n```\n<select-loader {promise}=\"states\" {(value)}=\"state\"\n               choose-text=\"Choose a state\">\n  {{#each states.value}}\n    <option value=\"{{short}}\">{{name}}</option>\n  {{/each}}\n</select-loader>\n```\n\n<a name=\"routing\"></a>\n### Routing with an AppViewModel\n\nCanJS maintains a reciprocal relationship between the browser's url\nand a [can.Map](../docs/can.Map.html) view-model. This view-model instance\nrepresents the state of the application as a whole and so is\ncalled the `appViewModel`.  When the url changes,\nCanJS will update the properties of the `appViewModel`.  When\nthe `appViewModel` changes, CanJS will update the url.  \n\n[can.route](../docs/can.route.html) is used to setup the relationship between the\n`appViewModel` and the URL. It can be used with both [pushstate](../docs/can.route.pushstate.html) and\nhashchange (the default) routing.  \n\n[Example: Route between <home-page> and <restaurants-page> custom elements.](http://jsbin.com/surokag/edit?html,js,output)\n```\n{{#eq page 'home'}}\n  <home-page/>\n{{else}}\n  <restaurants-page/>\n{{/eq}}\n```\n```\nvar AppViewModel = can.Map.extend({\n  define: {}\n});\n// Create an instance of that map\nvar appViewModel = new AppViewModel();\n\n// Connect the map to the browser's URL\ncan.route.map(appViewModel);\n\n// Define pretty routing rules\ncan.route(\":page\",{page: \"home\"});\n\n// Start the two-way binding between the URL and the `appViewModel`.\ncan.route.ready();\n```\n\nApplication ViewModels free developers\nfrom worrying about what the url looks like. Instead, you focus on\nupdating the state of the application.\n\n## Using the Getting Started Guide\nEach chapter in the Getting Started Guide is prefaced with an overview of the\ntopics covered in that chapter. The overview section also contains a link where\nyou can download a zip file containing the code relevant to that chapter, as follows:\n\n- - -\n**In this Chapter**\n - Topic 1\n - Topic 2\n - Connecting `can.Model`’s with `can.Component`’s\n\nGet the code for: [chapter 0](/guides/examples/PlaceMyOrder/ch-0_canjs-getting-started.zip)\n\n- - -\n\n- - -\n\n<span class=\"pull-right\">[Setup &rsaquo;](Setup.html)</span>\n\n</div>\n<script src=\"http://static.jsbin.com/js/embed.min.js?3.35.5\"></script>\n\n",
    "description": "\n",
    "name": "guides/pmo",
    "title": "Place My Order Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 4,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/ViewModels": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/view-models.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Getting and Setting Scope Properties\n - View Models\n\nGet the code for: [chapter: view models](/guides/examples/PlaceMyOrder/ch-5_canjs-getting-started.zip)\n\n- - -\n\nIn the last chapter, we created the `currentRestaurant` component, and included it in our\ntemplate. Let’s add a little bit more advanced functionality: two select elements,\nwhere selecting an option in the first one changes the options in the second.\n\nOpen your `components/restaurant_list/restaurant_list.stache` and edit it as follows:\n\n```\n<div class=\"restaurants\">\n  <h2 class=\"page-header\">Restaurants</h2>\n  <form class=\"form\">\n    <div class=\"form-group\">\n      <label>State</label>\n      <select {($value)}=\"state\">\n        {{^if state}}\n        <option value=\"\">Choose a state</option>\n        {{/if}}\n        {{#each states}}\n        <option value=\"{{name}}\">{{name}}</option>\n        {{/each}}\n      </select>\n    </div>\n    <!-- The city select will go here -->\n  </form>\n\n  <!-- Restaurants code will go here -->\n</div>\n```\n\nIn the above code, you can see one select element for selecting a state. You can\nsee `{{#each}}` being used to create the list of options. You can also see that\nif no state is selected, the “Choose a state” message is included as an option\nuntil one has been selected.\n\nLet’s modify our `components/restaurant_list/restaurant_list.js` file to include\nwhat’s needed for our partial:\n\n```\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: can.Map.extend({\n    define: {\n      state: {\n        value: null,\n        set: function(newState) {\n          if (newState) {\n            alert('Selected “' + newState + '” state.');\n          }\n          return newState;\n        }\n      },\n      states: {\n        value: [\n          {\n            cities: ['Green Bay', 'Milwaukee'],\n            name: 'Wisconsin'\n          },\n          {\n            cities: ['Detroit', 'Ann Arbor'],\n            name: 'Michigan'\n          },\n          {\n            cities: ['Chicago', 'Peoria'],\n            name: 'Illinois'\n          }\n        ]\n      },\n      // City code will go here\n    }\n  })\n});\n```\n\nHere we’re using [the define plugin](TheDefinePlugin.html) to set up two new\nproperties:\n- `state` to keep track of the selected state, and\n- `states` with the list of states that can be selected.\n\nIn the `state` setter, we’re showing an alert when a new state is selected.\nIf you refresh the Restaurants page, you should see a select element with the\nstates as options; when you select a state, an alert will appear with the selected\nstate’s name.\n\n![set up state selector](../can/guides/images/view-models/view_model_state.png)\n\n## Getting and Setting Scope Properties\nIt’s important to understand how to get and set the properties\nof the view model. Getting and setting are done through the `attr` function off of\nthe `viewModel` object, in this case `this` is bound to the scope, because we’re\nwithin a method of the scope. Let’s look at an example.\n\nOpen up `components/restaurant_list/restaurant_list.js` and replace this:\n\n```\n// City code will go here\n```\n\nwith this:\n\n```\n      cities: {\n        get: function() {\n          var state = this.attr('state');\n          return state && this.attr('citiesByState')[state];\n        }\n      },\n      citiesByState: {\n        get: function() {\n          var citiesByState = {};\n          this.attr('states').forEach(function(state) {\n            citiesByState[state.name] = state.cities;\n          });\n          return citiesByState;\n        }\n      },\n      city: {\n        value: null\n      }\n```\n\nThis code creates three new properties:\n- `city` with the name of the city that’s selected,\n- `citiesByState` which is an object that has the list of cities by state name, and\n- `cities` which is the list of cities for the selected state.\n\nLet’s update the stache file to take advantage of these new properties.\nOpen `components/restaurant_list/restaurant_list.stache` and find this line:\n\n```\n<!-- The city select will go here -->\n```\n\nand replace it with this:\n\n```\n    <div class=\"form-group\">\n      <label>City</label>\n      <select {($value)}=\"city\">\n        {{^if city}}\n        <option value=\"\">Choose a city</option>\n        {{/if}}\n        {{#each cities}}\n        <option>{{.}}</option>\n        {{/each}}\n      </select>\n    </div>\n```\n\nThis new part of the template will show a select element with the cities\nfor the selected state as options. Note that when no city is selected,\nthe element will have a “Choose a city” option.\n\nIf you refresh the Restaurants page, you’ll see the new city select\nelement that has options as soon as you select a state. However, there’s\na bug: if you change the state, the first city for the new state is automatically\nselected, even though the user hasn’t made a city choice. Let’s fix this\nby nullifying the city when the state changes. Find the state setter:\n\n```\n        set: function(newState) {\n          if (newState) {\n            alert('Selected “' + newState + '” state.');\n          }\n          return newState;\n        }\n```\n\nand replace it with this:\n\n```\n        set: function() {\n          // Remove the city when the state changes\n          this.attr('city', null);\n        }\n```\n\nNotice that we are nullifying the city property when the state changes.\nIf you refresh the Restaurants page in your browser, select a state,\nselect a city, then select another state, you’ll see the “Choose a city”\noption in the city select element instead of the first city in that\nstate.\n\n![set up state selector](../can/guides/images/view-models/view_model_city.png)\n\n## Separating the Component & View Model\nIt’s considered a best practice to keep your `can.Components`\nthin. This helps maintain readability and maintainability. To accomplish this,\nyou extract your scope from the `can.Component` into a `can.Map`.\n\nOpen up `components/restaurant_list/restaurant_list.js` and replace the\ncontents of the file with this:\n\n```\nvar RestaurantListViewModel = can.Map.extend({\n  define: {\n    state: {\n      value: null,\n      set: function() {\n        // Remove the city when the state changes\n        this.attr('city', null);\n      }\n    },\n    states: {\n      value: [\n        {\n          cities: ['Green Bay', 'Milwaukee'],\n          name: 'Wisconsin'\n        },\n        {\n          cities: ['Detroit', 'Ann Arbor'],\n          name: 'Michigan'\n        },\n        {\n          cities: ['Chicago', 'Peoria'],\n          name: 'Illinois'\n        }\n      ]\n    },\n    cities: {\n      get: function() {\n        var state = this.attr('state');\n        return state && this.attr('citiesByState')[state];\n      }\n    },\n    citiesByState: {\n      get: function() {\n        var citiesByState = {};\n        this.attr('states').forEach(function(state) {\n          citiesByState[state.name] = state.cities;\n        });\n        return citiesByState;\n      }\n    },\n    city: {\n      value: null\n    }\n  }\n});\n\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: RestaurantListViewModel\n});\n```\n\nIf you go back out to your application and refresh the page, it should all\nlook and work the same. What we’ve done, by separating out the view model,\nis make the code easier to read and maintain.\n\nIn the next chapter, we’ll learn about working with more realistic data by\nadding REST service interaction with `can.Model`.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Components](Components.html)</span>\n<span class=\"pull-right\">[Data Models and Fixtures &rsaquo;](DataModelsAndFixtures.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/ViewModels",
    "title": "View Models",
    "type": "page",
    "parent": "guides/pmo",
    "order": 8,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/WebServiceCommunication": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/web-service-communication.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n  - Saving and Updating a can.Model\n\nGet the code for: [chapter: web service communication](/guides/examples/PlaceMyOrder/ch-9_canjs-getting-started.zip)\n\n- - -\n\nTo illustrate sending data to a service, let’s implement saving an order in\nour `pmo-order` component. In the `components/order/order.js` file, locate\nwhere the `placeOrder` property is defined:\n\n```\n  placeOrder: function() {\n  },\n```\n\nand replace it with this implementation:\n\n```\n  placeOrder: function() {\n    var order = this.attr('order');\n    this.attr('saveStatus', order.save());\n    return false;\n  },\n```\n\nLet’s see what's going on here:\n - The first line in the getter function gets the `order`,\n - the second sets the `saveStatus` property on the component’s view model to whatever the `save` method on the `order` object returns, and\n - the third line returns `false` to stop the `form` element’s default submission behavior.\n\n## Saving and updating a model\nLet’s look at a few items in the code above.\nUnlike data access functions (e.g., `findAll`, `findOne`),\nwhich are called statically off of the prototype, the `save`, `update`, and\n`delete` functions are called off of a specific instance of a model. So, if\nwe want to create a new order, we will need to work with an instance of the\n`Order` model.\n\nTo provide fixture support for saving our `can.Model`, open up `models/fixtures.js`\nand add the following fixture:\n\n```\ncan.fixture({\n  'POST /api/orders': function(request, response){\n    var data = request.data;\n\n    response(can.extend({}, data, {\n      \"_id\":\"556f1503fdf0425207000001\"\n    }));\n  },\n\n  'GET /api/orders': 'models/orders.json'\n});\n```\n\nHere, you can see that we’re implementing the `save` functionality by\nresponding to `POST` requests to `/api/orders` with the original request\ndata, plus an `_id` property.\n\nWe also added support for `GET` requests to `/api/orders` so we can provide\norder history functionality.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Event Handling](EventHandling.html)</span>\n<span class=\"pull-right\">[Recap &rsaquo;](Recap.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/WebServiceCommunication",
    "title": "Web Service Communication",
    "type": "page",
    "parent": "guides/pmo",
    "order": 12,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/todomvc": {
    "src": {
      "path": "docs/can-guides/experiment/todomvc/todomvc.md"
    },
    "body": "\n## Setup\n\nThe easiest way to get started is to clone the following JSBin by clicking the __JS Bin__ button on the top left:\n\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/sasuje/10/embed?html,output\">JS Bin on jsbin.com</a>\n\nThe JSBin starts\nwith the static HTML and CSS a designer might turn over to a JS developer. We will be\nadding all the JavaScript functionality.\n\nThe JSBin also loads [can.all.js](https://github.com/canjs/canjs/blob/v3.0.0-pre.11/dist/global/can.all.js), which is a script that includes CanJS all of CanJS core, ecosystem, legacy and infrastructure libraries under a\nsingle global `can` namespace.\n\nGenerally speaking, you should not use the global can script and instead\nshould import things directly with a module loader like [StealJS](http://stealjs.com),\nWebPack or Browserify.  In a real app your code will look like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({ ... });\nTodo.List = DefineList.extend({ ... });\n```\n\nNot:\n\n```js\nvar Todo = can.DefineMap.extend({ ... });\nTodo.List = can.DefineList.extend({ ... });\n```\n\nRead [guides/setup] on how to setup CanJS in a real app.\n\n## Create and render the template\n\nIn this section, we will render the markup in a [can-stache] live bound template.  \n\nUpdate the `HTML` tab to have a `<script>` tag around the html content.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 Start\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n\t\t\t<li class=\"todo\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Do the dishes</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Do the dishes\">\n\t\t\t</li>\n\t\t\t<li class=\"todo completed\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Mow the lawn</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Mow the lawn\">\n\t\t\t</li>\n\t\t\t<li class=\"todo editing\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Pick up dry cleaning</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Pick up dry cleaning\">\n\t\t\t</li>\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>2</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed (1)\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='11,67,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Use [can-stache.from can-stache.from] to load the contents of the `<script>` tag as\n a [template renderer function](can-stache.renderer).\n - Render the template with an empty object into a [document fragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment).\n - Insert the fragment into the document's `<body>` element.\n\n To load and render this template, and add the result to the\nbody, add the following to the `JavaScript` tab:\n\n\n```js\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-3,only'></span>\n\nWhen complete, you should see the same content as before.  Only now, it's\nrendered with a live-bound stache template.  The live binding means that\nwhen the template's data is changed, it will update automatically. We'll see\nthat in the next step.\n\n\n## Define the todos type and show the active and complete count.\n\nIn this section, we will:\n\n - List todos from a list of todos.\n - Show the number of active (`complete === true`) and and complete todos.\n - Connect a todo's `complete` property to a checkbox so that when\n   we toggle the checkbox the number of active and complete todos changes.\n\n\nUpdate the `JavaScript` tab to:\n\n - Define a `Todo` type with [can-define/map/map].\n - Define a `Todo.List` type along with an `active` and `complete` property with [can-define/list/list].\n - Create a list of todos and pass those to the template.\n\n\n```js\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\nvar todos = new Todo.List([\n  { id: 5, name: \"mow lawn\", complete: false },\n  { id: 6, name: \"dishes\", complete: true },\n  { id: 7, name: \"learn canjs\", complete: false }\n]);\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todos: todos});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-21,24,only'></span>\nUpdate the `HTML` tab to:\n\n- Use [can-stache.helpers.each] to loop through every todo.\n- Add `completed` to the `<li>`'s `className` if the `<li>`'s todo is  complete.\n- Use [can-stache-bindings.twoWay] to two-way bind the checkbox's `checked` property to its todo's `complete` property.  \n- Use [can-stache.tags.escaped] to insert the value todo's `name` as the content of the `<label>` and\n  `value` of the text `<input/>`.\n- Insert the active and complete number of todos.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create and render the template\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todos}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todos.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todos.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='21-30,35,49,only'></span>\nWhen complete, you should be able to toggle the checkboxes and see the number of\nitems left and the completed count change automatically.  This is because\n[can-stache] is able to listen for changes in observables like [can-define/map/map],\n[can-define/list/list] and [can-compute].\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/2-items-left/completed.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/2-items-left/completed.webm\" type=\"video/webm\">\n</video>\n\n\n## Get todos from the server\n\nIn this section, we will:\n\n - Load todos from a restful service.\n - Fake that restful service.\n\n\nUpdate the `JavaScript` tab to:\n\n- Define what the restful service layer's parameters are with [can-set].\n- Create a fake data store that is initialized with data for 3 todos with [can-fixture.store].\n- Trap AJAX requests to `\"/api/todos\"` and provide responses with the data from the fake data store with [can-fixture].\n- Connect the `Todo` and `Todo.List` types to the restful `\"/api/todos\"` endpoint using [can-connect/can/super-map/super-map].  This allows you to load, create, update, and destroy todos\non the server.\n- Use [can-connect/can/map/map.getList] to load a list of all todos on the server. The result\n  of `getList` is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves to a `Todo.List` with the todos returned from the fake data store.  That `Promise`\n  is passed to the template as `todosPromise`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-15,33-39,42,only'></span>\nUpdate the `HTML` tab to:\n\n - Use [can-stache.helpers.each] to loop through the promise's resolved value, which\n   is the list of todos returned by the server.\n - Read the active and completed number of todos from the promise's resolved value.\n\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create the todos type and get items left working\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='21,35,49,only'></span>\nWhen complete, you'll notice a 1 second delay before seeing the list of todos as\nthey load for the first time from the fixtured data store. On future page reloads, the\nlist of todos will load immediately.  This is because [can-connect/can/super-map/super-map] ads the [can-connect/fall-through-cache/fall-through-cache] behavior.  The\n[can-connect/fall-through-cache/fall-through-cache] behavior stores loaded data in\nlocalStorage.  Future requests will hit localStorage for data first, present that data\nto the user, before making a request to the server and updating the original data with\nany changes.  Use `localStorage.clear()` to see the difference.\n\n\n## Destroy todos\n\nIn this section, we will:\n\n - Delete a todo on the server when it's destroy button is clicked.  \n - Remove the todo from the page after it's deleted.\n\nUpdate the `HTML` tab to:\n\n - Add `destroying` to the `<li>`'s `className` if the `<li>`'s todo is being destroyed using [can-connect/can/map/map.prototype.isDestroying].\n - Call the `todo`'s [can-connect/can/map/map.prototype.destroy] method when the `<button>` is clicked using [can-stache-bindings.event].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Destroy todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\n                    {{#if isDestroying}}destroying{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\" ($click)=\"destroy()\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='22-23,27,only'></span>\nWhen complete, you should be able to delete a todo by clicking its delete button.  After\nclicking the todo, its name will turn red and italic.  Once deleted the todo will be\nautomatically removed from the page.  \n\nThe deleted todo is automatically removed from the page because [can-connect/can/super-map/super-map] ads the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically updates lists (like `Todo.List`) when instances\nare created, updated or destroyed.  If you've created the right [can-set.Algebra], you\nshouldn't have to manage lists yourself.\n\nFinally, if you refresh the page after deleting, you'll notice the page temporarily shows fewer items.\nThis is because the fall through cache's data is shown before the response from fixtured data store\nis used.\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/4-destroy/completed.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/4-destroy/completed.webm\" type=\"video/webm\">\n</video>\n\n## Create todos\n\nIn this section, we will:\n\n - Create a custom element that can create todos on the server.\n - Use that custom element.\n\nUpdate the `JavaScript` tab to:\n\n - Use [can-define/map/map] to create a `TodoCreateVM` view model with:\n   - A `todo` property that holds a new `Todo` instance.\n   - A `createTodo` method that [can-connect/can/map/map.prototype.save]s the `Todo` instance\n     and replaces it with a new one once saved.\n - Use [can-component] to create a custom `<todo-create>` component that renders the `todo-create-template` template with an instance of the `TodoCreateVM`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n    todo: {Value: Todo},\n    createTodo: function(){\n        this.todo.save().then(function(){\n            this.todo = new Todo();\n        }.bind(this));\n    }\n});\n\ncan.Component.extend({\n    tag: \"todo-create\",\n    view: can.stache.from(\"todo-create-template\"),\n    ViewModel: TodoCreateVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='42-55,only'></span>\nUpdate the `HTML` tab to:\n\n - Create the `todo-create-template` that:\n   - Updates the `todo`'s `name` with the `<input>`'s `value` using [can-stache-bindings.toParent].\n   - Calls `createTodo` when the `enter` key is pressed using [can-stache-bindings.event].\n - Use `<todo-create/>`\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\n                    {{#if isDestroying}}destroying{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\" ($click)=\"destroy()\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='11-16,18,22,only'></span>\nWhen complete, you will be able to create a todo by typing the name of the todo and pressing\n`enter`. Notice that the new todo automatically appears in the list of todos. This\nis also because [can-connect/can/super-map/super-map] ads the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically will inserted newly created items into\nlists that they belong within.\n\n\n## List todos\n\nIn this section, we will:\n\n - Define a custom element that lists todos passed to it.\n - Use that custom element.\n\nUpdate the `JavaScript` tab to:\n\n - Create a `TodoListVM` view model type which has a `todos` property of type `Todo.List`.\n - Use [can-component] to define a `<todo-list>` element.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List\n});\n\ncan.Component.extend({\n    tag: \"todo-list\",\n    view: can.stache.from(\"todo-list-template\"),\n    ViewModel: TodoListVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='56-64,only'></span>\nUpdate the `HTML` tab to:\n\n - Create the `todo-list-template` that loops through a list of `todos` (instead of `todosPromise.value`).\n - Create a `<todo-list>` element and set it's `todos` property to the resolved value of `todosPromise`\n   using [can-stache-bindings.toChild].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - List todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\">\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\">\n      <div class=\"view\">\n        <input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n        <label>{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='18-32,43,only'></span>\nWhen complete, everything should work the same. We didn't add any new functionality, we\njust moved code around to make it more isolated, potentially reusable, and more maintainable.\n\n\n## Edit todos\n\nIn this section, we will:\n\n - Make it possible to edit a todo's `name` and save that change to the server.\n\nUpdate the `JavaScript` tab to:\n\n - Update the `TodoListVM` to include the methods and properties needed to edit a todo's name, including:\n   - An `editing` property of type `Todo` that stores which todo is being edited.\n   - A `backupName` property that stores the todo's name before being edited.\n   - An `edit` method that sets up the editing state.\n   - A `cancelEdit` method that undos the editing state if in the editing state.\n   - A `updateName` method that updates the editing todo and [can-connect/can/map/map.prototype.save saves] it to the server.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='58-76,only'></span>\n\nUpdate the `HTML` tab to:\n\n - Use the `isEditing` method to add `editing` to the `className` of the `<li>` being edited.\n - When the checkbox changes, update the todo on the server with [can-connect/can/map/map.prototype.save],\n - Call `edit` with the current context using [can-stache/keys/this].\n - Setup the edit input to:\n   - Two way bind it's value to the current todo's `name` using [can-stache-bindings.twoWay].\n   - Call `updateName` when the enter key is pressed using [can-stache-bindings.event].\n   - Focus the input when `isEditing` is true using the special [can-util/dom/attr/attr.special.focused] attribute.\n   - Call `cancelEdit` if the input element loses focus.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - List todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   {($checked)}=\"complete\" ($change)=\"save()\">\n        <label ($dblclick)=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        {($value)}=\"name\"\n        ($enter)=\"updateName()\"\n        {$focused}=\"isEditing(this)\"\n        ($blur)=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='23,25-27,29-33,only'></span>\nWhen complete, you should be able to edit a todo's name.\n\n## Routing\n\nIn this section, we will:\n\n - Make it possible to use the forward and backwards button to change\n between showing all todos, only active todos, or only completed todos.\n - Add links to change between showing all todos, only active todos, or only completed todos.\n - Make those links bold when the site is currently showing that link.\n\n\nUpdate the `JavaScript` tab to:\n\n - Create a `AppVM` view model type that will manage the behavior of the `todomvc-template` and\n   will update when the url changes.\n   - Define a `filter` property that will be updated when the route changes.\n   - Define a `route` property that will be updated when the route changes.\n   - Define a `todosPromise` property that uses `filter` to determine what data should be\n   loaded from the server.  \n     - If `filter` is falsey, all data will be loaded.  \n     - If `filter` is `\"complete\"`, only complete todos will be loaded.\n     - If `filter` is any other value, the active todos will be loaded.\n - Create an instance of the application view model (`appVM`).\n - Connect changes in the url to changes in the `appVM` with [can-route.data].\n - Create a pretty routing rule so if the url looks like `\"#!active\"`, the `filter` property of\n   `appVM` will be set to `filter` with [can-route].\n - Initialize the url's values on `appVM` and setup the two way connection with [can-route.ready].\n - Render the `todomvc-template` with the `appVM`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false})\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar AppVM = can.DefineMap.extend({\n  filter: \"string\",\n  route: \"string\",\n  get todosPromise(){\n    if(!this.filter) {\n      return Todo.getList({});\n    } else {\n      return Todo.getList({complete: this.filter === \"complete\"});\n    }\n  }\n});\n\nvar appVM = new AppVM();\ncan.route.data = appVM;\ncan.route(\"{filter}\");\ncan.route.ready();\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='85-100,103,only'></span>\nUpdate the `HTML` tab to:\n\n - Set `href` to a url that will set the desired properties on `appVM` when clicked.\n - Add `class='selected'` to the link if the current route matches the current properties of the `appVM` using [can-stache.helpers.routeCurrent].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   {($checked)}=\"complete\" ($change)=\"save()\">\n        <label ($dblclick)=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        {($value)}=\"name\"\n        ($enter)=\"updateName()\"\n        {$focused}=\"isEditing(this)\"\n        ($blur)=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter=undefined}}\"\n\t\t\t\t\t{{#routeCurrent filter=undefined}}class='selected'{{/routeCurrent}}>All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='active'}}\"\n\t\t\t\t\t{{#routeCurrent filter='active'}}class='selected'{{/routeCurrent}}>Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='complete'}}\"\n\t\t\t\t\t{{#routeCurrent filter='complete'}}class='selected'{{/routeCurrent}}>Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='57-58,61-62,65-66,only'></span>\nWhen complete, you should be able to click the `All`, `Active`, and `Completed` links and\nsee the right data.  When you click from `All` to `Active` or from `All` to `Completed`,\nyou'll notice that the list of todos is updated immediately, despite a request being made.\nThis is because the [can-connect/fall-through-cache/fall-through-cache] is able to make use\nof the data loaded for the `All` todos page.  It's able to filter out the `Active` and\n`Completed` data.\n\n## Toggle all and clear completed\n\nIn this section, we will:\n\n- Make the `toggle-all` button change all todos to complete or incomplete.\n- Make the `clear-completed` button delete all complete todos.\n\nUpdate the `JavaScript` tab to:\n\n- Add the following properties and methods to `Todo.List`:\n  - A `allComplete` property that returns `true` if every todo is complete.\n  - A `saving` property that returns todos that are being saved using [can-connect/can/map/map.prototype.isSaving].\n  - A `updateCompleteTo` method that updates every todo's `complete` property to the specified value and updates the compute on the server with [can-connect/can/map/map.prototype.save].\n  - A `destroyComplete` method that deletes every complete todo with [can-connect/can/map/map.prototype.destroy].\n- Adds the following properties to `AppVM`:\n  - A `todosList` property that gets its value from the `todosPromise` using an [can-define.types.get asynchronous getter].\n  - A `allChecked` property that returns `true` if every todo is complete.  The property can also be set to `true` or `false` and it will set every todo to that value.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  },\n  get allComplete(){\n    return this.length === this.complete.length;\n  },\n  get saving(){\n    return this.filter(function(todo){\n      return todo.isSaving();\n    });\n  },\n  updateCompleteTo: function(value){\n    this.forEach(function(todo){\n      todo.complete = value;\n      todo.save();\n    });\n  },\n  destroyComplete: function(){\n    this.complete.forEach(function(todo){\n      todo.destroy();\n    });\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar AppVM = can.DefineMap.extend({\n  filter: \"string\",\n  route: \"string\",\n  get todosPromise(){\n    if(!this.filter) {\n      return Todo.getList({});\n    } else {\n      return Todo.getList({complete: this.filter === \"complete\"});\n    }\n  },\n  todosList: {\n    get: function(lastSetValue, resolve){\n      this.todosPromise.then(resolve);\n    }\n  },\n  get allChecked(){\n    return this.todosList && this.todosList.allComplete;\n  },\n  set allChecked(newVal){\n    this.todosList && this.todosList.updateCompleteTo(newVal);\n  }\n});\n\nvar appVM = new AppVM();\ncan.route.data = appVM;\ncan.route(\"{filter}\");\ncan.route.ready();\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='31-49,114-124,only'></span>\nUpdate the `HTML` tab to:\n\n- Cross bind the `toggle-all`'s `checked` property to the `appVM`'s `allChecked` property.\n- Disable the `toggle-all` button while any todo is saving.\n- Call the `Todo.List`'s `destroyComplete` method when the `clear-completed` button is clicked on.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if ./complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   {($checked)}=\"complete\" ($change)=\"save()\">\n        <label ($dblclick)=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        {($value)}=\"name\"\n        ($enter)=\"updateName()\"\n        {$focused}=\"isEditing(this)\"\n        ($blur)=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\"\n          {($checked)}=\"allChecked\"\n          {$disabled}=\"todosList.saving.length\"/>\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter=undefined}}\"\n\t\t\t\t\t{{#routeCurrent filter=undefined}}class='selected'{{/routeCurrent}}>All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='active'}}\"\n\t\t\t\t\t{{#routeCurrent filter='active'}}class='selected'{{/routeCurrent}}>Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='complete'}}\"\n\t\t\t\t\t{{#routeCurrent filter='complete'}}class='selected'{{/routeCurrent}}>Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\"\n            ($click)=\"todosList.destroyComplete()\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.11/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='47-49,71-72,only'></span>\nWhen complete, you should be able to toggle all todos `complete` state and\ndelete the completed todos.  You should also have a really good idea how CanJS works!\n\n<script src=\"http://static.jsbin.com/js/embed.min.js?3.39.15\"></script>\n\n",
    "description": "This guide walks through building a slightly modified version of [TodoMVC](http://todomvc.com/) with CanJS's [can-core Core libraries] and [can-fixture]. It takes about 1 hour to complete.\n\n",
    "name": "guides/todomvc",
    "title": "TodoMVC Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 2,
    "comment": " "
  },
  "can-connect/data/callbacks/callbacks": {
    "name": "can-connect/data/callbacks/callbacks",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 10,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "\n",
    "description": "\nCalls callback methods as a result of raw [can-connect/DataInterface] requests.\n",
    "title": "",
    "signatures": [
      {
        "code": "dataCallbacks( baseConnection )",
        "description": "\n\n\n",
        "params": []
      }
    ]
  },
  "can-connect/data/callbacks/callbacks.gotListData": {
    "name": "can-connect/data/callbacks/callbacks.gotListData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 15,
      "codeLine": 23,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.getListData]. The result of this function will be used\nas the new response data.\n",
    "title": "gotListData"
  },
  "can-connect/data/callbacks/callbacks.createdData": {
    "name": "can-connect/data/callbacks/callbacks.createdData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 25,
      "codeLine": 41,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "",
    "description": "\n",
    "title": "createdData",
    "signatures": [
      {
        "code": "connection.createdData(props, params, cid)",
        "description": "\n\n  Called with the resolved response data\n  of [can-connect/connection.createData]. The result of this function will be used\n  as the new response data.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The raw data returned by the response."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "The parameters used to make this request."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "The cid of the instance created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The raw data this request represents.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "The cid of the instance created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The raw data this request represents.\n "
    }
  },
  "can-connect/data/callbacks/callbacks.updatedData": {
    "name": "can-connect/data/callbacks/callbacks.updatedData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 42,
      "codeLine": 50,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.updateData]. The result of this function will be used\nas the new response data.\n",
    "title": "updatedData"
  },
  "can-connect/data/callbacks/callbacks.destroyedData": {
    "name": "can-connect/data/callbacks/callbacks.destroyedData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 51,
      "codeLine": 59,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.destroyData]. The result of this function will be used\nas the new response data.\n",
    "title": "destroyedData"
  },
  "can-connect/data/inline-cache/inline-cache.data-methods": {
    "name": "can-connect/data/inline-cache/inline-cache.data-methods",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/inline-cache/inline-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/inline-cache/inline-cache.globals": {
    "name": "can-connect/data/inline-cache/inline-cache.globals",
    "title": "Globals",
    "type": "group",
    "parent": "can-connect/data/inline-cache/inline-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/inline-cache/inline-cache": {
    "type": "module",
    "name": "can-connect/data/inline-cache/inline-cache",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 3,
      "codeLine": 56,
      "path": "node_modules/can-connect/data/inline-cache/inline-cache.js"
    },
    "body": "\n## Use\n\nCreate a connection with `data-inline-cache` and a [connection.name].\n\n```\nvar todosConnection = connect([\"data-inline-cache\",\"data-url\"],{\n  url: \"/api/todos\",\n  name: \"todos\"\n})\n```\n\nMake the page respond with an `INLINE_CACHE` that contains the name of the\nconnection and a mapping of ids or sets to the response data:\n\n```\n<script>\nINLINE_CACHE = {\n  \"todos\": {\n    1: {id: 1, name: \"dishes\"},\n    \"{\\\"completed\\\": true}\": {data: [{...},{...}]}\n  }\n}\n</script>\n```\n\nNow, the first time the following requests are made, the cached data will be used:\n\n```\ntodosConnection.get({id: 1})\ntodosConnection.getList({completed: true})\n```\n\n\n\n",
    "description": "\n",
    "title": "",
    "hide": true,
    "deprecated": [
      {
        "version": "0.6.0",
        "description": "[can-zone] can now do this without this plugin.\n\nUse data embedded in the page response instead of making a request.\n"
      }
    ],
    "signatures": [
      {
        "code": "dataInlineCache( baseBehavior )",
        "description": "\n\n  Makes requests look for their data in a\n  [can-connect/data/inline-cache/inline-cache.INLINE_CACHE] object.  If it is found,\n  that entry in the cache is deleted so future requests will pass through.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/inline-cache/inline-cache.INLINE_CACHE": {
    "name": "can-connect/data/inline-cache/inline-cache.INLINE_CACHE",
    "type": "property",
    "parent": "can-connect/data/inline-cache/inline-cache.globals",
    "src": {
      "line": 58,
      "codeLine": 73,
      "path": "node_modules/can-connect/data/inline-cache/inline-cache.js"
    },
    "body": "\n",
    "description": "\nContains response data for requests that should not be made.\n",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n  A mapping of a [connection.name] to an Object that contains the\n  cached data for that connection.  That inner object is a mapping\n  between either [can-connect/base/base.id ids] or [can-connect/base/base.listSet serialized sets] to\n  response data for those requests.\n\n\n ",
        "template": [
          {
            "types": [
              {
                "type": "connection.name"
              }
            ]
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "id"
                      },
                      {
                        "type": "Set"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can-connect.listData"
                      },
                      {
                        "type": "props"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "title": "INLINE_CACHE"
  },
  "can-connect/data/inline-cache/inline-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/inline-cache/inline-cache.getListData",
    "parent": "can-connect/data/inline-cache/inline-cache.data-methods",
    "src": {
      "line": 91,
      "codeLine": 109,
      "path": "node_modules/can-connect/data/inline-cache/inline-cache.js"
    },
    "body": "\n",
    "description": "\nUses data in [can-connect/data/inline-cache/inline-cache.INLINE_CACHE] if available.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData( set )",
        "description": "\n\n  Looks if there is a key in [can-connect/data/inline-cache/inline-cache.INLINE_CACHE]\n  that matches `set`.  If there is, it uses that key's value for the\n  response data and deletes that key so it can not be reused.\n\n  If there is no matching `key`, the base `getListData` is used.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/data/inline-cache/inline-cache.getData": {
    "type": "function",
    "name": "can-connect/data/inline-cache/inline-cache.getData",
    "parent": "can-connect/data/inline-cache/inline-cache.data-methods",
    "src": {
      "line": 122,
      "codeLine": 140,
      "path": "node_modules/can-connect/data/inline-cache/inline-cache.js"
    },
    "body": "\n",
    "description": "\nUses data in [can-connect/data/inline-cache/inline-cache.INLINE_CACHE] if available.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getListData( set )",
        "description": "\n\n  Looks if there is a key in [can-connect/data/inline-cache/inline-cache.INLINE_CACHE]\n  that matches the [can-connect/base/base.id] of `params`.  If there is, it uses that key's value for the\n  response data and deletes that key so it can not be reused.\n\n  If there is no matching `key`, the base `getData` is used.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "props"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "props"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.data-methods": {
    "name": "can-connect/data/memory-cache/memory-cache.data-methods",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/memory-cache/memory-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/memory-cache/memory-cache": {
    "name": "can-connect/data/memory-cache/memory-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 43,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n\n## Use\n\n`data/memory-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n[can-connect/cache-requests/cache-requests].\n\n```js\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/fall-through-cache/fall-through-cache\")\n],\n{\n  url: \"/services/todos\",\n  cacheConnection: cacheConnection\n});\n```\n\n",
    "description": "\nSaves raw data in JavaScript memory that disappears when the page refreshes.\n",
    "title": "",
    "signatures": [
      {
        "code": "memoryCache( baseConnection )",
        "description": "\n\n  Creates a cache of instances and a cache of sets of instances that is\n  accessible to read via [can-connect/data/memory-cache/memory-cache.getSets],\n  [can-connect/data/memory-cache/memory-cache.getData], and [can-connect/data/memory-cache/memory-cache.getListData].\n  The caches are updated via [can-connect/data/memory-cache/memory-cache.createData],\n  [can-connect/data/memory-cache/memory-cache.updateData], [can-connect/data/memory-cache/memory-cache.destroyData],\n  and [can-connect/data/memory-cache/memory-cache.updateListData].\n\n  [can-connect/data/memory-cache/memory-cache.createData],\n  [can-connect/data/memory-cache/memory-cache.updateData],\n  [can-connect/data/memory-cache/memory-cache.destroyData] are able to move items in and out\n  of sets.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/memory-cache/memory-cache.getSets": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getSets",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 161,
      "codeLine": 182,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n\n## Use\n\n```\nconnection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n```\n\n\t \n",
    "description": "\nReturns the sets contained within the cache.\n",
    "title": "getSets",
    "signatures": [
      {
        "code": "connection.getSets()",
        "description": "\n\n  Returns the sets added by [can-connect/data/memory-cache/memory-cache.updateListData].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "can-set/Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the list of sets.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can-set/Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the list of sets.\n"
    },
    "comment": " "
  },
  "can-connect/data/memory-cache/memory-cache.clear": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.clear",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 187,
      "codeLine": 214,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nResets the memory cache so it contains nothing.\n",
    "title": "clear",
    "signatures": [
      {
        "code": "connection.clear()",
        "description": "\n\n  Removes all instances and lists being stored in memory.\n\n  ```\n  var cacheConnection = connect([\n    require(\"can-connect/data/memory-cache/memory-cache\")\n  ],{});\n\n  cacheConnection.updateInstance({id: 5, name: \"justin\"});\n\n  cacheConnection.getData({id: 5}).then(function(data){\n    data //-> {id: 5, name: \"justin\"}\n    cacheConnection.clear();\n    cacheConnection.getData({id: 5}).catch(function(err){\n      err -> {message: \"no data\", error: 404}\n    });\n  });\n  ```\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getListData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 218,
      "codeLine": 235,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nGets a set of data from the memory cache.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Goes through each set add by [can-connect/data/memory-cache/memory-cache.updateListData]. If\n  `set` is a subset, uses [can-connect/base/base.algebra] to get the data for the requested `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "An object that represents the data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "An object that represents the data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
    }
  },
  "can-connect/data/memory-cache.getListDataSync": {
    "type": "function",
    "name": "can-connect/data/memory-cache.getListDataSync",
    "parent": "can-connect/data/memory-cache.data-methods",
    "src": {
      "line": 244,
      "codeLine": 252,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nSynchronously gets a set of data from the memory cache.\n",
    "title": "getListDataSync",
    "signatures": [
      {
        "code": "connection.getListDataSync(set)",
        "description": "\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.updateListData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.updateListData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 268,
      "codeLine": 283,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nSaves a set of data in the cache.\n",
    "title": "updateListData",
    "signatures": [
      {
        "code": "connection.updateListData(listData, set)",
        "description": "\n\n  Tries to merge this set of data with any other saved sets of data. If\n  unable to merge this data, saves the set by itself.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The data that belongs to `set`."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set `listData` belongs to."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Promise resolves if and when the data has been successfully saved.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set `listData` belongs to."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Promise resolves if and when the data has been successfully saved.\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.getData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 307,
      "codeLine": 323,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nGet an instance's data from the memory cache.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Looks in the instance store for the requested instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A promise that resolves to the item if the memory cache has this item.\nIf the memory cache does not have this item, it rejects the promise.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A promise that resolves to the item if the memory cache has this item.\nIf the memory cache does not have this item, it rejects the promise.\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.createData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.createData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 335,
      "codeLine": 346,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is created and should be added to cache.\n",
    "title": "createData",
    "signatures": [
      {
        "code": "connection.createData(props)",
        "description": "\n\n  Adds `props` to the stored list of instances. Then, goes\n  through every set and adds props the sets it belongs to.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.updateData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.updateData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 359,
      "codeLine": 370,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is updated.\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "connection.updateData(props)",
        "description": "\n\n  Overwrites the stored instance with the new props. Then, goes\n  through every set and adds or removes the instance if it belongs or not.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.destroyData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.destroyData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 404,
      "codeLine": 415,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance should be removed from the cache.\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "connection.destroyData(props)",
        "description": "\n\n  Goes through each set of data and removes any data that matches\n  `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/combine-requests.data-methods": {
    "name": "can-connect/data/combine-requests.data-methods",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.options": {
    "name": "can-connect/data/combine-requests.options",
    "title": "Options",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.algebra": {
    "name": "can-connect/data/combine-requests.algebra",
    "title": "Algebra Methods",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.types": {
    "name": "can-connect/data/combine-requests.types",
    "title": "Types",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests/combine-requests": {
    "type": "module",
    "name": "can-connect/data/combine-requests/combine-requests",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 8,
      "codeLine": 76,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n\n## Use\n\nCreate a connection with the `combine-requests` plugin like:\n\n```\nvar todosConnection = connect([\n  require(\"can-connect/data/combine-requests/combine-requests\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\"\n});\n```\n\nBy default, the following will only make a single request if made at the same time:\n\n```\ntodosConnection.getListData({})\ntodosConnection.getListData({userId: 5});\ntodosConnection.getListData({userId: 5, type: \"critical\"});\n```\n\nThis is because [can-set](https://github.com/canjs/can-set) knows that\n`{userId: 5, type: \"critical\"}` and `{userId: 5}` are subsets of `{}`.\n\nFor more advanced combining, use set algebra.  The following supports\ncombining ranges:\n\n```\nvar todosConnection = connect([\n  require(\"can-connect/data/combine-requests/combine-requests\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\",\n  algebra: new Algebra(set.props.range(\"start\",\"end\"))\n});\n```\n\nNow the following will make single request:\n\n```\ntodosConnection.getListData({start: 0, end: 49})\ntodosConnection.getListData({start: 0, end: 5});\ntodosConnection.getListData({start: 50, end: 99});\n```\n\n\n",
    "description": "\nCombines multiple incoming requests into one if possible.\n",
    "title": "",
    "signatures": [
      {
        "code": "dataCombineRequests(baseConnection)",
        "description": "\n\n  Overwrites [can-connect/data/combine-requests.getListData] to collect the requested\n  sets for\n  some [can-connect/data/combine-requests.time].  Once that time has expired, it tries\n  to take the [can-connect/data/combine-requests.unionPendingRequests union] of those sets. It\n  makes requests with those unioned sets. Once the unioned set data has returned,\n  the original requests re satisified by getting\n  [can-connect/data/combine-requests.getSubset subsets] of the unioned set data.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/combine-requests.unionPendingRequests": {
    "type": "function",
    "name": "can-connect/data/combine-requests.unionPendingRequests",
    "parent": "can-connect/data/combine-requests.algebra",
    "src": {
      "line": 80,
      "codeLine": 128,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n## Use\n\nThis function gets called automatically.  However, it converts something like:\n\n```\n[\n  {set: {completed: false}, deferred: def1},\n  {set: {completed: true}, deferred: def2}\n]\n```\n\nto\n\n```\n[\n  {\n   set: {},\n   pendingRequests: [\n     {set: {completed: false}, deferred: def1},\n     {set: {completed: true}, deferred: def2}\n   ]\n  }\n]\n```\n\n\t \n",
    "description": "\n",
    "title": "unionPendingRequests",
    "signatures": [
      {
        "code": "connection.unionPendingRequests( pendingRequests )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-connect/data/combine-requests.PendingRequest"
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "\n\nAn array of objects, each containing:\n\n- `set` - the requested set\n- `deferred` - a deferred that will be resolved with this sets data\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": [
                        {
                          "name": "set",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        },
                        {
                          "name": "pendingRequests",
                          "types": [
                            {
                              "type": "can-connect/data/combine-requests.PendingRequest"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\nReturns an array of each of the unioned requests to be made.  Each unionized request should have:\n\n- `set` - the set to request\n- `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the set satisfies.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/data/combine-requests.PendingRequest"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\nAn array of objects, each containing:\n\n- `set` - the requested set\n- `deferred` - a deferred that will be resolved with this sets data\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": [
                    {
                      "name": "set",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    },
                    {
                      "name": "pendingRequests",
                      "types": [
                        {
                          "type": "can-connect/data/combine-requests.PendingRequest"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\nReturns an array of each of the unioned requests to be made.  Each unionized request should have:\n\n- `set` - the set to request\n- `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the set satisfies.\n"
    },
    "comment": " "
  },
  "can-connect/data/combine-requests.getSubset": {
    "type": "function",
    "name": "can-connect/data/combine-requests.getSubset",
    "parent": "can-connect/data/combine-requests.algebra",
    "src": {
      "line": 176,
      "codeLine": 191,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nReturn the items that belong to an initial request.\n",
    "title": "getSubset",
    "signatures": [
      {
        "code": "connection.getSubset( set, unionSet, data )",
        "description": "\n\n  This implementation uses [can-set.Algebra.prototype.getSubset] on the [can-connect/base/base.algebra].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "the subset initially requested"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "unionSet",
            "description": "the combined set that was actually requested"
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "data",
            "description": "the data from the combined set"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "the data that belongs to `set`\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "name": "data",
      "description": "the data from the combined set"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "the data that belongs to `set`\n\t "
    }
  },
  "can-connect/data/combine-requests.time": {
    "name": "can-connect/data/combine-requests.time",
    "type": "property",
    "parent": "can-connect/data/combine-requests.options",
    "src": {
      "line": 194,
      "codeLine": 214,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nSpecifies the amount of time to wait to combine requests.\n",
    "types": [
      {
        "type": "Number",
        "description": "Defaults to `1` which means that only requests made within the same\n\"thread of execution\" will be combined.  Increasing this number will mean\nthat requests are going to be delayed that length of time in case other requests\nare made.  Generally speaking, there's no good reason to increase the amount of time.\n\n```\nconnect([\n  require(\"can-connect/data/combine-requests/combine-requests\"),\n  ...\n],{\n  time: 100\n})\n```\n\t "
      }
    ],
    "title": "time"
  },
  "can-connect/data/combine-requests.getListData": {
    "type": "function",
    "name": "can-connect/data/combine-requests.getListData",
    "parent": "can-connect/data/combine-requests.data-methods",
    "src": {
      "line": 215,
      "codeLine": 233,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nTries to combine requests using set logic.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData( set )",
        "description": "\n\n  Collects the sets for calls to `getListData` for\n  some [can-connect/data/combine-requests.time].  Once that time has expired, it tries\n  to take the [union](https://github.com/canjs/can-set#setunion) of those sets. It\n  makes requests with those unioned sets. Once the unioned set data has returned,\n  the original requests rae satisified by taking\n  [can-set.Algebra.prototype.getSubset] of the unioned set data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set used to request data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "The data for the requested set of data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set used to request data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "The data for the requested set of data.\n\t "
    }
  },
  "can-connect/data/combine-requests.PendingRequest": {
    "src": {
      "line": 288,
      "codeLine": 295,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "type": "typedef",
    "body": "",
    "description": "\n",
    "title": "PendingRequest",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "set",
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "description": "A [can-set](https://github.com/canjs/can-set) set object."
          },
          {
            "name": "deferred",
            "types": [
              {
                "type": "Deferred"
              }
            ],
            "description": "A defferred that can be used to resolve or reject a promise.\n"
          }
        ]
      }
    ],
    "name": "can-connect/data/combine-requests.PendingRequest",
    "parent": "can-connect/data/combine-requests.types"
  },
  "can-connect/data/callbacks-cache/callbacks-cache": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 13,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": "\n",
    "description": "\nCallback [can-connect/base/base.cacheConnection] methods when [can-connect/data/callbacks/callbacks data interface callbacks]\nare called.\n",
    "title": "",
    "signatures": [
      {
        "code": "dataCallbacksCache( baseConnection )",
        "description": "\n\n  Implements the [can-connect/data/callbacks/callbacks data callbacks] so that a corresponding method is called\n  on the [can-connect/base/base.cacheConnection].This is\n  useful for making sure a [can-connect/base/base.cacheConnection] is updated whenever data is updated.\n",
        "params": []
      }
    ]
  },
  "can-connect/data/callbacks-cache/callbacks-cache.createdData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.createdData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 19,
      "codeLine": 26,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.createData]. Calls `createData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "createdData"
  },
  "can-connect/data/callbacks-cache/callbacks-cache.updatedData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.updatedData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 27,
      "codeLine": 34,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.updateData]. Calls `updateData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "updatedData"
  },
  "can-connect/data/callbacks-cache/callbacks-cache.destroyedData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.destroyedData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 35,
      "codeLine": 42,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.destroyData]. Calls `destroyData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "destroyedData"
  },
  "can-connect/data/localstorage-cache/localstorage-cache.identifiers": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache.identifiers",
    "title": "Indentifiers",
    "type": "group",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/localstorage-cache/localstorage-cache.data-methods": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache",
    "description": "",
    "order": 1
  },
  "can-connect/data/localstorage-cache/localstorage-cache": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 47,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n\n## Use\n\n`data/localstorage-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n[can-connect/cache-requests/cache-requests].  Make sure you configure the connection's [can-connect/data/localstorage-cache/localstorage-cache.name].\n\n```\nvar cacheConnection = connect([\n  require(\"can-connect/data/localstorage-cache/localstorage-cache\")\n],{\n  name: \"todos\"\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/fall-through-cache/fall-through-cache\")\n],\n{\n  url: \"/services/todos\",\n  cacheConnection: cacheConnection\n});\n```\n\n\n",
    "description": "\nSaves raw data in localStorage.\n",
    "title": "",
    "signatures": [
      {
        "code": "localStorage( baseConnection )",
        "description": "\n\n  Creates a cache of instances and a cache of sets of instances that is\n  accessible to read via [can-connect/data/localstorage-cache/localstorage-cache.getSets],\n  [can-connect/data/localstorage-cache/localstorage-cache.getData], and [can-connect/data/localstorage-cache/localstorage-cache.getListData].\n  The caches are updated via [can-connect/data/localstorage-cache/localstorage-cache.createData],\n  [can-connect/data/localstorage-cache/localstorage-cache.updateData], [can-connect/data/localstorage-cache/localstorage-cache.destroyData],\n  and [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n\n  [can-connect/data/localstorage-cache/localstorage-cache.createData],\n  [can-connect/data/localstorage-cache/localstorage-cache.updateData],\n  [can-connect/data/localstorage-cache/localstorage-cache.destroyData] are able to move items in and out\n  of sets.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.name": {
    "src": {
      "line": 212,
      "codeLine": 234,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```\nvar cacheConnection = connect([\"data-localstorage-cache\"],{\n  name: \"todos\"\n});\n```\n\t \n",
    "description": "\nSpecify a name to use when saving data in localstorage.\n",
    "types": [
      {
        "type": "String",
        "description": "This name is used to find and save data in\nlocalstorage. Instances are saved in `{name}/instance/{id}`\nand sets are saved in `{name}/set/{set}`.\n"
      }
    ],
    "title": "name",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.name",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.identifiers",
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.clear": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.clear",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 236,
      "codeLine": 245,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nResets the memory cache so it contains nothing.\n",
    "title": "clear",
    "signatures": [
      {
        "code": "connection.clear()",
        "description": "\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getSets": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getSets",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 270,
      "codeLine": 291,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n\n## Use\n\n```\nconnection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n```\n\n\t \n",
    "description": "\nReturns the sets contained within the cache.\n",
    "title": "getSets",
    "signatures": [
      {
        "code": "connection.getSets(set)",
        "description": "\n\n  Returns the sets added by [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the list of sets.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the list of sets.\n"
    },
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getListData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 294,
      "codeLine": 311,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nGets a set of data from localstorage.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Goes through each set add by [can-connect/data/memory-cache.updateListData]. If\n  `set` is a subset, uses [can-connect/base/base.algebra] to get the data for the requested `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "An object that represents the data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "An object that represents the data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
    }
  },
  "can-connect/data/localstorage-cache.getListDataSync": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache.getListDataSync",
    "parent": "can-connect/data/localstorage-cache.data-methods",
    "src": {
      "line": 319,
      "codeLine": 327,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nSynchronously gets a set of data from localstorage.\n",
    "title": "getListDataSync",
    "signatures": [
      {
        "code": "connection.getListDataSync(set)",
        "description": "\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 349,
      "codeLine": 365,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nGet an instance's data from localstorage.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Looks in localstorage for the requested instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A promise that resolves to the item if the memory cache has this item.\nIf localstorage does not have this item, it rejects the promise.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A promise that resolves to the item if the memory cache has this item.\nIf localstorage does not have this item, it rejects the promise.\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.updateListData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.updateListData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 375,
      "codeLine": 390,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nSaves a set of data in the cache.\n",
    "title": "updateListData",
    "signatures": [
      {
        "code": "connection.updateListData(listData, set)",
        "description": "\n\n  Tries to merge this set of data with any other saved sets of data. If\n  unable to merge this data, saves the set by itself.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Promise resolves if and when the data has been successfully saved.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Promise resolves if and when the data has been successfully saved.\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.createData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.createData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 412,
      "codeLine": 423,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is created and should be added to cache.\n",
    "title": "createData",
    "signatures": [
      {
        "code": "connection.createData(props)",
        "description": "\n\n  Adds `props` to the stored list of instances. Then, goes\n  through every set and adds props the sets it belongs to.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.updateData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.updateData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 435,
      "codeLine": 446,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is updated.\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "connection.updateData(props)",
        "description": "\n\n  Overwrites the stored instance with the new props. Then, goes\n  through every set and adds or removes the instance if it belongs or not.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.destroyData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.destroyData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 478,
      "codeLine": 489,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance should be removed from the cache.\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "connection.destroyData(props)",
        "description": "\n\n  Goes through each set of data and removes any data that matches\n  `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/url/url.data-methods": {
    "name": "can-connect/data/url/url.data-methods",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/url/url",
    "description": "",
    "order": 0
  },
  "can-connect/data/url/url.option": {
    "name": "can-connect/data/url/url.option",
    "title": "Options",
    "type": "group",
    "parent": "can-connect/data/url/url",
    "description": "",
    "order": 0
  },
  "can-connect/data/url/url": {
    "name": "can-connect/data/url/url",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 96,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "\n## Use\n\nThe `data/url` behavior implements many of the [can-connect/DataInterface]\nmethods to send instance data to a URL.\n\nFor example, the following `todoConnection`:\n\n```js\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: {\n    getListData: \"GET /todos\",\n    getData: \"GET /todos/{id}\",\n    createData: \"POST /todos\",\n    updateData: \"PUT /todos/{id}\",\n    destroyData: \"DELETE /todos/{id}\"\n  }\n});\n```\n\nWill make the following request when the following\nmethods are called:\n\n```\n// GET /todos?due=today\ntodoConnection.getListData({due: \"today\"});\n\n// GET /todos/5\ntodosConnection.getData({id: 5})\n\n// POST /todos \\\n// name=take out trash\ntodosConnection.createData({\n  name: \"take out trash\"\n});\n\n// PUT /todos/5 \\\n// name=do the dishes\ntodosConnection.updateData({\n  name: \"do the dishes\",\n  id: 5\n});\n\n// DELETE /todos/5\ntodosConnection.destroyData({\n  id: 5\n});\n```\n\nThere's a few things to notice:\n\n1. URL values can include simple templates like `{id}`\n   that replace that part of the URL with values in the data\n   passed to the method.\n2. GET and DELETE request data is put in the URL using [can-util/js/param/param].\n3. POST and PUT requests put data that is not templated in the URL in POST or PUT body\n   as JSON-encoded data.  To use form-encoded requests instead, add the property\n   `contentType:'application/x-www-form-urlencoded'` to your [can-connect/data/url/url.url].\n4. If a provided URL doesn't include the method, the following default methods are provided:\n   - `getListData` - `GET`\n   - `getData` - `GET`\n   - `createData` - `POST`\n   - `updateData` - `PUT`\n   - `destroyData` - `DELETE`\n\nIf [can-connect/data/url/url.url] is provided as a string like:\n\n```js\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\"\n});\n```\n\nThis does the same thing as the first `todoConnection` example.\n\n",
    "description": "\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior",
        "description": "\n\nUses the [can-connect/data/url/url.url] option to implement the behavior of\n[can-connect/connection.getListData],\n[can-connect/connection.getData],\n[can-connect/connection.createData],\n[can-connect/connection.updateData], and\n[can-connect/connection.destroyData] to make an AJAX request\nto urls.\n"
      }
    ],
    "comment": " "
  },
  "can-connect/data/url/url.url": {
    "body": "\n",
    "description": "\nSpecify the url and methods that should be used for the \"Data Methods\".\n",
    "types": [
      {
        "type": "String",
        "description": "If a string is provided, it's assumed to be a RESTful interface. For example,\nif the following is provided:\n\n```\nurl: \"/services/todos\"\n```\n\n... the following methods and requests are used:\n\n - `getListData` - `GET /services/todos`\n - `getData` - `GET /services/todos/{id}`\n - `createData` - `POST /services/todos`\n - `updateData` - `PUT /services/todos/{id}`\n - `destroyData` - `DELETE /services/todos/{id}`\n"
      },
      {
        "type": "Object",
        "options": [],
        "description": "If an object is provided, it can customize each method and URL directly\nlike:\n\n```\nurl: {\n  getListData: \"GET /services/todos\",\n  getData: \"GET /services/todo/{id}\",\n  createData: \"POST /services/todo\",\n  updateData: \"PUT /services/todo/{id}\",\n  destroyData: \"DELETE /services/todo/{id}\"\n}\n```\n\nYou can provide a `resource` property that works like providing `url` as a string, but overwrite\nother values like:\n\n```\nurl: {\n  resource: \"/services/todo\",\n  getListData: \"GET /services/todos\"\n}\n```\n\nFinally, you can provide your own method to totally control how the request is made:\n\n```\nurl: {\n  resource: \"/services/todo\",\n  getListData: \"GET /services/todos\",\n  getData: function(param){\n    return new Promise(function(resolve, reject){\n      $.get(\"/services/todo\", {identifier: param.id}).then(resolve, reject);\n    });\n  }\n}\n```\n"
      }
    ],
    "title": "url",
    "name": "can-connect/data/url/url.url",
    "type": "property",
    "parent": "can-connect/data/url/url.option"
  },
  "can-connect/data/url/url.ajax": {
    "src": {
      "line": 204,
      "codeLine": 227,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "type": "property",
    "body": "\n",
    "description": "\nSpecify the ajax functionality that should be used to make the request.\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that resolves to the data.\n "
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "settings",
            "description": "Configuration options for the AJAX request."
          }
        ],
        "description": "Provides an alternate function to be used to make\najax requests.  By default [can-util/dom/ajax/ajax] provides the ajax\nfunctionality. jQuery's ajax method can be substituted as follows:\n\n```js\nconnect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/things\",\n  ajax: $.ajax\n});\n```\n"
      }
    ],
    "title": "ajax",
    "name": "can-connect/data/url/url.ajax",
    "parent": "can-connect/data/url/url.option",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "settings",
      "description": "Configuration options for the AJAX request."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that resolves to the data.\n "
    }
  },
  "can-connect/data/url/url.getListData": {
    "name": "can-connect/data/url/url.getListData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 232,
      "codeLine": 246,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "getListData(set)",
        "description": "\n\n  Retrieves list data for a particular set given the [can-connect/data/url/url.url] settings.\n  If `url.getListData` is a function, that function will be called.  If `url.getListData` is a\n  string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n  `url`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the ListData format.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the ListData format.\n "
    }
  },
  "can-connect/data/url/url.getData": {
    "name": "can-connect/data/url/url.getData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 247,
      "codeLine": 261,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "signatures": [
      {
        "code": "getData(params)",
        "description": "\n\n  Retrieves raw instance data given the [can-connect/data/url/url.url] settings.\n  If `url.getData` is a function, that function will be called.  If `url.getData` is a\n  string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "A object that represents the set of data needed to be loaded."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "A object that represents the set of data needed to be loaded."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance data.\n "
    }
  },
  "can-connect/data/url/url.createData": {
    "name": "can-connect/data/url/url.createData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 262,
      "codeLine": 278,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "signatures": [
      {
        "code": "createData(instanceData, cid)",
        "description": "\n\n  Creates instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.createData` is a function, that function will be called.  If `url.createData` is a\n  string, a request to that string will be made. If `url` is a string, a `POST` request is made to\n  `url`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "A unique id that represents the instance that is being created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the newly created instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "A unique id that represents the instance that is being created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the newly created instance data.\n "
    }
  },
  "can-connect/data/url/url.updateData": {
    "name": "can-connect/data/url/url.updateData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 279,
      "codeLine": 294,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "updateData(instanceData)",
        "description": "\n\nUpdates instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.updateData` is a function, that function will be called.  If `url.updateData` is a\n  string, a request to that string will be made. If `url` is a string, a `PUT` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the updated instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the updated instance data.\n "
    }
  },
  "can-connect/data/url/url.destroyData": {
    "name": "can-connect/data/url/url.destroyData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 295,
      "codeLine": 310,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "destroyData(instanceData)",
        "description": "\n\nDeletes instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.destroyData` is a function, that function will be called.  If `url.destroyData` is a\n  string, a request to that string will be made. If `url` is a string, a `DELETE` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the deleted instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the deleted instance data.\n "
    }
  },
  "can-connect/data/worker/worker.getListData": {
    "src": {
      "line": 64,
      "codeLine": 76,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getListData",
    "name": "can-connect/data/worker/worker.getListData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getListData(set)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getListData` is overwritten\nto forward calling [can-connect/connection.getListData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getListData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.updateListData": {
    "src": {
      "line": 77,
      "codeLine": 89,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "updateListData",
    "name": "can-connect/data/worker/worker.updateListData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".updateListData(listData, set)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `updateListData` is overwritten\nto forward calling [can-connect/connection.updateListData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.updateListData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.getSets": {
    "src": {
      "line": 90,
      "codeLine": 102,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getSets",
    "name": "can-connect/data/worker/worker.getSets",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getSets()",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getSets` is overwritten\nto forward calling [can-connect/connection.getSets] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getSets] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.clear": {
    "src": {
      "line": 103,
      "codeLine": 115,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "clear",
    "name": "can-connect/data/worker/worker.clear",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".clear()",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `clear` is overwritten\nto forward calling [can-connect/connection.clear] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.clear] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.getData": {
    "src": {
      "line": 116,
      "codeLine": 128,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-connect/data/worker/worker.getData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getData(params)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getData` is overwritten\nto forward calling [can-connect/connection.getData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.createData": {
    "src": {
      "line": 129,
      "codeLine": 141,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-connect/data/worker/worker.createData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".createData(instanceData, cid)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `createData` is overwritten\nto forward calling [can-connect/connection.createData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.createData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.updateData": {
    "src": {
      "line": 142,
      "codeLine": 154,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "updateData",
    "name": "can-connect/data/worker/worker.updateData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".updateData(instanceData)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `updateData` is overwritten\nto forward calling [can-connect/connection.updateData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.updateData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.destroyData": {
    "src": {
      "line": 155,
      "codeLine": 167,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-connect/data/worker/worker.destroyData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".destroyData(instanceData)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `destroyData` is overwritten\nto forward calling [can-connect/connection.destroyData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.destroyData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.name": {
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "String",
        "description": "The connection must be provided a unique name. This\nmakes sure the connections in both windows are linked.\n\n```js\nconnect([...],{\n  name: \"todos\"\n})\n```\n\t\t "
      }
    ],
    "title": "name",
    "name": "can-connect/data/worker/worker.name",
    "type": "property",
    "parent": "can-connect/data/worker/worker.identifiers"
  },
  "can-connect/data/worker/worker.worker": {
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Worker",
        "description": "A [web-worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) that \"data instance\" methods will be sent to.  This\nweb-worker should include a connection that matches the name of the window's\nconnection. If a worker isn't provided, the connection behaves as if the `data/worker` behavior\nwas not added.\n\n```js\nvar worker = new Worker(\"path/to/script.js\");\nconnect([...],{\n  worker: worker\n})\n```\n\t\t "
      }
    ],
    "title": "worker",
    "name": "can-connect/data/worker/worker.worker",
    "type": "property",
    "parent": "can-connect/data/worker/worker.identifiers"
  },
  "can-connect/data/worker/worker.identifiers": {
    "name": "can-connect/data/worker/worker.identifiers",
    "title": "Options",
    "type": "group",
    "parent": "can-connect/data/worker/worker",
    "description": "",
    "order": 0
  },
  "can-connect/data/worker/worker.data": {
    "name": "can-connect/data/worker/worker.data",
    "title": "Data Methods",
    "type": "group",
    "parent": "can-connect/data/worker/worker",
    "description": "",
    "order": 0
  },
  "can-connect/data/worker/worker": {
    "src": {
      "path": "node_modules/can-connect/data/worker/worker.md"
    },
    "body": "\n\n## Use\n\nThe best way to use `data/worker` is to create a connection module that works when loaded in\neither the `window` or in a [Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers).\nThis pattern tends to work even if workers are not supported.\n\nThe following creates a connection that does the work of [can-connect/cache-requests/cache-requests],\n[can-connect/data/url/url], and [can-connect/data/memory-cache/memory-cache] in a worker thread.  \n\n<div class='demo_wrapper' data-demo-src='../../../demos/can-connect/data-worker.html'></div>\n\nThe `todo_connection` module can be found [here](https://github.com/canjs/can-connect/blob/master/src/data/worker/demo/todo_connection.js)\nand looks like the following:\n\n\n```js\nvar connect = require(\"can-connect\");\nvar fixture = require(\"can-fixture\");\n\n// If we are in the main thread, see if we can load this same\n// connection in a worker thread.\nvar worker;\nif(typeof document !== \"undefined\") {\n\tworker = new Worker( System.stealURL+\"?main=can-connect/data/worker/demo/todo_connection\" );\n}\n\n\n// create cache connection\nvar cache = connect([\n\trequire(\"can-connect/data/memory-cache/\")\n],{\n\tname: \"todos\"\n});\n\n// Create the main connection with everything you need.  If there is a worker,\n// all data interface methods will be sent to the worker.\nvar todosConnection = connect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/cache-requests/cache-requests\"),\n\trequire(\"can-connect/data/worker/worker\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\")\n],{\n    url: \"/todos\",\n    cacheConnection: cache,\n    worker: worker,\n    name: \"todos\"\n});\n\n\nfixture.delay = 1000;\nfixture({\n\t\"GET /todos\": function(request){\n\t\treturn {data: [\n\t\t\t{id: 1, name: \"wash dishes\"},\n\t\t\t{id: 2, name: \"mow lawn\"},\n\t\t\t{id: 3, name: \"do laundry\"}\n\t\t]};\n\t}\n});\n\nmodule.exports = todosConnection;\n```\n\n\n\nThe things to notice:\n\n1. A `Worker` should be passed as the [can-connect/data/worker/worker.worker] option\nthat loads a connection with the same name as the connection in the `window`.  In thise case, the same\nconnection module is loaded so everything works.\n\n2. A single `Worker` could load multiple connection modules and perform other behaviors.  \n\n### Split Connection Logic\n\nTHe previous example used a single module that was loaded by both the window and the worker.\nThis doesn't have to be the case.  Two different modules could be used.  For example, `todo-window.js` and\n`todo-worker.js`.  Each might look like:\n\n```js\n// todo-window.js\nvar workerURL = System.stealURL+\"?main=app/models/todo-worker\";\n\nvar todoConnection = connect([\n\trequire(\"can-connect/data/worker/worker\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\"),\n  {\n    worker: new Worker( workerURL ),\n    name: \"todos\"\n  });\n```\n\n```js\n// todo-worker.js\nvar cache = connect([\n\trequire(\"can-connect/data/memory-cache/memory-cache\")\n],{\n\tname: \"todos-cache\"\n});\n\nvar todoConnection = connect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/cache-requests/cache-requests\"),\n\trequire(\"can-connect/data/worker/worker\")\n],{\n    url: \"/todos\",\n    cacheConnection: cache,\n    name: \"todos\"\n  });\n```\n\nHowever, the problem with the two-module approach is that it will not work\nif Workers are not supported by your browser.\n\n",
    "description": "\nConnects a connection to another connection in a worker thread.\n",
    "type": "module",
    "title": "",
    "name": "can-connect/data/worker/worker",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "dataWorker(baseConnection)",
        "description": "\n\nIf a [Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)\nis provided, overwrites the \"data interface methods\" to package the arguments and send them as\npart of a `postMessage` to the Worker.\n\n\nIf a `Worker` is not provided, it is assumed \"data-worker\" is being added\nwithin a worker thread.  It listens to messages sent to the Worker, calls the specified \"data interface method\"\nand sends a message back with the result.\n\nAny data methods called on the `window` connection will wait until the `worker` connection\nhas established a handshake.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/parse/parse": {
    "name": "can-connect/data/parse/parse",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 55,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n\n## Use\n\n`data/parse` is used to modify the response data of \"data interface\" methods to comply with what\nis expected by \"instance interface\" methods.  For example, if a service was returning list data\nat the `/services/todos` url like:\n\n```\n{\n  todos: [\n    {todo: {id: 0, name: \"dishes\"}},\n    {todo: {id: 2, name: \"lawn\"}}\n  ]\n}\n```\n\nThat service does not return [can-connect.listData] in the right format which should look like:\n\n```\n{\n  data: [\n    {id: 0, name: \"dishes\"},\n    {id: 2, name: \"lawn\"}\n  ]\n}\n```\n\nTo correct this, you can configure `data-parse` to use the [can-connect/data/parse/parse.parseListProp] and [connection.parseInstanceProp]\nas follows:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n parseListProp: \"todos\",\n parseInstanceProp: \"todo\"\n})\n```\n\n\n",
    "description": "\nExtract response data into a format needed for other extensions.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "dataParse(baseConnection)",
        "description": "\n\n  Overwrites the [can-connect/DataInterface] methods to run their results through\n  either [can-connect/data/parse/parse.parseInstanceData] or [can-connect/data/parse/parse.parseListData].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "The base connection.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "The base connection.\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseListData": {
    "type": "function",
    "name": "can-connect/data/parse/parse.parseListData",
    "parent": "can-connect/data/parse/parse",
    "src": {
      "line": 64,
      "codeLine": 131,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n## Use\n\n`parseListData` comes in handy when dealing with an irregular API\nthat can be improved with data transformation.\n\nSuppose an endpoint responds with a status of 200 OK, even when the\nrequest generates an empty result set. Worse yet, instead of representing\nan emtpy set with an empty list, it removes the property.\n\nA request to `/services/todos` may return:\n\n```\n{\n  todos: [\n    {todo: {id: 0, name: \"dishes\"}},\n    {todo: {id: 2, name: \"lawn\"}}\n  ]\n}\n```\n\nWhat if a request for `/services/todos?filterName=bank` responds with\n200 OK:\n\n```\n{\n}\n```\n\nThis response breaks its own schema. One way to bring it in line\nwith a format compatible with [can-connect.listData] is:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  parseListProp: \"todos\",\n  parseListData(responseData) {\n    if (responseData && !responseData.todos) {\n      responseData = { todos: [] };\n    }\n\n    return responseData;\n  }\n})\n```\n    \n",
    "description": "Given a response from [can-connect/connection.getListData] returns its data in the proper [can-connect.listData] format.\n\n",
    "title": "parseListData",
    "signatures": [
      {
        "code": "connection.parseListData(responseData)",
        "description": "\n\n  This function uses [can-connect/data/parse/parse.parseListProp] to find the array\n  containing the data for each instance.  Then it uses [can-connect/data/parse/parse.parseInstanceData]\n  on each item in the array  Finally, it returns data in the\n  [can-connect.listData] format.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "The response data from the AJAX request.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "An object like `{data: [props, props, ...]}`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "responseData",
      "description": "The response data from the AJAX request.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "An object like `{data: [props, props, ...]}`.\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseInstanceData": {
    "type": "function",
    "name": "can-connect/data/parse/parse.parseInstanceData",
    "parent": "can-connect/data/parse/parse",
    "src": {
      "line": 161,
      "codeLine": 231,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n## Use\n\n`parseInstanceData` comes in handy when dealing with an irregular API\nthat can be improved with data transformation.\n\nSuppose a request to `/services/todos` returns:\n```\n{\n  baseUrl: \"/proxy/share\",\n  todo: {\n    id: 0,\n    name: \"dishes\",\n    friendFaceUrl: \"friendface?id=0\",\n    fiddlerUrl: \"fiddler?id=0\"\n  }\n}\n```\n\nThe baseUrl property is meta-data that needs to be incorporated into the\ninstance data. One way to deal with this is:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  parseInstanceProp: \"todo\",\n  parseInstanceData(responseData) {\n    ['friendFaceUrl', 'fiddlerUrl'].map(urlProp => {\n      responseData.todo[urlProp] = [\n        responseData.baseUrl,\n        responseData.todo[urlProp]\n      ].join('/');\n    });\n\n    return responseData;\n  }\n})\n```\n\nThis results in an object like:\n\n```js\n{\n  id: 0,\n  name: \"dishes\",\n  friendFaceUrl: \"/proxy/share/friendface?id=0\",\n  fiddlerUrl: \"/proxy/share/fiddler?id=0\"\n}\n```\n    \n",
    "description": "Returns the properties that should be used to [can-connect/constructor/constructor.hydrateInstance make an instance] given the results of [can-connect/connection.getData], [can-connect/connection.createData], [can-connect/connection.updateData],\nand [can-connect/connection.destroyData].\n\n",
    "title": "parseInstanceData",
    "signatures": [
      {
        "code": "connection.parseInstanceData(responseData)",
        "description": "\n\n  This function will use [connection.parseInstanceProp] to find the data object\n  representing the instance that will be created.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "responseData",
      "description": "The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseListProp": {
    "body": "\n\n## Use\n\nSet `parseListProp` if your response data does not look like: `{data: [props, props]}`.\n\nFor example, if [can-connect/connection.getListData] returns data like:\n\n```\n{\n\t  todos: [{id: 1, name: \"dishes\"}, {id: 2, name: \"lawn\"}]\n}\n```\n\nSet `parseListProp` to `\"todos\"` like:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url : \"/todos\",\n  parseListProp: \"todos\"\n});\n```\n\n\t \n",
    "description": "\nThe property to find the array-like data that represents each instance item.\n",
    "types": [
      {
        "type": "String",
        "description": "[can-connect/data/parse/parse.parseListData] uses this property to find an array-like data struture\non the result of [can-connect/connection.getListData].\n"
      }
    ],
    "title": "parseListProp",
    "name": "can-connect/data/parse/parse.parseListProp",
    "type": "property",
    "parent": "can-connect/data/parse/parse",
    "comment": " "
  },
  "connection.parseInstanceProp": {
    "src": {
      "line": 276,
      "codeLine": 318,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\nSet `parseInstanceData` if your response data does not directly contain the data you would like to pass to\n[connection.hydrateInstance].\n\nFor example, if [can-connect/connection.getData] returns data like:\n\n```\n{\n  todo: {\n\t   id: 1,\n    name: \"dishes\"\n  }\n}\n```\n\nSet `parseInstanceProp` to `\"todo\"` like:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url : \"/todos\",\n  parseInstanceProp: \"todo\"\n});\n```\n\t \n",
    "description": "\nThe property to find the data that represents an instance item.\n",
    "types": [
      {
        "type": "String",
        "description": "[can-connect/data/parse/parse.parseInstanceData] uses this property's value to\n[can-connect/constructor/constructor.hydrateInstance make an instance].\n"
      }
    ],
    "title": "parseInstanceProp",
    "name": "connection.parseInstanceProp",
    "parent": "can-connect/data/parse/parse",
    "comment": " "
  },
  "can-connect/can/base-map/base-map": {
    "src": {
      "path": "node_modules/can-connect/can/base-map/base-map.md"
    },
    "body": "\n\n## Use\n\nThe `can-connect/can/base-map` module exports a helper function that creates a connection\nwith the \"standard\" behaviors in can-connect and hooks it up to a\n[can.Map](http://canjs.com/docs/can.Map.html) and [can.List](http://canjs.com/docs/can.List.html).\n\nIf you are using CanJS, this is an easy way to create a connection that can be useful and\nfast in most circumstances.\n\nTo use it, first define a Map and List constructor function:\n\n```\nvar Todo = can.Map.extend({ ... });\nvar TodoList = can.List.extend({Map: Todo},{ ... });\n```\n\nNext, call `baseMap` with all of the options needed by the behaviors that `baseMap` adds:\n\n```\nvar todoConnection = baseMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nAs, [can-connect/can/map/map] adds CRUD methods to the `Map` option, you can use those to create,\nread, update and destroy todos:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.attr({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nCreate connection with many of the best behaviors in can-connect and hook it up to\na [can.Map](http://canjs.com/docs/can.Map.html).\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect/can/base-map/base-map",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "baseMap(options)",
        "description": "\n\n  Creates a connection with the following behaviors: [can-connect/constructor/constructor],\n  [can-connect/can/map/map],\n  [can-connect/constructor/store/store],\n  [can-connect/data/callbacks/callbacks],\n  [can-connect/data/callbacks-cache/callbacks-cache],\n  [can-connect/data/parse/parse],\n  [can-connect/data/url/url],\n  [can-connect/real-time/real-time],\n  [can-connect/constructor/callbacks-once/callbacks-once].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/map/map.id": {
    "type": "function",
    "name": "can-connect/can/map/map.id",
    "parent": "can-connect/can/map/map.identifiers",
    "src": {
      "line": 41,
      "codeLine": 57,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nReturns a unique identifier value for an instance.\n",
    "title": "id",
    "signatures": [
      {
        "code": "connection.id( instance )",
        "description": "\n\n  Reads the [can-connect/base/base.algebra]'s id so that it's observable unless\n  the id is being read as part of the map being bound or\n  unbound.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/map/map.serializeInstance": {
    "type": "function",
    "name": "can-connect/can/map/map.serializeInstance",
    "parent": "can-connect/can/map/map.serializers",
    "src": {
      "line": 82,
      "codeLine": 92,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCalls `instance.serialize()`.\n",
    "title": "serializeInstance",
    "signatures": [
      {
        "code": "connection.serializeInstance( instance )",
        "description": "\n\n  Simply calls [can-define/map/map.prototype.serialize] on the underlying map.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.serializeList": {
    "type": "function",
    "name": "can-connect/can/map/map.serializeList",
    "parent": "can-connect/can/map/map.serializers",
    "src": {
      "line": 95,
      "codeLine": 105,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCalls `list.serialize()`.\n",
    "title": "serializeList",
    "signatures": [
      {
        "code": "connection.serializeList( list )",
        "description": "\n\n  Simply calls [can-define/list/list.prototype.serialize] on the underlying list.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map._Map": {
    "src": {
      "line": 108,
      "codeLine": 143,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  complete: function(){\n    this.completed = true\n  }\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n```\n\t \n",
    "description": "\nSpecify what type of `Map` should be hydrated.\n",
    "types": [
      {
        "type": "Map",
        "description": "Defaults to [can-util/js/types/types.DefaultMap] if a Map is\nnot specified.\n"
      }
    ],
    "title": "Map",
    "name": "can-connect/can/map/map._Map",
    "parent": "can-connect/can/map/map.hydrators",
    "comment": " "
  },
  "can-connect/can/map/map._List": {
    "src": {
      "line": 143,
      "codeLine": 188,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  complete: function(){\n    this.completed = true\n  }\n});\n\nvar Todo.List = DefineList.extend({\n  \"*\": Todo,\n  completed: function(){\n    this.filter(function(todo){\n      return todo.completed;\n    });\n  }\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  List: Todo.List,\n  url: \"/todos\"\n});\n```\n\t \n",
    "description": "\nSpecify what type of `CanList` should be hydrated.\n",
    "types": [
      {
        "type": "CanList",
        "description": "Defaults to [can-connect/can/map/map._Map]'s `.List` and\nthen [can-util/js/types/types.DefaultList] if `connection.List` is not specified.\n"
      }
    ],
    "title": "List",
    "name": "can-connect/can/map/map._List",
    "parent": "can-connect/can/map/map.hydrators",
    "comment": " "
  },
  "can-connect/can/map/map.instance": {
    "type": "function",
    "name": "can-connect/can/map/map.instance",
    "parent": "can-connect/can/map/map.hydrators",
    "src": {
      "line": 188,
      "codeLine": 201,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCreates a `Map` instance.\n",
    "title": "instance",
    "signatures": [
      {
        "code": "connection.instance( props )",
        "description": "\n\n  Uses the [can-connect/can/map/map._Map] property if available, otherwise\n  creates the [can-util/js/types/types.DefaultMap].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The raw instance data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Map"
            }
          ],
          "description": "An observable map type.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The raw instance data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Map"
        }
      ],
      "description": "An observable map type.\n\t "
    }
  },
  "can-connect/can/map/map.list": {
    "type": "function",
    "name": "can-connect/can/map/map.list",
    "parent": "can-connect/can/map/map.hydrators",
    "src": {
      "line": 205,
      "codeLine": 223,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCreates a `List` instance given raw data.\n",
    "title": "list",
    "signatures": [
      {
        "code": "connection.list(listData, set)",
        "description": "\n\n  Uses the [can-connect/can/map/map._List] property if available, otherwise\n  creates the [can-connect/can/map/map._Map].List if available, and then finally\n  defaults to [can-util/js/types/types.DefaultList].\n\n  This will add properties on `listData` to the list too.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The raw list data."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set the data belongs to."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "An observable list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set the data belongs to."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "An observable list.\n\t "
    }
  },
  "can-connect/can/map/map.updatedList": {
    "type": "function",
    "name": "can-connect/can/map/map.updatedList",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "src": {
      "line": 235,
      "codeLine": 249,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nUpdates a list with response data.\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedList( list, listData, set)",
        "description": "\n\n  Updates the list within a batch event. Overwrite this if you want custom updating behavior.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The list to be updated."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "Raw list data."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set of the list being updated.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set of the list being updated.\n\t "
    }
  },
  "can-connect/can/map/map.createdInstance": {
    "src": {
      "line": 280,
      "codeLine": 294,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.createData].\n",
    "title": "createdInstance",
    "name": "can-connect/can/map/map.createdInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"created\" event on the map and the map's constructor function.\n",
        "params": [
          {
            "types": [
              {
                "type": "Map"
              }
            ],
            "name": "instance",
            "description": "a Map instance"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the updated properties\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the updated properties\n\t "
    }
  },
  "can-connect/can/map/map.updatedInstance": {
    "src": {
      "line": 295,
      "codeLine": 306,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.updateData].\n",
    "title": "updatedInstance",
    "name": "can-connect/can/map/map.updatedInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"updated\" event on the map and the map's constructor function.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.destroyedInstance": {
    "src": {
      "line": 307,
      "codeLine": 318,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.destroyData].\n",
    "title": "destroyedInstance",
    "name": "can-connect/can/map/map.destroyedInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.destroyedInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"destroyed\" event on the map and the map's constructor function.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.getList": {
    "type": "function",
    "name": "can-connect/can/map/map.getList",
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 364,
      "codeLine": 400,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n\n## Use\n\n```\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nTodo.getList({due: \"today\"}).then(function(todos){\n\n});\n```\n \n",
    "description": "\nGets a list of instances of the map type.\n",
    "title": "getList",
    "signatures": [
      {
        "code": "Map.getList(set)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "CanList"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "CanList"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.findAll": {
    "type": "function",
    "name": "can-connect/can/map/map.findAll",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "connection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 405,
      "codeLine": 411,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": " \n",
    "description": "\nAlias of [can-connect/can/map/map.getList]. You should use `.getList()`.\n",
    "title": "findAll"
  },
  "can-connect/can/map/map.get": {
    "type": "function",
    "name": "can-connect/can/map/map.get",
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 416,
      "codeLine": 452,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n\n## Use\n\n```js\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nTodo.get({id: 5}).then(function(todo){\n\n});\n```\n \n",
    "description": "\nGets an instance of the map type.\n",
    "title": "get",
    "signatures": [
      {
        "code": "Map.get(params)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "params",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Map"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "params",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Map"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.findOne": {
    "type": "function",
    "name": "can-connect/can/map/map.findOne",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "connection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 458,
      "codeLine": 464,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": " \n",
    "description": "\nAlias of [can-connect/can/map/map.get]. You should use `.get()`.\n",
    "title": "findOne"
  },
  "can-connect/can/map/map.prototype.isNew": {
    "src": {
      "line": 500,
      "codeLine": 512,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map has not been persisted.\n",
    "title": "isNew",
    "name": "can-connect/can/map/map.prototype.isNew",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isNew()",
        "description": "\n\n  Returns `true` if [can-connect/base/base.id] is 0 or truthy.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/map/map.prototype.isSaving": {
    "src": {
      "line": 520,
      "codeLine": 532,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map is currently being saved.\n",
    "title": "isSaving",
    "name": "can-connect/can/map/map.prototype.isSaving",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isSaving()",
        "description": "\n\n  Returns `true` if .save() has been called, but has not resolved yet.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/map/map.prototype.isDestroying": {
    "src": {
      "line": 538,
      "codeLine": 558,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map is currently being destroyed.\n",
    "title": "isDestroying",
    "name": "can-connect/can/map/map.prototype.isDestroying",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isDestroying()",
        "description": "\n\nObserves if the promise returned by `.destroy()` has completed.  This is\noften used in template like:\n\n```\n<button ($click)=\"todo.destroy()\"\n   {{#todo.isDestroying}}disabled{{/todo.isDestroying}}>\n  X\n</button>\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `.destroy()` has been called but is not resolved yet.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `.destroy()` has been called but is not resolved yet.\n\t "
    }
  },
  "can-connect/can/map/map.prototype.save": {
    "src": {
      "line": 564,
      "codeLine": 601,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\n```\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nnew Todo({name: \"dishes\"}).save();\n```\n\t \n",
    "description": "\nPersists the map's data to the connection.\n",
    "title": "save",
    "name": "can-connect/can/map/map.prototype.save",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.save( [success], [error] )",
        "description": "\n\n  Calls [can-connect/connection.save].\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "success",
            "description": "A function that is called if the save is successful."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function that is called if the save is rejected."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance is successful.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function that is called if the save is rejected."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance is successful.\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.prototype.destroy": {
    "src": {
      "line": 609,
      "codeLine": 646,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\n```\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nnew Todo({name: \"dishes\"}).save(function(todo){\n  todo.destroy();\n});\n```\n\t \n",
    "description": "\nDelete's the instance with the connection.\n",
    "title": "destroy",
    "name": "can-connect/can/map/map.prototype.destroy",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.destroy( [success], [error] )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "success",
            "description": "A function that is called if the destroy is successful."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function that is called if the destroy is rejected."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance is successful.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function that is called if the destroy is rejected."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance is successful.\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.map-static": {
    "name": "can-connect/can/map/map.map-static",
    "title": "Map Static Methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 0
  },
  "can-connect/can/map/map.map": {
    "name": "can-connect/can/map/map.map",
    "title": "Map Instance Methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 1
  },
  "can-connect/can/map/map.hydrators": {
    "name": "can-connect/can/map/map.hydrators",
    "title": "Hydrators",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 2
  },
  "can-connect/can/map/map.serializers": {
    "name": "can-connect/can/map/map.serializers",
    "title": "Serializers",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 3
  },
  "can-connect/can/map/map.identifiers": {
    "name": "can-connect/can/map/map.identifiers",
    "title": "Identifiers",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 4
  },
  "can-connect/can/map/map.instance-callbacks": {
    "name": "can-connect/can/map/map.instance-callbacks",
    "title": "Instance Callbacks",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 5
  },
  "can-connect/can/map/map": {
    "src": {
      "path": "node_modules/can-connect/can/map/map.md"
    },
    "body": "\n\n## Use\n\nThe `can/map` behavior make a connection use instances of a [can.Map](http://canjs.com/docs/can.Map.html) and\n[can.List](http://canjs.com/docs/can.List.html).  It also adds methods to the [can.Map](http://canjs.com/docs/can.Map.html)\nthat use the connection for retrieving, creating, updating, and destroying Map instances.\n\nTo use `can/map`, first create a Map and List constructor function:\n\n```\nvar Todo = can.Map.extend({\n  canComplete: function(ownerId) {\n    return this.attr(\"ownerId\") === ownerId;\n  }\n});\n\nvar TodoList = can.List.extend({\n  Map: Todo\n},{\n  incomplete: function(){\n    return this.filter(function(todo){\n      return !todo.attr(\"complete\")\n    });\n  }\n});\n```\n\nNext, pass the Map and List constructor functions to `connect` as options. The following\ncreates a connection that connects `Todo` and `TodoList` to a restful URL:\n\n```js\nvar connect = require(\"can-connect\");\n\nvar todoConnection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/can/map/map\")\n],{\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\"\n});\n```\n\nNow the connection can be used to CRUD `Todo` and `TodoList`s:\n\n```\ntodoConnection.getList({}).then(function(todos){\n  var incomplete = todos.incomplete();\n  incomplete.attr(0).canComplete( 5 ) //-> true\n})\n```\n\nHowever, because `can/map` adds methods to the `Map` option, you can use `Todo` directly to\nCRUD `Todo` and `TodoList`s:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.attr({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nConnects a [can.Map](http://canjs.com/docs/can.Map.html) to everything that needs to be connected to\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect/can/map/map",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "canMap( baseConnect )",
        "description": "\n\n  Implements the hydrators, serializers, identifiers, and instance\n  callback interfaces so they work with a [can.Map](http://canjs.com/docs/can.Map.html) and\n  [can.List](http://canjs.com/docs/can.List.html).\n  Adds static and prototype methods to the Map that make use of the connection's\n  methods.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/super-map/super-map": {
    "src": {
      "path": "node_modules/can-connect/can/super-map/super-map.md"
    },
    "body": "\n\n## Use\n\nThe `can-connect/can/super-map` module exports a helper function that creates a connection\nwith the \"standard\" behaviors in can-connect and hooks it up to a\n[can.Map](http://canjs.com/docs/can.Map.html) and [can.List](http://canjs.com/docs/can.List.html).\n\nIf you are using CanJS, this is an easy way to create a connection that can be useful and\nfast in most circumstances.\n\nTo use it, first define a Map and List constructor function:\n\n```\nvar Todo = can.Map.extend({ ... });\nvar TodoList = can.List.extend({Map: Todo},{ ... });\n```\n\nNext, call `superMap` with all of the options needed by the behaviors that `superMap` adds:\n\n```\nvar todoConnection = superMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nAs, [can-connect/can/map/map] adds CRUD methods to the `Map` option, you can use those to create,\nread, update and destroy todos:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.attr({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nCreate connection with many of the best behaviors in can-connect and hook it up to\na [can.Map](http://canjs.com/docs/can.Map.html).\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect/can/super-map/super-map",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "superMap(options)",
        "description": "\n\n  Creates a connection with the following behaviors: [can-connect/constructor/constructor],\n  [can-connect/can/map/map],\n  [can-connect/constructor/store/store],\n  [can-connect/data/callbacks/callbacks],\n  [can-connect/data/callbacks-cache/callbacks-cache],\n  [can-connect/data/combine-requests/combine-requests],\n  [can-connect/data/inline-cache/inline-cache],\n  [can-connect/data/parse/parse],\n  [can-connect/data/url/url],\n  [can-connect/real-time/real-time],\n  [can-connect/fall-through-cache/fall-through-cache],\n  [can-connect/constructor/callbacks-once/callbacks-once].\n\n  And creates a [can-connect/data/localstorage-cache/localstorage-cache] to use as a [can-connect/base/base.cacheConnection].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/model/model": {
    "src": {
      "path": "node_modules/can-connect/can/model/model.md"
    },
    "body": "\n## Use\n\n`can-connect/can/model` is for backwards compatability\nwith [can.Model](http://canjs.com/docs/can.Model.html) so that developers can migrate\nto `can-connect` without having to rewrite their models immediately.\n\nHowever, use of `can.Model` will be deprecated in CanJS 3.0. Instead of extending `can.Model`,\nextend `can.Map` and `can.List` and use the [can-connect/can/map/map] behavior to connect your Map and List to a connection:\n\n```\nvar Todo = can.Map.extend({ ... });\n\nvar TodoList = can.List.extend({\n  Map: Todo\n},{ ... });\n\nvar todoConnection = connect([\"data-url\",\"constructor\",\"can/map\"],{\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\"\n});\n```\n\nOr, use the [can-connect/can/super-map/super-map] function to create a connection with the \"standard\" behaviors:\n\n```\nvar todoConnection = superMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nFor your legacy code, you should just need to import \"can-connect/can/model/\" instead of \"can/model/\" like:\n\n```\nimport Model from \"can-connect/can/model/\";\n\nTodo = Model.extend({\n  findAll: \"/todos\"\n},{});\n\nTodo.findAll({}).then(function(todos){\n\n});\n```\n\n## Upgrading can.Models to can-connect\n\nThis section walks through making the necessary changes to upgrade a legacy can.Model to use `can-connect` and its\nbehaviors.  We'll convert a `can.Model` and `can.Model.List` that looks like:\n\n```\nTodo = can.Model.extend({\n  resource: \"/\",\n  destroy: \"POST /todos/{id}/delete\",\n  findOne: function(params){\n    return $.get(\"/todos/\"+params._id);\n  },\n\n  parseModels: function(data){\n    return data.todos;\n  },\n  parseModel: \"todo\",\n\n  id: \"_id\",\n},{\n  method: function(){ ... },\n  define: { ... }\n});\n\nTodo.List = Todo.List.extend({ ... });\n```\n\nConverting this to use `can-connect` looks like:\n\n```\nTodo = can.Map.extend({\n  method: function(){ ... },\n  define: { ... }\n});\nTodo.List = can.List.extend({\n  Map: Todo\n},{ ... })\n\nconnect([\"data-url\",\"data-parse\",\n        \"constructor\",\"constructor-store\",\n        \"can-map\"],\n  {\n    Map: Todo,\n    List: Todo.List,\n\n    url: {\n      resource: \"/\",\n      destroyData: \"POST /todos/{id}/delete\",\n      getData: function(params){\n        return $.get(\"/todos/\"+params._id);\n      }\n    },\n\n    parseListData: function(data){\n      return data.todos;\n    },\n    parseInstanceProp: \"todo\",\n\n    idProp: \"_id\"\n  });\n```\n\nInstead of `Todo.findAll` and `Todo.findOne`, use `Todo.getList` and `Todo.get`.\n\nLets break this down in the following sections.\n\n### Defining the Map and List\n\nThe first step is to pull out the parts of the Model and Model.List that define the\nobservable Map and List's behavior into a `can.Map` and `can.List`:\n\n```\nTodo = can.Map.extend({\n  method: function(){ ... },\n  define: { ... }\n});\nTodo.List = can.List.extend({\n  Map: Todo\n},{ ... })\n```\n\nOne of the main advantegous of `can-connect` is that it lets seperate persistence behavior\nfrom property behavior.\n\n### Connecting the Map and List to behaviors\n\nThe next step is to connect the Map and List to the right behaviors.  The following\nadds behaviors with similar functionality to legacy `can.Map` and uses the [can-connect/can/map/map] behavior\n(which makes use of [can-connect/constructor/constructor]) to connect the connection to the provided Map and List types:\n\n```\nconnect([\"data-url\",\"data-parse\",\n        \"constructor\",\"constructor-store\",\n        \"can-map\"],\n  {\n    Map: Todo,\n    List: Todo.List,\n    ...\n  })\n```\n\n### Connecting to urls\n\nThe [can-connect/data/url/url] behavior supports CRUDing data from urls.  It can be configured like:\n\n```\nconnect([\"data-url\", ...],\n  {\n    ...\n    url: {\n      resource: \"/\",\n      destroyData: \"POST /todos/{id}/delete\",\n      getData: function(params){\n        return $.get(\"/todos/\"+params._id);\n      }\n    },\n    ...\n  });\n```\n\n### Correcting response data\n\nThe [can-connect/data/parse/parse] behavior supports correcting response data.  It can be configured like:\n\n```\nconnect([..., \"data-parse\", ...],\n  {\n    ...\n    parseListData: function(data){\n      return data.todos;\n    },\n    parseInstanceProp: \"todo\",\n    ...\n  });\n```\n\n### Specifying the id\n\nThe id of a model is used in a variety of ways.  It's part of the [can-connect/base/base] behavior\nadded to every connection.  You can customize which property represents the id with [can-connect/base/base.idProp].\n\n```\nconnect([...],\n  {\n    idProp: \"_id\"\n  });\n```\n\n### Retrieving data\n\nThe [can-connect/can/map/map] behavior adds a `getList` and `get` method to the `Map` option.  Use them in\nplace of `findAll` and `findOne`:\n\n```\nTodo.findAll({}).then(function(todosList){ ... });\nTodo.findOne({id: 5}).then(function(todo){ ... });\n```\n\n## Differences from can.Model\n\nModel's produced from `can-connect/can/model`:\n\n - Do not support `makeFindAll` or `makeFindOne`.  If your legacy code did this, you can probably add it as a custom behavior.\n - Has the instance store at `Model.store`, but items should be retrieved like `Model.store.get(id)`.\n - Should not use `Model.models` or `Model.model` to correct Ajax data and should instead use `Models.parseModel` and `Model.parseModels`.\n - Uses a Promise polyfill, not jQuery's promises.\n\n",
    "description": "Exports a constructor that works very similar to [can.Model](http://canjs.com/docs/can.Model.html). \n",
    "type": "module",
    "title": "",
    "name": "can-connect/can/model/model",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "Model.extend( static, prototype )",
        "description": "\n\n\tDefines a [map](http://canjs.com/docs/can.Map.html) that has almost all of the functionality of\n\t[can.Model](http://canjs.com/docs/can.Model.html).\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/ref/ref.hydrators": {
    "name": "can-connect/can/ref/ref.hydrators",
    "title": "Hydrators",
    "type": "group",
    "parent": "can-connect/can/ref/ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.methods": {
    "name": "can-connect/can/ref/ref.methods",
    "title": "Methods",
    "type": "group",
    "parent": "can-connect/can/ref/ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref": {
    "name": "can-connect/can/ref/ref",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 145,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n## Use\n\n`can/ref` is useful when the server might return either a reference to\na value or the value itself.  For example, in a MongoDB setup, it\na request like `GET /game/5` might return:\n\n```\n{\n  id: 5,\n  teamRef: 7,\n  score: 21\n}\n```\n\nBut a request like `GET /game/5?$populate=teamRef` might return:\n\n```\n{\n  id: 5,\n  teamRef: {id: 7, name: \"Cubs\"},\n  score: 21\n}\n```\n\n`can/ref` can handle this abigutity, and even make lazy loading possible.\n\nTo use `can/ref`, first create a Map and a connection for the referenced type:\n\n```\nvar Team = DefineMap.extend({\n\tid: 'string'\n});\n\nconnect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/constructor/store/store\"),\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/can/ref/ref\")\n],{\n    Map: Team,\n    List: Team.List,\n    ...\n})\n```\n\nThe connection is necessary because it creates an instance store which will\nhold instances of `Team` that the `Team.Ref` type will be able to access.\n\nNow we can create a reference to the Team within a Game map and the Game's connection:\n\n```\nvar Game = DefineMap.extend({\n id: 'string',\n teamRef: {type: Team.Ref.type},\n score: \"number\"\n});\n\nsuperMap({\n  Map: Game,\n  List: Game.List\n})\n```\n\nNow, `teamRef` is a [can-connect/can/ref/ref.Map.Ref] type, which will\nhouse the id of the reference no matter how the server returns data like\n`game.teamRef.id`.\n\nFor example, without populating the team data:\n\n```\nGame.get({id: 5}).then(function(game){\n\tgame.teamRef.id //-> 7\n});\n```\n\nWith populating the team data:\n\n```\nGame.get({id: 5, populate: \"teamRef\"}).then(function(game){\n\tgame.teamRef.id //-> 7\n});\n```\n\nThe values of other properties and methods on the [can-connect/can/ref/ref.Map.Ref] type\nare determined by if the reference was populated or the referenced item already exists\nin the [can-connect/constructor/store/store.instanceStore].\n\nFor example, `value`, which points to the referenced instance will be populated if the reference was populated:\n\n```\nGame.get({id: 5, $populate: \"teamRef\"}).then(function(game){\n\tgame.teamRef.value.name //-> 5\n});\n```\n\nOr, it will be populated if that instance had loaded through another means and\nis in the instance store:\n\n```\nTeam.get({id: 7}).then(function(team){\n  // binding adds things to the store\n  team.on(\"name\", function(){})\n}).then(function(){\n  Game.get({id: 5}).then(function(game){\n    game.teamRef.value.name //-> 5\n  });\n})\n```\n\n`value` is an [can-define.types.get asynchrounos getter], which means that even if\nthe referenced value isn't populated or loaded through the store, it can be lazy loaded. This\nis generally most useful in a template.\n\nThe following will make an initial request for game `5`, but when the template\ntried to read and listen to `game.teamRef.value.name`, a request for team `7`\nwill be made.\n\n```\nvar template = stache(\"{{game.teamRef.value.name}} scored {{game.score}} points\");\nGame.get({id: 5}).then(function(game){\n   template({game: game});\n});\n```\n\n\n\n",
    "description": "Handle references to instances in the raw data returned by the server. \n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "canRef( baseConnect )",
        "description": "\n\n  Makes a reference type that is loads the related type or hold onto an existing one. This allows us to create circular references and load relevant data as needed\n",
        "params": [
          {
            "types": [
              {
                "type": "connection"
              }
            ],
            "name": "baseConnect",
            "description": "The base connection should have [can-connect/can/map/map]\nalready applied to it.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "connection"
        }
      ],
      "name": "baseConnect",
      "description": "The base connection should have [can-connect/can/map/map]\nalready applied to it.\n"
    },
    "comment": " "
  },
  "can-connect/can/ref/ref.Map.Ref.static": {
    "name": "can-connect/can/ref/ref.Map.Ref.static",
    "title": "static",
    "type": "group",
    "parent": "can-connect/can/ref/ref.Map.Ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.Map.Ref.prototype": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-connect/can/ref/ref.Map.Ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.Map.Ref": {
    "type": "property",
    "name": "can-connect/can/ref/ref.Map.Ref",
    "params": [
      {
        "types": [
          {
            "type": "string"
          }
        ],
        "name": "id",
        "description": "string representing the record id"
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "value",
        "description": "instance loaded / hydrated"
      }
    ],
    "parent": "can-connect/can/ref/ref.hydrators",
    "src": {
      "line": 154,
      "codeLine": 163,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "title": "Map.Ref",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "value",
      "description": "instance loaded / hydrated"
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Instance for the id\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Instance for the id\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.store": {
    "name": "can-connect/can/ref/ref.Map.Ref.store",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.static",
    "src": {
      "line": 184,
      "codeLine": 189,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": " \n",
    "description": "A WeakReferenceMap that contains instances being created by their `._cid` property.\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map"
      }
    ],
    "title": "store"
  },
  "can-connect/can/ref/ref.Map.Ref.type": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.type",
    "parent": "can-connect/can/ref/ref.Map.Ref.static",
    "src": {
      "line": 191,
      "codeLine": 200,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "\n",
    "title": "type",
    "signatures": [
      {
        "code": "Map.Ref.type(ref)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "name": "ref",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/can/ref/ref.Map.Ref"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "String"
        },
        {
          "type": "Number"
        }
      ],
      "name": "ref",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/can/ref/ref.Map.Ref"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.promise": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.promise",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 212,
      "codeLine": 219,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Promise"
      }
    ],
    "title": "promise",
    "signatures": [
      {
        "code": "ref.promise",
        "description": "\n\treturns a promise if it has already been resolved, if not, returns a new promise",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.value": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.value",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 243,
      "codeLine": 250,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "value",
    "signatures": [
      {
        "code": "ref.value",
        "description": "\n\treturns the actual object that reference points to",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "object"
            }
          ],
          "description": "actual object that reference points to\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "object"
        }
      ],
      "description": "actual object that reference points to\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.reason": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.reason",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 261,
      "codeLine": 268,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "reason",
    "signatures": [
      {
        "code": "ref.reason",
        "description": "\n\thandles the rejection case for the promise",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "error message if the promise is rejected\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "error message if the promise is rejected\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isResolved": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isResolved",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 292,
      "codeLine": 300,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "\n",
    "title": "isResolved",
    "signatures": [
      {
        "code": "ref.isResolved",
        "description": "\n\tReturns a {boolean}",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isRejected": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isRejected",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 303,
      "codeLine": 310,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "title": "isRejected",
    "signatures": [
      {
        "code": "ref.isRejected",
        "description": "\n\tReturns boolean if the promise was rejected",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isPending": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isPending",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 314,
      "codeLine": 321,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "title": "isPending",
    "signatures": [
      {
        "code": "ref.isPending",
        "description": "\n\tReturns true if the state is not 'resolved' or 'rejected'",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.serialize": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.serialize",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 325,
      "codeLine": 332,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "title": "serialize",
    "signatures": [
      {
        "code": "ref.serialize",
        "description": "\n\treturns the `idProp`",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "string"
            }
          ],
          "description": "idProp\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "string"
        }
      ],
      "description": "idProp\n "
    }
  },
  "init": {
    "type": "function",
    "name": "init",
    "params": [],
    "parent": "can-connect/can/ref/ref.methods",
    "src": {
      "line": 361,
      "codeLine": 367,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\t \n",
    "description": "\n",
    "can": "-connect/can/ref/ref.init init",
    "comment": "Initializes the base connection and then creates and sets [can-connect/can/ref/ref.Map.Ref]. "
  },
  "can-connect/can/tag/tag": {
    "src": {
      "line": 0,
      "codeLine": 32,
      "path": "node_modules/can-connect/can/tag/tag.js"
    },
    "type": "module",
    "body": "\n## Use\n\n```\nconnect.tag(\"order-model\", connection);\n```\n\n```\n<order-model get-list=\"{type=orderType}\">\n  <ul>\n  \\{{#isPending}}<li>Loading</li>\\{{/isPending}}\n  \\{{#isResolved}}\n    \\{{#each value}}\n      <li>\\{{name}}</li>\n    \\{{/each}}\n  \\{{/isResolved}}\n  </ul>\n</order-model>\n```\n\n\n",
    "description": "\nMakes either getList or getInstance\n",
    "title": "",
    "name": "can-connect/can/tag/tag",
    "parent": "can-connect.modules",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "tagName",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "connection",
        "description": "\n"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "connection",
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/connection.destroy": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/destroy.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.destroy",
    "name": "can-connect/connection.destroy",
    "type": "function",
    "parent": "can-connect/InstanceInterface"
  },
  "can-connect/connection.getList": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/getList.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.getList",
    "name": "can-connect/connection.getList",
    "type": "function",
    "parent": "can-connect/InstanceInterface",
    "signatures": [
      {
        "code": "connection.getList(set)",
        "description": "\n\n  Loads a List\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A set object that represents the list of data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "List",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Instance"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A set object that represents the list of data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "List",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Instance"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    }
  },
  "can-connect/connection.get": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/get.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.get",
    "name": "can-connect/connection.get",
    "type": "function",
    "parent": "can-connect/InstanceInterface"
  },
  "can-connect/InstanceInterface": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/instance_interface.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "InstanceInterface",
    "name": "can-connect/InstanceInterface",
    "parent": "can-connect.types",
    "signatures": [
      {
        "code": "InstanceInterface",
        "description": "\n\nBlah\n",
        "params": []
      }
    ]
  },
  "can-connect/connection.save": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/save.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.save",
    "name": "can-connect/connection.save",
    "type": "function",
    "parent": "can-connect/InstanceInterface"
  },
  "can-connect/constructor/callbacks-once/callbacks-once": {
    "name": "can-connect/constructor/callbacks-once/callbacks-once",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 14,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "body": "\n",
    "description": "\nPrevents unecessary calls to the instance callback methods.\n",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "constructorCallbacksOnce(baseBehavior)",
        "description": "\n\n  Prevents duplicate calls to the instance callback methods by tracking\n  the last data the methods were called with.  If called with the\n  same data again, it does not call the base behavior's instance callback.\n\n\n",
        "params": []
      }
    ]
  },
  "can-connect/constructor/callbacks-once/callbacks-once.createdData": {
    "src": {
      "line": 20,
      "codeLine": 28,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.createData]. The result of this function will be used\nas the new response data.\n",
    "title": "createdData",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.createdData",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once"
  },
  "can-connect/constructor/callbacks-once/callbacks-once.updatedData": {
    "src": {
      "line": 29,
      "codeLine": 37,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.updateData]. The result of this function will be used\nas the new response data.\n",
    "title": "updatedData",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.updatedData",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once"
  },
  "can-connect/constructor/callbacks-once/callbacks-once.destroyedData": {
    "src": {
      "line": 38,
      "codeLine": 46,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.destroyData]. The result of this function will be used\nas the new response data.\n",
    "title": "destroyedData",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.destroyedData",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once"
  },
  "can-connect/constructor/store/store.stores": {
    "name": "can-connect/constructor/store/store.stores",
    "title": "Stores",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 0
  },
  "can-connect/constructor/store/store.crud": {
    "name": "can-connect/constructor/store/store.crud",
    "title": "CRUD Methods",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 1
  },
  "can-connect/constructor/store/store.hydrators": {
    "name": "can-connect/constructor/store/store.hydrators",
    "title": "Hydrators",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 2
  },
  "can-connect/constructor/store/store": {
    "name": "can-connect/constructor/store/store",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 80,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe `constructor-store` extension is used to:\n - provide a store of instances and lists used by the client.\n - prevent multiple instances from being hydrated for the same [can-connect/base/base.id] or multiple\n   lists for the same [can-connect/base/base.listSet].\n\nThe stores provide access to an instance\nby its [can-connect/base/base.id] or a list by its [can-connect/base/base.listSet]. These stores are\nused by other extensions like [can-connect/real-time/real-time] and [can-connect/fall-through-cache/fall-through-cache].\n\nLets see how `constructor-store`'s behavior be used to prevent multiple\ninstances from being hydrated.  This example allows you to create multiple instances of a `todoEditor` that loads\nand edits a todo instance.\n\n<div class='demo_wrapper' data-demo-src='../../../demos/can-connect/constructor-store.html'></div>\n\nYou'll notice that you can edit one todo's name and the other\ntodo editors update.  This is because each `todoEditor` gets the same instance in memory.  So that when it\nupdates the todo's name ...\n\n```\nelement.firstChild.onchange = function(){\n  todo.name = this.value;\n};\n```\n\n... the other widgets update because they have bound on the same instance:\n\n```\nObject.observe(todo, update, [\"update\"] );\ntodosConnection.addInstanceReference(todo);\n```\n\nEach `todoEditor` gets the same instance because they called [can-connect/constructor/store/store.addListReference]\nwhich makes it so anytime a todo with `id=5` is requested, the same instance is returned.\n\nNotice that if you change an input element, and click \"Create Todo Editor\", all the `todoEditor`\nwidgets are set back to the old text.  This is because whenever data is loaded from the server,\nit is passed to [can-connect/constructor/constructor.updatedInstance] which defaults to overwriting any current\nproperties with those from the server.\n\nTo make sure the server has the latest, you can save a todo by hitting \"ENTER\".\n\nFinally, this widget cleans itself up nicely when it is removed by unobserving the\n`todo` instance and\n[can-connect/constructor/store/store.deleteInstanceReference deleting the instance reference]. Doing this\nprevents memory leaks.\n\n```\nObject.unobserve(todo, update, [\"update\"] );\ntodosConnection.deleteInstanceReference(todo);\n```\n\n\n\n\n",
    "description": "\nSupports saving and retrieving lists and instances in a store.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructorStore(baseConnection)",
        "description": "\n\n  Overwrites baseConnection so it contains a store for\n  instances and lists.  It traps calls to the\n  [can-connect/constructor/store/store.hydrateInstance] and\n  [can-connect/constructor/store/store.hydrateList] methods to\n  use instances or lists in the store if available. It\n  overwrites \"CRUD METHODS\" to make sure that while any request\n  is pending, all lists and instances are added to the store.\n  Finally, it provides methods to add and remove items in the\n  store via reference counting.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/constructor/store/store.instanceStore": {
    "name": "can-connect/constructor/store/store.instanceStore",
    "type": "property",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 112,
      "codeLine": 129,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nA store of instances mapped by [can-connect/base/base.id].\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "\n\n  Stores instances by their [can-connect/base/base.id] which have had\n  [can-connect/constructor/store/store.addInstanceReference] called more\n  times than [can-connect/constructor/store/store.deleteInstanceReference].\n\n  ```js\n  connection.addInstanceReference(todo5);\n  connection.instanceStore.get(\"5\") //-> todo5\n  ```\n\t "
      }
    ],
    "title": "instanceStore"
  },
  "can-connect/constructor/store/store.listStore": {
    "name": "can-connect/constructor/store/store.listStore",
    "type": "property",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 130,
      "codeLine": 146,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "A store of lists mapped by [can-connect/base/base.listSet].\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "\n\n  Stores lists by their [can-connect/base/base.listSet] which have had\n  [can-connect/constructor/store/store.addListReference] called more\n  times than [can-connect/constructor/store/store.deleteListReference].\n\n  ```js\n  connection.addInstanceReference(allTodos,{});\n  connection.instanceStore.get({}) //-> allTodos\n  ```\n\t "
      }
    ],
    "title": "listStore"
  },
  "can-connect/constructor/store/store.addInstanceReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.addInstanceReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 163,
      "codeLine": 227,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe [can-connect/constructor/store/store.instanceStore] contains a collection of instances\ncreated for each [can-connect/base/base.id]. The `instanceStore` is used to prevent creating the\nsame instance multiple times.  Instances need to be added to this store for this behavior\nto happen.  To do this, call `addInstanceReference` like the following:\n\n```\n// A basic connection:\nvar todoConnection = connect([\n  require(\"can-connect/constructor/store/store\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"/todos\"\n});\n\nvar originalTodo;\n\n// Get a todo:\ntodoConnection.get({id: 5}).then(function( todo ){\n\n  // Add it to the store\n  todoConnection.addInstanceReference(todo);\n  originalTodo = todo;\n});\n```\n\nNow, if you were to retrieve the same data sometime later,\nit would be the same instance.\n\n```\ntodoConnection.get({id: 5}).then(function( todo ){\n\n  todo === originalTodo //-> true\n});\n```\n\nThe `.getData`  response data is passed with `originalTodo` to [can-connect/constructor/constructor.updatedInstance]\nwhich can update the `originalTodo` with the new data.\n\n\nAll these instances stay in memory.  Use [can-connect/constructor/store/store.deleteInstanceReference]\nto remove them.\n\nTypically, `addInstanceReference` is called when something expresses interest in the interest, such\nas an event binding, and `deleteInstanceReference` is called when interest is removed.\n\n\t \n",
    "description": "\nAdds a reference to an instance so it can be easily looked up.\n",
    "title": "addInstanceReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Adds a reference to an instance in the [can-connect/constructor/store/store.instanceStore] by [can-connect/base/base.id].\n  The number of references are incremented.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to add.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to add.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.deleteInstanceReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.deleteInstanceReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 247,
      "codeLine": 278,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\n`deleteInstanceReference` is called to remove references to instances in\nthe [can-connect/constructor/store/store.instanceStore] so the instances maybe garbage\ncollected.  It's usually called when the application or some part of the application no\nlonger is interested in an instance.\n\n[can-connect/constructor/store/store.addInstanceReference] has an example of adding\nan instance to the store.  The following continues that example to remove\nthe `originalTodo` from the store:\n\n```\ntodoConnection.deleteInstanceReference(originalTodo);\n```\n\n\t \n",
    "description": "\nRemoves a reference to an instance by [can-connect/base/base.id] so it can be garbage collected.\n",
    "title": "deleteInstanceReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Decrements the number of references to an instance in the [can-connect/constructor/store/store.instanceStore].\n  Removes the instance if there are no longer any references.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to remove.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to remove.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.addListReference": {
    "type": "property",
    "name": "can-connect/constructor/store/store.addListReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 281,
      "codeLine": 346,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe [can-connect/constructor/store/store.listStore] contains a collection of lists\ncreated for each [can-connect/base/base.listSet]. The `listStore` is used to prevent creating the\nsame list multiple times and for identifying a list for a given set. Lists need to be added to this store for this behavior\nto happen.  To do this, call `addListReference` like the following:\n\n```\n// A basic connection:\nvar todoConnection = connect([\n  require(\"can-connect/constructor/store/store\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"/todos\"\n});\n\nvar dueToday;\n\n// Get a todo:\ntodoConnection.getList({due: \"today\"}).then(function( todos ){\n\n  // Add it to the store\n  todoConnection.addListReference(todos, {due: \"today\"});\n  dueToday = todos;\n});\n```\n\nNow, if you were to retrieve the same data sometime later,\nit would be the same list.\n\n```\ntodoConnection.get({due: \"today\"}).then(function( todos ){\n\n  todos === dueToday //-> true\n});\n```\n\nThe `.getListData`  response data is passed with `dueToday` to [can-connect/constructor/constructor.updatedList]\nwhich can update `dueToday` with the new data.\n\nAll these lists stay in memory.  Use [can-connect/constructor/store/store.deleteListReference]\nto remove them.\n\nTypically, `addListReference` is called when something expresses interest in the list, such\nas an event binding, and `deleteListReference` is called when interest is removed.\n\n\t \n",
    "description": "\nAdds a reference to a list so it can be easily looked up.\n",
    "types": [
      {
        "type": "WeakReferenceMap"
      }
    ],
    "title": "addListReference",
    "signatures": [
      {
        "code": "connection.addListReference( list[, set] )",
        "description": "\n\n  Adds a reference to a list in the [can-connect/constructor/store/store.listStore].  The number of\n  references are incremented.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The list to add.\n"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "optional": true,
            "name": "set",
            "description": "The set this list represents if it can't be identified with [can-connect/base/base.listSet].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "optional": true,
      "name": "set",
      "description": "The set this list represents if it can't be identified with [can-connect/base/base.listSet].\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.deleteListReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.deleteListReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 352,
      "codeLine": 383,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\n`deleteListReference` is called to remove references to lists in\nthe [can-connect/constructor/store/store.listStore] so the lists maybe garbage\ncollected.  It's usually called when the application or some part of the application no\nlonger is interested in an list.\n\n[can-connect/constructor/store/store.addListReference] has an example of adding\na list to the store.  The following continues that example to remove\nthe `dueToday` from the store:\n\n```\ntodoConnection.deleteListReference(dueToday);\n```\n\n\t \n",
    "description": "\nRemoves a reference to a list by [can-connect/base/base.listSet] so it can be garbage collected.\n",
    "title": "deleteListReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Decrements the number of references to an list in the [can-connect/constructor/store/store.listStore].\n  Removes the list if there are no longer any references.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "list",
            "description": "The list to remove.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "list",
      "description": "The list to remove.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.hydratedInstance": {
    "src": {
      "line": 389,
      "codeLine": 402,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nCalled when [can-connect/constructor/store/store.hydrateInstance] is called and a new instance is created.\n",
    "title": "hydratedInstance",
    "name": "can-connect/constructor/store/store.hydratedInstance",
    "parent": "can-connect/constructor/store/store.hydrators",
    "signatures": [
      {
        "code": "hydratedInstance(instance)",
        "description": "\n\n  If there are pending requests, the instance is kept in the [can-connect/constructor/store/store.instanceStore].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The hydrated instance.\n\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The hydrated instance.\n\n\t "
    }
  },
  "can-connect/constructor/store/store.hydrateInstance": {
    "src": {
      "line": 413,
      "codeLine": 429,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns a instance given raw data.\n",
    "title": "hydrateInstance",
    "name": "can-connect/constructor/store/store.hydrateInstance",
    "parent": "can-connect/constructor/store/store.hydrators",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  Overwrites the base `hydratedInstance` so that if a matching instance is\n  in the [can-connect/constructor/store/store.instanceStore], that instance will\n  be [can-connect/constructor/constructor.updatedInstance updated] with `props` and returned.\n  If there isn't a matching instance, the base `hydrateInstance` will be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The raw data used to create an instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Instance"
            }
          ],
          "description": "A typed instance created or updated from `props`.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The raw data used to create an instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "description": "A typed instance created or updated from `props`.\n\t "
    }
  },
  "can-connect/constructor/store/store.hydratedList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.hydratedList",
    "parent": "can-connect/constructor/store/store.hydrators",
    "src": {
      "line": 442,
      "codeLine": 456,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nCalled whenever [can-connect/constructor/store/store.hydrateList] is called with the hydration result.\n",
    "title": "hydratedList",
    "signatures": [
      {
        "code": "hydratedList(list)",
        "description": "\n\n  If there are pending requests, the list is kept in the [can-connect/constructor/store/store.listStore].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The hydrated list.\n\n\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "The hydrated list.\n\n\n\t "
    }
  },
  "can-connect/constructor/store/store.hydrateList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.hydrateList",
    "parent": "can-connect/constructor/store/store.hydrators",
    "src": {
      "line": 469,
      "codeLine": 486,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nReturns a list given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList( listData, set )",
        "description": "\n\n  Overwrites the base `hydrateList` so that if a matching list is\n  in the [can-connect/constructor/store/store.listStore], that list will\n  be [can-connect/constructor/constructor.updatedList updated] with `listData` and returned.\n  If there isn't a matching list, the base `hydrateList` will be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "List data to hyrate into a list type."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set that represents the data in `listData`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "List"
            }
          ],
          "description": "A list from either the store or a newly created instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set that represents the data in `listData`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "List"
        }
      ],
      "description": "A list from either the store or a newly created instance.\n\t "
    }
  },
  "can-connect/constructor/store/store.getList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.getList",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 499,
      "codeLine": 516,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.getList] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] or [can-connect/constructor/store/store.hydrateList hydrated lists]\nare kept in the store until the response resolves.\n",
    "title": "getList",
    "signatures": [
      {
        "code": "connection.getList( set )",
        "description": "\n\n  Increments the request counter so these instances will be stored\n  and then decrements it after the request is complete.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "Params used to specify which list to retrieve."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.getList].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "Params used to specify which list to retrieve."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.getList].\n\t "
    }
  },
  "can-connect/constructor/store/store.get": {
    "type": "function",
    "name": "can-connect/constructor/store/store.get",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 528,
      "codeLine": 545,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.get] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "get",
    "signatures": [
      {
        "code": "connection.get( params )",
        "description": "\n\n  Increments the request counter so this instance will be stored\n  and then decrements it after the request is complete.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "Params used to specify which instance to retrieve."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.get].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "Params used to specify which instance to retrieve."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.get].\n\t "
    }
  },
  "can-connect/constructor/store/store.save": {
    "type": "function",
    "name": "can-connect/constructor/store/store.save",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 558,
      "codeLine": 582,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.save] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "save",
    "signatures": [
      {
        "code": "connection.save( instance )",
        "description": "\n\n  Increments the request counter so this instance will be stored\n  and then decrements it after the request is complete.\n\n  ```\n  var promise = connection.save(todo5);\n  connection.instanceStore.get(\"5\") //-> todo5\n  promise.then(function(){\n    connection.instanceStore.has(\"5\") //-> false\n  })\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "An typed instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.save].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "An typed instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.save].\n\t "
    }
  },
  "can-connect/constructor/store/store.destroy": {
    "type": "function",
    "name": "can-connect/constructor/store/store.destroy",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 603,
      "codeLine": 627,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.destroy] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "destroy",
    "signatures": [
      {
        "code": "connection.destroy( instance )",
        "description": "\n\n  Increments the request counter so this instance will be stored\n  and then decrements it after the request is complete.\n\n  ```\n  var promise = connection.destroy(todo5);\n  connection.instanceStore.get(\"5\") //-> todo5\n  promise.then(function(){\n    connection.instanceStore.has(\"5\") //-> false\n  })\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "An typed instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.destroy].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "An typed instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.destroy].\n\t "
    }
  },
  "can-connect/Instance": {
    "src": {
      "path": "node_modules/can-connect/docs/types/instance.md"
    },
    "body": "",
    "description": "An instance of some JavaScript type. \n",
    "type": "typedef",
    "title": "Instance",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-connect/Instance",
    "parent": "can-connect.types"
  },
  "can-connect.listData": {
    "src": {
      "path": "node_modules/can-connect/docs/types/listData.md"
    },
    "body": "\n\n## Use\n\n[can-connect/connection.getListData] should return a promise that resolves\nan object that looks like:\n\n```\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ]\n}\n```\n\nThe object must have a `data` property that is an Array of \ninstanceData.\n\nThe object can have other meta information related to the data\nthat has been loaded.  For example, `count` might be the total\nnumber of items the server has:\n\n```\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ],\n  count: 1000\n}\n```\n",
    "description": "\nThe data resolved by [can-connect/connection.getListData].\n",
    "type": "typedef",
    "title": "ListData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "data",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "Foo\n"
          }
        ]
      }
    ],
    "name": "can-connect.listData",
    "parent": "can-connect.types",
    "comment": " "
  },
  "can-connect.List": {
    "src": {
      "path": "node_modules/can-connect/docs/types/list.md"
    },
    "body": "",
    "description": "A list type. \n",
    "type": "typedef",
    "title": "List",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-connect.List",
    "parent": "can-connect.types"
  },
  "can-connect/connection.clear": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/clear.md"
    },
    "body": "",
    "description": "Deletes all records on a connection. \n",
    "type": "typedef",
    "title": "clear",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Returns a promise that resolves when all data is cleared.\n"
        },
        "params": [],
        "description": "\n\nDeletes all records on a connection.\n"
      }
    ],
    "name": "can-connect/connection.clear",
    "parent": "can-connect/DataInterface",
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Returns a promise that resolves when all data is cleared.\n"
    }
  },
  "can-connect/DataInterface": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/data_interface.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "DataInterface",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-connect/DataInterface",
    "parent": "can-connect.types",
    "signatures": [
      {
        "code": "DataInterface",
        "description": "\n",
        "params": []
      }
    ]
  },
  "can-connect/connection.destroyData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/destroyData.md"
    },
    "body": "",
    "description": "Destroys an instance given the serialized form of the instance. \n",
    "type": "typedef",
    "title": "destroyData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves with any properties that should be added to the instance.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          }
        ],
        "description": "\n\nDestroys an instance given the seralized form of the data.  Returns any additional properties that should be added to the instance.\n"
      }
    ],
    "name": "can-connect/connection.destroyData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves with any properties that should be added to the instance.\n"
    }
  },
  "can-connect/connection.createData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/createData.md"
    },
    "body": "",
    "description": "Creates instance data given the serialized form of the instance. \n",
    "type": "typedef",
    "title": "createData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise with the data that will be passed to [connection.createdData].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "cid",
            "description": "A unique id that represents the instance that is being created.\n"
          }
        ],
        "description": "\n\nCreates instance data given the serialized form of the data. Returns any additional properties that should be added to the\ninstance. A client ID is passed of the instance that is being created.\n"
      }
    ],
    "name": "can-connect/connection.createData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "cid",
      "description": "A unique id that represents the instance that is being created.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise with the data that will be passed to [connection.createdData].\n"
    }
  },
  "can-connect/connection.getData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getData.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/url/url] make it easy to implement `getData`, but it can be as simple as:\n\n```\nvar connection = connect([],{\n  getData: function(params){\n    return new Promise(function(resolve, reject){\n\t\t$.get(\"/api/todo\",params).then(resolve, reject)\n\t});\n  }\n})\n```\n\n",
    "description": "Retrieves instance data for particular parameters. \n",
    "type": "typedef",
    "title": "getData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the [can-connect.listData] format.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to the instance data for particular parameters.\n"
      }
    ],
    "name": "can-connect/connection.getData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the [can-connect.listData] format.\n"
    },
    "comment": " "
  },
  "can-connect/connection.getListData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getListData.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/url/url] make it easy to implement `getListData`, but it can be as simple as:\n\n```\nvar connection = connect([],{\n  getListData: function(set){\n    return new Promise(function(resolve, reject){\n\t\t$.get(\"/api/todos\",set).then(resolve, reject)\n\t});\n  }\n})\n```\n\n",
    "description": "Retrieves list data for a particular set. \n",
    "type": "typedef",
    "title": "getListData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the [can-connect.listData] format.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to the list data for a particular set.\n"
      }
    ],
    "name": "can-connect/connection.getListData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the [can-connect.listData] format.\n"
    },
    "comment": " "
  },
  "can-connect/connection.updateData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/updateData.md"
    },
    "body": "",
    "description": "Updates an instance's data. \n",
    "type": "typedef",
    "title": "updateData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "props"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves with any properties that should be added to the instance.\nThis should include the [can-connect/base/base.idProp] of the instance.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The serialized instance data.\n"
          }
        ],
        "description": "\n\n  Updates instance data given the serialized form of the data. Returns any\n  additional properties that should be added to the instance.\n"
      }
    ],
    "name": "can-connect/connection.updateData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The serialized instance data.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "props"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves with any properties that should be added to the instance.\nThis should include the [can-connect/base/base.idProp] of the instance.\n"
    }
  },
  "can-connect/connection.getSets": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getSets.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/localstorage-cache/localstorage-cache] implement\n`.getSets` to provide the sets they contain.\n\n",
    "description": "Gets the sets that are available in the connection. \n",
    "type": "typedef",
    "title": "getSets",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "can-set/Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to an an array of sets.\n"
        },
        "params": [],
        "description": "\n\n  Returns a promise that resolves to a list of [can-set/Set] objects contained in the connection.\n"
      }
    ],
    "name": "can-connect/connection.getSets",
    "parent": "can-connect/DataInterface",
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can-set/Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to an an array of sets.\n"
    },
    "comment": " "
  },
  "connection.algebra": {
    "src": {
      "path": "node_modules/can-connect/docs/options/algebra.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Algebra"
      }
    ],
    "title": "algebra",
    "name": "connection.algebra",
    "type": "property",
    "parent": "can-connect.options"
  },
  "can-connect/connection.updateListData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/updateListData.md"
    },
    "body": "\n",
    "description": "Updates list data for a particular set. \n",
    "type": "typedef",
    "title": "updateListData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the updated [can-connect.listData].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "A object that represents the set of data needed to be loaded.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "set",
            "description": "The set of data that is updating.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to the list data for a particular set.\n"
      }
    ],
    "name": "can-connect/connection.updateListData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "set",
      "description": "The set of data that is updating.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the updated [can-connect.listData].\n"
    },
    "comment": " "
  },
  "connection.cacheConnection": {
    "src": {
      "path": "node_modules/can-connect/docs/options/cacheConnection.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "connection"
      }
    ],
    "title": "cacheConnection",
    "name": "connection.cacheConnection",
    "type": "property",
    "parent": "can-connect.options"
  },
  "connection.id": {
    "src": {
      "path": "node_modules/can-connect/docs/options/id.md"
    },
    "body": "",
    "description": "",
    "title": "id",
    "name": "connection.id",
    "type": "function",
    "parent": "can-connect.options"
  },
  "connection.instance": {
    "src": {
      "path": "node_modules/can-connect/docs/options/instance.md"
    },
    "body": "",
    "description": "",
    "title": "instance",
    "name": "connection.instance",
    "type": "function",
    "parent": "can-connect.options"
  },
  "connection.idProp": {
    "src": {
      "path": "node_modules/can-connect/docs/options/idProp.md"
    },
    "body": "",
    "description": "",
    "title": "idProp",
    "name": "connection.idProp",
    "type": "property",
    "parent": "can-connect.options"
  },
  "connection.listSet": {
    "src": {
      "path": "node_modules/can-connect/docs/options/listSet.md"
    },
    "body": "",
    "description": "",
    "title": "listSet",
    "name": "connection.listSet",
    "type": "function",
    "parent": "can-connect.options"
  },
  "connection.list": {
    "src": {
      "path": "node_modules/can-connect/docs/options/list.md"
    },
    "body": "",
    "description": "\n",
    "title": "list",
    "name": "connection.list",
    "type": "function",
    "parent": "can-connect.options",
    "signatures": [
      {
        "code": "connection.list( instancesData, set )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": [
                  {
                    "name": "data",
                    "types": [
                      {
                        "type": "Array",
                        "template": [
                          {
                            "types": [
                              {
                                "type": "Object",
                                "options": []
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "instancesData",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "data",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "name": "instancesData",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "\n"
    }
  },
  "can-fixture/StoreType.prototype.destroyData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.destroyData.md"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-fixture/StoreType.prototype.destroyData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.destroyData(request, response)",
        "description": "\n\nA `requestHandler` that removes an item from the store.\n\n```js\nfixture(\"DELETE /api/todos/{_id}\", todoStore.destroyData)\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.createData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.createData.md"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-fixture/StoreType.prototype.createData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.createData(request, response)",
        "description": "\n\nA `requestHandler` that creates an item in the store.\n\n```js\nfixture(\"POST /api/todos\", todoStore.createData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.getData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getData.md"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-fixture/StoreType.prototype.getData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getData(request, response)",
        "description": "\n\nA `requestHandler` that gets a single item from the store.\n\n```js\nfixture(\"GET /api/todos/{_id}\", todoStore.getData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.get": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.get.md"
    },
    "body": "",
    "description": "\n",
    "title": "get",
    "name": "can-fixture/StoreType.prototype.get",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.get(params)",
        "description": "\n\nReturns a single item's data from the store.\n\n```js\ntodoStore.get({id: 1}) //-> {id: 1, name: \"dishes\"}\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.getList": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getList.md"
    },
    "body": "",
    "description": "\n",
    "title": "getList",
    "name": "can-fixture/StoreType.prototype.getList",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getList(set)",
        "description": "\n\nReturns the matching items from the store like: `{data: [...]}`.\n\n```js\ntodoStore.get({name: \"dishes\"}) //-> {data: [{id: 1, name: \"dishes\"}]}\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.reset": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.reset.md"
    },
    "body": "",
    "description": "\n",
    "title": "reset",
    "name": "can-fixture/StoreType.prototype.reset",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.reset([baseItems])",
        "description": "\n\nSets the items in the store to their original state or to `baseItems` if it's passed as an argument.\n\n```js\n// Creates a store with one item.\nvar todoStore = fixture.store(\n    [{id: 1, name: \"dishes\"}],\n    new set.Algebra());\nfixture(\"/todos/{id}\", todoStore)\ntodoStore.getList({}).length //-> 1\n\n// delete that item\n$.ajax({url: \"todos/1\", method: \"delete\"}).then(function(){\n    return todoStore.getList({}).length //-> 0\n}).then(function(){\n    // calling reset adds it back\n    todoStore.reset();\n    todoStore.getList({}).length //-> 1\n});\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "baseItems",
            "description": "If provided, adds these items to the store.  \nThis can be useful for setting up particular testing scenarios.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "baseItems",
      "description": "If provided, adds these items to the store.  \nThis can be useful for setting up particular testing scenarios.\n"
    }
  },
  "can-fixture/StoreType.prototype.getListData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getListData.md"
    },
    "body": "",
    "description": "\n",
    "title": "getListData",
    "name": "can-fixture/StoreType.prototype.getListData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getListData(request, response)",
        "description": "\n\nA `requestHandler` that gets multiple items from the store.\n\n```js\nfixture(\"GET /api/todos\", todoStore.getListData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.updateData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.updateData.md"
    },
    "body": "",
    "description": "\n",
    "title": "updateData",
    "name": "can-fixture/StoreType.prototype.updateData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.updateData(request, response)",
        "description": "\n\nA `requestHandler` that updates an item in the store.\n\n```js\nfixture(\"PUT /api/todos/{_id}\", todoStore.updateData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype": {
    "name": "can-fixture/StoreType.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-fixture/StoreType",
    "description": "",
    "order": 0
  },
  "can-fixture/StoreType": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/StoreType.md"
    },
    "body": "",
    "description": "\n",
    "title": "Store",
    "name": "can-fixture/StoreType",
    "type": "function",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "Store",
        "description": "\n\nThe following documents the methods on a store object returned by [can-fixture.store].\n",
        "params": []
      }
    ]
  },
  "can-fixture/types/ajaxSettings": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/ajaxSettings.md"
    },
    "body": "\n",
    "description": "\nAn object used to match incoming [can-fixture/types/request] objects.\n",
    "type": "typedef",
    "title": "ajaxSettings",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "url",
            "description": "The requested url with anything after the querystring taken off in `GET` and `DESTROY` method requests.  For example, you can't match:\n\n```\nfixture({method: \"GET\", url: \"/things?name=Justin\"});\n```\n\nInstead write:\n\n```\nfixture({method: \"GET\", url: \"/things\", data: {name: \"Justin\"}});\n```\n\nThe `url` can have templates like:\n\n```\nfixture({method: \"GET\", url: \"/things/{id}\"})\n```\n\nThe templated values get added to the [can-fixture/types/request] object's `data`.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "method",
            "description": "The method of the request. Ex: `GET`, `PUT`, `POST`, etc. Capitalization is ignored.",
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true
          },
          {
            "name": "data",
            "description": "Match the data of the request. The data of the querystring or the data to `XMLHTTPRequest.prototype.send` is converted to a JavaScript objects with either `JSON.stringify` or [can-util/js/deparam/deparam].  The data must match part of the `request`'s data.",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true
          },
          {
            "name": "async",
            "description": "Write `true` to match asynchronous requests only.  \n",
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true
          }
        ],
        "description": "\n\nThis object is used to match values on [can-fixture/types/request] objects.\nIf there's a match, the fixture handler provided with the\n[can-fixture/types/ajaxSettings] will be invoked.\n\nIf a property on an `ajaxSettings` is not provided, all request values\nwill be matched for that property.\n\nFor example,\nyou can match all `GET` requests, no matter what `url` is passed like:\n\n```\nfixture({method: \"GET\"}, function(){ ... });\n```\n\n"
      }
    ],
    "name": "can-fixture/types/ajaxSettings",
    "parent": "can-fixture.types"
  },
  "can-fixture/types/request": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/request.md"
    },
    "body": "\n",
    "description": "\nAn object with easily digestible values derived from the mock XHR\nobject.  \n",
    "type": "typedef",
    "title": "request",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "url",
            "description": "The requested url with anything after the querystring taken off in `GET` and `DESTROY` method requests.",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "method",
            "description": "The method of the request. Ex: `GET`, `PUT`, `POST`, etc.",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "data",
            "description": "The data of the querystring or the data to `XMLHTTPRequest.prototype.send` converted back to JavaScript objects with either `JSON.stringify` or [can-util/js/deparam/deparam].",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "headers",
            "description": "Headers added to the XHR object with `XMLHTTPRequest.prototype.setRequestHeader`.",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "async",
            "description": "`true` if the request was a synchronous request.",
            "types": [
              {
                "type": "Boolean"
              }
            ]
          },
          {
            "name": "xhr",
            "description": "The mock xhr request.\n",
            "types": [
              {
                "type": "XMLHTTPRequest"
              }
            ]
          }
        ],
        "description": "\n\nThis object is passed to a [can-fixture.requestHandler]\nand can be used to determine the response.\n\n```js\nfixture(\"GET /todos/{id}\", function(request, response){\n    request.url     //-> \"todos/5\"\n    request.method  //-> \"get\"\n    request.data    //-> {id: \"5\", include: [\"owner\"]}\n    request.headers //-> {}\n    request.async   //-> false\n});\n\n$.get(\"/todos/5?include[]=owner\");\n```\n"
      }
    ],
    "name": "can-fixture/types/request",
    "parent": "can-fixture.types"
  },
  "can-fixture.requestHandler": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/requestHandler.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "requestHandler",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/request"
              }
            ],
            "name": "request"
          },
          {
            "types": [
              {
                "type": "can-fixture.response"
              }
            ],
            "name": "response"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "requestHeaders"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "ajaxSettings"
          }
        ]
      }
    ],
    "name": "can-fixture.requestHandler",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "requestHandler(request, response(...), requestHeaders, ajaxSettings)",
        "description": "\n\nDefines the XHR response for a given trapped request.\n\n```js\nfixture({method: \"get\", url: \"/todos\"},\n  function(request, response, headers, ajaxSettings){\n    request //-> {\n            //    method: \"get\",\n            //    url: \"/todos\",\n            //    data: {complete: true}\n            //   }\n\n  }\n});\n\n$.ajax({ method: \"get\", url: \"/todos?complete=true\" })\n```\n\nTemplated `url` data will be added to the `requestHandler`'s `request` argument's `data` property:\n\n```js\nfixture({url: \"/todos/{action}\"},\n  function(request, response, headers, ajaxSettings){\n    request //-> {\n            //    method: \"post\",\n            //    url: \"/todos\",\n            //    data: {action: delete}\n            //   }\n  }\n});\n\n$.post(\"/todos/delete\");\n```",
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/request"
              }
            ],
            "name": "request",
            "description": "Information about the request. The request's data property will contain data from the request's querystring or request body. Also\nany templated values in the [can-fixture/types/ajaxSettings]'s `url` will be added. "
          },
          {
            "types": [
              {
                "type": "can-fixture.response"
              }
            ],
            "name": "response",
            "description": "A callback function that provides response information."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "requestHeaders",
            "description": "Headers used to make the request."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "ajaxSettings",
            "description": "The settings object used to match this request.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "ajaxSettings",
      "description": "The settings object used to match this request.\n"
    }
  },
  "can-fixture.response": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/response.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "response",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-fixture.response",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "response(status, body, headers, statusText)",
        "description": "\n\nUsed to detail a response.\n\nExample:\n\n```js\nfixture({url: \"/todos/{action}\"},\n  function(request, response, headers, ajaxSettings){\n    response(\n        401,\n        { message: \"Unauthorized\"},\n        { \"WWW-Authenticate\": 'Basic realm=\"myRealm\"'},\n        \"unauthorized\");\n  }\n});\n\n$.post(\"/todos/delete\");\n```\n\nYou don't have to provide every argument to `response`. It can be called like:\n\n```js\n// Just body\nresponse({ message: \"Hello World\"});\n// status and body\nresponse(401, { message: \"Unauthorized\"});\n// body and headers\nresponse('{\"message\":\"Unauthorized\"}',{\"WWW-Authenticate\":'Basic realm=\"myRealm\"'});\n// status, body statusText\nresponse(401, '{\"message\":\"Unauthorized\"}','unauthorized');\n```\n\nThe default `statusText` will be `ok` for `200 <= status < 300, status === 304` and `error`\nfor everything else.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "status",
            "description": "The [HTTP response code](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html). Ex: `200`."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "body",
            "description": "A JS object that will be serialized and set as the responseText of the XHR object, or\nthe raw string text that will be set as the responseText of the XHR object."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "headers",
            "description": "An object of HTTP response headers and values."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "statusText",
            "description": "The status text of the response. Ex: ``\"ok\"`` for 200.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "statusText",
      "description": "The status text of the response. Ex: ``\"ok\"`` for 200.\n"
    }
  },
  "can-define/map/map.prototype.forEach": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.forEach.md"
    },
    "body": "\n## Use\n\nExample\n\n```\nvar names = [];\nnew DefineMap({a: 'Alice', b: 'Bob', e: 'Eve'}).forEach(function(value, key) {\n    names.push(value);\n});\n\nnames; // ['Alice', 'Bob', 'Eve']\n\nnames = [];\nnew DefineMap({a: 'Alice', b: 'Bob', e: 'Eve'}).forEach(function(value, key) {\n    names.push(value);\n    if(key === 'b') {\n        return false;\n    }\n});\n\nnames; // ['Alice', 'Bob']\n```\n\n",
    "description": "Call a function on each property of a DefineMap. \n",
    "title": "forEach",
    "name": "can-define/map/map.prototype.forEach",
    "type": "function",
    "parent": "can-define/map/map.prototype",
    "signatures": [
      {
        "code": "map.forEach( callback(value, propName ) )",
        "description": "\n\n`forEach` iterates through the map instance, calling a function\nfor each property value and key.\n\n```js\nmap.forEach(function(value, propName){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "value"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "propName"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "The function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns `false`,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "value"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "propName"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "The function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns `false`,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "The map instance for chaining.\n"
    },
    "comment": " "
  },
  "can-define/map/map.prototype": {
    "name": "can-define/map/map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map.static": {
    "name": "can-define/map/map.static",
    "title": "static",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map/events": {
    "name": "can-define/map/map/events",
    "title": "events",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map": {
    "src": {
      "path": "node_modules/can-define/map/docs/define-map.md"
    },
    "body": "",
    "description": "Create observable objects. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define/map/map",
    "parent": "can-core",
    "alias": "can.DefineMap",
    "inherits": "can.Construct",
    "signatures": [
      {
        "code": "new DefineMap([props])",
        "description": "\n\nCreates a new instance of DefineMap or an extended DefineMap. Then, assigns every property on `props` to the new instance.  If props are passed that are not defined already, those property definitions are created.  If the instance should be sealed, it is sealed.\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar person = new DefineMap({\n  first: \"Justin\",\n  last: \"Meyer\"\n})\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the map with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "An instance of `can.DefineMap` with the properties from _props_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "props",
      "description": "Properties and values to seed the map with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "An instance of `can.DefineMap` with the properties from _props_.\n"
    }
  },
  "can-define/map/map/KeysEvent": {
    "src": {
      "path": "node_modules/can-define/map/docs/events.keys.md"
    },
    "body": "\n",
    "description": "\nEvent fired when a property is added.\n",
    "type": "typedef",
    "title": "__keys",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/map/map/KeysEvent",
    "parent": "can-define/map/map/events",
    "signatures": [
      {
        "code": "handler(event)",
        "description": "\n\nHandlers registered on `__keys` events will be called\nback as follows.\n\n```\nvar person = new DefineMap({name: \"Justin\"});\nlist.on(\"__keys\", function(event){ ... });\nperson.set(\"age\", 33);\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Event"
        }
      ],
      "name": "event",
      "description": "An event object.\n"
    }
  },
  "can-define/map/map/PropertyNameEvent": {
    "src": {
      "path": "node_modules/can-define/map/docs/events.propertyName.md"
    },
    "body": "\n",
    "description": "\nEvent fired when a property on the map changes values.\n",
    "type": "typedef",
    "title": "propertyName",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/map/map/PropertyNameEvent",
    "parent": "can-define/map/map/events",
    "signatures": [
      {
        "code": "handler(event, newValue, oldValue)",
        "description": "\n\nHandlers registered on `propertyName` events will be called\nback as follows.\n\n```\nvar person = new DefineMap({name: \"Justin\"});\nlist.on(\"name\", function(event, newVal, oldVal){\n  newVal //-> \"Brian\"\n  oldVal //-> \"Justin\"\n});\nperson.name = \"Brian\";\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newVal",
            "description": "The new value of the `propertyName` property."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "oldVal",
            "description": "The old value of the `propertyName` property.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "oldVal",
      "description": "The old value of the `propertyName` property.\n"
    }
  },
  "can-define/map/map.prototype.on": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.on.md"
    },
    "body": "\n## Use\n\n`on` binds event handlers to property changes on `DefineMap`s. When you change\na property value, a _property name_ event is fired, allowing other parts\nof your application to map the changes to the object.\n\nThis event is useful for noticing changes to a specific property.\n\n\n    var o = new DefineMap({name: \"Justin\"});\n    o.on('name', function(ev, newVal, oldVal) {\n        console.log('The value of a changed.');\n    });\n\n\nThe parameters of the event handler for the _property name_ event are:\n\n- _ev_ The event object.\n- _newVal_ The value of the property after the change. `\n- _oldVal_ The value of the property before the change.\n\nHere is a concrete tour through the _property name_ event handler's arguments:\n\n\n    var o = new DefineMap({a: undefined, b: undefined});\n    o.on('a', function(ev, newVal, oldVal) {\n        console.log(newVal + ', ' + oldVal);\n    });\n\n    o.a = 'Alexis';       // Alexis, undefined\n    o.set('a', 'Adam');   // Adam, Alexis\n    o.set({\n        'a': 'Alice',     // Alice, Adam\n        'b': 'Bob'\n    });\n    o.a = undefined;      // undefined, Alice\n\n",
    "description": "Add event handlers to a map. \n",
    "title": "on",
    "name": "can-define/map/map.prototype.on",
    "type": "function",
    "parent": "can-define/map/map.prototype",
    "signatures": [
      {
        "code": "map.on(eventType, handler)",
        "description": "\n\nListens to `eventType` on `map` and calls `handler` when the event is dispatched.  This is simply\na reference to [can-event.on can-event.on] as all of [can-event] methods are available on `DefineMap`.\n\n```js\nvar map = new DefineMap({name: \"Justin\"})\nmap.on(\"name\", function(ev, newVal, oldVal){\n    newVal //-> \"Brian\"\n    oldVal //-> \"Justin\"\n});\nmap.name = \"Brian\";\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of event to bind this handler to.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event"
                  },
                  {
                    "variable": true,
                    "name": "args"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "This map, for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Event"
                }
              ],
              "name": "event"
            },
            {
              "variable": true,
              "name": "args"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "This map, for chaining.\n"
    },
    "comment": " "
  },
  "can-define/map/map.extend": {
    "src": {
      "path": "node_modules/can-define/map/docs/static.extend.md"
    },
    "body": "",
    "description": "Define a custom map type. \n",
    "title": "extend",
    "name": "can-define/map/map.extend",
    "type": "function",
    "parent": "can-define/map/map.static",
    "signatures": [
      {
        "code": "DefineMap.extend([name,] [static,] prototype)",
        "description": "\n\nExtends can.DefineMap, or constructor functions derived from can.DefineMap,\nto create a new constructor function.\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Person = DefineMap.extend(\n  \"Person\",\n  {seal: true},\n  {\n    first: \"string\",\n    last: {type: \"string\"},\n    fullName: {\n      get: function(){\n        return this.first+\" \"+this.last;\n      }\n    },\n    age: {value: 0},\n  });\n\nvar me = new Person({first: \"Justin\", last: \"Meyer\"})\nme.fullName //-> \"Justin Meyer\"\nme.age      //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Provides an optional name for this type that will\nshow up nicely in debuggers.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "static",
            "description": "Static properties that are set directly on the\nconstructor function.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      },
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "prototype",
            "description": "A definition of the properties or methods on this type.\n\nIf the property definition is a __plain function__, it's considered a method.\n\n```js\nvar Person = DefineMap.extend({\n  sayHi: function(){ console.log(\"hi\"); }\n});\n\nvar me = new Person();\nme.sayHi();\n```\n\nIf the property definition is a __string__, it's considered a `type` setting to be looked up in [can-define.types can.define.types].\n\n```js\nvar Person = DefineMap.extend({\n  age: 'number',\n  isCool: 'boolean',\n  hobbies: 'observable'\n});\n\nvar me = new Person({age: '33', isCool: 'false', hobbies: ['js','bball']});\nme.age    //-> 33\nme.isCool //-> false\nme.hobbies instanceof DefineList //-> true\n```\n\n\nIf the property definition is a Constructor function, it's considered a `Type` setting.\n\n```js\nvar Address = DefineMap.extend({\n  zip: 'number'\n});\nvar Person = DefineMap.extend({\n  address: Address\n});\n\nvar me = new Person({address: {zip: '60048'}});\nme.address.zip //-> 60048\n```\n\nIf the property is an __object__, it's considered to be a [can-define.types.propDefinition].\n\n```js\nvar Person = DefineMap.extend({\n  fullName: {\n    get: function() {\n      return this.first+\" \"+this.last;\n    },\n    set: function(newVal) {\n      var parts = newVal.split(\" \");\n      this.first = parts[0];\n      this.last = parts[1];\n    }\n  },\n  // slick way of creating an 'inline' type.\n  address: {\n    Type: {\n      zip: \"number\"\n    }\n  }\n});\n\nvar me = new Person({fullName: \"Rami Myer\", address: {zip: '60048'}});\nme.first       //-> \"Rami\"\nme.address.zip //-> 60048\n```\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "A DefineMap constructor function.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                },
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "prototype",
      "description": "A definition of the properties or methods on this type.\n\nIf the property definition is a __plain function__, it's considered a method.\n\n```js\nvar Person = DefineMap.extend({\n  sayHi: function(){ console.log(\"hi\"); }\n});\n\nvar me = new Person();\nme.sayHi();\n```\n\nIf the property definition is a __string__, it's considered a `type` setting to be looked up in [can-define.types can.define.types].\n\n```js\nvar Person = DefineMap.extend({\n  age: 'number',\n  isCool: 'boolean',\n  hobbies: 'observable'\n});\n\nvar me = new Person({age: '33', isCool: 'false', hobbies: ['js','bball']});\nme.age    //-> 33\nme.isCool //-> false\nme.hobbies instanceof DefineList //-> true\n```\n\n\nIf the property definition is a Constructor function, it's considered a `Type` setting.\n\n```js\nvar Address = DefineMap.extend({\n  zip: 'number'\n});\nvar Person = DefineMap.extend({\n  address: Address\n});\n\nvar me = new Person({address: {zip: '60048'}});\nme.address.zip //-> 60048\n```\n\nIf the property is an __object__, it's considered to be a [can-define.types.propDefinition].\n\n```js\nvar Person = DefineMap.extend({\n  fullName: {\n    get: function() {\n      return this.first+\" \"+this.last;\n    },\n    set: function(newVal) {\n      var parts = newVal.split(\" \");\n      this.first = parts[0];\n      this.last = parts[1];\n    }\n  },\n  // slick way of creating an 'inline' type.\n  address: {\n    Type: {\n      zip: \"number\"\n    }\n  }\n});\n\nvar me = new Person({fullName: \"Rami Myer\", address: {zip: '60048'}});\nme.first       //-> \"Rami\"\nme.address.zip //-> 60048\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "A DefineMap constructor function.\n"
    }
  },
  "can-define/map/map.prototype.wildcard": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.wildcard.md"
    },
    "body": "",
    "description": "Define default behavior for a Map instance. \n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\nBy defining a wildcard property like `\"*\"` on the prototype, this will supply a\ndefault behavior for every property.  The default wildcard `\"*\"` definition\nmakes every property run through the \"observable\" [can-define.types] converter.\nIt looks like:\n\n```\n\"*\": {\n  type: \"observable\"\n}\n```\n\nSetting the wildcard is useful when every property on a\nmap instance should behave in a particular way.  For example, for map types used\nwith [can-route]:\n\n```\nvar MyMap = DefineMap.extend({\n  \"*\": {\n    type: \"stringOrObservable\"\n  }\n})\n```\n\nOr if you want to turn off implicit conversion of Objects and Arrays to DefineMap and DefineLists:\n\n```\nvar MyMap = DefineMap.extend({\n  \"*\": {\n    type: \"*\"\n  }\n})\n```\n"
      }
    ],
    "title": "*",
    "name": "can-define/map/map.prototype.wildcard",
    "type": "property",
    "parent": "can-define/map/map.prototype"
  },
  "can-define/map/map.seal": {
    "src": {
      "path": "node_modules/can-define/map/docs/static.seal.md"
    },
    "body": "\n",
    "description": "Defines if instances of the map should be [sealed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal) in development. \n",
    "types": [
      {
        "type": "Boolean",
        "description": "If `true`, in development, instances of this object will be [sealed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal).  In  [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) errors will be thrown when undefined properties are set.  This is the default\nbehavior of [can-define/map/map.extend extended DefineMaps]:\n\n```js\n\"use strict\";\nvar Person = can.DefineMap.extend({});\nvar me = new Person();\nme.age = 33 //-> throws \"TypeError: Can't add property age, object is not extensible\"\n```\n\nIf `false`, the object will not be sealed.  This is the default behavior of\nunextended [can-define/map/map DefineMaps].  Use [can-define/map/map.prototype.get] and [can-define/map/map.prototype.set] to get and set values:\n\n```js\nvar person = new can.DefineMap();\nperson.set(\"first\",\"Justin\");\nperson.set(\"last\",\"Meyer\");\n\nperson.get(\"first\") //-> \"Justin\"\nperson.get(\"last\") //-> \"Meyer\"\n```\n\nSet `seal` to `false` on objects that have an indeterminate number of properties:\n\n```js\nvar Style = can.DefineMap.extend({\n  seal: false\n},{\n  cssText: {\n    get: function(){\n      return _.map(this.get(), function(val, prop){\n        return prop+\": \"+val;\n      }).join(\";\")\n    }\n  }\n});\nvar style = new Style();\nstyle.set(\"color\",\"green\");\nstyle.set(\"font\",\"awesome\");\nstyle.cssText //-> \"color:green; font: awesome;\"\n```\n"
      }
    ],
    "title": "seal",
    "name": "can-define/map/map.seal",
    "type": "property",
    "parent": "can-define/map/map.static"
  },
  "can-define/list/list/events": {
    "name": "can-define/list/list/events",
    "title": "events",
    "type": "group",
    "parent": "can-define/list/list",
    "description": "",
    "order": 0
  },
  "can-define/list/list/PropertyNameEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.propertyName.md"
    },
    "body": "\n",
    "description": "\nEvent fired when a property on the list changes values.\n",
    "type": "typedef",
    "title": "propertyName",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/PropertyNameEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, newValue, oldValue)",
        "description": "\n\nHandlers registered on `propertyName` events will be called\nback as follows.\n\n```\nlist.set(\"totalCount\", 500);\nlist.on(\"totalCount\", function(event, newVal, oldVal){\n  newVal //-> 5\n  oldVal //-> 500\n});\nlist.set(\"totalCount\", 5);\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newVal",
            "description": "The new value of the `propertyName` property."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "oldVal",
            "description": "The old value of the `propertyName` property.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "oldVal",
      "description": "The old value of the `propertyName` property.\n"
    }
  },
  "can-define/list/list/AddEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.add.md"
    },
    "body": "\n",
    "description": "\nEvent fired when items are added to the list.\n",
    "type": "typedef",
    "title": "add",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/AddEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, added, index)",
        "description": "\n\nHandlers registered with [can-event] methods on `list` will be called back when\nitems are added to a list.\n\n```\nlist.on(\"add\", function(event, added, index){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "added",
            "description": "An array of the items added to the list."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The location where the items were added.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "index",
      "description": "The location where the items were added.\n"
    }
  },
  "can-define/list/list/LengthEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.length.md"
    },
    "body": "\n",
    "description": "\nEvent fired when items are added or removed from the list.\n",
    "type": "typedef",
    "title": "length",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/LengthEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, length)",
        "description": "\n\nHandlers registered on \"length\" events will be called\nback as follows.\n\n```\nlist.on(\"length\", function(event, length){ ... });\n```\n\nIt's possible that the length was not changed, but an item was [can-define/list/list::set] on the list.\nIn this case, a `length` event will still be fired.\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "length",
            "description": "The new length of the list.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "length",
      "description": "The new length of the list.\n"
    }
  },
  "can-define/list/list/RemoveEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.remove.md"
    },
    "body": "\n",
    "description": "\nEvent fired when items are removed from the list.\n",
    "type": "typedef",
    "title": "remove",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/RemoveEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, removed, index)",
        "description": "\n\nHandlers registered with [can-event] methods on `list` will be called back when\nitems are removed to a list.\n\n```\nlist.on(\"remove\", function(event, removed, index){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "removed",
            "description": "An array of the items removed from the list."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The location where the items were removed.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "index",
      "description": "The location where the items were removed.\n"
    }
  },
  "can-define/list/list.prototype.on": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.on.md"
    },
    "body": "",
    "description": "Add event handlers to a list. \n",
    "title": "on",
    "name": "can-define/list/list.prototype.on",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "signatures": [
      {
        "code": "list.on(eventType, handler)",
        "description": "\n\nListens to `eventType` on `list` and calls `handler` when the event is dispatched.  This is simply\na reference to [can-event.on can-event.on] as all of [can-event] methods are available on `DefineMap`.\n\n```js\nvar list = new DefineList([\"CanJS\",\"StealJS\"])\nlist.on(\"add\", function(ev, added, index){ ... });\nlist.push(\"DoneJS\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of event to bind this handler to.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event"
                  },
                  {
                    "variable": true,
                    "name": "args"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Event"
                }
              ],
              "name": "event"
            },
            {
              "variable": true,
              "name": "args"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "This list, for chaining.\n"
    }
  },
  "can-define/list/list.prototype.wildcard": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.wildcard.md"
    },
    "body": "",
    "description": "Define default behavior for all properties and items in the list. Use [can-define/list/list.prototype.itemsDefinition] to define the default type of items in the list.\n\n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\nBy defining a wildcard property (`\"*\"`) on the prototype, this will supply a\ndefault behavior for every property in the list.  The default wildcard `\"*\"` definition\nmakes every property run through the \"observable\" [can-define.types] converter.\nIt looks like:\n\n```js\n\"*\": {\n  type: \"observable\"\n}\n```\n\nSetting the wildcard is useful when all properties should be converted to a particular type.\n\n```js\nvar Person = DefineList.extend({ ... });\n\nvar People = DefineList.extend({\n  \"*\": \"string\"\n  \"#\": Person\n});\n\nvar people = new People();\n\npeople.set(\"age\", 21);\npeople.age //-> \"21\"\n```\n"
      }
    ],
    "title": "*",
    "name": "can-define/list/list.prototype.wildcard",
    "type": "property",
    "parent": "can-define/list/list.prototype"
  },
  "can-define/list/list.prototype.wildcardItems": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.wildcardItems.md"
    },
    "body": "",
    "description": "Define default behavior for items in the list. \n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\nBy defining a wildcard property (`\"#\"`) on the prototype, this will supply a\ndefault behavior for items in the list.  The default wildcard (`\"#\"`) definition\nmakes every item run through the \"observable\" [can-define.types] converter.\nIt looks like:\n\n```js\n\"#\": {\n  type: \"observable\"\n}\n```\n\nSetting the wildcard is useful when items should be converted to a particular type.\n\n```js\nvar Person = DefineMap.extend({ ... });\n\nvar People = DefineList.extend({\n  \"#\": Person\n});\n```\n\nThe wildcard property has optional `added` and `removed` functions that will be called after\nan item is added or removed from the list with `this` being the list.\n\n```js\nvar People = DefineList.extend({\n  \"#\": {\n  \tadded: function(itemsAdded, index) { ... },\n  \tremoved: function(itemsRemoved, index) { ... }\n  }\n});\n```\n"
      }
    ],
    "title": "#",
    "name": "can-define/list/list.prototype.wildcardItems",
    "type": "property",
    "parent": "can-define/list/list.prototype"
  },
  "can-define/list/list.extend": {
    "src": {
      "path": "node_modules/can-define/list/docs/static.extend.md"
    },
    "body": "\n",
    "description": "Define a custom list type. \n",
    "title": "extend",
    "name": "can-define/list/list.extend",
    "type": "function",
    "parent": "can-define/list/list.static",
    "signatures": [
      {
        "code": "DefineList.extend([name,] [static,] prototype)",
        "description": "\n\nExtends DefineList, or constructor functions derived from DefineList,\nto create a new constructor function.\n\n```js\nvar DefineList = require(\"can-define/list/list\");\n\nvar TodoList = DefineList.extend(\n  \"TodoList\",\n  {\n    \"#\": {type: {complete: \"boolean\", name: \"string\"}}\n    availableCount: \"number\",\n    completedCount: {\n      get: function(){\n        return this.filter({complete: true}).length;\n      }\n    },\n    completeAll: function(){\n      this.forEach(function(todo){\n        todo.complete = true;\n      })\n    }\n  });\n\nvar todos = new TodoList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: false}\n]);\ntodos.availableCount = 100;\n\ntodos.completeAll();\ntodos.completeCount //-> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Provides an optional name for this type that will\nshow up nicely in debuggers.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "static",
            "description": "Static properties that are set directly on the\nconstructor function.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      },
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "prototype",
            "description": "A definition of the properties or methods on this type.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A DefineList constructor function.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                },
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "prototype",
      "description": "A definition of the properties or methods on this type.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A DefineList constructor function.\n\n"
    },
    "comment": " "
  },
  "can-stache/expressions/bracket": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/bracket.md"
    },
    "body": "\n## Use\n\nA bracket expression can be used to look up a dynamic property in the [can-view-scope scope]. This looks like:\n\n```\nTemplate:\n\t<h1>{{[key]}}</h1>\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tname: \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nThis can be useful for looking up values using keys containing non-alphabetic characters:\n\n```\nTemplate:\n\t<h1>{{[\"person:name\"]}}</h1>\n\nData:\n\t{\n\t\t\"person:name\": \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nBracket expressions can also be used to look up a value in the result of another expression:\n\n```\nTemplate:\n{{getPerson()[key]}}\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tgetPerson: function() {\n\t\t\treturn {\n\t\t\t\tname: \"Kevin\"\n\t\t\t};\n\t\t}\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Bracket Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/bracket",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "[key]",
        "description": "\n\nEvaluates `key` and looks up the result in the [can-view-scope scope].\n\n```\n{{[key]}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the [can-view-scope scope].\n"
          }
        ]
      },
      {
        "code": "CALL_EXPRESSION[key]",
        "description": "\n\nEvaluates `key` and looks up the result in the return value of `CALL_EXPRESSION`.\n\n```\n{{method()[key]}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A [can-stache/expressions/call Call], [can-stache/expressions/helper Helper], or [can-stache/expressions/key-lookup KeyLookup] expression that may or may not return a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the result of `CALL_EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the result of `CALL_EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache.expressions": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/expressions.md"
    },
    "body": "\n```\n{{helper key1 \"string\" method(key2, 1, prop1=key3) prop2=key4}}\n```\n\nThere are 6 expression types stache supports:\n\n - Literal expressions like `{{\"string\"}}`\n - KeyLookup expressions like `{{key}}`\n - Hash expressions like `{{prop=key}}`\n - Call expressions like `{{method(arg)}}`\n - Helper expressions like `{{helper arg}}`\n - Bracket expressions like `{{[key]}}`\n\n## Literal expressions\n\nA [can-stache/expressions/literal] specifies JS primitive values like:\n\n- Strings `\"strings\"`\n- Numbers `5`\n- Booleans `true` or `false`\n- And `null` or `undefined`\n\nThey are usually passed as arguments to Call or Helper expressions like:\n\n```\n{{pluralize \"dog\" 2}}\n{{task.filter(\"completed\", true)}}\n```\n\n## KeyLookup expressions\n\nA [can-stache/expressions/key-lookup] specifies a value in the [can-view-scope scope] or\n[can-view-scope.Options HelperOptions scope] that will be looked up. KeyLookup expressions\ncan be the entire stache expression like:\n\n```\n{{key}}\n```\n\nOr they can make up the method, helper, arguments, and hash value parts of\nCall, Helper, and Hash expressions:\n\n```\n{{method(arg1,arg2}}          Call\n{{helper arg1 arg2}}          Helper\n{{method( prop=hashValue )}}  Hash\n```\n\nThe value returned up by a KeyLookup depends on what the [can-stache.key] looks like, and\nwhat expression type the KeyLookup is within.\n\nFor example, `{{method(~./key)}}` will call `method` with\na [can-compute.computed compute] that looks up the value of `key` only in the top of the [can-view-scope scope].\n\nThe rules are as follows:\n\n - __call expression arguments__ `{{method(key)}}` - values are passed.\n - __helper expression arguments__ `{{helper key}}` - computes are passed.\n - __hash value in call expression__ `{{method(hash=key)}}` - values are set as property values.\n - __hash value in helper expression__ `{{method hash=key}}` - computes are set as property values.\n - __special operator__ `{{%index}}` - lookup values in a special context provided by some helpers.\n - __compute operator__ `{{method(~key)}}` - pass a compute instead of a value.\n - __at operator__ `{{method(@key}}` - pass a function instead of trying to read the value of the function.\n - __current context__ `{{./key}}` - only lookup key at the top of the scope.\n - __parent context__ `{{../key}}` - lookup the value in the parent context.\n - __context__ `{{.}}` - return the current context/top of the scope.\n\n## Hash expressions\n\nA [can-stache/expressions/hash] specifies a property value on a object argument in a call expression\nand property value on the the hash object in a helper expression's [can-stache.helperOptions] argument.\n\nFor example, in a call expression:\n\n```\nTemplate:\n\t{{methodA(prop=key)}}\n    {{methodB(propX=key propY='literal', propZ=5)}}\nData:\n\t{\n\t  methodA: function(arg){},\n      methodB: function(arg1, arg2),\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: \"value\"}` as `arg`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal'}` as `arg1` and `{propZ: 5}` as `arg2`\n\nIn a helper expression:\n\n```\nTemplate:\n\t{{methodA prop=key}}\n    {{methodB(propX=key propY='literal' propZ=5)}}\nData:\n\t{\n\t  methodA: function(options){},\n      methodB: function(options){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: compute(\"value\")}` as `options.hash`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal', propZ: 5}` as `options.hash`.\n\n## Call expressions\n\nA [can-stache/expressions/call] calls a function looked up in the [can-view-scope scope] followed by\nthe [can-view-scope.Options helpers scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize(type, ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return type+(count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nCall expression arguments are comma (,) separated.  If a Hash expression is an argument,\nan object with the hash properties and values will be passed. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize(word=type count=ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(options){\n\t    return options.word+(options.count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n\n## Helper expressions\n\nA [can-stache/expressions/helper] calls a function looked up in the [can-view-scope.Options helpers scope] followed by\nthe [can-view-scope scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize type ages.length}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return \"data-pluralize\"\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(type, count){\n\t    return type+(count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nHelper expression arguments that are observable are passed a compute.  This is\nin contrast to Call expressions that get passed the value.\n\nHelper expression arguments are space seperated.  If a Hash expression is an argument,\nthe hash properties and values will be added to the helper options object. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize word=type count=ages.length}}</h1>\n\nData:\n\t{\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(helperOptions){\n\t    return helperOptions.hash.type+(helperOptions.hash.count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n## Bracket expressions\n\nA [can-stache/expressions/bracket] can be used to look up a dynamic property in the [can-view-scope scope]. This looks like:\n\n```\nTemplate:\n\t<h1>{{[key]}}</h1>\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tname: \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nThis can be useful for looking up values using keys containing non-alphabetic characters:\n\n```\nTemplate:\n\t<h1>{{[\"person:name\"]}}</h1>\n\nData:\n\t{\n\t\t\"person:name\": \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nBracket expressions can also be used to look up a value in the result of another expression:\n\n```\nTemplate:\n{{getPerson()[key]}}\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tgetPerson: function() {\n\t\t\treturn {\n\t\t\t\tname: \"Kevin\"\n\t\t\t};\n\t\t}\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\n",
    "description": "\nIn addition to different magic tag types, stache supports different expression\ntypes.  These can be used in various combinations to call [can-stache.registerHelper helper methods]\nor [can-component.prototype.ViewModel viewModel methods].  The following is an example of all the expressions\ncombined:\n",
    "name": "can-stache.expressions",
    "title": "Expressions",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 2
  },
  "can-stache/expressions/call": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/call.md"
    },
    "body": "\n\n## Use\n\nA call expression calls a function looked up in the [can-view-scope scope] followed by\nthe [can-view-scope.Options helpers scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize(type,ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return type+(count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nCall expression arguments are comma (,) separated.  If a Hash expression is an argument,\nan object with the hash properties and values will be passed. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize(word=type count=ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(options){\n\t    return options.word+(options.count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Call Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/call",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "{{ method( [EXPRESSION...] ) }}",
        "description": "\n\nCalls `method` with zero or many arguments where each argument\nis a comma separated\n`EXPRESSION`.\n\n```\nmethod(1,key,hashProp=hashValue,call(),helper expression)\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/hash"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be passed as an argument\nto `method`.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/hash"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be passed as an argument\nto `method`.\n\n"
    },
    "comment": " "
  },
  "can-stache/expressions/hash": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/hash.md"
    },
    "body": "\n## Use\n\nA hash expression specifies a property value on a object argument in a call expression\nand property value on the the hash object in a helper expression's [can-stache.helperOptions] argument.\n\nFor example, in a call expression:\n\n```\nTemplate:\n\t{{methodA(prop=key)}}\n    {{methodB(propX=key propY='literal', propZ=5)}}\nData:\n\t{\n\t  methodA: function(arg){},\n      methodB: function(arg1, arg2){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: \"value\"}` as `arg`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal'}` as `arg1` and `{propZ: 5}` as `arg2`\n\nIn a helper expression:\n\n```\nTemplate:\n\t{{methodA prop=key}}\n    {{methodB(propX=key propY='literal' propZ=5)}}\nData:\n\t{\n\t  methodA: function(options){},\n      methodB: function(options){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: compute(\"value\")}` as `options.hash`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal', propZ: 5}` as `options.hash`.\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Hash Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/hash",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "[PROPERTY_NAME=EXPRESSION ]+",
        "description": "\n\nA sequence of one or more property names and their values as another expression like:\n\n```\nprop1=1 prop2=key prop3=callExpression()\n```\n\nIn a [can-stache/expressions/call], `Hash` expressions\ncreate an object argument with the specified `PROPERTY_NAME` properties\nand `EXPRESSION` values.\n\nThe following template:\n\n```js\n{{ method( age=5 first=person.firstName last=person.getLastName() ) }}\n```\n\nMight call `method` with:\n\n```js\n{age: 5, first: \"Justin\", last: \"Meyer\"}\n```\n\nIn a [can-stache/expressions/helper], `Hash` expressions\nadd to the [can-stache.helperOptions]'s `hash` object with the specified `PROPERTY_NAME` properties\nand `EXPRESSION` values.\n\nThe following template:\n\n```js\n{{ method age=5 first=person.firstName last=person.getLastName() }}\n```\n\nMight call `method` with:\n\n```js\n{\n\thash: {age: 5, first: compute(\"Justin\"), last: compute(\"Meyer\")}\n}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "PROPERTY_NAME",
            "description": "The property name on the call expression\nargument object or [can-stache.helperOptions]'s `hash` object.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that provides a\nvalue for the property name.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that provides a\nvalue for the property name.\n"
    },
    "comment": " "
  },
  "can-stache/expressions/helper": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/helper.md"
    },
    "body": "\n## Use\n\nA helpers expression calls a function looked up in the [can-view-scope.Options helpers scope] followed by\nthe [can-view-scope scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize type ages.length}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return \"data-pluralize\"\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(type, count){\n\t    return type+(count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nHelper expression arguments that are observable are passed a compute.  This is\nin contrast to Call expressions that get passed the value.\n\nHelper expression arguments are space seperated.  If a Hash expression is an argument,\nthe hash properties and values will be added to the helper options object. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize word=type count=ages.length}}</h1>\n\nData:\n\t{\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(helperOptions){\n\t    return helperOptions.hash.type+(helperOptions.hash.count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Helper Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/helper",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "method [EXPRESSION...]",
        "description": "\n\nCalls `method` with zero or many arguments where each argument\nis a space separated\n`EXPRESSION`.  \n\n\n\n```\n{{method 1 key call() hashProp=hashValue}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/hash"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be passed as an argument\nto `method`.\n\n\nAll [can-stache/expressions/hash]s will be collectively\nadded to the [can-stache.helperOptions]'s `hash` object.\n\nIf an `EXPRESSION` reads an observable, a\n[can-compute.computed] will be passed to `method`.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/hash"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be passed as an argument\nto `method`.\n\n\nAll [can-stache/expressions/hash]s will be collectively\nadded to the [can-stache.helperOptions]'s `hash` object.\n\nIf an `EXPRESSION` reads an observable, a\n[can-compute.computed] will be passed to `method`.\n\n\n"
    },
    "comment": " "
  },
  "can-stache.helpers.case": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/case.md"
    },
    "body": "\n## Use\n\nThe `case` helper is contextual inside of a [can-stache.helpers.switch] block. The parent switch contains an `expr` that will be matched against the case `expr` and if they are equal the block will be returned.\n\nFor more information on how `{{#case}}` is used check:\n\n- [can-stache.helpers.switch]\n- [can-stache.helpers.default]\n\n",
    "description": "\n",
    "title": "{{#case expression}}",
    "name": "can-stache.helpers.case",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 14,
    "signatures": [
      {
        "code": "{{#case EXPRESSION}}BLOCK{{/case}}",
        "description": "\n\nRenders the `BLOCK` when `EXPRESSION` matches the `EXPRESSION` provided in the parent [can-stache.helpers.switch].\n\n```\n{{#switch user.type}}\n\t{{#case \"admin\"}}\n\t\tPay\n\t{{/case}}\n\t{{#case \"admin\"}}\n\t\t<button/>\n\t{{/case}}\n\t{{#default}}\n\t\tLook at data\n\t{{/default}}\n{{/switch}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression or key that references a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "A subsection that will be rendered if\nthe case `EXPRESSION` matches the switch's `EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "A subsection that will be rendered if\nthe case `EXPRESSION` matches the switch's `EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache/expressions/key-lookup": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/key-lookup.md"
    },
    "body": "\n## Use\n\n\n\nThe value returned up by a KeyLookup depends on what the [can-stache.key] looks like, and\nwhat expression type the KeyLookup is within.\n\nFor example, `{{method(~./key)}}` will call `method` with\na [can-compute.computed compute] that looks up the value of `key` only in the top of the [can-view-scope scope].\n\nThe rules are as follows:\n\n - __[can-stache/expressions/call] arguments__ `{{method(key)}}` - values are passed.\n - __[can-stache/expressions/helper] arguments__ `{{helper key}}` - computes are passed.\n - __hash value in [can-stache/expressions/call]__ `{{method(hash=key)}}` - values are set as property values.\n - __hash value in [can-stache/expressions/helper]__ `{{method hash=key}}` - computes are set as property values.\n - __[can-stache/keys/special special operator]__ `{{%index}}` - lookup values in a special context provided by some helpers.\n - __[can-stache/keys/compute compute operator]__ `{{method(~key)}}` - pass a compute instead of a value.\n - __[can-stache/keys/special at operator]__ `{{method(@key}}` - pass a function instead of trying to read the value of the function.\n - __[can-stache/keys/current current operator]__ `{{./key}}` - only lookup key at the top of the scope.\n - __[can-stache/keys/parent parent operator]__ `{{../key}}` - lookup the value in the parent context.\n - __[can-stache/keys/this context key]__ `{{this}}` - return the current context/top of the scope.\n\n\n## Default key return values by expression and data types\n\nKeys can have slightly different default behavior depending if they are used in:\n\n - [can-stache/expressions/helper helper arguments] like: `{{helper some.key}}`\n\nwhen compared to the other places they are used:\n\n - [can-stache.tags.escaped insertion tags] like: `{{some.key}}`\n - [can-stache/expressions/call call-expression arguments] like: `{{helper(some.key)}}`\n - [can-stache-bindings.event event bindings] like: `($click)=\"method(some.key)\"`\n - [can-stache-bindings data bindings] like: `{some-attr}=\"some.key\"`\n\nFurthermore keys return different values depending on the data type.\n\nIn general:\n\n - Functions are called to get their return value. (Use the [can-stache/keys/at `@` operator] to prevent this).\n - Keys in helper expression arguments that find observable data return\n   a [can-compute.computed] that represents the value.\n - Keys in other expressions return the value.\n - If no observable data is found, the key's value is returned in all expressions.\n\nThe following illustrates what `some.key` would return given\ndifferent data structures as a [can-stache/expressions/helper] and in all other expressions.\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}};\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A non-observable JS object with intermeidate functions:\n{some: function(){ return {key: \"value\"}}}\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A observable can-map\n{some: new Map({key: \"value\"})}\n   // Helper -> canCompute(\"value\")\n   // Other  -> \"value\"\n\n// A method on an observable can-map that reads observables\nvar Some = Map.extend({key: function(){ return this.attr(\"value\")}})\n{some: new Some({value: \"value\"})}\n   // Helper -> canCompute(\"value\")\n   // Other  -> \"value\"\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "KeyLookup Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/key-lookup",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "key",
        "description": "\n\nA [can-stache.key KeyLookup expression] specifies a value in the [can-view-scope scope] or\n[can-view-scope.Options HelperOptions scope] that will be looked up.  KeyLookup expressions\ncan be the entire stache expression like:\n\n```\n{{key}}\n```\n\nOr they can makeup the method, helper, arguments and hash value parts of\n[can-stache/expressions/call],\n[can-stache/expressions/helper], and [can-stache/expressions/hash]s:\n\n```\n{{method(arg1,arg2}}          Call\n{{helper arg1 arg2}}          Helper\n{{method( prop=hashValue )}}  Hash\n```\n",
        "params": []
      },
      {
        "code": "CALL_EXPRESSION.key",
        "description": "\n\nLooks up `key` on the return value of `CALL_EXPRESSION`.\n\n```\n{{#each Todo.getList(complete=completed).value}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A\ncall expression that may or may not return a value.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A property value to look up on\nthe result of `CALL_EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A property value to look up on\nthe result of `CALL_EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache/expressions/literal": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/literal.md"
    },
    "body": "\n\n## Use\n\nLiteral expressions are usually passed as arguments to [can-stache/expressions/call] or [can-stache/expressions/helper]s like:\n\n```js\n{{task.filter(\"completed\", true)}}\n{{pluralize \"dog\" 2}}\n```\n\n",
    "description": "\nSpecify a JavaScript primitive type.\n",
    "type": "typedef",
    "title": "Literal Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/literal",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "\"string\" | 'string'",
        "description": "\n\nSpecifies a string.\n\n```\n{{myHelper( \"this is a string\" )}}\n```\n",
        "params": []
      },
      {
        "code": "\\-[0-9]+\\.?[0-9]*",
        "description": "\n\nSpecifies a number.\n\n```\n{{myHelper( 5.2 )}}\n```\n",
        "params": []
      },
      {
        "code": "null | undefined | true | false",
        "description": "\n\nSpecifies a JavaScript `null`, `undefined`, `true`, or `false` value.\n\n```\n{{myHelper( false )}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache.helpers.default": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/default.md"
    },
    "body": "\n## Use\n\nThe `default` helper is contextual inside of a [can-stache.helpers.switch] block. It acts as a fall-through in case none of the [can-stache.helpers.case] helpers resolved.\n\nFor more information on how `{{#default}}` is used check:\n\n- [can-stache.helpers.switch {{#switch expr}}]\n- [can-stache.helpers.case {{#case expr}}]\n\n",
    "description": "\n",
    "title": "{{#default}}",
    "name": "can-stache.helpers.default",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 15,
    "signatures": [
      {
        "code": "{{#default}}BLOCK{{/default}}",
        "description": "\n\nRenders `BLOCK` if no [can-stache.helpers.case] blocks within the [can-stache.helpers.switch] resolved.\n\n```\n{{#switch user.type}}\n\t{{#case \"admin\"}}\n\t\tPay\n\t{{/case}}\n\t{{#case \"admin\"}}\n\t\t<button/>\n\t{{/case}}\n\t{{#default}}\n\t\tLook at data\n\t{{/default}}\n{{/switch}}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "a template to be rendered.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "a template to be rendered.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.if": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/if.md"
    },
    "body": "\n## Use\n\n`{{#if key}}` provides explicit conditional truthy tests. For example,\n\nThe template:\n\n    {{#if user.isFemale}}\n      {{#if user.isMarried}}\n        Mrs\n      {{/if}}\n      {{#if user.isSingle}}\n        Miss\n      {{/if}}\n    {{/if}}\n\nRendered with:\n\n    {user: {isFemale: true, isMarried: true}}\n\nResults in:\n\n    Mrs\n\nIf can be used with [can-stache.helpers.else {{else}}] too. For example,\n\n    {{#if user.isFemale}}\n      {{#if user.isMarried}}\n        Mrs\n      {{else}}\n        Miss\n      {{/if}}\n    {{/if}}\n\nRendered with:\n\n    {user: {isFemale: true, isMarried: false}}\n\nResults in:\n\n    Miss\n\n",
    "description": "",
    "title": "{{#if expression}}",
    "name": "can-stache.helpers.if",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 2,
    "signatures": [
      {
        "code": "{{#if EXPRESSION}}FN{{else}}INVERSE{{/if}}",
        "description": "\n\nRenders `FN` if `EXPRESSION` is truthy or `INVERSE` if `EXPRESSION`\nis falsey. Both `FN` and `INVERSE` will be rendered with the\ncurrent scope.\n\n```\n{{#if person.isAwake() }} Hello {{/if}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a truthy or falsey value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that can be optionally rendered.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey and [can-stache.helpers.else] is used.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey and [can-stache.helpers.else] is used.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.is": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/is.md"
    },
    "body": "\n\n## Use\n\nThe `is` helper compares expr1 and expr2 and renders the blocks accordingly.\n\n\t{{#is expr1 expr2}}\n\t\t// truthy\n\t{{else}}\n\t\t// falsey\n\t{{/is}}\n\n",
    "description": "\nRender something if two values are equal.\n",
    "title": "{{#is expressions}}",
    "name": "can-stache.helpers.is",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 12,
    "signatures": [
      {
        "code": "{{#is [EXPRESSION...]}}FN{{else}}INVERSE{{/is}}",
        "description": "\n\nRenders the `FN` if every `EXPRESSION` argument is equal (`===`).\n\n```\n{{#is user.type \"admin\"}} <button/> {{else}}  Login {{/is}}\n{{#is task.ownerId task.assignedId user.id }} Delegate! {{/is}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "Two or more expressions whose return values will be tested for equality.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered if each\n`EXPRESSION` argument is equal.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif one of the `EXPRESSION` arguments is not equal to one of the others.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif one of the `EXPRESSION` arguments is not equal to one of the others.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.each": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/each.md"
    },
    "body": "\n## Use\n\nUse the `each` helper to iterate over a array\nof items and render the block between the helper and the slash. For example,\n\nThe template:\n\n    <ul>\n      {{#each friends}}\n        <li>{{name}}</li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    {friends: [{name: \"Austin\"},{name: \"Justin\"}]}\n\nRenders:\n\n    <ul>\n      <li>Austin</li>\n      <li>Justin</li>\n    </ul>\n\n## Object iteration\n\nWhen iterating over [can-map] it will only iterate over the\nmap's [can-map.keys] and none of the hidden properties of a Map. For example,\n\nThe template:\n\n    <ul>\n      {{#each person}}\n        <li>{{.}}</li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    {person: {name: 'Josh', age: 27}}\n\nRenders:\n\n    <ul>\n      <li>Josh</li>\n      <li>27</li>\n    </ul>\n\n## Understanding when to use #each with lists\n\n`{{#each key}}` iteration will do basic diffing and aim to only update the DOM where the change occurred. Whereas\n[can-stache.tags.section] default iteration will re-render the entire section for any change in the list.\n[can-stache.tags.section] iteration is the preferred method to use when a list is replaced or changing significantly.\nWhen doing single list item changes frequently, `{{#each expression}}` iteration is the faster choice.\n\nFor example, assuming \"list\" is a [can-define/list/list] instance:\n\n`{{#each list}}` and `{{#list}}` both iterate through an instance of [can-define/list/list], however we setup the bindings differently.\n\n`{{#each list}}` will setup bindings on every individual item being iterated through, while `{{#list}}` will not. This makes a difference in two scenarios:\n\n1) You have a large list, with minimal updates planned after initial render. In this case, `{{#list}}` might be more advantageous as there will be a faster initial render. However, if any part of the list changes, the entire `{{#list}}` area will be re-processed.\n\n2) You have a large list, with many updates planned after initial render. A grid with many columns of editable fields, for instance. In this case, you many want to use `{{#each list}}`, even though it will be slower on initial render(we're setting up more bindings), you'll have faster updates as there are now many sections.\n\n",
    "description": "\n",
    "title": "{{#each expression}}",
    "name": "can-stache.helpers.each",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 5,
    "signatures": [
      {
        "code": "{{#each EXPRESSION}}FN{{else}}INVERSE{{/each}}",
        "description": "\n\nRender `FN` for each item in `EXPRESSION`'s return value.  If `EXPRESSION`\nis falsey or an empty list, render `INVERSE`.\n\n```\n{{#each todos}}\n  <li>{{name}}</li>\n{{else}}\n  <li>No todos, rest easy!</li>\n{{/each}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An\nexpression that typically returns a list like data structure.\n\nIf the value of the EXPRESSION is a [can-define/list/list] or [can-list], the resulting HTML is updated when the list changes. When a change in the list happens, only the minimum amount of DOM\nelement changes occur.  The list itself can also change, and a [can-util/js/diff/diff]\nwill be performed, which also will perform a minimal set of updates. The [can-stache/keys/special special %key key] is available within `FN`.\n\nIf the value of the key is an object, `FN` will be\ncalled for each property on the object. The [can-stache/keys/special special %key key]\nis available within `FN`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered with each\nitem in `EXPRESSION` or property value in `EXPRESSION`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n"
          }
        ]
      },
      {
        "code": "{{#each EXPRESSION as KEY}}FN{{else}}INVERSE{{/each}}",
        "description": "\n\nLike a normal `{{#each EXPRESSION}}`, but adds each item in `EXPRESSION` as\n`KEY` in `FN`'s [can-view-scope].\n\n```\n{{#each todos as todo}}\n    <li>{{todo.name}}</li>\n{{/each}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An\nexpression that returns a list or object like data structure.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "The name that:\n - each item in `EXPRESSION`'s list, or\n - each property value in `EXPRESSION`'s object\nshould take on in `FN`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered with each\nitem in `EXPRESSION` or property value in `EXPRESSION`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n\n"
    },
    "comment": " "
  },
  "can-stache.helpers.joinBase": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/joinBase.md"
    },
    "body": "\nThe `joinBase` helper is used to create urls within your application for static resources, such as images. An example usage:\n\n    {{joinBase \"hello/\" name \".png\"}}\n\nWhere `name` is a scope value, this might return `http://example.com/app/hello/world.png` if the application is `http://example.com/app`.\n\nThe url to join with is determined by the following factors:\n\n* If attempting to load a relative url, such as `{{joinBase \"../foo.png\"}}` and using StealJS the template's address will be used as a reference to look up the location.\n* If the `can.baseURL` string is set, this will be used.\n* If the `System.baseURL` is set, this will be used.\n* Lastly we fall back to `location.pathname`.\n\n",
    "description": "\n",
    "title": "{{joinBase expressions}}",
    "name": "can-stache.helpers.joinBase",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 16,
    "signatures": [
      {
        "code": "{{joinBase [EXPRESSION...]}}",
        "description": "\n\nReturn an application-relative url for a resource.\n\n```\n{{joinBase \"hello/\" name \".png\"}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "variable": true,
            "description": "Expression or key arguments that reference a value within the current or parent scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "variable": true,
      "description": "Expression or key arguments that reference a value within the current or parent scope.\n"
    },
    "comment": " "
  },
  "can-stache.registerHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/registerHelper.md"
    },
    "body": "\n",
    "description": "Register a helper. \n",
    "title": "registerHelper",
    "name": "can-stache.registerHelper",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerHelper(name, helper)",
        "description": "\n\n\nRegisters a helper function.\nPass the name of the helper followed by the\nfunction to which stache should invoke. See [can-stache.Helpers] for more details on using helpers\nand [can-stache.registerSimpleHelper] to avoid converting computes;\n\n```js\nstache.registerHelper(\"upper\", function(str){\n\tif(str.isComputed) {\n\t\tstr = str();\n\t}\n\treturn str.toUpperCase();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the helper."
          },
          {
            "types": [
              {
                "type": "can-stache.helper"
              }
            ],
            "name": "helper",
            "description": "The helper function.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helper"
        }
      ],
      "name": "helper",
      "description": "The helper function.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.log": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/log.md"
    },
    "body": "",
    "description": "\n",
    "title": "{{log}}",
    "name": "can-stache.helpers.log",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 9,
    "signatures": [
      {
        "code": "{{ log([EXPRESSION]) }}",
        "description": "\n\n`console.log`s the current context or the result of the provided expressions.\n\n```\n{{log}}\n{{ log(person.name, person.age)  }}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "\nArguments to `console.log`.  If none are provided, the current context (the top of the [can-view-scope]) will be logged.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "description": "\nArguments to `console.log`.  If none are provided, the current context (the top of the [can-view-scope]) will be logged.\n"
    }
  },
  "can-stache.registerSimpleHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/registerSimpleHelper.md"
    },
    "body": "\n",
    "description": "Register a helper that gets passed values. \n",
    "title": "registerSimpleHelper",
    "name": "can-stache.registerSimpleHelper",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerSimpleHelper(name, helper)",
        "description": "\n\nRegisters a helper with stache that always returns\nthe arguments value (instead of a compute).\nPass the name of the helper followed by the\nfunction to which Mustache should invoke.\n\nSee [can-stache.Helpers] for more details on using helpers\nand [can-stache.registerHelper] to get computes for observable values.\n\n```js\nstache.registerSimpleHelper(\"upper\", function(str){\n\treturn str.toUpperCase();\n});\n```\n\nSee [can-stache.Helpers] for more details on using helpers.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the helper."
          },
          {
            "types": [
              {
                "type": "can-stache.simpleHelper"
              }
            ],
            "name": "helper",
            "description": "The helper function.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.simpleHelper"
        }
      ],
      "name": "helper",
      "description": "The helper function.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.with": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/with.md"
    },
    "body": "\n\n## Use\n\n`{{#with}}` renders a subsection with a new context added to the [can-view-scope].\nFor example:\n\n```\nTEMPLATE:\n\t{{#with person.address}}\n\t\tStreet: {{street}}\n\t\tCity: {{city}}\n\t{{/with}}\nDATA:\n\t{person: {address: {street: \"123 Evergreen\", city: \"Springfield\"}}}\n\nRESULT:\n\tStreet: 123 Evergreen\n\tCity: Springfield\n```\n\nThe difference between `{{#with}}` and the default [can-stache.tags.section]\nis that the subsection `BLOCK` is rendered no matter what:\n\n```\nTEMPLATE:\n\t{{#with person.address}}\n\t\tStreet: {{street}}\n\t\tCity: {{city}}\n\t{{/with}}\nDATA:\n\t{person: {}}\n\nRESULT:\n\tStreet:\n\tCity:\n```\n\n",
    "description": "\nChanges the context within a block.\n",
    "title": "{{#with expression}}",
    "name": "can-stache.helpers.with",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 6,
    "signatures": [
      {
        "code": "{{#with EXPRESSION}}BLOCK{{/with}}",
        "description": "\n\nRenders `BLOCK` with the result of `EXPRESSION` added to the top of the [can-view-scope].\n\n```\n{{#with person.address}}\n\tStreet: {{street}}\n\tCity: {{city}}\n{{/with}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "A template that is rendered\nwith the context of the `EXPRESSION`'s value.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "A template that is rendered\nwith the context of the `EXPRESSION`'s value.\n"
    },
    "comment": " "
  },
  "can-stache/helpers/route": {
    "src": {
      "path": "node_modules/can-stache/docs/route/route.md"
    },
    "body": "\n",
    "description": "\nAdds stache helpers that use [can-route].\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-stache/helpers/route",
    "parent": "can-core"
  },
  "can-stache.helpers.switch": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/switch.md"
    },
    "body": "\n## Use\n\nThe `switch` helper is used to render a block where one of several cases matches expr. It works just like a JavaScript switch.\n\n\n\t{{#switch page}}\n\n\t\t{{#case \"cart\"}}\n\t\t\t<can-import from=\"cart\">\n\t\t\t\t<cart-page></cart-page>\n\t\t\t</can-import>\n\t\t{{/case}}\n\n\t\t{{#default}}\n\t\t\t<can-import from=\"home\">\n\t\t\t\t<home-page></home-page>\n\t\t\t</can-import>\n\t\t{{/default}}\n\n\t{{/switch}}\n\n",
    "description": "\n",
    "title": "{{#switch expression}}",
    "name": "can-stache.helpers.switch",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 13,
    "signatures": [
      {
        "code": "{{#switch EXPRESSION}}BLOCK{{/switch}}",
        "description": "\n\nRenders the `BLOCK` with contextual [can-stache.helpers.case] and [can-stache.helpers.default] helpers.\n\n```\n{{#switch user.type}}\n\t{{#case \"admin\"}}\n\t\tPay\n\t{{/case}}\n\t{{#case \"admin\"}}\n\t\t<button/>\n\t{{/case}}\n\t{{#default}}\n\t\tLook at data\n\t{{/default}}\n{{/switch}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression or key that references a value that will be switched on.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "a template that is rendered, uses [can-stache.helpers.case] and [can-stache.helpers.default] helpers to match `EXPRESSION`.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "a template that is rendered, uses [can-stache.helpers.case] and [can-stache.helpers.default] helpers to match `EXPRESSION`.\n\n"
    },
    "comment": " "
  },
  "can-stache.helpers.unless": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/unless.md"
    },
    "body": "\n## Use\n\nThe `unless` helper evaluates the inverse of the value\nof the key and renders the block between the helper and the slash.\n\n    {{#unless expr}}\n      // unless\n    {{/unless}}\n\n",
    "description": "\n",
    "title": "{{#unless expression}}",
    "name": "can-stache.helpers.unless",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 4,
    "signatures": [
      {
        "code": "{{#unless EXPRESSION}}FN{{else}}INVERSE{{/unless}}",
        "description": "\n\nRenders `FN` if `EXPRESSION` is falsey or `INVERSE` if `EXPRESSION`\nis truthy. Both `FN` and `INVERSE` will be rendered with the\ncurrent scope.\n\n```\n{{#unless person.isAwake() }} Shhhhh! {{/if}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a truthy or falsey value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that can be optionally rendered.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is truthy and [can-stache.helpers.else] is used.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is truthy and [can-stache.helpers.else] is used.\n"
    },
    "comment": " "
  },
  "can-stache/keys/at": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/at.md"
    },
    "body": "\n\n\n## Use\n\nThe following illustrates what `some@key` would return given\ndifferent data structures:\n\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}}\n   //-> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   //-> function(){ return \"value\"; }\n\n// A non-observable JS object with intermeidate functions:\n{some: function(){ return {key: \"value\"}}}\n   //-> \"value\"\n\n// A observable can-map\n{some: new Map({key: \"value\"})}\n   //-> \"value\"\n\n// A method on an observable can-map that reads observables\nvar Some = Map.extend({key: function(){ return this.attr(\"value\")}})\n{some: new Some({value: \"value\"})}\n   //-> function(){ return this.attr(\"value\")}\n```\n\nWhere `some@key` returns a function, that function is \"bound\" via `.bind(context)`\nto the parent object.  This means that calling the function will\nhave `this` set to what is expected.\n\nIf the AT key is used at the start of a key like:\n\n```\n{{method(@key)}}\n```\n\nThis will return whatever is at the `key` property on the first context in the scope\nto have a non-undefined `key` value.\n\nThe AT key can be used multiple times within a value lookup expression like:\n\n```\n{{method(models@Todo@getList)}}\n```\n\n",
    "description": "\nReturn whatever value is at a key, regardless\nif it's a function or a compute.\n",
    "type": "typedef",
    "title": "@at",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/at",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "@key",
        "description": "\n\nLookup a `key` value in the scope and return whatever is there.\n\n```\n<paginator {next}=\"@loadNext\"/>\n```\n",
        "params": []
      },
      {
        "code": "key@prop",
        "description": "\n\nLookup `prop` property on `key` and return whatever is there.\n\n```\n<grid {get-data}=\"Todo@getList\"/>\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache.helpers.routeCurrent": {
    "src": {
      "path": "node_modules/can-stache/docs/route/routeCurrent.md"
    },
    "body": "\n\n## Use\n\nUse the `routeCurrent` helper like:\n\n```\n<li {{#routeCurrent page=\"recipe\" id=5}}class='active'{{/routeCurrent}}>\n  <a href='{{routeUrl page=\"recipe\" id=5}}'>{{recipe.name}}</a>\n</li>\n```\n\nWith default routes and a url like `#!&page=5&id=5`, this produces:\n\n```\n<li class='active'>\n  <a href='#!&page=5&id=5'>{{recipe.name}}</a>\n</li>\n```\n\nIt this functionality could use call expressions like:\n\n```\n<li {{#routeCurrent(page=\"recipe\" id=5)}}class='active'{{/routeCurrent}}>\n  <a href='{{ routeCurrent(page=\"recipe\" id=5) }}'>{{recipe.name}}</a>\n</li>\n```\n\n\nThe following demo uses `routeCurrent` and [can-stache.helpers.routeUrl] to\ncreate links that update [can-route]'s `page` attribute:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache/route-url.html'></div>\n\n",
    "description": "\nReturns if the hash values match the [can-route]'s current properties.\n",
    "title": "{{#routeCurrent hash}}",
    "name": "can-stache.helpers.routeCurrent",
    "type": "function",
    "parent": "can-stache/helpers/route",
    "signatures": [
      {
        "code": "routeCurrent( hashes... [,subsetMatch] )",
        "description": "\n\n  Calls [can-route.current route.current] with `hashes` and returns the result. This\n  can be used in conjunction with other helpers:\n\n```\n{{linkTo \"Todos\" routeCurrent(page='todos' id=todo.id)}}\n```\n\nOr on its own:\n\n```\n<a class=\"{{#routeCurrent(page='todos',true) }}active{{/routeCurrent}}\">Todos</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "name": "hashes",
            "description": "A hash expression like `page='edit' recipeId=id`.\n"
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If an optional `true` is passed, `routeCurrent` will\nreturn `true` if every value in `hashes` matches the current route data, even if\nthe route data has additional properties that are not matched.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Returns the result of calling [can-route.current route.current].\n"
        }
      },
      {
        "code": "{{#routeCurrent [subsetMatch] hashes...}}FN{{else}}INVERSE{{/routeCurrent}}",
        "description": "\n\nRenders `FN` if the `hashes` passed to [can-route.current route.current] returns `true`.\nRenders the `INVERSE` if [can-route.current route.current] returns `false`.\n\n```\n<a class=\"{{#routeCurrent true page='todos'}}active{{/routeCurrent}}\">Todos</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If an optional `true` is passed, `routeCurrent` will\nreturn `true` if every value in `hashes` matches the current route data, even if\nthe route data has additional properties that are not matched.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "name": "hashes",
            "description": "A hash expression like `page='edit' recipeId=id`.\n\n\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered if the current route matches `hashes`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif the current route does not match `hashes`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The result of `SUBEXPRESSION` or `{{else}}` expression.\n\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The result of `SUBEXPRESSION` or `{{else}}` expression.\n\n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif the current route does not match `hashes`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.routeUrl": {
    "src": {
      "path": "node_modules/can-stache/docs/route/routeUrl.md"
    },
    "body": "\n\n## Use\n\nUse the `routeUrl` helper like:\n\n```\n<a href='{{routeUrl page=\"recipe\" id=5}}'>{{recipe.name}}</a>\n```\n\nThis produces (with no pretty routing rules):\n\n```\n<a href='#!&page=5&id=5'>{{recipe.name}}</a>\n```\n\nIt this functionality could also be written as:\n\n```\n<a href='{{ routeUrl(page=\"recipe\" id=5) }}'>{{recipe.name}}</a>\n```\n\nUsing call expressions/parenthesis lets you pass the `merge` option to `route`.  This\nlets you write a url that only changes specified properties:\n\n```\n<a href='{{ routeUrl(id=5, true) }}'>{{recipe.name}}</a>\n```\n\n\n\n\nThe following demo uses `routeUrl` and [can-stache.helpers.routeCurrent] to\ncreate links that update [can-route]'s `page` attribute:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache/route-url.html'></div>\n\nIt also writes out the current url like:\n\n```\n{{ routeUrl(undefined,true) }}\n```\n\nThis calls `route.url({}, true)` which has the effect of writing out\nthe current url.\n\n",
    "description": "\nReturns a url using [can-route.url route.url].\n",
    "title": "{{routeUrl hashes}}",
    "name": "can-stache.helpers.routeUrl",
    "type": "function",
    "parent": "can-stache/helpers/route",
    "signatures": [
      {
        "code": "routeUrl( hashes... [,merge] )",
        "description": "\n\nCalls [can-route.url] with  `hashes` as it's `data` argument and an\noptional `merge`.\n\nThis can be used on its own to create `<a>` `href`s like:\n\n```\n<a href=\"{{ routeUrl(page='todos' id=todo.id) }}\">details</a>\n```\n\nOr in conjunction with other helpers:\n\n```\n{{makeLink \"details\" routeUrl(page='todos', true)}}\n```\n",
        "params": []
      },
      {
        "code": "{{routeUrl [merge] hashes... }}",
        "description": "\n\nPasses the hashes to `route.url` and returns the result.\n\n```\n<a href=\"{{routeUrl page='todos' id=todo.id}}\">details</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Pass `true` to create a url that merges `hashes` into the\ncurrent [can-route] properties.  \n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "optional": true,
            "name": "hashes",
            "variable": true,
            "description": "A hash expression like `page='edit' recipeId=id`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the result of calling `route.url`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/hash"
        }
      ],
      "optional": true,
      "name": "hashes",
      "variable": true,
      "description": "A hash expression like `page='edit' recipeId=id`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the result of calling `route.url`.\n"
    },
    "comment": " "
  },
  "can-stache/keys/compute": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/compute.md"
    },
    "body": "\n\n## Use\n\nThe following illustrates what `~some.key` would return given\ndifferent data structures:\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}}\n   //-> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   //-> \"value\"\n\n// A non-observable JS object with intermediate functions:\n{some: function(){ return {key: \"value\"}}}\n   //-> \"value\"\n\n// A observable can-map\n{some: new DefineMap({key: \"value\"})}\n   //-> canCompute(\"value\")\n\n// A method on an observable can-map that reads observables\nvar Some = DefineMap.extend({\n\tvalue: \"string\",\n\tkey: function(){ return this.value; }\n})\n{some: new Some({value: \"value\"})}\n   //-> compute(function(){ return this.value; })\n```\n\nNotice that `~` should only be used once in a value lookup expression.\n\n",
    "description": "\nPass a compute instead of a value if an observable is found within\n[can-stache/expressions/calls].\n",
    "type": "typedef",
    "title": "~compute",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/compute",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "~key",
        "description": "\n\nThis makes non-helper expression arguments behave similar to helper\nexpression arguments.\n\n```\n{{#each(~todos)}} ... {{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/current": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/current.md"
    },
    "body": "\n\n## Use\n\nSometimes, especially with recursive templates, you want to control which\ncontext is used to lookup.  Adding `./` before the key name will\nonly look up in the current context.\n\nThe following template:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{./last}}\n      {{/children}}\n\nRendered with:\n\n    {\n      first: \"Barry\", last: \"Meyer\",\n      children: [\n        {first: \"Kim\", last: \"Sully\"},\n        {first: \"Justin\"},\n      ]\n    }\n\nWrites out:\n\n    Barry Meyer\n        Kim Sully\n        Justin\n\nNotice that `{{./last}}` returns nothing because there's no `last` property\nin the `{first: \"Justin\"}` object.\n\n",
    "description": "\nLookup a value in only the current context.\n",
    "type": "typedef",
    "title": "./current",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/current",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "./key",
        "description": "\n\nOnly looks up `key` in the current context.  Returns `undefined` if\nnot found.\n\n```\n{{#each todo}}\n  <input {($checked)}=\"./complete\"/> {{./name}}\n{{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/parent": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/parent.md"
    },
    "body": "\n\n## Use\n\nAdding `../` before a key will lookup the key starting in the parent\ncontext.  By changing the previous template to:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{../last}}\n      {{/children}}\n\nIt will write out:\n\n    Barry Meyer\n        Kim Meyer\n        Justin Meyer\n\nYou can use `.././last` to lookup `last` _only_ in the parent context.\n\n",
    "description": "\nStart looking for values in the parent context.\n",
    "type": "typedef",
    "title": "../parent",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/parent",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "../key",
        "description": "\n\nLook for values starting in the parent context.\n\n```\n{{#each todos}}\n\t<div class='{{#if ../isEditing(this)}}editing{{/if}}'>\n\t\t{{./name}}\n\t</div>\n{{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache.key": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/key.md"
    },
    "body": "\n\n## Use\n\nA key references a value within the [can-view-scope scope] of a\ntemplate being rendered. In the following example, the\nkey is `name`:\n\n    <h1>{{name}}</h1>\n\nIf this template is rendered with:\n\n    {\n      name: \"Austin\"\n    }\n\nThe template writes out:\n\n    <h1>Austin</h1>\n\nA scope is a collection of multiple contexts. By default, a\nkey walks up the scope to each context until it finds a value. For example,\na template like:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{last}}\n      {{/children}}\n\nRendered with:\n\n    {\n      first: \"Barry\", last: \"Meyer\",\n      children: [\n        {first: \"Kim\", last: \"Sully\"},\n        {first: \"Justin\"},\n      ]\n    }\n\nWrites out:\n\n    Barry Meyer\n        Kim Sully\n        Justin Meyer\n\nWhen `last` is looked up on the `{first: \"Justin\"}` object and not found,\nit will then try to read the parent context's `last` property.  This is\nwhy \"Justin Meyer\" is written out.\n\n",
    "description": "A named reference to a value in the [can-view-scope scope] or [can-view-scope.Options helper scope] in a template.\n\n",
    "type": "typedef",
    "title": "key",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache.key",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "key",
        "description": "\n\nLooks up a value in the [can-view-scope scope] or\n[can-view-scope.Options helper scope].  This results in a\n[can-stache/expressions/key-lookup]. [can-stache/expressions/key-lookup]\nexpressions can provide different values depending on what type of expression they\nare within.  These rules are detailed in [can-stache/expressions/key-lookup].\n\n```\n{{name}}\n{{#canVote(age)}}\n```\n",
        "params": []
      },
      {
        "code": "EXPRESSION.key",
        "description": "\n\nLooks up `key` on the result of a subexpression `EXPRESSION`.\n\n```\n{{person.first.name}}\n{{#if tasks.completed().length}} ... {{/if}}\n```\n",
        "params": []
      },
      {
        "code": "a\\\\.single\\\\.key",
        "description": "\n\nLooks up a value without reading intermediate properties.\n\n\n```\n{{meta\\\\.data}}\n```\n\nThis is deprecated.  If you do have properties with dots in them, use a [can-stache/expressions/bracket Bracket Expression]:\n\n```\n{{[\"meta.data\"]}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/special": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/special.md"
    },
    "body": "\n",
    "description": "\n[can-stache-bindings.can-EVENT Event bindings] and some helpers like [can-stache.helpers.each]\nprovide special values that start with `%` to prevent potential collisions with\nother values.  \n",
    "type": "typedef",
    "title": "%special",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/special",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "%index",
        "description": "\n\nWhen looping over an array, [can-define/list/list], or [can-list], you an use `%index` to write out the index of each property:\n\n    {{#each tasks}}\n      <li>{{%index}} {{name}}</li>\n    {{/each}}\n\nIndexes start at 0.  If you want to start at 1, you can create a helper like:\n\n    stache.registerHelper('%indexNum', function(options){\n      return options.scope.get(\"%index\")+1;\n    })\n\nAnd use it like:\n\n    {{#each task}}\n      <li>{{%indexNum}} {{name}}</li>\n    {{/each}}\n",
        "params": []
      },
      {
        "code": "%key",
        "description": "\n\nLike `%index`, but provides the key value when looping through an object:\n\n```\n{{#each style}}\n   {{%key}}: {{this}}\n{{/each}}\n```\n\n",
        "params": []
      },
      {
        "code": "%element",
        "description": "\n\nIn an event binding, `%element` references the DOM element the event happened on:\n\n```\n<input ($click)=\"doSomething(%element.value)\"/>\n```\n",
        "params": []
      },
      {
        "code": "%event",
        "description": "\n\nIn an event binding, `%event` references the dispatched event object:\n\n```\n<input ($click)=\"doSomething(%event)/>\"\n```\n",
        "params": []
      },
      {
        "code": "%viewModel",
        "description": "\n\nIn an event binding, `%viewModel` references the view model of the current element:\n\n```\n<my-component (closed)=\"doSomething(%viewModel)\"/>\n```\n",
        "params": []
      },
      {
        "code": "%arguments",
        "description": "\n\nIn an event binding, `%arguments` references the arguments passed when the event was dispatched/triggered.\n\n```\n<input ($click)=\"doSomething(%arguments)\"/>\n```\n",
        "params": []
      }
    ]
  },
  "can-stache/keys/this": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/this.md"
    },
    "body": "\n\n## Use\n\n\nTo write out the current context, write `{{.}}` or `{{this}}`. For example,\na template like:\n\n    {{#each names}}{{this}} {{/each}}\n\nWith data like:\n\n    {names: [\"Jan\",\"Mark\",\"Andrew\"]}\n\nWill write out:\n\n    Jan Mark Andrew\n\n",
    "description": "\nWrite out or return the current context.\n",
    "type": "typedef",
    "title": "this",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/this",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "this",
        "description": "\n\nWrites out or returns the current context.\n\n```\n{{#each names}}{{this}} {{/each}}\n{{#each names}}\n\t{{sanitize(this)}}\n{{/each}}\n```\n\n",
        "params": []
      },
      {
        "code": ".",
        "description": "\n\n  The same as writing `this`, but with 3 fewer characters!\n\n  ```\n  {{#each names}}{{.}} {{/each}}\n  {{#each names}}\n  \t{{sanitize(.)}}\n  {{/each}}\n  ```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/variable": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/variable.md"
    },
    "body": "\n\n## Use  \n\nEvery template contains a context which is able to store values\nlocal to the template. Keys with `*` reference variables in that context.\n\nTemplate variables are often used to pass data between\ncomponents. `<component-a>` exports its `propA` value to the\ntemplate variable `*variable`.  This is, in turn, used to update\nthe value of `propB` in `<component-b>`.\n\n```\n<component-a {^prop-a}=\"*variable\"/>\n<component-b {prop-b}=\"*variable\"/>\n```\n\nTemplate variables are global to the template. Similar to JavaScript `var`\nvariables, template variables do not have block level scope.  The following\ndoes not work:\n\n```\n{{#each something}}\n\t<component-a {^prop-a}=\"*variable\"/>\n\t<component-b {prop-b}=\"*variable\"/>\n{{/each}}\n```\n\nTo work around this, an `localContext` helper could be created as follows:\n\n```\nstache.regsiterHelper(\"localContext\", function(options){\n  return options.fn(new Map());\n});\n```\n\nAnd used like:\n\n```\n{{#each something}}\n\t{{#localContext}}\n\t  <component-a {^prop-a}=\"./variable\"/>\n\t  <component-b {prop-b}=\"./variable\"/>\n\t{{/localContext}}\n{{/each}}\n```\n\n",
    "description": "\nStore a variable local to the template.\n",
    "type": "typedef",
    "title": "*variable",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/variable",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "*variable",
        "description": "\n\nA placeholder for a value that is local to the template.\n\n```\n<drivers-licenses {^selected}=\"*selectedDriver\"/>\n<edit-driver {driver}=\"*selectedDriver\"/>\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache.tags.close": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/close.md"
    },
    "body": "",
    "description": "\n",
    "title": "{{/expression}}",
    "name": "can-stache.tags.close",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 4,
    "signatures": [
      {
        "code": "{{/helperKeyOrMethod}}",
        "description": "\n\nEnds a [can-stache.tags.section] block.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "helperKeyOrMethod",
            "description": "A name that matches the opening key, method or helper name. It's also possible to simply write `{{/}}` to end a block.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "helperKeyOrMethod",
      "description": "A name that matches the opening key, method or helper name. It's also possible to simply write `{{/}}` to end a block.\n"
    }
  },
  "can-stache.tags.comment": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/comment.md"
    },
    "body": "\n",
    "description": "A comment that doesn't get inserted into the rendered result. \n",
    "title": "{{!expression}}",
    "name": "can-stache.tags.comment",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 7,
    "signatures": [
      {
        "code": "{{!EXPRESSION}}",
        "description": "\n\nThe comment tag operates similarly to a `<!-- -->` tag in HTML. It exists in your template but never shows up.\n\n```\n{{!getFoo()}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be ignored.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be ignored.\n"
    }
  },
  "can-stache.tags.escaped": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/escaped.md"
    },
    "body": "\n\n## Use\n\nThe following breaks down the behavior of `{{expression}}`.  It groups\nthe behavior of [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s\nbecause their behavior works the same way.  It then details how [can-stache/expressions/helper]s\nwork.\n\n### Key and Call Expressions\n\n`{{key}}` insert data into the template. It most commonly references\nvalues within the current context. For example:\n\nRendering:\n\n    <h1>{{name}}</h1>\n\nWith:\n\n    {name: \"Austin\"}\n\nResults in:\n\n    <h1>Austin</h1>\n\nIf the key value is a String or Number, it is inserted into the template.\nIf it is `null` or `undefined`, nothing is added to the template.\n\n\n### Nested Properties\n\nStache supports nested paths, making it possible to\nlook up properties nested deep inside the current context. For example:\n\nRendering:\n\n    <h1>{{book.author}}</h1>\n\nWith:\n\n    {\n      book: {\n        author: \"Ernest Hemingway\"\n      }\n    }\n\nResults in:\n\n    <h1>Ernest Hemingway</h1>\n\n### Looking up values in parent contexts\n\nSections and block helpers can create their own contexts. If a key's value\nis not found in the current context, it will look up the key's value\nin parent contexts. For example:\n\nRendering:\n\n    {{#chapters}}\n       <li>{{title}} - {{name}}</li>\n    {{chapters}}\n\nWith:\n\n    {\n      title: \"The Book of Bitovi\"\n      chapters: [{name: \"Breakdown\"}]\n    }\n\nResults in:\n\n    <li>The Book of Bitovi - Breakdown</li>\n\n## Helper expressions\n\nThe `{{helper}}` syntax is used to call out to stache [can-stache.helper helper functions] functions\nthat may contain more complex functionality. `helper` is a [can-stache.key key] that must match either:\n\n - a [can-stache.registerHelper registered helper function], or\n - a function in the current or parent [can-stache.scopeAndContext contexts]\n\nThe following example shows both cases.\n\nThe Template:\n\n    <p>{{greeting}} {{user}}</p>\n\nRendered with data:\n\n    {\n      user: function(){ return \"Justin\" }\n    }\n\nAnd a with a registered helper like:\n\n    stache.registerHelper('greeting', function(){\n      return \"Hello\"\n    });\n\nResults in:\n\n    <p>Hello Justin</p>\n\n### Arguments\n\nArguments can be passed from the template to helper function by\nlisting space seperated strings, numbers or other [can-stache.key keys] after the\n`helper` name.  For example:\n\nThe template:\n\n    <p>{{madLib \"Lebron James\" verb 4}}</p>\n\nRendered with:\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements:\n\n    stache.registerHelper('madLib',\n      function(subject, verb, number, options){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n    });\n\nIf an argument `key` value is a [can-map] property, the Observe's\nproperty is converted to a getter/setter [can-compute.computed]. For example:\n\nThe template:\n\n    <p>What! My name is: {{mr user.name}}</p>\n\nRendered with:\n\n    {user: new Map({name: \"Slim Shady\"})}\n\nNeeds the helper to check if name is a function or not:\n\n    stache.registerHelper('mr',function(name){\n      return \"Mr. \"+ (typeof name === \"function\" ?\n                      name():\n                      name)\n    })\n\nThis behavior enables two way binding helpers and is explained in more detail\non the [can-stache.helper helper functions] docs.\n\n### Hash\n\nIf enumerated arguments isn't an appropriate way to configure the behavior\nof a helper, it's possible to pass a hash of key-value pairs to the\n[can-stache.helperOptions helper option argument]'s\nhash object.  Properties and values are specified\nas `hashProperty=hashValue`.  For example:\n\nThe template:\n\n    <p>My {{excuse who=pet how=\"shreded\"}}</p>\n`\nAnd the helper:\n\n    stache.registerHelper(\"excuse\",function(options){\n      return [\"My\",\n        options.hash.who || \"dog\".\n        options.hash.how || \"ate\",\n        \"my\",\n        options.hash.what || \"homework\"].join(\" \")\n    })\n\nRender with:\n\n    {pet: \"cat\"}\n\nResults in:\n\n    <p>My cat shareded my homework</p>\n\n### Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create stache tags that have rich behavior. Read about it\non the [can-stache.helper helper function] page.\n\n",
    "description": "Insert the value of the expression into the output of the template.\n\n",
    "title": "{{expression}}",
    "name": "can-stache.tags.escaped",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 0,
    "signatures": [
      {
        "code": "{{EXPRESSION}}",
        "description": "\n\nGets the value of `EXPRESSION` and inserts the result into the output of the\ntemplate.\n\nIf the expression is clearly of a particular expression type like: `{{myHelper arg}}` or\n`{{myMethod(arg)}}`, that expression's rules will be followed.\n\nAn ambiguous expression type like `{{keyOrHelper}}` will first treat `keyOrHelper`\nas a [can-stache/expressions/key-lookup] and if there is no value in the scope of\n`keyOrHelper`, it will be treated as a [can-stache/expressions/helper].\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "expression",
            "description": "The `expression` can be:\n\n - [can-stache/expressions/literal] - `{{5}}` - Inserts a string representation of the literal.\n - [can-stache/expressions/key-lookup] - `{{key}}` - Looks up the value of `key` in the [can-view-scope].\n - [can-stache/expressions/call] - `{{method()}}` - Calls `method` in the [can-view-scope].\n - [can-stache/expressions/helper] - `{{helper arg}}` - Calls `helper` in the [can-view-scope.Options] and passes it a [can-stache.helperOptions].\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "expression",
      "description": "The `expression` can be:\n\n - [can-stache/expressions/literal] - `{{5}}` - Inserts a string representation of the literal.\n - [can-stache/expressions/key-lookup] - `{{key}}` - Looks up the value of `key` in the [can-view-scope].\n - [can-stache/expressions/call] - `{{method()}}` - Calls `method` in the [can-view-scope].\n - [can-stache/expressions/helper] - `{{helper arg}}` - Calls `helper` in the [can-view-scope.Options] and passes it a [can-stache.helperOptions].\n\n\n"
    },
    "comment": " "
  },
  "can-stache.tags.partial": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/partial.md"
    },
    "body": "\n\n## Use\n\nPartials are templates embedded in other templates.  Partials begin with a greater than sign, like `{{>my_partial}}`.  Partials inherit the calling scope.  \n\n\nPartials render at runtime, so recursive partials are possible but make sure you avoid infinite loops.\n\nPartials are typically registered [can-stache.registerPartial] like:\n\n```\nstache.registerPartial(\"address.stache\", \"<p>{{street}} {{city}}</p>\");\n```\n\nAnd called within another template like:\n\n```\nvar template = stache(\"{{#person.address}} {{>address.stache}} {{/person.address}}\");\n```\n\nWith data like `{person: {address: {street: \"123 Evergreen\", city: \"Chicago\"}}}`,\nrendering `template` would produce:\n\n```\n<p>123 Evergreen Chicago</p>\n```\n\nThe 2nd argument to `{{>key}}` can specify a different context for the partial to be rendered\nwith.  The following example renders the same thing as above:\n\n```\nvar template = stache(\"{{#person}} {{>address.stache address}} {{/person}}\");\n```\n\n\n\n## Functions as partials\n\n`{{>key}}` can be used to call [can-stache.renderer] functions in the scope.  For example:\n\n\n```\nDATA\n\t{\n\t\titem: {name: \"Justin\"},\n\t\tmyPartial: stache(\"{{name}}\")\n\t}\n\nTEMPLATE:\n    {{#item}}{{>myPartial}}{{/item}}\n\nRESULT:\n\tJustin\n```\n\n## Script tags as partials\n\n`{{>key}}` can be used to render the contents of script tags.\n\nFor example, if you've embedded a partial like:\n\n```\n<script type='text/stache' id='todo-stache'>\n  <li>{{name}}</li>\n</script>\n```\n\nThis can be rendered like:\n\n```\n{{#each todos}}{{>todo-stache}}{{/each}}\n```\n\n",
    "description": "\nRender another template within the current template.\n",
    "title": "{{>key}}",
    "name": "can-stache.tags.partial",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 6,
    "signatures": [
      {
        "code": "{{>key [EXPRESSION]}}",
        "description": "\n\nLooks up another template with `key` and renders it with the current scope or\n`EXPRESSION` added on top of the current scope.\n\n```js\nstache.registerPartial(\"address.stache\", \"<p>{{street}} {{city}}</p>\");\nvar template = stache(\"{{#each people}} {{>address.stache address}} {{/each}}\")\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A key used to lookup a\n[can-stache.renderer stache renderer function].   \n\nThe behavior is determined by what the key returns.  \n\nIf the key returns\na `function`, that function is used as the __renderer function__.  The __renderer function__\nis called with the current scope (or a scope modified by `EXPRESSION`) and the\nresult is inserted in place of the magic tag.\n\nIf the key returns a `string`, that string is used as the __renderer function name__.\nIf the key returns `undefined`, the key itself is used as the __renderer function name__.\n\nOnce the __renderer function name__ is known, the __renderer function__ is looked for\nby the same name.  A __renderer function__ is looked for in the following places:\n\n 1. In [can-view-scope.Options]'s `partials` property.\n 2. In partials registered with [can-stache.registerPartial].\n 3. For an element whose `id` matches __renderer function name__.  Its `innerHTML` will be converted to a template.\n\nThe __renderer function__\nis called with the current scope (or a scope modified by `EXPRESSION`) and the\nresult is inserted in place of the magic tag.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "An\noptional expression that adds a new context to the [can-view-scope] the template is\nrendered with.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "description": "An\noptional expression that adds a new context to the [can-view-scope] the template is\nrendered with.\n\n\n"
    },
    "comment": " "
  },
  "can-stache.helpers.else": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/else.md"
    },
    "body": "\n## Use\n\nFor more information on how `{{else}}` is used checkout:\n\n - [can-stache.helpers.if]\n - [can-stache.tags.section]\n\n",
    "description": "\n",
    "title": "{{else}}",
    "name": "can-stache.helpers.else",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 4,
    "signatures": [
      {
        "code": "{{#helper}}BLOCK{{else}}INVERSE{{/helper}}",
        "description": "\n\nCreates an `inverse` block for a [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "A partial stache template\nconverted into a function and set as the [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "INVERSE",
      "description": "A partial stache template\nconverted into a function and set as the [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n"
    },
    "comment": " "
  },
  "can-stache.tags.inverse": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/inverse.md"
    },
    "body": "\n## Use\n\nInverted sections match falsey values. An inverted section\nsyntax is similar to regular sections except it begins with a caret\nrather than a pound. If the value referenced is falsey, the section\nwill render. For example:\n\n\nThe template:\n\n    <ul>\n        {{#friends}}\n            </li>{{name}}</li>\n        {{/friends}}\n        {{^friends}}\n            <li>No friends.</li>\n        {{/friends}}\n    </ul>\n\nAnd data:\n\n    {\n        friends: []\n    }\n\nResults in:\n\n\n    <ul>\n        <li>No friends.</li>\n    </ul>\n\n",
    "description": "Like [can-stache.tags.section], but renders the opposite subsection depending on the type of expression\nor the expression's return value.\n\n",
    "title": "{{^expression}}",
    "name": "can-stache.tags.inverse",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 5,
    "signatures": [
      {
        "code": "{{^EXPRESSION}}FN{{else}}INVERSE{{/key}}",
        "description": "\n\nWorks just like [can-stache.tags.section], but renders `INVERSE`\nwhen it would have rendered the `FN` block and vice-versa.\n\nFor example:\n\n```\n{{^ isOver18(person) }} Can't Vote {{/isOver18}}\n```\n\nRenders `Can't Vote` if `isOver18(person)` returns `falsey`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression type. Behavior depends on the type of expression:\n\n - [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s:\n   - renders `FN` with falsey values and empty lists.\n   - renders `INVERSE` with truthy values or each item in a list.\n - [can-stache/expressions/helper]s: switch the `options.fn` and `options.inverse`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression type. Behavior depends on the type of expression:\n\n - [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s:\n   - renders `FN` with falsey values and empty lists.\n   - renders `INVERSE` with truthy values or each item in a list.\n - [can-stache/expressions/helper]s: switch the `options.fn` and `options.inverse`.\n"
    },
    "comment": " "
  },
  "can-stache.tags.section": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/section.md"
    },
    "body": "\n\n## Use\n\nThe following breaks down the behavior of `{{#expression}}`.  It groups\nthe behavior of [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s\nbecause their behavior works the same way.  It then details how [can-stache/expressions/helper]s\nwork.\n\n\n## KeyLookup and Call expressions\n\nSections contain text blocks and evaluate whether to render it or not.  If\nthe object evaluates to an array it will iterate over it and render the block\nfor each item in the array.  There are four different types of sections.\n\n### Falseys or Empty Arrays\n\nIf the value returns a `false`, `undefined`, `null`, `\"\"` or `[]` we consider\nthat a *falsey* value.\n\nIf the value is falsey, the section will **NOT** render the block.\n\n    {\n      friends: false\n    }\n\n    {{#friends}}\n      Never shown!\n    {{/friends}}\n\n\n### Arrays\n\nIf the value is a non-empty array, sections will iterate over the\narray of items, rendering the items in the block.\n\nFor example, a list of friends will iterate\nover each of those items within a section.\n\n    {\n        friends: [\n            { name: \"Austin\" },\n            { name: \"Justin\" }\n        ]\n    }\n\n    <ul>\n        {{#friends}}\n            <li>{{name}}</li>\n        {{/friends}}\n    </ul>\n\nwould render:\n\n    <ul>\n        <li>Austin</li>\n        <li>Justin</li>\n    </ul>\n\nReminder: Sections will reset the current context to the value for which it is iterating.\nSee the [basics of contexts](#Basics) for more information.\n\n### Truthys\n\nWhen the value is a non-falsey object but not a list, it is considered truthy and will be used\nas the context for a single rendering of the block.\n\n    {\n        friends: { name: \"Jon\" }\n    }\n\n    {{#friends}}\n        Hi {{name}}\n    {{/friends}}\n\nwould render:\n\n    Hi Jon!\n\n## Helper expression\n\n\nA helper like:\n\n```js\nstache.registerHelper('countTo', function(number, options){\n    var out = [];\n    if(number > 0) {\n        for(var i =1; i <= number; i++){\n          var docFrag = options.fn({num: i});\n          out.push( docFrag );\n        }\n        return out;\n    } else {\n        return options.inverse({num: i});\n    }\n});\n```\n\nCould be called like:\n\n```\n<p>\n  {{#countTo number}}\n    {{num}}\n  {{else}}\n    Can't count to {{num}}!\n  {{/countTo}}\n</p>\n```\n\nCalled with data like:\n\n```js\n{number: 3}\n```\n\nProduces:\n\n```\n<p> 1 2 3 </p>\n```\n\nCalled with data like:\n\n```\n{number: -5}\n```\n\nProduces:\n\n```\n<p> Can't count to -5! </p>\n```\n\nNotice how `options` has `.fn` and `.inverse`.\n\n",
    "description": "\nRenders a subsection one or more times depending on the type of expression\nor the expression's return value.\n",
    "title": "{{#expression}}",
    "name": "can-stache.tags.section",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 3,
    "signatures": [
      {
        "code": "{{#KEY_EXPRESSION}}FN{{else}}INVERSE{{/KEY_EXPRESSION}}",
        "description": "\n\nRenders the `FN` or `INVERSE` section one or many times depending on\nthe value in `KEY_EXPRESSION`.\n\nIf `KEY_EXPRESSION` returns an  [can-util/js/is-array-like/is-array-like array like object],\nthe `FN` section will be rendered for each item in the array.  If the array like object is\nempty, the `INVERSE` section will be rendered. The [can-stache.helpers.each] helper\nshould generally be used for observable array-like objects as it has some performance\nadvantages.  \n\n```\n{{#items}}<li>{{name}}</li>{{/items}}\n```\n\nIf `KEY_EXPRESSION` returns a truthy value, the `FN` section will be rendered with\nthe truthy value.\n\nIf `KEY_EXPRESSION` returns a fasley value, the `INVERSE` section will be rendered with\nthe fasley value.\n\n```\n{{#address}} {{street}} {{city}} {{/address}}\n```\n\nThe closing tag can end with `{{/}}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              }
            ],
            "name": "KEY_EXPRESSION",
            "description": "A key expression.\nIf there is no value in the scope of `keyOrHelper`, it will be treated as a [can-stache/expressions/helper]."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n\n"
          }
        ]
      },
      {
        "code": "{{#CALL_EXPRESSION}}FN{{else}}INVERSE{{/CALL_EXPRESSION}}",
        "description": "\n\nWorks like `{{#KEY_EXPRESSION}}`, but uses the return value of\nthe `CALL_EXPRESSION`.\n\n```\n{{#getTasksForPerson(person)}}<li>{{name}}</li>{{/getTasksForPerson}}\n```\n\nTypically, the closing tag only include the method name and not its parameters.\n\nThe closing tag can end with `{{/}}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A function that\nwill be called with any specified arguments."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n\n"
          }
        ]
      },
      {
        "code": "{{#HELPER_EXPRESSION}}FN{{else}}INVERSE{{/HELPER_EXPRESSION}}",
        "description": "\n\nCalls a [can-stache.registerHelper registered helper] or a function in the\n[can-view-scope] with an additional [can-stache.helperOptions] argument\nthat can call the `FN` or `INVERSE` helpers to build the content that\nshould replace these tags.\n\n```\n<p>{{#countTo number}}{{num}}{{/countTo}}</p>\n```\n\nHelpers, with their direct access to subsection renderers and scope\nhave more control over template flow.  However, they are harder to test\nthan methods in the view model or model.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "HELPER_EXPRESSION",
            "description": "Calls a helper method\nor function in the [can-view-scope] with specified arguments."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "INVERSE",
      "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n"
    },
    "comment": " "
  },
  "can-stache.tags.unescaped2": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/unescaped_amp.md"
    },
    "body": "",
    "description": "Insert the unescaped value of the expression into the output of the template.\n\n",
    "title": "{{&key}}",
    "name": "can-stache.tags.unescaped2",
    "type": "function",
    "hide": true,
    "parent": "can-stache.tags",
    "order": 2,
    "signatures": [
      {
        "code": "{{&key}}",
        "description": "\n\nThe `{{&key}}` tag is an alias for [can-stache.tags.unescaped {{{key}}}].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            },
            {
              "type": "*"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        },
        {
          "type": "*"
        }
      ],
      "description": "\n"
    }
  },
  "can-stache.tags.unescaped": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/unescaped.md"
    },
    "body": "\n",
    "description": "Insert the unescaped value of the expression into the output of the template.\n\n",
    "title": "{{{expression}}}",
    "name": "can-stache.tags.unescaped",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 1,
    "signatures": [
      {
        "code": "{{{EXPRESSION}}}",
        "description": "\n\nBehaves just like [can-stache.tags.escaped] but does not\nescape the result.\n\n```js\n<div> {{{ toMarkdown(content) }}} </div>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression whose unescaped result is inserted into the page.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression whose unescaped result is inserted into the page.\n"
    }
  },
  "can-util/dom/ajax/ajax": {
    "name": "can-util/dom/ajax/ajax",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 5,
      "codeLine": 29,
      "path": "node_modules/can-util/dom/ajax/ajax.js"
    },
    "body": "`ajax( settings )` is used to make an asynchronous HTTP (AJAX) request\nsimilar to [http://api.jquery.com/jQuery.ajax/jQuery.ajax]. The example below\nmakes use of [can-util/dom/frag/frag].\n\n        ajax({\n                url: 'http://canjs.com/docs/can.ajax.html',\n                success: function(document) {\n                        var frag = can.frag(document);\n                        return frag.querySelector(\".heading h1\").innerText; //-> ajax\n                }\n        });\n\n \n",
    "description": "",
    "title": "ajax",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "ajax(settings)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "settings",
            "description": "Configuration options for the AJAX request.\nThe list of configuration options is the same as for [jQuery.ajax](http://api.jquery.com/jQuery.ajax/#jQuery-ajax-settings)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that resolves to the data. The Promise instance is abortable and exposes an `abort` method.\n Invoking abort on the Promise instance indirectly rejects it.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "settings",
      "description": "Configuration options for the AJAX request.\nThe list of configuration options is the same as for [jQuery.ajax](http://api.jquery.com/jQuery.ajax/#jQuery-ajax-settings)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that resolves to the data. The Promise instance is abortable and exposes an `abort` method.\n Invoking abort on the Promise instance indirectly rejects it.\n"
    },
    "comment": " "
  },
  "can-util/dom/attr/attr": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr.md"
    },
    "body": "\n",
    "description": "\nA module that makes it easy to access attributes and properties of elements.\n",
    "type": "module",
    "title": "attr",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-util/dom/attr/attr",
    "parent": "can-util/dom"
  },
  "can-util/dom/attr/attr.special.focused": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr-special.focused.md"
    },
    "body": "\n```js\ndomAttr.get(input, \"focused\"); // -> false\n\ndomAttr.set(input, \"focused\", true);\ndomAttr.get(input, \"focused\"); // -> true\n```\n\n\n## One-way binding to set focus\n\nUse `focused` in event bindings to have a way to set focus to an input. In this example we are one-way binding to `focused` to a function that will recompute:\n\n```handlebars\n<input type=\"text\" {$focused}=\"isEditing()\" />\n\n<button></button>\n```\n\n```js\nvar ViewModel = DefineMap.extend({\n\tediting: {\n\t\tvalue: false\n\t},\n\tisEditing: function(){\n\t\treturn this.editing;\n\t}\n});\n\n...\n```\n\nIn this example whenever the `editing` property changes to `true`, `isEditing` will be reevaluated to `true` when will set focus on the input. You can imagine there might be some other use, such as a button, that triggers the editing status to change.\n\n## Two-way binding to focused\n\nAnother scenario is that you would like to know when an element is focused, perhaps to show a message (such as a tooltip) somewhere else in the DOM. The example below two-way binds to a boolean property on the ViewModel. When focus is set, the property is updated.\n\n<div class='demo_wrapper' data-demo-src='demos/can-util/input-focused.html'></div>\n\n",
    "description": "\nSignifies if an element, usually an `<input>` is the focused element on the page.\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "focused",
    "name": "can-util/dom/attr/attr.special.focused",
    "type": "property",
    "parent": "can-util/dom/attr/attr.special",
    "comment": " "
  },
  "can-util/dom/attr/attr.special": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr-special.md"
    },
    "body": "\n```js\nattr.special.foo = {\n\tget: function(){\n\t\treturn this.foo;\n\t},\n\tset: function(val){\n\t\tthis.foo = val;\n\t},\n\taddEventListener: function(){\n\t\t// Listen to this property changing some how\n\t}\n};\n```\n\nCanJS comes with a couple of special properties that can be used in bindings:\n\n* [can-util/dom/attr/attr.special.values]\n* [can-util/dom/attr/attr.special.focused]\n\n",
    "description": "\nAn object used to set up special properties. Each key on `attr.special` is a name of a property/attribute that has special behaviors when being get, set, or bound to.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "special",
    "name": "can-util/dom/attr/attr.special",
    "type": "property",
    "parent": "can-util/dom/attr/attr"
  },
  "can-util/dom/attr/attr.special.values": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr.special.values.md"
    },
    "body": "\n\nBinding to `values` in your [can-stache] template is useful to get a list of the selected values:\n\n```handlebars\n<select multiple {($values)}=\"colors\">\n\t<option value=\"red\">Red</option>\n\t<option value=\"green\">Green</option>\n\t<option value=\"blue\">Blue</option>\n</select>\n```\n\nThis will two-way bind to a \"colors\" property in the ViewModel.\n\n",
    "description": "\nA special property that represents the selected values in a `<select>` element, usually a `<select multiple>`. The special property is needed because the DOM's native `value` property on a multiple select only gives you one of the selected options' values.\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "values",
    "name": "can-util/dom/attr/attr.special.values",
    "type": "property",
    "parent": "can-util/dom/attr/attr.special",
    "comment": " "
  },
  "can-util/dom/child-nodes/child-nodes": {
    "type": "module",
    "name": "can-util/dom/child-nodes/child-nodes",
    "parent": "can-util/dom",
    "src": {
      "line": 0,
      "codeLine": 20,
      "path": "node_modules/can-util/dom/child-nodes/child-nodes.js"
    },
    "body": "",
    "description": "",
    "title": "childNodes",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "childNodes(node)",
        "description": "\n\nGet all of the childNodes of a given node.\n\n```js\nvar stache = require(\"can-stache\");\nvar childNodes = require(\"can-util/child-nodes/child-nodes\");\n\nvar html = \"<div><h1><span></span></h1></div>\";\nvar frag = stache(html)();\n\nconsole.log(childNodes(frag)[0].nodeName); // -> DIV\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "node",
            "description": "The Node that you want child nodes for.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "node",
      "description": "The Node that you want child nodes for.\n"
    }
  },
  "can-util/dom/class-name/class-name": {
    "name": "can-util/dom/class-name/class-name",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 10,
      "codeLine": 23,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "Allows querying and manipulation of classes on HTML elements \n```js\nvar className = require(\"can-util/dom/class-name/class-name\");\n\nvar fooDiv = document.createElement(\"div\");\nclassName.add(fooDiv, \"foo\");\nfooDiv.outerHTML; //-> '<div class=\"foo\"></div>'\n```\n\n",
    "title": "className",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/class-name/class-name.has": {
    "name": "can-util/dom/class-name/class-name.has",
    "type": "function",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 24,
      "codeLine": 39,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.has",
    "signatures": [
      {
        "code": "className.has.call(el, cls)",
        "description": "\n\nDetermine wheter a DOM node has a given class name.\n\n```js\nvar isContainer = className.has.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "true if the element's class attribute contains the token, false otherwise.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "true if the element's class attribute contains the token, false otherwise.\n "
    }
  },
  "can-util/dom/class-name/class-name.add": {
    "type": "function",
    "name": "can-util/dom/class-name/class-name.add",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 40,
      "codeLine": 55,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.add",
    "signatures": [
      {
        "code": "className.add.call(el, cls)",
        "description": "\n\nAdd a class name to a DOM node if it is not already there.\n\n```js\nclassName.add.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "void"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "void"
        }
      ],
      "description": "\n "
    }
  },
  "can-util/dom/class-name/class-name.remove": {
    "type": "function",
    "name": "can-util/dom/class-name/class-name.remove",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 63,
      "codeLine": 78,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.remove",
    "signatures": [
      {
        "code": "className.remove.call(el, cls)",
        "description": "\n\nRemove a class name from a DOM node if it exists on the node\n\n```js\nclassName.remove.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "void"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "void"
        }
      ],
      "description": "\n "
    }
  },
  "can-util/dom/data/data": {
    "name": "can-util/dom/data/data",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 13,
      "codeLine": 23,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "Allows associating data as a key/value pair for a particular DOM Node.\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n```\n\n",
    "title": "data",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/data/data.getCid": {
    "type": "function",
    "name": "can-util/dom/data/data.getCid",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 24,
      "codeLine": 31,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.getCid",
    "signatures": [
      {
        "code": "domData.getCid.call(el)",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The value of the element's unique CID\n\nReturn the previously set unique identifier for the dom node.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The value of the element's unique CID\n\nReturn the previously set unique identifier for the dom node.\n "
    }
  },
  "can-util/dom/data/data.cid": {
    "type": "function",
    "name": "can-util/dom/data/data.cid",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 34,
      "codeLine": 48,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "\nIf a unique cid value has not yet been set for this element, set it \nusing the [can-util/dom/data/data.expando expando] property.  Return the\nunique cid whether or not it is newly set\n \n",
    "description": "",
    "title": "domData.cid",
    "signatures": [
      {
        "code": "domData.cid.call(el)",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The value of the element's unique CID\n\nSet a unique identifier for the dom node, using the \n[can-util/dom/data/data.expando expando] property.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The value of the element's unique CID\n\nSet a unique identifier for the dom node, using the \n[can-util/dom/data/data.expando expando] property.\n"
    },
    "comment": " "
  },
  "can-util/dom/data/data.expando": {
    "name": "can-util/dom/data/data.expando",
    "type": "property",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 51,
      "codeLine": 57,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": " \n",
    "description": "\nThe key in which elements' cids are stored\n",
    "types": [],
    "title": "domData.expando"
  },
  "can-util/dom/data/data.clean": {
    "type": "function",
    "name": "can-util/dom/data/data.clean",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 58,
      "codeLine": 69,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.clean",
    "signatures": [
      {
        "code": "domData.clean.call(el, key)",
        "description": "\n\nRemove data from an element previously added by [can-util/dom/data/data.set set]\n\n```js\ndomData.clean.call(el, \"metadata\");\n```\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/data/data.get": {
    "type": "function",
    "name": "can-util/dom/data/data.get",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 76,
      "codeLine": 88,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.get",
    "signatures": [
      {
        "code": "domData.get.call(el, key)",
        "description": "\n\nGet data that was stored in a DOM Node using the specified `key`.\n\n```js\nvar metadata = domData.get.call(el, \"metadata\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A string used as a unique key for storing data associated with this DOM Node.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A string used as a unique key for storing data associated with this DOM Node.\n "
    }
  },
  "can-util/dom/data/data.set": {
    "name": "can-util/dom/data/data.set",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 93,
      "codeLine": 108,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.set",
    "signatures": [
      {
        "code": "domData.set.call(el, key, value)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "the key to store the value under"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "the value to store under the key\n\nSet data to be associated with a DOM Node using the specified `key`. If data already exists for this key, it will be overwritten.\n\n```js\ndomData.set.call(el, \"metadata\", {\n  foo: \"bar\"\n});\n```\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "the value to store under the key\n\nSet data to be associated with a DOM Node using the specified `key`. If data already exists for this key, it will be overwritten.\n\n```js\ndomData.set.call(el, \"metadata\", {\n  foo: \"bar\"\n});\n```\n "
    }
  },
  "can-util/dom/events/events": {
    "name": "can-util/dom/events/events",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 3,
      "codeLine": 12,
      "path": "node_modules/can-util/dom/events/events.js"
    },
    "body": "",
    "description": "Allows you to listen to a domEvent and special domEvents as well as dispatch domEvents. \n```js\nvar domEvents = require(\"can-util/dom/events/events\");\n```\n\n",
    "title": "events",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/dispatch/dispatch": {
    "type": "module",
    "name": "can-util/dom/dispatch/dispatch",
    "parent": "can-util/dom",
    "src": {
      "line": 2,
      "codeLine": 14,
      "path": "node_modules/can-util/dom/dispatch/dispatch.js"
    },
    "body": "",
    "description": "",
    "title": "dispatch",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "dispatch.call(el, event, args, bubbles)",
        "description": "\n\nDispatch an event on an element.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "An object specifies options applied to this event."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Arguments passed into this event."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "bubbles",
            "defaultValue": "true",
            "description": "Specifies whether this event should bubble (by default it will).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "bubbles",
      "defaultValue": "true",
      "description": "Specifies whether this event should bubble (by default it will).\n"
    }
  },
  "can-util/dom/document/document": {
    "src": {
      "line": 2,
      "codeLine": 22,
      "path": "node_modules/can-util/dom/document/document.js"
    },
    "type": "module",
    "body": "",
    "description": "",
    "title": "document",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/dom/document/document",
    "parent": "can-util/dom",
    "signatures": [
      {
        "code": "document(document)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "document",
            "description": "An optional document-like object \nto set as the context's document\n\nOptionally sets, and returns, the document object for the context.\n\n```js\nvar documentShim = { getElementById() {...} };\nvar domDocument = require(\"can-util/dom/data/data\");\ndomDocument(documentShim);\n\n...\n\ndomDocument().getElementById(\"foo\");\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "document",
      "description": "An optional document-like object \nto set as the context's document\n\nOptionally sets, and returns, the document object for the context.\n\n```js\nvar documentShim = { getElementById() {...} };\nvar domDocument = require(\"can-util/dom/data/data\");\ndomDocument(documentShim);\n\n...\n\ndomDocument().getElementById(\"foo\");\n```\n"
    }
  },
  "can-util/dom/frag/frag": {
    "type": "module",
    "name": "can-util/dom/frag/frag",
    "parent": "can-util/dom",
    "src": {
      "line": 5,
      "codeLine": 36,
      "path": "node_modules/can-util/dom/frag/frag.js"
    },
    "body": "\n\n## Use\n\nContentArrays can be used to combine multiple HTMLElements into a single document fragment.  For example:\n\n    var p = document.createElement(\"p\");\n    p.innerHTML = \"Welcome to <b>CanJS</b>\";\n    var contentArray = [\"<h1>Hi There</h1>\", p];\n    var fragment = frag( contentArray )\n\n`fragment` will be a documentFragment with the following elements:\n\n    <h1>Hi There</h1>\n    <p>Welcome to <b>CanJS</b></p>\n\n \n",
    "description": "\nConvert a String, HTMLElement, documentFragment, or contentArray into a documentFragment.\n",
    "title": "frag",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "frag: function(item, doc)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "HTMLElement"
              },
              {
                "type": "documentFragment"
              },
              {
                "type": "contentArray"
              }
            ],
            "name": "item",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Document"
              }
            ],
            "name": "doc",
            "description": "an optional DOM document in which to build the fragment\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Document"
        }
      ],
      "name": "doc",
      "description": "an optional DOM document in which to build the fragment\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-util/dom/mutate/mutate": {
    "name": "can-util/dom/mutate/mutate",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 87,
      "codeLine": 104,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "Mutate an element by appending, inserting, and removing DOM nodes. Use this so that on the server \"inserted\" will be fired. \n```js\nvar mutate = require(\"can-util/dom/mutate/mutate\");\n\nvar el = document.createElement(\"div\");\n\nel.addEventListener(\"inserted\", function(){\n  console.log(\"Inserted was fired!\");\n});\n\nmutate.appendChild.call(document.body, el);\n```\n\n",
    "title": "mutate",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.appendChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.appendChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 105,
      "codeLine": 110,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "appendChild",
    "signatures": [
      {
        "code": "mutate.appendChild.call(el, child)",
        "description": "\nUsed to append a node to an element and trigger the \"inserted\" event on all of the newly inserted children. Since `mutated` takes an array we convert the child to an array, or in the case of a DocumentFragment we first convert the childNodes to an array and call inserted on those.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.insertBefore": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.insertBefore",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 124,
      "codeLine": 129,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "insertBefore",
    "signatures": [
      {
        "code": "mutate.insertBefore.call(el, ref, child)",
        "description": "\nLike mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"inserted\" event.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.removeChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.removeChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 143,
      "codeLine": 148,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "removeChild",
    "signatures": [
      {
        "code": "mutate.removeChild.call(el, child)",
        "description": "\nLike mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"removed\" event.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.replaceChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.replaceChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 156,
      "codeLine": 161,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "replaceChild",
    "signatures": [
      {
        "code": "mutate.replaceChild.call(el, child)",
        "description": "\nLike mutate.appendChild and mutate.removeChild, used to replace a node with another node and trigger \"removed\" on the removed element and \"inserted\" on the inserted elements.\n ",
        "params": []
      }
    ]
  },
  "can-util/js/assign/assign": {
    "type": "module",
    "name": "can-util/js/assign/assign",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 25,
      "path": "node_modules/can-util/js/assign/assign.js"
    },
    "body": "",
    "description": "",
    "title": "assign",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "assign(target, source)",
        "description": "\n\nA simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.\n\n```js\nvar assign = require(\"can-util/js/assign/assign\");\n\nvar obj = {};\n\nassign(obj, {\n  foo: \"bar\"\n});\n\nconsole.log(obj.foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The destination object. This object's properties will be mutated based on the object provided as `source`."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "The source object whose own properties will be applied to `target`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the `target` argument.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "The source object whose own properties will be applied to `target`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the `target` argument.\n"
    }
  },
  "can-util/js/base-url/base-url": {
    "src": {
      "line": 2,
      "codeLine": 22,
      "path": "node_modules/can-util/js/base-url/base-url.js"
    },
    "type": "module",
    "body": "",
    "description": "",
    "title": "baseUrl",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/base-url/base-url",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "baseUrl(optionalBaseUrlToSet)",
        "description": "\n\nGet and/or set the \"base\" (containing path) of the document.\n\n```js\nvar baseUrl = require(\"can-util/js/base-url/base-url\");\n\nconsole.log(baseUrl());           // -> \"http://localhost:8080\"\nconsole.log(baseUrl(baseUrl() + \"/foo/bar\")); // -> \"http://localhost:8080/foo/bar\"\nconsole.log(baseUrl());           // -> \"http://localhost:8080/foo/bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "setUrl",
            "description": "An optional base url to override reading the base URL from the known path.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the set or computed base URL\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "setUrl",
      "description": "An optional base url to override reading the base URL from the known path.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the set or computed base URL\n"
    }
  },
  "can-util/js/cid/cid": {
    "name": "can-util/js/cid/cid",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 25,
      "path": "node_modules/can-util/js/cid/cid.js"
    },
    "body": "",
    "description": "",
    "title": "cid",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "cid(object, optionalObjectType)",
        "description": "\n\nGet a unique identifier for the object, optionally prefixed by a type name.\n\nOnce set, the unique identifier does not change, even if the type name\nchanges on subsequent calls.\n\n```js\nvar cid = require(\"can-util/js/cid/cid\");\nvar x = {};\nvar y = {};\n\nconsole.log(cid(x, \"demo\")); // -> \"demo1\"\nconsole.log(cid(x, \"prod\")); // -> \"demo1\"\nconsole.log(cid(y));         // -> \"2\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "The object to uniquely identify."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "An optional type name with which to prefix the identifier \n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the unique identifier\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "name",
      "description": "An optional type name with which to prefix the identifier \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the unique identifier\n"
    }
  },
  "can-util/js/deep-assign/deep-assign": {
    "src": {
      "path": "node_modules/can-util/js/deep-assign/deep-assign.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "deepAssign",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/deep-assign/deep-assign",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "deepAssign(target, [ ... sources ])",
        "description": "\n\nAssign properties from a source object to a target object, deeply copying properties that are objects or arrays.\n\n```js\nvar deepAssign = require(\"can-util/js/deep-assign/deep-assign\");\n\nvar dest = deepAssign({}, {\n  obj: {\n\t\tfoo: \"bar\"\n\t}\n}, {\n  arr: [{ hello: \"world\" }]\n});\n\nconsole.log(dest.obj.foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The target object who's properties will be assigned from the source objects."
          },
          {
            "variable": true,
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "Source objects from which properties will be assigned to the `target` object. Sources will be copied deeply; meaning any object or array properties will be traversed and copied (like a clone).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "variable": true,
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "Source objects from which properties will be assigned to the `target` object. Sources will be copied deeply; meaning any object or array properties will be traversed and copied (like a clone).\n"
    }
  },
  "can-util/js/deparam/deparam": {
    "name": "can-util/js/deparam/deparam",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 20,
      "path": "node_modules/can-util/js/deparam/deparam.js"
    },
    "body": "",
    "description": "",
    "title": "deparam",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "deparam(params)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "params",
            "description": "a form-urlencoded string of key-value pairs"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The params formatted into an object\n\nTakes a string of name value pairs and returns a Object literal that represents those params.\n\n```js\nvar deparam = require(\"can-util/js/deparam/deparam\");\n\nconsole.log(JSON.stringify(deparam(\"?foo=bar&number=1234\"))); // -> '{\"foo\" : \"bar\", \"number\": 1234}'\nconsole.log(JSON.stringify(deparam(\"#foo[]=bar&foo[]=baz\"))); // -> '{\"foo\" : [\"bar\", \"baz\"]}'\nconsole.log(JSON.stringify(deparam(\"foo=bar%20%26%20baz\"))); // -> '{\"foo\" : \"bar & baz\"}'\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "params",
      "description": "a form-urlencoded string of key-value pairs"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The params formatted into an object\n\nTakes a string of name value pairs and returns a Object literal that represents those params.\n\n```js\nvar deparam = require(\"can-util/js/deparam/deparam\");\n\nconsole.log(JSON.stringify(deparam(\"?foo=bar&number=1234\"))); // -> '{\"foo\" : \"bar\", \"number\": 1234}'\nconsole.log(JSON.stringify(deparam(\"#foo[]=bar&foo[]=baz\"))); // -> '{\"foo\" : [\"bar\", \"baz\"]}'\nconsole.log(JSON.stringify(deparam(\"foo=bar%20%26%20baz\"))); // -> '{\"foo\" : \"bar & baz\"}'\n```\n"
    }
  },
  "can-util/js/defaults/defaults": {
    "type": "module",
    "name": "can-util/js/defaults/defaults",
    "parent": "can-util/js",
    "src": {
      "line": 1,
      "codeLine": 26,
      "path": "node_modules/can-util/js/defaults/defaults.js"
    },
    "body": "",
    "description": "",
    "title": "defaults",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "defaults(target, [ ... sources])",
        "description": "\n\nMimics [_.defaults](https://lodash.com/docs/4.16.2#defaults). Assigns first level properties in sources from left to\nright if they are not already defined.\n\n```js\nvar defaults = require(\"can-util/js/defaults/defaults\");\n\nvar obj = {a: 1, b: 2};\nvar src = {b: 3, c: 3};\n\nassign(obj, src, {a: 2, d: 4});\n\nconsole.log(obj); // -> {a: 1, b: 2, c: 3, d: 4}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The destination object. This object's properties will be mutated based on the objects provided as [ ... sources]."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "variable": true,
            "name": "sources",
            "description": "The source objects whose own properties will be applied to `target`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the `target` argument.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "variable": true,
      "name": "sources",
      "description": "The source objects whose own properties will be applied to `target`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the `target` argument.\n"
    }
  },
  "warn": {
    "type": "function",
    "name": "warn",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "out",
        "description": "the message\n "
      }
    ],
    "parent": "node_modules/can-util/js/dev/dev.js",
    "src": {
      "line": 4,
      "codeLine": 11,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "body": "",
    "description": "Adds a warning message to the console.\n```\ndev.warn(\"something evil\");\n```\n",
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "out",
      "description": "the message\n "
    }
  },
  "log": {
    "type": "function",
    "name": "log",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "out",
        "description": "the message\n "
      }
    ],
    "parent": "node_modules/can-util/js/dev/dev.js",
    "src": {
      "line": 24,
      "codeLine": 31,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "body": "",
    "description": "Adds a message to the console.\n```\ndev.log(\"hi\");\n```\n",
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "out",
      "description": "the message\n "
    }
  },
  "can-util/js/diff/diff": {
    "type": "module",
    "name": "can-util/js/diff/diff",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 28,
      "path": "node_modules/can-util/js/diff/diff.js"
    },
    "body": "",
    "description": "",
    "title": "diff",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "diff(oldList, newList)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "oldList",
            "description": "the array to diff from"
          },
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "newList",
            "description": "the array to diff to"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a list of Patch objects representing the differences\n\nReturns the difference between two ArrayLike objects (that have nonnegative\ninteger keys and the `length` property) as an array of patch objects.\n\nA patch object returned by this function has the following properties:\n- **index**:  the index of newList where the patch begins\n- **deleteCount**: the number of items deleted from that index in newList\n- **insert**: an Array of items newly inserted at that index in newList\n\n```js\nvar diff = require(\"can-util/js/diff/diff\");\n\nconsole.log(diff([1], [1, 2])); // -> [{index: 1, deleteCount: 0, insert: [2]}]\nconsole.log(diff([1, 2], [1])); // -> [{index: 1, deleteCount: 1, insert: []}]\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ArrayLike"
        }
      ],
      "name": "newList",
      "description": "the array to diff to"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a list of Patch objects representing the differences\n\nReturns the difference between two ArrayLike objects (that have nonnegative\ninteger keys and the `length` property) as an array of patch objects.\n\nA patch object returned by this function has the following properties:\n- **index**:  the index of newList where the patch begins\n- **deleteCount**: the number of items deleted from that index in newList\n- **insert**: an Array of items newly inserted at that index in newList\n\n```js\nvar diff = require(\"can-util/js/diff/diff\");\n\nconsole.log(diff([1], [1, 2])); // -> [{index: 1, deleteCount: 0, insert: [2]}]\nconsole.log(diff([1, 2], [1])); // -> [{index: 1, deleteCount: 1, insert: []}]\n```\n"
    }
  },
  "can-util/js/diff-object/diff-object": {
    "type": "module",
    "name": "can-util/js/diff-object/diff-object",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 28,
      "path": "node_modules/can-util/js/diff-object/diff-object.js"
    },
    "body": "",
    "description": "",
    "title": "diffObject",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "diffObject(oldObject, newObject)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "oldObject",
            "description": "the object to diff from"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "newObject",
            "description": "the object to diff to"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "an array of object-patch objects\n\nFind the differences between two objects, based on properties and values\n\nThe object-patch object format has the following keys:\n- **property**: the property key on the new object\n- **type**:     the type of operation on this property: add, remove, or set\n- **value**:    the new value (if type is \"add\" or \"set\")\n\n```js\nvar diffObject = require(\"can-util/js/diff-object/diff-object\");\n\nconsole.log(diffObject({a: 1, b: 2}, {b: 3, c: 4})); // ->\n  [{property: \"a\", type: \"remove\"},\n   {property: \"b\", type: \"set\": value: 3},\n   {property: \"c\", type: \"add\", \"value\": 4}]\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "newObject",
      "description": "the object to diff to"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "an array of object-patch objects\n\nFind the differences between two objects, based on properties and values\n\nThe object-patch object format has the following keys:\n- **property**: the property key on the new object\n- **type**:     the type of operation on this property: add, remove, or set\n- **value**:    the new value (if type is \"add\" or \"set\")\n\n```js\nvar diffObject = require(\"can-util/js/diff-object/diff-object\");\n\nconsole.log(diffObject({a: 1, b: 2}, {b: 3, c: 4})); // ->\n  [{property: \"a\", type: \"remove\"},\n   {property: \"b\", type: \"set\": value: 3},\n   {property: \"c\", type: \"add\", \"value\": 4}]\n```\n"
    }
  },
  "can-util/js/each/each": {
    "src": {
      "path": "node_modules/can-util/js/each/each.md"
    },
    "body": "",
    "description": "\n",
    "type": "module",
    "title": "each",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/each/each",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "each(elements, callback, context)",
        "description": "\n\nLoop over each element in an Array-Like data structure.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "ArrayLike"
              }
            ],
            "name": "elements",
            "description": ""
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "element"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "key"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "elements"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "the context object\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "ArrayLike"
            }
          ],
          "description": "the orignal array of elements\n\n```js\n var each = require(\"can-util/js/each/each\");\n \n each([2,1,0], function(i) { console.log(this[i]); }, [4,5,6]); // -> 6 \\n 5 \\n 4\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "context",
      "description": "the context object\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "ArrayLike"
        }
      ],
      "description": "the orignal array of elements\n\n```js\n var each = require(\"can-util/js/each/each\");\n \n each([2,1,0], function(i) { console.log(this[i]); }, [4,5,6]); // -> 6 \\n 5 \\n 4\n```\n"
    }
  },
  "can-util/js/global/global": {
    "body": "",
    "description": "",
    "type": "module",
    "title": "global",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/global/global",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "GLOBAL()",
        "description": "\n\nReturns the global that this environment provides. It will be one of:\n\n* **Browser**: `window`\n* **Web Worker**: `self`\n* **Node.js**: `global`\n\n```js\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nvar g = GLOBAL();\n\n// In a browser\nconsole.log(g === window); // -> true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The global object for this JavaScript environment.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The global object for this JavaScript environment.\n"
    }
  },
  "can-util/js/import/import": {
    "type": "module",
    "name": "can-util/js/import/import",
    "parent": "can-util/js",
    "src": {
      "line": 3,
      "codeLine": 21,
      "path": "node_modules/can-util/js/import/import.js"
    },
    "body": "",
    "description": "",
    "title": "import",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "importModule(moduleName, parentName)",
        "description": "\n\n```js\nvar importModule = require(\"can-util/js/import/import\");\n\nimportModule(\"foo.stache\").then(function(){\n  // module was imported\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "moduleName",
            "description": "The module to be imported."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "parentName",
            "description": "A parent module that will be used as a reference for resolving relative module imports."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that will resolve when the module has been imported.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "parentName",
      "description": "A parent module that will be used as a reference for resolving relative module imports."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that will resolve when the module has been imported.\n"
    }
  },
  "can-util/js/is-array-like/is-array-like": {
    "src": {
      "path": "node_modules/can-util/js/is-array-like/is-array-like.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "isArrayLike",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-array-like/is-array-like",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isArrayLike(obj)",
        "description": "\n\nDetermines if an object is \"array like\", meaning it can be looped over. Any object with a `.length` property is array like.\n\n```js\nvar isArrayLike = require(\"can-util/js/is-array-like/is-array-like\");\n\n// Arrays\nconsole.log(isArrayLike([{ foo: \"bar\" }])); // -> true\n\n// Strings\nconsole.log(isArrayLike(\"some string\")); // -> true\n\n// Objects with .length property\nconsole.log(isArrayLike({ length: 11 })); // -> true\n\n// Numbers and Booleans are not.\nconsole.log(isArrayLike(true)); // -> false\nconsole.log(isArrayLike(13)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "Any object type."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True, if the object is similar to an array.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "Any object type."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True, if the object is similar to an array.\n"
    }
  },
  "can-util/js/is-browser-window/is-browser-window": {
    "type": "module",
    "name": "can-util/js/is-browser-window/is-browser-window",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 19,
      "path": "node_modules/can-util/js/is-browser-window/is-browser-window.js"
    },
    "body": "",
    "description": "",
    "title": "isBrowserWindow",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isBrowserWindow()",
        "description": "\n\nReturns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).\n\n```js\nvar isBrowserWindow = require(\"can-util/js/is-browser-window/is-browser-window\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isBrowserWindow()) {\n  console.log(GLOBAL() === window); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the environment is a Browser window.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the environment is a Browser window.\n"
    }
  },
  "can-util/js/is-empty-object/is-empty-object": {
    "type": "module",
    "name": "can-util/js/is-empty-object/is-empty-object",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 27,
      "path": "node_modules/can-util/js/is-empty-object/is-empty-object.js"
    },
    "body": "",
    "description": "",
    "title": "isEmptyObject",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isEmptyObject(obj)",
        "description": "\n\nUsed to determine if an object is an empty object (an object with no enumerable properties) such as `{}`.\n\n```js\nvar isEmptyObject = require(\"can-util/js/is-empty-object/is-empty-object\");\n\nconsole.log(isEmptyObject({})); // -> true\n\nconsole.log(isEmptyObject({ a: 1 })); // -> false\n\nvar obj = {};\nObject.defineProperty(obj, \"foo\", {\n    enumerable: false,\n    value: \"bar\"\n});\nconsole.log(isEmptyObject(obj)); // -> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "Any object."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is an object with no enumerable properties.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "Any object."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is an object with no enumerable properties.\n"
    }
  },
  "can-util/js/is-function": {
    "type": "module",
    "name": "can-util/js/is-function",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 18,
      "path": "node_modules/can-util/js/is-function/is-function.js"
    },
    "body": "",
    "description": "\n",
    "title": "/is-function isFunction",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isFunction(value)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "the item to test for being a function"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the provided argument is a function.\n\n```js\nvar isFunction = require(\"can-util/js/is-function/is-function\");\n\nconsole.log(isFunction(function(){})); // -> true\n\nconsole.log(isFunction({})); // -> false\n```\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "the item to test for being a function"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the provided argument is a function.\n\n```js\nvar isFunction = require(\"can-util/js/is-function/is-function\");\n\nconsole.log(isFunction(function(){})); // -> true\n\nconsole.log(isFunction({})); // -> false\n```\n\n"
    }
  },
  "can-util/js/is-node/is-node": {
    "type": "module",
    "name": "can-util/js/is-node/is-node",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 18,
      "path": "node_modules/can-util/js/is-node/is-node.js"
    },
    "body": "",
    "description": "Determines if your code is running in [Node.js](https://nodejs.org). ",
    "title": "isNode",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isNode()",
        "description": "\n\n```js\nvar isNode = require(\"can-util/js/is-node/is-node\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isNode()) {\n  console.log(GLOBAL() === global); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if running in Node.js\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if running in Node.js\n"
    }
  },
  "can-util/js/is-promise/is-promise": {
    "type": "module",
    "name": "can-util/js/is-promise/is-promise",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 21,
      "path": "node_modules/can-util/js/is-promise/is-promise.js"
    },
    "body": "",
    "description": "",
    "title": "isPromise",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isPromise(obj)",
        "description": "\n\nDetermines if object is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar isPromise = require(\"can-util/js/is-promise/is-promise\");\n\nvar promise = new Promise(function(resolve){\n  resolve();\n});\n\nconsole.log(isPromise(promise)); // -> true\nconsole.log(isPromise(\"foo bar\")); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be tested."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be tested."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a Promise.\n"
    }
  },
  "can-util/js/is-promise-like/is-promise-like": {
    "type": "module",
    "name": "can-util/js/is-promise-like/is-promise-like",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 22,
      "path": "node_modules/can-util/js/is-promise-like/is-promise-like.js"
    },
    "body": "",
    "description": "",
    "title": "isPromiseLike",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isPromiseLike(obj)",
        "description": "\n\nDetermines if an object is \"Then-able\".\nAlso see `isPromise(obj)` which checks for a standard [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar isPromiseLike = require(\"can-util/js/is-promise-like/is-promise-like\");\n\nvar promise = new Promise(function(resolve){\n  resolve();\n});\n\nconsole.log(isPromiseLike(promise)); // -> true\nconsole.log(isPromiseLike(\"foo bar\")); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be tested."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be tested."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a Promise.\n"
    }
  },
  "can-util/js/is-string/is-string": {
    "type": "module",
    "name": "can-util/js/is-string/is-string",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 18,
      "path": "node_modules/can-util/js/is-string/is-string.js"
    },
    "body": "",
    "description": "Determines if the provided argument is a string. ",
    "title": "isString",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isString(obj)",
        "description": "\n\n```js\nvar isString = require(\"can-util/js/is-string/is-string\");\n\nconsole.log(isString(\"foo\")); // -> true\nconsole.log(isString(String(\"foo\")); // -> true\n\nconsole.log(isString({})); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "An object to test if is a string."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "An object to test if is a string."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a string.\n"
    }
  },
  "can-util/js/is-web-worker/is-web-worker": {
    "body": "",
    "description": "Determines if the code is running with a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers). ",
    "type": "module",
    "title": "isWebWorker",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-web-worker/is-web-worker",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isWebWorker()",
        "description": "\n\n```js\nvar isWebWorker = require(\"can-util/js/is-web-worker/is-web-worker\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isWebWorker()) {\n  console.log(GLOBAL() === self); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if running in a Web Worker.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if running in a Web Worker.\n"
    }
  },
  "can-util/js/make-array/make-array": {
    "type": "module",
    "name": "can-util/js/make-array/make-array",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 11,
      "path": "node_modules/can-util/js/make-array/make-array.js"
    },
    "body": "",
    "description": "",
    "title": "makeArray",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeArray(arr)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "arr",
            "description": "any array-like object"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a JavaScript array object with the same elements as the passed-in ArrayLike\n\nmakeArray takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ArrayLike"
        }
      ],
      "name": "arr",
      "description": "any array-like object"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a JavaScript array object with the same elements as the passed-in ArrayLike\n\nmakeArray takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array\n"
    }
  },
  "can-util/js/make-promise/make-promise": {
    "name": "can-util/js/make-promise/make-promise",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 20,
      "path": "node_modules/can-util/js/make-promise/make-promise.js"
    },
    "body": "",
    "description": "",
    "title": "makePromise",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makePromise(obj)",
        "description": "\n\nWill make isPromiseLike object into [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar makePromise = require(\"can-util/js/make-promise/make-promise\");\n\nvar obj = {};\nvar promise = makePromise(obj);\n\nconsole.log(isPromise(promise)); // -> true\nconsole.log(isPromise(obj)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be made into Promise."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "the object as a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be made into Promise."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "the object as a Promise.\n"
    }
  },
  "can-util/js/param/param": {
    "type": "module",
    "name": "can-util/js/param/param",
    "parent": "can-util/js",
    "src": {
      "line": 34,
      "codeLine": 54,
      "path": "node_modules/can-util/js/param/param.js"
    },
    "body": "\n",
    "description": "\nSerialize an object into a query string.\n",
    "title": "param",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "param(params)",
        "description": "\n\n  Serializes an object or array into a query string useful for making Ajax requests or the\n  browser. `param` handles nested objects and arrays.  It uses `encodeURIComponent` to\n  escape values and keys.\n\n  ```js\n  param({a: \"b\", c: \"d\"}) //-> \"a=b&c=d\"\n  param({a: [\"X\",\"Y\"]})   //-> \"a[]=X&a[]=Y\"\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "[description]"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "[description]\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "[description]"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "[description]\n"
    }
  },
  "can-util/js/is-plain-object/is-plain-object": {
    "src": {
      "path": "node_modules/can-util/js/is-plain-object/is-plain-object.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "isPlainObject",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-plain-object/is-plain-object",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isPlainObject(obj)",
        "description": "\n\nAttempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:\n\n1. Objects with prototypes (created using the `new` keyword).\n2. Booleans.\n3. Numbers.\n4. NaN.\n\n```js\nvar isPlainObject = require(\"can-util/js/is-plain-object/is-plain-object\");\n\n// Created with {}\nconsole.log(isPlainObject({})); // -> true\n\n// new Object\nconsole.log(isPlainObject(new Object())); // -> true\n\n// Custom object\nvar Ctr = function(){};\nvar obj = new Ctr();\n\nconsole.log(isPlainObject(obj)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-util/js/set-immediate/set-immediate": {
    "type": "module",
    "name": "can-util/js/set-immediate/set-immediate",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 10,
      "path": "node_modules/can-util/js/set-immediate/set-immediate.js"
    },
    "body": "",
    "description": "",
    "title": "setImmediate",
    "signatures": [
      {
        "code": "setImmediate(function())",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "cb",
            "description": "\n\nPolyfill for setImmediate() if it doesn't exist in the global context\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "cb",
      "description": "\n\nPolyfill for setImmediate() if it doesn't exist in the global context\n"
    }
  },
  "can-util/js/join-uris/join-uris": {
    "src": {
      "path": "node_modules/can-util/js/join-uris/join-uris.md"
    },
    "body": "",
    "description": "Join together a URI path to a base. ",
    "type": "module",
    "title": "joinURIs",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/join-uris/join-uris",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "joinURIs(base, href)",
        "description": "\n\nProvides a convenient way to join together URIs handling relative paths.\n\n```js\nvar joinURIs = require(\"can-util/js/join-uris\");\n\nvar base = \"http://example.com/some/long/path\";\nvar href = \"../../images/foo.png\";\n\nvar res = joinURIs(base, href);\n\nconsole.log(res); // -> http://example.com/images/foo.png\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "base",
            "description": ""
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "href",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The result of joining the two parts.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "href",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The result of joining the two parts.\n"
    }
  },
  "can-util/js/string/string": {
    "name": "can-util/js/string/string",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 7,
      "codeLine": 13,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "String utilities used by CanJS libraries \n",
    "title": "string",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/js/string/string.esc": {
    "type": "function",
    "name": "can-util/js/string/string.esc",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 43,
      "codeLine": 49,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.esc",
    "signatures": [
      {
        "code": "string.esc(content)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "content",
            "description": "a string"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the string safely HTML-escaped\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "content",
      "description": "a string"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the string safely HTML-escaped\n "
    }
  },
  "can-util/js/string/string.getObject": {
    "type": "function",
    "name": "can-util/js/string/string.getObject",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 57,
      "codeLine": 87,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.getObject",
    "signatures": [
      {
        "code": "string.getObject(name, roots, add)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "a String of dot-separated keys, representing a path of properties"
          },
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "roots",
            "description": "the object to use as the root for property based navigation"
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "add",
            "description": "if true, add the parts at each step as new objects"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value at the property path descending from `roots`\n\nReturn the result of descending the path `name` through the properties of the object or objects\n`roots`\n\nIf `roots` is an Array, each element of the array is evaluated, in order, until\nthe path is found in an element's properties (and properties-of-properties, etc.).  Otherwise\n`roots` is evaluated as the root object, returning either the object at the property path\ndescended from `roots` or `undefined` if any subpath is not found.\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the first object in `roots`\nif it's an array, `roots` itself otherwise.\n\nIf `add` is `true` and `path` is not found in any roots, a matching path that resolves to an empty object\nis added to the first object in `roots` if `roots` is an array, `roots` itself otherwise.\n\n```js\nvar string = require(\"can-util/js/string/string\");\nconsole.log(string.getObject(\"a.b.c\", {a: {b: {c: \"foo\"}}})); // -> \"foo\"\nconsole.log(string.getObject(\"a.b.c\", {a: {}})); // -> undefined\nconsole.log(string.getObject(\"a.b\", [{a: {}}, {a: {b: \"bar\"}}])); // -> \"bar\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "add",
      "description": "if true, add the parts at each step as new objects"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value at the property path descending from `roots`\n\nReturn the result of descending the path `name` through the properties of the object or objects\n`roots`\n\nIf `roots` is an Array, each element of the array is evaluated, in order, until\nthe path is found in an element's properties (and properties-of-properties, etc.).  Otherwise\n`roots` is evaluated as the root object, returning either the object at the property path\ndescended from `roots` or `undefined` if any subpath is not found.\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the first object in `roots`\nif it's an array, `roots` itself otherwise.\n\nIf `add` is `true` and `path` is not found in any roots, a matching path that resolves to an empty object\nis added to the first object in `roots` if `roots` is an array, `roots` itself otherwise.\n\n```js\nvar string = require(\"can-util/js/string/string\");\nconsole.log(string.getObject(\"a.b.c\", {a: {b: {c: \"foo\"}}})); // -> \"foo\"\nconsole.log(string.getObject(\"a.b.c\", {a: {}})); // -> undefined\nconsole.log(string.getObject(\"a.b\", [{a: {}}, {a: {b: \"bar\"}}])); // -> \"bar\"\n```\n "
    }
  },
  "can-util/js/string/string.capitalize": {
    "type": "function",
    "name": "can-util/js/string/string.capitalize",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 128,
      "codeLine": 141,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.capitalize",
    "signatures": [
      {
        "code": "string.capitalize(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "s",
            "description": "the string to capitalize"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with the first character uppercased if it is a letter\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.capitalize(\"foo\")); // -> \"Foo\"\nconsole.log(string.capitalize(\"123\")); // -> \"123\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "s",
      "description": "the string to capitalize"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with the first character uppercased if it is a letter\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.capitalize(\"foo\")); // -> \"Foo\"\nconsole.log(string.capitalize(\"123\")); // -> \"123\"\n```\n "
    }
  },
  "can-util/js/string/string.camelize": {
    "type": "function",
    "name": "can-util/js/string/string.camelize",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 146,
      "codeLine": 159,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.camelize",
    "signatures": [
      {
        "code": "string.camelize(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "the string to camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with hyphens removed and following letters capitalized.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\nconsole.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "the string to camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with hyphens removed and following letters capitalized.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\nconsole.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n```\n "
    }
  },
  "can-util/js/string/string.hyphenate": {
    "type": "function",
    "name": "can-util/js/string/string.hyphenate",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 165,
      "codeLine": 178,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.hyphenate",
    "signatures": [
      {
        "code": "string.hyphenate(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string in camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with camelCase converted to hyphen-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\nconsole.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "a string in camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with camelCase converted to hyphen-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\nconsole.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n```\n "
    }
  },
  "can-util/js/string/string.underscore": {
    "type": "function",
    "name": "can-util/js/string/string.underscore",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 185,
      "codeLine": 198,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.underscore",
    "signatures": [
      {
        "code": "string.underscore(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string in camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with camelCase converted to underscore-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\nconsole.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "a string in camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with camelCase converted to underscore-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\nconsole.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n```\n "
    }
  },
  "can-util/js/string/string.sub": {
    "type": "function",
    "name": "can-util/js/string/string.sub",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 205,
      "codeLine": 222,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.sub",
    "signatures": [
      {
        "code": "string.sub(str, data, remove)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string with {curly brace} delimited property names"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "an object from which to read properties"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "null"
            }
          ],
          "description": "the supplied string with delimited properties replaced with their values\n                      if all properties exist on the object, null otherwise\n\nIf `remove` is true, the properties found in delimiters in `str` are removed from `data`.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.sub(\"foo_{bar}\", {bar: \"baz\"}})); // -> \"foo_baz\"\nconsole.log(string.sub(\"foo_{bar}\", {})); // -> null\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "data",
      "description": "an object from which to read properties"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "null"
        }
      ],
      "description": "the supplied string with delimited properties replaced with their values\n                      if all properties exist on the object, null otherwise\n\nIf `remove` is true, the properties found in delimiters in `str` are removed from `data`.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.sub(\"foo_{bar}\", {bar: \"baz\"}})); // -> \"foo_baz\"\nconsole.log(string.sub(\"foo_{bar}\", {})); // -> null\n```\n "
    }
  },
  "can-util/js/string/string.strReplacer": {
    "name": "can-util/js/string/string.strReplacer",
    "type": "property",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 241,
      "codeLine": 246,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": " \n",
    "description": "\nThe regex used to find replacement sections in [can-util/js/string/string.sub string.sub]\n",
    "types": [
      {
        "type": "RegExp"
      }
    ],
    "title": "string.strReplacer"
  },
  "can-util/js/string/string.strUndHash": {
    "name": "can-util/js/string/string.strUndHash",
    "type": "property",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 247,
      "codeLine": 252,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": " \n",
    "description": "\nA regex which matches an underscore or hyphen character\n",
    "types": [
      {
        "type": "RegExp"
      }
    ],
    "title": "string.strUndHash"
  },
  "can-util/js/string-to-any/string-to-any": {
    "src": {
      "path": "node_modules/can-util/js/string-to-any/string-to-any.md"
    },
    "body": "",
    "description": "Turns a string representation of a primitive type back into the associated primitive. \n",
    "type": "module",
    "title": "string-to-any",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/string-to-any/string-to-any",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "stringToAny(string)",
        "description": "\n\nExamines the provided string to see if it can be converted to a primitive type. Supported arguments are:\n\n* \"true\"\n* \"false\"\n* \"null\"\n* \"undefined\"\n* \"NaN\"\n* \"Infinity\"\n* Any [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)\n* Any [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)\n\n```js\nstringToAny(\"NaN\"); // -> NaN\nstringToAny(\"44.4\"); // -> 44.4\nstringToAny(\"false\"); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "string",
            "description": "A string to convert back to its primitive type.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The primitive representation of the provided string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "string",
      "description": "A string to convert back to its primitive type.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The primitive representation of the provided string.\n"
    }
  },
  "can-util/js/types/types": {
    "name": "can-util/js/types/types",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 29,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "\n## Use\n\n`can-util/js/types/types` exports an object with placeholder functions that\ncan be used to provide default types or test if something is of a certain type.\n\nThis is where the sausage of loose coupling modules takes place.\nModules that provide a type will overwrite one or multiple of these functions so\nthey take into account the new type.\n\nFor example, `can-define/map/map` might overwrite `isMapLike` to return true\nif the object is an instance of Map:\n\n```js\nvar types = require(\"can-util/js/types/types\");\nvar oldIsMapLike = types.isMapLike;\ntypes.isMapLike = function(obj){\n  return obj instanceof DefineMap || oldIsMapLike.apply(this, arguments);\n};\ntypes.DefaultMap = DefineMap;\n```\n\n",
    "description": "A stateful container for CanJS type information. \n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "comment": " "
  },
  "can-util/js/types/types.isMapLike": {
    "type": "function",
    "name": "can-util/js/types/types.isMapLike",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 32,
      "codeLine": 39,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isMapLike",
    "signatures": [
      {
        "code": "types.isMapLike(obj)",
        "description": "\n  Returns true if `obj` is an observable key-value pair type object.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is map like.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is map like.\n "
    }
  },
  "can-util/js/types/types.isListLike": {
    "type": "function",
    "name": "can-util/js/types/types.isListLike",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 42,
      "codeLine": 49,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isListLike",
    "signatures": [
      {
        "code": "types.isListLike(obj)",
        "description": "\n  Returns true if `obj` is an observable list-type object with numeric keys and a length.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is list like.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is list like.\n "
    }
  },
  "can-util/js/types/types.isPromise": {
    "type": "function",
    "name": "can-util/js/types/types.isPromise",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 52,
      "codeLine": 59,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isPromise",
    "signatures": [
      {
        "code": "types.isPromise(obj)",
        "description": "\n  Returns true if `obj` is a Promise.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is a Promise.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is a Promise.\n "
    }
  },
  "can-util/js/types/types.isConstructor": {
    "type": "function",
    "name": "can-util/js/types/types.isConstructor",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 62,
      "codeLine": 69,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isConstructor",
    "signatures": [
      {
        "code": "types.isConstructor(obj)",
        "description": "\n  Returns true if `obj` looks like a constructor function to be called with `new`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is a constructor function.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is a constructor function.\n "
    }
  },
  "can-util/js/types/types.isCallableForValue": {
    "type": "function",
    "name": "can-util/js/types/types.isCallableForValue",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 81,
      "codeLine": 88,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isCallableForValue",
    "signatures": [
      {
        "code": "types.isConstructor(obj)",
        "description": "\n  Returns true if `obj` looks like a function that should be read to get a value.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object should be called for a value.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object should be called for a value.\n "
    }
  },
  "can-util/js/types/types.isCompute": {
    "type": "function",
    "name": "can-util/js/types/types.isCompute",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 91,
      "codeLine": 98,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isCompute",
    "signatures": [
      {
        "code": "types.isCompute(obj)",
        "description": "\n  Returns true if `obj` is a [can-compute].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is a [can-compute].\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is a [can-compute].\n "
    }
  },
  "can-util/js/types/types.iterator": {
    "name": "can-util/js/types/types.iterator",
    "type": "property",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 101,
      "codeLine": 107,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Symbol",
        "description": "\n\nUsed to implement an iterable object that can be used with [can-util/js/each/each]. In browsers that support for/of this will be Symbol.iterator; in older browsers it will be a string, but is still useful with [can-util/js/each/each].\n "
      }
    ],
    "title": "iterator"
  },
  "can-util/js/types/types.DefaultMap": {
    "name": "can-util/js/types/types.DefaultMap",
    "type": "property",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 108,
      "codeLine": 116,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Map",
        "description": "\n\n  The default map type to create if a map is needed.  If both [can-map] and [can-define/map/map]\n  are imported, the default type will be [can-define/map/map].\n "
      }
    ],
    "title": "DefaultMap"
  },
  "can-util/js/types/types.DefaultList": {
    "name": "can-util/js/types/types.DefaultList",
    "type": "property",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 117,
      "codeLine": 125,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "can-connect.List",
        "description": "\n\n  The default list type to create if a list is needed. If both [can-list] and [can-define/list/list]\n  are imported, the default type will be [can-define/list/list].\n "
      }
    ],
    "title": "DefaultList"
  },
  "can-util/js/types/types.wrapElement": {
    "body": "",
    "description": "",
    "title": "wrapElement",
    "name": "can-util/js/types/types.wrapElement",
    "type": "function",
    "signatures": [
      {
        "code": "types.wrapElement(element)",
        "description": "\n  Wraps an element into an object useful by DOM libraries ala jQuery.\n",
        "params": [
          {
            "types": [
              {
                "type": "Node"
              }
            ],
            "name": "element",
            "description": "Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A wrapped object.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Node"
        }
      ],
      "name": "element",
      "description": "Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A wrapped object.\n "
    }
  },
  "can-util/js/types/types.queueTask": {
    "type": "function",
    "name": "can-util/js/types/types.queueTask",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 134,
      "codeLine": 140,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "queueTask",
    "signatures": [
      {
        "code": "types.queueTask(task)",
        "description": "\n  Run code that will be queued at the end of the current batch.",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "task",
            "description": "\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "task",
      "description": "\n "
    }
  },
  "can-util/js/types/types.unwrapElement": {
    "type": "function",
    "name": "can-util/js/types/types.unwrapElement",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 147,
      "codeLine": 155,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "unwrapElement",
    "signatures": [
      {
        "code": "types.unwrapElement(object)",
        "description": "\n  Unwraps an object that contains an element within.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "Any object that can be unwrapped into a Node."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Node"
            }
          ],
          "description": "A Node.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "object",
      "description": "Any object that can be unwrapped into a Node."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Node"
        }
      ],
      "description": "A Node.\n "
    }
  },
  "can-zone/debug.DebugInfo": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/debuginfo.md"
    },
    "body": "",
    "description": "An array of objects containing information useful for debugging. Gives you the name of the **task** that failed to complete and a **stack** trace of where the error occured. \nEach object has a shape of:\n\n```js\n{\n\t\"task\": \"setTimeout\",\n\t\"stack\": Error ....\"\n}\n```\n\n",
    "type": "typedef",
    "title": "DebugInfo",
    "types": [
      {
        "type": "Array",
        "template": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ],
        "options": [
          {
            "name": "task",
            "description": "An identifier of the task that failed to complete. This can be any of the [asynchronous tasks](https://github.com/canjs/can-zone#tasks) supported by can-zone like `setTimeout` or `Promise`.\n\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "stack",
            "description": "A stack trace taken as a snapshot when the task was called. This allows you t see the source of the call to help debug why the task never completed.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/debug.DebugInfo",
    "parent": "can-zone/debug"
  },
  "can-zone/timeout": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/timeout.md"
    },
    "body": "\n## Use\n\nThe timeout zone allows you to specify a timeout for your Zone. If the Zone promise doesn't resolve before timing out, the Zone promise will be rejected by the plugin.\n\nThe **timeout** zone is a function that takes a timeout in milliseconds.\n\nThe Promise will reject with a special type of Error, a [can-zone/timeout.TimeoutError].\n\n```js\nvar Zone = require(\"can-zone\");\nvar timeout = require(\"can-zone/timeout\");\nvar TimeoutError = timeout.TimeoutError;\n\nvar zone = new Zone({\n\tplugins: [\n\t\ttimeout(2000)\n\t]\n});\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\n\t}, 5000);\n\n}).then(null, function(err){\n\n\t// err.timeout -> 2000\n\n});\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-zone/timeout",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "ms"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/timeout",
    "parent": "can-zone.plugins",
    "signatures": [
      {
        "code": "timeout(ms)",
        "description": "\n\nCreates a [can-zone.ZoneSpec] that you can use as a plugin for your [can-zone Zone] in order to timeout after a certain length of time (as `ms`).\n\nIf the Zone times out it's [can-zone.prototype.run run promise] will be rejected with a [can-zone/timeout.TimeoutError], a special error that also includes the number of milliseconds waited before timing out.\n\n```js\nvar Zone = require(\"can-zone\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar zone = new Zone({\n\tplugins: [ timeout(5000) ]\n});\n\nzone.run(function(){\n\tsetTimeout(function(){\n\n\t}, 10000); // waiting over 5 sec\n})\n.catch(function(err){\n\t// Called because we exceeded the timeout.\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "ms",
            "description": "The number of milliseconds to wait before timing out the [can-zone Zone].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-zone.ZoneSpec"
            }
          ],
          "description": "A ZoneSpec that can be passed as a plugin.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "ms",
      "description": "The number of milliseconds to wait before timing out the [can-zone Zone].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        }
      ],
      "description": "A ZoneSpec that can be passed as a plugin.\n"
    },
    "comment": " "
  },
  "can-zone/debug": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/debug.md"
    },
    "body": "\n## Use\n\nThe **debug** zone gives you information about which tasks failed to complete in case of a timeout. It is to be used with [./timeout.md](can-zone/timeout).\n\nWhen a timeout occurs the debug Zone will appending debug information to the Zone's [data](https://github.com/canjs/can-zone/blob/master/docs/data.md) property, which can be retrieved when the Zone's promise is rejected:\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nvar zone = new Zone(debug(5000);\n\nzone.run(function(){\n\n\tsetTimeout(function(){}, 10000);\n\n}).catch(err){\n\n\tvar debugInfo = zone.data.debugInfo;\n\n});\n```\n\n## DebugInfo\n\nThe **DebugInfo** is an array of objects that contain information about which tasks failed to complete. Each object has a shape of:\n\n```js\n{\n\t\"task\": \"setTimeout\",\n\t\"stack\": Error ....\"\n}\n```\n\n### DebugInfo[].task\n\nA *string* identifier of the task that failed to complete. This can be any of the [asynchronous tasks](https://github.com/canjs/can-zone#tasks) supported by can-zone like `setTimeout` or `Promise`.\n\n### DebugInfo[].stack\n\nA *string* stack trace taken as a snapshot when the task was called. This allows you t see the source of the call to help debug why the task never completed.\n\n## debug(timeout)\n\nCreate a debug Zone by passing the debug function a timeout in milliseconds:\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nnew Zone({\n\tplugins: [\n\t\tdebug(5000)\n\t]\n});\n```\n\n## debug(timeoutZone)\n\nCreate a debug Zone by passing in a timeout Zone that was already created:\n\n```js\nvar timeout = require(\"can-zone/timeout\");\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nvar timeoutZone = timeout(5000);\nvar debugZone = debug(timeoutZone);\n\nnew Zone({\n\tplugins: [\n\t\ttimeoutZone,\n\t\tdebugZone\n\t]\n});\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-zone/debug",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone/debug",
    "parent": "can-zone.plugins",
    "signatures": [
      {
        "code": "debug(ms)",
        "description": "\n\nCreates a new [can-zone.ZoneSpec] that can be provided to your Zone, timing out in `ms` (milliseconds).\n\n```js\nvar Zone = require(\"can-zone\");\nvar debug = require(\"can-zone/debug\");\n\nvar zone = new Zone({\n\tplugins: [debug(5000)]\n})\n.catch(function(err){\n\tvar info = zone.data.debugInfo;\n});\n```\n\nSee the [can-zone/debug.DebugInfo] type for a list of properties \n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "ms",
            "description": "The timeout, in milliseconds, before the [can-zone Zone] will be rejected and debug information attached to the [can-zone.prototype.data zone's data] object.\n"
          }
        ]
      },
      {
        "code": "debug(timeoutZone)",
        "description": "\n\nLike the previous signature, but directly pass it a [can-zone/timeout timeout ZoneSpec] object that you create yourself.\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar timeoutZone = timeout(5000);\nvar debugZone = debug(timeoutZone):\n\n...\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-zone/timeout"
              }
            ],
            "name": "timeoutZone",
            "description": "A [can-zone.ZoneSpec] created using the timeout plugin.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-zone/timeout"
        }
      ],
      "name": "timeoutZone",
      "description": "A [can-zone.ZoneSpec] created using the timeout plugin.\n"
    },
    "comment": " "
  },
  "can-zone/timeout.TimeoutError": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/timeouterror.md"
    },
    "body": "\n",
    "description": "A special type of Error that also includes the number of milliseconds that were waited before timing out. \nThe error object is included with the timeout module:\n\n```js\nvar timeout = require(\"can-zone/timeout\");\n\nvar TimeoutError = timeout.TimeoutError;\n// Maybe use this to check `instanceof`.\n```\n\n",
    "type": "typedef",
    "title": "TimeoutError",
    "types": [
      {
        "type": "Error",
        "options": [
          {
            "name": "timeout",
            "description": "Specifies the timeout that was exceeded.\n",
            "types": [
              {
                "type": "Number"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/timeout.TimeoutError",
    "parent": "can-zone/timeout"
  },
  "can-util/dom/events/attributes/attributes": {
    "type": "module",
    "name": "can-util/dom/events/attributes/attributes",
    "params": [
      {
        "name": "eventName",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 10,
      "codeLine": 31,
      "path": "node_modules/can-util/dom/events/attributes/attributes.js"
    },
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/attributes/attributes\");\nvar el = document.createElement(\"div\");\n\nfunction attributesHandler() {\n\tconsole.log(\"attributes event fired\");\n}\n\nevents.addEventListener.call(el, \"attributes\", attributesHandler, false);\n\nevents.removeEventListener.call(el, \"attributes\", attributesHandler);\n```\n\n",
    "description": "\nAdds a listenable \"attributes\" event to DOM nodes, which fires when\nthe node's attributes change.\n",
    "title": "attributes",
    "types": [
      {
        "type": "events"
      }
    ]
  },
  "can-util/dom/events/delegate/delegate": {
    "type": "module",
    "name": "can-util/dom/events/delegate/delegate",
    "params": [
      {
        "name": "ev",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 15,
      "codeLine": 41,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/delegate/delegate\");\nvar el = document.createElement(\"div\");\nvar sub = document.createElement(\"div\");\nsub.className = \"foo\"\nel.appendChild(sub);\n\nfunction delegateEventsHandler() {\n\tconsole.log(\"delegate event fired\");\n}\n\nevents.addDelegateListener.call(el, \"click\", \".foo\", delegateEventsHandler, false);\n\nevents.removeDelegateListener.call(el, \"click\", \".foo\", delegateEventsHandler);\n```\n\n",
    "description": "\nAdd delegate listeners to DOM events.  Delegated listeners use a selector on an \nancestor element to determine when to fire the event for an item.  This can help \ncases where large numbers of similar DOM nodes are added into a DOM subtree, since\nevent handlers do not have to be attached to each new node.\n",
    "title": "delegateEvents",
    "types": [
      {
        "type": "events"
      }
    ]
  },
  "can-util/dom/events/delegate/delegate.addDelegateListener": {
    "type": "function",
    "name": "can-util/dom/events/delegate/delegate.addDelegateListener",
    "parent": "can-util/dom/events/delegate/delegate",
    "src": {
      "line": 94,
      "codeLine": 107,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "",
    "description": "",
    "title": "events.addDelegateListener",
    "signatures": [
      {
        "code": "events.addDelegateListener(eventType, selector, handler)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of the event to virtually bind to delegates"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "A CSS selector that matches all intended delegates"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The function to call when the event is dispatched\n\nAdd an event as in [can-util/dom/events/events.addEventListener addEventListener] but with a selector\nmatching child nodes (\"delegates\") for which the event should fire.\n\nDelegate events are limited to firing in the bubble phase.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The function to call when the event is dispatched\n\nAdd an event as in [can-util/dom/events/events.addEventListener addEventListener] but with a selector\nmatching child nodes (\"delegates\") for which the event should fire.\n\nDelegate events are limited to firing in the bubble phase.\n"
    }
  },
  "can-util/dom/events/delegate/delegate.removeDelegateListener": {
    "type": "function",
    "name": "can-util/dom/events/delegate/delegate.removeDelegateListener",
    "parent": "can-util/dom/events/delegate/delegate",
    "src": {
      "line": 134,
      "codeLine": 144,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "",
    "description": "",
    "title": "events.removeDelegateListener",
    "signatures": [
      {
        "code": "events.removeDelegateListener(eventType, selector, handler)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of the event to unbind"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "A CSS selector that matches a delegate selector added for this event type"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The function bound as handler when the listener was added\n\nRemove a delegated event added by in [can-util/dom/delegate/delegate.addDelegateListener addDelegateListener] \n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The function bound as handler when the listener was added\n\nRemove a delegated event added by in [can-util/dom/delegate/delegate.addDelegateListener addDelegateListener] \n"
    }
  },
  "can-util/dom/events/inserted/inserted": {
    "src": {
      "line": 2,
      "codeLine": 16,
      "path": "node_modules/can-util/dom/events/inserted/inserted.js"
    },
    "type": "module",
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/inserted/inserted\");\n\nvar foo = document.createElement(\"div\");\nvar log = function() { console.log(\"inserted event fired\"); }\nevents.addEventListener(foo, \"inserted\", log);\n\n",
    "description": " \nThis event fires when nodes are added as descendants of the attached element\n",
    "title": "inserted",
    "types": [
      {
        "type": "events"
      }
    ],
    "name": "can-util/dom/events/inserted/inserted",
    "parent": "can-util/dom/events/events"
  },
  "can-util/dom/events/make-mutation-event/make-mutation-event": {
    "type": "module",
    "name": "can-util/dom/events/make-mutation-event/make-mutation-event",
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 17,
      "codeLine": 29,
      "path": "node_modules/can-util/dom/events/make-mutation-event/make-mutation-event.js"
    },
    "body": "",
    "description": "\n",
    "title": "makeMutationEvent",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeMutationEvent(specialEventNae, mutationNodesProperty)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "specialEventName",
            "description": "the event to handle as a mutation observer-based event"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "mutationNodesProperty",
            "description": "the property of interest in a DOM mutation\n\nThis function provides a simple interface to bind the DOM events interface to the mutation\nobserver interface, by firing an event when a matching mutation is generated by the client\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "mutationNodesProperty",
      "description": "the property of interest in a DOM mutation\n\nThis function provides a simple interface to bind the DOM events interface to the mutation\nobserver interface, by firing an event when a matching mutation is generated by the client\n"
    }
  },
  "can-util/dom/events/removed/removed": {
    "src": {
      "line": 2,
      "codeLine": 17,
      "path": "node_modules/can-util/dom/events/removed/removed.js"
    },
    "type": "module",
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/removed/removed\");\n\nvar foo = document.createElement(\"div\");\nvar log = function() { console.log(\"removed event fired\"); }\nevents.addEventListener(foo, \"removed\", log);\n\n",
    "description": " \nThis event fires when descendant elements of the bound element are detached\nor destroyed.\n",
    "title": "removed",
    "types": [
      {
        "type": "events"
      }
    ],
    "name": "can-util/dom/events/removed/removed",
    "parent": "can-util/dom/events/events"
  }
}